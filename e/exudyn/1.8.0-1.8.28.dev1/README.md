# Comparing `tmp/exudyn-1.8.0-cp39-cp39-win_amd64.whl.zip` & `tmp/exudyn-1.8.28.dev1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,45 +1,53 @@
-Zip file size: 6474802 bytes, number of entries: 43
--rw-rw-rw-  2.0 fat   213433 b- defN 24-Mar-06 10:12 exudyn/FEM.py
--rw-rw-rw-  2.0 fat    43137 b- defN 24-Mar-06 10:12 exudyn/GUI.py
--rw-rw-rw-  2.0 fat     7167 b- defN 24-Mar-06 10:12 exudyn/__init__.py
--rw-rw-rw-  2.0 fat    56668 b- defN 24-Mar-06 10:13 exudyn/__init__.pyi
--rw-rw-rw-  2.0 fat    22678 b- defN 24-Mar-06 10:12 exudyn/advancedUtilities.py
--rw-rw-rw-  2.0 fat    15271 b- defN 24-Mar-06 10:12 exudyn/artificialIntelligence.py
--rw-rw-rw-  2.0 fat    11950 b- defN 24-Mar-06 10:12 exudyn/basicUtilities.py
--rw-rw-rw-  2.0 fat    45052 b- defN 24-Mar-06 10:12 exudyn/beams.py
--rw-rw-rw-  2.0 fat     7370 b- defN 24-Mar-06 10:12 exudyn/demos.py
--rw-rw-rw-  2.0 fat  6461440 b- defN 24-Mar-06 10:16 exudyn/exudynCPP.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  6135296 b- defN 24-Mar-06 10:19 exudyn/exudynCPPfast.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  6460416 b- defN 24-Mar-06 10:22 exudyn/exudynCPPnoAVX.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    85742 b- defN 24-Mar-06 10:12 exudyn/graphicsDataUtilities.py
--rw-rw-rw-  2.0 fat    54811 b- defN 24-Mar-06 10:12 exudyn/interactive.py
--rw-rw-rw-  2.0 fat   175460 b- defN 24-Mar-06 10:12 exudyn/itemInterface.py
--rw-rw-rw-  2.0 fat    32779 b- defN 24-Mar-06 10:12 exudyn/kinematicTree.py
--rw-rw-rw-  2.0 fat    22928 b- defN 24-Mar-06 10:12 exudyn/lieGroupBasics.py
--rw-rw-rw-  2.0 fat    13557 b- defN 24-Mar-06 10:12 exudyn/lieGroupIntegration.py
--rw-rw-rw-  2.0 fat     3165 b- defN 24-Mar-06 10:12 exudyn/machines.py
--rw-rw-rw-  2.0 fat    99682 b- defN 24-Mar-06 10:12 exudyn/mainSystemExtensions.py
--rw-rw-rw-  2.0 fat    10570 b- defN 24-Mar-06 10:12 exudyn/mainSystemInterface.py
--rw-rw-rw-  2.0 fat     6230 b- defN 24-Mar-06 10:12 exudyn/physics.py
--rw-rw-rw-  2.0 fat    51548 b- defN 24-Mar-06 10:12 exudyn/plot.py
--rw-rw-rw-  2.0 fat    73811 b- defN 24-Mar-06 10:12 exudyn/processing.py
--rw-rw-rw-  2.0 fat    14646 b- defN 24-Mar-06 10:12 exudyn/resultsMonitor.py
--rw-rw-rw-  2.0 fat    66510 b- defN 24-Mar-06 10:12 exudyn/rigidBodyUtilities.py
--rw-rw-rw-  2.0 fat    15339 b- defN 24-Mar-06 10:12 exudyn/signalProcessing.py
--rw-rw-rw-  2.0 fat    45326 b- defN 24-Mar-06 10:12 exudyn/solver.py
--rw-rw-rw-  2.0 fat     6494 b- defN 24-Mar-06 10:13 exudyn/symbolic.pyi
--rw-rw-rw-  2.0 fat    67384 b- defN 24-Mar-06 10:12 exudyn/utilities.py
--rw-rw-rw-  2.0 fat      968 b- defN 24-Mar-06 10:12 exudyn/robotics/__init__.py
--rw-rw-rw-  2.0 fat    24528 b- defN 24-Mar-06 10:12 exudyn/robotics/future.py
--rw-rw-rw-  2.0 fat    30272 b- defN 24-Mar-06 10:12 exudyn/robotics/mobile.py
--rw-rw-rw-  2.0 fat    32560 b- defN 24-Mar-06 10:12 exudyn/robotics/models.py
--rw-rw-rw-  2.0 fat    26110 b- defN 24-Mar-06 10:12 exudyn/robotics/motion.py
--rw-rw-rw-  2.0 fat    98196 b- defN 24-Mar-06 10:12 exudyn/robotics/roboticsCore.py
--rw-rw-rw-  2.0 fat    15773 b- defN 24-Mar-06 10:12 exudyn/robotics/rosInterface.py
--rw-rw-rw-  2.0 fat    15827 b- defN 24-Mar-06 10:12 exudyn/robotics/special.py
--rw-rw-rw-  2.0 fat     5174 b- defN 24-Mar-06 10:12 exudyn/robotics/utilities.py
--rw-rw-rw-  2.0 fat     1705 b- defN 24-Mar-06 10:22 exudyn-1.8.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Mar-06 10:22 exudyn-1.8.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 24-Mar-06 10:22 exudyn-1.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3500 b- defN 24-Mar-06 10:22 exudyn-1.8.0.dist-info/RECORD
-43 files, 20580580 bytes uncompressed, 6469376 bytes compressed:  68.6%
+Zip file size: 4314427 bytes, number of entries: 51
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-04 22:24 exudyn-1.8.28.dev1.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-04 22:24 exudyn/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-04 22:24 exudyn.libs/
+-rw-r--r--  2.0 unx     1653 b- defN 24-May-04 22:24 exudyn-1.8.28.dev1.dist-info/METADATA
+-rw-rw-r--  2.0 unx     3968 b- defN 24-May-04 22:24 exudyn-1.8.28.dev1.dist-info/RECORD
+-rw-r--r--  2.0 unx        7 b- defN 24-May-04 22:24 exudyn-1.8.28.dev1.dist-info/top_level.txt
+-rw-r--r--  2.0 unx      148 b- defN 24-May-04 22:24 exudyn-1.8.28.dev1.dist-info/WHEEL
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-04 22:24 exudyn/robotics/
+-rw-r--r--  2.0 unx    14281 b- defN 24-May-04 22:24 exudyn/resultsMonitor.py
+-rw-r--r--  2.0 unx    11667 b- defN 24-May-04 22:24 exudyn/basicUtilities.py
+-rw-r--r--  2.0 unx     6253 b- defN 24-May-04 22:24 exudyn/symbolic.pyi
+-rwxr-xr-x  2.0 unx 12776825 b- defN 24-May-04 22:24 exudyn/exudynCPP.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx    53889 b- defN 24-May-04 22:24 exudyn/interactive.py
+-rw-r--r--  2.0 unx     6121 b- defN 24-May-04 22:24 exudyn/physics.py
+-rw-r--r--  2.0 unx    22381 b- defN 24-May-04 22:24 exudyn/advancedUtilities.py
+-rw-r--r--  2.0 unx    50534 b- defN 24-May-04 22:24 exudyn/plot.py
+-rw-r--r--  2.0 unx    97900 b- defN 24-May-04 22:24 exudyn/mainSystemExtensions.py
+-rw-r--r--  2.0 unx    14982 b- defN 24-May-04 22:24 exudyn/artificialIntelligence.py
+-rw-r--r--  2.0 unx    10405 b- defN 24-May-04 22:24 exudyn/mainSystemInterface.py
+-rw-r--r--  2.0 unx    32180 b- defN 24-May-04 22:24 exudyn/kinematicTree.py
+-rw-r--r--  2.0 unx    66084 b- defN 24-May-04 22:24 exudyn/utilities.py
+-rw-r--r--  2.0 unx    44259 b- defN 24-May-04 22:24 exudyn/beams.py
+-rw-r--r--  2.0 unx    72842 b- defN 24-May-04 22:24 exudyn/processing.py
+-rw-r--r--  2.0 unx    83805 b- defN 24-May-04 22:24 exudyn/graphicsDataUtilities.py
+-rw-r--r--  2.0 unx     7014 b- defN 24-May-04 22:24 exudyn/__init__.py
+-rw-r--r--  2.0 unx     3086 b- defN 24-May-04 22:24 exudyn/machines.py
+-rw-r--r--  2.0 unx    22322 b- defN 24-May-04 22:24 exudyn/lieGroupBasics.py
+-rw-r--r--  2.0 unx   171841 b- defN 24-May-04 22:24 exudyn/itemInterface.py
+-rw-r--r--  2.0 unx    56002 b- defN 24-May-04 22:24 exudyn/__init__.pyi
+-rw-r--r--  2.0 unx    15037 b- defN 24-May-04 22:24 exudyn/signalProcessing.py
+-rw-r--r--  2.0 unx   209587 b- defN 24-May-04 22:24 exudyn/FEM.py
+-rw-r--r--  2.0 unx    65154 b- defN 24-May-04 22:24 exudyn/rigidBodyUtilities.py
+-rw-r--r--  2.0 unx    46904 b- defN 24-May-04 22:24 exudyn/solver.py
+-rw-r--r--  2.0 unx    42144 b- defN 24-May-04 22:24 exudyn/GUI.py
+-rw-r--r--  2.0 unx    13239 b- defN 24-May-04 22:24 exudyn/lieGroupIntegration.py
+-rw-r--r--  2.0 unx     7206 b- defN 24-May-04 22:24 exudyn/demos.py
+-rw-r--r--  2.0 unx     5801 b- defN 24-May-04 22:24 exudyn/robotics/utilities.py
+-rw-r--r--  2.0 unx    15471 b- defN 24-May-04 22:24 exudyn/robotics/rosInterface.py
+-rw-r--r--  2.0 unx    96344 b- defN 24-May-04 22:24 exudyn/robotics/roboticsCore.py
+-rw-r--r--  2.0 unx      944 b- defN 24-May-04 22:24 exudyn/robotics/__init__.py
+-rw-r--r--  2.0 unx    31870 b- defN 24-May-04 22:24 exudyn/robotics/models.py
+-rw-r--r--  2.0 unx    15455 b- defN 24-May-04 22:24 exudyn/robotics/special.py
+-rw-r--r--  2.0 unx    25548 b- defN 24-May-04 22:24 exudyn/robotics/motion.py
+-rw-r--r--  2.0 unx    23971 b- defN 24-May-04 22:24 exudyn/robotics/future.py
+-rw-r--r--  2.0 unx    29720 b- defN 24-May-04 22:24 exudyn/robotics/mobile.py
+-rwxr-xr-x  2.0 unx    13057 b- defN 24-May-04 22:24 exudyn.libs/libXinerama-b7a62e01.so.1.0.0
+-rwxr-xr-x  2.0 unx    25817 b- defN 24-May-04 22:24 exudyn.libs/libXxf86vm-3971cbbb.so.1.0.0
+-rwxr-xr-x  2.0 unx    26345 b- defN 24-May-04 22:24 exudyn.libs/libXfixes-d274cb03.so.3.1.0
+-rwxr-xr-x  2.0 unx    55585 b- defN 24-May-04 22:24 exudyn.libs/libXcursor-1a09904e.so.1.0.2
+-rwxr-xr-x  2.0 unx    47657 b- defN 24-May-04 22:24 exudyn.libs/libXrandr-1b5fae8f.so.2.2.0
+-rwxr-xr-x  2.0 unx   135985 b- defN 24-May-04 22:24 exudyn.libs/libglfw-14630bf2.so.3.2
+51 files, 14579290 bytes uncompressed, 4307883 bytes compressed:  70.5%
```

## zipnote {}

```diff
@@ -1,130 +1,154 @@
-Filename: exudyn/FEM.py
+Filename: exudyn-1.8.28.dev1.dist-info/
 Comment: 
 
-Filename: exudyn/GUI.py
+Filename: exudyn/
 Comment: 
 
-Filename: exudyn/__init__.py
+Filename: exudyn.libs/
 Comment: 
 
-Filename: exudyn/__init__.pyi
+Filename: exudyn-1.8.28.dev1.dist-info/METADATA
 Comment: 
 
-Filename: exudyn/advancedUtilities.py
+Filename: exudyn-1.8.28.dev1.dist-info/RECORD
 Comment: 
 
-Filename: exudyn/artificialIntelligence.py
+Filename: exudyn-1.8.28.dev1.dist-info/top_level.txt
+Comment: 
+
+Filename: exudyn-1.8.28.dev1.dist-info/WHEEL
+Comment: 
+
+Filename: exudyn/robotics/
+Comment: 
+
+Filename: exudyn/resultsMonitor.py
 Comment: 
 
 Filename: exudyn/basicUtilities.py
 Comment: 
 
-Filename: exudyn/beams.py
+Filename: exudyn/symbolic.pyi
 Comment: 
 
-Filename: exudyn/demos.py
+Filename: exudyn/exudynCPP.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
-Filename: exudyn/exudynCPP.cp39-win_amd64.pyd
+Filename: exudyn/interactive.py
 Comment: 
 
-Filename: exudyn/exudynCPPfast.cp39-win_amd64.pyd
+Filename: exudyn/physics.py
 Comment: 
 
-Filename: exudyn/exudynCPPnoAVX.cp39-win_amd64.pyd
+Filename: exudyn/advancedUtilities.py
 Comment: 
 
-Filename: exudyn/graphicsDataUtilities.py
+Filename: exudyn/plot.py
 Comment: 
 
-Filename: exudyn/interactive.py
+Filename: exudyn/mainSystemExtensions.py
 Comment: 
 
-Filename: exudyn/itemInterface.py
+Filename: exudyn/artificialIntelligence.py
 Comment: 
 
-Filename: exudyn/kinematicTree.py
+Filename: exudyn/mainSystemInterface.py
 Comment: 
 
-Filename: exudyn/lieGroupBasics.py
+Filename: exudyn/kinematicTree.py
 Comment: 
 
-Filename: exudyn/lieGroupIntegration.py
+Filename: exudyn/utilities.py
 Comment: 
 
-Filename: exudyn/machines.py
+Filename: exudyn/beams.py
 Comment: 
 
-Filename: exudyn/mainSystemExtensions.py
+Filename: exudyn/processing.py
 Comment: 
 
-Filename: exudyn/mainSystemInterface.py
+Filename: exudyn/graphicsDataUtilities.py
 Comment: 
 
-Filename: exudyn/physics.py
+Filename: exudyn/__init__.py
 Comment: 
 
-Filename: exudyn/plot.py
+Filename: exudyn/machines.py
 Comment: 
 
-Filename: exudyn/processing.py
+Filename: exudyn/lieGroupBasics.py
 Comment: 
 
-Filename: exudyn/resultsMonitor.py
+Filename: exudyn/itemInterface.py
 Comment: 
 
-Filename: exudyn/rigidBodyUtilities.py
+Filename: exudyn/__init__.pyi
 Comment: 
 
 Filename: exudyn/signalProcessing.py
 Comment: 
 
+Filename: exudyn/FEM.py
+Comment: 
+
+Filename: exudyn/rigidBodyUtilities.py
+Comment: 
+
 Filename: exudyn/solver.py
 Comment: 
 
-Filename: exudyn/symbolic.pyi
+Filename: exudyn/GUI.py
 Comment: 
 
-Filename: exudyn/utilities.py
+Filename: exudyn/lieGroupIntegration.py
 Comment: 
 
-Filename: exudyn/robotics/__init__.py
+Filename: exudyn/demos.py
 Comment: 
 
-Filename: exudyn/robotics/future.py
+Filename: exudyn/robotics/utilities.py
 Comment: 
 
-Filename: exudyn/robotics/mobile.py
+Filename: exudyn/robotics/rosInterface.py
+Comment: 
+
+Filename: exudyn/robotics/roboticsCore.py
+Comment: 
+
+Filename: exudyn/robotics/__init__.py
 Comment: 
 
 Filename: exudyn/robotics/models.py
 Comment: 
 
+Filename: exudyn/robotics/special.py
+Comment: 
+
 Filename: exudyn/robotics/motion.py
 Comment: 
 
-Filename: exudyn/robotics/roboticsCore.py
+Filename: exudyn/robotics/future.py
 Comment: 
 
-Filename: exudyn/robotics/rosInterface.py
+Filename: exudyn/robotics/mobile.py
 Comment: 
 
-Filename: exudyn/robotics/special.py
+Filename: exudyn.libs/libXinerama-b7a62e01.so.1.0.0
 Comment: 
 
-Filename: exudyn/robotics/utilities.py
+Filename: exudyn.libs/libXxf86vm-3971cbbb.so.1.0.0
 Comment: 
 
-Filename: exudyn-1.8.0.dist-info/METADATA
+Filename: exudyn.libs/libXfixes-d274cb03.so.3.1.0
 Comment: 
 
-Filename: exudyn-1.8.0.dist-info/WHEEL
+Filename: exudyn.libs/libXcursor-1a09904e.so.1.0.2
 Comment: 
 
-Filename: exudyn-1.8.0.dist-info/top_level.txt
+Filename: exudyn.libs/libXrandr-1b5fae8f.so.2.2.0
 Comment: 
 
-Filename: exudyn-1.8.0.dist-info/RECORD
+Filename: exudyn.libs/libglfw-14630bf2.so.3.2
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## exudyn/FEM.py

 * *Ordering differences only*

```diff
@@ -1,3846 +1,3846 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Support functions and helper classes for import of meshes, finite element models (ABAQUS, ANSYS, NETGEN) and for generation of FFRF (floating frame of reference) objects.
-#
-# Author:   Johannes Gerstmayr; Stefan Holzinger (Abaqus and Ansys import utilities); Joachim Sch\"oberl (support for Netgen and NGsolve \cite{Schoeberl1997,NGsolve2014,NGsolve2022} import and eigen computations)
-# Date:     2020-03-10 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-# Notes:    internal CSR matrix storage format contains 3 float numbers per row: [row, column, value], can be converted to scipy csr sparse matrices with function CSRtoScipySparseCSR(...)
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#constants and fixed structures:
-import exudyn.itemInterface as eii
-#from exudyn.utilities import 
-from exudyn.advancedUtilities import IsListOrArray, RoundMatrix, PlotLineCode
-from exudyn.rigidBodyUtilities import GetRigidBodyNode, AngularVelocity2EulerParameters_t, EulerParameters2GLocal, \
-             RotationVector2GLocal, RotXYZ2GLocal, RotXYZ2GLocal_t, ComputeSkewMatrix, Skew, eulerParameters0, \
-             StrNodeType2NodeType
-
-from exudyn.graphicsDataUtilities import ComputeTriangleArea
-
-import numpy as np #LoadSolutionFile
-from enum import Enum #for class HCBstaticModeSelection
-import os
-
-
-#convert zero-based sparse matrix data to dense numpy matrix
-#DEPRECTAED!!!!!!!!!!!!!!!!
-def CompressedRowToDenseMatrix(sparseData):
-    print("\n**************************\nWARNING: CompressedRowToDenseMatrix is deprecated!\n**************************\n")
-    n = int(max(np.max(sparseData[:,0]),np.max(sparseData[:,1]))) #rows and columns are 1-based
-    m = np.zeros((n,n))
-    for row in sparseData:
-        m[int(row[0])-1,int(row[1])-1] += row[2] #convert 1-based to 0-based; += for double entries
-    return m
-
-#**function: convert zero-based sparse matrix data to dense numpy matrix
-#**input: 
-#  sparseData: format (per row): [row, column, value] ==> converted into dense format
-#**output: a dense matrix as np.array
-def CompressedRowSparseToDenseMatrix(sparseData):
-    #does not work, if there are no entry in highest rows and columns
-    n = int(max(np.max(sparseData[:,0]),np.max(sparseData[:,1])))+1 #rows and columns indices are 0-based ==> add 1 for size!
-    m = np.zeros((n,n))
-    for row in sparseData:
-        m[int(row[0]),int(row[1])] += row[2]  #+= for double entries
-    return m
-
-#**function: resort a sparse matrix (internal CSR format) with given sorting for rows and columns; changes matrix directly! used for ANSYS matrix import
-def MapSparseMatrixIndices(matrix, sorting):
-    for row in matrix:
-        row[0] = sorting[int(row[0])]
-        row[1] = sorting[int(row[1])]
-
-
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute diadic product of vector v and a 3D unit matrix = diadic(v,I$_{3x3}$); used for ObjectFFRF and CMS implementation
-def VectorDiadicUnitMatrix3D(v):
-    return np.kron(np.array(v), np.eye(3)).T
-
-#print("diadicTest=", VectorDiadicUnitMatrix3D(np.array([1,2,3,4,5,6])))
-
-#+++++++++++++++++++++++++++
-#**function: compare cyclic two lists, reverse second list; return True, if any cyclic shifted lists are same, False otherwise
-def CyclicCompareReversed(list1, list2):
-    revList1 = np.flip(list1,0)
-    for i in range(len(list2)):
-        if (revList1 == np.roll(list2,i)).all(): return True
-    return False
-
-
-#**function: add entry to compressedRowSparse matrix, avoiding duplicates
-#value is either added to existing entry (avoid duplicates) or a new entry is appended
-def AddEntryToCompressedRowSparseArray(sparseData, row, column, value):
-    n = len(sparseData[:,0])
-    #print("AddEntryToCompressedRowSparseArray:",row,column,value, ", n=", n)
-    for i in range(n):
-        if int(sparseData[i,0]) == row and int(sparseData[i,1]) == column:
-            sparseData[i,2] += value
-            #print("AddEntryToCompressedRowSparseArray, value added")
-            return sparseData
-#        if int(sparseData[i,0]) > row:
-#            np.insert(sparseData, i, np.array((row, column, value)), 0)
-#            print("AddEntryToCompressedRowSparseArray, row inserted, i=",i)
-#            return sparseData
-    #insert at end of matrix:
-    #print("AddEntryToCompressedRowSparseArray, row added at end")
-    np.insert(sparseData, n, np.array((row, column, value)), 0)
-    return sparseData
-
-#**function: compute rows and columns of a compressed sparse matrix and return as tuple: (rows,columns)
-def CSRtoRowsAndColumns(sparseMatrixCSR):
-    rows = sparseMatrixCSR[:,0].max()
-    columns = sparseMatrixCSR[:,1].max()
-    return (rows, columns)
-
-#**function: convert internal compressed CSR to scipy.sparse csr matrix
-def CSRtoScipySparseCSR(sparseMatrixCSR):
-    from scipy.sparse import csr_matrix
-    X = csr_matrix((sparseMatrixCSR[:,2],(sparseMatrixCSR[:,0].astype(int),sparseMatrixCSR[:,1].astype(int))))
-    #X.sum_duplicates() 
-    return X
-
-
-#**function: convert scipy.sparse csr matrix to internal compressed CSR 
-def ScipySparseCSRtoCSR(scipyCSR):
-    #from scipy.sparse import csr_matrix
-    data=scipyCSR.tocoo()
-    sparseData = [data.row,data.col,data.data]
-    return np.array(sparseData).T
-
-#**function: resort indices of given NGsolve CSR matrix in XXXYYYZZZ format to XYZXYZXYZ format; numberOfRows must be equal to columns
-#needed for import from NGsolve
-def ResortIndicesOfCSRmatrix(mXXYYZZ, numberOfRows):
-    #compute resorting index array [0,1,2, 3,4,5, 6,7,8] ==> [0,3,6, 1,4,7, 2,5,8]
-    if numberOfRows%3 != 0:
-        raise ValueError("ResortIndicesOfCSRmatrix: numberOfRows must be multiple of 3")
-    
-    #compute transformation of indices:
-    r = np.arange(numberOfRows).reshape((int(numberOfRows/3),3))
-    r = r.T.flatten()
-    
-    mXXYYZZ[:,0] = r[mXXYYZZ[:,0].astype(int)]
-    mXXYYZZ[:,1] = r[mXXYYZZ[:,1].astype(int)]
-
-    # nSparse = len(mXXYYZZ)
-    # for i in range(nSparse): #for loop is slow, but works ok for 100.000 DOF
-    #     mXXYYZZ[i,0] = r[int(mXXYYZZ[i,0])]
-    #     mXXYYZZ[i,1] = r[int(mXXYYZZ[i,1])]
-    
-#**function: resort indices of given NGsolve vector in XXXYYYZZZ format to XYZXYZXYZ format
-def ResortIndicesOfNGvector(vXXYYZZ):
-    #compute resorting index array [0,1,2, 3,4,5, 6,7,8] ==> [0,3,6, 1,4,7, 2,5,8]
-    v = np.array(vXXYYZZ)
-    numberOfRows = len(v)
-    if numberOfRows%3 != 0:
-        raise ValueError("ResortIndicesOfNGvector: length must be multiple of 3")
-
-    vNew = np.zeros(numberOfRows)
-
-    #compute transformation of indices:
-    r = np.arange(numberOfRows).reshape((int(numberOfRows/3),3))
-    r = r.T.flatten()
-    
-    # for i in range(numberOfRows): #for loop is slow, but works ok for 100.000 DOF
-    #     vNew[r[i]] = v[i]
-    vNew[r[:]] = v[:]
-
-    return vNew
-    
-#**function: resort indices of given Exudyun vector XYZXYZXYZ to NGsolve vector in XXXYYYZZZ format
-def ResortIndicesExudyn2NGvector(vXYZXYZ):
-    #compute resorting index array [0,1,2, 3,4,5, 6,7,8] ==> [0,3,6, 1,4,7, 2,5,8]
-    v = np.array(vXYZXYZ)
-    numberOfRows = len(v)
-    if numberOfRows%3 != 0:
-        raise ValueError("ResortIndicesOfNGvector: length must be multiple of 3")
-
-    vNew = np.zeros(numberOfRows)
-
-    #compute transformation of indices:
-    r = np.arange(numberOfRows).reshape((int(numberOfRows/3),3))
-    r = r.T.flatten()
-    
-    # for i in range(numberOfRows): #for loop is slow, but works ok for 100.000 DOF
-    #     vNew[i] = v[r[i]]
-    vNew[:] = v[r[:]]
-
-    return vNew
-    
-
-
-
-#DEPRECATED!
-#read abaqus nodes information to numpy array
-#typeName is Part or Instance; name is part's or instance's name
-#if exportElement=False: returns np.array(nodes) with nodal coordinates
-#if exportElements=True: returns a list [np.array(nodes), elementsDict, surfaceElementsDict] with information on types of elements
-def ReadNodesFromAbaqusInp(fileName, typeName='Part', name='Part-1', exportElements=False):
-    print("\n********************WARNING:\nFUNCTION ReadNodesFromAbaqusInp is deprecated; use FEMinterface!\n********************\n")
-    fileLines = []
-    try: #still close file if crashes
-        file=open(fileName,'r') 
-        fileLines = file.readlines()
-    finally:
-        file.close()
-        
-        
-    print("read ", len(fileLines), "lines")
-    
-    startPart = False
-    startReadNodes = False
-    finishedReadNodes = False
-    startReadElements = False
-    finishedReadElements = False
-    nodes = [] #store list of node values
-    elements = [] #store list of elements with node numbers
-    surfaceElements = [] #store list of surface elements (trigs, quads) with node numbers
-    elementTypes = [] #string list of element types
-    surfaceElementTypes = [] #string list of surface element types
-
-    errorOccured = False
-    lineCnt = 0
-    for line in fileLines:
-        #print("line", lineCnt, "=", line)
-        lineCnt+=1
-        if errorOccured:
-            break
-        
-        if startReadNodes and not finishedReadNodes:
-            if line[0] != '*': #check if nodes section has finished
-                lineData = line.split(',') #split into values
-                if len(lineData) != 4:
-                    print("ERROR: Expected node number and 3 coordinates, line ", lineCnt)
-                    errorOccured = True
-                else:
-                    v = []
-                    for i in range(3):
-                        v+=[float(lineData[i+1])]
-                    nodes += [v] #add node data
-            else:
-                startReadNodes = False
-                finishedReadNodes = True
-    
-        if startReadElements and not finishedReadElements:
-            if line[0] != '*': #check if nodes section has finished
-                lineData = line.split(',') #split into values
-                if len(lineData) != 9:
-                    print("ERROR: Expected element number and 8 indices for C3D8R, line=", lineCnt)
-                    errorOccured = True
-                else:
-                    v = []
-                    for i in range(8):
-                        v+=[float(lineData[i+1])]
-                    elements += [v] #add node data
-                    elementTypes += ['Hex8'] #8-noded hexahedral
-            else:
-                startReadElements = False
-                finishedReadElements = True
-    
-        if startPart and not startReadNodes and not finishedReadNodes:
-            if line[0:5] == '*Node':
-                startReadNodes = True
-                startPart = False
-            else:
-                print("ERROR: Expected *Node after *Part, line=", lineCnt)
-                errorOccured = True
-
-        if finishedReadNodes and exportElements and not startReadElements:
-            if line[0:8] == '*Element':
-                startReadElements = True
-                #check "type=C3D8R" in future
-
-            
-        if line[0:len(typeName)+1] == '*'+typeName:
-            if not startPart:
-                #print("ERROR: only one *Part section allowed, line=", lineCnt)
-                #errorOccured = True
-                
-                lineInfo = line.split(',')
-                #print(lineInfo)
-                if len(lineInfo) != 3:
-                    print("ERROR: invalid information for part/instance name, line=", lineCnt)
-                    errorOccured = True
-                else:
-                    nameInfo = lineInfo[1].strip().split('=')
-                    if nameInfo[0] != 'name':
-                        print("ERROR: expected 'name=' in line=", lineCnt)
-                        errorOccured = True
-                    else:
-                        if nameInfo[1] != name:
-                            print("ERROR: expected name='" + name + "' in line=", lineCnt)
-                            errorOccured = True
-                        else:
-                            startPart = True
-    
-    if not exportElements:
-        return np.array(nodes)
-    else:
-        elementsDict = {'elements':np.array(elements), 'elementTypes':elementTypes}
-        surfaceElementsDict = {'elements':np.array(surfaceElements), 'elementTypes':surfaceElementTypes}
-        return [np.array(nodes), elementsDict, surfaceElementsDict]
-
-
-
-
-#**function: convert list of Hex8/C3D8  element with 8 nodes in nodeNumbers into triangle-List
-#**notes: works for Hex20 elements, but does only take the corner nodes for drawing!
-def ConvertHexToTrigs(nodeNumbers):
-    localList = [[0,1,2], [0,2,3], [6,5,4], [6,4,7], [0,4,1], [1,4,5], [1,5,2], [2,5,6], [2,6,3], [3,6,7], [3,7,0], [0,7,4]]
-
-    trigList = []
-    for trig in localList:
-        ind = [nodeNumbers[trig[0]], nodeNumbers[trig[1]], nodeNumbers[trig[2]]]
-        trigList += [ind]
-    return trigList
-
-#**function: convert list of Tet4/Tet10 element with 4 or 10 nodes in nodeNumbers into triangle-List
-#**notes: works for Tet10 elements, but does only take the corner nodes for drawing!
-def ConvertTetToTrigs(nodeNumbers):
-    localList = [[0,1,2], [0,3,1], [1,3,2], [0,2,3]]
-
-    trigList = []
-    for trig in localList:
-        ind = [nodeNumbers[trig[0]], nodeNumbers[trig[1]], nodeNumbers[trig[2]]]
-        trigList += [ind]
-    return trigList
-
-
-
-#**function: convert numpy.array dense matrix to (internal) compressed row format
-def ConvertDenseToCompressedRowMatrix(denseMatrix):
-    sparseMatrix = []
-    (nRows,nColumns) = denseMatrix.shape
-    for i in range(nRows):
-        for j in range(nColumns):
-            if denseMatrix[i,j] != 0.:
-                sparseMatrix += [[i,j,denseMatrix[i,j]]]
-    return np.array(sparseMatrix)
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function:This function reads either the mass or stiffness matrix from an Ansys
-#           Matrix Market Format (MMF). The corresponding matrix can either be exported 
-#           as dense matrix or sparse matrix.
-#
-#**input: fileName of MMF file
-#**output: internal compressed row sparse matrix (as (nrows x 3) numpy array)
-#
-#**author: Stefan Holzinger
-#
-#**notes:
-#   A MMF file can be created in Ansys by placing the following APDL code inside
-#   the solution tree in Ansys Workbench:
-#
-#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-#   ! APDL code that exports sparse stiffnes and mass matrix in MMF format. If 
-#   ! the dense matrix is needed, replace *SMAT with *DMAT in the following
-#   ! APDL code.
-#    
-#   ! Export the stiffness matrix in MMF format
-#   *SMAT,MatKD,D,IMPORT,FULL,file.full,STIFF
-#   *EXPORT,MatKD,MMF,fileNameStiffnessMatrix,,,
-#
-#   ! Export the mass matrix in MMF format
-#   *SMAT,MatMD,D,IMPORT,FULL,file.full,MASS
-#   *EXPORT,MatMD,MMF,fileNameMassMatrix,,,
-#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-#
-# In case a lumped mass matrix is needed, place the following APDL Code inside 
-# the Modal Analysis Tree:
-#
-#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-#   ! APDL code to force Ansys to use a lumped mass formulation (if available for
-#   ! used elements)
-#   LUMPM, ON, , 0
-#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-def ReadMatrixFromAnsysMMF(fileName, verbose=False):
-    if verbose: print("Start read matrix")
-    # read file
-    fileLines = []
-    file=open(fileName,'r') 
-    fileLines = file.readlines()
-    file.close()
-    
-    # delete text infos
-    offset = 0 #compute offset of comments and others
-    while fileLines[offset][0] == '%':
-        offset += 1
-        #del fileLines[0]
-    
-    # delete size information in fileLines
-    #del fileLines[0]
-    offset += 1
-
-    # put CSR data into this list
-    dataList = []
-    
-    # read row and col indices as well as corresponding matrix values
-    lineCnt = 0
-    for line in fileLines:
-        if lineCnt%500000 == 0 and lineCnt !=0: 
-            if verbose: print("parse line",lineCnt," / ", len(fileLines))
-        if lineCnt>=offset:
-            rowStr = line.rsplit()
-            
-            row=[int(rowStr[0])-1, int(rowStr[1])-1, float(rowStr[2])] #convert to 0-based format
-            dataList+=[row]
-            if row[0] != row[1]: #Ansys only stores half of matrix==>add symmetric terms except diagonal terms!
-                dataList+=[[row[1],row[0],row[2]]]
-        lineCnt+=1
-                    
-    return np.array(dataList)
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: read sorting vector for ANSYS mass and stiffness matrices and return sorting vector as np.array
-#  the file contains sorting for nodes and applies this sorting to the DOF (assuming 3 DOF per node!)
-#  the resulting sorted vector is already converted to 0-based indices
-def ReadMatrixDOFmappingVectorFromAnsysTxt(fileName):
-    fileLines = []
-    file=open(fileName,'r') 
-    fileLines = file.readlines()
-    file.close()
-    nLines = len(fileLines)
-
-    #read leading comments
-    lineOffset = 0
-    while lineOffset < nLines and fileLines[lineOffset][0] == '%':
-        lineOffset+=1
-
-    #check header:
-    rowStr = fileLines[lineOffset].rsplit()
-    nDOF = int(rowStr[0])
-    if int(rowStr[1]) != 1:
-        raise ValueError("ReadMatrixDOFmappingVectorFromAnsysTxt: invalid value in line " + str(lineOffset+1) + ", expected 1 column")
-
-    if int(rowStr[0]) != nLines-lineOffset-1:
-        raise ValueError("ReadMatrixDOFmappingVectorFromAnsysTxt: number of lines do not match the number of DOF: nDOF="+str(nDOF)+
-                         ", #data lines="+ str(nLines-lineOffset-1)) #removed arg_str() => Stefan
-
-    lineOffset+=1
-
-    #read now the mapping of the DOF line by line
-    dataList = []
-    lineCnt = 0
-    for line in fileLines:
-        if lineCnt>=lineOffset:
-            dataList += [(int(line)-1)*3+0] #convert to 0-base and apply for x,y and z coordinate of node ...
-            dataList += [(int(line)-1)*3+1] #convert to 0-base and apply for x,y and z coordinate of node ...
-            dataList += [(int(line)-1)*3+2] #convert to 0-base and apply for x,y and z coordinate of node ...
-        lineCnt+=1
-                    
-    return np.array(dataList)    
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: This function reads the nodal coordinates exported from Ansys.
-#
-#**input: fileName (file name ending must be .txt!)
-#**output: nodal coordinates as numpy array
-#
-#**author: Stefan Holzinger
-#
-#**notes:
-#   The nodal coordinates can be exported from Ansys by creating a named selection
-#   of the body whos mesh should to exported by choosing its geometry. Next, 
-#   create a second named selcetion by using a worksheet. Add the named selection
-#   that was created first into the worksheet of the second named selection.
-#   Inside the working sheet, choose 'convert' and convert the first created
-#   named selection to 'mesh node' (Netzknoten in german) and click on generate
-#   to create the second named selection. Next, right click on the second 
-#   named selection tha was created and choose 'export' and save the nodal 
-#   coordinates as .txt file.
-#   
-def ReadNodalCoordinatesFromAnsysTxt(fileName, verbose=False):
-    
-    # read file
-    fileLines = []
-    file=open(fileName,'r') 
-    fileLines = file.readlines()
-    file.close()
-            
-    # delete first line
-    del fileLines[0]
-    
-    # number of mesh nodes
-    numberOfNodes = len(fileLines)
-    
-    # allocate memory
-    # unsorted lists
-    unsortedNodalCoordinates = [None]*(numberOfNodes)
-    unsortedNodeNumberList   = [None]*(numberOfNodes)
-    currentNodalCoordinates  = np.zeros(3)
-    unsortedNodeDictList     = [None]*(numberOfNodes)
-    # sorted lists
-    #sortedNodalCoordinates = [None]*(numberOfNodes)
-    sortedNodalCoordinates = np.zeros((numberOfNodes,3),dtype=float)
-    sortedNodeNumberList   = [None]*(numberOfNodes)
-    sortedNodeListDict     = [None]*(numberOfNodes)
-    
-    lineCtr = 0
-    for line in fileLines:
-        #if lineCtr%10000 == 0: print("read node",lineCtr)
-        # remove '\n' from value at line end
-        currentLine = line.rsplit()
-            
-        # add node index (one based) and corresponding nodal coordinates to node dict   
-        currentNodalCoordinates = currentLine[1:]   
-        for i in range(len(currentNodalCoordinates)): 
-            currentNodalCoordinates[i] = float(currentNodalCoordinates[i].replace(",","."))   
-        
-        # add items to corresponding list
-        unsortedNodeNumberList[lineCtr]   = int(currentLine[0])
-        unsortedNodalCoordinates[lineCtr] = currentNodalCoordinates
-        unsortedNodeDictList[lineCtr]     = {"nodeNr":int(currentLine[0]), "nodalCoordinates": currentNodalCoordinates}
-            
-        # increase line counter
-        lineCtr += 1        
-        
-    
-    # sort node list w.r.t. increasing node numbers
-    sortedNodeListDict = sorted(unsortedNodeDictList, key = lambda i: i["nodeNr"])
-    dictCtr = 0
-    for dict_ in sortedNodeListDict:
-        
-        sortedNodalCoordinates[dictCtr] = sortedNodeListDict[dictCtr]["nodalCoordinates"]
-        sortedNodeNumberList[dictCtr]   = sortedNodeListDict[dictCtr]["nodeNr"]
-        dictCtr += 1
-    
-    return sortedNodalCoordinates
-
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: This function reads the nodal coordinates exported from Ansys.
-#
-#**input: fileName (file name ending must be .txt!)
-#**output: element connectivity as numpy array
-#
-#**author: Stefan Holzinger
-#
-#**notes:
-#   The elements can be exported from Ansys by creating a named selection
-#   of the body whos mesh should to exported by choosing its geometry. Next, 
-#   create a second named selcetion by using a worksheet. Add the named selection
-#   that was created first into the worksheet of the second named selection.
-#   Inside the worksheet, choose 'convert' and convert the first created
-#   named selection to 'mesh element' (Netzelement in german) and click on generate
-#   to create the second named selection. Next, right click on the second 
-#   named selection tha was created and choose 'export' and save the elements 
-#   as .txt file.
-def ReadElementsFromAnsysTxt(fileName, verbose=False):
-    
-    # read file
-    fileLines = []
-    file=open(fileName,'r') 
-    fileLines = file.readlines()
-    file.close()
-                
-    # delete first line ==> contains text
-    del fileLines[0]
-        
-    # number of mesh nodes
-    #numberOfElements = len(fileLines) #do not trust this, could be changed with one additional line
-    numberOfElements = 0
-
-    #check file consistency => first columns should contain element number (1-based)
-    for i in range(len(fileLines)):
-        line = fileLines[i]
-        n = int(line.rsplit()[0])
-        #print("element:", n)
-        if n == i+1: 
-            numberOfElements = n
-        else:
-            raise ValueError("ReadElementsFromAnsysTxt: invalid format in line "+str(i+2)+": expected element number, type and connectivity; be careful with empty lines")
-                
-    
-    # allocate memory
-    elementTypeList = [None]*(numberOfElements)
-    elementConnectivityList = [None]*(numberOfElements)
-    currentNodeIndexList = []
-    
-    for lineCtr in range(numberOfElements):
-        if lineCtr%10000 == 0 and lineCtr !=0: 
-            if verbose: print("read element",lineCtr," / ", numberOfElements)
-        #if lineCtr%10000 == 0: print("read element",lineCtr)
-        line = fileLines[lineCtr]
-        
-        # split current line at \n
-        currentLine = line.rsplit()
-        
-        # get element type of current element
-        elementTypeList[lineCtr] = currentLine[1]
-        
-        # get element connectivity of current element
-        for node in currentLine[2:]:
-            currentNodeIndexList.append( int(node)-1 )  # convert to zero based
-        
-        # add element connectivity of current element to elementConnectivityList 
-        elementConnectivityList[lineCtr] = currentNodeIndexList 
-        
-        # clear current node index list (nodes that form the current element)
-        currentNodeIndexList = []
-        
-    #elementsDict = {'Name':'elements', 'Tet4':[], 'Hex8':elementConnectivityList}
-    elementsDict = {'Name':'elements'}
-
-    if verbose: print("create element dictionaries...")
-    for lineCtr in range(numberOfElements):
-        line = fileLines[lineCtr]
-        if not(elementTypeList[lineCtr] in elementsDict):
-            elementsDict[elementTypeList[lineCtr]] = []
-        elementsDict[elementTypeList[lineCtr]] += [elementConnectivityList[lineCtr]]
-
-    return elementsDict
-
-
-
-
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: material base class, e.g., for FiniteElement
-class MaterialBaseClass:
-    def __init__(self, youngsModulus, poissonsRatio, density):
-        self.youngsModulus = youngsModulus
-        self.poissonsRatio = poissonsRatio
-        self.density = density
-
-#**class: class for representation of Kirchhoff (linear elastic, 3D and 2D) material
-#**notes: use planeStress=False for plane strain
-class KirchhoffMaterial(MaterialBaseClass):
-    def __init__(self, youngsModulus, poissonsRatio, density = 0, planeStress = True):
-        super().__init__(youngsModulus, poissonsRatio, density)
-        self.planeStress = planeStress
-
-        Em = self.youngsModulus
-        nu = self.poissonsRatio
-
-        lam = nu*Em / ((1 + nu) * (1 - 2*nu))
-        mu = Em / (2*(1 + nu))
-        self.elasticityTensor = np.array([[lam + 2*mu, lam, lam, 0, 0, 0],
-                              [lam, lam + 2*mu, lam, 0, 0, 0],
-                              [lam, lam, lam + 2*mu, 0, 0, 0],
-                              [0, 0, 0, mu, 0, 0],
-                              [0, 0, 0, 0, mu, 0],
-                              [0, 0, 0, 0, 0, mu]])
-
-        if self.planeStress:
-            self.elasticityTensor2D = Em/(1-nu**2)*np.array([[1, nu, 0],
-                                                            [nu, 1, 0],
-                                                            [0, 0, (1-nu)/2]])
-        else:
-            self.elasticityTensor2D = np.array([[lam + 2*mu, lam, 0],
-                                                [lam, lam + 2*mu, 0],
-                                                [0, 0, mu]])
-
-
-    #**classFunction: convert strain tensor into stress tensor using elasticity tensor
-    def Strain2Stress(self, strain):
-        E = strain
-        strainVector = np.array([  E[0,0],   E[1,1],   E[2,2],
-                                 2*E[1,2], 2*E[0,2], 2*E[0,1]])
-        SV = self.StrainVector2StressVector(strainVector)
-        S = np.array([[SV[0], SV[5], SV[4]],
-                      [SV[5], SV[1], SV[3]],
-                      [SV[4], SV[3], SV[2]]])
-        return S
-
-    #**classFunction: convert strain vector into stress vector
-    def StrainVector2StressVector(self, strainVector):
-        return self.elasticityTensor @ strainVector
-
-    #**classFunction: compute 2D stress vector from strain vector
-    def StrainVector2StressVector2D(self, strainVector2D):
-        #E=strain
-        #strainVector2D = np.array([E[0,0], E[1,1], 2*E[0,1]])
-        SV = self.elasticityTensor2D @ strainVector2D
-        #S = np.array([[SV[0], SV[2]], [SV[2], SV[1]]])
-        return SV
-
-    #**classFunction: compute Lame parameters from internal Young's modulus and Poisson ratio
-    #**output: return vector [mu, lam] of Lame parameters
-    def LameParameters(self):
-        E = self.youngsModulus
-        nu = self.poissonsRatio
-        mu  = E / 2 / (1+nu) #Lame parameters
-        lam = E * nu / ((1+nu)*(1-2*nu))
-        return [mu, lam]
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: finite element base class for lateron implementations of other finite elements
-class FiniteElement:
-    def __init__(self, material):
-        self.material = material
-    
-#**class: simplistic 4-noded tetrahedral interface to compute strain/stress at nodal points
-class Tet4(FiniteElement):
-    def __init__(self, material):
-        super().__init__(material)
-    
-    #return (per node) linearized strain, linearized stress, reference B-matrix and deformation gradient
-    def ComputeMatrices(self, nodalReferenceCoordinates, nodalDisplacements):
-        #following routines implemented according to implementation in AMFE (TU-Munich):
-        [X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3, X4, Y4, Z4] = nodalReferenceCoordinates
-        
-        Umat = nodalDisplacements.reshape(-1, 3)
-        #Xmat = nodalReferenceCoordinates.reshape(-1, 3)
-
-        det = (-X1*Y2*Z3 + X1*Y2*Z4 + X1*Y3*Z2 - X1*Y3*Z4 - X1*Y4*Z2 + X1*Y4*Z3 
-              + X2*Y1*Z3 - X2*Y1*Z4 - X2*Y3*Z1 + X2*Y3*Z4 + X2*Y4*Z1 - X2*Y4*Z3 
-              - X3*Y1*Z2 + X3*Y1*Z4 + X3*Y2*Z1 - X3*Y2*Z4 - X3*Y4*Z1 + X3*Y4*Z2 
-              + X4*Y1*Z2 - X4*Y1*Z3 - X4*Y2*Z1 + X4*Y2*Z3 + X4*Y3*Z1 - X4*Y3*Z2)
-
-        #compute B matrix for reference coordinates
-        B0 = 1/det*np.array([
-            [-Y2*Z3 + Y2*Z4 + Y3*Z2 - Y3*Z4 - Y4*Z2 + Y4*Z3,
-              X2*Z3 - X2*Z4 - X3*Z2 + X3*Z4 + X4*Z2 - X4*Z3,
-              -X2*Y3 + X2*Y4 + X3*Y2 - X3*Y4 - X4*Y2 + X4*Y3],
-            [ Y1*Z3 - Y1*Z4 - Y3*Z1 + Y3*Z4 + Y4*Z1 - Y4*Z3,
-              -X1*Z3 + X1*Z4 + X3*Z1 - X3*Z4 - X4*Z1 + X4*Z3,
-              X1*Y3 - X1*Y4 - X3*Y1 + X3*Y4 + X4*Y1 - X4*Y3],
-            [-Y1*Z2 + Y1*Z4 + Y2*Z1 - Y2*Z4 - Y4*Z1 + Y4*Z2,
-              X1*Z2 - X1*Z4 - X2*Z1 + X2*Z4 + X4*Z1 - X4*Z2,
-              -X1*Y2 + X1*Y4 + X2*Y1 - X2*Y4 - X4*Y1 + X4*Y2],
-            [ Y1*Z2 - Y1*Z3 - Y2*Z1 + Y2*Z3 + Y3*Z1 - Y3*Z2,
-              -X1*Z2 + X1*Z3 + X2*Z1 - X2*Z3 - X3*Z1 + X3*Z2,
-              X1*Y2 - X1*Y3 - X2*Y1 + X2*Y3 + X3*Y1 - X3*Y2]])
-
-        #displacement gradient:
-        grad = Umat.T @ B0
-        #deformation gradient:
-        #F = grad + np.eye(3)
-
-        #linearized strain:
-        linE = 0.5*(grad + grad.T)
-        strainVector = np.array([  linE[0,0],   linE[1,1],   linE[2,2],
-                                 2*linE[1,2], 2*linE[0,2], 2*linE[0,1]])
-        
-        stressVector = self.material.StrainVector2StressVector(strainVector)
-        
-        # strainVector4 = np.ones((4,1)) @ np.array([[linE[0,0],   linE[1,1],   linE[2,2],
-        #                                             2*linE[1,2], 2*linE[0,2], 2*linE[0,1]]])
-        strainVector4 = np.ones((4,1)) @ np.array([strainVector])
-
-        stressVector4 = np.ones((4,1)) @ np.array([stressVector])
-
-        #strainvector per node:
-        return [strainVector4, stressVector4, B0, grad]
-
-
-
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++++          ObjectFFRF                               ++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: compute terms necessary for ObjectFFRF
-#class used internally in FEMinterface to compute ObjectFFRF object 
-#this class holds all data for ObjectFFRF user functions
-class ObjectFFRFinterface:
-    #**classFunction: initialize ObjectFFRFinterface with FEMinterface class
-    #  initializes the ObjectFFRFinterface with nodes, modes, surface description and systemmatrices from FEMinterface
-    #  data is then transfered to mbs object with classFunction AddObjectFFRF(...)
-    def __init__(self, femInterface):
-        self.modeBasis = femInterface.modeBasis['matrix']
-        self.nodeArray = femInterface.GetNodePositionsAsArray()
-        self.trigList = femInterface.GetSurfaceTriangles()
-
-        #stiffnessMatrixCSR = CSRtoScipySparseCSR(femInterface.GetStiffnessMatrix(sparse=True))
-        self.massMatrixCSR = CSRtoScipySparseCSR(femInterface.GetMassMatrix(sparse=True)) #for multiplications
-        self.stiffnessMatrixSparse = femInterface.GetStiffnessMatrix(sparse=True)
-        self.massMatrixSparse = femInterface.GetMassMatrix(sparse=True)
-
-        #new coordinates:
-        self.nNodes = len(self.nodeArray)                   #stored in nNodes x 3 np-array
-        self.dim3D = len(self.nodeArray[0])                 #dimension of position, assuming that one node exists ....
-        self.nODE2rot = 4                                   #dimension of rotation parameters; fixed to 4 for now!
-        self.nODE2rigid = self.dim3D + self.nODE2rot
-        self.nODE2FF = self.nNodes * self.dim3D
-        self.nODE2FFRF = self.nODE2rigid + self.nODE2FF
-        # nNodesFFRF = self.nNodes+1                          #including rigid body node
-
-        #self.massMatrixFFRF = np.zeros((self.nODE2FFRF,self.nODE2FFRF)) #create larger FFRF mass matrix
-        #self.stiffnessMatrixFFRF = np.zeros((self.nODE2FFRF,self.nODE2FFRF)) #create larger FFRF mass matrix
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #FFRFreduced constant matrices:
-        self.Phit = np.kron(np.ones(self.nNodes),np.eye(3)).T
-        self.PhitTM = self.Phit.T @ self.massMatrixCSR #LARGE MATRIX COMPUTATION
-        self.xRef = self.nodeArray.flatten()                     #node reference values in single vector (can be added then to q[7:])
-        self.xRefTilde = ComputeSkewMatrix(self.xRef) #rfTilde without q    
-
-        #not needed, but may be interesting for checks:
-        self.inertiaLocal = self.xRefTilde.T @ self.massMatrixCSR @ self.xRefTilde #LARGE MATRIX COMPUTATION
-
-
-    #**classFunction: add according nodes, objects and constraints for FFRF object to MainSystem mbs; only implemented for Euler parameters
-    #**input:
-    #  exu: the exudyn module
-    #  mbs: a MainSystem object
-    #  positionRef: reference position of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
-    #  eulerParametersRef: reference euler parameters of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
-    #  initialVelocity: initial velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
-    #  initialAngularVelocity: initial angular velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
-    #  gravity: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
-    #  constrainRigidBodyMotion: set True in order to add constraint (Tisserand frame) in order to suppress rigid motion of mesh nodes
-    #  color: provided as list of 4 RGBA values
-    #add object to mbs as well as according nodes
-    def AddObjectFFRF(self, exu, mbs, 
-                      positionRef=[0,0,0], eulerParametersRef=[1,0,0,0], 
-                      initialVelocity=[0,0,0], initialAngularVelocity=[0,0,0],
-                      gravity=[0,0,0],
-                      constrainRigidBodyMotion=True, 
-                      massProportionalDamping = 0, stiffnessProportionalDamping = 0,
-                      color=[0.1,0.9,0.1,1.]):
-
-        self.gravity = gravity
-
-        #compute initial euler parameter velocities from angular velocity vector
-        self.eulerParameters_t0 = AngularVelocity2EulerParameters_t(initialAngularVelocity, eulerParametersRef)
-        self.eulerParameters0 = eulerParametersRef
-
-        #rigid body node for ObjectFFRF
-        self.nRigidBody = mbs.AddNode(eii.NodeRigidBodyEP(referenceCoordinates=list(positionRef)+list(eulerParametersRef), 
-                                            initialVelocities=list(initialVelocity)+list(self.eulerParameters_t0)))
-
-        self.nodeList = [] #list of nodenumbers in mbs
-        for node in self.nodeArray:
-            nMBS = mbs.AddNode(eii.Point(referenceCoordinates = list(node), visualization=eii.VNodePoint(show = False))) 
-            self.nodeList += [nMBS]
-
-        stiffnessMatrixMC = exu.MatrixContainer()
-        #stiffnessMatrixMC.SetWithSparseMatrixCSR(self.nODE2FF, self.nODE2FF, self.stiffnessMatrixSparse,useDenseMatrix=False)
-        stiffnessMatrixMC.SetWithDenseMatrix(CompressedRowSparseToDenseMatrix(self.stiffnessMatrixSparse),useDenseMatrix=False)
-
-        massMatrixMC = exu.MatrixContainer()
-        #massMatrixMC.SetWithSparseMatrixCSR(self.nODE2FF, self.nODE2FF, self.massMatrixSparse,useDenseMatrix=False)
-        massMatrixMC.SetWithDenseMatrix(CompressedRowSparseToDenseMatrix(self.massMatrixSparse),useDenseMatrix=False)
-
-        if (massProportionalDamping != 0 or massProportionalDamping != 0):
-            dampingMatrixMC = exu.MatrixContainer()
-            dampingMatrixMC.SetWithDenseMatrix(massProportionalDamping*CompressedRowSparseToDenseMatrix(self.massMatrixSparse)+
-                                               stiffnessProportionalDamping*CompressedRowSparseToDenseMatrix(self.stiffnessMatrixSparse),useDenseMatrix=False)
-        else:
-            dampingMatrixMC=[]
-        
-        #add body for FFRF-Object:
-        self.oFFRF = mbs.AddObject(eii.ObjectFFRF(nodeNumbers = [self.nRigidBody] + self.nodeList, 
-                                                            massMatrixFF=massMatrixMC,
-                                                            stiffnessMatrixFF=stiffnessMatrixMC, 
-                                                            dampingMatrixFF=dampingMatrixMC,
-                                                            #dampingMatrixFF=emptyMC,
-                                                            #forceVector=fNew,
-                                                            #forceUserFunction=UFforce,
-                                                            #computeFFRFterms=True,
-                                                            #massMatrixUserFunction=UFmassGenericODE2,
-                                                            visualization=eii.VObjectFFRF(triangleMesh = self.trigList, 
-                                                                                      color=color,
-                                                                                      showNodes = True)))
-
-
-        self.oRigidBodyConstraint = -1
-        if constrainRigidBodyMotion:
-            mObjectCoordinates = mbs.AddMarker(eii.MarkerObjectODE2Coordinates(objectNumber=self.oFFRF))
-            nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=[0,0,0], 
-                                                      visualization = eii.VNodePointGround(show=False))) #ground node for coordinate constraint
-            mGroundCoordinate = mbs.AddMarker(eii.MarkerNodeCoordinates(nodeNumber = nGround)) #Ground node ==> no action
-
-            X1 = np.zeros((6, self.nODE2FFRF))
-            X1rot = ComputeSkewMatrix(self.xRef).T @ self.massMatrixCSR
-            X1[0:3,self.nODE2rigid:] = self.PhitTM
-            X1[3:6,self.nODE2rigid:] = X1rot
-            offset = np.zeros(6)
-            offset[0:3] = self.PhitTM @ self.xRef #constrain current COM to reference COM
-
-            #add constraint: X1*qObjectFFRF - offset = 0
-            self.oRigidBodyConstraint = mbs.AddObject(eii.CoordinateVectorConstraint(markerNumbers=[mGroundCoordinate, mObjectCoordinates], 
-                                                                                 scalingMarker1 = X1, offset=offset))
-
-        dictReturn = {'nRigidBody':self.nRigidBody,
-                      'nodeList':self.nodeList,
-                      'oFFRF':self.oFFRF,
-                      'oRigidBodyConstraint':self.oRigidBodyConstraint}
-
-        return dictReturn
-
-    #**classFunction: optional forceUserFunction for ObjectFFRF (per default, this user function is ignored)
-    def UFforce(self, exu, mbs, t, q, q_t):
-        print("UFforce: not tested and not integrated in to FFRFinterface!")
-
-        force = np.zeros(self.nODE2FFRF)
-        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
-        A = Avec.reshape((3,3))
-
-        #implementation for Euler Parameters (Glocal_t*theta_t=0)
-        ep = np.array(q[self.dim3D:self.nODE2rigid]) + eulerParameters0 #add reference values, q are only the change w.r.t. reference values!
-        G = EulerParameters2GLocal(ep)
-    
-        cF_t = np.array(q_t[self.nODE2rigid:])         #velocities of flexible coordinates
-
-        rF = self.xRef + np.array(q[self.nODE2rigid:]) #nodal position
-
-        omega3D = G @ np.array(q_t[self.dim3D:self.nODE2rigid])
-        omega3Dtilde = Skew(omega3D)
-        #omega = np.array(list(omega3D)*self.nNodes)
-        omegaTilde = np.kron(np.eye(self.nNodes),omega3Dtilde)
-
-        #squared angul. vel. matrix:
-        omega3Dtilde2 = Skew(omega3D) @ Skew(omega3D)
-        omegaTilde2 = np.kron(np.eye(self.nNodes),omega3Dtilde2)
-
-        #these 2 terms are computationally costly:
-        rfTilde = ComputeSkewMatrix(rF) #rfTilde
-        cF_tTilde = ComputeSkewMatrix(cF_t) 
-
-        fTrans = A @ (omega3Dtilde @ self.PhitTM @ rfTilde @ omega3D + 2*self.PhitTM @ cF_tTilde @ omega3D)
-        force[0:self.dim3D] = fTrans
-
-        fRot = -G.T@(omega3Dtilde @ rfTilde.T @ self.massMatrixCSR @ rfTilde @ omega3D + 
-                        2*rfTilde.T @ self.massMatrixCSR @ cF_tTilde @ omega3D)
-        force[self.dim3D:self.nODE2rigid] = fRot
-    
-        fFlex = -self.massMatrixCSR @ (omegaTilde2 @ rF + 2*(omegaTilde @ cF_t))
-        force[self.nODE2rigid:] = fFlex
-
-        #add gravity:
-        # if False:
-        #     fGrav = np.array(fGravRigid + list(self.PhitTM.T @ (A.T @ self.gravity)) ) #only local vector, without rotation
-        #     force += fGrav
-
-        return force
-
-    #**classFunction: optional massMatrixUserFunction for ObjectFFRF (per default, this user function is ignored)
-    def UFmassGenericODE2(self, exu, mbs, t, q, q_t):
-        print("UFmassGenericODE2: not tested and not integrated into FFRFinterface!")
-        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
-        A = Avec.reshape((3,3))
-        ep = q[self.dim3D:self.nODE2rigid] + eulerParameters0 #add reference values, q are only the change w.r.t. reference values!
-        G = EulerParameters2GLocal(ep)
-
-        rF = self.xRef + q[self.nODE2rigid:] #nodal position
-        rfTilde = ComputeSkewMatrix(rF) #rfTilde
-        
-        Mnew = np.zeros((len(q), len(q)))
-
-        #Mtr:
-        Mtr = -A @ self.PhitTM @ rfTilde @ G
-        Mnew[0:self.dim3D, self.dim3D:self.dim3D+self.nODE2rot] = Mtr
-        Mnew[self.dim3D:self.dim3D+self.nODE2rot, 0:self.dim3D] = Mtr.T
-        #Mtf:
-        Mtf = A @ self.PhitTM
-        Mnew[0:self.dim3D, self.nODE2rigid:] = Mtf
-        Mnew[self.nODE2rigid:, 0:self.dim3D] = Mtf.T
-        #Mrf:
-        Mrf = -G.T @ rfTilde.T @ self.massMatrixCSR
-        Mnew[self.dim3D:self.dim3D+self.nODE2rot, self.nODE2rigid:] = Mrf
-        Mnew[self.nODE2rigid:, self.dim3D:self.dim3D+self.nODE2rot] = Mrf.T
-        #Mrr:
-        Mnew[self.dim3D:self.dim3D+self.nODE2rot, self.dim3D:self.dim3D+self.nODE2rot] = -Mrf @ rfTilde @ G   #G.T @ rfTilde.T @ massMatrix @ rfTilde @ G
-
-        return Mnew
-
-
-
-#**function: compute current (max, min, ...) value for chosen ObjectFFRFreducedOrder object (CMSobject) with exu.OutputVariableType. The function operates on nodal values. This is a helper function, which can be used to conveniently compute output quantities of the CMSobject efficiently and to use it in sensors
-#**input: 
-#  mbs: MainSystem of objectNumber
-#  objectNumber: number of ObjectFFRFreducedOrder in mbs
-#  outputVariableType: a exu.OutputVariableType out of [StressLocal, DisplacementLocal, VelocityLocal]
-#  norm: string containing chosen norm to be computed, out of 'Mises', 'maxNorm', 'min', 'max'; 'max' will return maximum of all components (component wise), 'min' does same but for minimum; 'maxNorm' computes np.linalg.norm for every node and then takes maximum of all norms; Mises computes von-Mises stress for every node and then takes maximum of all nodes
-#  nodeNumberList: list of mesh node numbers (from FEMinterface); if empty [], all nodes are used; otherwise, only given nodes are evaluated
-#**output: return value or list of values according to chosen norm as np.array
-def CMSObjectComputeNorm(mbs, objectNumber, outputVariableType, norm='max', nodeNumberList=[]):
-    import exudyn as exu
-    #get generic node number containing current coordinates:
-    nGeneric = mbs.GetObjectParameter(objectNumber,'nodeNumbers')[1]
-    #problem with rigid body coordinates:
-    #c = mbs.GetObjectOutputBody(objectNumber,variableType=exu.OutputVariableType.Coordinates,localPosition=[0,0,0])
-    #c_t = mbs.GetObjectOutputBody(objectNumber,variableType=exu.OutputVariableType.Coordinates_t,localPosition=[0,0,0])
-    
-    #see which outputvariable to compute:
-    if (mbs.GetObjectParameter(objectNumber,'outputVariableTypeModeBasis') == outputVariableType):
-        #get current coordinates:
-        c = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates)
-        X = mbs.GetObjectParameter(objectNumber,'outputVariableModeBasis')
-        values = np.zeros((X.shape[0], 6))
-        #compute stresses in nodes
-        #nc = len(c)
-        for i in range(len(c)):
-            for j in range(6): #6 stress components
-                values[:,j] += X[:,6*i+j] * c[i] #
-                
-    elif outputVariableType == exu.OutputVariableType.DisplacementLocal:
-        c = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates)
-        X = mbs.GetObjectParameter(objectNumber,'modeBasis')
-        nn = int(X.shape[0]/3)
-        values = (X@c).reshape((nn,3))
-    elif outputVariableType == exu.OutputVariableType.VelocityLocal:
-        c_t = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates_t)
-        X = mbs.GetObjectParameter(objectNumber,'modeBasis')
-        nn = int(X.shape[0]/3)
-        values = (X@c_t).reshape((nn,3))
-    #elif outputVariableType == exu.OutputVariableType.AccelerationLocal:
-    #    c_tt = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates_tt)
-    #    X = mbs.GetObjectParameter(objectNumber,'modeBasis')
-    #    nn = int(X.shape[0]/3)
-    #    values = (X@c_tt).reshape((nn,3))
-    else:
-        raise ValueError("CMSObjectComputeNorm: illegal outputVariableType")
-
-    #restrict evaluation to given nodes
-    if nodeNumberList != []:
-        values = values[nodeNumberList]
-
-    if norm == 'max':
-        return np.max(values, axis=0)
-    elif norm == 'min':
-        return np.min(values, axis=0)
-    elif norm == 'maxNorm':
-        return np.max(np.linalg.norm(values,axis=1))
-    elif norm == 'Mises':
-        from exudyn.physics import VonMisesStress
-        if outputVariableType != exu.OutputVariableType.StressLocal:
-            raise ValueError("CMSObjectComputeMaximum: norm = 'Mises' only possible for outputVariableType == StressLocal")
-        return np.max(VonMisesStress(values))
-
-    raise ValueError("CMSObjectComputeMaximum: unknown norm")
-    return 0
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++++          ObjectFFRFreducedOrderTerms              ++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: compute terms necessary for ObjectFFRFreducedOrder
-#  class used internally in FEMinterface to compute ObjectFFRFreducedOrder dictionary
-#  this class holds all data for ObjectFFRFreducedOrder user functions
-class ObjectFFRFreducedOrderInterface:
-    #**classFunction: initialize ObjectFFRFreducedOrderInterface with FEMinterface class
-    #  initializes the ObjectFFRFreducedOrderInterface with nodes, modes, surface description and reduced system matrices from FEMinterface
-    #  data is then transfered to mbs object with classFunction AddObjectFFRFreducedOrderWithUserFunctions(...)
-    #**input: 
-    #  femInterface: must provide nodes, surfaceTriangles, modeBasis, massMatrix, stiffness; if femInterface=None, an empty ObjectFFRFreducedOrderInterface instance is created which may be used to load data with LoadFromFile()
-    #  roundMassMatrix: use this value to set entries of reduced mass matrix to zero which are below the treshold
-    #  roundStiffnessMatrix: use this value to set entries of reduced stiffness matrix to zero which are below the treshold
-    def __init__(self, femInterface=None, rigidBodyNodeType = 'NodeType.RotationEulerParameters',
-                 roundMassMatrix = 1e-13, roundStiffnessMatrix = 1e-13):
- 
-        if femInterface!=None:
-            #self.femInterface = femInterface #2023-04-20: removed in order to consistenly store class
-            self.modeBasis = femInterface.modeBasis['matrix']
-            nodeArray = femInterface.GetNodePositionsAsArray()
-            self.trigList = femInterface.GetSurfaceTriangles()
-            self.postProcessingModes = femInterface.postProcessingModes
-    
-            stiffnessMatrixCSR = CSRtoScipySparseCSR(femInterface.GetStiffnessMatrix(sparse=True))
-            massMatrixCSR = CSRtoScipySparseCSR(femInterface.GetMassMatrix(sparse=True))
-    
-            #compute reduced mass and stiffness matrices, only flexible coordinates:
-            self.massMatrixReduced = self.modeBasis.T @ massMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
-            self.stiffnessMatrixReduced = self.modeBasis.T @ stiffnessMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
-            RoundMatrix(self.massMatrixReduced, roundMassMatrix*abs(self.massMatrixReduced).max()) #erase off-diagonal terms for higher efficiency ...
-            RoundMatrix(self.stiffnessMatrixReduced, roundStiffnessMatrix*abs(self.stiffnessMatrixReduced).max())
-    
-            #new coordinates:
-            #nODE2 = nNodes*3        #non reduced, full coordinates
-            #nODE2reduced = nModes
-            self.nModes = self.modeBasis.shape[1]                 #number of columns in self.modeBasis is the number of modes to consider
-            self.nNodes = len(nodeArray)                #stored in nNodes x 3 np-array
-            self.dim3D = len(nodeArray[0])              #dimension of position, assuming that one node exists ....
-            
-            self.rigidBodyNodeType = rigidBodyNodeType
-            if str(self.rigidBodyNodeType) == 'NodeType.RotationEulerParameters':
-                self.nODE2rot = 4                       #Euler parameters
-            else:
-                self.nODE2rot = 3
-            
-            self.nODE2rigid = self.dim3D + self.nODE2rot
-            self.nODE2FFRFreduced = self.nODE2rigid + self.nModes
-    
-            self.massMatrixFFRFreduced = np.zeros((self.nODE2FFRFreduced,self.nODE2FFRFreduced)) #create larger FFRF mass matrix
-    
-            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-            #FFRFreduced constant matrices:
-            Phit = np.kron(np.ones(self.nNodes),np.eye(3)).T
-            PhitTM = Phit.T @ massMatrixCSR #LARGE MATRIX COMPUTATION
-            self.xRef = nodeArray.flatten()          #node reference values in single vector (can be added then to q[7:])
-            xRefTilde = ComputeSkewMatrix(self.xRef) #rfTilde without q    
-            self.inertiaLocal = xRefTilde.T @ massMatrixCSR @ xRefTilde #LARGE MATRIX COMPUTATION
-    
-            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-            #prepare CMS matrices (some already given):
-            #according to: A. Zw\"olfer, J. Gerstmayr. The nodal-based floating frame of reference formulation with modal reduction, Acta Mechanica, 2020, submitted.
-            #\bar x = xRef
-            #\tilde \bar x = xRefTilde
-            #\bar Theta = inertiaLocal
-            #\bar mPsiPsi = massMatrixReduced
-            #Psi = self.modeBasis
-            self.Mtt = PhitTM @ Phit
-            self.totalMass = self.Mtt[0,0]                #Mtt must be diagonal matrix with mass in diagonal
-            self.PsiTilde = ComputeSkewMatrix(self.modeBasis)
-            self.chiU = 1./self.totalMass*(PhitTM @ self.xRef)                 #center of mass
-            self.chiUtilde = ComputeSkewMatrix(self.chiU)
-            self.mPsiTildePsi = self.PsiTilde.T @ massMatrixCSR @ self.modeBasis         #LARGE MATRIX COMPUTATION
-            self.mPsiTildePsiTilde = self.PsiTilde.T @ massMatrixCSR @ self.PsiTilde#LARGE MATRIX COMPUTATION
-            self.mPhitTPsi = Phit.T @ massMatrixCSR @ self.modeBasis                #LARGE MATRIX COMPUTATION
-            self.mPhitTPsiTilde = Phit.T @ massMatrixCSR @ self.PsiTilde       #LARGE MATRIX COMPUTATION
-            self.mXRefTildePsi = xRefTilde.T @ massMatrixCSR @ self.modeBasis       #LARGE MATRIX COMPUTATION
-            self.mXRefTildePsiTilde = xRefTilde.T @ massMatrixCSR @ self.PsiTilde    #LARGE MATRIX COMPUTATION
-    
-            #fill already parts of the mass matrix in order to avoid copying this constant data during user function calls:
-            self.massMatrixFFRFreduced[0:3,0:3] = self.Mtt
-            #FillInSubMatrix(self.massMatrixReduced, self.massMatrixFFRFreduced, self.nODE2rigid, self.nODE2rigid)
-            self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:] = self.massMatrixReduced
-
-    #**classFunction: save all data to a data filename; can be used to avoid loading femInterface and FE data
-    #**input: 
-    #  fileName: string for path and file name without ending ==> ".npy" will be added
-    #  fileVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; version must by > 0; the default value will change in future!
-    #**output: stores file
-    def SaveToFile(self, fileName, fileVersion = 1 ):
-        fileExtension = ''
-        if len(fileName) < 4 or fileName[-4:]!='.npy':
-            fileExtension = '.npy'
-
-        try:
-            os.makedirs(os.path.dirname(fileName+fileExtension), exist_ok=True)
-        except:
-            pass #makedirs may fail on some systems, but we keep going
-
-        with open(fileName+fileExtension, 'wb') as f:
-            np.save(f, np.array([int(fileVersion)])) #array allows to add more data in future
-
-            np.save(f, self.modeBasis)
-            np.save(f, self.trigList, allow_pickle=True)
-            np.save(f, self.postProcessingModes, allow_pickle=True)
-            np.save(f, self.massMatrixReduced)
-            np.save(f, self.stiffnessMatrixReduced)
-            
-            infoList = np.array([self.nModes, self.nNodes, self.dim3D, self.nODE2rot, self.nODE2rigid, self.nODE2FFRFreduced])
-            np.save(f, infoList)
-            np.save(f, str(self.rigidBodyNodeType), allow_pickle=True)
-
-            np.save(f, self.xRef)
-
-            np.save(f, self.inertiaLocal)
-            np.save(f, self.Mtt)
-            np.save(f, self.totalMass)
-            np.save(f, self.chiU)
-            np.save(f, self.chiUtilde)
-            np.save(f, self.mPsiTildePsi)
-            np.save(f, self.mPsiTildePsiTilde)
-            np.save(f, self.mPhitTPsi)
-            np.save(f, self.mPhitTPsiTilde)
-            np.save(f, self.mXRefTildePsi)
-            np.save(f, self.mXRefTildePsiTilde)
-    
-            #np.save(f, self.PsiTilde) #large (3 x modeBasis)!, not needed
-            #np.save(f, self.Phit)
-            #np.save(f, self.PhitTM)
-            #np.save(f, self.xRefTilde)
-            #np.save(f, self.massMatrixFFRFreduced) #created when loaded; only needed for user functions
-
-    #**classFunction: load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...). 
-    #this function is much faster than the text-based import functions
-    #**input: 
-    #  fileName: string for path and file name without ending ==> ".npy" will be added
-    #**output: loads data into fem (note that existing values are not overwritten!)
-    def LoadFromFile(self, fileName):
-        fileExtension = ''
-        fileVersion = None
-        if len(fileName) < 4 or fileName[-4:]!='.npy':
-            fileExtension = '.npy'
-        with open(fileName+fileExtension, 'rb') as f:
-            fileVersion = int(np.load(f)[0])
-            self.modeBasis = np.load(f)
-            self.trigList = np.load(f, allow_pickle=True).tolist()
-            self.postProcessingModes = np.load(f, allow_pickle=True)
-            self.massMatrixReduced = np.load(f)
-            self.stiffnessMatrixReduced = np.load(f)
-
-            infoList = list(np.load(f))
-            #print('list=',infoList)
-            [self.nModes, self.nNodes, self.dim3D, self.nODE2rot, self.nODE2rigid, self.nODE2FFRFreduced] = infoList
-
-            self.rigidBodyNodeType = StrNodeType2NodeType(np.load(f, allow_pickle=True))
-
-            #this term is large, but currently needed for markers / constraints!
-            self.xRef = np.load(f)
-
-            #reduced inertia terms
-            self.inertiaLocal = np.load(f)
-            self.Mtt = np.load(f)
-            self.totalMass = np.load(f)
-            self.chiU = np.load(f)
-            self.chiUtilde = np.load(f)
-            self.mPsiTildePsi = np.load(f)
-            self.mPsiTildePsiTilde = np.load(f)
-            self.mPhitTPsi = np.load(f)
-            self.mPhitTPsiTilde = np.load(f)
-            self.mXRefTildePsi = np.load(f)
-            self.mXRefTildePsiTilde = np.load(f)
-            
-            # if fileVersion>1:
-            #     #do things here for higher versions in future
-
-        self.massMatrixFFRFreduced = np.zeros((self.nODE2FFRFreduced,self.nODE2FFRFreduced)) #create larger FFRF mass matrix
-        #fill already parts of the mass matrix in order to avoid copying this constant data during user function calls:
-        self.massMatrixFFRFreduced[0:3,0:3] = self.Mtt
-        #FillInSubMatrix(self.massMatrixReduced, self.massMatrixFFRFreduced, self.nODE2rigid, self.nODE2rigid)
-        self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:] = self.massMatrixReduced
-                
-        return fileVersion
-        
-    ##  UFforce: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFforceFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced\_t):\\ \phantom{XXXX}return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
-
-    #**classFunction: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs; use this function with userfunctions=0 in order to use internal C++ functionality, which is approx. 10x faster; implementation of userfunctions also available for rotation vector (Lie group formulation), which needs further testing
-    #**input:
-    #  exu: the exudyn module
-    #  mbs: a MainSystem object
-    #  positionRef: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  initialVelocity: initial velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  rotationMatrixRef: reference rotation of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder); if [], it becomes the unit matrix
-    #  initialAngularVelocity: initial angular velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  eulerParametersRef: DEPRECATED, use rotationParametersRef or rotationMatrixRef in future: reference euler parameters of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  gravity: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
-    #  UFforce: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; see example
-    #  UFmassMatrix: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; see example
-    #  massProportionalDamping: Rayleigh damping factor for mass proportional damping (multiplied with reduced mass matrix), added to floating frame/modal coordinates only
-    #  stiffnessProportionalDamping: Rayleigh damping factor for stiffness proportional damping, added to floating frame/modal coordinates only (multiplied with reduced stiffness matrix)
-    #  color: provided as list of 4 RGBA values
-    #**example:
-    # #example of a user function for forces:
-    # def UFforceFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced_t):
-    #     return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced_t)
-    # #example of a user function for mass matrix:
-    # def UFmassFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced\_t):
-    #     return cms.UFmassFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)
-    def AddObjectFFRFreducedOrderWithUserFunctions(self, exu, mbs, 
-                                                  positionRef=[0,0,0], 
-                                                  initialVelocity=[0,0,0], 
-                                                  rotationMatrixRef=[], 
-                                                  initialAngularVelocity=[0,0,0],
-                                                  gravity=[0,0,0],
-                                                  UFforce=0, UFmassMatrix=0,
-                                                  massProportionalDamping = 0, stiffnessProportionalDamping = 0,
-                                                  color=[0.1,0.9,0.1,1.],
-                                                  eulerParametersRef=[]):
-
-        #check chosen rotation parameterization:
-        if len(rotationMatrixRef) == 0 and len(eulerParametersRef) == 0:
-            rotationMatrixRef=np.diag([1,1,1])
-        elif len(rotationMatrixRef) != 0 and len(eulerParametersRef) != 0:
-            raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions: rotationMatrixRef or eulerParametersRef must be zero')
-        
-        if len(eulerParametersRef) != 0:
-            if str(self.rigidBodyNodeType) != 'NodeType.RotationEulerParameters':
-                raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions: inconsistent reference rotation parameters and rigidBodyNodeType')
-            #compute initial euler parameter velocities from angular velocity vector
-            self.rotationParameters_t0 = AngularVelocity2EulerParameters_t(initialAngularVelocity, eulerParametersRef)
-            self.rotationParameters0 = eulerParametersRef
-    
-            #rigid body node for ObjectFFRFreducedOrder
-            self.nRigidBody = mbs.AddNode(eii.NodeRigidBodyEP(referenceCoordinates=list(positionRef)+list(eulerParametersRef), 
-                                                initialVelocities=list(initialVelocity)+list(self.rotationParameters_t0)))
-            self.rigidBodyNodeType = exu.NodeType.RotationEulerParameters
-        else:
-            #compute initial rotation parameter velocities from angular velocity vector
-            nodeItem = GetRigidBodyNode(nodeType=self.rigidBodyNodeType, position=positionRef, 
-                                        velocity=initialVelocity, rotationMatrix=rotationMatrixRef, 
-                                        angularVelocity=initialAngularVelocity)
-            self.nRigidBody = mbs.AddNode(nodeItem)
-                        
-            self.rotationParameters0 = nodeItem.referenceCoordinates[3:]
-            self.rotationParameters_t0 = nodeItem.initialVelocities[3:]
-
-        #print("self.rotationParameters0 =",self.rotationParameters0 )
-        #print("self.rotationParameters_t0 =",self.rotationParameters_t0 )
-
-        self.gravity = gravity
-        self.loadGravity = None #only defined if LoadMassProportional is added
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #check if postProcessingModes exist
-        outputVariableModeBasis = []
-        outputVariableTypeModeBasis = 0
-        #FEM: self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
-
-        if 'matrix' in self.postProcessingModes:
-            #check FEMinterface if modes exist:
-            if str(self.postProcessingModes['outputVariableType']) == 'OutputVariableType.StressLocal':
-                outputVariableTypeModeBasis = exu.OutputVariableType.StressLocal
-            elif str(self.postProcessingModes['outputVariableType']) == 'OutputVariableType.StrainLocal':
-                outputVariableTypeModeBasis = exu.OutputVariableType.StrainLocal
-            else:
-                raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions(...): invalid outputVariableType in postProcessingModes')
-
-            outputVariableModeBasis  = self.postProcessingModes['matrix']
-            
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #generic node for modal coordinates in ObjectFFRFreducedOrder
-        self.nGenericODE2 = mbs.AddNode(eii.NodeGenericODE2(numberOfODE2Coordinates=self.nModes,
-                                          referenceCoordinates=[0]*self.nModes,
-                                          initialCoordinates=[0]*self.nModes,
-                                          initialCoordinates_t=[0]*self.nModes))
-
-        stiffnessMatrixMC = exu.MatrixContainer()
-        stiffnessMatrixMC.SetWithDenseMatrix(self.stiffnessMatrixReduced,useDenseMatrix=False)
-
-        self.dampingMatrixReduced = massProportionalDamping*self.massMatrixReduced+stiffnessProportionalDamping*self.stiffnessMatrixReduced
-        if (massProportionalDamping != 0 or stiffnessProportionalDamping != 0):
-            dampingMatrixMC = exu.MatrixContainer()
-            dampingMatrixMC.SetWithDenseMatrix(self.dampingMatrixReduced, useDenseMatrix=False)
-        else:
-            dampingMatrixMC=[]
-
-        massMatrixMC = exu.MatrixContainer()
-        
-        #not needed, as not included in C++ computation until full CMS functionality
-        #factMass = 1.
-        #if UFmassMatrix != 0:
-        #    factMass = 0.
-        #massMatrixMC.SetWithDenseMatrix(factMass*self.massMatrixReduced,useDenseMatrix=False)
-        
-        massMatrixMC.SetWithDenseMatrix(self.massMatrixReduced,useDenseMatrix=False)
-        #emptyMC = exu.MatrixContainer()
-
-        #add generic body for FFRF-Object:
-        if UFmassMatrix == 0 or UFforce == 0:
-            
-            self.oFFRFreducedOrder = mbs.AddObject(eii.ObjectFFRFreducedOrder(nodeNumbers = [self.nRigidBody, self.nGenericODE2], 
-                                                                stiffnessMatrixReduced=stiffnessMatrixMC, 
-                                                                massMatrixReduced=massMatrixMC,
-                                                                dampingMatrixReduced=dampingMatrixMC,
-                                                                modeBasis=self.modeBasis,
-                                                                referencePositions = self.xRef,
-                                                                physicsMass=self.totalMass,
-                                                                physicsInertia=self.inertiaLocal,
-                                                                physicsCenterOfMass=self.chiU,
-                                                                mPsiTildePsi = self.mPsiTildePsi,
-                                                                mPsiTildePsiTilde = self.mPsiTildePsiTilde,
-                                                                mPhitTPsi = self.mPhitTPsi,
-                                                                mPhitTPsiTilde = self.mPhitTPsiTilde,
-                                                                mXRefTildePsi = self.mXRefTildePsi,
-                                                                mXRefTildePsiTilde = self.mXRefTildePsiTilde,
-                                                                outputVariableModeBasis = outputVariableModeBasis,
-                                                                outputVariableTypeModeBasis = outputVariableTypeModeBasis,
-                                                                #
-                                                                forceUserFunction=UFforce,
-                                                                massMatrixUserFunction=UFmassMatrix,
-                                                                computeFFRFterms=True, #only compute user function, no internal components ...
-                                                                visualization=eii.VObjectFFRF(triangleMesh = self.trigList, 
-                                                                                            color=color,
-                                                                                            showNodes = True)))
-
-            if np.array(gravity) @ np.array(gravity) != 0.:
-                mBody = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=self.oFFRFreducedOrder))
-                self.loadGravity = mbs.AddLoad(eii.LoadMassProportional(markerNumber=mBody, loadVector= gravity))
-
-        else:
-            self.oFFRFreducedOrder = mbs.AddObject(eii.ObjectFFRFreducedOrder(nodeNumbers = [self.nRigidBody, self.nGenericODE2], 
-                                                                stiffnessMatrixReduced=stiffnessMatrixMC, 
-                                                                massMatrixReduced=massMatrixMC,
-                                                                dampingMatrixReduced=dampingMatrixMC,
-                                                                modeBasis=self.modeBasis,
-                                                                referencePositions = self.xRef,
-                                                                forceUserFunction=UFforce,
-                                                                massMatrixUserFunction=UFmassMatrix,
-                                                                computeFFRFterms=False, #only compaute user function, no internal components ...
-                                                                visualization=eii.VObjectFFRF(triangleMesh = self.trigList, 
-                                                                                            color=color,
-                                                                                            showNodes = True)))
-
-        dictReturn = {'nRigidBody':self.nRigidBody,
-                      'nGenericODE2':self.nGenericODE2,
-                      'oFFRFreducedOrder':self.oFFRFreducedOrder,
-                      'loadGravity':self.loadGravity}
-
-        #not needed any more; Euler parameter constraint included now in ObjectFFRFreducedOrder
-        #if self.nODE2rot == 4: #for euler parameters --> add body to constrain EP
-        #    epsMass = 1e-3#needed, if not all ffrf terms are included
-        #    #add rigid body to node for Euler Parameter constraint:
-        #    oAddedBody = mbs.AddObject(ObjectRigidBody(nodeNumber=self.nRigidBody, physicsMass=epsMass, 
-        #                                               physicsInertia=[epsMass,epsMass,epsMass,0,0,0])) 
-        #    dictReturn['oAddedBody'] = oAddedBody
-
-        return dictReturn
-
-
-
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: CMS mass matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!
-    def UFmassFFRFreducedOrder(self, exu, mbs, t, qReduced, qReduced_t):
-
-        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
-        A = Avec.reshape((3,3))
-        #compute rotation parameters including reference values:
-        rp = np.array(qReduced[self.dim3D:self.nODE2rigid]) + np.array(self.rotationParameters0) #add reference values, q are only the change w.r.t. reference values!
-        if self.rigidBodyNodeType == exu.NodeType.RotationEulerParameters:
-            G = EulerParameters2GLocal(rp)
-        elif self.rigidBodyNodeType == exu.NodeType.RotationRotationVector:
-            G = RotationVector2GLocal(rp)
-        elif self.rigidBodyNodeType ==exu.NodeType.RotationRxyz:
-            G = RotXYZ2GLocal(rp)
-        else:
-            raise ValueError('UFmassFFRFreducedOrder: rotation parameterization not implemented')
-        
-
-        zetaI = VectorDiadicUnitMatrix3D(qReduced[self.nODE2rigid:])
-        #zeta_tI = VectorDiadicUnitMatrix3D(qReduced_t[self.nODE2rigid:]) #not needed
-
-        #print("Mtt=",self.massMatrixFFRFreduced[0:3,0:3])
-        #print("Mff=",self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:])
-        #Mtt and Mff already filled into massMatrixFFRFreduced
-        #Mtr:
-        Mtr = -A @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ G
-        self.massMatrixFFRFreduced[0:self.dim3D, self.dim3D:self.dim3D+self.nODE2rot] = Mtr
-        self.massMatrixFFRFreduced[self.dim3D:self.dim3D+self.nODE2rot, 0:self.dim3D] = Mtr.T
-
-        #Mtf:
-        Mtf = A @ self.mPhitTPsi
-        self.massMatrixFFRFreduced[0:self.dim3D, self.nODE2rigid:] = Mtf 
-        self.massMatrixFFRFreduced[self.nODE2rigid:, 0:self.dim3D] = Mtf.T
-
-        #Mrf:
-        Mrf = -G.T @ (self.mXRefTildePsi + zetaI.T @ self.mPsiTildePsi)
-        self.massMatrixFFRFreduced[self.dim3D:self.nODE2rigid, self.nODE2rigid:] = Mrf
-        self.massMatrixFFRFreduced[self.nODE2rigid:, self.dim3D:self.nODE2rigid] = Mrf.T
-
-        #Mrr:
-        self.massMatrixFFRFreduced[self.dim3D:self.nODE2rigid, self.dim3D:self.nODE2rigid] = G.T@(self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + 
-                                                                            zetaI.T @ self.mXRefTildePsiTilde.T + 
-                                                                            zetaI.T @ self.mPsiTildePsiTilde @ zetaI)@G
-
-        #print("Mtr=",Mtr)
-        #print("Mtf=",Mtf)
-        #print("Mrf=",Mrf)
-        #print("Mrr=",self.massMatrixFFRFreduced[self.dim3D:self.nODE2rigid, self.dim3D:self.nODE2rigid])
-
-        return self.massMatrixFFRFreduced
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: CMS force matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!
-    def UFforceFFRFreducedOrder(self, exu, mbs, t, qReduced, qReduced_t):
-        force = np.zeros(self.nODE2FFRFreduced)
-
-        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
-        A = Avec.reshape((3,3))
-
-        #compute rotation parameters including reference values:
-        rp = np.array(qReduced[self.dim3D:self.nODE2rigid]) + np.array(self.rotationParameters0) #add reference values, q are only the change w.r.t. reference values!
-        # if len(ep) != 4: 
-        #     print("ERROR: equations only implemented for Euler parameters case (terms missing for other formulations)"); exit()
-
-        if self.rigidBodyNodeType == exu.NodeType.RotationEulerParameters:
-            G = EulerParameters2GLocal(rp)
-        elif self.rigidBodyNodeType == exu.NodeType.RotationRotationVector:
-            G = RotationVector2GLocal(rp)
-        elif self.rigidBodyNodeType ==exu.NodeType.RotationRxyz:
-            G = RotXYZ2GLocal(rp)
-            #time derivatives:
-            rp_t = np.array(qReduced_t[self.dim3D:self.nODE2rigid])
-            G_t = RotXYZ2GLocal_t(rp, rp_t)
-            G_tRp_t = G_t @ rp_t
-        else:
-            raise ValueError('UFforceFFRFreducedOrder: rotation parameterization not implemented')
-
-        zetaI = VectorDiadicUnitMatrix3D(qReduced[self.nODE2rigid:])
-        zeta_tI = VectorDiadicUnitMatrix3D(qReduced_t[self.nODE2rigid:])
-
-        omega3D = G @ np.array(qReduced_t[self.dim3D:self.nODE2rigid])
-        omega3Dtilde = Skew(omega3D)
-        IZetadiadicOmega = np.kron(np.eye(self.nModes), np.array(omega3D)).T
-
-        qReducedFF = np.array(qReduced[self.nODE2rigid:])
-        qReduced_tFF = np.array(qReduced_t[self.nODE2rigid:])
-
-        #CMS:
-        force[0:self.dim3D] = (A @ omega3Dtilde @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ omega3D + 
-                               2*A @ self.mPhitTPsiTilde @ zeta_tI @ omega3D) #identical to FFRF up to 1e-16
-    
-        force[self.dim3D:self.nODE2rigid] = (-G.T @ omega3Dtilde @ (self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + 
-                                                                    zetaI.T @ self.mXRefTildePsiTilde.T + 
-                                                                    zetaI.T @ self.mPsiTildePsiTilde @ zetaI ) @ omega3D - 
-                                   2*G.T @ (self.mXRefTildePsiTilde @ zeta_tI + zetaI.T @ self.mPsiTildePsiTilde @ zeta_tI ) @ omega3D)  #identical to FFRF up to 1e-16
-        
-        force[self.nODE2rigid:] = (IZetadiadicOmega.T @ (self.mXRefTildePsiTilde.T + self.mPsiTildePsiTilde @ zetaI) @ omega3D + 
-                                   2 * self.mPsiTildePsi.T @ zeta_tI @ omega3D #identical to FFRF up to 1e-16
-                                   - self.stiffnessMatrixReduced @ qReducedFF  #stiffness term added to user function, for better distinguishing with internal FFRF
-                                   - self.dampingMatrixReduced @ qReduced_tFF) #damping term added to user function, for better distinguishing with internal FFRF
-
-        #print("fQV=", force)
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #additional terms for Euler angles:
-        if self.rigidBodyNodeType == exu.NodeType.RotationRxyz:
-            force[0:self.dim3D] += A @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ G_tRp_t
-            
-            force[self.dim3D:self.nODE2rigid] += -G.T @ (self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + 
-                                                         zetaI.T @ self.mXRefTildePsiTilde.T + 
-                                                         zetaI.T @ self.mPsiTildePsiTilde @ zetaI ) @ G_tRp_t
-            
-            force[self.nODE2rigid:] += (self.mXRefTildePsi.T + self.mPsiTildePsi.T @ zetaI) @ G_tRp_t
-
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #add gravity (needs to be tested):
-        if True:
-            force[0:self.dim3D] += self.totalMass*np.array(self.gravity)
-            force[self.dim3D:self.nODE2rigid] += G.T @ (Skew(self.chiU) @ (self.totalMass*A.T @ np.array(self.gravity)))
-            force[self.nODE2rigid:] += self.mPhitTPsi.T @ (A.T @ np.array(self.gravity))
-
-            #force[nODE2rigid:] += modeBasis.T @ PhitTM.T @ (A.T @ g)
-
-        return force
-
-    #**classFunction: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs; use this function in order to use internal C++ functionality, which is approx. 10x faster than AddObjectFFRFreducedOrderWithUserFunctions(...)
-    #**input:
-    #  exu: the exudyn module
-    #  mbs: a MainSystem object
-    #  positionRef: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  initialVelocity: initial velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  rotationMatrixRef: reference rotation of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder); if [], it becomes the unit matrix
-    #  initialAngularVelocity: initial angular velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
-    #  massProportionalDamping: Rayleigh damping factor for mass proportional damping, added to floating frame/modal coordinates only
-    #  stiffnessProportionalDamping: Rayleigh damping factor for stiffness proportional damping, added to floating frame/modal coordinates only
-    #  gravity: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
-    #  color: provided as list of 4 RGBA values
-    def AddObjectFFRFreducedOrder(self, mbs, 
-                                  positionRef=[0,0,0], initialVelocity=[0,0,0], 
-                                  rotationMatrixRef=[], initialAngularVelocity=[0,0,0],
-                                  massProportionalDamping = 0, stiffnessProportionalDamping = 0,
-                                  gravity = [0,0,0],
-                                  color=[0.1,0.9,0.1,1.]):
-        import exudyn as exu
-        return self.AddObjectFFRFreducedOrderWithUserFunctions(exu=exu, mbs=mbs, 
-                                                  positionRef=positionRef, initialVelocity=initialVelocity, rotationMatrixRef=rotationMatrixRef, 
-                                                  initialAngularVelocity=initialAngularVelocity,
-                                                  massProportionalDamping = massProportionalDamping, stiffnessProportionalDamping = stiffnessProportionalDamping,
-                                                  gravity = gravity, color=color)
-    
-        
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: helper calss for function ComputeHurtyCraigBamptonModes, declaring some computation options. It offers the following options:\\
-# - allBoundaryNodes:     compute a single static mode for every boundary coordinate\\
-# - RBE2:                 static modes only for rigid body motion at boundary nodes; using rigid boundary surfaces (additional stiffening)\\
-# - RBE3:                 static modes only for rigid body motion at boundary nodes; averaged rigid body motion at boundary surfaces (leads to deformation at boundaries)\\
-# - noStaticModes:        do not compute static modes, only eigen modes (not recommended; usually only for tests)
-class HCBstaticModeSelection(Enum):
-    allBoundaryNodes = 1    #compute a single static mode for every boundary coordinate; if this is used, 6 constraints need to be added to the ObjectFFRFreducedOrder, otherwise there is additional rigid body motion!
-    RBE2 = 2                #static modes which include (exact / constrained) rigid body motion (3x translation, 3x rotation) at boundary / interface; recommended as basic / simpler method, however, leads to additional stiffening and stress concentration at boundary
-    RBE3 = 3                #static modes which include averaged rigid body motion (3x translation, 3x rotation) at boundary / interface; recommended as advanced method; may lead to overly large deformation at boundary
-    noStaticModes = 4       #do not compute static modes, only eigen modes (not really recommended; usually only for tests)
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++++   FEMinterface - finite element interface class   ++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: general interface to different FEM / mesh imports and export to EXUDYN functions
-#         use this class to import meshes from different meshing or FEM programs (NETGEN/NGsolve \cite{NGsolve2022}, ABAQUS, ANSYS, ..) and store it in a unique format
-#         do mesh operations, compute eigenmodes and reduced basis, etc.
-#         load/store the data efficiently with LoadFromFile(...), SaveToFile(...)  if import functions are slow
-#         export to EXUDYN objects
-class FEMinterface:
-    #**classFunction: initalize all data of the FEMinterface by, e.g., \texttt{fem = FEMinterface()}
-    #**example:
-    # #**** this is not an example, just a description for internal variables ****
-    # #default values for member variables stored internally in FEMinterface fem and typical structure:
-    # fem.nodes = {}                 # {'Position':[[x0,y0,z0],...], 'RigidBodyRxyz':[[x0,y0,z0],...],  },...]                     #dictionary of different node lists
-    # fem.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
-    # fem.massMatrix = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
-    # fem.stiffnessMatrix=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
-    # fem.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
-    # fem.nodeSets = []              # [{'Name':'identifier', 'NodeNumbers':[n_0,...,n_ns], 'NodeWeights':[w_0,...,w_ns]},...]     #for boundary conditions, etc.
-    # fem.elementSets = []           # [{'Name':'identifier', 'ElementNumbers':[n_0,...,n_ns]},...]                                #for different volumes, etc.
-    # fem.modeBasis = {}             # {'matrix':[[Psi_00,Psi_01, ..., Psi_0m],...,[Psi_n0,Psi_n1, ..., Psi_nm]],'type':'NormalModes'} #'NormalModes' are eigenmodes, 'HCBmodes' are Craig-Bampton modes including static modes
-    # fem.eigenValues = []           # [ev0, ev1, ...]                                                                             #eigenvalues according to eigenvectors in mode basis
-    # fem.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
-    def __init__(self):
-        self.nodes = {}                 # {'Position':[[x0,y0,z0],...], 'RigidBodyRxyz':[[x0,y0,z0],...],  },...]                     #dictionary of different node lists
-        self.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
-        self.massMatrix = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
-        self.stiffnessMatrix=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
-        # self.massMatrixReduced = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
-        # self.stiffnessMatrixReduced=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
-        self.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
-        self.nodeSets = []              # [{'Name':'identifier', 'NodeNumbers':[n_0,...,n_ns], 'NodeWeights':[w_0,...,w_ns]},...]     #for boundary conditions, etc.
-        self.elementSets = []           # [{'Name':'identifier', 'ElementNumbers':[n_0,...,n_ns]},...]                                #for different volumes, etc.
-
-        self.modeBasis = {}             # {'matrix':[[Psi_00,Psi_01, ..., Psi_0m],...,[Psi_n0,Psi_n1, ..., Psi_nm]],'type':'NormalModes'}
-        self.eigenValues = []           # [ev0, ev1, ...]                                                                             #eigenvalues according to eigenvectors in mode basis
-        self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
-        #self.massMatrix = {}           # {'Shape':[rows,columns], 'SparseCSR':[[r0,c0,value0],[r1,c1,value1], ... ],  }             #currently only in SparseCSR format allowed!
-
-        #some additional information, needed for checks and easier operation
-        self.coordinatesPerNodeType = {'Position':3, 'Position2D':2, 'RigidBodyRxyz':6, 'RigidBodyEP':7} #number of coordinates for a certain node type
-
-
-    #**classFunction: save all data (nodes, elements, ...) to a data filename; this function is much faster than the text-based import functions
-    #**input: 
-    #  fileName: string for path and file name without ending ==> ".npy" will be added
-    #  fileVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; version must by > 0
-    #**output: stores file
-    def SaveToFile(self, fileName, fileVersion = 13 ):
-        fileExtension = ''
-        if len(fileName) < 4 or fileName[-4:]!='.npy':
-            fileExtension = '.npy'
-                    
-        try:
-            os.makedirs(os.path.dirname(fileName+fileExtension), exist_ok=True)
-        except:
-            pass #makedirs may fail on some systems, but we keep going
-
-        with open(fileName+fileExtension, 'wb') as f:
-            if fileVersion>0:
-                dataVersion = np.array([int(fileVersion)])
-                np.save(f, dataVersion)
-
-            np.save(f, self.nodes, allow_pickle=True) #allow_pickle=True for lists or dictionaries
-            np.save(f, self.elements, allow_pickle=True)
-            np.save(f, self.massMatrix)
-            np.save(f, self.stiffnessMatrix)
-            np.save(f, self.surface, allow_pickle=True)
-            np.save(f, self.nodeSets, allow_pickle=True)
-            np.save(f, self.elementSets, allow_pickle=True)
-            np.save(f, self.modeBasis, allow_pickle=True)
-            np.save(f, self.eigenValues, allow_pickle=True)
-            np.save(f, self.postProcessingModes, allow_pickle=True)
-            #not needed
-            # if fileVersion>0:
-            #     np.save(f, self.massMatrixReduced)
-            #     np.save(f, self.stiffnessMatrixReduced)
-
-    #**classFunction: load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...). 
-    #this function is much faster than the text-based import functions
-    #**input: 
-    #  fileName: string for path and file name without ending ==> ".npy" will be added
-    #  forceVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; for old files, use forceVersion=0
-    #**output: loads data into fem (note that existing values are not overwritten!); returns file version or None if version is not available
-    def LoadFromFile(self, fileName, forceVersion=None):
-        fileExtension = ''
-        fileVersion = None
-        if len(fileName) < 4 or fileName[-4:]!='.npy':
-            fileExtension = '.npy'
-            
-        try:
-            with open(fileName+fileExtension, 'rb') as f:
-                if forceVersion==None or forceVersion>0:
-                    versionData = np.load(f)
-                    #print('LoadFromFile:file version:', versionData)
-                    if forceVersion != None:
-                        fileVersion = int(versionData[0])
-                else:
-                    fileVersion=forceVersion
-                    
-                self.nodes = np.load(f, allow_pickle=True).all()   #allow_pickle=True for lists or dictionaries; .all() for dictionaries
-                self.elements = list(np.load(f, allow_pickle=True))#list(...) to convert into list again!
-                self.massMatrix = np.load(f)
-                self.stiffnessMatrix = np.load(f)
-                self.surface = list(np.load(f, allow_pickle=True))
-                self.nodeSets =  list(np.load(f, allow_pickle=True))
-                self.elementSets = list(np.load(f, allow_pickle=True))
-                self.modeBasis = np.load(f, allow_pickle=True).all()
-                self.eigenValues = list(np.load(f, allow_pickle=True))
-                self.postProcessingModes = np.load(f, allow_pickle=True).all()
-                # if fileVersion>0:
-                #     self.massMatrixReduced = np.load(f)
-                #     self.stiffnessMatrixReduced = np.load(f)
-        except Exception as e:
-            print('\n\nFEMinterface.LoadFromFile(...) failed; check filename; if your data file is using old format, try with: LoadFromFile(self, fileName=..., forceVersion=0)\n')
-            raise
-        return fileVersion
-
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #ABAQUS import functions
-
-    #**classFunction: import nodes and elements from Abaqus input file and create surface elements; 
-    #                 node numbers in elements are converted from 1-based indices to python's 0-based indices;
-    #                 This function can only import one part or instance; this means that you have to merge all 
-    #                 instances or parts in order to use this function for import of flexible bodies for order reduction methods
-    #**input:
-    #  fileName: file name incl. path
-    #  typeName: this is what is searched for regarding nodes and elements, see your .inp file
-    #  name: if there are several parts, this name should address the according part name
-    #  verbose: use True for some debug information
-    #  createSurfaceTrigs: if True, triangles are created for visualization (triangles both for Tet and Hex elements)
-    #  surfaceTrigsAll: if False, visualization triangles are created at the surface; if True, surface triangles are created also for interior elements
-    #**notes: only works for Hex8, Hex20, Tet4 and Tet10 (C3D4, C3D8, C3D8R, C3D10, C3D20, C3D20R) elements; some functionality is untested and works in limited cases; only works for one single part or instance
-    #**output: return node numbers as numpy array
-    def ImportFromAbaqusInputFile(self, fileName, typeName='Part', name='Part-1', verbose=False,
-                                  createSurfaceTrigs=True, surfaceTrigsAll=False):
-        #def ImportABAQUS(fileName, typeName, name, verbose = False):
-        fileLines = []
-        if verbose: print("ImportFromAbaqusInputFile: read file name=", fileName)
-        file=open(fileName,'r') 
-        fileLines = file.readlines()
-        file.close()
-        
-        if verbose: print("read", len(fileLines), "lines")
-    
-        lineCnt = 0          #current counter for lines, makes life simpler
-        nLines = len(fileLines)
-        typeNameFound = False
-        elementsDict = {'Name':'elements'} #this is the destination for elements
-        #+++++++++++++++++++++++++++++++++++++++++++++
-        #find *Instance or *Part
-        strTypeName = '*'+typeName
-    
-        while lineCnt < nLines and not typeNameFound:
-            line = fileLines[lineCnt]
-            if line[0:len(strTypeName)] == strTypeName:
-                typeNameFound = True
-                if verbose: print("found ", strTypeName, "in line", lineCnt)
-                
-            lineCnt += 1
-    
-        if not typeNameFound: raise ValueError("ImportFromAbaqusInputFile: did not find keyword '"+strTypeName+"'")
-    
-        #+++++++++++++++++++++++++++++++++++++++++++++
-        #read *Node keyword
-        if fileLines[lineCnt][0:5] == '*Node':
-            lineCnt += 1
-        else:
-            raise ValueError("ImportFromAbaqusInputFile: expected *Node in line"+str(lineCnt+1)+', but received: '+fileLines[lineCnt])
-        
-        #+++++++++++++++++++++++++++++++++++++++++++++
-        #read nodes:
-        nodeReadFinished = False
-        nodes=[]
-        while lineCnt < nLines and not nodeReadFinished:
-            line = fileLines[lineCnt]
-        
-            if line[0] != '*': #check if nodes section has finished
-                lineData = line.split(',') #split into values
-                if len(lineData) != 4:
-                    raise ValueError("ImportFromAbaqusInputFile: Expected node number and 3 coordinates, line "+str(lineCnt))
-                else:
-                    v = []
-                    for i in range(3):
-                        v+=[float(lineData[i+1])] 
-                    nodes += [v] #add node data
-                    #if verbose: print("node=",v)
-                lineCnt += 1#do not increase counter if * found
-            else:
-                nodeReadFinished = True
-
-        if verbose: print("imported ", len(nodes), "nodes")
-    
-        #+++++++++++++++++++++++++++++++++++++++++++++
-        #read *Element keyword
-        #expect something like: *Element, type= C3D20 
-        availableElementTypesNodes={'C3D20':20, 'C3D20R':20, 'C3D8':8, 'C3D8R':8, #Hex
-                                    'C3D4':4, 'C3D10':10, #Tet standard
-                                    'C3D10H':10, 'C3D10MH':10, 'C3D10HS':10, #Tet advanced
-                                    }
-        elementTypeConversion={'C3D8':'Hex8', 'C3D20':'Hex20', 
-                               'C3D8R':'Hex8', 'C3D20R':'Hex20', #same nodes as C3D8 / C3D20, only reduced integration
-                               'C3D4':'Tet4', 'C3D10':'Tet10',
-                               'C3D10H':'Tet10', 'C3D10MH':'Tet10', 'C3D10HS':'Tet10',
-                               }
-        elementSectionFound = False
-        elementTypeName = ''
-        while lineCnt < nLines and not elementSectionFound:
-            line = fileLines[lineCnt]
-            #print("now=", line)
-            if line[0:len('*Element')] == '*Element':
-                elementSectionFound = True
-                elementTypeName=line.split(',')[1].split('=')[1].strip()
-                if verbose: print("found *Element in line", lineCnt, 'element type=',elementTypeName)
-                
-                if not (elementTypeName in availableElementTypesNodes):
-                    raise ValueError("ImportFromAbaqusInputFile: element type '"+elementTypeName+"' can not yet be imported")
-                
-            lineCnt += 1
-    
-        if not elementSectionFound: 
-            raise ValueError("ImportFromAbaqusInputFile: did not find keyword *Element ")
-    
-        elementType= elementTypeConversion[elementTypeName]
-        if not(elementTypeName in elementsDict):
-            elementsDict[elementType] = []
-    
-        #+++++++++++++++++++++++++++++++++++++++++++++
-        #read elements:
-        elementReadFinished = False
-        nElementNodes = availableElementTypesNodes[elementTypeName] #this is the expected number of nodes for element type
-        elementCnt = 0
-        while lineCnt < nLines and not elementReadFinished:
-            line = fileLines[lineCnt]
-            #print("read element line:",line)
-        
-            if line[0] != '*': #check if element section has finished
-                lineStr = line.strip() #cut spaces at end in order to detect ',' at end
-                while lineStr[-1] == ',' and lineCnt < nLines:
-                    lineCnt += 1
-                    line = fileLines[lineCnt]
-                    if line[0] == '*': 
-                        raise ValueError("ImportFromAbaqusInputFile: while reading elements, got invalid format of line "+str(lineCnt+1))
-                    lineStr += line
-                    #print("   extended line:",lineStr)
-                    
-                lineData = lineStr.strip().split(',') #split into values
-                
-                if len(lineData) != nElementNodes+1:
-                    raise ValueError("ImportFromAbaqusInputFile: Expected element and "+str(nElementNodes)+" node numbers in line "+str(lineCnt))
-                else:
-                    v = []
-                    for i in range(nElementNodes):
-                        v+=[int(lineData[i+1])-1] #changed from float
-                    elementsDict[elementType] += [v]
-                    elementCnt += 1
-            else:
-                elementReadFinished = True
-            lineCnt += 1
-        
-        if verbose: print("imported ", elementCnt, "elements")
-
-        #FEMinterface:
-        self.elements += [elementsDict]
-        self.nodes['Position'] = np.array(nodes)
-
-
-        #convert elements to triangles for drawing:
-        if createSurfaceTrigs:
-            if not surfaceTrigsAll:
-                self.VolumeToSurfaceElements(verbose) #create surface from imported elements
-            else:
-                if verbose:
-                    print('create surface triangles for all elements; may be large number of triangles for visualization ...')
-                trigList = []
-                if 'Hex8' in elementsDict:
-                    for element in elementsDict['Hex8']:
-                        trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
-                if 'Hex20' in elementsDict:
-                    for element in elementsDict['Hex20']:
-                        trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
-                if 'Tet4' in elementsDict:
-                    for element in elementsDict['Tet4']:
-                        trigList += ConvertTetToTrigs(element) #node numbers are already 0-based
-                if 'Tet10' in elementsDict:
-                    for element in elementsDict['Tet10']:
-                        trigList += ConvertTetToTrigs(element) #node numbers are already 0-based
-        
-                self.surface += [{'Name':'meshSurface', 'Trigs':trigList}]    # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
-
-
-        return np.array(nodes)
-        
-        #return [np.array(nodes), elementsDict]
-
-
-
-
-    #**classFunction: read mass matrix from compressed row text format (exported from Abaqus); in order to export system matrices, write the following lines in your Abaqus input file:
-    #*STEP
-    #*MATRIX GENERATE, STIFFNESS, MASS
-    #*MATRIX OUTPUT, STIFFNESS, MASS, FORMAT=COORDINATE
-    #*End Step
-    def ReadMassMatrixFromAbaqus(self, fileName, type='SparseRowColumnValue'):
-        self.massMatrix = np.loadtxt(fileName)
-        self.massMatrix[:,0] -= 1 #convert 1-based indices to 0-based indices
-        self.massMatrix[:,1] -= 1
-
-    #**classFunction: read stiffness matrix from compressed row text format (exported from Abaqus)
-    def ReadStiffnessMatrixFromAbaqus(self, fileName, type='SparseRowColumnValue'):
-        self.stiffnessMatrix = np.loadtxt(fileName)
-        self.stiffnessMatrix[:,0] -= 1 #convert 1-based indices to 0-based indices
-        self.stiffnessMatrix[:,1] -= 1
-
-
-
-    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: import mesh from NETGEN/NGsolve and setup mechanical problem
-    #**notes: The interface to NETGEN/NGsolve has been created together with Joachim Sch\"oberl, main developer 
-    #  of NETGEN/NGsolve \cite{Schoeberl1997,NGsolve2014}; Thank's a lot!
-    #  download NGsolve at: https://ngsolve.org/
-    #  NGsolve needs Python 3.7 (64bit) ==> use according EXUDYN version!
-    #  note that node/element indices in the NGsolve mesh are 1-based and need to be converted to 0-base!
-    #**input:
-    #    mesh: a previously created \texttt{ngs.mesh} (NGsolve mesh, see examples)
-    #    youngsModulus: Young's modulus used for mechanical model
-    #    poissonsRatio: Poisson's ratio used for mechanical model
-    #    density: density used for mechanical model
-    #    meshOrder: use 1 for linear elements and 2 for second order elements (recommended to use 2 for much higher accuracy!)
-    #    verbose: set True to print out some status information
-    #**notes: setting ngsolve.SetNumThreads(nt) you can select the number of treads that are used for assemble or other functionality with NGsolve functionality 
-    #**output: creates according nodes, elements, in FEM and returns [bfM, bfK, fes] which are the (mass matrix M, stiffness matrix K) bilinear forms and the finite element space fes
-    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
-    def ImportMeshFromNGsolve(self, mesh, density, youngsModulus, poissonsRatio, verbose = False, 
-                              computeEigenmodes = False, meshOrder = 1, **kwargs):
-        #OLD, DELETE 2022-01-01:
-        #    computeEigenmodes: set True to use NGsolve for eigenmode computation instead of ComputeEigenmodes
-        #    numberOfModes: if computeEigenmodes==True: number of eigen modes computed with NGsolve; default=10
-        #    maxEigensolveIterations: if computeEigenmodes==True: maximum number of iterations for iterative eigensolver; default=40
-        #    excludeRigidBodyModes: if computeEigenmodes==True: if rigid body modes are expected (in case of free-free modes), then this number specifies the number of eigenmodes to be excluded in the stored basis (usually 6 modes in 3D)
-        import ngsolve as ngs
-        if meshOrder < 1 or meshOrder > 2:
-            raise ValueError('mesh order > 1 or mesh order < 2 not supported!')
-            
-        if meshOrder == 2:
-            mesh.ngmesh.SecondOrder()
-
-        if verbose: print("NGsolve create mechanics FE space ...")
-        if meshOrder == 1:
-            fes = ngs.VectorH1(mesh, order=meshOrder) #add interleaved = True to get xyzxyz sorting
-        else:
-            fes = ngs.NodalFESpace(mesh, order=meshOrder)**3
-            
-        #create finite element spaces for mass matrix and stiffness matrix    
-        u = fes.TrialFunction()
-        v = fes.TestFunction()
-        bfK = ngs.BilinearForm(fes)
-        bfM = ngs.BilinearForm(fes)
-
-        def sigma(eps, mu, lam):
-            return 2*mu*eps + lam*ngs.Trace(eps) * ngs.Id(eps.dims[0])
-
-        E = youngsModulus
-        nu = poissonsRatio
-        rho = density
-
-        mu  = E / 2 / (1+nu) #Lame parameters
-        lam = E * nu / ((1+nu)*(1-2*nu))
-
-        #setup (linear) mechanical FE-space
-        bfK += ngs.InnerProduct(sigma(ngs.Sym(ngs.Grad(u)),mu,lam), ngs.Sym(ngs.Grad(v)))*ngs.dx
-        bfM += rho*u*v * ngs.dx
-
-        with ngs.TaskManager():
-            if verbose: print ("NGsolve assemble M and K")
-            bfK.Assemble()
-            bfM.Assemble()
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #export to scipy sparse matrices:
-        from scipy.sparse import csr_matrix
-        if verbose: print ("NGsolve convert system matrices to scipy csr_matrix format")
-        K = csr_matrix( bfK.mat.CSR(), copy=True )
-        M = csr_matrix( bfM.mat.CSR(), copy=True )
-        if verbose: print("K.shape=",K.shape)
-
-        #convert csr_matrix in NGsolve to exudyn sparse CSR np.array:
-        M1 = ScipySparseCSRtoCSR(M)
-        K1 = ScipySparseCSRtoCSR(K)
-
-        nMK = M.shape[0] #get size of mass matrix; assume square matrix!
-        #NGsolve sorts indices as x0x1x2...y0y1y2...z0z1z2...., but is needed as x0y0z0x1y1z1...
-        ResortIndicesOfCSRmatrix(M1, nMK)
-        ResortIndicesOfCSRmatrix(K1, nMK)
-
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #get node, element and surface list:
-        nodeList=[]
-        tetList=[]
-        surfaceTriangleList=[] #for drawing
-        NE = mesh.ne
-        if verbose: print("number of tets=", NE)
-
-        if meshOrder == 1:
-            NP = len(mesh.vertices)
-            if verbose: print("number of points=", NP)
-            for n in mesh.vertices: 
-                nodeList+=[list(n.point)]
-        else:
-            NP = len(mesh.ngmesh.Points())
-            if verbose: print("number of points=", NP)
-    
-            for n in mesh.ngmesh.Points(): 
-                nodeList+=[list(n)]
-
-    
-        #extract 3D elements from mesh:
-        tets = mesh.ngmesh.Elements3D()
-        cnt=0
-        for el in tets:
-            if len(el.vertices) == 4: #check if element is a tet
-                tetIndices=[]
-                for i in el.vertices:
-                    tetIndices+=[int(i.nr)-1] #convert to 0-base
-                tetList += [tetIndices]
-            else:
-                print("ERROR in ImportMeshFromNGsolve: invalid element in ngmesh, elementNr=", cnt, "linear tet elements required!")
-            cnt+=1
-
-        #function to flip surface elements:
-        def Flip3D(v):
-            return [v[0], v[2], v[1]]
-        
-        surface = mesh.ngmesh.Elements2D() #surface mesh
-        if meshOrder == 1:
-            for st in surface: 
-                vertices = []
-                for v in st.vertices: #st.points gives all nodes (for order>1), vertices only vertex points (always 4 per tet)
-                    vertices += [v.nr-1] #convert to 0-based indices
-                if len(vertices) != 3:
-                    raise ValueError('ImportMeshFromNGsolve: expected linear 3-node surface elements')
-
-                surfaceTriangleList += [Flip3D(vertices)]
-        else: #order 2
-            for st in surface: 
-                w = []
-                for v in st.points: #st.points gives all nodes (for order>1), vertices only vertex points (always 4 per tet)
-                    w += [v.nr-1] #convert to 0-based indices
-                if len(w) != 6:
-                    raise ValueError('ImportMeshFromNGsolve: expected second order 6-node surface elements')
-
-                surfaceTriangleList += [Flip3D([w[0],w[5],w[4]])]
-                surfaceTriangleList += [Flip3D([w[5],w[1],w[3]])]
-                surfaceTriangleList += [Flip3D([w[5],w[3],w[4]])]
-                surfaceTriangleList += [Flip3D([w[4],w[3],w[2]])]
-
-        nodes = np.array(nodeList)
-        elements=np.array(tetList) #unused
-        trigList = surfaceTriangleList
-
-        self.nodes = {'Position':nodes}
-        self.elements = [{'Name':'NGsolve','Tet4':elements}]
-        self.massMatrix = M1 
-        self.stiffnessMatrix = K1 
-        self.surface = [{'Name':'meshSurface','Trigs':trigList}]
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        if computeEigenmodes:
-            print('**********\nWARNING!**********\nNGsolve eigenmode computation deprecated: USE FEM.ComputeEigenmodesNGsolve(...)')
-            if verbose: print ("NGsolve: compute eigenmodes")
-            excludeRigidBodyModes = 0
-            if 'excludeRigidBodyModes' in kwargs:
-                excludeRigidBodyModes = kwargs['excludeRigidBodyModes']
-
-            nModes = 10
-            if 'numberOfModes' in kwargs: 
-                nModes = kwargs['numberOfModes'] 
-            maxIt = 40
-            if 'maxEigensolveIterations' in kwargs: 
-                maxIt = kwargs['maxEigensolveIterations']
-
-            from ngsolve.eigenvalues import PINVIT
-
-            with ngs.TaskManager():
-                KM = bfK.mat.CreateMatrix()
-                KM.AsVector().data = bfK.mat.AsVector() + 1e6* bfM.mat.AsVector()
-            
-                inv = KM.Inverse(inverse='sparsecholesky')
-                res = PINVIT(bfK.mat, bfM.mat, inv, num=nModes+excludeRigidBodyModes, maxit=maxIt, \
-                                printrates=verbose, GramSchmidt=True)
-
-            #self.res = res
-            nDOF = K.shape[0]
-            eigVecs = np.zeros((nDOF, nModes))
-            for i in range(nModes):
-                #eigVecs[:,i] = np.array(res[1][excludeRigidBodyModes+i])
-                eigVecs[:,i] = ResortIndicesOfNGvector(np.array(res[1][excludeRigidBodyModes+i]))
-            
-            self.modeBasis = {'matrix':eigVecs, 'type':'NormalModes'}
-            self.eigenValues = np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])
-                             
-            if verbose: print ("eigenfrequencies (Hz) =",(0.5/np.pi)*np.sqrt(np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])))
-
-        return [bfM, bfK, fes]
-
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute nModes smallest eigenvalues and eigenmodes from mass and stiffnessMatrix; store mode vectors in modeBasis, but exclude a number of 'excludeRigidBodyModes' rigid body modes from modeBasis; uses scipy for solution of generalized eigenvalue problem
-    #**input: 
-    #  nModes: prescribe the number of modes to be computed; total computed modes are  (nModes+excludeRigidBodyModes), but only nModes with smallest absolute eigenvalues are considered and stored
-    #  excludeRigidBodyModes: if rigid body modes are expected (in case of free-free modes), then this number specifies the number of eigenmodes to be excluded in the stored basis (usually 6 modes in 3D)
-    #  maxEigensolveIterations: maximum number of iterations for iterative eigensolver; default=40
-    #  verbose: if True, output some relevant information during solving
-    #**output: eigenmodes are stored internally in FEMinterface as 'modeBasis' and eigenvalues as 'eigenValues'
-    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
-    def ComputeEigenmodesNGsolve(self, bfM, bfK,
-                                 nModes, 
-                                 maxEigensolveIterations = 40,
-                                 excludeRigidBodyModes = 0,
-                                 verbose = False):
-        import ngsolve as ngs
-
-        maxIt = maxEigensolveIterations
-
-        from ngsolve.eigenvalues import PINVIT
-
-        with ngs.TaskManager():
-            KM = bfK.mat.CreateMatrix()
-            KM.AsVector().data = bfK.mat.AsVector() + 1e6* bfM.mat.AsVector()
-        
-            inv = KM.Inverse(inverse='sparsecholesky')
-            res = PINVIT(bfK.mat, bfM.mat, inv, num=nModes+excludeRigidBodyModes, maxit=maxIt, \
-                            printrates=verbose, GramSchmidt=True)
-
-        #nDOF = K.shape[0]
-        nDOF = bfK.space.ndof
-        eigVecs = np.zeros((nDOF, nModes))
-        for i in range(nModes):
-            #eigVecs[:,i] = np.array(res[1][excludeRigidBodyModes+i])
-            eigVecs[:,i] = ResortIndicesOfNGvector(np.array(res[1][excludeRigidBodyModes+i]))
-        
-        self.modeBasis = {'matrix':eigVecs, 'type':'NormalModes'}
-        self.eigenValues = np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])
-                         
-        if verbose: print ("eigenfrequencies (Hz) =",(0.5/np.pi)*np.sqrt(np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])))
-
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute static  and eigen modes based on Hurty-Craig-Bampton, for details see theory part \refSection{sec:theory:CMS}. This function uses internal computational functionality of NGsolve and is often much faster than the scipy variant
-    #**input:
-    #  bfM: bilinearform for mass matrix as retured in ImportMeshFromNGsolve(...)
-    #  bfK: bilinearform for stiffness matrix as retured in ImportMeshFromNGsolve(...)
-    #  boundaryNodesList: [nodeList0, nodeList1, ...] a list of node lists, each of them representing a set of 'Position' nodes for which a rigid body interface (displacement/rotation and force/torque) is created; NOTE THAT boundary nodes may not overlap between the different node lists (no duplicated node indices!)
-    #  nEigenModes: number of eigen modes in addition to static modes (may be zero for RBE2 computationMode); eigen modes are computed for the case where all rigid body motions at boundaries are fixed; only smallest nEigenModes absolute eigenvalues are considered
-    #  maxEigensolveIterations: maximum number of iterations for iterative eigensolver; default=40
-    #  verbose: if True, output some relevant information during solving
-    #**output: stores computed modes in self.modeBasis and abs(eigenvalues) in self.eigenValues
-    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
-    def ComputeHurtyCraigBamptonModesNGsolve(self,
-                                      bfM, bfK,
-                                      boundaryNodesList,
-                                      nEigenModes, 
-                                      maxEigensolveIterations = 40,
-                                      verbose = False):
-
-        import ngsolve as ngs
-        import time
-        start_time = time.time()
-        #from scipy.linalg import solve, eigh, eig #eigh for symmetric matrices, positive definite
-        
-        nNodeLists = len(boundaryNodesList)
-        #sizes of internal and boundary nodes:
-        #M = bfM.mat
-        K = bfK.mat
-        n = K.height
-        nNodes = int(n/3)
-        nodesPos = self.GetNodePositionsAsArray()
-
-        bndDOFsAll = ngs.BitArray(n) #fill in all boundaries later
-        bndDOFsAll[:] = False        
-        
-        #+++++++++++++++++++++++++++
-        #compute static rigid body modes:
-        addRotationModes = 1
-        rbSize = 3 + 3*addRotationModes #size of rigid body coordinates (3 for translation, 6 for translation+rotation)
-        nbRBE2 = (nNodeLists-1)*rbSize #number of chosen static modes, 6 DOF per rigid body interface; exclude first rigid body boundary in order to suppress rigid body motion of static modes
-        #DOFeig = np.arange(nbRBE2,nbRBE2+nEigenModes) #for final mapping of eigenmode coordinates
-
-        modeBasis = np.zeros((n, nbRBE2+nEigenModes))
-
-        #all rigid body modes
-        mvAll = ngs.MultiVector(K.CreateColVector(),0)
-        
-        #1 rigid body modes
-        mvRB = ngs.MultiVector(K.CreateColVector(),6)
-        for v in mvRB: v[:]=0 #initialize!
-
-        #rigid body displacements
-        for i in range(3):
-            mvRB[i][nNodes*i:nNodes*(i+1)] = 1
-                        
-        #create list of mappings between average rigid body motion and boundary DOF matrix
-        #rigidBodyMappings = [[]]*nNodeLists #list of mappings
-        cntBoundary = 0 #counter for boundaryNodeLists / number of interfaces
-        for cntBoundary, boundaryNodes in enumerate(boundaryNodesList):
-            nbn = len(boundaryNodes)
-            
-            bndDOFs = ngs.BitArray(n)
-            bndDOFs[:] = False
-    
-            DOFb = np.zeros(nbn*3, dtype=np.int)
-            for i in range(len(boundaryNodes)):
-                node = boundaryNodes[i]
-                #DOFb[i*3:i*3+3] = [node*3,node*3+1,node*3+2] #interleaved xyzxyz
-                DOFb[i*3:i*3+3] = [node,node+nNodes,node+2*nNodes] #xxxx yyyy zzzz
-                
-            for i, d in enumerate(DOFb):
-                bndDOFs[d] = True
-
-            bndDOFsAll |= bndDOFs
-            
-            #compute midpoints of boundary nodes:
-            p0 = np.zeros(3)
-            for node in boundaryNodes:
-                p0 += nodesPos[node]
-            
-            p0 = p0*(1./len(boundaryNodes))
-
-            #compute rigid body modes for this boundary:
-            for i in range(3): #iterate about 3 rotation axes
-                rot = np.zeros(3) #rotation vector, unit rotation
-                rot[i] = 1
-                rotTilde = Skew(rot)
-                for bj in boundaryNodes:
-                    p = nodesPos[bj]-p0
-                    qRot = rotTilde@p
-
-                    for k in range(3):
-                        mvRB[i+3][bj+k*nNodes] = qRot[k]
-            
-            proj = ngs.Projector(bndDOFs, True)
-            for v in mvRB:
-                hv = v.CreateVector()
-                hv.data = proj * v
-                mvAll.Append(hv)
-        
-        if verbose: print('solve...')
-        KiiInv = K.Inverse(~bndDOFsAll,inverse='sparsecholesky')
-        if verbose: print('...ready')
-
-        #compute static modes for all rigid body boundaries
-        mvAll.data = mvAll - KiiInv @ K * mvAll
-            
-        for i in range(len(mvAll)-1*rbSize):
-            modeBasis[:,i] = ResortIndicesOfNGvector(mvAll[i+1*rbSize])
-   
-        #++++++++++++++++++++++++++++++++++++++
-        #compute modes for free inner nodes:    
-        from ngsolve.eigenvalues import PINVIT
-
-        if nEigenModes != 0:
-            if verbose: print('compute eigenvectors of inner nodes...')
-            maxIt = maxEigensolveIterations
-            with ngs.TaskManager():#pajetrace=10**8):
-                #with shift strategy, but not necessary for inner nodes (no rigid-body-modes)
-                # KM = bfK.mat.CreateMatrix()
-                # KM.AsVector().data = bfK.mat.AsVector() + 1e6* bfM.mat.AsVector()
-                # KMinv = KM.Inverse(~bndDOFsAll,inverse='sparsecholesky')
-                KMinv = KiiInv
-                res = PINVIT(bfK.mat, bfM.mat, KMinv, 
-                             num=nEigenModes, maxit=maxIt, \
-                             printrates=verbose, GramSchmidt=True)
-    
-            if verbose: print('...ready')
-    
-            for i in range(nEigenModes):
-                modeBasis[:,i+nbRBE2] = ResortIndicesOfNGvector(np.array(res[1][i]))
-
-            self.eigenValues = np.abs(res[0][0:nEigenModes])
-        else:
-            self.eigenValues = np.array([])
-
-        self.modeBasis = {'matrix':modeBasis, 'type':'HCBmodes'}
-                         
-        if verbose: 
-            print ("eigenfrequencies (Hz) =",(0.5/np.pi)*np.sqrt(np.abs(self.eigenValues)))
-            print("HCB NGsolve modes needed %.3f seconds" % (time.time() - start_time))
-
-
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute special stress or strain modes in order to enable visualization of stresses and strains in ObjectFFRFreducedOrder; takes a NGsolve fes as input and uses internal NGsolve methods to efficiently compute stresses or strains
-    #**input: 
-    #  fes: finite element space as retured in ImportMeshFromNGsolve(...)
-    #  material: specify material properties for computation of stresses, using a material class, e.g. material = KirchhoffMaterial(Emodulus, nu, rho); not needed for strains (material = 0)
-    #  outputVariableType: specify either exudyn.OutputVariableType.StressLocal or exudyn.OutputVariableType.StrainLocal as the desired output variables
-    #**notes: This function is implemented in Python and rather slow for larger meshes; for NGsolve / Netgen meshes, see the according ComputePostProcessingModesNGsolve function, which is usually much faster
-    #**output: post processing modes are stored in FEMinterface in local variable postProcessingModes as a dictionary, where 'matrix' represents the modes and 'outputVariableType' stores the type of mode as a OutputVariableType
-    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
-    def ComputePostProcessingModesNGsolve(self, fes, material = 0, 
-                                          outputVariableType = 'OutputVariableType.StressLocal', 
-                                          verbose = False):
-
-        import ngsolve as ngs
-        #++++++++++++++++++++++++++++++++++++
-        #special ngsolve functions which are put into expression trees:
-        def Strain2Stress(eps, mu, lam):
-            return 2*mu*eps + lam*ngs.Trace(eps) * ngs.Id(eps.dims[0])
-    
-        def Strain2Strain(eps, mu, lam):
-            return eps
-        #++++++++++++++++++++++++++++++++++++
-        #print("t=",outputVariableType)
-        if str(outputVariableType) == 'OutputVariableType.StressLocal':
-            computeStrains = False
-            StressFunction = Strain2Stress
-        elif str(outputVariableType) == 'OutputVariableType.StrainLocal':
-            computeStrains = True
-            StressFunction = Strain2Strain
-        else:
-            raise ValueError('ComputePostProcessingModes invoked with invalid outputVariableType')
-
-        if material == 0:
-            material=KirchhoffMaterial(1, 0, 1)
-            if not computeStrains:
-                raise ValueError('ComputePostProcessingModes: if material=0, outputVariableType must be StrainLocal')
-
-        nNodes = int(fes.ndof/3)
-        modeBasis = self.modeBasis['matrix']
-        [mu, lam] = material.LameParameters()
-                
-        nModeVectors = modeBasis.shape[1]
-        stressModesMatrix = np.zeros((nNodes,6*nModeVectors))
-    
-        meshOrder = fes.components[0].globalorder
-        if verbose: print('ORDER of fes=',meshOrder)
-        # meshOrder = 2
-        if meshOrder == 1:
-            fesStress = ngs.MatrixValued(ngs.H1(fes.mesh, order=meshOrder), symmetric=True)
-        else:
-            fesStress = ngs.MatrixValued(ngs.NodalFESpace(fes.mesh, order=meshOrder), symmetric=True)
-
-        #order of stresses (per node) = xx,xy,xz,yy,yz,zz (in order xx xx xx xy xy xy...)
-        gfStress = ngs.GridFunction(fesStress)
-        gfu = ngs.GridFunction(fes)
-    
-        #map ngsolve stress components xx,xy,yy,xz,yz,zz to Exudyn xx,yy,zz,yz,xz,xy
-        ngsStressMap = [0,2,5,4,3,1] #stressModeExu[i] = stressModeNGS[ngsStressMap[i]]
-    
-        with ngs.TaskManager():
-            for i in range(nModeVectors):
-                if verbose: print('compute stress mode ', i, 'of', nModeVectors)
-                v = modeBasis[:,i]
-                gfu.vec.FV()[:] = ResortIndicesExudyn2NGvector(v)
-                #gfStress.Interpolate(StressFunction(ngs.Sym(ngs.Grad(gfu)), mu, lam).Compile())
-                gfStress.Set(StressFunction(ngs.Sym(ngs.Grad(gfu)), mu, lam))
-                
-                sv = gfStress.vec.FV()
-                for j in range(6):
-                    stressModesMatrix[:,i*6+j] = sv[ngsStressMap[j]*nNodes:(ngsStressMap[j]+1)*nNodes]
-        
-        self.postProcessingModes = {'matrix': stressModesMatrix, 
-                                    'outputVariableType': outputVariableType}
-        
-
-
-
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #general FEMinterface functionality
-
-
-    #**classFunction: get sparse mass matrix in according format
-    def GetMassMatrix(self, sparse=True):
-        if sparse:
-            return self.massMatrix
-        else:
-            return CompressedRowSparseToDenseMatrix(self.massMatrix)
-
-    #**classFunction: get sparse stiffness matrix in according format
-    def GetStiffnessMatrix(self, sparse=True):
-        if sparse:
-            return self.stiffnessMatrix
-        else:
-            return CompressedRowSparseToDenseMatrix(self.stiffnessMatrix)
-
-    #**classFunction: get total number of nodes
-    def NumberOfNodes(self):
-        nNodes = 0
-        for nodeTypeName in self.nodes:
-            nNodes += len(self.nodes[nodeTypeName])
-        return nNodes
-
-    #**classFunction: get node points as array; only possible, if there exists only one type of Position nodes
-    #**notes: in order to obtain a list of certain node positions, see example
-    #**example:
-    #p=GetNodePositionsAsArray(self)[42] #get node 42 position
-    #nodeList=[1,13,42]
-    #pArray=GetNodePositionsAsArray(self)[nodeList] #get np.array with positions of node indices
-    def GetNodePositionsAsArray(self):
-        if len(self.nodes) != 1:
-            raise ValueError("ERROR: GetNodePositionsAsArray() only possible for one type of Position nodes!")
-
-        nodeTypeName = list(self.nodes)[0]
-        return self.nodes[nodeTypeName]
-
-    #**classFunction: get mean (average) position of nodes defined by list of node numbers
-    def GetNodePositionsMean(self,nodeNumberList):
-        if len(self.nodes) != 1:
-            raise ValueError("ERROR: GetNodesMeanPositions(...) only possible for one type of Position nodes!")
-
-        return np.mean(self.GetNodePositionsAsArray()[nodeNumberList], axis=0)
-
-    #**classFunction: get number of total nodal coordinates
-    def NumberOfCoordinates(self):
-        nCoordinates = 0
-        for nodeTypeName in self.nodes:
-            nCoordinates += len(self.nodes[nodeTypeName]) * self.coordinatesPerNodeType[nodeTypeName]
-        return nCoordinates
-
-    #**classFunction: get node number for node at given point, e.g. p=[0.1,0.5,-0.2], using a tolerance (+/-) if coordinates are available only with reduced accuracy
-    #if not found, it returns an invalid index
-    def GetNodeAtPoint(self, point, tolerance = 1e-5, raiseException = True):
-        cnt = 0
-        if len(self.nodes) != 1 or 'Position' not in self.nodes:
-            raise ValueError('FEMinterface.GetNodeAtPoint: only Position type nodes allowed')
-        for nodeTypeName in self.nodes:
-            for nodePoint in self.nodes[nodeTypeName]:
-                if abs(nodePoint - point).max() <= tolerance:
-                    return cnt #this holds the node number
-                cnt+=1
-        
-        if raiseException:
-            raise ValueError("ERROR: GetNodeAtPoint: node point not found!")
-        return -1 #invalid index, only if no exception raised
-
-    #**classFunction: get node numbers in plane defined by point p and (normalized) normal vector n using a tolerance for the distance to the plane
-    #if not found, it returns an empty list
-    def GetNodesInPlane(self, point, normal,  tolerance = 1e-5):
-        cnt = 0
-        nodeList=[]
-        if len(self.nodes) != 1 or 'Position' not in self.nodes:
-            raise ValueError('FEMinterface.GetNodesInPlane: only Position type nodes allowed')
-        for nodeTypeName in self.nodes:
-            for nodePoint in self.nodes[nodeTypeName]:
-                if abs(np.dot(nodePoint - point, normal)) <= tolerance:
-                    nodeList += [cnt]
-                cnt+=1
-        return nodeList
-
-    #**classFunction: get node numbers in cube, given by pMin and pMax, containing the minimum and maximum x, y, and z coordinates
-    #**example:
-    #nList = GetNodesInCube([-1,-0.2,0],[1,0.5,0.5])
-    #**output: returns list of nodes; if no nodes found, return an empty list
-    def GetNodesInCube(self, pMin, pMax):
-        cnt = 0
-        nodeList=[]
-        if len(self.nodes) != 1 or 'Position' not in self.nodes:
-            raise ValueError('FEMinterface.GetNodesInCube: only Position type nodes allowed')
-        for nodeTypeName in self.nodes:
-            for nodePoint in self.nodes[nodeTypeName]:
-                if (nodePoint[0] >= pMin[0] and nodePoint[0] <= pMax[0] and
-                    nodePoint[1] >= pMin[1] and nodePoint[1] <= pMax[1] and
-                    nodePoint[2] >= pMin[2] and nodePoint[2] <= pMax[2]):
-                    nodeList += [cnt]
-                cnt+=1
-        return nodeList
-
-    #**classFunction: get node numbers lying on line defined by points p1 and p2 and tolerance, which is accepted for points slightly outside the surface
-    def GetNodesOnLine(self, p1, p2, tolerance=1e-5):
-        return self.GetNodesOnCylinder(p1, p2, radius=0, tolerance=1e-5)
-
-    #**classFunction: get node numbers lying on cylinder surface; cylinder defined by cylinder axes (points p1 and p2), 
-    #  cylinder radius and tolerance, which is accepted for points slightly outside the surface
-    #  if not found, it returns an empty list
-    def GetNodesOnCylinder(self, p1, p2, radius, tolerance=1e-5):
-        cnt = 0
-        v0 = np.array(p2) - np.array(p1)
-        lAxis = np.linalg.norm(v0)
-        if lAxis != 0:
-            v0 = v0/lAxis
-            
-        nodeList=[]
-        if len(self.nodes) != 1 or 'Position' not in self.nodes:
-            raise ValueError('FEMinterface.GetNodesOnCylinder: only Position type nodes allowed')
-
-        for nodeTypeName in self.nodes:
-            for nodePoint in self.nodes[nodeTypeName]:
-                p = np.array(nodePoint)
-                v1 = p-p1
-                s = v0 @ v1
-                
-                if s <= lAxis+tolerance and s >= -tolerance:
-                    pp = p1 + s*v0 #projected point
-                    r = np.linalg.norm(p-pp) #shortest distance to axis
-                    if abs(r-radius) <= tolerance:
-                        nodeList += [cnt]
-                cnt+=1
-        return nodeList
-
-    #**classFunction: get node numbers lying on a circle, by point p, (normalized) normal vector n (which is the axis of the circle) and radius r
-    #using a tolerance for the distance to the plane
-    #if not found, it returns an empty list
-    def GetNodesOnCircle(self, point, normal, r, tolerance = 1e-5):
-        cnt = 0
-        nodeList=[]
-        if len(self.nodes) != 1 or 'Position' not in self.nodes:
-            raise ValueError('FEMinterface.GetNodesOnCircle: only Position type nodes allowed')
-        for nodeTypeName in self.nodes:
-            for nodePoint in self.nodes[nodeTypeName]:
-                if abs(np.dot(nodePoint - point, normal)) <= tolerance:
-                    if abs(np.dot(nodePoint - point, nodePoint - point) - r**2) <= tolerance**2:
-                        nodeList += [cnt]
-                cnt+=1
-        return nodeList
-
-
-    #**classFunction: return list of node weights based on surface triangle areas; surface triangles are identified as such for which all nodes of a triangle are on the surface
-    #**nodes: requires that surface triangles have been already built during import of finite element mesh, or by calling VolumeToSurfaceElements!
-    #**input: 
-    #  nodeList: list of local (Position) node numbers
-    #  normalizeWeights: if True, weights are normalized to sum(weights)==1; otherwise, returned list contains areas according to nodes per
-    #**output: numpy array with weights according to indices in node list
-    def GetNodeWeightsFromSurfaceAreas(self, nodeList, normalizeWeights=True):
-        verboseMode=False #for debug
-        if len(self.surface) != 1:
-            raise ValueError('GetNodeWeightsFromSurfaces: expected one surface triangle list in FEM, but received: '+str(len(self.surface)))
-
-        if 'Trigs' not in self.surface[0]:
-            raise ValueError('GetNodeWeightsFromSurfaces: only works for triangle surfaces!')
-
-        if len(self.nodes) != 1:
-            raise ValueError('GetNodeWeightsFromSurfaces: only works for one node set!')
-            
-        trigList = self.surface[0]['Trigs']
-        nNodes = self.NumberOfNodes()
-        
-        #build a node list, which contains !=-1 for every node in nodelist
-        globalToLocal = -np.ones(nNodes, dtype=int)
-        for i, node in enumerate(nodeList):
-            globalToLocal[node] = i #also stores global to local mapping ...
-
-        #find according surface trigs and compute areas:
-        femNodes = self.GetNodePositionsAsArray()
-        localSurfaceAreas = []
-        localSurfaceTrigs = []
-        weights = np.zeros(len(nodeList))
-        for trig in trigList: #if all nodes are on surface, also trig is on surface ... (except rare events, which are not considered)
-            if (globalToLocal[trig[0]] != -1 and #zero means that node is not on local surface
-                globalToLocal[trig[1]] != -1 and
-                globalToLocal[trig[2]] != -1 ):
-                localSurfaceTrigs += [trig]
-                A = ComputeTriangleArea(femNodes[trig[0]], femNodes[trig[1]], femNodes[trig[2]]) #always positive
-                localSurfaceAreas += [A]
-                #now add areas weighted to nodes:
-                for k in trig:
-                    weights[globalToLocal[k]] += A/3 #add area to every node
-                    
-        
-        totalArea = sum(localSurfaceAreas)
-        sumWeights = sum(weights)
-        if verboseMode: 
-            print('localSurfaceTrigs:', localSurfaceTrigs)
-            print('total area=', totalArea)
-            print('sum weights=', sumWeights)
-        
-        if sumWeights == 0:
-            raise ValueError('GetNodeWeightsFromSurfaces: no according triangle surfaces found!')
-
-        if normalizeWeights:
-            weights *= 1./sumWeights
-        
-        return weights
-
-    #**classFunction: return surface trigs as node number list (for drawing in EXUDYN and for node weights)
-    def GetSurfaceTriangles(self):
-        trigList = []
-        for surface in self.surface:
-            if 'Trigs' in surface:
-                trigList += surface['Trigs']
-        return trigList
-
-    #**classFunction: generate surface elements from volume elements
-    #stores the surface in self.surface
-    #only works for one element list and only for element types 'Hex8', 'Hex20', 'Tet4' and 'Tet10'
-    def VolumeToSurfaceElements(self, verbose=False):
-        if verbose: print("create surface from volume elements")
-#        self.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
-#        self.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
-        nNodes = self.NumberOfNodes()
-        hex8QuadIndices = [[0,1,2,3],[7,6,5,4],[0,4,5,1],[1,5,6,2],[2,6,7,3],[3,7,4,0]]
-        hex20QuadIndices = [[0,1,2,3],[7,6,5,4],[0,4,5,1],[1,5,6,2],[2,6,7,3],[3,7,4,0]] #without midnodes, works for now
-        tet4TrigIndices = [[0,1,2],[0,3,1],[1,3,2],[2,3,0]]
-        tet10TrigIndices = [[0,1,2],[0,3,1],[1,3,2],[2,3,0]] #without midnodes, works for now
-        
-        elementTypes = ['Hex8','Hex20','Tet4','Tet10']
-
-        element2IndexList = {'Hex8': hex8QuadIndices,
-                             'Hex20':hex20QuadIndices,
-                             'Tet4': tet4TrigIndices,
-                             'Tet10':tet10TrigIndices}
-        surfaceListTrigs = []
-        surfaceListQuads = [] #list of surface quads, will be converted to trigs
-        nodes2elements = [[]]*nNodes #element to node list
-
-        #first store all elements linked to a certain node
-        #print("build nodes to elements...")
-        #print("nodes2elements=",nodes2elements)
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #preprocess and generate nodes2elements list
-        cnt = 0
-        for elementDict in self.elements:
-            for elementType in elementTypes:
-                if elementType in elementDict:   #only implemented for Hex8
-                    elementList = elementDict[elementType]
-                    for element in elementList:
-                        #print("  element",cnt,"=",element)
-                        for i in element:
-                            #print("    i=",i)
-                            #nodes2elements[int(i)].append(int(cnt))
-                            alist=list(nodes2elements[i])
-                            alist.append(cnt)
-                            nodes2elements[i] = alist
-                            #print("nodes2elements[",i,"]=",nodes2elements[i])
-                        cnt+=1
-
-        
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        for elementDict in self.elements:
-            for elementType in elementTypes:
-                if elementType in elementDict:   #only implemented for Hex8
-                    elementList = elementDict[elementType]
-                    currentIndexList = element2IndexList[elementType]
-                    
-                    #run through all elements:
-                    nElements = len(elementList)
-                    elementCnt = 0
-                    cnt2=0
-                    #now run over all elements:
-                    for element in elementList:
-                        if verbose and elementCnt%10000 == 0 and elementCnt>0:
-                            print("process element ",elementCnt,"/",nElements)
-                        for surface in currentIndexList:
-                            #test a surface with nodes
-                            actSurface = []
-                            for i in surface:
-                                actSurface += [element[i]]
-                            lenSurface = len(actSurface) #3 or 4 nodes at surface
-                            #print("  actsurface=",actSurface)
-                            #find all potential candidates, which could be opposite
-    
-                            testElements = []
-                            for nn in actSurface:
-                                for elNum in nodes2elements[nn]:
-                                    if not (elNum in testElements):
-                                        testElements += [elNum]
-                            
-                            #print("  testElements=",testElements)
-                            foundNeighbor = False
-                            for el in testElements:
-                                if el != elementCnt: #do not compare with itself!!!
-                                    testElement = elementList[el]
-                                    #print("    testElement=",testElement)
-                                    for surface2 in currentIndexList:
-                                        cnt2+=1
-                                        #print("      surface2=",surface2)
-                                        #test a surface2 with nodes
-                                        testSurface = []
-                                        for j in surface2:
-                                            testSurface += [testElement[j]]
-                                        #print("      testSurface=",testSurface)
-                                        
-                                        if len(set(testSurface).intersection(actSurface)) == lenSurface:
-                                            #print("        found!")
-                                            foundNeighbor = True
-                                            break;
-                            
-                            if not foundNeighbor:
-                                #print("      not found!")
-                                if lenSurface == 4:
-                                    surfaceListQuads += [actSurface]
-                                else:
-                                    surfaceListTrigs += [actSurface]
-                        elementCnt += 1
-        
-        if verbose: print("surfaceListQuad length=",len(surfaceListQuads))
-        for quad in surfaceListQuads:
-            surfaceListTrigs += [[quad[0],quad[1],quad[2]]]
-            surfaceListTrigs += [[quad[0],quad[2],quad[3]]]
-
-        #print("surfaceListTrigs",surfaceListTrigs)
-        #find if surface exists:
-        surfaceExists = False
-        for surf in self.surface:
-            if surf['Name'] == 'meshSurface':
-                surfaceExists = True
-                surf['Trigs'] = surfaceListTrigs
-
-        #otherwise add new surface
-        if not surfaceExists:
-            self.surface += [{'Name':'meshSurface', 'Trigs':surfaceListTrigs}]
-                 
-        
-        
-        
-        
-        
-        
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #+++++++++++      COMPUTATIONAL FUNCTIONS            ++++++++++++++++++++++
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-            
-    #**classFunction: get gyroscopic matrix in according format; rotationAxis=[0,1,2] = [x,y,z]
-    def GetGyroscopicMatrix(self, rotationAxis=2, sparse=True):
-        #create gyroscopic terms
-        nNodes = self.NumberOfNodes()
-        if rotationAxis == 0:
-            X=np.array([[ 0.,  0.,  0.],
-                        [ 0.,  0., -1.],
-                        [ 0.,  1.,  0.]])
-        elif rotationAxis == 1:
-            X=np.array([[ 0.,  0.,  1.],
-                        [ 0.,  0.,  0.],
-                        [-1.,  0.,  0.]])
-        elif rotationAxis == 2:
-            X=np.array([[ 0., -1.,  0.],
-                        [ 1.,  0.,  0.],
-                        [ 0.,  0.,  0.]])
-            
-        if sparse:
-            from scipy import sparse
-            xBlock = sparse.kron(sparse.eye(nNodes), X) #create big block-diagonal matrix
-            G=np.dot(xBlock,CSRtoScipySparseCSR(self.massMatrix))
-        else:
-            xBlock = np.kron(np.eye(nNodes), X) #create big block-diagonal matrix
-            G=np.dot(xBlock,CompressedRowSparseToDenseMatrix(self.massMatrix))
-
-        return G
-
-
-
-    #**classFunction: scale (=multiply) mass matrix with factor
-    def ScaleMassMatrix(self, factor):
-        self.massMatrix[:,2] *= factor
-
-    #**classFunction: scale (=multiply) stiffness matrix with factor
-    def ScaleStiffnessMatrix(self, factor):
-        self.stiffnessMatrix[:,2] *= factor
-
-        
-    #**classFunction: modify stiffness matrix to add elastic support (joint, etc.) to a node; nodeNumber zero based (as everywhere in the code...)
-    #springStiffness must have length according to the node size
-    def AddElasticSupportAtNode(self, nodeNumber, springStiffness=[1e8,1e8,1e8]):
-        if len(self.nodes) != 1:
-            print("ERROR: AddElasticSupportAtNode: there must be exactly one list of nodes!")
-        #nodeList = self.nodes(list(self.nodes)[0])
-        nodeTypeName = list(self.nodes)[0]
-        nodeSize = self.coordinatesPerNodeType[nodeTypeName]
-        nCoordinate = nodeNumber * nodeSize
-        #print("AddElasticSupportAtNode, nCoordinate=", nCoordinate)
-        
-        #supports = []
-        for i in range(nodeSize):
-            #supports += [[nCoordinate+i,nCoordinate+i,springStiffness[i]]]
-            self.stiffnessMatrix = AddEntryToCompressedRowSparseArray(self.stiffnessMatrix, nCoordinate+i,nCoordinate+i,springStiffness[i])
-        #np.vstack((self.stiffnessMatrix, np.array(supports))) #append supports to sparse matrix
-
-    #**classFunction: modify mass matrix by adding a mass to a certain node, modifying directly the mass matrix
-    def AddNodeMass(self, nodeNumber, addedMass):
-        if len(self.nodes) != 1:
-            print("ERROR: AddElasticSupportAtNode: there must be exactly one list of nodes!")
-
-        #nodeList = self.nodes(list(self.nodes)[0])
-        nodeTypeName = list(self.nodes)[0]
-        nodeSize = self.coordinatesPerNodeType[nodeTypeName]
-
-        nCoordinate = nodeNumber * nodeSize
-        #supports = []
-        for i in range(nodeSize):
-            #supports += [[nCoordinate+i,nCoordinate+i,addedMass]]
-            self.massMatrix = AddEntryToCompressedRowSparseArray(self.massMatrix, nCoordinate+i,nCoordinate+i,addedMass)
-        #np.vstack((self.massMatrix, np.array(supports))) #append supports to sparse matrix
-
-    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: create GenericODE2 object out of (linear) FEM model; uses always the sparse matrix mode, independent of the solver settings; this model can be directly used inside the multibody system as a static or dynamic FEM subsystem undergoing small deformations; computation is several magnitudes slower than ObjectFFRFreducedOrder
-    #**input:
-    #  mbs: multibody system to which the GenericODE2 is added
-    #**output: return list [oGenericODE2, nodeList] containing object number of GenericODE2 as well as the list of mbs node numbers of all NodePoint nodes
-    def CreateLinearFEMObjectGenericODE2(self, mbs, color=[0.9,0.4,0.4,1.]):
-        import exudyn as exu
-        femNodes = self.GetNodePositionsAsArray()
-        
-        #add nodes:
-        allNodeList = [] #create node list
-        for node in femNodes:
-            allNodeList += [mbs.AddNode(eii.NodePoint(referenceCoordinates=node))]
-        
-        nRows = self.NumberOfCoordinates()
-        Mcsr = exu.MatrixContainer()
-        Mcsr.SetWithSparseMatrixCSR(nRows,nRows,self.GetMassMatrix(sparse=True), useDenseMatrix=False)
-        Kcsr = exu.MatrixContainer()
-        Kcsr.SetWithSparseMatrixCSR(nRows,nRows,self.GetStiffnessMatrix(sparse=True), useDenseMatrix=False)
-        
-        #now add generic body built from FEM model with mass and stiffness matrix (optional damping could be added):
-        oGenericODE2 = mbs.AddObject(eii.ObjectGenericODE2(nodeNumbers = allNodeList, 
-                                                        massMatrix=Mcsr, 
-                                                        stiffnessMatrix=Kcsr,
-                                                        #forceVector=np.zeros(nRows), 
-                                                        #forceUserFunction=UFforce,
-                                                        visualization=eii.VObjectGenericODE2(triangleMesh = self.GetSurfaceTriangles(), 
-                                                                                         color=color)
-                                                        ))
-        return [oGenericODE2, allNodeList]
-        
-    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: import mesh from NETGEN/NGsolve and setup mechanical problem
-    #**classFunction: create GenericODE2 object fully nonlinear FEM model using NGsolve; uses always the sparse matrix mode, independent of the solver settings; this model can be directly used inside the multibody system as a static or dynamic nonlinear FEM subsystem undergoing large deformations; computation is several magnitudes slower than ObjectFFRFreducedOrder
-    #**input:
-    #    mbs: multibody system to which the GenericODE2 is added
-    #    mesh: a previously created \texttt{ngs.mesh} (NGsolve mesh, see examples)
-    #    youngsModulus: Young's modulus used for mechanical model
-    #    poissonsRatio: Poisson's ratio used for mechanical model
-    #    density: density used for mechanical model
-    #    meshOrder: use 1 for linear elements and 2 for second order elements (recommended to use 2 for much higher accuracy!)
-    #**output: return list [oGenericODE2, nodeList] containing object number of GenericODE2 as well as the list of mbs node numbers of all NodePoint nodes
-    #**notes: The interface to NETGEN/NGsolve has been created together with Joachim Sch\"oberl, main developer 
-    #  of NETGEN/NGsolve \cite{Schoeberl1997,NGsolve2014}; Thank's a lot!
-    #  download NGsolve at: https://ngsolve.org/
-    #  NGsolve needs Python 3.7 (64bit) ==> use according EXUDYN version!
-    #  note that node/element indices in the NGsolve mesh are 1-based and need to be converted to 0-base!
-    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
-    def CreateNonlinearFEMObjectGenericODE2NGsolve(self, mbs, mesh, 
-                                                   density, youngsModulus, poissonsRatio, 
-                                                   meshOrder=1, color=[0.9,0.4,0.4,1.]):
-        import ngsolve as ngs
-        import exudyn as exu
-        from scipy.sparse import csr_matrix
-        
-        if meshOrder < 1 or meshOrder > 2:
-            raise ValueError('mesh order > 1 or mesh order < 2 not supported!')
-            
-        if meshOrder == 2:
-            mesh.ngmesh.SecondOrder()
-
-        nu = poissonsRatio
-        mu  = youngsModulus / 2 / (1+nu)
-        lam = youngsModulus * nu / ((1+nu)*(1-2*nu))
-        
-        #compute Green-Lagrange (nonlinear) strain tensor from displacement field
-        def GLstrain(u):
-            #F = ngs.Id(3) + ngs.Grad(u)
-            #return 0.5*(F.trans * F - ngs.Id(3))
-            return ngs.Sym(ngs.Grad(u)) + 0.5*(ngs.Grad(u).trans * ngs.Grad(u))
-        
-        #compute 2nd PK-stress from strain
-        def Strain2Stress(eps, mu, lam):
-            return 2*mu*eps + lam*ngs.Trace(eps) * ngs.Id(eps.dims[0])
-        
-        #deformation energy acc. to St. Venant-Kirchhoff material
-        def DeformationEnergy (GLstrain, mu, lam):
-            #return 0.5*lam*(ngs.Trace(GLstrain))**2 + mu * ngs.Trace(GLstrain*GLstrain) #2*mu/lam*Det(C)**(-lam/2/mu)-1)
-            return 0.5*ngs.Trace(Strain2Stress(GLstrain,mu,lam).trans*GLstrain)
-        
-        #do not add boundary conditions here, otherwise stiffness matrix cannot be exported!
-        fes = ngs.NodalFESpace(mesh, order=meshOrder)**3
-        uu = fes.TrialFunction()
-        #v = fes.TestFunction()
-    
-        a = ngs.BilinearForm(fes)
-        a += ngs.Variation(DeformationEnergy(GLstrain(uu), mu, lam).Compile()*ngs.dx)
-        #linear:
-        #a += ngs.InnerProduct(Strain2Stress(ngs.Sym(ngs.Grad(uu)),mu,lam), ngs.Sym(ngs.Grad(v)))*ngs.dx
-        
-        #define grid function to work with in nonlinear solver:
-        u = ngs.GridFunction(fes)
-        u.vec[:] = 0
-            
-        fem=FEMinterface()
-        #this is mainly needed for triangleMesh, but also creates the linearized matrices, but ok:
-        fem.ImportMeshFromNGsolve(mesh, density=density, 
-                                  youngsModulus=youngsModulus, poissonsRatio=poissonsRatio, 
-                                  meshOrder=meshOrder)
-
-        #create nodes:
-        femNodes = fem.GetNodePositionsAsArray()
-        
-        #add nodes:
-        allNodeList = [] #create node list
-        for node in femNodes:
-            allNodeList += [mbs.AddNode(eii.NodePoint(referenceCoordinates=node))]
-        
-        nRows = fem.NumberOfCoordinates()
-        Mcsr = exu.MatrixContainer()
-        Mcsr.SetWithSparseMatrixCSR(nRows,nRows,fem.GetMassMatrix(sparse=True), useDenseMatrix=False)
-        Kcsr = exu.MatrixContainer()
-        Kcsr.SetWithDenseMatrix(fem.GetStiffnessMatrix(sparse=True), useDenseMatrix=False)
-        
-        res = u.vec.CreateVector() #temporary vector
-        
-        #compute RHS of FEM object
-        def UFforce(mbs, t, itemIndex, q, q_t):
-            u.vec[:] = ResortIndicesExudyn2NGvector(np.array(q))
-            a.Apply(u.vec, res)
-            resNonlin = ResortIndicesOfNGvector(-res.FV().NumPy())
-            return resNonlin
-
-        #jacobian function for FEM object:
-        #put some of the following functions into PyMatrixContainer for higher efficiency
-        def UFjacobian(mbs, t, itemNumber, q, q_t, fODE2, fODE2_t):
-            u.vec[:] = ResortIndicesExudyn2NGvector(np.array(q))
-            a.AssembleLinearization(u.vec)
-            Knonlinear = fODE2*csr_matrix( a.mat.CSR())#, copy=True )
-            Kexu = ScipySparseCSRtoCSR(Knonlinear)
-            nMK = Knonlinear.shape[0] #get size of mass matrix; assume square matrix!
-            ResortIndicesOfCSRmatrix(Kexu, nMK)
-            MCK = exu.MatrixContainer()
-            MCK.SetWithSparseMatrixCSR(nMK,nMK,Kexu)
-            return MCK
-        
-        #now add generic body built from FEM model with mass and stiffness matrix (optional damping could be added):
-        oGenericODE2 = mbs.AddObject(eii.ObjectGenericODE2(nodeNumbers = allNodeList, 
-                                                        massMatrix=Mcsr, 
-                                                        forceUserFunction=UFforce,
-                                                        jacobianUserFunction=UFjacobian,
-                                                        visualization=eii.VObjectGenericODE2(triangleMesh = fem.GetSurfaceTriangles(), color=color)
-                                                        ))
-
-        return [oGenericODE2, allNodeList]
-        
-    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute nModes smallest eigenvalues and eigenmodes from mass and stiffnessMatrix; store mode vectors in modeBasis, but exclude a number of 'excludeRigidBodyModes' rigid body modes from modeBasis; uses scipy for solution of generalized eigenvalue problem
-    #**input: 
-    #  nModes: prescribe the number of modes to be computed; total computed modes are  (nModes+excludeRigidBodyModes), but only nModes with smallest absolute eigenvalues are considered and stored
-    #  excludeRigidBodyModes: if rigid body modes are expected (in case of free-free modes), then this number specifies the number of eigenmodes to be excluded in the stored basis (usually 6 modes in 3D)
-    #  useSparseSolver: for larger systems, the sparse solver needs to be used, which iteratively solves the problem and uses a random number generator (internally in ARPACK): therefore, results are not fully repeatable!!!
-    #**notes: for NGsolve / Netgen meshes, see the according ComputeEigenmodesNGsolve function, which is usually much faster
-    #**output: eigenmodes are stored internally in FEMinterface as 'modeBasis' and eigenvalues as 'eigenValues'
-    def ComputeEigenmodes(self, nModes, excludeRigidBodyModes = 0, useSparseSolver = True):
-        if not useSparseSolver:
-            #unsorted, dense eigen vectors
-            from scipy.linalg import eigh#, solve, eig #eigh for symmetric matrices, positive definite
-
-            K = self.GetStiffnessMatrix(sparse=False)
-            M = self.GetMassMatrix(sparse=False)
-
-            [eigVals, eigVecs] = eigh(K,M) #this gives omega^2 ... squared eigen frequencies (rad/s)
-            self.modeBasis = {'matrix':eigVecs[:,excludeRigidBodyModes:excludeRigidBodyModes + nModes], 'type':'NormalNodes'}
-            self.eigenValues = abs(eigVals)
-        else:
-            #sorted, sparse eigen vectors
-            from scipy.sparse.linalg import eigsh #eigh for symmetric matrices, positive definite
-
-            K = CSRtoScipySparseCSR(self.GetStiffnessMatrix(sparse=True))
-            M = CSRtoScipySparseCSR(self.GetMassMatrix(sparse=True))
-            #optional, using shift-invert mode; DOES NOT WORK:
-            #guess for smallest eigenvalue:
-            #n=self.NumberOfCoordinates()
-            #mMax = self.GetMassMatrix(sparse=True)[:,2].sum()/3 #take total mass
-            #kMax = self.GetStiffnessMatrix(sparse=True)[:,2].max()   #assume only one node fixed
-            #omegaMin = kMax/mMax*0.1 #factor 0.1 in order to make guess not too large
-            #print("min freq=", np.sqrt(omegaMin)/(2*np.pi))
-            #[eigVals, eigVecs] = eigsh(A=K, k=nModes+excludeRigidBodyModes, M=M, which='SM', sigma=omegaMin) #this gives omega^2 ... squared eigen frequencies (rad/s)
-
-            #use "LM" (largest magnitude), but shift-inverted mode with sigma=0, to find the zero-eigenvalues:
-            #see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html
-            [eigVals, eigVecs] = eigsh(A=K, k=nModes+excludeRigidBodyModes, M=M, 
-                                       which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
-            
-            #[eigVals, eigVecs] = eigsh(A=K, k=nModes+excludeRigidBodyModes, M=M, which='SM') #this gives omega^2 ... squared eigen frequencies (rad/s)
-
-            self.modeBasis = {'matrix':eigVecs[:,excludeRigidBodyModes:excludeRigidBodyModes + nModes], 
-                              'type':'NormalModes'}
-            self.eigenValues = abs(eigVals[excludeRigidBodyModes:excludeRigidBodyModes + nModes])
-
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute eigenmodes, using a set of boundary nodes that are all fixed; very similar to ComputeEigenmodes, but with additional definition of (fixed) boundary nodes.
-    #**input: 
-    #  boundaryNodes: a list of boundary node indices, refering to 'Position' type nodes in FEMinterface; all coordinates of these nodes are fixed for the computation of the modes
-    #  nEigenModes: prescribe the number of modes to be computed; only nEigenModes with smallest abs(eigenvalues) are considered and stored
-    #  useSparseSolver: [yet NOT IMPLEMENTED] for larger systems, the sparse solver needs to be used, which iteratively solves the problem and uses a random number generator (internally in ARPACK): therefore, results are not fully repeatable!!!
-    #**output: eigenmodes are stored internally in FEMinterface as 'modeBasis' and eigenvalues as 'eigenValues'
-    def ComputeEigenModesWithBoundaryNodes(self, 
-                                      boundaryNodes,
-                                      nEigenModes, 
-                                      useSparseSolver = True):
-        if not useSparseSolver:
-            #unsorted, dense eigen vectors
-            from scipy.linalg import eigh#, solve, eig #eigh for symmetric matrices, positive definite
-    
-            K = self.GetStiffnessMatrix(sparse=False)
-            M = self.GetMassMatrix(sparse=False)
-            
-            if len(boundaryNodes) != 0:
-                #sizes of internal and boundary nodes:
-                n = len(M)
-                nb = len(boundaryNodes)*3
-                ni = n-nb
-        
-                #compute indices for internal and boundary DOF/coordinates:
-                DOFb = []
-                for node in boundaryNodes:
-                    DOFb += [node*3,node*3+1,node*3+2]
-                
-                DOFb = np.array(DOFb)
-                DOFb.sort()
-                DOFi = np.arange(n)
-                DOFi = np.delete(DOFi, DOFb)
-                DOFstatic = np.arange(nb) #for final mapping of boundary coordinates
-                DOFeig = np.arange(nb,nb+nEigenModes) #for final mapping of eigenmode coordinates
-                
-                print("n=", n, ", nb=",nb, ", ni=", ni)
-                #print("DOFb=", DOFb)
-                #print("DOFi=", DOFi)
-                
-                #create mass and stiffness matrices with new indices:
-                Mii = M[np.ix_(DOFi,DOFi)]
-                Kii = K[np.ix_(DOFi,DOFi)]
-                Kib = K[np.ix_(DOFi,DOFb)]
-    
-                print("solve eigenvalues...")
-                [eigVals, eigVecs] = eigh(Kii,Mii) #this gives omega^2 ... squared eigen frequencies (rad/s)
-    
-                print("solve static modes...")
-                KiiInvKib = -np.linalg.inv(Kii) @ Kib
-    
-                print("assemble matrices ...")
-                if False:
-                    modeBasis = np.zeros((n, nb+nEigenModes))
-                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
-                    modeBasis[np.ix_(DOFb,DOFstatic)] = np.eye(nb)
-                    modeBasis[np.ix_(DOFi,DOFstatic)] = KiiInvKib
-                else:
-                    modeBasis = np.zeros((n, nEigenModes))
-                    DOFeig = np.arange(nEigenModes) #for final mapping of eigenmode coordinates
-                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
-                
-                #print(modeBasis.shape)
-                #print(modeBasis.round(2))
-               
-                self.modeBasis = {'matrix':modeBasis, 'type':'NormalModes'}
-                self.eigenValues = abs(eigVals)
-    
-            else:
-                [eigVals, eigVecs] = eigh(K,M) #this gives omega^2 ... squared eigen frequencies (rad/s)
-                self.modeBasis = {'matrix':eigVecs[:,0:nEigenModes], 'type':'NormalNodes'}
-                self.eigenValues = abs(eigVals)
-        else:
-            raise ValueError("ComputeEigenModesWithBoundaryNodes: only implemented for dense mode")
-    
-    
-    
-    
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute static  and eigen modes based on Hurty-Craig-Bampton, for details see theory part \refSection{sec:theory:CMS}. Note that this function may need significant time, depending on your hardware, but 50.000 nodes will require approx. 1-2 minutes and more nodes typically raise time more than linearly.
-    #**input:
-    #  boundaryNodesList: [nodeList0, nodeList1, ...] a list of node lists, each of them representing a set of 'Position' nodes for which a rigid body interface (displacement/rotation and force/torque) is created; NOTE THAT boundary nodes may not overlap between the different node lists (no duplicated node indices!)
-    #  nEigenModes: number of eigen modes in addition to static modes (may be zero for RBE2/RBE3 computationMode); eigen modes are computed for the case where all rigid body motions at boundaries are fixed; only smallest nEigenModes absolute eigenvalues are considered
-    #  useSparseSolver: for more than approx.~500 nodes, it is recommended to use the sparse solver; dense mode not available for RBE3
-    #  computationMode: see class HCBstaticModeSelection for available modes; select RBE2 / RBE3 as standard, which is both efficient and accurate and which uses rigid-body-interfaces (6 independent modes) per boundary; RBE3 mode uses singular value decomposition, which requires full matrices for boundary nodes; this becomes slow in particular if the number of a single boundary node set gets larger than 500 nodes
-    #  boundaryNodesWeights: according list of weights with same order as boundaryNodesList, as returned e.g. by FEMinterface.GetNodeWeightsFromSurfaceAreas(...)
-    #  excludeRigidBodyMotion: if True (recommended), the first set of boundary modes is eliminated, which defines the reference conditions for the FFRF object
-    #  RBE3secondMomentOfAreaWeighting: if True, the weighting of RBE3 boundaries is done according to second moment of area; if False, the more conventional (but less appropriate) quadratic distance to reference point weighting is used
-    #  verboseMode: if True, some additional output is printed
-    #  timerTreshold: for more DOF than this number, CPU times are printed even with verboseMode=False
-    #**notes: for NGsolve / Netgen meshes, see the according ComputeHurtyCraigBamptonModesNGsolve function, which is usually much faster - currently only implemented for RBE2 case
-    #**output: stores computed modes in self.modeBasis and abs(eigenvalues) in self.eigenValues
-    def ComputeHurtyCraigBamptonModes(self,
-                                  boundaryNodesList,
-                                  nEigenModes, 
-                                  useSparseSolver = True,
-                                  computationMode = HCBstaticModeSelection.RBE2,
-                                  boundaryNodesWeights = [],
-                                  excludeRigidBodyMotion = True,
-                                  RBE3secondMomentOfAreaWeighting = True,
-                                  verboseMode = False,
-                                  timerTreshold = 20000):
-
-        #only makes sense for RBE3 modes:  positionOnlyModes: provide empty list [] to compute rigid body interfaces for all boundary node lists, or a boolean list [False, False, True, ...] to indicate which modes only have 3 position but no rotation modes; only valid for computationMode = RBE2 
-        #unsorted, dense eigen vectors
-        from scipy.linalg import eigh#, solve, eig #eigh for symmetric matrices, positive definite
-        from scipy.linalg import block_diag
-        import time #for some timers
-    
-        addRotationModes = 1 #may become an argument in future ...
-    
-    
-        if useSparseSolver: 
-            from scipy.sparse.linalg import eigsh, factorized #eigh for symmetric matrices, positive definite
-    
-            K = CSRtoScipySparseCSR(self.GetStiffnessMatrix(sparse=True))
-            M = CSRtoScipySparseCSR(self.GetMassMatrix(sparse=True))
-    
-        else: #not recommended for more than 2000 nodes (6000 DOF)!
-            if computationMode == HCBstaticModeSelection.RBE3:
-                raise ValueError('ComputeHurtyCraigBamptonModes: RBE3 mode only available in sparse mode')
-    
-            K = self.GetStiffnessMatrix(sparse=False)
-            M = self.GetMassMatrix(sparse=False)
-    
-        n = M.shape[0] #size of mass and stiffness matrix; assume square matrix!
-        verboseTimer = n>timerTreshold or verboseMode
-    
-    
-        for bnl in boundaryNodesList:
-            if not IsListOrArray(bnl,checkIfNoneEmpty=True):
-                raise ValueError('ComputeHurtyCraigBamptonModes: boundaryNodesList must contain non-empty node lists')
-                
-    
-            
-        if len(boundaryNodesWeights) != 0:
-            if len(boundaryNodesList) != len(boundaryNodesList):
-                raise ValueError('ComputeHurtyCraigBamptonModes: boundaryNodesWeights must be either empty or have same dimension as boundaryNodesList')
-                for i in range(len(boundaryNodesList)):
-                    if len(boundaryNodesWeights[i]) != len(boundaryNodesList[i]):
-                        raise ValueError('ComputeHurtyCraigBamptonModes: boundaryNodesWeights and boundaryNodesList must have same dimension for every sublist')
-            BNWlist = list(boundaryNodesWeights)
-        else: #create boundaryNodesWeights
-            BNWlist = []
-            for i in range(len(boundaryNodesList)):
-                nBNL = len(boundaryNodesList[i])
-                BNWlist += [1/nBNL*np.ones(nBNL)]
-        
-        
-        #implementation with RBE2 boundary mode
-        if len(boundaryNodesList) != 0:
-            
-            nb = 0
-            DOFb = []
-            nNodeLists = len(boundaryNodesList)
-            if 'Position' not in self.nodes or len(self.nodes) != 1:
-                raise ValueError('ComputeHurtyCraigBamptonModes: nodes in FEMinterface must be of position type!')
-            nodesPos = self.nodes['Position']
-            boundaryNodesMidPoints = []
-            
-            #determine sizes and some parameters:
-            for boundaryIndex, boundaryNodes in enumerate(boundaryNodesList):
-            #sizes of internal and boundary nodes:
-                nb += len(boundaryNodes)*3
-                #compute indices for internal and boundary DOF/coordinates:
-                for node in boundaryNodes:
-                    DOFb += [node*3,node*3+1,node*3+2]
-    
-                #compute midpoints of boundary nodes:
-                p = np.zeros(3)
-                for nodeIndex, node in enumerate(boundaryNodes):
-                    #OLD, without weighting: p += nodesPos[node]
-                    p += BNWlist[boundaryIndex][nodeIndex]*nodesPos[node]
-                
-                #OLD, without weighting: boundaryNodesMidPoints += [p*(1./len(boundaryNodes))]
-                boundaryNodesMidPoints += [p]
-    
-            if verboseMode:
-                print('calculated boundary midpoints=', boundaryNodesMidPoints)
-    
-            #compute boundary and internal DOF numbers:
-            DOFb = np.array(DOFb)
-            DOFi = np.arange(n)
-            DOFi = np.delete(DOFi, DOFb) #sorting not needed for DOFb
-                    
-            #create mass and stiffness matrices with new indices:
-            if useSparseSolver: 
-                #A = B.tocsr()[np.array(list1),:].tocsc()[:,np.array(list2)] faster?
-                #takes 0,042 seconds for 16000 nodes ...
-                Mii = M[DOFi,:][:,DOFi] #these matrices are np.array (dense) or sparse ...
-                Kii = K[DOFi,:][:,DOFi]
-                Kib = K[DOFi,:][:,DOFb]
-                if computationMode == HCBstaticModeSelection.RBE3:
-                    Kbi = K[DOFb,:][:,DOFi] #Kib.T may be used alternatively ...
-                    Kbb = K[DOFb,:][:,DOFb]
-                    
-                    Mbi = M[DOFb,:][:,DOFi] 
-                    Mib = M[DOFi,:][:,DOFb] 
-                    Mbb = M[DOFb,:][:,DOFb] 
-                
-            else:
-                #works also for sparse matrices, but computes dense matrices in between ...
-                Mii = M[np.ix_(DOFi,DOFi)] 
-                Kii = K[np.ix_(DOFi,DOFi)]
-                Kib = K[np.ix_(DOFi,DOFb)]
-            #Mii, Kii, Kib are now np.array (dense) or sparse ...
-        
-            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-            if nEigenModes != 0 and computationMode != HCBstaticModeSelection.RBE3:
-                if verboseTimer: print("compute eigenvalues and eigenvectors... "); start_time = time.time()
-                if useSparseSolver: 
-                    #for details on solver settings, see selfComputeEigenmodes(...)
-                    [eigVals, eigVecs] = eigsh(A=Kii, k=nEigenModes, M=Mii, 
-                                               which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
-                else:
-                    [eigVals, eigVecs] = eigh(Kii,Mii) #this gives omega^2 ... squared eigen frequencies (rad/s)
-                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
-    
-            #for testing and for case where only one boundary exists, which is eliminated afterwards ...
-            if computationMode == HCBstaticModeSelection.allBoundaryNodes: #quite inefficient, because it 
-                modeBasis = np.zeros((n, nb+nEigenModes))
-                DOFstatic = np.arange(nb) #for final mapping of boundary coordinates
-                if nEigenModes != 0:
-                    DOFeig = np.arange(nb,nb+nEigenModes) #for final mapping of eigenmode coordinates
-                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
-                
-                modeBasis[np.ix_(DOFb,DOFstatic)] = np.eye(nb)
-                if verboseTimer: print("factorize Kii... "); start_time = time.time()
-                if useSparseSolver: 
-                    invKii = factorized(Kii.tocsc()) #factorized expects csc format, otherwise warning
-                    KiiInvKib = invKii(-Kib.toarray())
-                else:
-                    KiiInvKib = -np.linalg.inv(Kii) @ Kib
-                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
-                modeBasis[np.ix_(DOFi,DOFstatic)] = KiiInvKib
-    
-            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-            #leading to infinitly stiff (rigid) boundaries; adds additional stiffening:
-            elif computationMode == HCBstaticModeSelection.RBE2:
-                rbSize = 3 + 3*addRotationModes #size of rigid body coordinates (3 for translation, 6 for translation+rotation)
-                nbRBE = (nNodeLists-int(excludeRigidBodyMotion))*rbSize #number of chosen static modes, 6 DOF per rigid body interface; exclude first rigid body boundary in order to suppress rigid body motion of static modes
-    
-                modeBasis = np.zeros((n, nbRBE+nEigenModes))
-                if nEigenModes != 0:
-                    DOFeig = np.arange(nbRBE,nbRBE+nEigenModes) #for final mapping of eigenmode coordinates
-                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
-                
-                #create list of mappings between average rigid body motion and boundary DOF matrix
-                rigidBodyMappings = [[]]*nNodeLists #list of mappings
-                cntBoundary = 0 #counter for boundaryNodeLists / number of interfaces
-                for boundaryNodes in boundaryNodesList:
-                    nn = len(boundaryNodes)
-                    #compute mapping from average displacement to displacement at boundary nodes:
-                    T = np.kron(np.ones(nn),np.eye(3)).T #maps rigid body motion of interface to all boundary nodes
-                    
-                    #compute mapping from (averaged) rotation at boundary to displacement of boundary nodes:
-                    if addRotationModes:
-                        Trot = np.zeros((nn*3,3))
-                        p0 = boundaryNodesMidPoints[cntBoundary]
-                        # for i in range(3): #iterate about 3 rotation axes
-                        #     rot = np.zeros(3) #rotation vector, unit rotation
-                        #     rot[i] = 1
-                        #     rotTilde = Skew(rot)
-                        #     for j in range(len(boundaryNodes)):
-                        #         p = nodesPos[boundaryNodes[j]]-p0
-                        #         pRot = rotTilde@p
-                        #         Trot[j*3:j*3+3,i] = pRot
-                        #shorter:
-                        for j in range(len(boundaryNodes)):
-                            p = nodesPos[boundaryNodes[j]]-p0
-                            pRot = Skew(p)
-                            Trot[j*3:j*3+3,:] = pRot
-                            
-                        T = np.hstack((T,Trot))
-                                
-    
-                    rigidBodyMappings[cntBoundary] = T
-                    cntBoundary += 1
-    
-                
-                Tall = block_diag(*rigidBodyMappings)  # '*' does unpacking of lists;
-                if excludeRigidBodyMotion:
-                    Tall = Tall[:,rbSize:] #exclude first rigid body boundary in order to suppress rigid body motion of static modes
-    
-                DOFstatic = np.arange(nbRBE) #for final mapping of boundary coordinates; 
-                modeBasis[np.ix_(DOFb,DOFstatic)] = Tall
-                if verboseTimer: print("factorize Kii... "); start_time = time.time()
-                if useSparseSolver: 
-                    invKii = factorized(Kii.tocsc()) #factorized expects csc format, otherwise warning
-                    KiiInvKibTall = invKii(-(Kib @ Tall)) #(Kib @ Tall) gives already dense matrix; may be huge ...!
-                else:
-                    KiiInvKibTall = -np.linalg.inv(Kii) @ (Kib @ Tall)
-                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
-    
-                modeBasis[np.ix_(DOFi,DOFstatic)] = KiiInvKibTall #KiiInvKib @ Tall
-    
-            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-            #advanced case: modes average motion at boundary; may not be desired, but does not add additional stiffening
-            elif computationMode == HCBstaticModeSelection.RBE3:
-                from scipy.linalg import svd
-                
-                rbSize = 3 + 3*addRotationModes #size of rigid body coordinates (3 for translation, 6 for translation+rotation)
-                nbRBE = (nNodeLists-int(excludeRigidBodyMotion))*rbSize #number of chosen static modes, 6 DOF per rigid body interface; exclude first rigid body boundary in order to suppress rigid body motion of static modes
-                dim3D =3 #3D displacement nodes
-    
-                modeBasis = np.zeros((n, nbRBE+nEigenModes))
-                
-                #create list of mappings between average rigid body motion and boundary DOF matrix
-                # rigidBodyMappings = [[]]*nNodeLists #list of mappings
-                modesRBE3 = [[]]*nNodeLists
-                #%%
-                from scipy import sparse
-                Knew = sparse.bmat([[Kbb,Kbi],[Kib, Kii]])
-                
-                bNodesCnt = 0
-                bNodesCntList = [bNodesCnt] #this list contains start and end indices of number of boundary nodes
-                for boundaryNodes in boundaryNodesList:
-                    bNodesCnt += len(boundaryNodes)
-                    bNodesCntList += [bNodesCnt]
-    
-                # print('boundaryNodesList =',boundaryNodesList )
-                # print('bNodesCntList =',bNodesCntList )
-    
-                Cmat = np.zeros((nNodeLists*rbSize, n)) #Constraint matrix
-                unitForces = []
-                
-                ClocalList = []
-                
-                for k, boundaryNodes in enumerate(boundaryNodesList):
-                    # print('********\nboundary ',k,':\n********')
-                    nPrev = bNodesCntList[k]
-                    nn = len(boundaryNodes)
-                    p0 = boundaryNodesMidPoints[k]
-    
-                    W=np.zeros((dim3D,dim3D)) #compute weighting ('inertia') for rotation part
-                    if addRotationModes:
-                        Clocal = np.zeros((rbSize, nn*dim3D))
-                        for j in range(len(boundaryNodes)):
-                            p = nodesPos[boundaryNodes[j]]-p0
-                            pRot = Skew(p)
-    
-                            #Cnode = BNWlist[k][j]*block_diag(np.eye(dim3D), pRot)
-                            Cnode = BNWlist[k][j]*np.vstack((np.eye(dim3D), pRot))
-                            Clocal[:,j*dim3D:(j+1)*dim3D] = Cnode
-                            
-                            if RBE3secondMomentOfAreaWeighting:
-                                W += -BNWlist[k][j]*pRot@pRot
-                            else:
-                                W += BNWlist[k][j]*(np.linalg.norm(p)**2)*np.eye(3) #could be easier to just sum up terms, but for consistency, it is also computed as matrix
-    
-                        WposRot = block_diag(np.eye(dim3D), W)
-                        WposRotInv = np.eye(6) #old mode
-                        #WposRotInv = np.linalg.inv(WposRot) #not necessary / does not influence results!
-                        
-                        Clocal = WposRotInv @ Clocal
-                        unitForces += [WposRotInv @ WposRot]
-                        #print('unit Forces=', unitForces)
-                        #print('W=', W)
-                        
-    
-                    else:
-                        unitForces += [np.eye(dim3D)]
-                        Clocal = np.kron(BNWlist[k],np.eye(dim3D)) #maps rigid body motion of interface to all boundary nodes
-                    
-                    ClocalList += [Clocal]
-    
-    
-                    Cmat[k*rbSize:(k+1)*rbSize, nPrev*dim3D:(nPrev+nn)*dim3D] = Clocal
-    
-                    
-                #==> now Cmat contains the constraint jacobian                
-                # print('Knew=',Knew.shape)
-                # print('Cmat=',Cmat.shape)
-    
-                #stiffness matrix + constraints:
-                KC = sparse.bmat([[Knew,Cmat.T],[Cmat, None]])
-                #print('KC=',KC.shape)
-                if verboseTimer: print("factorize KC... "); start_time = time.time()
-                invKC = factorized(KC.tocsc()) #factorized expects csc format, otherwise warning
-                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
-                
-                fUnit = np.zeros((n + nNodeLists*rbSize, rbSize)) #prescribed displacements
-                        
-                for k, boundaryNodes in enumerate(boundaryNodesList):
-                
-                    #add unit displacements at constraint equations side:
-                    fUnit *= 0
-                    #fUnit[n + k*rbSize:n + (k+1)*rbSize, :] = len(boundaryNodes)*np.eye(rbSize) #prescribed average unit displacemnets/rotations for boundary
-                    fUnit[n + k*rbSize:n + (k+1)*rbSize, :] = unitForces[k] #prescribed average unit displacemnets/rotations for boundary
-                    modesWithC = invKC(fUnit) 
-                    modes = modesWithC [:n,:]
-                    if verboseMode: print('max displacement=', np.amax(modes))
-    
-                    maxDisplacement = np.amax(modes)
-                    if maxDisplacement == 0: #should not occur
-                        maxDisplacement = 1
-                    
-                    modesRBE3[k] = (1/maxDisplacement)*modes #exclude solution for Lagrange multipliers
-                    
-                                
-                allModes = np.hstack(tuple(modesRBE3[int(excludeRigidBodyMotion):])) 
-                #print('allModes=',allModes.shape)
-                DOFstatic = np.arange(nbRBE) #for final mapping of boundary coordinates; 
-    
-                modeBasis[np.ix_(DOFb,DOFstatic)] = allModes[0:nb,:]
-                modeBasis[np.ix_(DOFi,DOFstatic)] = allModes[nb:,:]
-    
-    
-                #+++++++++++++++++++++++++++++++++++++
-                #now compute special RBE3 eigenmodes:
-                rigidBoundaries = False
-                if nEigenModes != 0: #otherwise, nothing to be done!
-                    if rigidBoundaries:
-                        [eigVals, eigVecs] = eigsh(A=Kii, k=nEigenModes, M=Mii, 
-                                                   which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
-                        # print('eigValues RBE2=', 0.5/pi*np.sqrt(eigVals))
-            
-                        DOFeig = np.arange(nbRBE,nbRBE+nEigenModes) #for final mapping of eigenmode coordinates
-                        modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
-                    if not rigidBoundaries:
-                        #singular value decomposition needs to be done PER BOUNDARY!
-                        
-                        rowsC = nNodeLists*rbSize
-                        nbReduced = nb-rowsC
-                        VlocalList = []
-                        for i, Clocal in enumerate(ClocalList):
-                            [U, s, V] = svd(Clocal)
-                            #VlocalList += [V[:-rbSize,:]]
-                            VlocalList += [V[rbSize:,:]]
-                        
-                            if np.amin(s) / np.amax(s) < 1e-8:
-                                print('************\nWARNING: ComputeHurtyCraigBamptonModes: expected '+str(rowsC) +
-                                      ' singular values, but some values are smaller than a threshold of 1e-8; check boundary nodes and mesh and \n************')
-                                #print('singular values=',s)
-                        
-                        V1 = block_diag(*VlocalList)
-                               
-                        # print('rowsC=',rowsC)
-                        # print('nb=',nb)
-                        # print('nbReduced=',nbReduced)
-                        # print('Kbb=',Kbb.shape)
-                        # print('Kbi=',Kbi.shape)
-                        # print('V=',V.shape)
-                        # print('U=',U.shape)
-                        # print('V1=',V1.shape)
-                        
-                        #compute reduced size matrices (just 6 columns/rows less per boundary/interface)
-                        KbbV = V1 @ Kbb @ V1.T
-                        KbiV = V1 @ Kbi
-                        KibV = Kib @ V1.T
-        
-                        MbbV = V1 @ Mbb @ V1.T
-                        MbiV = V1 @ Mbi
-                        MibV = Mib @ V1.T
-                        
-                        Knew = sparse.bmat([[KbbV,KbiV],[KibV, Kii]])
-                        Mnew = sparse.bmat([[MbbV,MbiV],[MibV, Mii]])
-                        # print('Knew=',Knew.shape)
-                        # print('Mnew=',Mnew.shape)
-                        
-                        [eigVals, eigVecs] = eigsh(A=Knew, k=nEigenModes, M=Mnew, 
-                                                   which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
-                        # print('eigValues RBE3=', 0.5/pi*np.sqrt(eigVals))
-                        eigVecsB = eigVecs[0:nbReduced,:] 
-                        eigVecsI = eigVecs[nbReduced:,:] 
-                        # print('eigVecsB=',eigVecsB.shape)
-                        eigVecsB = V1.T @ eigVecsB #project into original unconstrained space ...
-                        eigVecs = np.vstack((eigVecsB, eigVecsI))
-            
-                        DOFeig = np.arange(nbRBE,nbRBE+nEigenModes) #for final mapping of eigenmode coordinates
-                        modeBasis[np.ix_(list(DOFb)+list(DOFi),DOFeig)] = eigVecs[:,:nEigenModes]
-                    
-            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-    
-            elif computationMode == HCBstaticModeSelection.onlyEigenModes: #only eigen modes, e.g., for testing
-                if nEigenModes != 0:
-                    raise ValueError('ComputeHurtyCraigBamptonModes: in computationMode onlyEigenModes, nEigenModes must be != 0')
-    
-                modeBasis = np.zeros((n, nEigenModes))
-                DOFeig = np.arange(nEigenModes) #for final mapping of eigenmode coordinates
-                modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
-            
-            if modeBasis.shape[1] == 0:
-                print('************\nWARNING: ComputeHurtyCraigBamptonModes computed 0 modes, check boundaryNodesList and settings\n************')
-           
-            self.modeBasis = {'matrix':modeBasis, 'type':'HCBmodes'}
-            if nEigenModes != 0:
-                self.eigenValues = abs(eigVals)
-            else:
-                self.eigenValues = np.array([])
-    
-        else:
-            [eigVals, eigVecs] = eigh(K,M) #this gives omega^2 ... squared eigen frequencies (rad/s)
-            self.modeBasis = {'matrix':eigVecs[:,0:nEigenModes], 'type':'NormalModes'}
-            self.eigenValues = abs(eigVals)
-
-
-
-
-    #**classFunction: return list of eigenvalues in Hz of previously computed eigenmodes
-    def GetEigenFrequenciesHz(self):
-        return np.sqrt(self.eigenValues)/(2.*np.pi)
-
-    #internal function for ComputePostProcessingModes, do not call from outside FEM
-    def InternalComputePostprocessingMode(self,parameterList):
-        #map list of parameters to internal variables (due to multiprocessing)
-        iMode = parameterList[0]
-        nodes = parameterList[1]
-        modes = parameterList[2]
-        elemList = parameterList[3]
-        material = parameterList[4]
-        computeStrains = parameterList[5]
-        
-        nNodes = len(nodes)
-        nodesPerTet = 4
-        elemRefCoords = np.zeros(nodesPerTet*3)
-        displacements = np.zeros(nodesPerTet*3)
-        stressModesCnt = np.zeros(nNodes) #store how many elements contribute to nodal stress (for averaging)
-
-        stressModesMatrix = np.zeros((nNodes, 6)) #add up nodal stresses in this 6 modes for sigma_xx, sigma_yy, etc.
-        for elem in elemList:
-            for cnt in range(len(elem)):
-                ind = elem[cnt]
-                elemRefCoords[cnt*3:cnt*3+3] = nodes[ind,:]
-                displacements[cnt*3:cnt*3+3] = modes[ind*3:ind*3+3,iMode]
-                
-            tet=Tet4(material) #all material is the same ...
-            [Ev4, Sv4, B0, grad]=tet.ComputeMatrices(elemRefCoords, displacements)
-
-            #now write stresses into stress modes
-            for cnt in range(4): #number of nodes per element
-                ind = elem[cnt]  #node index
-                #if iMode == 0: #count how often nodes need to be averaged (count only for first mode)
-                stressModesCnt[ind] += 1
-                for j in range(6): #6 components
-                    if computeStrains:
-                        stressModesMatrix[ind,j] += Ev4[cnt, j]
-                    else:
-                        stressModesMatrix[ind,j] += Sv4[cnt, j]
-        nodeWarned = False
-        for ind in range(nNodes):
-            elPerNode = stressModesCnt[ind]
-            if elPerNode == 0:
-                if not nodeWarned:
-                    nodeWarned = True
-                    print('********\nWARNING:\n********\n Compute stress/strain modes: averaging of stress/strain at nodes failed, because node not connected to elements; this function only works for linear elements!')
-                elPerNode = 1 #does not matter because no element attached, no stress computed
-            stressModesMatrix[ind,:] *= 1/elPerNode
-
-        return stressModesMatrix
-
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute special stress or strain modes in order to enable visualization of stresses and strains in ObjectFFRFreducedOrder;
-    #**input: 
-    #  material: specify material properties for computation of stresses, using a material class, e.g. material = KirchhoffMaterial(Emodulus, nu, rho); not needed for strains
-    #  outputVariableType: specify either exudyn.OutputVariableType.StressLocal or exudyn.OutputVariableType.StrainLocal as the desired output variables
-    #  numberOfThreads: if numberOfThreads=1, it uses single threaded computation; if numberOfThreads>1, it uses the multiprocessing pools functionality, which requires that all code in your main file must be encapsulated within an if clause "if \_\_name\_\_ == '\_\_main\_\_':", see examples; if numberOfThreads==-1, it uses all threads/CPUs available
-    #**notes: This function is implemented in Python and rather slow for larger meshes; for NGsolve / Netgen meshes, see the according ComputePostProcessingModesNGsolve function, which is usually much faster
-    #**output: post processing modes are stored in FEMinterface in local variable postProcessingModes as a dictionary, where 'matrix' represents the modes and 'outputVariableType' stores the type of mode as a OutputVariableType
-    def ComputePostProcessingModes(self, material=0, 
-                                   outputVariableType='OutputVariableType.StressLocal',
-                                   numberOfThreads=1):
-        #import exudyn as exu #needed for outputVariableType
-
-        if str(outputVariableType) == 'OutputVariableType.StressLocal':
-            computeStrains = False
-        elif str(outputVariableType) == 'OutputVariableType.StrainLocal':
-            computeStrains = True
-        else:
-            raise ValueError('ComputePostProcessingModes invoked with invalid outputVariableType')
-            
-        nodes = self.nodes['Position']
-        nNodes = len(nodes)
-        if len(self.elements) != 1:
-            raise ValueError('ComputePostProcessingModes(...): only implemented for FEMinterface with one list of elements')
-        if 'Tet4' not in self.elements[0]:
-            raise ValueError('ComputePostProcessingModes(...): only implemented for Tet4 elements')
-        if 'matrix' not in self.modeBasis:
-            raise ValueError('ComputePostProcessingModes(...): modeBasis needs to be computed in FEMinterface prior to calling ComputePostProcessingModes; use e.g. ComputeEigenmodes(...)')
-            
-        elemList = self.elements[0]['Tet4']
-        modes = self.modeBasis['matrix']
-        nModes = modes.shape[1]
-        stressModes = np.zeros((nNodes, 6*nModes)) #add up nodal stresses
-
-        if material == 0:
-            material=KirchhoffMaterial(1, 0, 1)
-            if not computeStrains:
-                raise ValueError('ComputePostProcessingModes: if material=0, outputVariableType must be StrainLocal')
-
-        showProgress = False
-        if nModes*nNodes > 10000:
-            showProgress = True
-            #print("")
-
-        #create vectorized input data for ComputePostprocessingMode
-        vectorInput = [[]]*nModes
-        for i in range(nModes):
-            vectorInput[i] = [i,nodes, modes, elemList, material, computeStrains]
-            
-
-        useSingleThreading = True
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        if numberOfThreads > 1 or numberOfThreads == -1:
-            try:
-                from multiprocessing import Pool, cpu_count #parallelization of computation
-                if numberOfThreads == -1:
-                    numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
-                useSingleThreading = False
-            except:
-                pass
-            if not useSingleThreading:
-                vectorInput = np.array(vectorInput)
-                
-                useTQDM = False
-                if showProgress:
-                    try:
-                        import tqdm #progress bar
-                        try: #_instances only available after first run!
-                            tqdm.tqdm._instances.clear() #if open instances of tqdm, which leads to nasty newline
-                        except:
-                            pass
-                        useTQDM = True
-                        print("useTQDM")
-                    except:
-                        pass
-                
-                if useTQDM:
-                    with Pool(processes=numberOfThreads) as p:
-                        values = list(tqdm.tqdm(p.imap(self.InternalComputePostprocessingMode, vectorInput), 
-                                                total=nModes))
-                    print("", flush=True) #newline after tqdm progress bar output....
-                else:
-                    # simpler approach without tqdm:
-                    with Pool(processes=numberOfThreads) as p:
-                        values = p.map(self.InternalComputePostprocessingMode, vectorInput)
-
-                for iMode in range(nModes):
-                    stressModes[:,6*iMode:6*iMode+6] = values[iMode]
-                
-            
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        if useSingleThreading:
-            for iMode in range(nModes):
-                stressModeMatrix = self.InternalComputePostprocessingMode(vectorInput[iMode])
-                stressModes[:,6*iMode:6*iMode+6] = stressModeMatrix
-                
-                if showProgress:
-                    print("\rComputePostProcessingModes: " + str(iMode/nModes*100) + str("%"),end='', flush=True)
-
-            if showProgress:
-                print("") #line break finally
-
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-        self.postProcessingModes = {'matrix': stressModes, 
-                                    'outputVariableType': outputVariableType}
-        
-        #self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: compute Campbell diagram for given mechanical system
-    #create a first order system Axd + Bx = 0 with x= [q,qd]' and compute eigenvalues
-    #takes mass M, stiffness K and gyroscopic matrix G from FEMinterface
-    #currently only uses dense matrices, so it is limited to approx. 5000 unknowns!
-    #**input:
-    #  terminalFrequency: frequency in Hz, up to which the campbell diagram is computed
-    #  nEigenfrequencies: gives the number of computed eigenfrequencies(modes), in addition to the rigid body mode 0
-    #  frequencySteps: gives the number of increments (gives frequencySteps+1 total points in campbell diagram)
-    #  rotationAxis:[0,1,2] = [x,y,z] provides rotation axis
-    #  plotDiagram: if True, plots diagram for nEigenfrequencies befor terminating
-    #  verbose: if True, shows progress of computation; if verbose=2, prints also eigenfrequencies
-    #  useCorotationalFrame: if False, the classic rotor dynamics formulation for rotationally-symmetric rotors is used, where the rotor can be understood in a Lagrangian-Eulerian manner: the rotation is represented by an additional (Eulerian) velocity in rotation direction; if True, the corotational frame is used, which gives a factor 2 in the gyroscopic matrix and can be used for non-symmetric rotors as well
-    #  useSparseSolver: for larger systems, the sparse solver needs to be used for creation of system matrices and for the eigenvalue solver (uses a random number generator internally in ARPACK, therefore, results are not fully repeatable!!!)
-    #**output: [listFrequencies, campbellFrequencies]
-    #  listFrequencies: list of computed frequencies
-    #  campbellFrequencies: array of campbell frequencies per eigenfrequency of system
-    def ComputeCampbellDiagram(self, terminalFrequency, nEigenfrequencies=10, frequencySteps=25, 
-                               rotationAxis=2, plotDiagram=False, verbose=False, 
-                               useCorotationalFrame=False, useSparseSolver=False):
-        from scipy.linalg import eig #eigh for symmetric matrices, positive definite
-        
-        #create gyroscopic terms
-#        X=np.array([[ 0., -1.,  0.],
-#                    [ 1.,  0.,  0.],
-#                    [ 0.,  0.,  0.]])
-#        xBlock = np.kron(np.eye(nNodes), X) #create big block-diagonal matrix
-#        G=np.dot(xBlock,M)
-        
-        if self.NumberOfCoordinates() > 1000 and useSparseSolver == False:
-            print('WARNING: ComputeCampbellDiagram(...): system has more than 1000 coordinates, set useSparseSolver=True')
-            if self.NumberOfCoordinates() > 5000:
-                raise ValueError('ComputeCampbellDiagram(...): system has more than 5000 coordinates, MUST set useSparseSolver=True')
-
-        #dense matrix version:
-        if not useSparseSolver:        
-            M = self.GetMassMatrix(sparse=False)
-            K = self.GetStiffnessMatrix(sparse=False)
-            G = self.GetGyroscopicMatrix(rotationAxis=rotationAxis, sparse=False)
-    
-            #create system:
-            #A*x_t + B*x=0
-            nODE = self.NumberOfCoordinates()
-            B = np.block([[                    K, np.zeros((nODE,nODE))],
-                          [np.zeros((nODE,nODE)), -M                   ]])
-        
-            factorGyro = 1
-            if useCorotationalFrame:
-                factorGyro = 2 #this is the only difference to between fixed and corotational frame
-    #        terminalFrequencyCampbell = 2*np.pi*225 #rad/s
-            campbellFrequencies = []
-            listFrequencies = []
-    
-            for val in range(frequencySteps+1):
-                
-                omega = val * terminalFrequency * 2*np.pi / frequencySteps
-                if verbose:
-                    print("compute Campbell for frequency =", round(omega/(2*np.pi),3), " / ", terminalFrequency, '(Hz)')
-
-                if True:
-                    A = np.block([[factorGyro*omega * G, M                    ],
-                                  [                   M, np.zeros((nODE,nODE))]])
-            
-                
-                    Amod = -np.dot(np.linalg.inv(A),B)
-                
-                else:
-                    Minv = np.linalg.inv(M)
-                    #alternative approach:
-                    Amod = np.block([[np.zeros((nODE,nODE)),  np.eye(nODE) ],
-                                     [              -Minv@K, -Minv@(factorGyro*omega * G)]])
-                    
-                
-                #print("Amod =", Amod)
-                [eigVals, eigVecs] = eig(Amod) #this gives omega^2 ... squared eigen frequencies (rad/s)
-            
-                ev = np.sort(eigVals)
-            
-                listEigAbs = []
-                for i in range(len(ev)):
-                    v=abs(ev[i].imag/(2*np.pi))
-                    if not (v in listEigAbs):
-                        listEigAbs += [v]
-    
-                listEigAbs = np.sort(listEigAbs)
-                if verbose == 2:
-                    print('  frequencies =',listEigAbs[0:nEigenfrequencies+1])
-            
-                campbellFrequencies += [list(listEigAbs[0:nEigenfrequencies+1])] #+1 for rigid body mode 0
-                listFrequencies += [omega/(2*np.pi)]
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #SPARSE version:
-        else: 
-            from scipy import sparse
-            from scipy.sparse.linalg import eigs #, factorized
-            #[M, 0][q_tt] + [omega*G, 0] [q_t] = [0]
-            #[0, 0][q_t ] + [       , K] [q  ] = [0]
- 
-            #M*d(q_t) + omega*G*q_t + K * q = 0
-            #d(q) = q_t
-            #d(q_t) = -Minv*(omega*G*q_t+K*q)
-            
-            #       [0      , I      ]
-            #d(x) = [                ] * x
-            #       [-Minv*K, -omega*Minv*G] 
- 
-            M = CSRtoScipySparseCSR(self.GetMassMatrix(sparse=True))
-            K = CSRtoScipySparseCSR(self.GetStiffnessMatrix(sparse=True))
-            G = self.GetGyroscopicMatrix(rotationAxis=rotationAxis, sparse=True) #already in scypi sparse format
-    
-            nODE = self.NumberOfCoordinates()
-
-            # Minv = factorized(M.tocsc()) #factorized expects csc format, otherwise warning
-            # MinvK = sparse.csr_matrix(Minv(-K.toarray())) #slow, but no other way right now
-            # MinvG = sparse.csr_matrix(Minv((-G).toarray())) #this is for omega=1, multiplied with factor hereafter!
-
-            #twice as large mass-matrix:
-            M2 = sparse.bmat([[M   , None],
-                              [None, M   ]]) 
-            #M2inv = factorized(M2.tocsc()) 
-        
-            factorGyro = 1
-            if useCorotationalFrame:
-                factorGyro = 2 #this is the only difference to between fixed and corotational frame
-
-            campbellFrequencies = []
-            listFrequencies = []
-   
-            minNumberOfEigenvalues = 2*(nEigenfrequencies+1)
-    
-            for val in range(frequencySteps+1):
-                
-                omega = val * terminalFrequency * 2*np.pi / frequencySteps
-                if verbose:
-                    print("compute Campbell for frequency =", round(omega/(2*np.pi),3), " / ", terminalFrequency, '(Hz)')
-                # print('nEig:',nEigenfrequencies)
-                # A = sparse.bmat([[None , sparse.eye(nODE)        ],
-                #                  [MinvK, (factorGyro*omega)*MinvG]]) #in fact negative sign included in MinvK and MinvG!!!
-                
-                # [eigVals, eigVecs] = eigs(A=A, k=2*(nEigenfrequencies+1), #M=Mii, 
-                #                           which='LM', sigma=0)
-                A = sparse.bmat([[None , M        ],
-                                  [-K, -(factorGyro*omega)*G]]) #in fact negative sign included in MinvK and MinvG!!!
-                [eigVals, eigVecs] = eigs(A=A, k=2*(nEigenfrequencies+1), M=M2, #Minv=M2inv,
-                                          which='LM', sigma=0)
-            
-                ev = np.sort(eigVals)
-            
-                listEigAbs = []
-                for i in range(len(ev)):
-                    v=abs(ev[i].imag/(2*np.pi))
-                    if not (v in listEigAbs):
-                        listEigAbs += [v]
-    
-                listEigAbs = np.sort(listEigAbs)
-                if verbose == 2:
-                    print('  frequencies =',listEigAbs[0:nEigenfrequencies+1])
-            
-                minNumberOfEigenvalues = min(minNumberOfEigenvalues, len(listEigAbs))
-                campbellFrequencies += [list(listEigAbs[0:nEigenfrequencies+1])] #+1 for rigid body mode 0
-                    
-                listFrequencies += [omega/(2*np.pi)]
-
-            #sometimes there are several duplicated eigenvalues, therefore need to clean up...
-            cfClean = []
-            for freq in campbellFrequencies:
-                cfClean += [freq[0:minNumberOfEigenvalues]]
-            campbellFrequencies = cfClean
-            # print('minNumberOfEigenvalues=',minNumberOfEigenvalues)
-            #adjust in case that less results are available
-            nEigenfrequencies = min(nEigenfrequencies,minNumberOfEigenvalues-1)
-
-            
-        if plotDiagram:
-            import matplotlib.pyplot as plt
-            import matplotlib.ticker as ticker
-        
-            campbellFrequencies = np.array(campbellFrequencies)
-
-            nPlotFrequencies = nEigenfrequencies
-            if nEigenfrequencies > 27:
-                nPlotFrequencies = 27
-                print("only 27 eigenfrequencies can be plotted!")
-            
-            for i in range(nPlotFrequencies): #do not plot rigid body mode 0
-                plt.plot(listFrequencies, campbellFrequencies[:,i+1], PlotLineCode(i+1), label='freq '+str(i))
-
-            plt.plot(listFrequencies, listFrequencies, PlotLineCode(0), label='rotor speed (Hz)') 
-            
-            ax=plt.gca() # get current axes
-            ax.grid(True, 'major', 'both')
-            ax.xaxis.set_major_locator(ticker.MaxNLocator(10)) #use maximum of 8 ticks on y-axis
-            ax.yaxis.set_major_locator(ticker.MaxNLocator(10)) #use maximum of 8 ticks on y-axis
-            plt.xlabel("excitation / rotor frequency (Hz)")
-            plt.ylabel("eigen frequency (Hz)")
-            plt.tight_layout()
-            plt.legend()
-            plt.show() 
-
-        return [listFrequencies, campbellFrequencies]
-
-    #**classFunction: perform some consistency checks
-    def CheckConsistency(self):
-        nNodes = self.NumberOfNodes()
-        #nNodes = len(self.nodes['Position']) #old
-
-        if self.massMatrix.shape != (0,0):
-            (rows,columns) = CSRtoRowsAndColumns(self.massMatrix)
-            if rows != nNodes*3:
-                print("ERROR: CheckConsistency: massMatrix rows different from nodes coordinates dimension")
-            if columns != nNodes*3:
-                print("ERROR: CheckConsistency: massMatrix columns different from nodes coordinates dimension")
-
-        if self.stiffnessMatrix.shape != (0,0):
-            (rows,columns) = CSRtoRowsAndColumns(self.stiffnessMatrix)
-            if rows != nNodes*3:
-                print("ERROR: CheckConsistency: stiffnessMatrix rows different from nodes coordinates dimension")
-            if columns != nNodes*3:
-                print("ERROR: CheckConsistency: stiffnessMatrix columns different from nodes coordinates dimension")
-                
-
-    
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # Ansys    
-    
-    #**classFunction: read mass matrix from CSV format (exported from Ansys)
-    def ReadMassMatrixFromAnsys(self, fileName, dofMappingVectorFile, sparse=True, verbose=False):
-        if sparse:
-            self.massMatrix = ReadMatrixFromAnsysMMF(fileName, verbose)
-        else:
-            M = np.loadtxt(fileName,delimiter=',')
-            self.massMatrix = ConvertDenseToCompressedRowMatrix(M)
-
-        sorting = ReadMatrixDOFmappingVectorFromAnsysTxt(dofMappingVectorFile)
-        if len(sorting) < max(self.massMatrix[:,0]):
-            raise ValueError("ReadMassMatrixFromAnsys: dofMappingVectorFile and matrix size do not fit")
-
-        MapSparseMatrixIndices(self.massMatrix, sorting)
-
-    #**classFunction: read stiffness matrix from CSV format (exported from Ansys)
-    def ReadStiffnessMatrixFromAnsys(self, fileName, dofMappingVectorFile, sparse=True, verbose=False):
-        if sparse:
-            self.stiffnessMatrix = ReadMatrixFromAnsysMMF(fileName, verbose) 
-        else:
-            K = np.loadtxt(fileName,delimiter=',')
-            self.stiffnessMatrix = ConvertDenseToCompressedRowMatrix(K)
-
-        sorting = ReadMatrixDOFmappingVectorFromAnsysTxt(dofMappingVectorFile)
-        if len(sorting) < max(self.stiffnessMatrix[:,0]):
-            raise ValueError("ReadStiffnessMatrixFromAnsys: dofMappingVectorFile and matrix size do not fit")
-
-        MapSparseMatrixIndices(self.stiffnessMatrix, sorting)
-                    
-    #**classFunction: read nodal coordinates (exported from Ansys as .txt-File)
-    def ReadNodalCoordinatesFromAnsys(self, fileName, verbose=False):
-        nodes = ReadNodalCoordinatesFromAnsysTxt(fileName, verbose)
-        self.nodes['Position'] = np.array(nodes)
-        
-    #**classFunction: read elements (exported from Ansys as .txt-File)
-    def ReadElementsFromAnsys(self, fileName, verbose=False):
-        self.elements += [ReadElementsFromAnsysTxt(fileName, verbose)]
-        self.VolumeToSurfaceElements() #generate surface elements
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Support functions and helper classes for import of meshes, finite element models (ABAQUS, ANSYS, NETGEN) and for generation of FFRF (floating frame of reference) objects.
+#
+# Author:   Johannes Gerstmayr; Stefan Holzinger (Abaqus and Ansys import utilities); Joachim Sch\"oberl (support for Netgen and NGsolve \cite{Schoeberl1997,NGsolve2014,NGsolve2022} import and eigen computations)
+# Date:     2020-03-10 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+# Notes:    internal CSR matrix storage format contains 3 float numbers per row: [row, column, value], can be converted to scipy csr sparse matrices with function CSRtoScipySparseCSR(...)
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#constants and fixed structures:
+import exudyn.itemInterface as eii
+#from exudyn.utilities import 
+from exudyn.advancedUtilities import IsListOrArray, RoundMatrix, PlotLineCode
+from exudyn.rigidBodyUtilities import GetRigidBodyNode, AngularVelocity2EulerParameters_t, EulerParameters2GLocal, \
+             RotationVector2GLocal, RotXYZ2GLocal, RotXYZ2GLocal_t, ComputeSkewMatrix, Skew, eulerParameters0, \
+             StrNodeType2NodeType
+
+from exudyn.graphicsDataUtilities import ComputeTriangleArea
+
+import numpy as np #LoadSolutionFile
+from enum import Enum #for class HCBstaticModeSelection
+import os
+
+
+#convert zero-based sparse matrix data to dense numpy matrix
+#DEPRECTAED!!!!!!!!!!!!!!!!
+def CompressedRowToDenseMatrix(sparseData):
+    print("\n**************************\nWARNING: CompressedRowToDenseMatrix is deprecated!\n**************************\n")
+    n = int(max(np.max(sparseData[:,0]),np.max(sparseData[:,1]))) #rows and columns are 1-based
+    m = np.zeros((n,n))
+    for row in sparseData:
+        m[int(row[0])-1,int(row[1])-1] += row[2] #convert 1-based to 0-based; += for double entries
+    return m
+
+#**function: convert zero-based sparse matrix data to dense numpy matrix
+#**input: 
+#  sparseData: format (per row): [row, column, value] ==> converted into dense format
+#**output: a dense matrix as np.array
+def CompressedRowSparseToDenseMatrix(sparseData):
+    #does not work, if there are no entry in highest rows and columns
+    n = int(max(np.max(sparseData[:,0]),np.max(sparseData[:,1])))+1 #rows and columns indices are 0-based ==> add 1 for size!
+    m = np.zeros((n,n))
+    for row in sparseData:
+        m[int(row[0]),int(row[1])] += row[2]  #+= for double entries
+    return m
+
+#**function: resort a sparse matrix (internal CSR format) with given sorting for rows and columns; changes matrix directly! used for ANSYS matrix import
+def MapSparseMatrixIndices(matrix, sorting):
+    for row in matrix:
+        row[0] = sorting[int(row[0])]
+        row[1] = sorting[int(row[1])]
+
+
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute diadic product of vector v and a 3D unit matrix = diadic(v,I$_{3x3}$); used for ObjectFFRF and CMS implementation
+def VectorDiadicUnitMatrix3D(v):
+    return np.kron(np.array(v), np.eye(3)).T
+
+#print("diadicTest=", VectorDiadicUnitMatrix3D(np.array([1,2,3,4,5,6])))
+
+#+++++++++++++++++++++++++++
+#**function: compare cyclic two lists, reverse second list; return True, if any cyclic shifted lists are same, False otherwise
+def CyclicCompareReversed(list1, list2):
+    revList1 = np.flip(list1,0)
+    for i in range(len(list2)):
+        if (revList1 == np.roll(list2,i)).all(): return True
+    return False
+
+
+#**function: add entry to compressedRowSparse matrix, avoiding duplicates
+#value is either added to existing entry (avoid duplicates) or a new entry is appended
+def AddEntryToCompressedRowSparseArray(sparseData, row, column, value):
+    n = len(sparseData[:,0])
+    #print("AddEntryToCompressedRowSparseArray:",row,column,value, ", n=", n)
+    for i in range(n):
+        if int(sparseData[i,0]) == row and int(sparseData[i,1]) == column:
+            sparseData[i,2] += value
+            #print("AddEntryToCompressedRowSparseArray, value added")
+            return sparseData
+#        if int(sparseData[i,0]) > row:
+#            np.insert(sparseData, i, np.array((row, column, value)), 0)
+#            print("AddEntryToCompressedRowSparseArray, row inserted, i=",i)
+#            return sparseData
+    #insert at end of matrix:
+    #print("AddEntryToCompressedRowSparseArray, row added at end")
+    np.insert(sparseData, n, np.array((row, column, value)), 0)
+    return sparseData
+
+#**function: compute rows and columns of a compressed sparse matrix and return as tuple: (rows,columns)
+def CSRtoRowsAndColumns(sparseMatrixCSR):
+    rows = sparseMatrixCSR[:,0].max()
+    columns = sparseMatrixCSR[:,1].max()
+    return (rows, columns)
+
+#**function: convert internal compressed CSR to scipy.sparse csr matrix
+def CSRtoScipySparseCSR(sparseMatrixCSR):
+    from scipy.sparse import csr_matrix
+    X = csr_matrix((sparseMatrixCSR[:,2],(sparseMatrixCSR[:,0].astype(int),sparseMatrixCSR[:,1].astype(int))))
+    #X.sum_duplicates() 
+    return X
+
+
+#**function: convert scipy.sparse csr matrix to internal compressed CSR 
+def ScipySparseCSRtoCSR(scipyCSR):
+    #from scipy.sparse import csr_matrix
+    data=scipyCSR.tocoo()
+    sparseData = [data.row,data.col,data.data]
+    return np.array(sparseData).T
+
+#**function: resort indices of given NGsolve CSR matrix in XXXYYYZZZ format to XYZXYZXYZ format; numberOfRows must be equal to columns
+#needed for import from NGsolve
+def ResortIndicesOfCSRmatrix(mXXYYZZ, numberOfRows):
+    #compute resorting index array [0,1,2, 3,4,5, 6,7,8] ==> [0,3,6, 1,4,7, 2,5,8]
+    if numberOfRows%3 != 0:
+        raise ValueError("ResortIndicesOfCSRmatrix: numberOfRows must be multiple of 3")
+    
+    #compute transformation of indices:
+    r = np.arange(numberOfRows).reshape((int(numberOfRows/3),3))
+    r = r.T.flatten()
+    
+    mXXYYZZ[:,0] = r[mXXYYZZ[:,0].astype(int)]
+    mXXYYZZ[:,1] = r[mXXYYZZ[:,1].astype(int)]
+
+    # nSparse = len(mXXYYZZ)
+    # for i in range(nSparse): #for loop is slow, but works ok for 100.000 DOF
+    #     mXXYYZZ[i,0] = r[int(mXXYYZZ[i,0])]
+    #     mXXYYZZ[i,1] = r[int(mXXYYZZ[i,1])]
+    
+#**function: resort indices of given NGsolve vector in XXXYYYZZZ format to XYZXYZXYZ format
+def ResortIndicesOfNGvector(vXXYYZZ):
+    #compute resorting index array [0,1,2, 3,4,5, 6,7,8] ==> [0,3,6, 1,4,7, 2,5,8]
+    v = np.array(vXXYYZZ)
+    numberOfRows = len(v)
+    if numberOfRows%3 != 0:
+        raise ValueError("ResortIndicesOfNGvector: length must be multiple of 3")
+
+    vNew = np.zeros(numberOfRows)
+
+    #compute transformation of indices:
+    r = np.arange(numberOfRows).reshape((int(numberOfRows/3),3))
+    r = r.T.flatten()
+    
+    # for i in range(numberOfRows): #for loop is slow, but works ok for 100.000 DOF
+    #     vNew[r[i]] = v[i]
+    vNew[r[:]] = v[:]
+
+    return vNew
+    
+#**function: resort indices of given Exudyun vector XYZXYZXYZ to NGsolve vector in XXXYYYZZZ format
+def ResortIndicesExudyn2NGvector(vXYZXYZ):
+    #compute resorting index array [0,1,2, 3,4,5, 6,7,8] ==> [0,3,6, 1,4,7, 2,5,8]
+    v = np.array(vXYZXYZ)
+    numberOfRows = len(v)
+    if numberOfRows%3 != 0:
+        raise ValueError("ResortIndicesOfNGvector: length must be multiple of 3")
+
+    vNew = np.zeros(numberOfRows)
+
+    #compute transformation of indices:
+    r = np.arange(numberOfRows).reshape((int(numberOfRows/3),3))
+    r = r.T.flatten()
+    
+    # for i in range(numberOfRows): #for loop is slow, but works ok for 100.000 DOF
+    #     vNew[i] = v[r[i]]
+    vNew[:] = v[r[:]]
+
+    return vNew
+    
+
+
+
+#DEPRECATED!
+#read abaqus nodes information to numpy array
+#typeName is Part or Instance; name is part's or instance's name
+#if exportElement=False: returns np.array(nodes) with nodal coordinates
+#if exportElements=True: returns a list [np.array(nodes), elementsDict, surfaceElementsDict] with information on types of elements
+def ReadNodesFromAbaqusInp(fileName, typeName='Part', name='Part-1', exportElements=False):
+    print("\n********************WARNING:\nFUNCTION ReadNodesFromAbaqusInp is deprecated; use FEMinterface!\n********************\n")
+    fileLines = []
+    try: #still close file if crashes
+        file=open(fileName,'r') 
+        fileLines = file.readlines()
+    finally:
+        file.close()
+        
+        
+    print("read ", len(fileLines), "lines")
+    
+    startPart = False
+    startReadNodes = False
+    finishedReadNodes = False
+    startReadElements = False
+    finishedReadElements = False
+    nodes = [] #store list of node values
+    elements = [] #store list of elements with node numbers
+    surfaceElements = [] #store list of surface elements (trigs, quads) with node numbers
+    elementTypes = [] #string list of element types
+    surfaceElementTypes = [] #string list of surface element types
+
+    errorOccured = False
+    lineCnt = 0
+    for line in fileLines:
+        #print("line", lineCnt, "=", line)
+        lineCnt+=1
+        if errorOccured:
+            break
+        
+        if startReadNodes and not finishedReadNodes:
+            if line[0] != '*': #check if nodes section has finished
+                lineData = line.split(',') #split into values
+                if len(lineData) != 4:
+                    print("ERROR: Expected node number and 3 coordinates, line ", lineCnt)
+                    errorOccured = True
+                else:
+                    v = []
+                    for i in range(3):
+                        v+=[float(lineData[i+1])]
+                    nodes += [v] #add node data
+            else:
+                startReadNodes = False
+                finishedReadNodes = True
+    
+        if startReadElements and not finishedReadElements:
+            if line[0] != '*': #check if nodes section has finished
+                lineData = line.split(',') #split into values
+                if len(lineData) != 9:
+                    print("ERROR: Expected element number and 8 indices for C3D8R, line=", lineCnt)
+                    errorOccured = True
+                else:
+                    v = []
+                    for i in range(8):
+                        v+=[float(lineData[i+1])]
+                    elements += [v] #add node data
+                    elementTypes += ['Hex8'] #8-noded hexahedral
+            else:
+                startReadElements = False
+                finishedReadElements = True
+    
+        if startPart and not startReadNodes and not finishedReadNodes:
+            if line[0:5] == '*Node':
+                startReadNodes = True
+                startPart = False
+            else:
+                print("ERROR: Expected *Node after *Part, line=", lineCnt)
+                errorOccured = True
+
+        if finishedReadNodes and exportElements and not startReadElements:
+            if line[0:8] == '*Element':
+                startReadElements = True
+                #check "type=C3D8R" in future
+
+            
+        if line[0:len(typeName)+1] == '*'+typeName:
+            if not startPart:
+                #print("ERROR: only one *Part section allowed, line=", lineCnt)
+                #errorOccured = True
+                
+                lineInfo = line.split(',')
+                #print(lineInfo)
+                if len(lineInfo) != 3:
+                    print("ERROR: invalid information for part/instance name, line=", lineCnt)
+                    errorOccured = True
+                else:
+                    nameInfo = lineInfo[1].strip().split('=')
+                    if nameInfo[0] != 'name':
+                        print("ERROR: expected 'name=' in line=", lineCnt)
+                        errorOccured = True
+                    else:
+                        if nameInfo[1] != name:
+                            print("ERROR: expected name='" + name + "' in line=", lineCnt)
+                            errorOccured = True
+                        else:
+                            startPart = True
+    
+    if not exportElements:
+        return np.array(nodes)
+    else:
+        elementsDict = {'elements':np.array(elements), 'elementTypes':elementTypes}
+        surfaceElementsDict = {'elements':np.array(surfaceElements), 'elementTypes':surfaceElementTypes}
+        return [np.array(nodes), elementsDict, surfaceElementsDict]
+
+
+
+
+#**function: convert list of Hex8/C3D8  element with 8 nodes in nodeNumbers into triangle-List
+#**notes: works for Hex20 elements, but does only take the corner nodes for drawing!
+def ConvertHexToTrigs(nodeNumbers):
+    localList = [[0,1,2], [0,2,3], [6,5,4], [6,4,7], [0,4,1], [1,4,5], [1,5,2], [2,5,6], [2,6,3], [3,6,7], [3,7,0], [0,7,4]]
+
+    trigList = []
+    for trig in localList:
+        ind = [nodeNumbers[trig[0]], nodeNumbers[trig[1]], nodeNumbers[trig[2]]]
+        trigList += [ind]
+    return trigList
+
+#**function: convert list of Tet4/Tet10 element with 4 or 10 nodes in nodeNumbers into triangle-List
+#**notes: works for Tet10 elements, but does only take the corner nodes for drawing!
+def ConvertTetToTrigs(nodeNumbers):
+    localList = [[0,1,2], [0,3,1], [1,3,2], [0,2,3]]
+
+    trigList = []
+    for trig in localList:
+        ind = [nodeNumbers[trig[0]], nodeNumbers[trig[1]], nodeNumbers[trig[2]]]
+        trigList += [ind]
+    return trigList
+
+
+
+#**function: convert numpy.array dense matrix to (internal) compressed row format
+def ConvertDenseToCompressedRowMatrix(denseMatrix):
+    sparseMatrix = []
+    (nRows,nColumns) = denseMatrix.shape
+    for i in range(nRows):
+        for j in range(nColumns):
+            if denseMatrix[i,j] != 0.:
+                sparseMatrix += [[i,j,denseMatrix[i,j]]]
+    return np.array(sparseMatrix)
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function:This function reads either the mass or stiffness matrix from an Ansys
+#           Matrix Market Format (MMF). The corresponding matrix can either be exported 
+#           as dense matrix or sparse matrix.
+#
+#**input: fileName of MMF file
+#**output: internal compressed row sparse matrix (as (nrows x 3) numpy array)
+#
+#**author: Stefan Holzinger
+#
+#**notes:
+#   A MMF file can be created in Ansys by placing the following APDL code inside
+#   the solution tree in Ansys Workbench:
+#
+#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#   ! APDL code that exports sparse stiffnes and mass matrix in MMF format. If 
+#   ! the dense matrix is needed, replace *SMAT with *DMAT in the following
+#   ! APDL code.
+#    
+#   ! Export the stiffness matrix in MMF format
+#   *SMAT,MatKD,D,IMPORT,FULL,file.full,STIFF
+#   *EXPORT,MatKD,MMF,fileNameStiffnessMatrix,,,
+#
+#   ! Export the mass matrix in MMF format
+#   *SMAT,MatMD,D,IMPORT,FULL,file.full,MASS
+#   *EXPORT,MatMD,MMF,fileNameMassMatrix,,,
+#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#
+# In case a lumped mass matrix is needed, place the following APDL Code inside 
+# the Modal Analysis Tree:
+#
+#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#   ! APDL code to force Ansys to use a lumped mass formulation (if available for
+#   ! used elements)
+#   LUMPM, ON, , 0
+#   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+def ReadMatrixFromAnsysMMF(fileName, verbose=False):
+    if verbose: print("Start read matrix")
+    # read file
+    fileLines = []
+    file=open(fileName,'r') 
+    fileLines = file.readlines()
+    file.close()
+    
+    # delete text infos
+    offset = 0 #compute offset of comments and others
+    while fileLines[offset][0] == '%':
+        offset += 1
+        #del fileLines[0]
+    
+    # delete size information in fileLines
+    #del fileLines[0]
+    offset += 1
+
+    # put CSR data into this list
+    dataList = []
+    
+    # read row and col indices as well as corresponding matrix values
+    lineCnt = 0
+    for line in fileLines:
+        if lineCnt%500000 == 0 and lineCnt !=0: 
+            if verbose: print("parse line",lineCnt," / ", len(fileLines))
+        if lineCnt>=offset:
+            rowStr = line.rsplit()
+            
+            row=[int(rowStr[0])-1, int(rowStr[1])-1, float(rowStr[2])] #convert to 0-based format
+            dataList+=[row]
+            if row[0] != row[1]: #Ansys only stores half of matrix==>add symmetric terms except diagonal terms!
+                dataList+=[[row[1],row[0],row[2]]]
+        lineCnt+=1
+                    
+    return np.array(dataList)
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: read sorting vector for ANSYS mass and stiffness matrices and return sorting vector as np.array
+#  the file contains sorting for nodes and applies this sorting to the DOF (assuming 3 DOF per node!)
+#  the resulting sorted vector is already converted to 0-based indices
+def ReadMatrixDOFmappingVectorFromAnsysTxt(fileName):
+    fileLines = []
+    file=open(fileName,'r') 
+    fileLines = file.readlines()
+    file.close()
+    nLines = len(fileLines)
+
+    #read leading comments
+    lineOffset = 0
+    while lineOffset < nLines and fileLines[lineOffset][0] == '%':
+        lineOffset+=1
+
+    #check header:
+    rowStr = fileLines[lineOffset].rsplit()
+    nDOF = int(rowStr[0])
+    if int(rowStr[1]) != 1:
+        raise ValueError("ReadMatrixDOFmappingVectorFromAnsysTxt: invalid value in line " + str(lineOffset+1) + ", expected 1 column")
+
+    if int(rowStr[0]) != nLines-lineOffset-1:
+        raise ValueError("ReadMatrixDOFmappingVectorFromAnsysTxt: number of lines do not match the number of DOF: nDOF="+str(nDOF)+
+                         ", #data lines="+ str(nLines-lineOffset-1)) #removed arg_str() => Stefan
+
+    lineOffset+=1
+
+    #read now the mapping of the DOF line by line
+    dataList = []
+    lineCnt = 0
+    for line in fileLines:
+        if lineCnt>=lineOffset:
+            dataList += [(int(line)-1)*3+0] #convert to 0-base and apply for x,y and z coordinate of node ...
+            dataList += [(int(line)-1)*3+1] #convert to 0-base and apply for x,y and z coordinate of node ...
+            dataList += [(int(line)-1)*3+2] #convert to 0-base and apply for x,y and z coordinate of node ...
+        lineCnt+=1
+                    
+    return np.array(dataList)    
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: This function reads the nodal coordinates exported from Ansys.
+#
+#**input: fileName (file name ending must be .txt!)
+#**output: nodal coordinates as numpy array
+#
+#**author: Stefan Holzinger
+#
+#**notes:
+#   The nodal coordinates can be exported from Ansys by creating a named selection
+#   of the body whos mesh should to exported by choosing its geometry. Next, 
+#   create a second named selcetion by using a worksheet. Add the named selection
+#   that was created first into the worksheet of the second named selection.
+#   Inside the working sheet, choose 'convert' and convert the first created
+#   named selection to 'mesh node' (Netzknoten in german) and click on generate
+#   to create the second named selection. Next, right click on the second 
+#   named selection tha was created and choose 'export' and save the nodal 
+#   coordinates as .txt file.
+#   
+def ReadNodalCoordinatesFromAnsysTxt(fileName, verbose=False):
+    
+    # read file
+    fileLines = []
+    file=open(fileName,'r') 
+    fileLines = file.readlines()
+    file.close()
+            
+    # delete first line
+    del fileLines[0]
+    
+    # number of mesh nodes
+    numberOfNodes = len(fileLines)
+    
+    # allocate memory
+    # unsorted lists
+    unsortedNodalCoordinates = [None]*(numberOfNodes)
+    unsortedNodeNumberList   = [None]*(numberOfNodes)
+    currentNodalCoordinates  = np.zeros(3)
+    unsortedNodeDictList     = [None]*(numberOfNodes)
+    # sorted lists
+    #sortedNodalCoordinates = [None]*(numberOfNodes)
+    sortedNodalCoordinates = np.zeros((numberOfNodes,3),dtype=float)
+    sortedNodeNumberList   = [None]*(numberOfNodes)
+    sortedNodeListDict     = [None]*(numberOfNodes)
+    
+    lineCtr = 0
+    for line in fileLines:
+        #if lineCtr%10000 == 0: print("read node",lineCtr)
+        # remove '\n' from value at line end
+        currentLine = line.rsplit()
+            
+        # add node index (one based) and corresponding nodal coordinates to node dict   
+        currentNodalCoordinates = currentLine[1:]   
+        for i in range(len(currentNodalCoordinates)): 
+            currentNodalCoordinates[i] = float(currentNodalCoordinates[i].replace(",","."))   
+        
+        # add items to corresponding list
+        unsortedNodeNumberList[lineCtr]   = int(currentLine[0])
+        unsortedNodalCoordinates[lineCtr] = currentNodalCoordinates
+        unsortedNodeDictList[lineCtr]     = {"nodeNr":int(currentLine[0]), "nodalCoordinates": currentNodalCoordinates}
+            
+        # increase line counter
+        lineCtr += 1        
+        
+    
+    # sort node list w.r.t. increasing node numbers
+    sortedNodeListDict = sorted(unsortedNodeDictList, key = lambda i: i["nodeNr"])
+    dictCtr = 0
+    for dict_ in sortedNodeListDict:
+        
+        sortedNodalCoordinates[dictCtr] = sortedNodeListDict[dictCtr]["nodalCoordinates"]
+        sortedNodeNumberList[dictCtr]   = sortedNodeListDict[dictCtr]["nodeNr"]
+        dictCtr += 1
+    
+    return sortedNodalCoordinates
+
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: This function reads the nodal coordinates exported from Ansys.
+#
+#**input: fileName (file name ending must be .txt!)
+#**output: element connectivity as numpy array
+#
+#**author: Stefan Holzinger
+#
+#**notes:
+#   The elements can be exported from Ansys by creating a named selection
+#   of the body whos mesh should to exported by choosing its geometry. Next, 
+#   create a second named selcetion by using a worksheet. Add the named selection
+#   that was created first into the worksheet of the second named selection.
+#   Inside the worksheet, choose 'convert' and convert the first created
+#   named selection to 'mesh element' (Netzelement in german) and click on generate
+#   to create the second named selection. Next, right click on the second 
+#   named selection tha was created and choose 'export' and save the elements 
+#   as .txt file.
+def ReadElementsFromAnsysTxt(fileName, verbose=False):
+    
+    # read file
+    fileLines = []
+    file=open(fileName,'r') 
+    fileLines = file.readlines()
+    file.close()
+                
+    # delete first line ==> contains text
+    del fileLines[0]
+        
+    # number of mesh nodes
+    #numberOfElements = len(fileLines) #do not trust this, could be changed with one additional line
+    numberOfElements = 0
+
+    #check file consistency => first columns should contain element number (1-based)
+    for i in range(len(fileLines)):
+        line = fileLines[i]
+        n = int(line.rsplit()[0])
+        #print("element:", n)
+        if n == i+1: 
+            numberOfElements = n
+        else:
+            raise ValueError("ReadElementsFromAnsysTxt: invalid format in line "+str(i+2)+": expected element number, type and connectivity; be careful with empty lines")
+                
+    
+    # allocate memory
+    elementTypeList = [None]*(numberOfElements)
+    elementConnectivityList = [None]*(numberOfElements)
+    currentNodeIndexList = []
+    
+    for lineCtr in range(numberOfElements):
+        if lineCtr%10000 == 0 and lineCtr !=0: 
+            if verbose: print("read element",lineCtr," / ", numberOfElements)
+        #if lineCtr%10000 == 0: print("read element",lineCtr)
+        line = fileLines[lineCtr]
+        
+        # split current line at \n
+        currentLine = line.rsplit()
+        
+        # get element type of current element
+        elementTypeList[lineCtr] = currentLine[1]
+        
+        # get element connectivity of current element
+        for node in currentLine[2:]:
+            currentNodeIndexList.append( int(node)-1 )  # convert to zero based
+        
+        # add element connectivity of current element to elementConnectivityList 
+        elementConnectivityList[lineCtr] = currentNodeIndexList 
+        
+        # clear current node index list (nodes that form the current element)
+        currentNodeIndexList = []
+        
+    #elementsDict = {'Name':'elements', 'Tet4':[], 'Hex8':elementConnectivityList}
+    elementsDict = {'Name':'elements'}
+
+    if verbose: print("create element dictionaries...")
+    for lineCtr in range(numberOfElements):
+        line = fileLines[lineCtr]
+        if not(elementTypeList[lineCtr] in elementsDict):
+            elementsDict[elementTypeList[lineCtr]] = []
+        elementsDict[elementTypeList[lineCtr]] += [elementConnectivityList[lineCtr]]
+
+    return elementsDict
+
+
+
+
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: material base class, e.g., for FiniteElement
+class MaterialBaseClass:
+    def __init__(self, youngsModulus, poissonsRatio, density):
+        self.youngsModulus = youngsModulus
+        self.poissonsRatio = poissonsRatio
+        self.density = density
+
+#**class: class for representation of Kirchhoff (linear elastic, 3D and 2D) material
+#**notes: use planeStress=False for plane strain
+class KirchhoffMaterial(MaterialBaseClass):
+    def __init__(self, youngsModulus, poissonsRatio, density = 0, planeStress = True):
+        super().__init__(youngsModulus, poissonsRatio, density)
+        self.planeStress = planeStress
+
+        Em = self.youngsModulus
+        nu = self.poissonsRatio
+
+        lam = nu*Em / ((1 + nu) * (1 - 2*nu))
+        mu = Em / (2*(1 + nu))
+        self.elasticityTensor = np.array([[lam + 2*mu, lam, lam, 0, 0, 0],
+                              [lam, lam + 2*mu, lam, 0, 0, 0],
+                              [lam, lam, lam + 2*mu, 0, 0, 0],
+                              [0, 0, 0, mu, 0, 0],
+                              [0, 0, 0, 0, mu, 0],
+                              [0, 0, 0, 0, 0, mu]])
+
+        if self.planeStress:
+            self.elasticityTensor2D = Em/(1-nu**2)*np.array([[1, nu, 0],
+                                                            [nu, 1, 0],
+                                                            [0, 0, (1-nu)/2]])
+        else:
+            self.elasticityTensor2D = np.array([[lam + 2*mu, lam, 0],
+                                                [lam, lam + 2*mu, 0],
+                                                [0, 0, mu]])
+
+
+    #**classFunction: convert strain tensor into stress tensor using elasticity tensor
+    def Strain2Stress(self, strain):
+        E = strain
+        strainVector = np.array([  E[0,0],   E[1,1],   E[2,2],
+                                 2*E[1,2], 2*E[0,2], 2*E[0,1]])
+        SV = self.StrainVector2StressVector(strainVector)
+        S = np.array([[SV[0], SV[5], SV[4]],
+                      [SV[5], SV[1], SV[3]],
+                      [SV[4], SV[3], SV[2]]])
+        return S
+
+    #**classFunction: convert strain vector into stress vector
+    def StrainVector2StressVector(self, strainVector):
+        return self.elasticityTensor @ strainVector
+
+    #**classFunction: compute 2D stress vector from strain vector
+    def StrainVector2StressVector2D(self, strainVector2D):
+        #E=strain
+        #strainVector2D = np.array([E[0,0], E[1,1], 2*E[0,1]])
+        SV = self.elasticityTensor2D @ strainVector2D
+        #S = np.array([[SV[0], SV[2]], [SV[2], SV[1]]])
+        return SV
+
+    #**classFunction: compute Lame parameters from internal Young's modulus and Poisson ratio
+    #**output: return vector [mu, lam] of Lame parameters
+    def LameParameters(self):
+        E = self.youngsModulus
+        nu = self.poissonsRatio
+        mu  = E / 2 / (1+nu) #Lame parameters
+        lam = E * nu / ((1+nu)*(1-2*nu))
+        return [mu, lam]
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: finite element base class for lateron implementations of other finite elements
+class FiniteElement:
+    def __init__(self, material):
+        self.material = material
+    
+#**class: simplistic 4-noded tetrahedral interface to compute strain/stress at nodal points
+class Tet4(FiniteElement):
+    def __init__(self, material):
+        super().__init__(material)
+    
+    #return (per node) linearized strain, linearized stress, reference B-matrix and deformation gradient
+    def ComputeMatrices(self, nodalReferenceCoordinates, nodalDisplacements):
+        #following routines implemented according to implementation in AMFE (TU-Munich):
+        [X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3, X4, Y4, Z4] = nodalReferenceCoordinates
+        
+        Umat = nodalDisplacements.reshape(-1, 3)
+        #Xmat = nodalReferenceCoordinates.reshape(-1, 3)
+
+        det = (-X1*Y2*Z3 + X1*Y2*Z4 + X1*Y3*Z2 - X1*Y3*Z4 - X1*Y4*Z2 + X1*Y4*Z3 
+              + X2*Y1*Z3 - X2*Y1*Z4 - X2*Y3*Z1 + X2*Y3*Z4 + X2*Y4*Z1 - X2*Y4*Z3 
+              - X3*Y1*Z2 + X3*Y1*Z4 + X3*Y2*Z1 - X3*Y2*Z4 - X3*Y4*Z1 + X3*Y4*Z2 
+              + X4*Y1*Z2 - X4*Y1*Z3 - X4*Y2*Z1 + X4*Y2*Z3 + X4*Y3*Z1 - X4*Y3*Z2)
+
+        #compute B matrix for reference coordinates
+        B0 = 1/det*np.array([
+            [-Y2*Z3 + Y2*Z4 + Y3*Z2 - Y3*Z4 - Y4*Z2 + Y4*Z3,
+              X2*Z3 - X2*Z4 - X3*Z2 + X3*Z4 + X4*Z2 - X4*Z3,
+              -X2*Y3 + X2*Y4 + X3*Y2 - X3*Y4 - X4*Y2 + X4*Y3],
+            [ Y1*Z3 - Y1*Z4 - Y3*Z1 + Y3*Z4 + Y4*Z1 - Y4*Z3,
+              -X1*Z3 + X1*Z4 + X3*Z1 - X3*Z4 - X4*Z1 + X4*Z3,
+              X1*Y3 - X1*Y4 - X3*Y1 + X3*Y4 + X4*Y1 - X4*Y3],
+            [-Y1*Z2 + Y1*Z4 + Y2*Z1 - Y2*Z4 - Y4*Z1 + Y4*Z2,
+              X1*Z2 - X1*Z4 - X2*Z1 + X2*Z4 + X4*Z1 - X4*Z2,
+              -X1*Y2 + X1*Y4 + X2*Y1 - X2*Y4 - X4*Y1 + X4*Y2],
+            [ Y1*Z2 - Y1*Z3 - Y2*Z1 + Y2*Z3 + Y3*Z1 - Y3*Z2,
+              -X1*Z2 + X1*Z3 + X2*Z1 - X2*Z3 - X3*Z1 + X3*Z2,
+              X1*Y2 - X1*Y3 - X2*Y1 + X2*Y3 + X3*Y1 - X3*Y2]])
+
+        #displacement gradient:
+        grad = Umat.T @ B0
+        #deformation gradient:
+        #F = grad + np.eye(3)
+
+        #linearized strain:
+        linE = 0.5*(grad + grad.T)
+        strainVector = np.array([  linE[0,0],   linE[1,1],   linE[2,2],
+                                 2*linE[1,2], 2*linE[0,2], 2*linE[0,1]])
+        
+        stressVector = self.material.StrainVector2StressVector(strainVector)
+        
+        # strainVector4 = np.ones((4,1)) @ np.array([[linE[0,0],   linE[1,1],   linE[2,2],
+        #                                             2*linE[1,2], 2*linE[0,2], 2*linE[0,1]]])
+        strainVector4 = np.ones((4,1)) @ np.array([strainVector])
+
+        stressVector4 = np.ones((4,1)) @ np.array([stressVector])
+
+        #strainvector per node:
+        return [strainVector4, stressVector4, B0, grad]
+
+
+
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++++          ObjectFFRF                               ++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: compute terms necessary for ObjectFFRF
+#class used internally in FEMinterface to compute ObjectFFRF object 
+#this class holds all data for ObjectFFRF user functions
+class ObjectFFRFinterface:
+    #**classFunction: initialize ObjectFFRFinterface with FEMinterface class
+    #  initializes the ObjectFFRFinterface with nodes, modes, surface description and systemmatrices from FEMinterface
+    #  data is then transfered to mbs object with classFunction AddObjectFFRF(...)
+    def __init__(self, femInterface):
+        self.modeBasis = femInterface.modeBasis['matrix']
+        self.nodeArray = femInterface.GetNodePositionsAsArray()
+        self.trigList = femInterface.GetSurfaceTriangles()
+
+        #stiffnessMatrixCSR = CSRtoScipySparseCSR(femInterface.GetStiffnessMatrix(sparse=True))
+        self.massMatrixCSR = CSRtoScipySparseCSR(femInterface.GetMassMatrix(sparse=True)) #for multiplications
+        self.stiffnessMatrixSparse = femInterface.GetStiffnessMatrix(sparse=True)
+        self.massMatrixSparse = femInterface.GetMassMatrix(sparse=True)
+
+        #new coordinates:
+        self.nNodes = len(self.nodeArray)                   #stored in nNodes x 3 np-array
+        self.dim3D = len(self.nodeArray[0])                 #dimension of position, assuming that one node exists ....
+        self.nODE2rot = 4                                   #dimension of rotation parameters; fixed to 4 for now!
+        self.nODE2rigid = self.dim3D + self.nODE2rot
+        self.nODE2FF = self.nNodes * self.dim3D
+        self.nODE2FFRF = self.nODE2rigid + self.nODE2FF
+        # nNodesFFRF = self.nNodes+1                          #including rigid body node
+
+        #self.massMatrixFFRF = np.zeros((self.nODE2FFRF,self.nODE2FFRF)) #create larger FFRF mass matrix
+        #self.stiffnessMatrixFFRF = np.zeros((self.nODE2FFRF,self.nODE2FFRF)) #create larger FFRF mass matrix
+
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #FFRFreduced constant matrices:
+        self.Phit = np.kron(np.ones(self.nNodes),np.eye(3)).T
+        self.PhitTM = self.Phit.T @ self.massMatrixCSR #LARGE MATRIX COMPUTATION
+        self.xRef = self.nodeArray.flatten()                     #node reference values in single vector (can be added then to q[7:])
+        self.xRefTilde = ComputeSkewMatrix(self.xRef) #rfTilde without q    
+
+        #not needed, but may be interesting for checks:
+        self.inertiaLocal = self.xRefTilde.T @ self.massMatrixCSR @ self.xRefTilde #LARGE MATRIX COMPUTATION
+
+
+    #**classFunction: add according nodes, objects and constraints for FFRF object to MainSystem mbs; only implemented for Euler parameters
+    #**input:
+    #  exu: the exudyn module
+    #  mbs: a MainSystem object
+    #  positionRef: reference position of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
+    #  eulerParametersRef: reference euler parameters of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
+    #  initialVelocity: initial velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
+    #  initialAngularVelocity: initial angular velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
+    #  gravity: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
+    #  constrainRigidBodyMotion: set True in order to add constraint (Tisserand frame) in order to suppress rigid motion of mesh nodes
+    #  color: provided as list of 4 RGBA values
+    #add object to mbs as well as according nodes
+    def AddObjectFFRF(self, exu, mbs, 
+                      positionRef=[0,0,0], eulerParametersRef=[1,0,0,0], 
+                      initialVelocity=[0,0,0], initialAngularVelocity=[0,0,0],
+                      gravity=[0,0,0],
+                      constrainRigidBodyMotion=True, 
+                      massProportionalDamping = 0, stiffnessProportionalDamping = 0,
+                      color=[0.1,0.9,0.1,1.]):
+
+        self.gravity = gravity
+
+        #compute initial euler parameter velocities from angular velocity vector
+        self.eulerParameters_t0 = AngularVelocity2EulerParameters_t(initialAngularVelocity, eulerParametersRef)
+        self.eulerParameters0 = eulerParametersRef
+
+        #rigid body node for ObjectFFRF
+        self.nRigidBody = mbs.AddNode(eii.NodeRigidBodyEP(referenceCoordinates=list(positionRef)+list(eulerParametersRef), 
+                                            initialVelocities=list(initialVelocity)+list(self.eulerParameters_t0)))
+
+        self.nodeList = [] #list of nodenumbers in mbs
+        for node in self.nodeArray:
+            nMBS = mbs.AddNode(eii.Point(referenceCoordinates = list(node), visualization=eii.VNodePoint(show = False))) 
+            self.nodeList += [nMBS]
+
+        stiffnessMatrixMC = exu.MatrixContainer()
+        #stiffnessMatrixMC.SetWithSparseMatrixCSR(self.nODE2FF, self.nODE2FF, self.stiffnessMatrixSparse,useDenseMatrix=False)
+        stiffnessMatrixMC.SetWithDenseMatrix(CompressedRowSparseToDenseMatrix(self.stiffnessMatrixSparse),useDenseMatrix=False)
+
+        massMatrixMC = exu.MatrixContainer()
+        #massMatrixMC.SetWithSparseMatrixCSR(self.nODE2FF, self.nODE2FF, self.massMatrixSparse,useDenseMatrix=False)
+        massMatrixMC.SetWithDenseMatrix(CompressedRowSparseToDenseMatrix(self.massMatrixSparse),useDenseMatrix=False)
+
+        if (massProportionalDamping != 0 or massProportionalDamping != 0):
+            dampingMatrixMC = exu.MatrixContainer()
+            dampingMatrixMC.SetWithDenseMatrix(massProportionalDamping*CompressedRowSparseToDenseMatrix(self.massMatrixSparse)+
+                                               stiffnessProportionalDamping*CompressedRowSparseToDenseMatrix(self.stiffnessMatrixSparse),useDenseMatrix=False)
+        else:
+            dampingMatrixMC=[]
+        
+        #add body for FFRF-Object:
+        self.oFFRF = mbs.AddObject(eii.ObjectFFRF(nodeNumbers = [self.nRigidBody] + self.nodeList, 
+                                                            massMatrixFF=massMatrixMC,
+                                                            stiffnessMatrixFF=stiffnessMatrixMC, 
+                                                            dampingMatrixFF=dampingMatrixMC,
+                                                            #dampingMatrixFF=emptyMC,
+                                                            #forceVector=fNew,
+                                                            #forceUserFunction=UFforce,
+                                                            #computeFFRFterms=True,
+                                                            #massMatrixUserFunction=UFmassGenericODE2,
+                                                            visualization=eii.VObjectFFRF(triangleMesh = self.trigList, 
+                                                                                      color=color,
+                                                                                      showNodes = True)))
+
+
+        self.oRigidBodyConstraint = -1
+        if constrainRigidBodyMotion:
+            mObjectCoordinates = mbs.AddMarker(eii.MarkerObjectODE2Coordinates(objectNumber=self.oFFRF))
+            nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=[0,0,0], 
+                                                      visualization = eii.VNodePointGround(show=False))) #ground node for coordinate constraint
+            mGroundCoordinate = mbs.AddMarker(eii.MarkerNodeCoordinates(nodeNumber = nGround)) #Ground node ==> no action
+
+            X1 = np.zeros((6, self.nODE2FFRF))
+            X1rot = ComputeSkewMatrix(self.xRef).T @ self.massMatrixCSR
+            X1[0:3,self.nODE2rigid:] = self.PhitTM
+            X1[3:6,self.nODE2rigid:] = X1rot
+            offset = np.zeros(6)
+            offset[0:3] = self.PhitTM @ self.xRef #constrain current COM to reference COM
+
+            #add constraint: X1*qObjectFFRF - offset = 0
+            self.oRigidBodyConstraint = mbs.AddObject(eii.CoordinateVectorConstraint(markerNumbers=[mGroundCoordinate, mObjectCoordinates], 
+                                                                                 scalingMarker1 = X1, offset=offset))
+
+        dictReturn = {'nRigidBody':self.nRigidBody,
+                      'nodeList':self.nodeList,
+                      'oFFRF':self.oFFRF,
+                      'oRigidBodyConstraint':self.oRigidBodyConstraint}
+
+        return dictReturn
+
+    #**classFunction: optional forceUserFunction for ObjectFFRF (per default, this user function is ignored)
+    def UFforce(self, exu, mbs, t, q, q_t):
+        print("UFforce: not tested and not integrated in to FFRFinterface!")
+
+        force = np.zeros(self.nODE2FFRF)
+        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
+        A = Avec.reshape((3,3))
+
+        #implementation for Euler Parameters (Glocal_t*theta_t=0)
+        ep = np.array(q[self.dim3D:self.nODE2rigid]) + eulerParameters0 #add reference values, q are only the change w.r.t. reference values!
+        G = EulerParameters2GLocal(ep)
+    
+        cF_t = np.array(q_t[self.nODE2rigid:])         #velocities of flexible coordinates
+
+        rF = self.xRef + np.array(q[self.nODE2rigid:]) #nodal position
+
+        omega3D = G @ np.array(q_t[self.dim3D:self.nODE2rigid])
+        omega3Dtilde = Skew(omega3D)
+        #omega = np.array(list(omega3D)*self.nNodes)
+        omegaTilde = np.kron(np.eye(self.nNodes),omega3Dtilde)
+
+        #squared angul. vel. matrix:
+        omega3Dtilde2 = Skew(omega3D) @ Skew(omega3D)
+        omegaTilde2 = np.kron(np.eye(self.nNodes),omega3Dtilde2)
+
+        #these 2 terms are computationally costly:
+        rfTilde = ComputeSkewMatrix(rF) #rfTilde
+        cF_tTilde = ComputeSkewMatrix(cF_t) 
+
+        fTrans = A @ (omega3Dtilde @ self.PhitTM @ rfTilde @ omega3D + 2*self.PhitTM @ cF_tTilde @ omega3D)
+        force[0:self.dim3D] = fTrans
+
+        fRot = -G.T@(omega3Dtilde @ rfTilde.T @ self.massMatrixCSR @ rfTilde @ omega3D + 
+                        2*rfTilde.T @ self.massMatrixCSR @ cF_tTilde @ omega3D)
+        force[self.dim3D:self.nODE2rigid] = fRot
+    
+        fFlex = -self.massMatrixCSR @ (omegaTilde2 @ rF + 2*(omegaTilde @ cF_t))
+        force[self.nODE2rigid:] = fFlex
+
+        #add gravity:
+        # if False:
+        #     fGrav = np.array(fGravRigid + list(self.PhitTM.T @ (A.T @ self.gravity)) ) #only local vector, without rotation
+        #     force += fGrav
+
+        return force
+
+    #**classFunction: optional massMatrixUserFunction for ObjectFFRF (per default, this user function is ignored)
+    def UFmassGenericODE2(self, exu, mbs, t, q, q_t):
+        print("UFmassGenericODE2: not tested and not integrated into FFRFinterface!")
+        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
+        A = Avec.reshape((3,3))
+        ep = q[self.dim3D:self.nODE2rigid] + eulerParameters0 #add reference values, q are only the change w.r.t. reference values!
+        G = EulerParameters2GLocal(ep)
+
+        rF = self.xRef + q[self.nODE2rigid:] #nodal position
+        rfTilde = ComputeSkewMatrix(rF) #rfTilde
+        
+        Mnew = np.zeros((len(q), len(q)))
+
+        #Mtr:
+        Mtr = -A @ self.PhitTM @ rfTilde @ G
+        Mnew[0:self.dim3D, self.dim3D:self.dim3D+self.nODE2rot] = Mtr
+        Mnew[self.dim3D:self.dim3D+self.nODE2rot, 0:self.dim3D] = Mtr.T
+        #Mtf:
+        Mtf = A @ self.PhitTM
+        Mnew[0:self.dim3D, self.nODE2rigid:] = Mtf
+        Mnew[self.nODE2rigid:, 0:self.dim3D] = Mtf.T
+        #Mrf:
+        Mrf = -G.T @ rfTilde.T @ self.massMatrixCSR
+        Mnew[self.dim3D:self.dim3D+self.nODE2rot, self.nODE2rigid:] = Mrf
+        Mnew[self.nODE2rigid:, self.dim3D:self.dim3D+self.nODE2rot] = Mrf.T
+        #Mrr:
+        Mnew[self.dim3D:self.dim3D+self.nODE2rot, self.dim3D:self.dim3D+self.nODE2rot] = -Mrf @ rfTilde @ G   #G.T @ rfTilde.T @ massMatrix @ rfTilde @ G
+
+        return Mnew
+
+
+
+#**function: compute current (max, min, ...) value for chosen ObjectFFRFreducedOrder object (CMSobject) with exu.OutputVariableType. The function operates on nodal values. This is a helper function, which can be used to conveniently compute output quantities of the CMSobject efficiently and to use it in sensors
+#**input: 
+#  mbs: MainSystem of objectNumber
+#  objectNumber: number of ObjectFFRFreducedOrder in mbs
+#  outputVariableType: a exu.OutputVariableType out of [StressLocal, DisplacementLocal, VelocityLocal]
+#  norm: string containing chosen norm to be computed, out of 'Mises', 'maxNorm', 'min', 'max'; 'max' will return maximum of all components (component wise), 'min' does same but for minimum; 'maxNorm' computes np.linalg.norm for every node and then takes maximum of all norms; Mises computes von-Mises stress for every node and then takes maximum of all nodes
+#  nodeNumberList: list of mesh node numbers (from FEMinterface); if empty [], all nodes are used; otherwise, only given nodes are evaluated
+#**output: return value or list of values according to chosen norm as np.array
+def CMSObjectComputeNorm(mbs, objectNumber, outputVariableType, norm='max', nodeNumberList=[]):
+    import exudyn as exu
+    #get generic node number containing current coordinates:
+    nGeneric = mbs.GetObjectParameter(objectNumber,'nodeNumbers')[1]
+    #problem with rigid body coordinates:
+    #c = mbs.GetObjectOutputBody(objectNumber,variableType=exu.OutputVariableType.Coordinates,localPosition=[0,0,0])
+    #c_t = mbs.GetObjectOutputBody(objectNumber,variableType=exu.OutputVariableType.Coordinates_t,localPosition=[0,0,0])
+    
+    #see which outputvariable to compute:
+    if (mbs.GetObjectParameter(objectNumber,'outputVariableTypeModeBasis') == outputVariableType):
+        #get current coordinates:
+        c = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates)
+        X = mbs.GetObjectParameter(objectNumber,'outputVariableModeBasis')
+        values = np.zeros((X.shape[0], 6))
+        #compute stresses in nodes
+        #nc = len(c)
+        for i in range(len(c)):
+            for j in range(6): #6 stress components
+                values[:,j] += X[:,6*i+j] * c[i] #
+                
+    elif outputVariableType == exu.OutputVariableType.DisplacementLocal:
+        c = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates)
+        X = mbs.GetObjectParameter(objectNumber,'modeBasis')
+        nn = int(X.shape[0]/3)
+        values = (X@c).reshape((nn,3))
+    elif outputVariableType == exu.OutputVariableType.VelocityLocal:
+        c_t = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates_t)
+        X = mbs.GetObjectParameter(objectNumber,'modeBasis')
+        nn = int(X.shape[0]/3)
+        values = (X@c_t).reshape((nn,3))
+    #elif outputVariableType == exu.OutputVariableType.AccelerationLocal:
+    #    c_tt = mbs.GetNodeOutput(nGeneric,variableType=exu.OutputVariableType.Coordinates_tt)
+    #    X = mbs.GetObjectParameter(objectNumber,'modeBasis')
+    #    nn = int(X.shape[0]/3)
+    #    values = (X@c_tt).reshape((nn,3))
+    else:
+        raise ValueError("CMSObjectComputeNorm: illegal outputVariableType")
+
+    #restrict evaluation to given nodes
+    if nodeNumberList != []:
+        values = values[nodeNumberList]
+
+    if norm == 'max':
+        return np.max(values, axis=0)
+    elif norm == 'min':
+        return np.min(values, axis=0)
+    elif norm == 'maxNorm':
+        return np.max(np.linalg.norm(values,axis=1))
+    elif norm == 'Mises':
+        from exudyn.physics import VonMisesStress
+        if outputVariableType != exu.OutputVariableType.StressLocal:
+            raise ValueError("CMSObjectComputeMaximum: norm = 'Mises' only possible for outputVariableType == StressLocal")
+        return np.max(VonMisesStress(values))
+
+    raise ValueError("CMSObjectComputeMaximum: unknown norm")
+    return 0
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++++          ObjectFFRFreducedOrderTerms              ++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: compute terms necessary for ObjectFFRFreducedOrder
+#  class used internally in FEMinterface to compute ObjectFFRFreducedOrder dictionary
+#  this class holds all data for ObjectFFRFreducedOrder user functions
+class ObjectFFRFreducedOrderInterface:
+    #**classFunction: initialize ObjectFFRFreducedOrderInterface with FEMinterface class
+    #  initializes the ObjectFFRFreducedOrderInterface with nodes, modes, surface description and reduced system matrices from FEMinterface
+    #  data is then transfered to mbs object with classFunction AddObjectFFRFreducedOrderWithUserFunctions(...)
+    #**input: 
+    #  femInterface: must provide nodes, surfaceTriangles, modeBasis, massMatrix, stiffness; if femInterface=None, an empty ObjectFFRFreducedOrderInterface instance is created which may be used to load data with LoadFromFile()
+    #  roundMassMatrix: use this value to set entries of reduced mass matrix to zero which are below the treshold
+    #  roundStiffnessMatrix: use this value to set entries of reduced stiffness matrix to zero which are below the treshold
+    def __init__(self, femInterface=None, rigidBodyNodeType = 'NodeType.RotationEulerParameters',
+                 roundMassMatrix = 1e-13, roundStiffnessMatrix = 1e-13):
+ 
+        if femInterface!=None:
+            #self.femInterface = femInterface #2023-04-20: removed in order to consistenly store class
+            self.modeBasis = femInterface.modeBasis['matrix']
+            nodeArray = femInterface.GetNodePositionsAsArray()
+            self.trigList = femInterface.GetSurfaceTriangles()
+            self.postProcessingModes = femInterface.postProcessingModes
+    
+            stiffnessMatrixCSR = CSRtoScipySparseCSR(femInterface.GetStiffnessMatrix(sparse=True))
+            massMatrixCSR = CSRtoScipySparseCSR(femInterface.GetMassMatrix(sparse=True))
+    
+            #compute reduced mass and stiffness matrices, only flexible coordinates:
+            self.massMatrixReduced = self.modeBasis.T @ massMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
+            self.stiffnessMatrixReduced = self.modeBasis.T @ stiffnessMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
+            RoundMatrix(self.massMatrixReduced, roundMassMatrix*abs(self.massMatrixReduced).max()) #erase off-diagonal terms for higher efficiency ...
+            RoundMatrix(self.stiffnessMatrixReduced, roundStiffnessMatrix*abs(self.stiffnessMatrixReduced).max())
+    
+            #new coordinates:
+            #nODE2 = nNodes*3        #non reduced, full coordinates
+            #nODE2reduced = nModes
+            self.nModes = self.modeBasis.shape[1]                 #number of columns in self.modeBasis is the number of modes to consider
+            self.nNodes = len(nodeArray)                #stored in nNodes x 3 np-array
+            self.dim3D = len(nodeArray[0])              #dimension of position, assuming that one node exists ....
+            
+            self.rigidBodyNodeType = rigidBodyNodeType
+            if str(self.rigidBodyNodeType) == 'NodeType.RotationEulerParameters':
+                self.nODE2rot = 4                       #Euler parameters
+            else:
+                self.nODE2rot = 3
+            
+            self.nODE2rigid = self.dim3D + self.nODE2rot
+            self.nODE2FFRFreduced = self.nODE2rigid + self.nModes
+    
+            self.massMatrixFFRFreduced = np.zeros((self.nODE2FFRFreduced,self.nODE2FFRFreduced)) #create larger FFRF mass matrix
+    
+            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+            #FFRFreduced constant matrices:
+            Phit = np.kron(np.ones(self.nNodes),np.eye(3)).T
+            PhitTM = Phit.T @ massMatrixCSR #LARGE MATRIX COMPUTATION
+            self.xRef = nodeArray.flatten()          #node reference values in single vector (can be added then to q[7:])
+            xRefTilde = ComputeSkewMatrix(self.xRef) #rfTilde without q    
+            self.inertiaLocal = xRefTilde.T @ massMatrixCSR @ xRefTilde #LARGE MATRIX COMPUTATION
+    
+            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+            #prepare CMS matrices (some already given):
+            #according to: A. Zw\"olfer, J. Gerstmayr. The nodal-based floating frame of reference formulation with modal reduction, Acta Mechanica, 2020, submitted.
+            #\bar x = xRef
+            #\tilde \bar x = xRefTilde
+            #\bar Theta = inertiaLocal
+            #\bar mPsiPsi = massMatrixReduced
+            #Psi = self.modeBasis
+            self.Mtt = PhitTM @ Phit
+            self.totalMass = self.Mtt[0,0]                #Mtt must be diagonal matrix with mass in diagonal
+            self.PsiTilde = ComputeSkewMatrix(self.modeBasis)
+            self.chiU = 1./self.totalMass*(PhitTM @ self.xRef)                 #center of mass
+            self.chiUtilde = ComputeSkewMatrix(self.chiU)
+            self.mPsiTildePsi = self.PsiTilde.T @ massMatrixCSR @ self.modeBasis         #LARGE MATRIX COMPUTATION
+            self.mPsiTildePsiTilde = self.PsiTilde.T @ massMatrixCSR @ self.PsiTilde#LARGE MATRIX COMPUTATION
+            self.mPhitTPsi = Phit.T @ massMatrixCSR @ self.modeBasis                #LARGE MATRIX COMPUTATION
+            self.mPhitTPsiTilde = Phit.T @ massMatrixCSR @ self.PsiTilde       #LARGE MATRIX COMPUTATION
+            self.mXRefTildePsi = xRefTilde.T @ massMatrixCSR @ self.modeBasis       #LARGE MATRIX COMPUTATION
+            self.mXRefTildePsiTilde = xRefTilde.T @ massMatrixCSR @ self.PsiTilde    #LARGE MATRIX COMPUTATION
+    
+            #fill already parts of the mass matrix in order to avoid copying this constant data during user function calls:
+            self.massMatrixFFRFreduced[0:3,0:3] = self.Mtt
+            #FillInSubMatrix(self.massMatrixReduced, self.massMatrixFFRFreduced, self.nODE2rigid, self.nODE2rigid)
+            self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:] = self.massMatrixReduced
+
+    #**classFunction: save all data to a data filename; can be used to avoid loading femInterface and FE data
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #  fileVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; version must by > 0; the default value will change in future!
+    #**output: stores file
+    def SaveToFile(self, fileName, fileVersion = 1 ):
+        fileExtension = ''
+        if len(fileName) < 4 or fileName[-4:]!='.npy':
+            fileExtension = '.npy'
+
+        try:
+            os.makedirs(os.path.dirname(fileName+fileExtension), exist_ok=True)
+        except:
+            pass #makedirs may fail on some systems, but we keep going
+
+        with open(fileName+fileExtension, 'wb') as f:
+            np.save(f, np.array([int(fileVersion)])) #array allows to add more data in future
+
+            np.save(f, self.modeBasis)
+            np.save(f, self.trigList, allow_pickle=True)
+            np.save(f, self.postProcessingModes, allow_pickle=True)
+            np.save(f, self.massMatrixReduced)
+            np.save(f, self.stiffnessMatrixReduced)
+            
+            infoList = np.array([self.nModes, self.nNodes, self.dim3D, self.nODE2rot, self.nODE2rigid, self.nODE2FFRFreduced])
+            np.save(f, infoList)
+            np.save(f, str(self.rigidBodyNodeType), allow_pickle=True)
+
+            np.save(f, self.xRef)
+
+            np.save(f, self.inertiaLocal)
+            np.save(f, self.Mtt)
+            np.save(f, self.totalMass)
+            np.save(f, self.chiU)
+            np.save(f, self.chiUtilde)
+            np.save(f, self.mPsiTildePsi)
+            np.save(f, self.mPsiTildePsiTilde)
+            np.save(f, self.mPhitTPsi)
+            np.save(f, self.mPhitTPsiTilde)
+            np.save(f, self.mXRefTildePsi)
+            np.save(f, self.mXRefTildePsiTilde)
+    
+            #np.save(f, self.PsiTilde) #large (3 x modeBasis)!, not needed
+            #np.save(f, self.Phit)
+            #np.save(f, self.PhitTM)
+            #np.save(f, self.xRefTilde)
+            #np.save(f, self.massMatrixFFRFreduced) #created when loaded; only needed for user functions
+
+    #**classFunction: load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...). 
+    #this function is much faster than the text-based import functions
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #**output: loads data into fem (note that existing values are not overwritten!)
+    def LoadFromFile(self, fileName):
+        fileExtension = ''
+        fileVersion = None
+        if len(fileName) < 4 or fileName[-4:]!='.npy':
+            fileExtension = '.npy'
+        with open(fileName+fileExtension, 'rb') as f:
+            fileVersion = int(np.load(f)[0])
+            self.modeBasis = np.load(f)
+            self.trigList = np.load(f, allow_pickle=True).tolist()
+            self.postProcessingModes = np.load(f, allow_pickle=True)
+            self.massMatrixReduced = np.load(f)
+            self.stiffnessMatrixReduced = np.load(f)
+
+            infoList = list(np.load(f))
+            #print('list=',infoList)
+            [self.nModes, self.nNodes, self.dim3D, self.nODE2rot, self.nODE2rigid, self.nODE2FFRFreduced] = infoList
+
+            self.rigidBodyNodeType = StrNodeType2NodeType(np.load(f, allow_pickle=True))
+
+            #this term is large, but currently needed for markers / constraints!
+            self.xRef = np.load(f)
+
+            #reduced inertia terms
+            self.inertiaLocal = np.load(f)
+            self.Mtt = np.load(f)
+            self.totalMass = np.load(f)
+            self.chiU = np.load(f)
+            self.chiUtilde = np.load(f)
+            self.mPsiTildePsi = np.load(f)
+            self.mPsiTildePsiTilde = np.load(f)
+            self.mPhitTPsi = np.load(f)
+            self.mPhitTPsiTilde = np.load(f)
+            self.mXRefTildePsi = np.load(f)
+            self.mXRefTildePsiTilde = np.load(f)
+            
+            # if fileVersion>1:
+            #     #do things here for higher versions in future
+
+        self.massMatrixFFRFreduced = np.zeros((self.nODE2FFRFreduced,self.nODE2FFRFreduced)) #create larger FFRF mass matrix
+        #fill already parts of the mass matrix in order to avoid copying this constant data during user function calls:
+        self.massMatrixFFRFreduced[0:3,0:3] = self.Mtt
+        #FillInSubMatrix(self.massMatrixReduced, self.massMatrixFFRFreduced, self.nODE2rigid, self.nODE2rigid)
+        self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:] = self.massMatrixReduced
+                
+        return fileVersion
+        
+    ##  UFforce: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFforceFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced\_t):\\ \phantom{XXXX}return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
+
+    #**classFunction: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs; use this function with userfunctions=0 in order to use internal C++ functionality, which is approx. 10x faster; implementation of userfunctions also available for rotation vector (Lie group formulation), which needs further testing
+    #**input:
+    #  exu: the exudyn module
+    #  mbs: a MainSystem object
+    #  positionRef: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  initialVelocity: initial velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  rotationMatrixRef: reference rotation of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder); if [], it becomes the unit matrix
+    #  initialAngularVelocity: initial angular velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  eulerParametersRef: DEPRECATED, use rotationParametersRef or rotationMatrixRef in future: reference euler parameters of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  gravity: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
+    #  UFforce: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; see example
+    #  UFmassMatrix: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; see example
+    #  massProportionalDamping: Rayleigh damping factor for mass proportional damping (multiplied with reduced mass matrix), added to floating frame/modal coordinates only
+    #  stiffnessProportionalDamping: Rayleigh damping factor for stiffness proportional damping, added to floating frame/modal coordinates only (multiplied with reduced stiffness matrix)
+    #  color: provided as list of 4 RGBA values
+    #**example:
+    # #example of a user function for forces:
+    # def UFforceFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced_t):
+    #     return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced_t)
+    # #example of a user function for mass matrix:
+    # def UFmassFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced\_t):
+    #     return cms.UFmassFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)
+    def AddObjectFFRFreducedOrderWithUserFunctions(self, exu, mbs, 
+                                                  positionRef=[0,0,0], 
+                                                  initialVelocity=[0,0,0], 
+                                                  rotationMatrixRef=[], 
+                                                  initialAngularVelocity=[0,0,0],
+                                                  gravity=[0,0,0],
+                                                  UFforce=0, UFmassMatrix=0,
+                                                  massProportionalDamping = 0, stiffnessProportionalDamping = 0,
+                                                  color=[0.1,0.9,0.1,1.],
+                                                  eulerParametersRef=[]):
+
+        #check chosen rotation parameterization:
+        if len(rotationMatrixRef) == 0 and len(eulerParametersRef) == 0:
+            rotationMatrixRef=np.diag([1,1,1])
+        elif len(rotationMatrixRef) != 0 and len(eulerParametersRef) != 0:
+            raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions: rotationMatrixRef or eulerParametersRef must be zero')
+        
+        if len(eulerParametersRef) != 0:
+            if str(self.rigidBodyNodeType) != 'NodeType.RotationEulerParameters':
+                raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions: inconsistent reference rotation parameters and rigidBodyNodeType')
+            #compute initial euler parameter velocities from angular velocity vector
+            self.rotationParameters_t0 = AngularVelocity2EulerParameters_t(initialAngularVelocity, eulerParametersRef)
+            self.rotationParameters0 = eulerParametersRef
+    
+            #rigid body node for ObjectFFRFreducedOrder
+            self.nRigidBody = mbs.AddNode(eii.NodeRigidBodyEP(referenceCoordinates=list(positionRef)+list(eulerParametersRef), 
+                                                initialVelocities=list(initialVelocity)+list(self.rotationParameters_t0)))
+            self.rigidBodyNodeType = exu.NodeType.RotationEulerParameters
+        else:
+            #compute initial rotation parameter velocities from angular velocity vector
+            nodeItem = GetRigidBodyNode(nodeType=self.rigidBodyNodeType, position=positionRef, 
+                                        velocity=initialVelocity, rotationMatrix=rotationMatrixRef, 
+                                        angularVelocity=initialAngularVelocity)
+            self.nRigidBody = mbs.AddNode(nodeItem)
+                        
+            self.rotationParameters0 = nodeItem.referenceCoordinates[3:]
+            self.rotationParameters_t0 = nodeItem.initialVelocities[3:]
+
+        #print("self.rotationParameters0 =",self.rotationParameters0 )
+        #print("self.rotationParameters_t0 =",self.rotationParameters_t0 )
+
+        self.gravity = gravity
+        self.loadGravity = None #only defined if LoadMassProportional is added
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #check if postProcessingModes exist
+        outputVariableModeBasis = []
+        outputVariableTypeModeBasis = 0
+        #FEM: self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
+
+        if 'matrix' in self.postProcessingModes:
+            #check FEMinterface if modes exist:
+            if str(self.postProcessingModes['outputVariableType']) == 'OutputVariableType.StressLocal':
+                outputVariableTypeModeBasis = exu.OutputVariableType.StressLocal
+            elif str(self.postProcessingModes['outputVariableType']) == 'OutputVariableType.StrainLocal':
+                outputVariableTypeModeBasis = exu.OutputVariableType.StrainLocal
+            else:
+                raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions(...): invalid outputVariableType in postProcessingModes')
+
+            outputVariableModeBasis  = self.postProcessingModes['matrix']
+            
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #generic node for modal coordinates in ObjectFFRFreducedOrder
+        self.nGenericODE2 = mbs.AddNode(eii.NodeGenericODE2(numberOfODE2Coordinates=self.nModes,
+                                          referenceCoordinates=[0]*self.nModes,
+                                          initialCoordinates=[0]*self.nModes,
+                                          initialCoordinates_t=[0]*self.nModes))
+
+        stiffnessMatrixMC = exu.MatrixContainer()
+        stiffnessMatrixMC.SetWithDenseMatrix(self.stiffnessMatrixReduced,useDenseMatrix=False)
+
+        self.dampingMatrixReduced = massProportionalDamping*self.massMatrixReduced+stiffnessProportionalDamping*self.stiffnessMatrixReduced
+        if (massProportionalDamping != 0 or stiffnessProportionalDamping != 0):
+            dampingMatrixMC = exu.MatrixContainer()
+            dampingMatrixMC.SetWithDenseMatrix(self.dampingMatrixReduced, useDenseMatrix=False)
+        else:
+            dampingMatrixMC=[]
+
+        massMatrixMC = exu.MatrixContainer()
+        
+        #not needed, as not included in C++ computation until full CMS functionality
+        #factMass = 1.
+        #if UFmassMatrix != 0:
+        #    factMass = 0.
+        #massMatrixMC.SetWithDenseMatrix(factMass*self.massMatrixReduced,useDenseMatrix=False)
+        
+        massMatrixMC.SetWithDenseMatrix(self.massMatrixReduced,useDenseMatrix=False)
+        #emptyMC = exu.MatrixContainer()
+
+        #add generic body for FFRF-Object:
+        if UFmassMatrix == 0 or UFforce == 0:
+            
+            self.oFFRFreducedOrder = mbs.AddObject(eii.ObjectFFRFreducedOrder(nodeNumbers = [self.nRigidBody, self.nGenericODE2], 
+                                                                stiffnessMatrixReduced=stiffnessMatrixMC, 
+                                                                massMatrixReduced=massMatrixMC,
+                                                                dampingMatrixReduced=dampingMatrixMC,
+                                                                modeBasis=self.modeBasis,
+                                                                referencePositions = self.xRef,
+                                                                physicsMass=self.totalMass,
+                                                                physicsInertia=self.inertiaLocal,
+                                                                physicsCenterOfMass=self.chiU,
+                                                                mPsiTildePsi = self.mPsiTildePsi,
+                                                                mPsiTildePsiTilde = self.mPsiTildePsiTilde,
+                                                                mPhitTPsi = self.mPhitTPsi,
+                                                                mPhitTPsiTilde = self.mPhitTPsiTilde,
+                                                                mXRefTildePsi = self.mXRefTildePsi,
+                                                                mXRefTildePsiTilde = self.mXRefTildePsiTilde,
+                                                                outputVariableModeBasis = outputVariableModeBasis,
+                                                                outputVariableTypeModeBasis = outputVariableTypeModeBasis,
+                                                                #
+                                                                forceUserFunction=UFforce,
+                                                                massMatrixUserFunction=UFmassMatrix,
+                                                                computeFFRFterms=True, #only compute user function, no internal components ...
+                                                                visualization=eii.VObjectFFRF(triangleMesh = self.trigList, 
+                                                                                            color=color,
+                                                                                            showNodes = True)))
+
+            if np.array(gravity) @ np.array(gravity) != 0.:
+                mBody = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=self.oFFRFreducedOrder))
+                self.loadGravity = mbs.AddLoad(eii.LoadMassProportional(markerNumber=mBody, loadVector= gravity))
+
+        else:
+            self.oFFRFreducedOrder = mbs.AddObject(eii.ObjectFFRFreducedOrder(nodeNumbers = [self.nRigidBody, self.nGenericODE2], 
+                                                                stiffnessMatrixReduced=stiffnessMatrixMC, 
+                                                                massMatrixReduced=massMatrixMC,
+                                                                dampingMatrixReduced=dampingMatrixMC,
+                                                                modeBasis=self.modeBasis,
+                                                                referencePositions = self.xRef,
+                                                                forceUserFunction=UFforce,
+                                                                massMatrixUserFunction=UFmassMatrix,
+                                                                computeFFRFterms=False, #only compaute user function, no internal components ...
+                                                                visualization=eii.VObjectFFRF(triangleMesh = self.trigList, 
+                                                                                            color=color,
+                                                                                            showNodes = True)))
+
+        dictReturn = {'nRigidBody':self.nRigidBody,
+                      'nGenericODE2':self.nGenericODE2,
+                      'oFFRFreducedOrder':self.oFFRFreducedOrder,
+                      'loadGravity':self.loadGravity}
+
+        #not needed any more; Euler parameter constraint included now in ObjectFFRFreducedOrder
+        #if self.nODE2rot == 4: #for euler parameters --> add body to constrain EP
+        #    epsMass = 1e-3#needed, if not all ffrf terms are included
+        #    #add rigid body to node for Euler Parameter constraint:
+        #    oAddedBody = mbs.AddObject(ObjectRigidBody(nodeNumber=self.nRigidBody, physicsMass=epsMass, 
+        #                                               physicsInertia=[epsMass,epsMass,epsMass,0,0,0])) 
+        #    dictReturn['oAddedBody'] = oAddedBody
+
+        return dictReturn
+
+
+
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: CMS mass matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!
+    def UFmassFFRFreducedOrder(self, exu, mbs, t, qReduced, qReduced_t):
+
+        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
+        A = Avec.reshape((3,3))
+        #compute rotation parameters including reference values:
+        rp = np.array(qReduced[self.dim3D:self.nODE2rigid]) + np.array(self.rotationParameters0) #add reference values, q are only the change w.r.t. reference values!
+        if self.rigidBodyNodeType == exu.NodeType.RotationEulerParameters:
+            G = EulerParameters2GLocal(rp)
+        elif self.rigidBodyNodeType == exu.NodeType.RotationRotationVector:
+            G = RotationVector2GLocal(rp)
+        elif self.rigidBodyNodeType ==exu.NodeType.RotationRxyz:
+            G = RotXYZ2GLocal(rp)
+        else:
+            raise ValueError('UFmassFFRFreducedOrder: rotation parameterization not implemented')
+        
+
+        zetaI = VectorDiadicUnitMatrix3D(qReduced[self.nODE2rigid:])
+        #zeta_tI = VectorDiadicUnitMatrix3D(qReduced_t[self.nODE2rigid:]) #not needed
+
+        #print("Mtt=",self.massMatrixFFRFreduced[0:3,0:3])
+        #print("Mff=",self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:])
+        #Mtt and Mff already filled into massMatrixFFRFreduced
+        #Mtr:
+        Mtr = -A @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ G
+        self.massMatrixFFRFreduced[0:self.dim3D, self.dim3D:self.dim3D+self.nODE2rot] = Mtr
+        self.massMatrixFFRFreduced[self.dim3D:self.dim3D+self.nODE2rot, 0:self.dim3D] = Mtr.T
+
+        #Mtf:
+        Mtf = A @ self.mPhitTPsi
+        self.massMatrixFFRFreduced[0:self.dim3D, self.nODE2rigid:] = Mtf 
+        self.massMatrixFFRFreduced[self.nODE2rigid:, 0:self.dim3D] = Mtf.T
+
+        #Mrf:
+        Mrf = -G.T @ (self.mXRefTildePsi + zetaI.T @ self.mPsiTildePsi)
+        self.massMatrixFFRFreduced[self.dim3D:self.nODE2rigid, self.nODE2rigid:] = Mrf
+        self.massMatrixFFRFreduced[self.nODE2rigid:, self.dim3D:self.nODE2rigid] = Mrf.T
+
+        #Mrr:
+        self.massMatrixFFRFreduced[self.dim3D:self.nODE2rigid, self.dim3D:self.nODE2rigid] = G.T@(self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + 
+                                                                            zetaI.T @ self.mXRefTildePsiTilde.T + 
+                                                                            zetaI.T @ self.mPsiTildePsiTilde @ zetaI)@G
+
+        #print("Mtr=",Mtr)
+        #print("Mtf=",Mtf)
+        #print("Mrf=",Mrf)
+        #print("Mrr=",self.massMatrixFFRFreduced[self.dim3D:self.nODE2rigid, self.dim3D:self.nODE2rigid])
+
+        return self.massMatrixFFRFreduced
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: CMS force matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!
+    def UFforceFFRFreducedOrder(self, exu, mbs, t, qReduced, qReduced_t):
+        force = np.zeros(self.nODE2FFRFreduced)
+
+        Avec = mbs.GetNodeOutput(self.nRigidBody,  exu.OutputVariableType.RotationMatrix)
+        A = Avec.reshape((3,3))
+
+        #compute rotation parameters including reference values:
+        rp = np.array(qReduced[self.dim3D:self.nODE2rigid]) + np.array(self.rotationParameters0) #add reference values, q are only the change w.r.t. reference values!
+        # if len(ep) != 4: 
+        #     print("ERROR: equations only implemented for Euler parameters case (terms missing for other formulations)"); exit()
+
+        if self.rigidBodyNodeType == exu.NodeType.RotationEulerParameters:
+            G = EulerParameters2GLocal(rp)
+        elif self.rigidBodyNodeType == exu.NodeType.RotationRotationVector:
+            G = RotationVector2GLocal(rp)
+        elif self.rigidBodyNodeType ==exu.NodeType.RotationRxyz:
+            G = RotXYZ2GLocal(rp)
+            #time derivatives:
+            rp_t = np.array(qReduced_t[self.dim3D:self.nODE2rigid])
+            G_t = RotXYZ2GLocal_t(rp, rp_t)
+            G_tRp_t = G_t @ rp_t
+        else:
+            raise ValueError('UFforceFFRFreducedOrder: rotation parameterization not implemented')
+
+        zetaI = VectorDiadicUnitMatrix3D(qReduced[self.nODE2rigid:])
+        zeta_tI = VectorDiadicUnitMatrix3D(qReduced_t[self.nODE2rigid:])
+
+        omega3D = G @ np.array(qReduced_t[self.dim3D:self.nODE2rigid])
+        omega3Dtilde = Skew(omega3D)
+        IZetadiadicOmega = np.kron(np.eye(self.nModes), np.array(omega3D)).T
+
+        qReducedFF = np.array(qReduced[self.nODE2rigid:])
+        qReduced_tFF = np.array(qReduced_t[self.nODE2rigid:])
+
+        #CMS:
+        force[0:self.dim3D] = (A @ omega3Dtilde @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ omega3D + 
+                               2*A @ self.mPhitTPsiTilde @ zeta_tI @ omega3D) #identical to FFRF up to 1e-16
+    
+        force[self.dim3D:self.nODE2rigid] = (-G.T @ omega3Dtilde @ (self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + 
+                                                                    zetaI.T @ self.mXRefTildePsiTilde.T + 
+                                                                    zetaI.T @ self.mPsiTildePsiTilde @ zetaI ) @ omega3D - 
+                                   2*G.T @ (self.mXRefTildePsiTilde @ zeta_tI + zetaI.T @ self.mPsiTildePsiTilde @ zeta_tI ) @ omega3D)  #identical to FFRF up to 1e-16
+        
+        force[self.nODE2rigid:] = (IZetadiadicOmega.T @ (self.mXRefTildePsiTilde.T + self.mPsiTildePsiTilde @ zetaI) @ omega3D + 
+                                   2 * self.mPsiTildePsi.T @ zeta_tI @ omega3D #identical to FFRF up to 1e-16
+                                   - self.stiffnessMatrixReduced @ qReducedFF  #stiffness term added to user function, for better distinguishing with internal FFRF
+                                   - self.dampingMatrixReduced @ qReduced_tFF) #damping term added to user function, for better distinguishing with internal FFRF
+
+        #print("fQV=", force)
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #additional terms for Euler angles:
+        if self.rigidBodyNodeType == exu.NodeType.RotationRxyz:
+            force[0:self.dim3D] += A @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ G_tRp_t
+            
+            force[self.dim3D:self.nODE2rigid] += -G.T @ (self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + 
+                                                         zetaI.T @ self.mXRefTildePsiTilde.T + 
+                                                         zetaI.T @ self.mPsiTildePsiTilde @ zetaI ) @ G_tRp_t
+            
+            force[self.nODE2rigid:] += (self.mXRefTildePsi.T + self.mPsiTildePsi.T @ zetaI) @ G_tRp_t
+
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #add gravity (needs to be tested):
+        if True:
+            force[0:self.dim3D] += self.totalMass*np.array(self.gravity)
+            force[self.dim3D:self.nODE2rigid] += G.T @ (Skew(self.chiU) @ (self.totalMass*A.T @ np.array(self.gravity)))
+            force[self.nODE2rigid:] += self.mPhitTPsi.T @ (A.T @ np.array(self.gravity))
+
+            #force[nODE2rigid:] += modeBasis.T @ PhitTM.T @ (A.T @ g)
+
+        return force
+
+    #**classFunction: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs; use this function in order to use internal C++ functionality, which is approx. 10x faster than AddObjectFFRFreducedOrderWithUserFunctions(...)
+    #**input:
+    #  exu: the exudyn module
+    #  mbs: a MainSystem object
+    #  positionRef: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  initialVelocity: initial velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  rotationMatrixRef: reference rotation of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder); if [], it becomes the unit matrix
+    #  initialAngularVelocity: initial angular velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
+    #  massProportionalDamping: Rayleigh damping factor for mass proportional damping, added to floating frame/modal coordinates only
+    #  stiffnessProportionalDamping: Rayleigh damping factor for stiffness proportional damping, added to floating frame/modal coordinates only
+    #  gravity: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
+    #  color: provided as list of 4 RGBA values
+    def AddObjectFFRFreducedOrder(self, mbs, 
+                                  positionRef=[0,0,0], initialVelocity=[0,0,0], 
+                                  rotationMatrixRef=[], initialAngularVelocity=[0,0,0],
+                                  massProportionalDamping = 0, stiffnessProportionalDamping = 0,
+                                  gravity = [0,0,0],
+                                  color=[0.1,0.9,0.1,1.]):
+        import exudyn as exu
+        return self.AddObjectFFRFreducedOrderWithUserFunctions(exu=exu, mbs=mbs, 
+                                                  positionRef=positionRef, initialVelocity=initialVelocity, rotationMatrixRef=rotationMatrixRef, 
+                                                  initialAngularVelocity=initialAngularVelocity,
+                                                  massProportionalDamping = massProportionalDamping, stiffnessProportionalDamping = stiffnessProportionalDamping,
+                                                  gravity = gravity, color=color)
+    
+        
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: helper calss for function ComputeHurtyCraigBamptonModes, declaring some computation options. It offers the following options:\\
+# - allBoundaryNodes:     compute a single static mode for every boundary coordinate\\
+# - RBE2:                 static modes only for rigid body motion at boundary nodes; using rigid boundary surfaces (additional stiffening)\\
+# - RBE3:                 static modes only for rigid body motion at boundary nodes; averaged rigid body motion at boundary surfaces (leads to deformation at boundaries)\\
+# - noStaticModes:        do not compute static modes, only eigen modes (not recommended; usually only for tests)
+class HCBstaticModeSelection(Enum):
+    allBoundaryNodes = 1    #compute a single static mode for every boundary coordinate; if this is used, 6 constraints need to be added to the ObjectFFRFreducedOrder, otherwise there is additional rigid body motion!
+    RBE2 = 2                #static modes which include (exact / constrained) rigid body motion (3x translation, 3x rotation) at boundary / interface; recommended as basic / simpler method, however, leads to additional stiffening and stress concentration at boundary
+    RBE3 = 3                #static modes which include averaged rigid body motion (3x translation, 3x rotation) at boundary / interface; recommended as advanced method; may lead to overly large deformation at boundary
+    noStaticModes = 4       #do not compute static modes, only eigen modes (not really recommended; usually only for tests)
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++++   FEMinterface - finite element interface class   ++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: general interface to different FEM / mesh imports and export to EXUDYN functions
+#         use this class to import meshes from different meshing or FEM programs (NETGEN/NGsolve \cite{NGsolve2022}, ABAQUS, ANSYS, ..) and store it in a unique format
+#         do mesh operations, compute eigenmodes and reduced basis, etc.
+#         load/store the data efficiently with LoadFromFile(...), SaveToFile(...)  if import functions are slow
+#         export to EXUDYN objects
+class FEMinterface:
+    #**classFunction: initalize all data of the FEMinterface by, e.g., \texttt{fem = FEMinterface()}
+    #**example:
+    # #**** this is not an example, just a description for internal variables ****
+    # #default values for member variables stored internally in FEMinterface fem and typical structure:
+    # fem.nodes = {}                 # {'Position':[[x0,y0,z0],...], 'RigidBodyRxyz':[[x0,y0,z0],...],  },...]                     #dictionary of different node lists
+    # fem.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
+    # fem.massMatrix = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+    # fem.stiffnessMatrix=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+    # fem.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
+    # fem.nodeSets = []              # [{'Name':'identifier', 'NodeNumbers':[n_0,...,n_ns], 'NodeWeights':[w_0,...,w_ns]},...]     #for boundary conditions, etc.
+    # fem.elementSets = []           # [{'Name':'identifier', 'ElementNumbers':[n_0,...,n_ns]},...]                                #for different volumes, etc.
+    # fem.modeBasis = {}             # {'matrix':[[Psi_00,Psi_01, ..., Psi_0m],...,[Psi_n0,Psi_n1, ..., Psi_nm]],'type':'NormalModes'} #'NormalModes' are eigenmodes, 'HCBmodes' are Craig-Bampton modes including static modes
+    # fem.eigenValues = []           # [ev0, ev1, ...]                                                                             #eigenvalues according to eigenvectors in mode basis
+    # fem.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
+    def __init__(self):
+        self.nodes = {}                 # {'Position':[[x0,y0,z0],...], 'RigidBodyRxyz':[[x0,y0,z0],...],  },...]                     #dictionary of different node lists
+        self.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
+        self.massMatrix = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+        self.stiffnessMatrix=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+        # self.massMatrixReduced = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+        # self.stiffnessMatrixReduced=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+        self.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
+        self.nodeSets = []              # [{'Name':'identifier', 'NodeNumbers':[n_0,...,n_ns], 'NodeWeights':[w_0,...,w_ns]},...]     #for boundary conditions, etc.
+        self.elementSets = []           # [{'Name':'identifier', 'ElementNumbers':[n_0,...,n_ns]},...]                                #for different volumes, etc.
+
+        self.modeBasis = {}             # {'matrix':[[Psi_00,Psi_01, ..., Psi_0m],...,[Psi_n0,Psi_n1, ..., Psi_nm]],'type':'NormalModes'}
+        self.eigenValues = []           # [ev0, ev1, ...]                                                                             #eigenvalues according to eigenvectors in mode basis
+        self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
+        #self.massMatrix = {}           # {'Shape':[rows,columns], 'SparseCSR':[[r0,c0,value0],[r1,c1,value1], ... ],  }             #currently only in SparseCSR format allowed!
+
+        #some additional information, needed for checks and easier operation
+        self.coordinatesPerNodeType = {'Position':3, 'Position2D':2, 'RigidBodyRxyz':6, 'RigidBodyEP':7} #number of coordinates for a certain node type
+
+
+    #**classFunction: save all data (nodes, elements, ...) to a data filename; this function is much faster than the text-based import functions
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #  fileVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; version must by > 0
+    #**output: stores file
+    def SaveToFile(self, fileName, fileVersion = 13 ):
+        fileExtension = ''
+        if len(fileName) < 4 or fileName[-4:]!='.npy':
+            fileExtension = '.npy'
+                    
+        try:
+            os.makedirs(os.path.dirname(fileName+fileExtension), exist_ok=True)
+        except:
+            pass #makedirs may fail on some systems, but we keep going
+
+        with open(fileName+fileExtension, 'wb') as f:
+            if fileVersion>0:
+                dataVersion = np.array([int(fileVersion)])
+                np.save(f, dataVersion)
+
+            np.save(f, self.nodes, allow_pickle=True) #allow_pickle=True for lists or dictionaries
+            np.save(f, self.elements, allow_pickle=True)
+            np.save(f, self.massMatrix)
+            np.save(f, self.stiffnessMatrix)
+            np.save(f, self.surface, allow_pickle=True)
+            np.save(f, self.nodeSets, allow_pickle=True)
+            np.save(f, self.elementSets, allow_pickle=True)
+            np.save(f, self.modeBasis, allow_pickle=True)
+            np.save(f, self.eigenValues, allow_pickle=True)
+            np.save(f, self.postProcessingModes, allow_pickle=True)
+            #not needed
+            # if fileVersion>0:
+            #     np.save(f, self.massMatrixReduced)
+            #     np.save(f, self.stiffnessMatrixReduced)
+
+    #**classFunction: load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...). 
+    #this function is much faster than the text-based import functions
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #  forceVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; for old files, use forceVersion=0
+    #**output: loads data into fem (note that existing values are not overwritten!); returns file version or None if version is not available
+    def LoadFromFile(self, fileName, forceVersion=None):
+        fileExtension = ''
+        fileVersion = None
+        if len(fileName) < 4 or fileName[-4:]!='.npy':
+            fileExtension = '.npy'
+            
+        try:
+            with open(fileName+fileExtension, 'rb') as f:
+                if forceVersion==None or forceVersion>0:
+                    versionData = np.load(f)
+                    #print('LoadFromFile:file version:', versionData)
+                    if forceVersion != None:
+                        fileVersion = int(versionData[0])
+                else:
+                    fileVersion=forceVersion
+                    
+                self.nodes = np.load(f, allow_pickle=True).all()   #allow_pickle=True for lists or dictionaries; .all() for dictionaries
+                self.elements = list(np.load(f, allow_pickle=True))#list(...) to convert into list again!
+                self.massMatrix = np.load(f)
+                self.stiffnessMatrix = np.load(f)
+                self.surface = list(np.load(f, allow_pickle=True))
+                self.nodeSets =  list(np.load(f, allow_pickle=True))
+                self.elementSets = list(np.load(f, allow_pickle=True))
+                self.modeBasis = np.load(f, allow_pickle=True).all()
+                self.eigenValues = list(np.load(f, allow_pickle=True))
+                self.postProcessingModes = np.load(f, allow_pickle=True).all()
+                # if fileVersion>0:
+                #     self.massMatrixReduced = np.load(f)
+                #     self.stiffnessMatrixReduced = np.load(f)
+        except Exception as e:
+            print('\n\nFEMinterface.LoadFromFile(...) failed; check filename; if your data file is using old format, try with: LoadFromFile(self, fileName=..., forceVersion=0)\n')
+            raise
+        return fileVersion
+
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #ABAQUS import functions
+
+    #**classFunction: import nodes and elements from Abaqus input file and create surface elements; 
+    #                 node numbers in elements are converted from 1-based indices to python's 0-based indices;
+    #                 This function can only import one part or instance; this means that you have to merge all 
+    #                 instances or parts in order to use this function for import of flexible bodies for order reduction methods
+    #**input:
+    #  fileName: file name incl. path
+    #  typeName: this is what is searched for regarding nodes and elements, see your .inp file
+    #  name: if there are several parts, this name should address the according part name
+    #  verbose: use True for some debug information
+    #  createSurfaceTrigs: if True, triangles are created for visualization (triangles both for Tet and Hex elements)
+    #  surfaceTrigsAll: if False, visualization triangles are created at the surface; if True, surface triangles are created also for interior elements
+    #**notes: only works for Hex8, Hex20, Tet4 and Tet10 (C3D4, C3D8, C3D8R, C3D10, C3D20, C3D20R) elements; some functionality is untested and works in limited cases; only works for one single part or instance
+    #**output: return node numbers as numpy array
+    def ImportFromAbaqusInputFile(self, fileName, typeName='Part', name='Part-1', verbose=False,
+                                  createSurfaceTrigs=True, surfaceTrigsAll=False):
+        #def ImportABAQUS(fileName, typeName, name, verbose = False):
+        fileLines = []
+        if verbose: print("ImportFromAbaqusInputFile: read file name=", fileName)
+        file=open(fileName,'r') 
+        fileLines = file.readlines()
+        file.close()
+        
+        if verbose: print("read", len(fileLines), "lines")
+    
+        lineCnt = 0          #current counter for lines, makes life simpler
+        nLines = len(fileLines)
+        typeNameFound = False
+        elementsDict = {'Name':'elements'} #this is the destination for elements
+        #+++++++++++++++++++++++++++++++++++++++++++++
+        #find *Instance or *Part
+        strTypeName = '*'+typeName
+    
+        while lineCnt < nLines and not typeNameFound:
+            line = fileLines[lineCnt]
+            if line[0:len(strTypeName)] == strTypeName:
+                typeNameFound = True
+                if verbose: print("found ", strTypeName, "in line", lineCnt)
+                
+            lineCnt += 1
+    
+        if not typeNameFound: raise ValueError("ImportFromAbaqusInputFile: did not find keyword '"+strTypeName+"'")
+    
+        #+++++++++++++++++++++++++++++++++++++++++++++
+        #read *Node keyword
+        if fileLines[lineCnt][0:5] == '*Node':
+            lineCnt += 1
+        else:
+            raise ValueError("ImportFromAbaqusInputFile: expected *Node in line"+str(lineCnt+1)+', but received: '+fileLines[lineCnt])
+        
+        #+++++++++++++++++++++++++++++++++++++++++++++
+        #read nodes:
+        nodeReadFinished = False
+        nodes=[]
+        while lineCnt < nLines and not nodeReadFinished:
+            line = fileLines[lineCnt]
+        
+            if line[0] != '*': #check if nodes section has finished
+                lineData = line.split(',') #split into values
+                if len(lineData) != 4:
+                    raise ValueError("ImportFromAbaqusInputFile: Expected node number and 3 coordinates, line "+str(lineCnt))
+                else:
+                    v = []
+                    for i in range(3):
+                        v+=[float(lineData[i+1])] 
+                    nodes += [v] #add node data
+                    #if verbose: print("node=",v)
+                lineCnt += 1#do not increase counter if * found
+            else:
+                nodeReadFinished = True
+
+        if verbose: print("imported ", len(nodes), "nodes")
+    
+        #+++++++++++++++++++++++++++++++++++++++++++++
+        #read *Element keyword
+        #expect something like: *Element, type= C3D20 
+        availableElementTypesNodes={'C3D20':20, 'C3D20R':20, 'C3D8':8, 'C3D8R':8, #Hex
+                                    'C3D4':4, 'C3D10':10, #Tet standard
+                                    'C3D10H':10, 'C3D10MH':10, 'C3D10HS':10, #Tet advanced
+                                    }
+        elementTypeConversion={'C3D8':'Hex8', 'C3D20':'Hex20', 
+                               'C3D8R':'Hex8', 'C3D20R':'Hex20', #same nodes as C3D8 / C3D20, only reduced integration
+                               'C3D4':'Tet4', 'C3D10':'Tet10',
+                               'C3D10H':'Tet10', 'C3D10MH':'Tet10', 'C3D10HS':'Tet10',
+                               }
+        elementSectionFound = False
+        elementTypeName = ''
+        while lineCnt < nLines and not elementSectionFound:
+            line = fileLines[lineCnt]
+            #print("now=", line)
+            if line[0:len('*Element')] == '*Element':
+                elementSectionFound = True
+                elementTypeName=line.split(',')[1].split('=')[1].strip()
+                if verbose: print("found *Element in line", lineCnt, 'element type=',elementTypeName)
+                
+                if not (elementTypeName in availableElementTypesNodes):
+                    raise ValueError("ImportFromAbaqusInputFile: element type '"+elementTypeName+"' can not yet be imported")
+                
+            lineCnt += 1
+    
+        if not elementSectionFound: 
+            raise ValueError("ImportFromAbaqusInputFile: did not find keyword *Element ")
+    
+        elementType= elementTypeConversion[elementTypeName]
+        if not(elementTypeName in elementsDict):
+            elementsDict[elementType] = []
+    
+        #+++++++++++++++++++++++++++++++++++++++++++++
+        #read elements:
+        elementReadFinished = False
+        nElementNodes = availableElementTypesNodes[elementTypeName] #this is the expected number of nodes for element type
+        elementCnt = 0
+        while lineCnt < nLines and not elementReadFinished:
+            line = fileLines[lineCnt]
+            #print("read element line:",line)
+        
+            if line[0] != '*': #check if element section has finished
+                lineStr = line.strip() #cut spaces at end in order to detect ',' at end
+                while lineStr[-1] == ',' and lineCnt < nLines:
+                    lineCnt += 1
+                    line = fileLines[lineCnt]
+                    if line[0] == '*': 
+                        raise ValueError("ImportFromAbaqusInputFile: while reading elements, got invalid format of line "+str(lineCnt+1))
+                    lineStr += line
+                    #print("   extended line:",lineStr)
+                    
+                lineData = lineStr.strip().split(',') #split into values
+                
+                if len(lineData) != nElementNodes+1:
+                    raise ValueError("ImportFromAbaqusInputFile: Expected element and "+str(nElementNodes)+" node numbers in line "+str(lineCnt))
+                else:
+                    v = []
+                    for i in range(nElementNodes):
+                        v+=[int(lineData[i+1])-1] #changed from float
+                    elementsDict[elementType] += [v]
+                    elementCnt += 1
+            else:
+                elementReadFinished = True
+            lineCnt += 1
+        
+        if verbose: print("imported ", elementCnt, "elements")
+
+        #FEMinterface:
+        self.elements += [elementsDict]
+        self.nodes['Position'] = np.array(nodes)
+
+
+        #convert elements to triangles for drawing:
+        if createSurfaceTrigs:
+            if not surfaceTrigsAll:
+                self.VolumeToSurfaceElements(verbose) #create surface from imported elements
+            else:
+                if verbose:
+                    print('create surface triangles for all elements; may be large number of triangles for visualization ...')
+                trigList = []
+                if 'Hex8' in elementsDict:
+                    for element in elementsDict['Hex8']:
+                        trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
+                if 'Hex20' in elementsDict:
+                    for element in elementsDict['Hex20']:
+                        trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
+                if 'Tet4' in elementsDict:
+                    for element in elementsDict['Tet4']:
+                        trigList += ConvertTetToTrigs(element) #node numbers are already 0-based
+                if 'Tet10' in elementsDict:
+                    for element in elementsDict['Tet10']:
+                        trigList += ConvertTetToTrigs(element) #node numbers are already 0-based
+        
+                self.surface += [{'Name':'meshSurface', 'Trigs':trigList}]    # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
+
+
+        return np.array(nodes)
+        
+        #return [np.array(nodes), elementsDict]
+
+
+
+
+    #**classFunction: read mass matrix from compressed row text format (exported from Abaqus); in order to export system matrices, write the following lines in your Abaqus input file:
+    #*STEP
+    #*MATRIX GENERATE, STIFFNESS, MASS
+    #*MATRIX OUTPUT, STIFFNESS, MASS, FORMAT=COORDINATE
+    #*End Step
+    def ReadMassMatrixFromAbaqus(self, fileName, type='SparseRowColumnValue'):
+        self.massMatrix = np.loadtxt(fileName)
+        self.massMatrix[:,0] -= 1 #convert 1-based indices to 0-based indices
+        self.massMatrix[:,1] -= 1
+
+    #**classFunction: read stiffness matrix from compressed row text format (exported from Abaqus)
+    def ReadStiffnessMatrixFromAbaqus(self, fileName, type='SparseRowColumnValue'):
+        self.stiffnessMatrix = np.loadtxt(fileName)
+        self.stiffnessMatrix[:,0] -= 1 #convert 1-based indices to 0-based indices
+        self.stiffnessMatrix[:,1] -= 1
+
+
+
+    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: import mesh from NETGEN/NGsolve and setup mechanical problem
+    #**notes: The interface to NETGEN/NGsolve has been created together with Joachim Sch\"oberl, main developer 
+    #  of NETGEN/NGsolve \cite{Schoeberl1997,NGsolve2014}; Thank's a lot!
+    #  download NGsolve at: https://ngsolve.org/
+    #  NGsolve needs Python 3.7 (64bit) ==> use according EXUDYN version!
+    #  note that node/element indices in the NGsolve mesh are 1-based and need to be converted to 0-base!
+    #**input:
+    #    mesh: a previously created \texttt{ngs.mesh} (NGsolve mesh, see examples)
+    #    youngsModulus: Young's modulus used for mechanical model
+    #    poissonsRatio: Poisson's ratio used for mechanical model
+    #    density: density used for mechanical model
+    #    meshOrder: use 1 for linear elements and 2 for second order elements (recommended to use 2 for much higher accuracy!)
+    #    verbose: set True to print out some status information
+    #**notes: setting ngsolve.SetNumThreads(nt) you can select the number of treads that are used for assemble or other functionality with NGsolve functionality 
+    #**output: creates according nodes, elements, in FEM and returns [bfM, bfK, fes] which are the (mass matrix M, stiffness matrix K) bilinear forms and the finite element space fes
+    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
+    def ImportMeshFromNGsolve(self, mesh, density, youngsModulus, poissonsRatio, verbose = False, 
+                              computeEigenmodes = False, meshOrder = 1, **kwargs):
+        #OLD, DELETE 2022-01-01:
+        #    computeEigenmodes: set True to use NGsolve for eigenmode computation instead of ComputeEigenmodes
+        #    numberOfModes: if computeEigenmodes==True: number of eigen modes computed with NGsolve; default=10
+        #    maxEigensolveIterations: if computeEigenmodes==True: maximum number of iterations for iterative eigensolver; default=40
+        #    excludeRigidBodyModes: if computeEigenmodes==True: if rigid body modes are expected (in case of free-free modes), then this number specifies the number of eigenmodes to be excluded in the stored basis (usually 6 modes in 3D)
+        import ngsolve as ngs
+        if meshOrder < 1 or meshOrder > 2:
+            raise ValueError('mesh order > 1 or mesh order < 2 not supported!')
+            
+        if meshOrder == 2:
+            mesh.ngmesh.SecondOrder()
+
+        if verbose: print("NGsolve create mechanics FE space ...")
+        if meshOrder == 1:
+            fes = ngs.VectorH1(mesh, order=meshOrder) #add interleaved = True to get xyzxyz sorting
+        else:
+            fes = ngs.NodalFESpace(mesh, order=meshOrder)**3
+            
+        #create finite element spaces for mass matrix and stiffness matrix    
+        u = fes.TrialFunction()
+        v = fes.TestFunction()
+        bfK = ngs.BilinearForm(fes)
+        bfM = ngs.BilinearForm(fes)
+
+        def sigma(eps, mu, lam):
+            return 2*mu*eps + lam*ngs.Trace(eps) * ngs.Id(eps.dims[0])
+
+        E = youngsModulus
+        nu = poissonsRatio
+        rho = density
+
+        mu  = E / 2 / (1+nu) #Lame parameters
+        lam = E * nu / ((1+nu)*(1-2*nu))
+
+        #setup (linear) mechanical FE-space
+        bfK += ngs.InnerProduct(sigma(ngs.Sym(ngs.Grad(u)),mu,lam), ngs.Sym(ngs.Grad(v)))*ngs.dx
+        bfM += rho*u*v * ngs.dx
+
+        with ngs.TaskManager():
+            if verbose: print ("NGsolve assemble M and K")
+            bfK.Assemble()
+            bfM.Assemble()
+
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #export to scipy sparse matrices:
+        from scipy.sparse import csr_matrix
+        if verbose: print ("NGsolve convert system matrices to scipy csr_matrix format")
+        K = csr_matrix( bfK.mat.CSR(), copy=True )
+        M = csr_matrix( bfM.mat.CSR(), copy=True )
+        if verbose: print("K.shape=",K.shape)
+
+        #convert csr_matrix in NGsolve to exudyn sparse CSR np.array:
+        M1 = ScipySparseCSRtoCSR(M)
+        K1 = ScipySparseCSRtoCSR(K)
+
+        nMK = M.shape[0] #get size of mass matrix; assume square matrix!
+        #NGsolve sorts indices as x0x1x2...y0y1y2...z0z1z2...., but is needed as x0y0z0x1y1z1...
+        ResortIndicesOfCSRmatrix(M1, nMK)
+        ResortIndicesOfCSRmatrix(K1, nMK)
+
+
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #get node, element and surface list:
+        nodeList=[]
+        tetList=[]
+        surfaceTriangleList=[] #for drawing
+        NE = mesh.ne
+        if verbose: print("number of tets=", NE)
+
+        if meshOrder == 1:
+            NP = len(mesh.vertices)
+            if verbose: print("number of points=", NP)
+            for n in mesh.vertices: 
+                nodeList+=[list(n.point)]
+        else:
+            NP = len(mesh.ngmesh.Points())
+            if verbose: print("number of points=", NP)
+    
+            for n in mesh.ngmesh.Points(): 
+                nodeList+=[list(n)]
+
+    
+        #extract 3D elements from mesh:
+        tets = mesh.ngmesh.Elements3D()
+        cnt=0
+        for el in tets:
+            if len(el.vertices) == 4: #check if element is a tet
+                tetIndices=[]
+                for i in el.vertices:
+                    tetIndices+=[int(i.nr)-1] #convert to 0-base
+                tetList += [tetIndices]
+            else:
+                print("ERROR in ImportMeshFromNGsolve: invalid element in ngmesh, elementNr=", cnt, "linear tet elements required!")
+            cnt+=1
+
+        #function to flip surface elements:
+        def Flip3D(v):
+            return [v[0], v[2], v[1]]
+        
+        surface = mesh.ngmesh.Elements2D() #surface mesh
+        if meshOrder == 1:
+            for st in surface: 
+                vertices = []
+                for v in st.vertices: #st.points gives all nodes (for order>1), vertices only vertex points (always 4 per tet)
+                    vertices += [v.nr-1] #convert to 0-based indices
+                if len(vertices) != 3:
+                    raise ValueError('ImportMeshFromNGsolve: expected linear 3-node surface elements')
+
+                surfaceTriangleList += [Flip3D(vertices)]
+        else: #order 2
+            for st in surface: 
+                w = []
+                for v in st.points: #st.points gives all nodes (for order>1), vertices only vertex points (always 4 per tet)
+                    w += [v.nr-1] #convert to 0-based indices
+                if len(w) != 6:
+                    raise ValueError('ImportMeshFromNGsolve: expected second order 6-node surface elements')
+
+                surfaceTriangleList += [Flip3D([w[0],w[5],w[4]])]
+                surfaceTriangleList += [Flip3D([w[5],w[1],w[3]])]
+                surfaceTriangleList += [Flip3D([w[5],w[3],w[4]])]
+                surfaceTriangleList += [Flip3D([w[4],w[3],w[2]])]
+
+        nodes = np.array(nodeList)
+        elements=np.array(tetList) #unused
+        trigList = surfaceTriangleList
+
+        self.nodes = {'Position':nodes}
+        self.elements = [{'Name':'NGsolve','Tet4':elements}]
+        self.massMatrix = M1 
+        self.stiffnessMatrix = K1 
+        self.surface = [{'Name':'meshSurface','Trigs':trigList}]
+
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        if computeEigenmodes:
+            print('**********\nWARNING!**********\nNGsolve eigenmode computation deprecated: USE FEM.ComputeEigenmodesNGsolve(...)')
+            if verbose: print ("NGsolve: compute eigenmodes")
+            excludeRigidBodyModes = 0
+            if 'excludeRigidBodyModes' in kwargs:
+                excludeRigidBodyModes = kwargs['excludeRigidBodyModes']
+
+            nModes = 10
+            if 'numberOfModes' in kwargs: 
+                nModes = kwargs['numberOfModes'] 
+            maxIt = 40
+            if 'maxEigensolveIterations' in kwargs: 
+                maxIt = kwargs['maxEigensolveIterations']
+
+            from ngsolve.eigenvalues import PINVIT
+
+            with ngs.TaskManager():
+                KM = bfK.mat.CreateMatrix()
+                KM.AsVector().data = bfK.mat.AsVector() + 1e6* bfM.mat.AsVector()
+            
+                inv = KM.Inverse(inverse='sparsecholesky')
+                res = PINVIT(bfK.mat, bfM.mat, inv, num=nModes+excludeRigidBodyModes, maxit=maxIt, \
+                                printrates=verbose, GramSchmidt=True)
+
+            #self.res = res
+            nDOF = K.shape[0]
+            eigVecs = np.zeros((nDOF, nModes))
+            for i in range(nModes):
+                #eigVecs[:,i] = np.array(res[1][excludeRigidBodyModes+i])
+                eigVecs[:,i] = ResortIndicesOfNGvector(np.array(res[1][excludeRigidBodyModes+i]))
+            
+            self.modeBasis = {'matrix':eigVecs, 'type':'NormalModes'}
+            self.eigenValues = np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])
+                             
+            if verbose: print ("eigenfrequencies (Hz) =",(0.5/np.pi)*np.sqrt(np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])))
+
+        return [bfM, bfK, fes]
+
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute nModes smallest eigenvalues and eigenmodes from mass and stiffnessMatrix; store mode vectors in modeBasis, but exclude a number of 'excludeRigidBodyModes' rigid body modes from modeBasis; uses scipy for solution of generalized eigenvalue problem
+    #**input: 
+    #  nModes: prescribe the number of modes to be computed; total computed modes are  (nModes+excludeRigidBodyModes), but only nModes with smallest absolute eigenvalues are considered and stored
+    #  excludeRigidBodyModes: if rigid body modes are expected (in case of free-free modes), then this number specifies the number of eigenmodes to be excluded in the stored basis (usually 6 modes in 3D)
+    #  maxEigensolveIterations: maximum number of iterations for iterative eigensolver; default=40
+    #  verbose: if True, output some relevant information during solving
+    #**output: eigenmodes are stored internally in FEMinterface as 'modeBasis' and eigenvalues as 'eigenValues'
+    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
+    def ComputeEigenmodesNGsolve(self, bfM, bfK,
+                                 nModes, 
+                                 maxEigensolveIterations = 40,
+                                 excludeRigidBodyModes = 0,
+                                 verbose = False):
+        import ngsolve as ngs
+
+        maxIt = maxEigensolveIterations
+
+        from ngsolve.eigenvalues import PINVIT
+
+        with ngs.TaskManager():
+            KM = bfK.mat.CreateMatrix()
+            KM.AsVector().data = bfK.mat.AsVector() + 1e6* bfM.mat.AsVector()
+        
+            inv = KM.Inverse(inverse='sparsecholesky')
+            res = PINVIT(bfK.mat, bfM.mat, inv, num=nModes+excludeRigidBodyModes, maxit=maxIt, \
+                            printrates=verbose, GramSchmidt=True)
+
+        #nDOF = K.shape[0]
+        nDOF = bfK.space.ndof
+        eigVecs = np.zeros((nDOF, nModes))
+        for i in range(nModes):
+            #eigVecs[:,i] = np.array(res[1][excludeRigidBodyModes+i])
+            eigVecs[:,i] = ResortIndicesOfNGvector(np.array(res[1][excludeRigidBodyModes+i]))
+        
+        self.modeBasis = {'matrix':eigVecs, 'type':'NormalModes'}
+        self.eigenValues = np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])
+                         
+        if verbose: print ("eigenfrequencies (Hz) =",(0.5/np.pi)*np.sqrt(np.abs(res[0][excludeRigidBodyModes:excludeRigidBodyModes + nModes])))
+
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute static  and eigen modes based on Hurty-Craig-Bampton, for details see theory part \refSection{sec:theory:CMS}. This function uses internal computational functionality of NGsolve and is often much faster than the scipy variant
+    #**input:
+    #  bfM: bilinearform for mass matrix as retured in ImportMeshFromNGsolve(...)
+    #  bfK: bilinearform for stiffness matrix as retured in ImportMeshFromNGsolve(...)
+    #  boundaryNodesList: [nodeList0, nodeList1, ...] a list of node lists, each of them representing a set of 'Position' nodes for which a rigid body interface (displacement/rotation and force/torque) is created; NOTE THAT boundary nodes may not overlap between the different node lists (no duplicated node indices!)
+    #  nEigenModes: number of eigen modes in addition to static modes (may be zero for RBE2 computationMode); eigen modes are computed for the case where all rigid body motions at boundaries are fixed; only smallest nEigenModes absolute eigenvalues are considered
+    #  maxEigensolveIterations: maximum number of iterations for iterative eigensolver; default=40
+    #  verbose: if True, output some relevant information during solving
+    #**output: stores computed modes in self.modeBasis and abs(eigenvalues) in self.eigenValues
+    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
+    def ComputeHurtyCraigBamptonModesNGsolve(self,
+                                      bfM, bfK,
+                                      boundaryNodesList,
+                                      nEigenModes, 
+                                      maxEigensolveIterations = 40,
+                                      verbose = False):
+
+        import ngsolve as ngs
+        import time
+        start_time = time.time()
+        #from scipy.linalg import solve, eigh, eig #eigh for symmetric matrices, positive definite
+        
+        nNodeLists = len(boundaryNodesList)
+        #sizes of internal and boundary nodes:
+        #M = bfM.mat
+        K = bfK.mat
+        n = K.height
+        nNodes = int(n/3)
+        nodesPos = self.GetNodePositionsAsArray()
+
+        bndDOFsAll = ngs.BitArray(n) #fill in all boundaries later
+        bndDOFsAll[:] = False        
+        
+        #+++++++++++++++++++++++++++
+        #compute static rigid body modes:
+        addRotationModes = 1
+        rbSize = 3 + 3*addRotationModes #size of rigid body coordinates (3 for translation, 6 for translation+rotation)
+        nbRBE2 = (nNodeLists-1)*rbSize #number of chosen static modes, 6 DOF per rigid body interface; exclude first rigid body boundary in order to suppress rigid body motion of static modes
+        #DOFeig = np.arange(nbRBE2,nbRBE2+nEigenModes) #for final mapping of eigenmode coordinates
+
+        modeBasis = np.zeros((n, nbRBE2+nEigenModes))
+
+        #all rigid body modes
+        mvAll = ngs.MultiVector(K.CreateColVector(),0)
+        
+        #1 rigid body modes
+        mvRB = ngs.MultiVector(K.CreateColVector(),6)
+        for v in mvRB: v[:]=0 #initialize!
+
+        #rigid body displacements
+        for i in range(3):
+            mvRB[i][nNodes*i:nNodes*(i+1)] = 1
+                        
+        #create list of mappings between average rigid body motion and boundary DOF matrix
+        #rigidBodyMappings = [[]]*nNodeLists #list of mappings
+        cntBoundary = 0 #counter for boundaryNodeLists / number of interfaces
+        for cntBoundary, boundaryNodes in enumerate(boundaryNodesList):
+            nbn = len(boundaryNodes)
+            
+            bndDOFs = ngs.BitArray(n)
+            bndDOFs[:] = False
+    
+            DOFb = np.zeros(nbn*3, dtype=np.int)
+            for i in range(len(boundaryNodes)):
+                node = boundaryNodes[i]
+                #DOFb[i*3:i*3+3] = [node*3,node*3+1,node*3+2] #interleaved xyzxyz
+                DOFb[i*3:i*3+3] = [node,node+nNodes,node+2*nNodes] #xxxx yyyy zzzz
+                
+            for i, d in enumerate(DOFb):
+                bndDOFs[d] = True
+
+            bndDOFsAll |= bndDOFs
+            
+            #compute midpoints of boundary nodes:
+            p0 = np.zeros(3)
+            for node in boundaryNodes:
+                p0 += nodesPos[node]
+            
+            p0 = p0*(1./len(boundaryNodes))
+
+            #compute rigid body modes for this boundary:
+            for i in range(3): #iterate about 3 rotation axes
+                rot = np.zeros(3) #rotation vector, unit rotation
+                rot[i] = 1
+                rotTilde = Skew(rot)
+                for bj in boundaryNodes:
+                    p = nodesPos[bj]-p0
+                    qRot = rotTilde@p
+
+                    for k in range(3):
+                        mvRB[i+3][bj+k*nNodes] = qRot[k]
+            
+            proj = ngs.Projector(bndDOFs, True)
+            for v in mvRB:
+                hv = v.CreateVector()
+                hv.data = proj * v
+                mvAll.Append(hv)
+        
+        if verbose: print('solve...')
+        KiiInv = K.Inverse(~bndDOFsAll,inverse='sparsecholesky')
+        if verbose: print('...ready')
+
+        #compute static modes for all rigid body boundaries
+        mvAll.data = mvAll - KiiInv @ K * mvAll
+            
+        for i in range(len(mvAll)-1*rbSize):
+            modeBasis[:,i] = ResortIndicesOfNGvector(mvAll[i+1*rbSize])
+   
+        #++++++++++++++++++++++++++++++++++++++
+        #compute modes for free inner nodes:    
+        from ngsolve.eigenvalues import PINVIT
+
+        if nEigenModes != 0:
+            if verbose: print('compute eigenvectors of inner nodes...')
+            maxIt = maxEigensolveIterations
+            with ngs.TaskManager():#pajetrace=10**8):
+                #with shift strategy, but not necessary for inner nodes (no rigid-body-modes)
+                # KM = bfK.mat.CreateMatrix()
+                # KM.AsVector().data = bfK.mat.AsVector() + 1e6* bfM.mat.AsVector()
+                # KMinv = KM.Inverse(~bndDOFsAll,inverse='sparsecholesky')
+                KMinv = KiiInv
+                res = PINVIT(bfK.mat, bfM.mat, KMinv, 
+                             num=nEigenModes, maxit=maxIt, \
+                             printrates=verbose, GramSchmidt=True)
+    
+            if verbose: print('...ready')
+    
+            for i in range(nEigenModes):
+                modeBasis[:,i+nbRBE2] = ResortIndicesOfNGvector(np.array(res[1][i]))
+
+            self.eigenValues = np.abs(res[0][0:nEigenModes])
+        else:
+            self.eigenValues = np.array([])
+
+        self.modeBasis = {'matrix':modeBasis, 'type':'HCBmodes'}
+                         
+        if verbose: 
+            print ("eigenfrequencies (Hz) =",(0.5/np.pi)*np.sqrt(np.abs(self.eigenValues)))
+            print("HCB NGsolve modes needed %.3f seconds" % (time.time() - start_time))
+
+
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute special stress or strain modes in order to enable visualization of stresses and strains in ObjectFFRFreducedOrder; takes a NGsolve fes as input and uses internal NGsolve methods to efficiently compute stresses or strains
+    #**input: 
+    #  fes: finite element space as retured in ImportMeshFromNGsolve(...)
+    #  material: specify material properties for computation of stresses, using a material class, e.g. material = KirchhoffMaterial(Emodulus, nu, rho); not needed for strains (material = 0)
+    #  outputVariableType: specify either exudyn.OutputVariableType.StressLocal or exudyn.OutputVariableType.StrainLocal as the desired output variables
+    #**notes: This function is implemented in Python and rather slow for larger meshes; for NGsolve / Netgen meshes, see the according ComputePostProcessingModesNGsolve function, which is usually much faster
+    #**output: post processing modes are stored in FEMinterface in local variable postProcessingModes as a dictionary, where 'matrix' represents the modes and 'outputVariableType' stores the type of mode as a OutputVariableType
+    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
+    def ComputePostProcessingModesNGsolve(self, fes, material = 0, 
+                                          outputVariableType = 'OutputVariableType.StressLocal', 
+                                          verbose = False):
+
+        import ngsolve as ngs
+        #++++++++++++++++++++++++++++++++++++
+        #special ngsolve functions which are put into expression trees:
+        def Strain2Stress(eps, mu, lam):
+            return 2*mu*eps + lam*ngs.Trace(eps) * ngs.Id(eps.dims[0])
+    
+        def Strain2Strain(eps, mu, lam):
+            return eps
+        #++++++++++++++++++++++++++++++++++++
+        #print("t=",outputVariableType)
+        if str(outputVariableType) == 'OutputVariableType.StressLocal':
+            computeStrains = False
+            StressFunction = Strain2Stress
+        elif str(outputVariableType) == 'OutputVariableType.StrainLocal':
+            computeStrains = True
+            StressFunction = Strain2Strain
+        else:
+            raise ValueError('ComputePostProcessingModes invoked with invalid outputVariableType')
+
+        if material == 0:
+            material=KirchhoffMaterial(1, 0, 1)
+            if not computeStrains:
+                raise ValueError('ComputePostProcessingModes: if material=0, outputVariableType must be StrainLocal')
+
+        nNodes = int(fes.ndof/3)
+        modeBasis = self.modeBasis['matrix']
+        [mu, lam] = material.LameParameters()
+                
+        nModeVectors = modeBasis.shape[1]
+        stressModesMatrix = np.zeros((nNodes,6*nModeVectors))
+    
+        meshOrder = fes.components[0].globalorder
+        if verbose: print('ORDER of fes=',meshOrder)
+        # meshOrder = 2
+        if meshOrder == 1:
+            fesStress = ngs.MatrixValued(ngs.H1(fes.mesh, order=meshOrder), symmetric=True)
+        else:
+            fesStress = ngs.MatrixValued(ngs.NodalFESpace(fes.mesh, order=meshOrder), symmetric=True)
+
+        #order of stresses (per node) = xx,xy,xz,yy,yz,zz (in order xx xx xx xy xy xy...)
+        gfStress = ngs.GridFunction(fesStress)
+        gfu = ngs.GridFunction(fes)
+    
+        #map ngsolve stress components xx,xy,yy,xz,yz,zz to Exudyn xx,yy,zz,yz,xz,xy
+        ngsStressMap = [0,2,5,4,3,1] #stressModeExu[i] = stressModeNGS[ngsStressMap[i]]
+    
+        with ngs.TaskManager():
+            for i in range(nModeVectors):
+                if verbose: print('compute stress mode ', i, 'of', nModeVectors)
+                v = modeBasis[:,i]
+                gfu.vec.FV()[:] = ResortIndicesExudyn2NGvector(v)
+                #gfStress.Interpolate(StressFunction(ngs.Sym(ngs.Grad(gfu)), mu, lam).Compile())
+                gfStress.Set(StressFunction(ngs.Sym(ngs.Grad(gfu)), mu, lam))
+                
+                sv = gfStress.vec.FV()
+                for j in range(6):
+                    stressModesMatrix[:,i*6+j] = sv[ngsStressMap[j]*nNodes:(ngsStressMap[j]+1)*nNodes]
+        
+        self.postProcessingModes = {'matrix': stressModesMatrix, 
+                                    'outputVariableType': outputVariableType}
+        
+
+
+
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #general FEMinterface functionality
+
+
+    #**classFunction: get sparse mass matrix in according format
+    def GetMassMatrix(self, sparse=True):
+        if sparse:
+            return self.massMatrix
+        else:
+            return CompressedRowSparseToDenseMatrix(self.massMatrix)
+
+    #**classFunction: get sparse stiffness matrix in according format
+    def GetStiffnessMatrix(self, sparse=True):
+        if sparse:
+            return self.stiffnessMatrix
+        else:
+            return CompressedRowSparseToDenseMatrix(self.stiffnessMatrix)
+
+    #**classFunction: get total number of nodes
+    def NumberOfNodes(self):
+        nNodes = 0
+        for nodeTypeName in self.nodes:
+            nNodes += len(self.nodes[nodeTypeName])
+        return nNodes
+
+    #**classFunction: get node points as array; only possible, if there exists only one type of Position nodes
+    #**notes: in order to obtain a list of certain node positions, see example
+    #**example:
+    #p=GetNodePositionsAsArray(self)[42] #get node 42 position
+    #nodeList=[1,13,42]
+    #pArray=GetNodePositionsAsArray(self)[nodeList] #get np.array with positions of node indices
+    def GetNodePositionsAsArray(self):
+        if len(self.nodes) != 1:
+            raise ValueError("ERROR: GetNodePositionsAsArray() only possible for one type of Position nodes!")
+
+        nodeTypeName = list(self.nodes)[0]
+        return self.nodes[nodeTypeName]
+
+    #**classFunction: get mean (average) position of nodes defined by list of node numbers
+    def GetNodePositionsMean(self,nodeNumberList):
+        if len(self.nodes) != 1:
+            raise ValueError("ERROR: GetNodesMeanPositions(...) only possible for one type of Position nodes!")
+
+        return np.mean(self.GetNodePositionsAsArray()[nodeNumberList], axis=0)
+
+    #**classFunction: get number of total nodal coordinates
+    def NumberOfCoordinates(self):
+        nCoordinates = 0
+        for nodeTypeName in self.nodes:
+            nCoordinates += len(self.nodes[nodeTypeName]) * self.coordinatesPerNodeType[nodeTypeName]
+        return nCoordinates
+
+    #**classFunction: get node number for node at given point, e.g. p=[0.1,0.5,-0.2], using a tolerance (+/-) if coordinates are available only with reduced accuracy
+    #if not found, it returns an invalid index
+    def GetNodeAtPoint(self, point, tolerance = 1e-5, raiseException = True):
+        cnt = 0
+        if len(self.nodes) != 1 or 'Position' not in self.nodes:
+            raise ValueError('FEMinterface.GetNodeAtPoint: only Position type nodes allowed')
+        for nodeTypeName in self.nodes:
+            for nodePoint in self.nodes[nodeTypeName]:
+                if abs(nodePoint - point).max() <= tolerance:
+                    return cnt #this holds the node number
+                cnt+=1
+        
+        if raiseException:
+            raise ValueError("ERROR: GetNodeAtPoint: node point not found!")
+        return -1 #invalid index, only if no exception raised
+
+    #**classFunction: get node numbers in plane defined by point p and (normalized) normal vector n using a tolerance for the distance to the plane
+    #if not found, it returns an empty list
+    def GetNodesInPlane(self, point, normal,  tolerance = 1e-5):
+        cnt = 0
+        nodeList=[]
+        if len(self.nodes) != 1 or 'Position' not in self.nodes:
+            raise ValueError('FEMinterface.GetNodesInPlane: only Position type nodes allowed')
+        for nodeTypeName in self.nodes:
+            for nodePoint in self.nodes[nodeTypeName]:
+                if abs(np.dot(nodePoint - point, normal)) <= tolerance:
+                    nodeList += [cnt]
+                cnt+=1
+        return nodeList
+
+    #**classFunction: get node numbers in cube, given by pMin and pMax, containing the minimum and maximum x, y, and z coordinates
+    #**example:
+    #nList = GetNodesInCube([-1,-0.2,0],[1,0.5,0.5])
+    #**output: returns list of nodes; if no nodes found, return an empty list
+    def GetNodesInCube(self, pMin, pMax):
+        cnt = 0
+        nodeList=[]
+        if len(self.nodes) != 1 or 'Position' not in self.nodes:
+            raise ValueError('FEMinterface.GetNodesInCube: only Position type nodes allowed')
+        for nodeTypeName in self.nodes:
+            for nodePoint in self.nodes[nodeTypeName]:
+                if (nodePoint[0] >= pMin[0] and nodePoint[0] <= pMax[0] and
+                    nodePoint[1] >= pMin[1] and nodePoint[1] <= pMax[1] and
+                    nodePoint[2] >= pMin[2] and nodePoint[2] <= pMax[2]):
+                    nodeList += [cnt]
+                cnt+=1
+        return nodeList
+
+    #**classFunction: get node numbers lying on line defined by points p1 and p2 and tolerance, which is accepted for points slightly outside the surface
+    def GetNodesOnLine(self, p1, p2, tolerance=1e-5):
+        return self.GetNodesOnCylinder(p1, p2, radius=0, tolerance=1e-5)
+
+    #**classFunction: get node numbers lying on cylinder surface; cylinder defined by cylinder axes (points p1 and p2), 
+    #  cylinder radius and tolerance, which is accepted for points slightly outside the surface
+    #  if not found, it returns an empty list
+    def GetNodesOnCylinder(self, p1, p2, radius, tolerance=1e-5):
+        cnt = 0
+        v0 = np.array(p2) - np.array(p1)
+        lAxis = np.linalg.norm(v0)
+        if lAxis != 0:
+            v0 = v0/lAxis
+            
+        nodeList=[]
+        if len(self.nodes) != 1 or 'Position' not in self.nodes:
+            raise ValueError('FEMinterface.GetNodesOnCylinder: only Position type nodes allowed')
+
+        for nodeTypeName in self.nodes:
+            for nodePoint in self.nodes[nodeTypeName]:
+                p = np.array(nodePoint)
+                v1 = p-p1
+                s = v0 @ v1
+                
+                if s <= lAxis+tolerance and s >= -tolerance:
+                    pp = p1 + s*v0 #projected point
+                    r = np.linalg.norm(p-pp) #shortest distance to axis
+                    if abs(r-radius) <= tolerance:
+                        nodeList += [cnt]
+                cnt+=1
+        return nodeList
+
+    #**classFunction: get node numbers lying on a circle, by point p, (normalized) normal vector n (which is the axis of the circle) and radius r
+    #using a tolerance for the distance to the plane
+    #if not found, it returns an empty list
+    def GetNodesOnCircle(self, point, normal, r, tolerance = 1e-5):
+        cnt = 0
+        nodeList=[]
+        if len(self.nodes) != 1 or 'Position' not in self.nodes:
+            raise ValueError('FEMinterface.GetNodesOnCircle: only Position type nodes allowed')
+        for nodeTypeName in self.nodes:
+            for nodePoint in self.nodes[nodeTypeName]:
+                if abs(np.dot(nodePoint - point, normal)) <= tolerance:
+                    if abs(np.dot(nodePoint - point, nodePoint - point) - r**2) <= tolerance**2:
+                        nodeList += [cnt]
+                cnt+=1
+        return nodeList
+
+
+    #**classFunction: return list of node weights based on surface triangle areas; surface triangles are identified as such for which all nodes of a triangle are on the surface
+    #**nodes: requires that surface triangles have been already built during import of finite element mesh, or by calling VolumeToSurfaceElements!
+    #**input: 
+    #  nodeList: list of local (Position) node numbers
+    #  normalizeWeights: if True, weights are normalized to sum(weights)==1; otherwise, returned list contains areas according to nodes per
+    #**output: numpy array with weights according to indices in node list
+    def GetNodeWeightsFromSurfaceAreas(self, nodeList, normalizeWeights=True):
+        verboseMode=False #for debug
+        if len(self.surface) != 1:
+            raise ValueError('GetNodeWeightsFromSurfaces: expected one surface triangle list in FEM, but received: '+str(len(self.surface)))
+
+        if 'Trigs' not in self.surface[0]:
+            raise ValueError('GetNodeWeightsFromSurfaces: only works for triangle surfaces!')
+
+        if len(self.nodes) != 1:
+            raise ValueError('GetNodeWeightsFromSurfaces: only works for one node set!')
+            
+        trigList = self.surface[0]['Trigs']
+        nNodes = self.NumberOfNodes()
+        
+        #build a node list, which contains !=-1 for every node in nodelist
+        globalToLocal = -np.ones(nNodes, dtype=int)
+        for i, node in enumerate(nodeList):
+            globalToLocal[node] = i #also stores global to local mapping ...
+
+        #find according surface trigs and compute areas:
+        femNodes = self.GetNodePositionsAsArray()
+        localSurfaceAreas = []
+        localSurfaceTrigs = []
+        weights = np.zeros(len(nodeList))
+        for trig in trigList: #if all nodes are on surface, also trig is on surface ... (except rare events, which are not considered)
+            if (globalToLocal[trig[0]] != -1 and #zero means that node is not on local surface
+                globalToLocal[trig[1]] != -1 and
+                globalToLocal[trig[2]] != -1 ):
+                localSurfaceTrigs += [trig]
+                A = ComputeTriangleArea(femNodes[trig[0]], femNodes[trig[1]], femNodes[trig[2]]) #always positive
+                localSurfaceAreas += [A]
+                #now add areas weighted to nodes:
+                for k in trig:
+                    weights[globalToLocal[k]] += A/3 #add area to every node
+                    
+        
+        totalArea = sum(localSurfaceAreas)
+        sumWeights = sum(weights)
+        if verboseMode: 
+            print('localSurfaceTrigs:', localSurfaceTrigs)
+            print('total area=', totalArea)
+            print('sum weights=', sumWeights)
+        
+        if sumWeights == 0:
+            raise ValueError('GetNodeWeightsFromSurfaces: no according triangle surfaces found!')
+
+        if normalizeWeights:
+            weights *= 1./sumWeights
+        
+        return weights
+
+    #**classFunction: return surface trigs as node number list (for drawing in EXUDYN and for node weights)
+    def GetSurfaceTriangles(self):
+        trigList = []
+        for surface in self.surface:
+            if 'Trigs' in surface:
+                trigList += surface['Trigs']
+        return trigList
+
+    #**classFunction: generate surface elements from volume elements
+    #stores the surface in self.surface
+    #only works for one element list and only for element types 'Hex8', 'Hex20', 'Tet4' and 'Tet10'
+    def VolumeToSurfaceElements(self, verbose=False):
+        if verbose: print("create surface from volume elements")
+#        self.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
+#        self.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
+        nNodes = self.NumberOfNodes()
+        hex8QuadIndices = [[0,1,2,3],[7,6,5,4],[0,4,5,1],[1,5,6,2],[2,6,7,3],[3,7,4,0]]
+        hex20QuadIndices = [[0,1,2,3],[7,6,5,4],[0,4,5,1],[1,5,6,2],[2,6,7,3],[3,7,4,0]] #without midnodes, works for now
+        tet4TrigIndices = [[0,1,2],[0,3,1],[1,3,2],[2,3,0]]
+        tet10TrigIndices = [[0,1,2],[0,3,1],[1,3,2],[2,3,0]] #without midnodes, works for now
+        
+        elementTypes = ['Hex8','Hex20','Tet4','Tet10']
+
+        element2IndexList = {'Hex8': hex8QuadIndices,
+                             'Hex20':hex20QuadIndices,
+                             'Tet4': tet4TrigIndices,
+                             'Tet10':tet10TrigIndices}
+        surfaceListTrigs = []
+        surfaceListQuads = [] #list of surface quads, will be converted to trigs
+        nodes2elements = [[]]*nNodes #element to node list
+
+        #first store all elements linked to a certain node
+        #print("build nodes to elements...")
+        #print("nodes2elements=",nodes2elements)
+
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #preprocess and generate nodes2elements list
+        cnt = 0
+        for elementDict in self.elements:
+            for elementType in elementTypes:
+                if elementType in elementDict:   #only implemented for Hex8
+                    elementList = elementDict[elementType]
+                    for element in elementList:
+                        #print("  element",cnt,"=",element)
+                        for i in element:
+                            #print("    i=",i)
+                            #nodes2elements[int(i)].append(int(cnt))
+                            alist=list(nodes2elements[i])
+                            alist.append(cnt)
+                            nodes2elements[i] = alist
+                            #print("nodes2elements[",i,"]=",nodes2elements[i])
+                        cnt+=1
+
+        
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        for elementDict in self.elements:
+            for elementType in elementTypes:
+                if elementType in elementDict:   #only implemented for Hex8
+                    elementList = elementDict[elementType]
+                    currentIndexList = element2IndexList[elementType]
+                    
+                    #run through all elements:
+                    nElements = len(elementList)
+                    elementCnt = 0
+                    cnt2=0
+                    #now run over all elements:
+                    for element in elementList:
+                        if verbose and elementCnt%10000 == 0 and elementCnt>0:
+                            print("process element ",elementCnt,"/",nElements)
+                        for surface in currentIndexList:
+                            #test a surface with nodes
+                            actSurface = []
+                            for i in surface:
+                                actSurface += [element[i]]
+                            lenSurface = len(actSurface) #3 or 4 nodes at surface
+                            #print("  actsurface=",actSurface)
+                            #find all potential candidates, which could be opposite
+    
+                            testElements = []
+                            for nn in actSurface:
+                                for elNum in nodes2elements[nn]:
+                                    if not (elNum in testElements):
+                                        testElements += [elNum]
+                            
+                            #print("  testElements=",testElements)
+                            foundNeighbor = False
+                            for el in testElements:
+                                if el != elementCnt: #do not compare with itself!!!
+                                    testElement = elementList[el]
+                                    #print("    testElement=",testElement)
+                                    for surface2 in currentIndexList:
+                                        cnt2+=1
+                                        #print("      surface2=",surface2)
+                                        #test a surface2 with nodes
+                                        testSurface = []
+                                        for j in surface2:
+                                            testSurface += [testElement[j]]
+                                        #print("      testSurface=",testSurface)
+                                        
+                                        if len(set(testSurface).intersection(actSurface)) == lenSurface:
+                                            #print("        found!")
+                                            foundNeighbor = True
+                                            break;
+                            
+                            if not foundNeighbor:
+                                #print("      not found!")
+                                if lenSurface == 4:
+                                    surfaceListQuads += [actSurface]
+                                else:
+                                    surfaceListTrigs += [actSurface]
+                        elementCnt += 1
+        
+        if verbose: print("surfaceListQuad length=",len(surfaceListQuads))
+        for quad in surfaceListQuads:
+            surfaceListTrigs += [[quad[0],quad[1],quad[2]]]
+            surfaceListTrigs += [[quad[0],quad[2],quad[3]]]
+
+        #print("surfaceListTrigs",surfaceListTrigs)
+        #find if surface exists:
+        surfaceExists = False
+        for surf in self.surface:
+            if surf['Name'] == 'meshSurface':
+                surfaceExists = True
+                surf['Trigs'] = surfaceListTrigs
+
+        #otherwise add new surface
+        if not surfaceExists:
+            self.surface += [{'Name':'meshSurface', 'Trigs':surfaceListTrigs}]
+                 
+        
+        
+        
+        
+        
+        
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #+++++++++++      COMPUTATIONAL FUNCTIONS            ++++++++++++++++++++++
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+            
+    #**classFunction: get gyroscopic matrix in according format; rotationAxis=[0,1,2] = [x,y,z]
+    def GetGyroscopicMatrix(self, rotationAxis=2, sparse=True):
+        #create gyroscopic terms
+        nNodes = self.NumberOfNodes()
+        if rotationAxis == 0:
+            X=np.array([[ 0.,  0.,  0.],
+                        [ 0.,  0., -1.],
+                        [ 0.,  1.,  0.]])
+        elif rotationAxis == 1:
+            X=np.array([[ 0.,  0.,  1.],
+                        [ 0.,  0.,  0.],
+                        [-1.,  0.,  0.]])
+        elif rotationAxis == 2:
+            X=np.array([[ 0., -1.,  0.],
+                        [ 1.,  0.,  0.],
+                        [ 0.,  0.,  0.]])
+            
+        if sparse:
+            from scipy import sparse
+            xBlock = sparse.kron(sparse.eye(nNodes), X) #create big block-diagonal matrix
+            G=np.dot(xBlock,CSRtoScipySparseCSR(self.massMatrix))
+        else:
+            xBlock = np.kron(np.eye(nNodes), X) #create big block-diagonal matrix
+            G=np.dot(xBlock,CompressedRowSparseToDenseMatrix(self.massMatrix))
+
+        return G
+
+
+
+    #**classFunction: scale (=multiply) mass matrix with factor
+    def ScaleMassMatrix(self, factor):
+        self.massMatrix[:,2] *= factor
+
+    #**classFunction: scale (=multiply) stiffness matrix with factor
+    def ScaleStiffnessMatrix(self, factor):
+        self.stiffnessMatrix[:,2] *= factor
+
+        
+    #**classFunction: modify stiffness matrix to add elastic support (joint, etc.) to a node; nodeNumber zero based (as everywhere in the code...)
+    #springStiffness must have length according to the node size
+    def AddElasticSupportAtNode(self, nodeNumber, springStiffness=[1e8,1e8,1e8]):
+        if len(self.nodes) != 1:
+            print("ERROR: AddElasticSupportAtNode: there must be exactly one list of nodes!")
+        #nodeList = self.nodes(list(self.nodes)[0])
+        nodeTypeName = list(self.nodes)[0]
+        nodeSize = self.coordinatesPerNodeType[nodeTypeName]
+        nCoordinate = nodeNumber * nodeSize
+        #print("AddElasticSupportAtNode, nCoordinate=", nCoordinate)
+        
+        #supports = []
+        for i in range(nodeSize):
+            #supports += [[nCoordinate+i,nCoordinate+i,springStiffness[i]]]
+            self.stiffnessMatrix = AddEntryToCompressedRowSparseArray(self.stiffnessMatrix, nCoordinate+i,nCoordinate+i,springStiffness[i])
+        #np.vstack((self.stiffnessMatrix, np.array(supports))) #append supports to sparse matrix
+
+    #**classFunction: modify mass matrix by adding a mass to a certain node, modifying directly the mass matrix
+    def AddNodeMass(self, nodeNumber, addedMass):
+        if len(self.nodes) != 1:
+            print("ERROR: AddElasticSupportAtNode: there must be exactly one list of nodes!")
+
+        #nodeList = self.nodes(list(self.nodes)[0])
+        nodeTypeName = list(self.nodes)[0]
+        nodeSize = self.coordinatesPerNodeType[nodeTypeName]
+
+        nCoordinate = nodeNumber * nodeSize
+        #supports = []
+        for i in range(nodeSize):
+            #supports += [[nCoordinate+i,nCoordinate+i,addedMass]]
+            self.massMatrix = AddEntryToCompressedRowSparseArray(self.massMatrix, nCoordinate+i,nCoordinate+i,addedMass)
+        #np.vstack((self.massMatrix, np.array(supports))) #append supports to sparse matrix
+
+    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: create GenericODE2 object out of (linear) FEM model; uses always the sparse matrix mode, independent of the solver settings; this model can be directly used inside the multibody system as a static or dynamic FEM subsystem undergoing small deformations; computation is several magnitudes slower than ObjectFFRFreducedOrder
+    #**input:
+    #  mbs: multibody system to which the GenericODE2 is added
+    #**output: return list [oGenericODE2, nodeList] containing object number of GenericODE2 as well as the list of mbs node numbers of all NodePoint nodes
+    def CreateLinearFEMObjectGenericODE2(self, mbs, color=[0.9,0.4,0.4,1.]):
+        import exudyn as exu
+        femNodes = self.GetNodePositionsAsArray()
+        
+        #add nodes:
+        allNodeList = [] #create node list
+        for node in femNodes:
+            allNodeList += [mbs.AddNode(eii.NodePoint(referenceCoordinates=node))]
+        
+        nRows = self.NumberOfCoordinates()
+        Mcsr = exu.MatrixContainer()
+        Mcsr.SetWithSparseMatrixCSR(nRows,nRows,self.GetMassMatrix(sparse=True), useDenseMatrix=False)
+        Kcsr = exu.MatrixContainer()
+        Kcsr.SetWithSparseMatrixCSR(nRows,nRows,self.GetStiffnessMatrix(sparse=True), useDenseMatrix=False)
+        
+        #now add generic body built from FEM model with mass and stiffness matrix (optional damping could be added):
+        oGenericODE2 = mbs.AddObject(eii.ObjectGenericODE2(nodeNumbers = allNodeList, 
+                                                        massMatrix=Mcsr, 
+                                                        stiffnessMatrix=Kcsr,
+                                                        #forceVector=np.zeros(nRows), 
+                                                        #forceUserFunction=UFforce,
+                                                        visualization=eii.VObjectGenericODE2(triangleMesh = self.GetSurfaceTriangles(), 
+                                                                                         color=color)
+                                                        ))
+        return [oGenericODE2, allNodeList]
+        
+    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: import mesh from NETGEN/NGsolve and setup mechanical problem
+    #**classFunction: create GenericODE2 object fully nonlinear FEM model using NGsolve; uses always the sparse matrix mode, independent of the solver settings; this model can be directly used inside the multibody system as a static or dynamic nonlinear FEM subsystem undergoing large deformations; computation is several magnitudes slower than ObjectFFRFreducedOrder
+    #**input:
+    #    mbs: multibody system to which the GenericODE2 is added
+    #    mesh: a previously created \texttt{ngs.mesh} (NGsolve mesh, see examples)
+    #    youngsModulus: Young's modulus used for mechanical model
+    #    poissonsRatio: Poisson's ratio used for mechanical model
+    #    density: density used for mechanical model
+    #    meshOrder: use 1 for linear elements and 2 for second order elements (recommended to use 2 for much higher accuracy!)
+    #**output: return list [oGenericODE2, nodeList] containing object number of GenericODE2 as well as the list of mbs node numbers of all NodePoint nodes
+    #**notes: The interface to NETGEN/NGsolve has been created together with Joachim Sch\"oberl, main developer 
+    #  of NETGEN/NGsolve \cite{Schoeberl1997,NGsolve2014}; Thank's a lot!
+    #  download NGsolve at: https://ngsolve.org/
+    #  NGsolve needs Python 3.7 (64bit) ==> use according EXUDYN version!
+    #  note that node/element indices in the NGsolve mesh are 1-based and need to be converted to 0-base!
+    #**author: Johannes Gerstmayr, Joachim Sch\"oberl
+    def CreateNonlinearFEMObjectGenericODE2NGsolve(self, mbs, mesh, 
+                                                   density, youngsModulus, poissonsRatio, 
+                                                   meshOrder=1, color=[0.9,0.4,0.4,1.]):
+        import ngsolve as ngs
+        import exudyn as exu
+        from scipy.sparse import csr_matrix
+        
+        if meshOrder < 1 or meshOrder > 2:
+            raise ValueError('mesh order > 1 or mesh order < 2 not supported!')
+            
+        if meshOrder == 2:
+            mesh.ngmesh.SecondOrder()
+
+        nu = poissonsRatio
+        mu  = youngsModulus / 2 / (1+nu)
+        lam = youngsModulus * nu / ((1+nu)*(1-2*nu))
+        
+        #compute Green-Lagrange (nonlinear) strain tensor from displacement field
+        def GLstrain(u):
+            #F = ngs.Id(3) + ngs.Grad(u)
+            #return 0.5*(F.trans * F - ngs.Id(3))
+            return ngs.Sym(ngs.Grad(u)) + 0.5*(ngs.Grad(u).trans * ngs.Grad(u))
+        
+        #compute 2nd PK-stress from strain
+        def Strain2Stress(eps, mu, lam):
+            return 2*mu*eps + lam*ngs.Trace(eps) * ngs.Id(eps.dims[0])
+        
+        #deformation energy acc. to St. Venant-Kirchhoff material
+        def DeformationEnergy (GLstrain, mu, lam):
+            #return 0.5*lam*(ngs.Trace(GLstrain))**2 + mu * ngs.Trace(GLstrain*GLstrain) #2*mu/lam*Det(C)**(-lam/2/mu)-1)
+            return 0.5*ngs.Trace(Strain2Stress(GLstrain,mu,lam).trans*GLstrain)
+        
+        #do not add boundary conditions here, otherwise stiffness matrix cannot be exported!
+        fes = ngs.NodalFESpace(mesh, order=meshOrder)**3
+        uu = fes.TrialFunction()
+        #v = fes.TestFunction()
+    
+        a = ngs.BilinearForm(fes)
+        a += ngs.Variation(DeformationEnergy(GLstrain(uu), mu, lam).Compile()*ngs.dx)
+        #linear:
+        #a += ngs.InnerProduct(Strain2Stress(ngs.Sym(ngs.Grad(uu)),mu,lam), ngs.Sym(ngs.Grad(v)))*ngs.dx
+        
+        #define grid function to work with in nonlinear solver:
+        u = ngs.GridFunction(fes)
+        u.vec[:] = 0
+            
+        fem=FEMinterface()
+        #this is mainly needed for triangleMesh, but also creates the linearized matrices, but ok:
+        fem.ImportMeshFromNGsolve(mesh, density=density, 
+                                  youngsModulus=youngsModulus, poissonsRatio=poissonsRatio, 
+                                  meshOrder=meshOrder)
+
+        #create nodes:
+        femNodes = fem.GetNodePositionsAsArray()
+        
+        #add nodes:
+        allNodeList = [] #create node list
+        for node in femNodes:
+            allNodeList += [mbs.AddNode(eii.NodePoint(referenceCoordinates=node))]
+        
+        nRows = fem.NumberOfCoordinates()
+        Mcsr = exu.MatrixContainer()
+        Mcsr.SetWithSparseMatrixCSR(nRows,nRows,fem.GetMassMatrix(sparse=True), useDenseMatrix=False)
+        Kcsr = exu.MatrixContainer()
+        Kcsr.SetWithDenseMatrix(fem.GetStiffnessMatrix(sparse=True), useDenseMatrix=False)
+        
+        res = u.vec.CreateVector() #temporary vector
+        
+        #compute RHS of FEM object
+        def UFforce(mbs, t, itemIndex, q, q_t):
+            u.vec[:] = ResortIndicesExudyn2NGvector(np.array(q))
+            a.Apply(u.vec, res)
+            resNonlin = ResortIndicesOfNGvector(-res.FV().NumPy())
+            return resNonlin
+
+        #jacobian function for FEM object:
+        #put some of the following functions into PyMatrixContainer for higher efficiency
+        def UFjacobian(mbs, t, itemNumber, q, q_t, fODE2, fODE2_t):
+            u.vec[:] = ResortIndicesExudyn2NGvector(np.array(q))
+            a.AssembleLinearization(u.vec)
+            Knonlinear = fODE2*csr_matrix( a.mat.CSR())#, copy=True )
+            Kexu = ScipySparseCSRtoCSR(Knonlinear)
+            nMK = Knonlinear.shape[0] #get size of mass matrix; assume square matrix!
+            ResortIndicesOfCSRmatrix(Kexu, nMK)
+            MCK = exu.MatrixContainer()
+            MCK.SetWithSparseMatrixCSR(nMK,nMK,Kexu)
+            return MCK
+        
+        #now add generic body built from FEM model with mass and stiffness matrix (optional damping could be added):
+        oGenericODE2 = mbs.AddObject(eii.ObjectGenericODE2(nodeNumbers = allNodeList, 
+                                                        massMatrix=Mcsr, 
+                                                        forceUserFunction=UFforce,
+                                                        jacobianUserFunction=UFjacobian,
+                                                        visualization=eii.VObjectGenericODE2(triangleMesh = fem.GetSurfaceTriangles(), color=color)
+                                                        ))
+
+        return [oGenericODE2, allNodeList]
+        
+    #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute nModes smallest eigenvalues and eigenmodes from mass and stiffnessMatrix; store mode vectors in modeBasis, but exclude a number of 'excludeRigidBodyModes' rigid body modes from modeBasis; uses scipy for solution of generalized eigenvalue problem
+    #**input: 
+    #  nModes: prescribe the number of modes to be computed; total computed modes are  (nModes+excludeRigidBodyModes), but only nModes with smallest absolute eigenvalues are considered and stored
+    #  excludeRigidBodyModes: if rigid body modes are expected (in case of free-free modes), then this number specifies the number of eigenmodes to be excluded in the stored basis (usually 6 modes in 3D)
+    #  useSparseSolver: for larger systems, the sparse solver needs to be used, which iteratively solves the problem and uses a random number generator (internally in ARPACK): therefore, results are not fully repeatable!!!
+    #**notes: for NGsolve / Netgen meshes, see the according ComputeEigenmodesNGsolve function, which is usually much faster
+    #**output: eigenmodes are stored internally in FEMinterface as 'modeBasis' and eigenvalues as 'eigenValues'
+    def ComputeEigenmodes(self, nModes, excludeRigidBodyModes = 0, useSparseSolver = True):
+        if not useSparseSolver:
+            #unsorted, dense eigen vectors
+            from scipy.linalg import eigh#, solve, eig #eigh for symmetric matrices, positive definite
+
+            K = self.GetStiffnessMatrix(sparse=False)
+            M = self.GetMassMatrix(sparse=False)
+
+            [eigVals, eigVecs] = eigh(K,M) #this gives omega^2 ... squared eigen frequencies (rad/s)
+            self.modeBasis = {'matrix':eigVecs[:,excludeRigidBodyModes:excludeRigidBodyModes + nModes], 'type':'NormalNodes'}
+            self.eigenValues = abs(eigVals)
+        else:
+            #sorted, sparse eigen vectors
+            from scipy.sparse.linalg import eigsh #eigh for symmetric matrices, positive definite
+
+            K = CSRtoScipySparseCSR(self.GetStiffnessMatrix(sparse=True))
+            M = CSRtoScipySparseCSR(self.GetMassMatrix(sparse=True))
+            #optional, using shift-invert mode; DOES NOT WORK:
+            #guess for smallest eigenvalue:
+            #n=self.NumberOfCoordinates()
+            #mMax = self.GetMassMatrix(sparse=True)[:,2].sum()/3 #take total mass
+            #kMax = self.GetStiffnessMatrix(sparse=True)[:,2].max()   #assume only one node fixed
+            #omegaMin = kMax/mMax*0.1 #factor 0.1 in order to make guess not too large
+            #print("min freq=", np.sqrt(omegaMin)/(2*np.pi))
+            #[eigVals, eigVecs] = eigsh(A=K, k=nModes+excludeRigidBodyModes, M=M, which='SM', sigma=omegaMin) #this gives omega^2 ... squared eigen frequencies (rad/s)
+
+            #use "LM" (largest magnitude), but shift-inverted mode with sigma=0, to find the zero-eigenvalues:
+            #see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html
+            [eigVals, eigVecs] = eigsh(A=K, k=nModes+excludeRigidBodyModes, M=M, 
+                                       which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
+            
+            #[eigVals, eigVecs] = eigsh(A=K, k=nModes+excludeRigidBodyModes, M=M, which='SM') #this gives omega^2 ... squared eigen frequencies (rad/s)
+
+            self.modeBasis = {'matrix':eigVecs[:,excludeRigidBodyModes:excludeRigidBodyModes + nModes], 
+                              'type':'NormalModes'}
+            self.eigenValues = abs(eigVals[excludeRigidBodyModes:excludeRigidBodyModes + nModes])
+
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute eigenmodes, using a set of boundary nodes that are all fixed; very similar to ComputeEigenmodes, but with additional definition of (fixed) boundary nodes.
+    #**input: 
+    #  boundaryNodes: a list of boundary node indices, refering to 'Position' type nodes in FEMinterface; all coordinates of these nodes are fixed for the computation of the modes
+    #  nEigenModes: prescribe the number of modes to be computed; only nEigenModes with smallest abs(eigenvalues) are considered and stored
+    #  useSparseSolver: [yet NOT IMPLEMENTED] for larger systems, the sparse solver needs to be used, which iteratively solves the problem and uses a random number generator (internally in ARPACK): therefore, results are not fully repeatable!!!
+    #**output: eigenmodes are stored internally in FEMinterface as 'modeBasis' and eigenvalues as 'eigenValues'
+    def ComputeEigenModesWithBoundaryNodes(self, 
+                                      boundaryNodes,
+                                      nEigenModes, 
+                                      useSparseSolver = True):
+        if not useSparseSolver:
+            #unsorted, dense eigen vectors
+            from scipy.linalg import eigh#, solve, eig #eigh for symmetric matrices, positive definite
+    
+            K = self.GetStiffnessMatrix(sparse=False)
+            M = self.GetMassMatrix(sparse=False)
+            
+            if len(boundaryNodes) != 0:
+                #sizes of internal and boundary nodes:
+                n = len(M)
+                nb = len(boundaryNodes)*3
+                ni = n-nb
+        
+                #compute indices for internal and boundary DOF/coordinates:
+                DOFb = []
+                for node in boundaryNodes:
+                    DOFb += [node*3,node*3+1,node*3+2]
+                
+                DOFb = np.array(DOFb)
+                DOFb.sort()
+                DOFi = np.arange(n)
+                DOFi = np.delete(DOFi, DOFb)
+                DOFstatic = np.arange(nb) #for final mapping of boundary coordinates
+                DOFeig = np.arange(nb,nb+nEigenModes) #for final mapping of eigenmode coordinates
+                
+                print("n=", n, ", nb=",nb, ", ni=", ni)
+                #print("DOFb=", DOFb)
+                #print("DOFi=", DOFi)
+                
+                #create mass and stiffness matrices with new indices:
+                Mii = M[np.ix_(DOFi,DOFi)]
+                Kii = K[np.ix_(DOFi,DOFi)]
+                Kib = K[np.ix_(DOFi,DOFb)]
+    
+                print("solve eigenvalues...")
+                [eigVals, eigVecs] = eigh(Kii,Mii) #this gives omega^2 ... squared eigen frequencies (rad/s)
+    
+                print("solve static modes...")
+                KiiInvKib = -np.linalg.inv(Kii) @ Kib
+    
+                print("assemble matrices ...")
+                if False:
+                    modeBasis = np.zeros((n, nb+nEigenModes))
+                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
+                    modeBasis[np.ix_(DOFb,DOFstatic)] = np.eye(nb)
+                    modeBasis[np.ix_(DOFi,DOFstatic)] = KiiInvKib
+                else:
+                    modeBasis = np.zeros((n, nEigenModes))
+                    DOFeig = np.arange(nEigenModes) #for final mapping of eigenmode coordinates
+                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
+                
+                #print(modeBasis.shape)
+                #print(modeBasis.round(2))
+               
+                self.modeBasis = {'matrix':modeBasis, 'type':'NormalModes'}
+                self.eigenValues = abs(eigVals)
+    
+            else:
+                [eigVals, eigVecs] = eigh(K,M) #this gives omega^2 ... squared eigen frequencies (rad/s)
+                self.modeBasis = {'matrix':eigVecs[:,0:nEigenModes], 'type':'NormalNodes'}
+                self.eigenValues = abs(eigVals)
+        else:
+            raise ValueError("ComputeEigenModesWithBoundaryNodes: only implemented for dense mode")
+    
+    
+    
+    
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute static  and eigen modes based on Hurty-Craig-Bampton, for details see theory part \refSection{sec:theory:CMS}. Note that this function may need significant time, depending on your hardware, but 50.000 nodes will require approx. 1-2 minutes and more nodes typically raise time more than linearly.
+    #**input:
+    #  boundaryNodesList: [nodeList0, nodeList1, ...] a list of node lists, each of them representing a set of 'Position' nodes for which a rigid body interface (displacement/rotation and force/torque) is created; NOTE THAT boundary nodes may not overlap between the different node lists (no duplicated node indices!)
+    #  nEigenModes: number of eigen modes in addition to static modes (may be zero for RBE2/RBE3 computationMode); eigen modes are computed for the case where all rigid body motions at boundaries are fixed; only smallest nEigenModes absolute eigenvalues are considered
+    #  useSparseSolver: for more than approx.~500 nodes, it is recommended to use the sparse solver; dense mode not available for RBE3
+    #  computationMode: see class HCBstaticModeSelection for available modes; select RBE2 / RBE3 as standard, which is both efficient and accurate and which uses rigid-body-interfaces (6 independent modes) per boundary; RBE3 mode uses singular value decomposition, which requires full matrices for boundary nodes; this becomes slow in particular if the number of a single boundary node set gets larger than 500 nodes
+    #  boundaryNodesWeights: according list of weights with same order as boundaryNodesList, as returned e.g. by FEMinterface.GetNodeWeightsFromSurfaceAreas(...)
+    #  excludeRigidBodyMotion: if True (recommended), the first set of boundary modes is eliminated, which defines the reference conditions for the FFRF object
+    #  RBE3secondMomentOfAreaWeighting: if True, the weighting of RBE3 boundaries is done according to second moment of area; if False, the more conventional (but less appropriate) quadratic distance to reference point weighting is used
+    #  verboseMode: if True, some additional output is printed
+    #  timerTreshold: for more DOF than this number, CPU times are printed even with verboseMode=False
+    #**notes: for NGsolve / Netgen meshes, see the according ComputeHurtyCraigBamptonModesNGsolve function, which is usually much faster - currently only implemented for RBE2 case
+    #**output: stores computed modes in self.modeBasis and abs(eigenvalues) in self.eigenValues
+    def ComputeHurtyCraigBamptonModes(self,
+                                  boundaryNodesList,
+                                  nEigenModes, 
+                                  useSparseSolver = True,
+                                  computationMode = HCBstaticModeSelection.RBE2,
+                                  boundaryNodesWeights = [],
+                                  excludeRigidBodyMotion = True,
+                                  RBE3secondMomentOfAreaWeighting = True,
+                                  verboseMode = False,
+                                  timerTreshold = 20000):
+
+        #only makes sense for RBE3 modes:  positionOnlyModes: provide empty list [] to compute rigid body interfaces for all boundary node lists, or a boolean list [False, False, True, ...] to indicate which modes only have 3 position but no rotation modes; only valid for computationMode = RBE2 
+        #unsorted, dense eigen vectors
+        from scipy.linalg import eigh#, solve, eig #eigh for symmetric matrices, positive definite
+        from scipy.linalg import block_diag
+        import time #for some timers
+    
+        addRotationModes = 1 #may become an argument in future ...
+    
+    
+        if useSparseSolver: 
+            from scipy.sparse.linalg import eigsh, factorized #eigh for symmetric matrices, positive definite
+    
+            K = CSRtoScipySparseCSR(self.GetStiffnessMatrix(sparse=True))
+            M = CSRtoScipySparseCSR(self.GetMassMatrix(sparse=True))
+    
+        else: #not recommended for more than 2000 nodes (6000 DOF)!
+            if computationMode == HCBstaticModeSelection.RBE3:
+                raise ValueError('ComputeHurtyCraigBamptonModes: RBE3 mode only available in sparse mode')
+    
+            K = self.GetStiffnessMatrix(sparse=False)
+            M = self.GetMassMatrix(sparse=False)
+    
+        n = M.shape[0] #size of mass and stiffness matrix; assume square matrix!
+        verboseTimer = n>timerTreshold or verboseMode
+    
+    
+        for bnl in boundaryNodesList:
+            if not IsListOrArray(bnl,checkIfNoneEmpty=True):
+                raise ValueError('ComputeHurtyCraigBamptonModes: boundaryNodesList must contain non-empty node lists')
+                
+    
+            
+        if len(boundaryNodesWeights) != 0:
+            if len(boundaryNodesList) != len(boundaryNodesList):
+                raise ValueError('ComputeHurtyCraigBamptonModes: boundaryNodesWeights must be either empty or have same dimension as boundaryNodesList')
+                for i in range(len(boundaryNodesList)):
+                    if len(boundaryNodesWeights[i]) != len(boundaryNodesList[i]):
+                        raise ValueError('ComputeHurtyCraigBamptonModes: boundaryNodesWeights and boundaryNodesList must have same dimension for every sublist')
+            BNWlist = list(boundaryNodesWeights)
+        else: #create boundaryNodesWeights
+            BNWlist = []
+            for i in range(len(boundaryNodesList)):
+                nBNL = len(boundaryNodesList[i])
+                BNWlist += [1/nBNL*np.ones(nBNL)]
+        
+        
+        #implementation with RBE2 boundary mode
+        if len(boundaryNodesList) != 0:
+            
+            nb = 0
+            DOFb = []
+            nNodeLists = len(boundaryNodesList)
+            if 'Position' not in self.nodes or len(self.nodes) != 1:
+                raise ValueError('ComputeHurtyCraigBamptonModes: nodes in FEMinterface must be of position type!')
+            nodesPos = self.nodes['Position']
+            boundaryNodesMidPoints = []
+            
+            #determine sizes and some parameters:
+            for boundaryIndex, boundaryNodes in enumerate(boundaryNodesList):
+            #sizes of internal and boundary nodes:
+                nb += len(boundaryNodes)*3
+                #compute indices for internal and boundary DOF/coordinates:
+                for node in boundaryNodes:
+                    DOFb += [node*3,node*3+1,node*3+2]
+    
+                #compute midpoints of boundary nodes:
+                p = np.zeros(3)
+                for nodeIndex, node in enumerate(boundaryNodes):
+                    #OLD, without weighting: p += nodesPos[node]
+                    p += BNWlist[boundaryIndex][nodeIndex]*nodesPos[node]
+                
+                #OLD, without weighting: boundaryNodesMidPoints += [p*(1./len(boundaryNodes))]
+                boundaryNodesMidPoints += [p]
+    
+            if verboseMode:
+                print('calculated boundary midpoints=', boundaryNodesMidPoints)
+    
+            #compute boundary and internal DOF numbers:
+            DOFb = np.array(DOFb)
+            DOFi = np.arange(n)
+            DOFi = np.delete(DOFi, DOFb) #sorting not needed for DOFb
+                    
+            #create mass and stiffness matrices with new indices:
+            if useSparseSolver: 
+                #A = B.tocsr()[np.array(list1),:].tocsc()[:,np.array(list2)] faster?
+                #takes 0,042 seconds for 16000 nodes ...
+                Mii = M[DOFi,:][:,DOFi] #these matrices are np.array (dense) or sparse ...
+                Kii = K[DOFi,:][:,DOFi]
+                Kib = K[DOFi,:][:,DOFb]
+                if computationMode == HCBstaticModeSelection.RBE3:
+                    Kbi = K[DOFb,:][:,DOFi] #Kib.T may be used alternatively ...
+                    Kbb = K[DOFb,:][:,DOFb]
+                    
+                    Mbi = M[DOFb,:][:,DOFi] 
+                    Mib = M[DOFi,:][:,DOFb] 
+                    Mbb = M[DOFb,:][:,DOFb] 
+                
+            else:
+                #works also for sparse matrices, but computes dense matrices in between ...
+                Mii = M[np.ix_(DOFi,DOFi)] 
+                Kii = K[np.ix_(DOFi,DOFi)]
+                Kib = K[np.ix_(DOFi,DOFb)]
+            #Mii, Kii, Kib are now np.array (dense) or sparse ...
+        
+            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+            if nEigenModes != 0 and computationMode != HCBstaticModeSelection.RBE3:
+                if verboseTimer: print("compute eigenvalues and eigenvectors... "); start_time = time.time()
+                if useSparseSolver: 
+                    #for details on solver settings, see selfComputeEigenmodes(...)
+                    [eigVals, eigVecs] = eigsh(A=Kii, k=nEigenModes, M=Mii, 
+                                               which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
+                else:
+                    [eigVals, eigVecs] = eigh(Kii,Mii) #this gives omega^2 ... squared eigen frequencies (rad/s)
+                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
+    
+            #for testing and for case where only one boundary exists, which is eliminated afterwards ...
+            if computationMode == HCBstaticModeSelection.allBoundaryNodes: #quite inefficient, because it 
+                modeBasis = np.zeros((n, nb+nEigenModes))
+                DOFstatic = np.arange(nb) #for final mapping of boundary coordinates
+                if nEigenModes != 0:
+                    DOFeig = np.arange(nb,nb+nEigenModes) #for final mapping of eigenmode coordinates
+                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
+                
+                modeBasis[np.ix_(DOFb,DOFstatic)] = np.eye(nb)
+                if verboseTimer: print("factorize Kii... "); start_time = time.time()
+                if useSparseSolver: 
+                    invKii = factorized(Kii.tocsc()) #factorized expects csc format, otherwise warning
+                    KiiInvKib = invKii(-Kib.toarray())
+                else:
+                    KiiInvKib = -np.linalg.inv(Kii) @ Kib
+                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
+                modeBasis[np.ix_(DOFi,DOFstatic)] = KiiInvKib
+    
+            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+            #leading to infinitly stiff (rigid) boundaries; adds additional stiffening:
+            elif computationMode == HCBstaticModeSelection.RBE2:
+                rbSize = 3 + 3*addRotationModes #size of rigid body coordinates (3 for translation, 6 for translation+rotation)
+                nbRBE = (nNodeLists-int(excludeRigidBodyMotion))*rbSize #number of chosen static modes, 6 DOF per rigid body interface; exclude first rigid body boundary in order to suppress rigid body motion of static modes
+    
+                modeBasis = np.zeros((n, nbRBE+nEigenModes))
+                if nEigenModes != 0:
+                    DOFeig = np.arange(nbRBE,nbRBE+nEigenModes) #for final mapping of eigenmode coordinates
+                    modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
+                
+                #create list of mappings between average rigid body motion and boundary DOF matrix
+                rigidBodyMappings = [[]]*nNodeLists #list of mappings
+                cntBoundary = 0 #counter for boundaryNodeLists / number of interfaces
+                for boundaryNodes in boundaryNodesList:
+                    nn = len(boundaryNodes)
+                    #compute mapping from average displacement to displacement at boundary nodes:
+                    T = np.kron(np.ones(nn),np.eye(3)).T #maps rigid body motion of interface to all boundary nodes
+                    
+                    #compute mapping from (averaged) rotation at boundary to displacement of boundary nodes:
+                    if addRotationModes:
+                        Trot = np.zeros((nn*3,3))
+                        p0 = boundaryNodesMidPoints[cntBoundary]
+                        # for i in range(3): #iterate about 3 rotation axes
+                        #     rot = np.zeros(3) #rotation vector, unit rotation
+                        #     rot[i] = 1
+                        #     rotTilde = Skew(rot)
+                        #     for j in range(len(boundaryNodes)):
+                        #         p = nodesPos[boundaryNodes[j]]-p0
+                        #         pRot = rotTilde@p
+                        #         Trot[j*3:j*3+3,i] = pRot
+                        #shorter:
+                        for j in range(len(boundaryNodes)):
+                            p = nodesPos[boundaryNodes[j]]-p0
+                            pRot = Skew(p)
+                            Trot[j*3:j*3+3,:] = pRot
+                            
+                        T = np.hstack((T,Trot))
+                                
+    
+                    rigidBodyMappings[cntBoundary] = T
+                    cntBoundary += 1
+    
+                
+                Tall = block_diag(*rigidBodyMappings)  # '*' does unpacking of lists;
+                if excludeRigidBodyMotion:
+                    Tall = Tall[:,rbSize:] #exclude first rigid body boundary in order to suppress rigid body motion of static modes
+    
+                DOFstatic = np.arange(nbRBE) #for final mapping of boundary coordinates; 
+                modeBasis[np.ix_(DOFb,DOFstatic)] = Tall
+                if verboseTimer: print("factorize Kii... "); start_time = time.time()
+                if useSparseSolver: 
+                    invKii = factorized(Kii.tocsc()) #factorized expects csc format, otherwise warning
+                    KiiInvKibTall = invKii(-(Kib @ Tall)) #(Kib @ Tall) gives already dense matrix; may be huge ...!
+                else:
+                    KiiInvKibTall = -np.linalg.inv(Kii) @ (Kib @ Tall)
+                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
+    
+                modeBasis[np.ix_(DOFi,DOFstatic)] = KiiInvKibTall #KiiInvKib @ Tall
+    
+            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+            #advanced case: modes average motion at boundary; may not be desired, but does not add additional stiffening
+            elif computationMode == HCBstaticModeSelection.RBE3:
+                from scipy.linalg import svd
+                
+                rbSize = 3 + 3*addRotationModes #size of rigid body coordinates (3 for translation, 6 for translation+rotation)
+                nbRBE = (nNodeLists-int(excludeRigidBodyMotion))*rbSize #number of chosen static modes, 6 DOF per rigid body interface; exclude first rigid body boundary in order to suppress rigid body motion of static modes
+                dim3D =3 #3D displacement nodes
+    
+                modeBasis = np.zeros((n, nbRBE+nEigenModes))
+                
+                #create list of mappings between average rigid body motion and boundary DOF matrix
+                # rigidBodyMappings = [[]]*nNodeLists #list of mappings
+                modesRBE3 = [[]]*nNodeLists
+                #%%
+                from scipy import sparse
+                Knew = sparse.bmat([[Kbb,Kbi],[Kib, Kii]])
+                
+                bNodesCnt = 0
+                bNodesCntList = [bNodesCnt] #this list contains start and end indices of number of boundary nodes
+                for boundaryNodes in boundaryNodesList:
+                    bNodesCnt += len(boundaryNodes)
+                    bNodesCntList += [bNodesCnt]
+    
+                # print('boundaryNodesList =',boundaryNodesList )
+                # print('bNodesCntList =',bNodesCntList )
+    
+                Cmat = np.zeros((nNodeLists*rbSize, n)) #Constraint matrix
+                unitForces = []
+                
+                ClocalList = []
+                
+                for k, boundaryNodes in enumerate(boundaryNodesList):
+                    # print('********\nboundary ',k,':\n********')
+                    nPrev = bNodesCntList[k]
+                    nn = len(boundaryNodes)
+                    p0 = boundaryNodesMidPoints[k]
+    
+                    W=np.zeros((dim3D,dim3D)) #compute weighting ('inertia') for rotation part
+                    if addRotationModes:
+                        Clocal = np.zeros((rbSize, nn*dim3D))
+                        for j in range(len(boundaryNodes)):
+                            p = nodesPos[boundaryNodes[j]]-p0
+                            pRot = Skew(p)
+    
+                            #Cnode = BNWlist[k][j]*block_diag(np.eye(dim3D), pRot)
+                            Cnode = BNWlist[k][j]*np.vstack((np.eye(dim3D), pRot))
+                            Clocal[:,j*dim3D:(j+1)*dim3D] = Cnode
+                            
+                            if RBE3secondMomentOfAreaWeighting:
+                                W += -BNWlist[k][j]*pRot@pRot
+                            else:
+                                W += BNWlist[k][j]*(np.linalg.norm(p)**2)*np.eye(3) #could be easier to just sum up terms, but for consistency, it is also computed as matrix
+    
+                        WposRot = block_diag(np.eye(dim3D), W)
+                        WposRotInv = np.eye(6) #old mode
+                        #WposRotInv = np.linalg.inv(WposRot) #not necessary / does not influence results!
+                        
+                        Clocal = WposRotInv @ Clocal
+                        unitForces += [WposRotInv @ WposRot]
+                        #print('unit Forces=', unitForces)
+                        #print('W=', W)
+                        
+    
+                    else:
+                        unitForces += [np.eye(dim3D)]
+                        Clocal = np.kron(BNWlist[k],np.eye(dim3D)) #maps rigid body motion of interface to all boundary nodes
+                    
+                    ClocalList += [Clocal]
+    
+    
+                    Cmat[k*rbSize:(k+1)*rbSize, nPrev*dim3D:(nPrev+nn)*dim3D] = Clocal
+    
+                    
+                #==> now Cmat contains the constraint jacobian                
+                # print('Knew=',Knew.shape)
+                # print('Cmat=',Cmat.shape)
+    
+                #stiffness matrix + constraints:
+                KC = sparse.bmat([[Knew,Cmat.T],[Cmat, None]])
+                #print('KC=',KC.shape)
+                if verboseTimer: print("factorize KC... "); start_time = time.time()
+                invKC = factorized(KC.tocsc()) #factorized expects csc format, otherwise warning
+                if verboseTimer: print("   ... needed %.3f seconds" % (time.time() - start_time))
+                
+                fUnit = np.zeros((n + nNodeLists*rbSize, rbSize)) #prescribed displacements
+                        
+                for k, boundaryNodes in enumerate(boundaryNodesList):
+                
+                    #add unit displacements at constraint equations side:
+                    fUnit *= 0
+                    #fUnit[n + k*rbSize:n + (k+1)*rbSize, :] = len(boundaryNodes)*np.eye(rbSize) #prescribed average unit displacemnets/rotations for boundary
+                    fUnit[n + k*rbSize:n + (k+1)*rbSize, :] = unitForces[k] #prescribed average unit displacemnets/rotations for boundary
+                    modesWithC = invKC(fUnit) 
+                    modes = modesWithC [:n,:]
+                    if verboseMode: print('max displacement=', np.amax(modes))
+    
+                    maxDisplacement = np.amax(modes)
+                    if maxDisplacement == 0: #should not occur
+                        maxDisplacement = 1
+                    
+                    modesRBE3[k] = (1/maxDisplacement)*modes #exclude solution for Lagrange multipliers
+                    
+                                
+                allModes = np.hstack(tuple(modesRBE3[int(excludeRigidBodyMotion):])) 
+                #print('allModes=',allModes.shape)
+                DOFstatic = np.arange(nbRBE) #for final mapping of boundary coordinates; 
+    
+                modeBasis[np.ix_(DOFb,DOFstatic)] = allModes[0:nb,:]
+                modeBasis[np.ix_(DOFi,DOFstatic)] = allModes[nb:,:]
+    
+    
+                #+++++++++++++++++++++++++++++++++++++
+                #now compute special RBE3 eigenmodes:
+                rigidBoundaries = False
+                if nEigenModes != 0: #otherwise, nothing to be done!
+                    if rigidBoundaries:
+                        [eigVals, eigVecs] = eigsh(A=Kii, k=nEigenModes, M=Mii, 
+                                                   which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
+                        # print('eigValues RBE2=', 0.5/pi*np.sqrt(eigVals))
+            
+                        DOFeig = np.arange(nbRBE,nbRBE+nEigenModes) #for final mapping of eigenmode coordinates
+                        modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
+                    if not rigidBoundaries:
+                        #singular value decomposition needs to be done PER BOUNDARY!
+                        
+                        rowsC = nNodeLists*rbSize
+                        nbReduced = nb-rowsC
+                        VlocalList = []
+                        for i, Clocal in enumerate(ClocalList):
+                            [U, s, V] = svd(Clocal)
+                            #VlocalList += [V[:-rbSize,:]]
+                            VlocalList += [V[rbSize:,:]]
+                        
+                            if np.amin(s) / np.amax(s) < 1e-8:
+                                print('************\nWARNING: ComputeHurtyCraigBamptonModes: expected '+str(rowsC) +
+                                      ' singular values, but some values are smaller than a threshold of 1e-8; check boundary nodes and mesh and \n************')
+                                #print('singular values=',s)
+                        
+                        V1 = block_diag(*VlocalList)
+                               
+                        # print('rowsC=',rowsC)
+                        # print('nb=',nb)
+                        # print('nbReduced=',nbReduced)
+                        # print('Kbb=',Kbb.shape)
+                        # print('Kbi=',Kbi.shape)
+                        # print('V=',V.shape)
+                        # print('U=',U.shape)
+                        # print('V1=',V1.shape)
+                        
+                        #compute reduced size matrices (just 6 columns/rows less per boundary/interface)
+                        KbbV = V1 @ Kbb @ V1.T
+                        KbiV = V1 @ Kbi
+                        KibV = Kib @ V1.T
+        
+                        MbbV = V1 @ Mbb @ V1.T
+                        MbiV = V1 @ Mbi
+                        MibV = Mib @ V1.T
+                        
+                        Knew = sparse.bmat([[KbbV,KbiV],[KibV, Kii]])
+                        Mnew = sparse.bmat([[MbbV,MbiV],[MibV, Mii]])
+                        # print('Knew=',Knew.shape)
+                        # print('Mnew=',Mnew.shape)
+                        
+                        [eigVals, eigVecs] = eigsh(A=Knew, k=nEigenModes, M=Mnew, 
+                                                   which='LM', sigma=0, mode='normal') #try modes 'normal','buckling' and 'cayley'
+                        # print('eigValues RBE3=', 0.5/pi*np.sqrt(eigVals))
+                        eigVecsB = eigVecs[0:nbReduced,:] 
+                        eigVecsI = eigVecs[nbReduced:,:] 
+                        # print('eigVecsB=',eigVecsB.shape)
+                        eigVecsB = V1.T @ eigVecsB #project into original unconstrained space ...
+                        eigVecs = np.vstack((eigVecsB, eigVecsI))
+            
+                        DOFeig = np.arange(nbRBE,nbRBE+nEigenModes) #for final mapping of eigenmode coordinates
+                        modeBasis[np.ix_(list(DOFb)+list(DOFi),DOFeig)] = eigVecs[:,:nEigenModes]
+                    
+            #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+    
+            elif computationMode == HCBstaticModeSelection.onlyEigenModes: #only eigen modes, e.g., for testing
+                if nEigenModes != 0:
+                    raise ValueError('ComputeHurtyCraigBamptonModes: in computationMode onlyEigenModes, nEigenModes must be != 0')
+    
+                modeBasis = np.zeros((n, nEigenModes))
+                DOFeig = np.arange(nEigenModes) #for final mapping of eigenmode coordinates
+                modeBasis[np.ix_(DOFi,DOFeig)] = eigVecs[:,:nEigenModes]
+            
+            if modeBasis.shape[1] == 0:
+                print('************\nWARNING: ComputeHurtyCraigBamptonModes computed 0 modes, check boundaryNodesList and settings\n************')
+           
+            self.modeBasis = {'matrix':modeBasis, 'type':'HCBmodes'}
+            if nEigenModes != 0:
+                self.eigenValues = abs(eigVals)
+            else:
+                self.eigenValues = np.array([])
+    
+        else:
+            [eigVals, eigVecs] = eigh(K,M) #this gives omega^2 ... squared eigen frequencies (rad/s)
+            self.modeBasis = {'matrix':eigVecs[:,0:nEigenModes], 'type':'NormalModes'}
+            self.eigenValues = abs(eigVals)
+
+
+
+
+    #**classFunction: return list of eigenvalues in Hz of previously computed eigenmodes
+    def GetEigenFrequenciesHz(self):
+        return np.sqrt(self.eigenValues)/(2.*np.pi)
+
+    #internal function for ComputePostProcessingModes, do not call from outside FEM
+    def InternalComputePostprocessingMode(self,parameterList):
+        #map list of parameters to internal variables (due to multiprocessing)
+        iMode = parameterList[0]
+        nodes = parameterList[1]
+        modes = parameterList[2]
+        elemList = parameterList[3]
+        material = parameterList[4]
+        computeStrains = parameterList[5]
+        
+        nNodes = len(nodes)
+        nodesPerTet = 4
+        elemRefCoords = np.zeros(nodesPerTet*3)
+        displacements = np.zeros(nodesPerTet*3)
+        stressModesCnt = np.zeros(nNodes) #store how many elements contribute to nodal stress (for averaging)
+
+        stressModesMatrix = np.zeros((nNodes, 6)) #add up nodal stresses in this 6 modes for sigma_xx, sigma_yy, etc.
+        for elem in elemList:
+            for cnt in range(len(elem)):
+                ind = elem[cnt]
+                elemRefCoords[cnt*3:cnt*3+3] = nodes[ind,:]
+                displacements[cnt*3:cnt*3+3] = modes[ind*3:ind*3+3,iMode]
+                
+            tet=Tet4(material) #all material is the same ...
+            [Ev4, Sv4, B0, grad]=tet.ComputeMatrices(elemRefCoords, displacements)
+
+            #now write stresses into stress modes
+            for cnt in range(4): #number of nodes per element
+                ind = elem[cnt]  #node index
+                #if iMode == 0: #count how often nodes need to be averaged (count only for first mode)
+                stressModesCnt[ind] += 1
+                for j in range(6): #6 components
+                    if computeStrains:
+                        stressModesMatrix[ind,j] += Ev4[cnt, j]
+                    else:
+                        stressModesMatrix[ind,j] += Sv4[cnt, j]
+        nodeWarned = False
+        for ind in range(nNodes):
+            elPerNode = stressModesCnt[ind]
+            if elPerNode == 0:
+                if not nodeWarned:
+                    nodeWarned = True
+                    print('********\nWARNING:\n********\n Compute stress/strain modes: averaging of stress/strain at nodes failed, because node not connected to elements; this function only works for linear elements!')
+                elPerNode = 1 #does not matter because no element attached, no stress computed
+            stressModesMatrix[ind,:] *= 1/elPerNode
+
+        return stressModesMatrix
+
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute special stress or strain modes in order to enable visualization of stresses and strains in ObjectFFRFreducedOrder;
+    #**input: 
+    #  material: specify material properties for computation of stresses, using a material class, e.g. material = KirchhoffMaterial(Emodulus, nu, rho); not needed for strains
+    #  outputVariableType: specify either exudyn.OutputVariableType.StressLocal or exudyn.OutputVariableType.StrainLocal as the desired output variables
+    #  numberOfThreads: if numberOfThreads=1, it uses single threaded computation; if numberOfThreads>1, it uses the multiprocessing pools functionality, which requires that all code in your main file must be encapsulated within an if clause "if \_\_name\_\_ == '\_\_main\_\_':", see examples; if numberOfThreads==-1, it uses all threads/CPUs available
+    #**notes: This function is implemented in Python and rather slow for larger meshes; for NGsolve / Netgen meshes, see the according ComputePostProcessingModesNGsolve function, which is usually much faster
+    #**output: post processing modes are stored in FEMinterface in local variable postProcessingModes as a dictionary, where 'matrix' represents the modes and 'outputVariableType' stores the type of mode as a OutputVariableType
+    def ComputePostProcessingModes(self, material=0, 
+                                   outputVariableType='OutputVariableType.StressLocal',
+                                   numberOfThreads=1):
+        #import exudyn as exu #needed for outputVariableType
+
+        if str(outputVariableType) == 'OutputVariableType.StressLocal':
+            computeStrains = False
+        elif str(outputVariableType) == 'OutputVariableType.StrainLocal':
+            computeStrains = True
+        else:
+            raise ValueError('ComputePostProcessingModes invoked with invalid outputVariableType')
+            
+        nodes = self.nodes['Position']
+        nNodes = len(nodes)
+        if len(self.elements) != 1:
+            raise ValueError('ComputePostProcessingModes(...): only implemented for FEMinterface with one list of elements')
+        if 'Tet4' not in self.elements[0]:
+            raise ValueError('ComputePostProcessingModes(...): only implemented for Tet4 elements')
+        if 'matrix' not in self.modeBasis:
+            raise ValueError('ComputePostProcessingModes(...): modeBasis needs to be computed in FEMinterface prior to calling ComputePostProcessingModes; use e.g. ComputeEigenmodes(...)')
+            
+        elemList = self.elements[0]['Tet4']
+        modes = self.modeBasis['matrix']
+        nModes = modes.shape[1]
+        stressModes = np.zeros((nNodes, 6*nModes)) #add up nodal stresses
+
+        if material == 0:
+            material=KirchhoffMaterial(1, 0, 1)
+            if not computeStrains:
+                raise ValueError('ComputePostProcessingModes: if material=0, outputVariableType must be StrainLocal')
+
+        showProgress = False
+        if nModes*nNodes > 10000:
+            showProgress = True
+            #print("")
+
+        #create vectorized input data for ComputePostprocessingMode
+        vectorInput = [[]]*nModes
+        for i in range(nModes):
+            vectorInput[i] = [i,nodes, modes, elemList, material, computeStrains]
+            
+
+        useSingleThreading = True
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        if numberOfThreads > 1 or numberOfThreads == -1:
+            try:
+                from multiprocessing import Pool, cpu_count #parallelization of computation
+                if numberOfThreads == -1:
+                    numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
+                useSingleThreading = False
+            except:
+                pass
+            if not useSingleThreading:
+                vectorInput = np.array(vectorInput)
+                
+                useTQDM = False
+                if showProgress:
+                    try:
+                        import tqdm #progress bar
+                        try: #_instances only available after first run!
+                            tqdm.tqdm._instances.clear() #if open instances of tqdm, which leads to nasty newline
+                        except:
+                            pass
+                        useTQDM = True
+                        print("useTQDM")
+                    except:
+                        pass
+                
+                if useTQDM:
+                    with Pool(processes=numberOfThreads) as p:
+                        values = list(tqdm.tqdm(p.imap(self.InternalComputePostprocessingMode, vectorInput), 
+                                                total=nModes))
+                    print("", flush=True) #newline after tqdm progress bar output....
+                else:
+                    # simpler approach without tqdm:
+                    with Pool(processes=numberOfThreads) as p:
+                        values = p.map(self.InternalComputePostprocessingMode, vectorInput)
+
+                for iMode in range(nModes):
+                    stressModes[:,6*iMode:6*iMode+6] = values[iMode]
+                
+            
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        if useSingleThreading:
+            for iMode in range(nModes):
+                stressModeMatrix = self.InternalComputePostprocessingMode(vectorInput[iMode])
+                stressModes[:,6*iMode:6*iMode+6] = stressModeMatrix
+                
+                if showProgress:
+                    print("\rComputePostProcessingModes: " + str(iMode/nModes*100) + str("%"),end='', flush=True)
+
+            if showProgress:
+                print("") #line break finally
+
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+        self.postProcessingModes = {'matrix': stressModes, 
+                                    'outputVariableType': outputVariableType}
+        
+        #self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: compute Campbell diagram for given mechanical system
+    #create a first order system Axd + Bx = 0 with x= [q,qd]' and compute eigenvalues
+    #takes mass M, stiffness K and gyroscopic matrix G from FEMinterface
+    #currently only uses dense matrices, so it is limited to approx. 5000 unknowns!
+    #**input:
+    #  terminalFrequency: frequency in Hz, up to which the campbell diagram is computed
+    #  nEigenfrequencies: gives the number of computed eigenfrequencies(modes), in addition to the rigid body mode 0
+    #  frequencySteps: gives the number of increments (gives frequencySteps+1 total points in campbell diagram)
+    #  rotationAxis:[0,1,2] = [x,y,z] provides rotation axis
+    #  plotDiagram: if True, plots diagram for nEigenfrequencies befor terminating
+    #  verbose: if True, shows progress of computation; if verbose=2, prints also eigenfrequencies
+    #  useCorotationalFrame: if False, the classic rotor dynamics formulation for rotationally-symmetric rotors is used, where the rotor can be understood in a Lagrangian-Eulerian manner: the rotation is represented by an additional (Eulerian) velocity in rotation direction; if True, the corotational frame is used, which gives a factor 2 in the gyroscopic matrix and can be used for non-symmetric rotors as well
+    #  useSparseSolver: for larger systems, the sparse solver needs to be used for creation of system matrices and for the eigenvalue solver (uses a random number generator internally in ARPACK, therefore, results are not fully repeatable!!!)
+    #**output: [listFrequencies, campbellFrequencies]
+    #  listFrequencies: list of computed frequencies
+    #  campbellFrequencies: array of campbell frequencies per eigenfrequency of system
+    def ComputeCampbellDiagram(self, terminalFrequency, nEigenfrequencies=10, frequencySteps=25, 
+                               rotationAxis=2, plotDiagram=False, verbose=False, 
+                               useCorotationalFrame=False, useSparseSolver=False):
+        from scipy.linalg import eig #eigh for symmetric matrices, positive definite
+        
+        #create gyroscopic terms
+#        X=np.array([[ 0., -1.,  0.],
+#                    [ 1.,  0.,  0.],
+#                    [ 0.,  0.,  0.]])
+#        xBlock = np.kron(np.eye(nNodes), X) #create big block-diagonal matrix
+#        G=np.dot(xBlock,M)
+        
+        if self.NumberOfCoordinates() > 1000 and useSparseSolver == False:
+            print('WARNING: ComputeCampbellDiagram(...): system has more than 1000 coordinates, set useSparseSolver=True')
+            if self.NumberOfCoordinates() > 5000:
+                raise ValueError('ComputeCampbellDiagram(...): system has more than 5000 coordinates, MUST set useSparseSolver=True')
+
+        #dense matrix version:
+        if not useSparseSolver:        
+            M = self.GetMassMatrix(sparse=False)
+            K = self.GetStiffnessMatrix(sparse=False)
+            G = self.GetGyroscopicMatrix(rotationAxis=rotationAxis, sparse=False)
+    
+            #create system:
+            #A*x_t + B*x=0
+            nODE = self.NumberOfCoordinates()
+            B = np.block([[                    K, np.zeros((nODE,nODE))],
+                          [np.zeros((nODE,nODE)), -M                   ]])
+        
+            factorGyro = 1
+            if useCorotationalFrame:
+                factorGyro = 2 #this is the only difference to between fixed and corotational frame
+    #        terminalFrequencyCampbell = 2*np.pi*225 #rad/s
+            campbellFrequencies = []
+            listFrequencies = []
+    
+            for val in range(frequencySteps+1):
+                
+                omega = val * terminalFrequency * 2*np.pi / frequencySteps
+                if verbose:
+                    print("compute Campbell for frequency =", round(omega/(2*np.pi),3), " / ", terminalFrequency, '(Hz)')
+
+                if True:
+                    A = np.block([[factorGyro*omega * G, M                    ],
+                                  [                   M, np.zeros((nODE,nODE))]])
+            
+                
+                    Amod = -np.dot(np.linalg.inv(A),B)
+                
+                else:
+                    Minv = np.linalg.inv(M)
+                    #alternative approach:
+                    Amod = np.block([[np.zeros((nODE,nODE)),  np.eye(nODE) ],
+                                     [              -Minv@K, -Minv@(factorGyro*omega * G)]])
+                    
+                
+                #print("Amod =", Amod)
+                [eigVals, eigVecs] = eig(Amod) #this gives omega^2 ... squared eigen frequencies (rad/s)
+            
+                ev = np.sort(eigVals)
+            
+                listEigAbs = []
+                for i in range(len(ev)):
+                    v=abs(ev[i].imag/(2*np.pi))
+                    if not (v in listEigAbs):
+                        listEigAbs += [v]
+    
+                listEigAbs = np.sort(listEigAbs)
+                if verbose == 2:
+                    print('  frequencies =',listEigAbs[0:nEigenfrequencies+1])
+            
+                campbellFrequencies += [list(listEigAbs[0:nEigenfrequencies+1])] #+1 for rigid body mode 0
+                listFrequencies += [omega/(2*np.pi)]
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #SPARSE version:
+        else: 
+            from scipy import sparse
+            from scipy.sparse.linalg import eigs #, factorized
+            #[M, 0][q_tt] + [omega*G, 0] [q_t] = [0]
+            #[0, 0][q_t ] + [       , K] [q  ] = [0]
+ 
+            #M*d(q_t) + omega*G*q_t + K * q = 0
+            #d(q) = q_t
+            #d(q_t) = -Minv*(omega*G*q_t+K*q)
+            
+            #       [0      , I      ]
+            #d(x) = [                ] * x
+            #       [-Minv*K, -omega*Minv*G] 
+ 
+            M = CSRtoScipySparseCSR(self.GetMassMatrix(sparse=True))
+            K = CSRtoScipySparseCSR(self.GetStiffnessMatrix(sparse=True))
+            G = self.GetGyroscopicMatrix(rotationAxis=rotationAxis, sparse=True) #already in scypi sparse format
+    
+            nODE = self.NumberOfCoordinates()
+
+            # Minv = factorized(M.tocsc()) #factorized expects csc format, otherwise warning
+            # MinvK = sparse.csr_matrix(Minv(-K.toarray())) #slow, but no other way right now
+            # MinvG = sparse.csr_matrix(Minv((-G).toarray())) #this is for omega=1, multiplied with factor hereafter!
+
+            #twice as large mass-matrix:
+            M2 = sparse.bmat([[M   , None],
+                              [None, M   ]]) 
+            #M2inv = factorized(M2.tocsc()) 
+        
+            factorGyro = 1
+            if useCorotationalFrame:
+                factorGyro = 2 #this is the only difference to between fixed and corotational frame
+
+            campbellFrequencies = []
+            listFrequencies = []
+   
+            minNumberOfEigenvalues = 2*(nEigenfrequencies+1)
+    
+            for val in range(frequencySteps+1):
+                
+                omega = val * terminalFrequency * 2*np.pi / frequencySteps
+                if verbose:
+                    print("compute Campbell for frequency =", round(omega/(2*np.pi),3), " / ", terminalFrequency, '(Hz)')
+                # print('nEig:',nEigenfrequencies)
+                # A = sparse.bmat([[None , sparse.eye(nODE)        ],
+                #                  [MinvK, (factorGyro*omega)*MinvG]]) #in fact negative sign included in MinvK and MinvG!!!
+                
+                # [eigVals, eigVecs] = eigs(A=A, k=2*(nEigenfrequencies+1), #M=Mii, 
+                #                           which='LM', sigma=0)
+                A = sparse.bmat([[None , M        ],
+                                  [-K, -(factorGyro*omega)*G]]) #in fact negative sign included in MinvK and MinvG!!!
+                [eigVals, eigVecs] = eigs(A=A, k=2*(nEigenfrequencies+1), M=M2, #Minv=M2inv,
+                                          which='LM', sigma=0)
+            
+                ev = np.sort(eigVals)
+            
+                listEigAbs = []
+                for i in range(len(ev)):
+                    v=abs(ev[i].imag/(2*np.pi))
+                    if not (v in listEigAbs):
+                        listEigAbs += [v]
+    
+                listEigAbs = np.sort(listEigAbs)
+                if verbose == 2:
+                    print('  frequencies =',listEigAbs[0:nEigenfrequencies+1])
+            
+                minNumberOfEigenvalues = min(minNumberOfEigenvalues, len(listEigAbs))
+                campbellFrequencies += [list(listEigAbs[0:nEigenfrequencies+1])] #+1 for rigid body mode 0
+                    
+                listFrequencies += [omega/(2*np.pi)]
+
+            #sometimes there are several duplicated eigenvalues, therefore need to clean up...
+            cfClean = []
+            for freq in campbellFrequencies:
+                cfClean += [freq[0:minNumberOfEigenvalues]]
+            campbellFrequencies = cfClean
+            # print('minNumberOfEigenvalues=',minNumberOfEigenvalues)
+            #adjust in case that less results are available
+            nEigenfrequencies = min(nEigenfrequencies,minNumberOfEigenvalues-1)
+
+            
+        if plotDiagram:
+            import matplotlib.pyplot as plt
+            import matplotlib.ticker as ticker
+        
+            campbellFrequencies = np.array(campbellFrequencies)
+
+            nPlotFrequencies = nEigenfrequencies
+            if nEigenfrequencies > 27:
+                nPlotFrequencies = 27
+                print("only 27 eigenfrequencies can be plotted!")
+            
+            for i in range(nPlotFrequencies): #do not plot rigid body mode 0
+                plt.plot(listFrequencies, campbellFrequencies[:,i+1], PlotLineCode(i+1), label='freq '+str(i))
+
+            plt.plot(listFrequencies, listFrequencies, PlotLineCode(0), label='rotor speed (Hz)') 
+            
+            ax=plt.gca() # get current axes
+            ax.grid(True, 'major', 'both')
+            ax.xaxis.set_major_locator(ticker.MaxNLocator(10)) #use maximum of 8 ticks on y-axis
+            ax.yaxis.set_major_locator(ticker.MaxNLocator(10)) #use maximum of 8 ticks on y-axis
+            plt.xlabel("excitation / rotor frequency (Hz)")
+            plt.ylabel("eigen frequency (Hz)")
+            plt.tight_layout()
+            plt.legend()
+            plt.show() 
+
+        return [listFrequencies, campbellFrequencies]
+
+    #**classFunction: perform some consistency checks
+    def CheckConsistency(self):
+        nNodes = self.NumberOfNodes()
+        #nNodes = len(self.nodes['Position']) #old
+
+        if self.massMatrix.shape != (0,0):
+            (rows,columns) = CSRtoRowsAndColumns(self.massMatrix)
+            if rows != nNodes*3:
+                print("ERROR: CheckConsistency: massMatrix rows different from nodes coordinates dimension")
+            if columns != nNodes*3:
+                print("ERROR: CheckConsistency: massMatrix columns different from nodes coordinates dimension")
+
+        if self.stiffnessMatrix.shape != (0,0):
+            (rows,columns) = CSRtoRowsAndColumns(self.stiffnessMatrix)
+            if rows != nNodes*3:
+                print("ERROR: CheckConsistency: stiffnessMatrix rows different from nodes coordinates dimension")
+            if columns != nNodes*3:
+                print("ERROR: CheckConsistency: stiffnessMatrix columns different from nodes coordinates dimension")
+                
+
+    
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # Ansys    
+    
+    #**classFunction: read mass matrix from CSV format (exported from Ansys)
+    def ReadMassMatrixFromAnsys(self, fileName, dofMappingVectorFile, sparse=True, verbose=False):
+        if sparse:
+            self.massMatrix = ReadMatrixFromAnsysMMF(fileName, verbose)
+        else:
+            M = np.loadtxt(fileName,delimiter=',')
+            self.massMatrix = ConvertDenseToCompressedRowMatrix(M)
+
+        sorting = ReadMatrixDOFmappingVectorFromAnsysTxt(dofMappingVectorFile)
+        if len(sorting) < max(self.massMatrix[:,0]):
+            raise ValueError("ReadMassMatrixFromAnsys: dofMappingVectorFile and matrix size do not fit")
+
+        MapSparseMatrixIndices(self.massMatrix, sorting)
+
+    #**classFunction: read stiffness matrix from CSV format (exported from Ansys)
+    def ReadStiffnessMatrixFromAnsys(self, fileName, dofMappingVectorFile, sparse=True, verbose=False):
+        if sparse:
+            self.stiffnessMatrix = ReadMatrixFromAnsysMMF(fileName, verbose) 
+        else:
+            K = np.loadtxt(fileName,delimiter=',')
+            self.stiffnessMatrix = ConvertDenseToCompressedRowMatrix(K)
+
+        sorting = ReadMatrixDOFmappingVectorFromAnsysTxt(dofMappingVectorFile)
+        if len(sorting) < max(self.stiffnessMatrix[:,0]):
+            raise ValueError("ReadStiffnessMatrixFromAnsys: dofMappingVectorFile and matrix size do not fit")
+
+        MapSparseMatrixIndices(self.stiffnessMatrix, sorting)
+                    
+    #**classFunction: read nodal coordinates (exported from Ansys as .txt-File)
+    def ReadNodalCoordinatesFromAnsys(self, fileName, verbose=False):
+        nodes = ReadNodalCoordinatesFromAnsysTxt(fileName, verbose)
+        self.nodes['Position'] = np.array(nodes)
+        
+    #**classFunction: read elements (exported from Ansys as .txt-File)
+    def ReadElementsFromAnsys(self, fileName, verbose=False):
+        self.elements += [ReadElementsFromAnsysTxt(fileName, verbose)]
+        self.VolumeToSurfaceElements() #generate surface elements
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

## exudyn/GUI.py

```diff
@@ -1,1000 +1,1000 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# File:     Exudyn GUI helper files (Tkinter)
-#
-# Details:  Helper functions and classes for graphical interaction with Exudyn
-#
-# Author:   Johannes Gerstmayr
-# Date:     2020-01-25
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-# Notes:    This is an internal library, which is only used inside Exudyn for modifying settings.
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import tkinter as tk
-import tkinter.messagebox
-import tkinter.ttk as ttk
-import tkinter.font as tkFont
-import numpy as np #for array checks
-from numpy import float32
-import ast #for ast.literal_eval
-import sys
-import exudyn
-
-useRenderWindowDisplayScaling = True #using this, scaling will change with render window
-
-treeviewDefaultFontSize = 9 #this is then scaled; but it could be changed to make fonts smaller
-textHeightFactor = 1.45 #this is the factor between font size and text height; larger values leading to more space between lines
-
-treeEditDefaultWidth = 1024     #unscaled width of e.g. visualizationSettings
-treeEditDefaultHeight = 800     #unscaled height of e.g. visualizationSettings
-treeEditMaxInitialHeight = 1440 #larger height, if screen resolution admits
-dialogDefaultWidth = 800        #unscaled width of e.g. right mouse edit
-dialogDefaultHeight = 600       #unscaled height of e.g. right mouse edit
-treeEditOpenItems = ['bodies','connectors','nodes','general'] #these items are opened at the beginning
-
-def IsApple():
-    if sys.platform == 'darwin':
-        return True
-    else:
-        return False
-
-def GetRendererSystemContainer():
-    try:
-        if 'currentRendererSystemContainer' in exudyn.sys: 
-            guiSC = exudyn.sys['currentRendererSystemContainer']
-            if guiSC != 0 and type(guiSC) == exudyn.SystemContainer:
-                return guiSC
-    except: 
-        pass
-    return None
-
-#**function: get new or current root and new window app; return list of [tkRoot, tkWindow, tkRuns]
-def GetTkRootAndNewWindow():
-    if tk._default_root == None:
-        root = tk.Tk()
-        tkWindow = root
-        tkRuns = False
-    else:
-        root = tk._default_root
-        tkWindow = tk.Toplevel(root)
-        tkRuns = True
-    return [root, tkWindow, tkRuns]
-
-#**function: this function returns True, if tkinter has already a root window (which is assumed to have already a mainloop running)
-def TkRootExists():
-    return (tk._default_root != None)
-
-
-
-#unique text height for tk with given scaling
-def TkTextHeight(systemScaling):
-    #OLD, without     style.configure("Treeview", font=(None, treeviewDefaultFontSize ) ):
-    #return int(13*systemScaling) #must be int; 13 is good; 16 is too big on surface
-    
-    return int((treeviewDefaultFontSize*textHeightFactor)*systemScaling) #must be int; 13 is good with treeviewDefaultFontSize = 9; 12 leads to some cuts of 'g'
-
-#check if is float:
-def IsFloat(v):
-    try:
-        float(v)
-    except ValueError:
-        return False
-    return True
-
-#check if converts to numpy array
-def IsArrayInt(v):
-    try:
-        np.fromstring(v,dtype=int,sep=',') #frombuffer does not work!
-    except ValueError:
-        return False
-    return True
-    
-def IsVector(v):
-    try:
-        np.fromstring(v,dtype=float,sep=',') #frombuffer does not work!
-    except ValueError:
-        return False
-    return True
-
-#safely request scaling factor from exudyn
-def GetExudynDisplayScaling():
-    try:
-        if 'currentRendererSystemContainer' in exudyn.sys: 
-            guiSC = exudyn.sys['currentRendererSystemContainer']
-            if guiSC != 0: #this would mean that renderer is detached
-                rs = guiSC.GetRenderState()
-                #print('return render state')
-                return rs['displayScaling']
-        
-        return 1
-
-    except: 
-        #print('except!')
-        return 1
-
-#return either exudyn or tkinter scaling, unified approach
-def GetGUIContentScaling(root):
-    try:
-        if useRenderWindowDisplayScaling: #would also work under linux
-            #print('exudyn scaling      =',GetExudynDisplayScaling())
-            #print('tkinter scaling(OLD)=',root.tk.call('tk', 'scaling'))
-            s = 1.4*GetExudynDisplayScaling() #gives similar size as other programs; factor 1.4 is empirical
-            root.tk.call('tk', 'scaling', s) #needed to update font size internally ...
-            #print('tkinter scaling(NEW)=',root.tk.call('tk', 'scaling'))
-            return s
-        else:
-            return root.tk.call('tk', 'scaling') #obtains current scaling?
-    except:
-        return 1
-    
-#create dictionaries for lists in combo box: bool, OutputVariableType, ...
-def GetComboBoxListsDict(exu = None):
-    d=dict()  #as string
-    dT=dict() #as type
-    
-    if exu != None: #exudyn loaded
-        listOfTypes = []
-        listOfTypesT = []
-        dTypes = exu.OutputVariableType.__members__
-        for i in dTypes: 
-            listOfTypes+=[str(dTypes[i])]
-            listOfTypesT+=[dTypes[i]]
-        d['OutputVariableType'] = listOfTypes
-        dT['OutputVariableType'] = listOfTypesT
-
-        
-        listOfTypes = []
-        listOfTypesT = []
-        dTypes = exu.LinearSolverType.__members__
-        for i in dTypes: 
-            listOfTypes+=[str(dTypes[i])]
-            listOfTypesT+=[dTypes[i]]
-        d['LinearSolverType'] = listOfTypes
-        dT['LinearSolverType'] = listOfTypesT
-
-        listOfTypes = []
-        listOfTypesT = []
-        dTypes = exu.ItemType.__members__
-        for i in dTypes: 
-            listOfTypes+=[str(dTypes[i])]
-            listOfTypesT+=[dTypes[i]]
-        d['ItemType'] = listOfTypes
-        dT['ItemType'] = listOfTypesT
-
-    else:
-        print('WARNING: exudyn not loaded as "exu"')
-
-    #d['bool'] = ['True','False']
-    dT['bool'] = [True, False]
-    return dT
-    
-#convert string into exudyn type
-def ConvertString2Value(value, vType, vSize, dictionaryTypesT):
-    errorMsg = ''
-    if vType == 'FileName' or vType == 'String':
-        return [value, errorMsg]
-
-    if vType == 'bool':
-        if value == 'True':
-            return [True, errorMsg]
-        else:
-            return [False, errorMsg]
-
-    if (vType == 'float' 
-        or vType == 'PReal' or vType == 'UReal' or vType == 'Real'
-        or vType == 'PFloat' or vType == 'UFloat'):
-        floatValue = float(value)
-        if vType == 'PReal' and floatValue <= 0:
-                errorMsg = 'PReal must be > 0'
-        if vType == 'UReal' and floatValue < 0:
-                errorMsg = 'UReal must be >= 0'
-        if vType == 'PFloat' and floatValue <= 0:
-                errorMsg = 'PFloat must be > 0'
-        if vType == 'UFloat' and floatValue < 0:
-                errorMsg = 'UFloat must be >= 0'
-        
-        return [float(value), errorMsg]
-
-    if vType == 'Index' or vType == 'Int' or vType == 'PInt' or vType == 'UInt':
-        intValue = int(value)
-
-        if vType == 'Index' or vType == 'UInt':
-            if intValue < 0:
-                errorMsg = 'UInt must be >= 0'
-
-        if vType == 'PInt':
-            if intValue <= 0:
-                errorMsg = 'PInt must be > 0'
-                
-        return [intValue, errorMsg]
-
-#    print('vType=',vType)
-#    print('value=',value)
-    
-    if vType in dictionaryTypesT:#search for correct type in list
-        for iValue in dictionaryTypesT[vType]:
-            if str(iValue) == value:
-                return [iValue, errorMsg]
-
-    if (len(vSize) == 2 or                      #must be matrix
-        (len(vSize)==1 and vSize[0] > 1) or     #must be vector with fixed size
-        (len(vSize)==1 and vSize[0] == -1) ):   #array / vector with undefined size
-        return [ast.literal_eval(value), errorMsg]
-
-    #print("Error in ConvertString2Value: unknown type",vType, "value=", value)
-    return [0, 'unknown type '+vType]
-
-#convert values to string; special treatment of floats (C++ float, single precision)
-def ConvertValue2String(value, vType, vSize):
-    if (len(vSize)==1 and vSize[0] == 1 and #special treatment for conversion with according number of digits!
-        (  vType == 'float'
-        or vType == 'PFloat'
-        or vType == 'UFloat'
-        )):
-        return str(float32(value))
-    #elif len(vSize)==1 and vType == 'VectorFloat':
-    elif vType == 'VectorFloat' or vType == 'MatrixFloat': #special treatment for conversion with according number of digits!
-        #return str(np.array(value,dtype=float32).tolist()) #still produces float64 converted numbers
-        return str(np.array(value,dtype=float32).astype(str).tolist()).replace("'","") #workaround to produce single-precition numbers ...
-    return str(value)
-
-#check if a valueStr corresponds to correct type and size; return True, if correct; False if type incorrect
-#returns [isValid, errorMSG]
-#isValid=True: everything is ok
-def CheckType(valueStr, vType, vSize):
-#    print('str=',valueStr)
-    
-    validFileNameChar = " `'{}()%&-@#$~!_^./\\"
-    
-#    if vType == 'bool':
-#        if valueStr=='False' or valueStr=='True':
-#            return [True, '']
-#        else:
-#            return [False, 'bool may only be True or False']
-
-    if vType == 'FileName':
-        if len(valueStr) == 0 or valueStr[0]==' ': #space at first position may be possible on file systems, but is not recommended
-            return [False, 'filename may neither be empty nor begin with a SPACE character']
-        for x in valueStr: #this is inefficient but should not delay too much
-            if not ((x in validFileNameChar)  or x.isalpha() or x.isnumeric()):
-                #print('(x in validFileNameChar)=',(x in validFileNameChar),',x.isalpha()=',x.isalpha(),',x.isnumeric()=',x.isnumeric())
-                return [False, 'invalid character in file name: may only be A-Z, a-z, 0-9, "'+validFileNameChar +'"']
-        return [True, '']
-
-    if vType == 'String':
-        return [True, '']
-    if vType == 'float':
-        #print('float=',IsFloat(valueStr))
-        rv = IsFloat(valueStr)
-        if rv:
-            return [True, '']
-        else:
-            return [False, 'invalid float number']
-    if vType == 'Index' and not valueStr.isdigit():
-        return [False, 'invalid integer (must be positive)']
-    
-    #Now check vectors, matrices, ...: try if value can be converted ...
-    x=[0]
-    try:
-        #s = 'global x\nx='+str(valueStr) + '\nprint(x)'
-        s = 'locx='+str(valueStr)# + '\nprint(x)'
-        mylocals={'locx':[]}
-        exec(s,globals(),mylocals)
-        x=mylocals['locx']
-        #print('mylocals=',mylocals)
-    except:
-        #print("entered text does not comply with the value's type")
-        return [False, 'invalid array or matrix: check brackets and types']
-
-    #print('x=',x)
-    
-    if len(vSize) == 1 and vSize[0] > 1: #vector/array
-        if len(x) != vSize[0]:
-            return [False, 'vector/array must have length '+str(vSize[0])]
-        
-        if vType == 'IndexArray':
-            for i in x:
-                if int(i) != i or i < 0: #not an integer
-                    return [False, 'array values must be positive integer (including 0)']
-    if len(vSize) == 2:
-        if len(x) != vSize[0]:
-            return [False, 'matrix must have '+str(vSize[0]) + ' rows']
-        for row in x:
-            if len(row) != vSize[1]:
-                return [False, 'matrix must have '+str(vSize[1]) + ' columns']
-    
-    return [True, '']
-
-#this class gets a dictionary with type information structure in, but a plain dictionary with types (int, float, string, list, ...) out
-#settingsStructure: contains hierarchical settings structure with function GetDictionaryWithTypeInfo() to obtain dictionary for editing
-#dictionaryTypes: contains a dictionary with the available types, e.g. bool, etc.
-#updateOnChange: every change is directly applied to the settingsStructure and redraw is signaled in stored renderer
-class TkinterEditDictionaryWithTypeInfo(tk.Frame):
-    def __init__(self, parent, settingsStructure, dictionaryTypesT, updateOnChange=False, treeOpen=False, textHeight = 15):
-        tk.Frame.__init__(self, parent)
-        
-        self.parentFrame = parent #parent frame stored for member functions
-        self.settingsStructure = settingsStructure
-        self.dictionaryTypesT = dictionaryTypesT #as type
-        self.updateOnChange = updateOnChange
-        self.treeOpen = treeOpen
-        self.textHeight = textHeight
-
-        self.dictionaryData = settingsStructure.GetDictionaryWithTypeInfo()
-
-        #additional storage for type, size, etc.
-        self.typeStorage = dict() #dictionary is stored as {'ID1': 'type1', 'ID2': 'type2', ...}
-        self.sizeStorage = dict()
-        self.descriptionStorage = dict()
-
-        #create treeview:
-        self.tree = ttk.Treeview(self, columns=("value","description"), selectmode='browse', height=self.textHeight)
-        self.vertivalScrollbar = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
-        self.tree.configure(yscrollcommand=self.vertivalScrollbar.set)
-
-        self.tree.grid(row=0, column=0, columnspan=3, sticky="nsew")
-        self.vertivalScrollbar.grid(row=0, column=3, sticky='nse')
-        self.vertivalScrollbar.configure(command=self.tree.yview)
-
-
-        self.grid_rowconfigure(0, weight=1)
-        self.grid_columnconfigure(0,weight=1)
-        self.grid_columnconfigure(1,weight=2)
-        self.grid_columnconfigure(2,weight=2)
-        self.grid_columnconfigure(3,weight=0)
-        
-        self.tree.heading("#0",text="Name",anchor=tk.W)
-        self.tree.heading("value",text="Value",anchor=tk.W)
-        self.tree.heading("description",text="Description (press H to show)",anchor=tk.W)
-
-
-        self.AddNodeFromDictionaryWithTypeInfo(value=self.dictionaryData, parentNode="")
-        self.tree.bind('<<TreeviewSelect>>', self.TreeviewSelect) #selection changed
-        self.tree.bind("<Double-1>", self.OnTreeDoubleClick) #an item has been selected for change
-        self.tree.bind("<Return>", self.OnTreeEdit) #an item has been selected for change
-        self.tree.bind("<ButtonRelease-1>", self.OnTreeEdit) #an item has been selected for change #1357
-        self.tree.bind("h", self.OnTreeHelp) #show description for selected item
-        self.tree.bind("<Escape>", self.OnQuit) 
-        self.tree.bind("q", self.OnQuit) 
-        
-        #+++++++++++++++++++++++++++++++++++++++++
-        #create the entry field for editing the treeview value
-        self.selectedItem = '' #will change to valid item in order to change value
-        self.editItemName = tk.StringVar()
-        self.editItemVar = tk.StringVar()
-
-        #self.editName = tk.Label(self, textvariable=self.editItemName) #label expands itself
-        self.editName = tk.Entry(self, textvariable=self.editItemName) #label expands itself
-        self.editName.configure(background='gray95', borderwidth=0)
-        self.editName.grid(row=1, column=0, columnspan=1, sticky=tk.N+tk.E+tk.S+tk.W)
-
-        self.editItem = tk.Entry(self, textvariable=self.editItemVar)
-        self.editItem.grid(row=1, column=1, columnspan=2, sticky=tk.N+tk.E+tk.S+tk.W)
-
-            
-        self.editItem.bind('<Return>', self.OnEditEntryItem)
-        self.editItem.bind('<FocusOut>', self.OnEditEntryItem)
-        self.editItem.bind('<Escape>', self.OnEscapeEntryItem)
-
-        #+++++++++++++++++++++++++++++++++++++++++
-        #combo box for special items (bool, enums, ...)
-        self.comboItem = ttk.Combobox(self, values=['True','False'] )
-        self.comboItem.current(0)
-        self.comboItem.grid(row=1, column=1, columnspan=2, sticky=tk.N+tk.E+tk.S+tk.W)
-        self.comboItem.lower(self.editItem)
-
-        #self.comboItem.bind('<Return>', self.OnEditComboItem)
-        self.comboItem.bind('<<ComboboxSelected>>', self.OnEditComboItem)
-        self.comboItem.bind('<Escape>', self.OnEscapeComboItem)
-
-        #+++++++++++++++++++++++++++++++++++++++++
-        #pre-select item
-        first = self.tree.get_children('')[0]
-        self.tree.focus_set()
-        self.tree.focus(first)
-        self.tree.selection_set((first))
-        
-        self.modifiedDictionary = self.GetDictionary('')
-
-    #create treeview from dictionary with type info
-    def AddNodeFromDictionaryWithTypeInfo(self, value, parentNode="", key=None, level=0):
-        if key is None:
-            id = ""
-        else:
-            id = self.tree.insert(parentNode, "end", text=key)
-        #print("key =", key)
-        isOpen = self.treeOpen and (level<=1)
-
-        if isinstance(value, dict):
-            itemIsOpen = isOpen
-            if ('itemIdentifier' not in value) and (key in treeEditOpenItems): 
-                itemIsOpen = True
-                
-            self.tree.item(id, open=itemIsOpen)
-            if 'itemIdentifier' in value: #is a value with types:
-                #strValue = ConvertValue2String(value['value'], value['type'], value['size'])
-                #print('v=',value['value'],',t=',str(value['type']),'s=', value['size'])
-                #strValue = str(value['value'])
-                strValue = ConvertValue2String(value['value'], value['type'], value['size'])
-                
-                self.tree.item(id, values=(strValue, value['description']))
-                #store additional data in dictionaries (could also be tuples ...)
-                self.typeStorage[id] = value['type']
-                self.sizeStorage[id] = value['size']
-                self.descriptionStorage[id] = value['description']
-            else: #must be another dictionary:
-                for (key, value) in value.items():
-                    self.AddNodeFromDictionaryWithTypeInfo(value, id, key, level=level+1)
-        else:
-            print("Error in AddNodeFromDictionaryWithTypeInfo with item:", value, ", parent=", parentNode, ", key=", key)
-            #self.tree.item(id, values=(value))
-
-    #create treeview from plain dictionary
-    def AddNodeFromDictionary(self, value, parentNode="", key=None):
-        if key is None:
-            id = ""
-        else:
-            id = self.tree.insert(parentNode, "end", text=key)
-
-        if isinstance(value, dict):
-            self.tree.item(id, open=True)
-            for (key, value) in value.items():
-                self.AddNodeFromDictionary(value, id, key)
-        else:
-            self.tree.item(id, values=(value))
-
-    def GetDictionary(self, item):
-        d=dict()
-        kids = self.tree.get_children(item)
-        #print(kids)
-        for i in kids:
-            nchilds = len(self.tree.get_children(i))
-            if nchilds == 0:
-                if len(self.tree.item(i,'values')) != 0:
-                    valStr = self.tree.item(i,'values')[0]
-                    [val, errorMsg] = ConvertString2Value(valStr, str(self.typeStorage[i]), self.sizeStorage[i], self.dictionaryTypesT)
-                    if errorMsg == '':
-                        d.update({self.tree.item(i,'text'): val})
-                    else:
-                        print('item '+ str(self.tree.item(i,'text')) + ' has illegal value "'+valStr + '": '+errorMsg)
-                else:
-                    d.update({self.tree.item(i,'text'): ''})
-            else:
-                d.update({self.tree.item(i,'text'): self.GetDictionary(i)})
-        return d
-
-    def OnTreeHelp(self,event):
-        item = self.tree.selection()[0]
-        if item in self.descriptionStorage:
-            d = self.descriptionStorage[item]
-            s = self.tree.item(item,'text')
-            tk.messagebox.showinfo(s, d)
-
-    def OnTreeDoubleClick(self,event):
-        #print('tree double clicked')
-        self.OnTreeEditOrDoubleClick(event, True)
-        
-    def OnTreeEdit(self,event):
-        self.OnTreeEditOrDoubleClick(event)
-        
-    def OnTreeEditOrDoubleClick(self,event,doubleClick=False):
-        item = self.tree.selection()[0]
-        nchilds = len(self.tree.get_children(item))
-        #print('tree edit: item=',item, ', childs=', nchilds)
-
-        #only edit items which have no subitems (no folders!)
-        if nchilds == 0:
-            
-            selectedType=self.typeStorage[item]
-            #+++++++++++++++++++                
-            if selectedType=='bool' and doubleClick: #just toggle value #1354
-                value=self.tree.item(item,'values')[0]
-                if value=='True': value='False'
-                else: value='True'
-
-                self.tree.item(item, values=(value, self.descriptionStorage[item]))
-                self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
-                self.UpdateSettingsStructure() #only if according flag set in visualizationSettings
-                return
-
-            #+++++++++++++++++++                
-            s = self.tree.item(item,'text')
-            #print('text=',s)
-            i=0
-            pItem=self.tree.parent(item)
-            while i < 10 and pItem != '': #limits to 10 levels ...
-                i+=1
-                s = self.tree.item(pItem,'text') + '.' + s
-                pItem=self.tree.parent(pItem)
-            
-            self.editItemName.set(s)
-            self.selectedItem = item #now item can be modified
-            
-            if selectedType in self.dictionaryTypesT:
-                #print('type =',selectedType)
-                
-                value = self.tree.item(item,'values')[0]
-                valueTypes = []
-                for iType in self.dictionaryTypesT[selectedType]:
-                    valueTypes += [str(iType)]
-                valueTypes = tuple(valueTypes)
-
-                self.comboItem['values'] = valueTypes
-                #print(self.comboItem['values'])
-                #print(type(self.comboItem['values']))
-                
-                #find current index:
-                i = 0 #default value
-                if value in valueTypes:
-                    i = valueTypes.index(value)
-                self.comboItem.current(i)
-                
-                self.comboItem.focus_set()
-                self.editItem.lower(self.comboItem)
-                
-            else:
-                #print('general value')
-                self.editItemVar.set(self.tree.item(item,'values')[0])
-                self.editItem.focus_set()
-                self.comboItem.lower(self.editItem)
-        else: #folders (may be opened/closed)
-            openState = self.tree.item(item, 'open')
-            s = self.tree.item(item,'text')
-            #print('  openState=', openState, ', text=',s)
-            if openState and (s not in treeEditOpenItems):
-                treeEditOpenItems.append(s)
-            elif not openState and (s in treeEditOpenItems):
-                treeEditOpenItems.remove(s)
-        
-
-    def OnQuit(self,event): #new selection --> nothing to edit for now
-        self.parentFrame.destroy()
-        
-    def TreeviewSelect(self,event): #new selection --> nothing to edit for now
-        #print('select')
-        self.editItemVar.set('')
-        self.editItemName.set('')
-        self.comboItem.lower(self.editItem) #bring entry item to front
-        
-    #if visualizationSettings are accordingly, the renderer will obtain an update signal
-    def UpdateSettingsStructure(self):
-        #++++++++++++++++++++++++++++++++++++++++++++++++
-        #update changes
-        self.settingsStructure.SetDictionary(self.modifiedDictionary)  #this may also change dialogs.multiThreadedDialogs itself
-        if 'currentRendererSystemContainer' in exudyn.sys:
-            guiSC = exudyn.sys['currentRendererSystemContainer']
-            if guiSC != 0:
-                if guiSC.visualizationSettings.dialogs.multiThreadedDialogs:
-                    guiSC.SendRedrawSignal()
-                    exudyn.DoRendererIdleTasks()
-        #++++++++++++++++++++++++++++++++++++++++++++++++
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        
-    #user has now edited the Entry dialog and valid updates are copied to treeview
-    def OnEditEntryItem(self,event):
-        if self.selectedItem != '':
-            valueStr = self.editItemVar.get()
-            [rv, errorMSG] = CheckType(valueStr, self.typeStorage[self.selectedItem], self.sizeStorage[self.selectedItem])
-            if rv:
-                self.tree.item(self.selectedItem, values=(self.editItemVar.get(), self.descriptionStorage[self.selectedItem]))
-                currentItem = self.selectedItem
-                self.selectedItem = '' #modification finished
-                self.editItemVar.set('')
-                self.editItemName.set('')
-                self.tree.focus_set()
-                self.tree.focus(currentItem)
-            else:
-                self.editItem.unbind('<FocusOut>') #otherwise OnEditEntryItem called twice
-                tk.messagebox.showerror("Error", errorMSG+'\npress ESCAPE to reset to original values')
-                self.editItem.bind('<FocusOut>', self.OnEditEntryItem) #bind again
-            
-            self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
-            self.UpdateSettingsStructure() #only if according flag set in visualizationSettings
-
-    def OnEscapeEntryItem(self,event):
-        #print('escape')
-        if self.selectedItem != '':
-            self.editItemVar.set(self.tree.item(self.selectedItem,'values')[0])
-            self.selectedItem = '' #now item can be modified
-#            self.editItemVar.set('')
-#            self.editItemName.set('')
-            self.tree.focus_set()
-
-    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        
-    #user has now edited the Entry dialog and valid updates are copied to treeview
-    def OnEditComboItem(self,event):
-        if self.selectedItem != '':
-            
-            value = self.comboItem.current()
-            valueStr = self.comboItem['values'][value]
-            
-            self.tree.item(self.selectedItem, values=(valueStr, self.descriptionStorage[self.selectedItem]))
-            currentItem = self.selectedItem
-            self.selectedItem = '' #modification finished
-            self.editItemVar.set('')
-            self.editItemName.set('')
-            self.comboItem.lower(self.editItem) #bring entry item to front
-            
-            self.tree.focus_set()
-            self.tree.focus(currentItem)
-
-            self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
-            self.UpdateSettingsStructure() #only if according flag set in visualizationSettings
-
-    def OnEscapeComboItem(self,event):
-        #print('escape')
-        if self.selectedItem != '':
-            self.editItemVar.set(self.tree.item(self.selectedItem,'values')[0])
-            self.selectedItem = '' #now item can be modified
-#            self.editItemVar.set('')
-#            self.editItemName.set('')
-            self.tree.focus_set()
-            self.comboItem.lower(self.editItem) #bring entry item to front
-
-
-#**function: edit dictionaryData and return modified (new) dictionary
-#**input: 
-#  settingsStructure: hierarchical settings structure, e.g., SC.visualizationSettings
-#  exu: exudyn module
-#  dictionaryName: name displayed in dialog
-#**output: returns modified dictionary, which can be used, e.g., for SC.visualizationSettings.SetDictionary(...)
-def EditDictionaryWithTypeInfo(settingsStructure, exu=None, dictionaryName='edit'):
-
-    [root, tkWindow, tkinterAlreadyRunning] = GetTkRootAndNewWindow()
-    
-    windowHeight = treeEditDefaultHeight
-    if treeEditMaxInitialHeight > treeEditDefaultHeight:
-        try:
-            #screen_width = root.winfo_screenwidth()
-            screen_height = root.winfo_screenheight()
-            #print('screen height=', screen_height)
-            if screen_height > 1.2*treeEditDefaultHeight:
-                windowHeight = int(min(treeEditMaxInitialHeight, 0.85*screen_height))
-        except:
-            print('WARNING: EditDictionaryWithTypeInfo could not determine screen size; please report error, Python version and platform as github issue')
-
-    tkWindow.geometry(str(treeEditDefaultWidth)+'x'+str(windowHeight))
-
-    guiSC = GetRendererSystemContainer()
-    updateOnChange = False
-    systemScaling = 1.35 #ideal for MacOS 
-    topmost = True
-    alphaTransparency = 1 #<1 means transparency
-    treeOpen = True
-    if guiSC != None:
-        updateOnChange = guiSC.visualizationSettings.dialogs.multiThreadedDialogs
-        systemScaling = guiSC.visualizationSettings.dialogs.fontScalingMacOS
-        topmost = guiSC.visualizationSettings.dialogs.alwaysTopmost
-        if guiSC.visualizationSettings.dialogs.alphaTransparency <= 1:
-            alphaTransparency = guiSC.visualizationSettings.dialogs.alphaTransparency
-        treeOpen = guiSC.visualizationSettings.dialogs.openTreeView
-        
-    fontFactor = systemScaling
-    if not IsApple():
-        #it seems that the font size should not be changed (what is done due to scaling internally ...)
-        fontFactor = 1
-        systemScaling = GetGUIContentScaling(root)
-
-    tkWindow.lift() #brings it to front of other; not always "strong" enough
-    if topmost:
-        root.attributes("-topmost", True) #puts window topmost (permanent)
-    if alphaTransparency <= 1:
-        tkWindow.attributes("-alpha", alphaTransparency) 
-        
-    tkWindow.title(dictionaryName)
-    tkWindow.focus_force() #window has focus
-
-    textHeight = TkTextHeight(systemScaling)
-
-    #no effect:
-    # defaultFont = tkFont.Font(root=root, family = "TkDefaultFont")
-    # defaultFont.configure(size=treeviewDefaultFontSize*fontFactor)
-        
-    style = ttk.Style(tkWindow)
-    style.configure('Treeview', rowheight=textHeight) 
-    
-    style.configure("Treeview.Heading", font=(None, int(treeviewDefaultFontSize*fontFactor) ) )
-    style.configure("Treeview", font=(None, int(treeviewDefaultFontSize*fontFactor) ))
-    
-    #style.configure("Vertical.TScrollbar", width=4)
-    
-    comboListsT = GetComboBoxListsDict(exu)
-    ex=TkinterEditDictionaryWithTypeInfo(parent=tkWindow, settingsStructure=settingsStructure, dictionaryTypesT=comboListsT, 
-                                         updateOnChange=updateOnChange, treeOpen=treeOpen, textHeight = textHeight)
-    ex.pack(fill="both", expand=True)
-
-    if not tkinterAlreadyRunning:
-        tk.mainloop()
-    else:
-        root.wait_window(tkWindow)
-    
-    settingsStructure.SetDictionary(ex.modifiedDictionary)
-    #return ex.modifiedDictionary
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#hierarchical lists, without type info:
-class TkinterEditDictionary(tk.Frame):
-    def __init__(self, parent, dictionaryData, dictionaryIsEditable=True, textHeight = 15):
-        tk.Frame.__init__(self, parent)
-        
-        self.parent = parent
-        self.dictionaryIsEditable = dictionaryIsEditable
-        self.longestColumn = 20 #min value
-        self.textHeight = textHeight
-
-        #create treeview:
-        self.tree = ttk.Treeview(self, columns=("value"), height=textHeight)
-        self.AddNodeFromDictionary(value=dictionaryData, parentNode="")
-
-        self.vsb = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview, )
-        self.hsb = ttk.Scrollbar(self, orient="horizontal", command=self.tree.xview)
-        self.tree.configure(yscrollcommand=self.vsb.set, xscrollcommand=self.hsb.set)
-
-        self.vsb.pack(side="right", fill="y")
-        self.tree.pack(side="top", fill="both", expand=True)
-
-        self.hsb.pack(side="bottom",anchor='w', fill="x",padx=10,pady=5)
-
-        self.tree.bind('<<TreeviewSelect>>', self.TreeviewSelect) #selection changed
-        self.tree.bind("<Double-1>", self.OnTreeDoubleClick) #an item has been selected for change
-        self.tree.bind("<Return>", self.OnTreeDoubleClick) #an item has been selected for change
-        self.tree.bind("<Escape>", self.OnQuit) 
-        self.tree.bind("q", self.OnQuit) 
-        
-        #create the entry field for editing the treeview value
-
-        if True:
-            self.selectedItem = '' #will change to valid item in order to change value
-            self.editItemName = tk.StringVar()
-            self.editItemVar = tk.StringVar()
-    
-            self.editName = tk.Label(self, textvariable=self.editItemName)#, width=10)
-            self.editName.pack(side="left", fill="both", expand=True)
-    
-            self.editItem = tk.Entry(self, textvariable=self.editItemVar)#, width=40)
-    #        self.editItem.grid(row=1, column=1)
-            self.editItem.pack(side="right", fill="both", expand=True)
-            self.editItem.bind('<Return>', self.OnEditEntryItem)
-            self.editItem.bind('<FocusOut>', self.OnEditEntryItem)
-            self.editItem.bind('<Escape>', self.OnEditEscapeItem)
-
-        first = self.tree.get_children('')[0]
-        self.tree.focus_set()
-        self.tree.focus(first)
-        self.tree.selection_set((first))
-        self.tree.heading('#0', text='variable', anchor='w')
-        self.tree.column("#0",minwidth=300, stretch=True)        
-        self.tree.heading('#1', text='value', anchor='w')
-        self.tree.column("#1",anchor='w', #width=200,
-                         minwidth=self.longestColumn*12,
-                         stretch=True)
-        self.hsb.config(command = self.tree.xview)
-
-        self.modifiedDictionary = self.GetDictionary('')
-
-    def IsItemIndex(self, var):
-        return (isinstance(var, exudyn.NodeIndex) or
-                isinstance(var, exudyn.ObjectIndex) or
-                isinstance(var, exudyn.MarkerIndex) or
-                isinstance(var, exudyn.LoadIndex) or
-                isinstance(var, exudyn.SensorIndex))
-    #create dictionary
-    #this is used e.g. for mouse right-button dialog
-    def AddNodeFromDictionary(self, value, parentNode="", key=None):
-        if key is None:
-            id = ""
-        else:
-            if key != 'TODO':
-                id = self.tree.insert(parentNode, "end", text=key)
-            else:
-                id = self.tree.insert(parentNode, "end", text='<unavailable>')
-
-        if isinstance(value, dict):
-            self.tree.item(id, open=True)
-            for (key, value) in value.items():
-                self.AddNodeFromDictionary(value, id, key)
-        else:
-            #print("value =", value)
-            if isinstance(value, bool) : #bool first, bool is also int
-                self.tree.item(id, values=(str(value)))
-            elif isinstance(value, int) or isinstance(value, float):
-                self.tree.item(id, values=(value))
-            elif isinstance(value, np.ndarray):
-                if (value.size < 5000):
-                    valueList = value.tolist()
-                    valueListStr = str(valueList)
-                    self.longestColumn = max(self.longestColumn,len(valueListStr))
-                    valueStr = valueListStr.replace(' ','\ ').replace(',','\,')
-                    self.tree.item(id, values=(valueStr))
-                else:
-                    self.tree.item(id, values=('<unavailable>'))
-            elif isinstance(value, list):
-                if np.array(value).size < 5000:
-                    valueListStr = str(value)
-                    self.longestColumn = max(self.longestColumn,len(valueListStr))
-                    valueStr = valueListStr.replace(' ','\ ').replace(',','\,')
-                    self.tree.item(id, values=(valueStr))
-                else:
-                    self.tree.item(id, values=('<unavailable>'))
-            elif isinstance(value, str) and value!='Get graphics data to be implemented':
-                self.longestColumn = max(self.longestColumn,len(value))
-                self.tree.item(id, values=(value.replace(' ','\ ')))
-            elif self.IsItemIndex(value):
-                self.tree.item(id, values=(int(value)))
-            else:
-                self.tree.item(id, values=('<unavailable>'))
-
-    def GetDictionary(self, item):
-        d=dict()
-        kids = self.tree.get_children(item)
-        #print(kids)
-        for i in kids:
-            nchilds = len(self.tree.get_children(i))
-            if nchilds == 0:
-                d.update({self.tree.item(i,'text'): self.tree.item(i,'values')[0]})
-            else:
-                d.update({self.tree.item(i,'text'): self.GetDictionary(i)})
-        return d
-
-    def OnTreeDoubleClick(self,event):
-        item = self.tree.selection()[0]
-        nchilds = len(self.tree.get_children(item))
-
-        if nchilds == 0:
-            self.editItemVar.set(self.tree.item(item,'values')[0])
-            
-            s = self.tree.item(item,'text')
-            i=0
-            pItem=self.tree.parent(item)
-            while i < 3 and pItem != '':
-                i+=1
-                s = self.tree.item(pItem,'text') + '.' + s
-                pItem=self.tree.parent(pItem)
-                
-                
-            self.editItemName.set(s)
-            self.selectedItem = item #now item can be modified
-            self.editItem.focus_set()
-        else: #move to next item
-            next = self.tree.get_children(item)[0]
-            if next != '':
-                self.tree.selection_set((next))
-                self.tree.focus(next)
-                self.tree.see(next)
-            
-
-    def OnQuit(self,event): #new selection --> nothing to edit for now
-        self.parent.destroy()
-        
-    def TreeviewSelect(self,event): #new selection --> nothing to edit for now
-        #print('select')
-        self.selectedItem = '' #now item can be modified
-        self.editItemVar.set('')
-        self.editItemName.set('')
-        
-        
-    def OnEditEntryItem(self,event):
-        if self.selectedItem != '':
-            #print('edit')
-            if self.dictionaryIsEditable:
-                valueStr = self.editItemVar.get()
-                valueStr = str(valueStr).replace(' ','\ ')
-                #print(valueStr)
-                self.tree.item(self.selectedItem, values=(valueStr))
-                currentItem = self.selectedItem
-                self.selectedItem = '' #now item can be modified
-                self.editItemVar.set('')
-                self.editItemName.set('')
-                self.tree.focus_set()
-    
-                #as return is pressed, move to next item
-                next = self.tree.next(currentItem)
-                if next != '':
-                    self.tree.selection_set((next))
-                    self.tree.focus(next)
-                    self.tree.see(next)
-                else:
-                    par = self.tree.parent(currentItem)
-                    if par != '' and self.tree.next(par) != '':
-                        next = self.tree.next(par)
-                        self.tree.selection_set(next)
-                        self.tree.focus(next)
-                        self.tree.see(next)
-                self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
-
-    def OnEditEscapeItem(self,event):
-        #print('escape')
-        if self.selectedItem != '':
-            valueStr = self.tree.item(self.selectedItem,'values')[0]
-            #print(valueStr)
-            valueStr = str(valueStr).replace(' ','\ ')
-            self.editItemVar.set(valueStr)
-            self.selectedItem = '' #now item can be modified
-#            self.editItemVar.set('')
-#            self.editItemName.set('')
-            self.tree.focus_set()
-    
-
-#edit dictionaryData and return modified (new) dictionary
-def EditDictionary(dictionaryData, dictionaryIsEditable=True, dialogName=''):
-    [root, tkWindow, tkinterAlreadyRunning] = GetTkRootAndNewWindow()
-
-    tkWindow.geometry(str(dialogDefaultWidth)+'x'+str(dialogDefaultHeight))
-
-    guiSC = GetRendererSystemContainer()
-    systemScaling = 1.35 #ideal for MacOS 
-    topmost = True
-    alphaTransparency = 1 #<1 means transparency
-    if guiSC != None:
-        systemScaling = guiSC.visualizationSettings.dialogs.fontScalingMacOS
-        topmost = guiSC.visualizationSettings.dialogs.alwaysTopmost
-        if guiSC.visualizationSettings.dialogs.alphaTransparency <= 1:
-            alphaTransparency = guiSC.visualizationSettings.dialogs.alphaTransparency
-        
-    fontFactor = systemScaling
-    if not IsApple():
-        #it seems that the font size should not be changed (what is done due to scaling internally ...)
-        fontFactor = 1
-        systemScaling = GetGUIContentScaling(root)
-
-    tkWindow.lift() #brings it to front of other; not always "strong" enough
-    if topmost:
-        tkWindow.attributes("-topmost", True) #puts window topmost (permanent)
-    if alphaTransparency:
-        tkWindow.attributes("-alpha", alphaTransparency) 
-    
-
-    textHeight = TkTextHeight(systemScaling)
-
-    #no effect:
-    # defaultFont = tkFont.Font(root=root, family = "TkDefaultFont")
-    # defaultFont.configure(size=treeviewDefaultFontSize*fontFactor)
-
-    tkWindow.title(dialogName)
-    tkWindow.focus_force() #window has focus
-
-    style = ttk.Style(tkWindow)
-    style.configure('Treeview', rowheight=textHeight) 
-    #it seems that the font size should not be changed (what is done due to scaling internally ...)
-
-    style.configure("Treeview.Heading", font=(None, int(treeviewDefaultFontSize*fontFactor) ) )
-    style.configure("Treeview", font=(None, int(treeviewDefaultFontSize*fontFactor) ) )
-
-    #this has no effect style.configure("Vertical.TScrollbar", width=4)
-
-    ex=TkinterEditDictionary(tkWindow, dictionaryData, dictionaryIsEditable, textHeight)
-    ex.pack(fill="both", expand=True)
-
-    if not tkinterAlreadyRunning:
-        tk.mainloop() #run second main loop? will crash
-    else:
-        root.wait_window(tkWindow)
-    
-    if dictionaryIsEditable:
-        return ex.modifiedDictionary
-    else:
-        return {}
-
-
-
-        
-##+++++++++++++++++++++++++++++++++++++++
-##EXAMPLE        
-
-#DATA2={'objectType': 'ConnectorSpringDamper',
-# 'markerNumbers': [1, 3],
-# 'referenceLength': 1.0,
-# 'stiffness': 1000.0,
-# 'damping': 5.0,
-# 'force': 0.0,
-# 'activeConnector': True,
-# 'springForceUserFunction': None,
-# 'name': 'spring damper0',
-# 'Vshow': True,
-# 'VdrawSize': 0.0,
-# 'Vcolor': [-1.0, -1.0, -1.0, -1.0]}
-#
-#x=EditDictionaryWithTypeInfo(DATA2)
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# File:     Exudyn GUI helper files (Tkinter)
+#
+# Details:  Helper functions and classes for graphical interaction with Exudyn
+#
+# Author:   Johannes Gerstmayr
+# Date:     2020-01-25
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+# Notes:    This is an internal library, which is only used inside Exudyn for modifying settings.
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import tkinter as tk
+import tkinter.messagebox
+import tkinter.ttk as ttk
+import tkinter.font as tkFont
+import numpy as np #for array checks
+from numpy import float32
+import ast #for ast.literal_eval
+import sys
+import exudyn
+
+useRenderWindowDisplayScaling = True #using this, scaling will change with render window
+
+treeviewDefaultFontSize = 9 #this is then scaled; but it could be changed to make fonts smaller
+textHeightFactor = 1.45 #this is the factor between font size and text height; larger values leading to more space between lines
+
+treeEditDefaultWidth = 1024     #unscaled width of e.g. visualizationSettings
+treeEditDefaultHeight = 800     #unscaled height of e.g. visualizationSettings
+treeEditMaxInitialHeight = 1440 #larger height, if screen resolution admits
+dialogDefaultWidth = 800        #unscaled width of e.g. right mouse edit
+dialogDefaultHeight = 600       #unscaled height of e.g. right mouse edit
+treeEditOpenItems = ['bodies','connectors','nodes','general'] #these items are opened at the beginning
+
+def IsApple():
+    if sys.platform == 'darwin':
+        return True
+    else:
+        return False
+
+def GetRendererSystemContainer():
+    try:
+        if 'currentRendererSystemContainer' in exudyn.sys: 
+            guiSC = exudyn.sys['currentRendererSystemContainer']
+            if guiSC != 0 and type(guiSC) == exudyn.SystemContainer:
+                return guiSC
+    except: 
+        pass
+    return None
+
+#**function: get new or current root and new window app; return list of [tkRoot, tkWindow, tkRuns]
+def GetTkRootAndNewWindow():
+    if tk._default_root == None:
+        root = tk.Tk()
+        tkWindow = root
+        tkRuns = False
+    else:
+        root = tk._default_root
+        tkWindow = tk.Toplevel(root)
+        tkRuns = True
+    return [root, tkWindow, tkRuns]
+
+#**function: this function returns True, if tkinter has already a root window (which is assumed to have already a mainloop running)
+def TkRootExists():
+    return (tk._default_root != None)
+
+
+
+#unique text height for tk with given scaling
+def TkTextHeight(systemScaling):
+    #OLD, without     style.configure("Treeview", font=(None, treeviewDefaultFontSize ) ):
+    #return int(13*systemScaling) #must be int; 13 is good; 16 is too big on surface
+    
+    return int((treeviewDefaultFontSize*textHeightFactor)*systemScaling) #must be int; 13 is good with treeviewDefaultFontSize = 9; 12 leads to some cuts of 'g'
+
+#check if is float:
+def IsFloat(v):
+    try:
+        float(v)
+    except ValueError:
+        return False
+    return True
+
+#check if converts to numpy array
+def IsArrayInt(v):
+    try:
+        np.fromstring(v,dtype=int,sep=',') #frombuffer does not work!
+    except ValueError:
+        return False
+    return True
+    
+def IsVector(v):
+    try:
+        np.fromstring(v,dtype=float,sep=',') #frombuffer does not work!
+    except ValueError:
+        return False
+    return True
+
+#safely request scaling factor from exudyn
+def GetExudynDisplayScaling():
+    try:
+        if 'currentRendererSystemContainer' in exudyn.sys: 
+            guiSC = exudyn.sys['currentRendererSystemContainer']
+            if guiSC != 0: #this would mean that renderer is detached
+                rs = guiSC.GetRenderState()
+                #print('return render state')
+                return rs['displayScaling']
+        
+        return 1
+
+    except: 
+        #print('except!')
+        return 1
+
+#return either exudyn or tkinter scaling, unified approach
+def GetGUIContentScaling(root):
+    try:
+        if useRenderWindowDisplayScaling: #would also work under linux
+            #print('exudyn scaling      =',GetExudynDisplayScaling())
+            #print('tkinter scaling(OLD)=',root.tk.call('tk', 'scaling'))
+            s = 1.4*GetExudynDisplayScaling() #gives similar size as other programs; factor 1.4 is empirical
+            root.tk.call('tk', 'scaling', s) #needed to update font size internally ...
+            #print('tkinter scaling(NEW)=',root.tk.call('tk', 'scaling'))
+            return s
+        else:
+            return root.tk.call('tk', 'scaling') #obtains current scaling?
+    except:
+        return 1
+    
+#create dictionaries for lists in combo box: bool, OutputVariableType, ...
+def GetComboBoxListsDict(exu = None):
+    d=dict()  #as string
+    dT=dict() #as type
+    
+    if exu != None: #exudyn loaded
+        listOfTypes = []
+        listOfTypesT = []
+        dTypes = exu.OutputVariableType.__members__
+        for i in dTypes: 
+            listOfTypes+=[str(dTypes[i])]
+            listOfTypesT+=[dTypes[i]]
+        d['OutputVariableType'] = listOfTypes
+        dT['OutputVariableType'] = listOfTypesT
+
+        
+        listOfTypes = []
+        listOfTypesT = []
+        dTypes = exu.LinearSolverType.__members__
+        for i in dTypes: 
+            listOfTypes+=[str(dTypes[i])]
+            listOfTypesT+=[dTypes[i]]
+        d['LinearSolverType'] = listOfTypes
+        dT['LinearSolverType'] = listOfTypesT
+
+        listOfTypes = []
+        listOfTypesT = []
+        dTypes = exu.ItemType.__members__
+        for i in dTypes: 
+            listOfTypes+=[str(dTypes[i])]
+            listOfTypesT+=[dTypes[i]]
+        d['ItemType'] = listOfTypes
+        dT['ItemType'] = listOfTypesT
+
+    else:
+        print('WARNING: exudyn not loaded as "exu"')
+
+    #d['bool'] = ['True','False']
+    dT['bool'] = [True, False]
+    return dT
+    
+#convert string into exudyn type
+def ConvertString2Value(value, vType, vSize, dictionaryTypesT):
+    errorMsg = ''
+    if vType == 'FileName' or vType == 'String':
+        return [value, errorMsg]
+
+    if vType == 'bool':
+        if value == 'True':
+            return [True, errorMsg]
+        else:
+            return [False, errorMsg]
+
+    if (vType == 'float' 
+        or vType == 'PReal' or vType == 'UReal' or vType == 'Real'
+        or vType == 'PFloat' or vType == 'UFloat'):
+        floatValue = float(value)
+        if vType == 'PReal' and floatValue <= 0:
+                errorMsg = 'PReal must be > 0'
+        if vType == 'UReal' and floatValue < 0:
+                errorMsg = 'UReal must be >= 0'
+        if vType == 'PFloat' and floatValue <= 0:
+                errorMsg = 'PFloat must be > 0'
+        if vType == 'UFloat' and floatValue < 0:
+                errorMsg = 'UFloat must be >= 0'
+        
+        return [float(value), errorMsg]
+
+    if vType == 'Index' or vType == 'Int' or vType == 'PInt' or vType == 'UInt':
+        intValue = int(value)
+
+        if vType == 'Index' or vType == 'UInt':
+            if intValue < 0:
+                errorMsg = 'UInt must be >= 0'
+
+        if vType == 'PInt':
+            if intValue <= 0:
+                errorMsg = 'PInt must be > 0'
+                
+        return [intValue, errorMsg]
+
+#    print('vType=',vType)
+#    print('value=',value)
+    
+    if vType in dictionaryTypesT:#search for correct type in list
+        for iValue in dictionaryTypesT[vType]:
+            if str(iValue) == value:
+                return [iValue, errorMsg]
+
+    if (len(vSize) == 2 or                      #must be matrix
+        (len(vSize)==1 and vSize[0] > 1) or     #must be vector with fixed size
+        (len(vSize)==1 and vSize[0] == -1) ):   #array / vector with undefined size
+        return [ast.literal_eval(value), errorMsg]
+
+    #print("Error in ConvertString2Value: unknown type",vType, "value=", value)
+    return [0, 'unknown type '+vType]
+
+#convert values to string; special treatment of floats (C++ float, single precision)
+def ConvertValue2String(value, vType, vSize):
+    if (len(vSize)==1 and vSize[0] == 1 and #special treatment for conversion with according number of digits!
+        (  vType == 'float'
+        or vType == 'PFloat'
+        or vType == 'UFloat'
+        )):
+        return str(float32(value))
+    #elif len(vSize)==1 and vType == 'VectorFloat':
+    elif vType == 'VectorFloat' or vType == 'MatrixFloat': #special treatment for conversion with according number of digits!
+        #return str(np.array(value,dtype=float32).tolist()) #still produces float64 converted numbers
+        return str(np.array(value,dtype=float32).astype(str).tolist()).replace("'","") #workaround to produce single-precition numbers ...
+    return str(value)
+
+#check if a valueStr corresponds to correct type and size; return True, if correct; False if type incorrect
+#returns [isValid, errorMSG]
+#isValid=True: everything is ok
+def CheckType(valueStr, vType, vSize):
+#    print('str=',valueStr)
+    
+    validFileNameChar = " `'{}()%&-@#$~!_^./\\"
+    
+#    if vType == 'bool':
+#        if valueStr=='False' or valueStr=='True':
+#            return [True, '']
+#        else:
+#            return [False, 'bool may only be True or False']
+
+    if vType == 'FileName':
+        if len(valueStr) == 0 or valueStr[0]==' ': #space at first position may be possible on file systems, but is not recommended
+            return [False, 'filename may neither be empty nor begin with a SPACE character']
+        for x in valueStr: #this is inefficient but should not delay too much
+            if not ((x in validFileNameChar)  or x.isalpha() or x.isnumeric()):
+                #print('(x in validFileNameChar)=',(x in validFileNameChar),',x.isalpha()=',x.isalpha(),',x.isnumeric()=',x.isnumeric())
+                return [False, 'invalid character in file name: may only be A-Z, a-z, 0-9, "'+validFileNameChar +'"']
+        return [True, '']
+
+    if vType == 'String':
+        return [True, '']
+    if vType == 'float':
+        #print('float=',IsFloat(valueStr))
+        rv = IsFloat(valueStr)
+        if rv:
+            return [True, '']
+        else:
+            return [False, 'invalid float number']
+    if vType == 'Index' and not valueStr.isdigit():
+        return [False, 'invalid integer (must be positive)']
+    
+    #Now check vectors, matrices, ...: try if value can be converted ...
+    x=[0]
+    try:
+        #s = 'global x\nx='+str(valueStr) + '\nprint(x)'
+        s = 'locx='+str(valueStr)# + '\nprint(x)'
+        mylocals={'locx':[]}
+        exec(s,globals(),mylocals)
+        x=mylocals['locx']
+        #print('mylocals=',mylocals)
+    except:
+        #print("entered text does not comply with the value's type")
+        return [False, 'invalid array or matrix: check brackets and types']
+
+    #print('x=',x)
+    
+    if len(vSize) == 1 and vSize[0] > 1: #vector/array
+        if len(x) != vSize[0]:
+            return [False, 'vector/array must have length '+str(vSize[0])]
+        
+        if vType == 'IndexArray':
+            for i in x:
+                if int(i) != i or i < 0: #not an integer
+                    return [False, 'array values must be positive integer (including 0)']
+    if len(vSize) == 2:
+        if len(x) != vSize[0]:
+            return [False, 'matrix must have '+str(vSize[0]) + ' rows']
+        for row in x:
+            if len(row) != vSize[1]:
+                return [False, 'matrix must have '+str(vSize[1]) + ' columns']
+    
+    return [True, '']
+
+#this class gets a dictionary with type information structure in, but a plain dictionary with types (int, float, string, list, ...) out
+#settingsStructure: contains hierarchical settings structure with function GetDictionaryWithTypeInfo() to obtain dictionary for editing
+#dictionaryTypes: contains a dictionary with the available types, e.g. bool, etc.
+#updateOnChange: every change is directly applied to the settingsStructure and redraw is signaled in stored renderer
+class TkinterEditDictionaryWithTypeInfo(tk.Frame):
+    def __init__(self, parent, settingsStructure, dictionaryTypesT, updateOnChange=False, treeOpen=False, textHeight = 15):
+        tk.Frame.__init__(self, parent)
+        
+        self.parentFrame = parent #parent frame stored for member functions
+        self.settingsStructure = settingsStructure
+        self.dictionaryTypesT = dictionaryTypesT #as type
+        self.updateOnChange = updateOnChange
+        self.treeOpen = treeOpen
+        self.textHeight = textHeight
+
+        self.dictionaryData = settingsStructure.GetDictionaryWithTypeInfo()
+
+        #additional storage for type, size, etc.
+        self.typeStorage = dict() #dictionary is stored as {'ID1': 'type1', 'ID2': 'type2', ...}
+        self.sizeStorage = dict()
+        self.descriptionStorage = dict()
+
+        #create treeview:
+        self.tree = ttk.Treeview(self, columns=("value","description"), selectmode='browse', height=self.textHeight)
+        self.vertivalScrollbar = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
+        self.tree.configure(yscrollcommand=self.vertivalScrollbar.set)
+
+        self.tree.grid(row=0, column=0, columnspan=3, sticky="nsew")
+        self.vertivalScrollbar.grid(row=0, column=3, sticky='nse')
+        self.vertivalScrollbar.configure(command=self.tree.yview)
+
+
+        self.grid_rowconfigure(0, weight=1)
+        self.grid_columnconfigure(0,weight=1)
+        self.grid_columnconfigure(1,weight=2)
+        self.grid_columnconfigure(2,weight=2)
+        self.grid_columnconfigure(3,weight=0)
+        
+        self.tree.heading("#0",text="Name",anchor=tk.W)
+        self.tree.heading("value",text="Value",anchor=tk.W)
+        self.tree.heading("description",text="Description (press H to show)",anchor=tk.W)
+
+
+        self.AddNodeFromDictionaryWithTypeInfo(value=self.dictionaryData, parentNode="")
+        self.tree.bind('<<TreeviewSelect>>', self.TreeviewSelect) #selection changed
+        self.tree.bind("<Double-1>", self.OnTreeDoubleClick) #an item has been selected for change
+        self.tree.bind("<Return>", self.OnTreeEdit) #an item has been selected for change
+        self.tree.bind("<ButtonRelease-1>", self.OnTreeEdit) #an item has been selected for change #1357
+        self.tree.bind("h", self.OnTreeHelp) #show description for selected item
+        self.tree.bind("<Escape>", self.OnQuit) 
+        self.tree.bind("q", self.OnQuit) 
+        
+        #+++++++++++++++++++++++++++++++++++++++++
+        #create the entry field for editing the treeview value
+        self.selectedItem = '' #will change to valid item in order to change value
+        self.editItemName = tk.StringVar()
+        self.editItemVar = tk.StringVar()
+
+        #self.editName = tk.Label(self, textvariable=self.editItemName) #label expands itself
+        self.editName = tk.Entry(self, textvariable=self.editItemName) #label expands itself
+        self.editName.configure(background='gray95', borderwidth=0)
+        self.editName.grid(row=1, column=0, columnspan=1, sticky=tk.N+tk.E+tk.S+tk.W)
+
+        self.editItem = tk.Entry(self, textvariable=self.editItemVar)
+        self.editItem.grid(row=1, column=1, columnspan=2, sticky=tk.N+tk.E+tk.S+tk.W)
+
+            
+        self.editItem.bind('<Return>', self.OnEditEntryItem)
+        self.editItem.bind('<FocusOut>', self.OnEditEntryItem)
+        self.editItem.bind('<Escape>', self.OnEscapeEntryItem)
+
+        #+++++++++++++++++++++++++++++++++++++++++
+        #combo box for special items (bool, enums, ...)
+        self.comboItem = ttk.Combobox(self, values=['True','False'] )
+        self.comboItem.current(0)
+        self.comboItem.grid(row=1, column=1, columnspan=2, sticky=tk.N+tk.E+tk.S+tk.W)
+        self.comboItem.lower(self.editItem)
+
+        #self.comboItem.bind('<Return>', self.OnEditComboItem)
+        self.comboItem.bind('<<ComboboxSelected>>', self.OnEditComboItem)
+        self.comboItem.bind('<Escape>', self.OnEscapeComboItem)
+
+        #+++++++++++++++++++++++++++++++++++++++++
+        #pre-select item
+        first = self.tree.get_children('')[0]
+        self.tree.focus_set()
+        self.tree.focus(first)
+        self.tree.selection_set((first))
+        
+        self.modifiedDictionary = self.GetDictionary('')
+
+    #create treeview from dictionary with type info
+    def AddNodeFromDictionaryWithTypeInfo(self, value, parentNode="", key=None, level=0):
+        if key is None:
+            id = ""
+        else:
+            id = self.tree.insert(parentNode, "end", text=key)
+        #print("key =", key)
+        isOpen = self.treeOpen and (level<=1)
+
+        if isinstance(value, dict):
+            itemIsOpen = isOpen
+            if ('itemIdentifier' not in value) and (key in treeEditOpenItems): 
+                itemIsOpen = True
+                
+            self.tree.item(id, open=itemIsOpen)
+            if 'itemIdentifier' in value: #is a value with types:
+                #strValue = ConvertValue2String(value['value'], value['type'], value['size'])
+                #print('v=',value['value'],',t=',str(value['type']),'s=', value['size'])
+                #strValue = str(value['value'])
+                strValue = ConvertValue2String(value['value'], value['type'], value['size'])
+                
+                self.tree.item(id, values=(strValue, value['description']))
+                #store additional data in dictionaries (could also be tuples ...)
+                self.typeStorage[id] = value['type']
+                self.sizeStorage[id] = value['size']
+                self.descriptionStorage[id] = value['description']
+            else: #must be another dictionary:
+                for (key, value) in value.items():
+                    self.AddNodeFromDictionaryWithTypeInfo(value, id, key, level=level+1)
+        else:
+            print("Error in AddNodeFromDictionaryWithTypeInfo with item:", value, ", parent=", parentNode, ", key=", key)
+            #self.tree.item(id, values=(value))
+
+    #create treeview from plain dictionary
+    def AddNodeFromDictionary(self, value, parentNode="", key=None):
+        if key is None:
+            id = ""
+        else:
+            id = self.tree.insert(parentNode, "end", text=key)
+
+        if isinstance(value, dict):
+            self.tree.item(id, open=True)
+            for (key, value) in value.items():
+                self.AddNodeFromDictionary(value, id, key)
+        else:
+            self.tree.item(id, values=(value))
+
+    def GetDictionary(self, item):
+        d=dict()
+        kids = self.tree.get_children(item)
+        #print(kids)
+        for i in kids:
+            nchilds = len(self.tree.get_children(i))
+            if nchilds == 0:
+                if len(self.tree.item(i,'values')) != 0:
+                    valStr = self.tree.item(i,'values')[0]
+                    [val, errorMsg] = ConvertString2Value(valStr, str(self.typeStorage[i]), self.sizeStorage[i], self.dictionaryTypesT)
+                    if errorMsg == '':
+                        d.update({self.tree.item(i,'text'): val})
+                    else:
+                        print('item '+ str(self.tree.item(i,'text')) + ' has illegal value "'+valStr + '": '+errorMsg)
+                else:
+                    d.update({self.tree.item(i,'text'): ''})
+            else:
+                d.update({self.tree.item(i,'text'): self.GetDictionary(i)})
+        return d
+
+    def OnTreeHelp(self,event):
+        item = self.tree.selection()[0]
+        if item in self.descriptionStorage:
+            d = self.descriptionStorage[item]
+            s = self.tree.item(item,'text')
+            tk.messagebox.showinfo(s, d)
+
+    def OnTreeDoubleClick(self,event):
+        #print('tree double clicked')
+        self.OnTreeEditOrDoubleClick(event, True)
+        
+    def OnTreeEdit(self,event):
+        self.OnTreeEditOrDoubleClick(event)
+        
+    def OnTreeEditOrDoubleClick(self,event,doubleClick=False):
+        item = self.tree.selection()[0]
+        nchilds = len(self.tree.get_children(item))
+        #print('tree edit: item=',item, ', childs=', nchilds)
+
+        #only edit items which have no subitems (no folders!)
+        if nchilds == 0:
+            
+            selectedType=self.typeStorage[item]
+            #+++++++++++++++++++                
+            if selectedType=='bool' and doubleClick: #just toggle value #1354
+                value=self.tree.item(item,'values')[0]
+                if value=='True': value='False'
+                else: value='True'
+
+                self.tree.item(item, values=(value, self.descriptionStorage[item]))
+                self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
+                self.UpdateSettingsStructure() #only if according flag set in visualizationSettings
+                return
+
+            #+++++++++++++++++++                
+            s = self.tree.item(item,'text')
+            #print('text=',s)
+            i=0
+            pItem=self.tree.parent(item)
+            while i < 10 and pItem != '': #limits to 10 levels ...
+                i+=1
+                s = self.tree.item(pItem,'text') + '.' + s
+                pItem=self.tree.parent(pItem)
+            
+            self.editItemName.set(s)
+            self.selectedItem = item #now item can be modified
+            
+            if selectedType in self.dictionaryTypesT:
+                #print('type =',selectedType)
+                
+                value = self.tree.item(item,'values')[0]
+                valueTypes = []
+                for iType in self.dictionaryTypesT[selectedType]:
+                    valueTypes += [str(iType)]
+                valueTypes = tuple(valueTypes)
+
+                self.comboItem['values'] = valueTypes
+                #print(self.comboItem['values'])
+                #print(type(self.comboItem['values']))
+                
+                #find current index:
+                i = 0 #default value
+                if value in valueTypes:
+                    i = valueTypes.index(value)
+                self.comboItem.current(i)
+                
+                self.comboItem.focus_set()
+                self.editItem.lower(self.comboItem)
+                
+            else:
+                #print('general value')
+                self.editItemVar.set(self.tree.item(item,'values')[0])
+                self.editItem.focus_set()
+                self.comboItem.lower(self.editItem)
+        else: #folders (may be opened/closed)
+            openState = self.tree.item(item, 'open')
+            s = self.tree.item(item,'text')
+            #print('  openState=', openState, ', text=',s)
+            if openState and (s not in treeEditOpenItems):
+                treeEditOpenItems.append(s)
+            elif not openState and (s in treeEditOpenItems):
+                treeEditOpenItems.remove(s)
+        
+
+    def OnQuit(self,event): #new selection --> nothing to edit for now
+        self.parentFrame.destroy()
+        
+    def TreeviewSelect(self,event): #new selection --> nothing to edit for now
+        #print('select')
+        self.editItemVar.set('')
+        self.editItemName.set('')
+        self.comboItem.lower(self.editItem) #bring entry item to front
+        
+    #if visualizationSettings are accordingly, the renderer will obtain an update signal
+    def UpdateSettingsStructure(self):
+        #++++++++++++++++++++++++++++++++++++++++++++++++
+        #update changes
+        self.settingsStructure.SetDictionary(self.modifiedDictionary)  #this may also change dialogs.multiThreadedDialogs itself
+        if 'currentRendererSystemContainer' in exudyn.sys:
+            guiSC = exudyn.sys['currentRendererSystemContainer']
+            if guiSC != 0:
+                if guiSC.visualizationSettings.dialogs.multiThreadedDialogs:
+                    guiSC.SendRedrawSignal()
+                    exudyn.DoRendererIdleTasks()
+        #++++++++++++++++++++++++++++++++++++++++++++++++
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        
+    #user has now edited the Entry dialog and valid updates are copied to treeview
+    def OnEditEntryItem(self,event):
+        if self.selectedItem != '':
+            valueStr = self.editItemVar.get()
+            [rv, errorMSG] = CheckType(valueStr, self.typeStorage[self.selectedItem], self.sizeStorage[self.selectedItem])
+            if rv:
+                self.tree.item(self.selectedItem, values=(self.editItemVar.get(), self.descriptionStorage[self.selectedItem]))
+                currentItem = self.selectedItem
+                self.selectedItem = '' #modification finished
+                self.editItemVar.set('')
+                self.editItemName.set('')
+                self.tree.focus_set()
+                self.tree.focus(currentItem)
+            else:
+                self.editItem.unbind('<FocusOut>') #otherwise OnEditEntryItem called twice
+                tk.messagebox.showerror("Error", errorMSG+'\npress ESCAPE to reset to original values')
+                self.editItem.bind('<FocusOut>', self.OnEditEntryItem) #bind again
+            
+            self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
+            self.UpdateSettingsStructure() #only if according flag set in visualizationSettings
+
+    def OnEscapeEntryItem(self,event):
+        #print('escape')
+        if self.selectedItem != '':
+            self.editItemVar.set(self.tree.item(self.selectedItem,'values')[0])
+            self.selectedItem = '' #now item can be modified
+#            self.editItemVar.set('')
+#            self.editItemName.set('')
+            self.tree.focus_set()
+
+    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++        
+    #user has now edited the Entry dialog and valid updates are copied to treeview
+    def OnEditComboItem(self,event):
+        if self.selectedItem != '':
+            
+            value = self.comboItem.current()
+            valueStr = self.comboItem['values'][value]
+            
+            self.tree.item(self.selectedItem, values=(valueStr, self.descriptionStorage[self.selectedItem]))
+            currentItem = self.selectedItem
+            self.selectedItem = '' #modification finished
+            self.editItemVar.set('')
+            self.editItemName.set('')
+            self.comboItem.lower(self.editItem) #bring entry item to front
+            
+            self.tree.focus_set()
+            self.tree.focus(currentItem)
+
+            self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
+            self.UpdateSettingsStructure() #only if according flag set in visualizationSettings
+
+    def OnEscapeComboItem(self,event):
+        #print('escape')
+        if self.selectedItem != '':
+            self.editItemVar.set(self.tree.item(self.selectedItem,'values')[0])
+            self.selectedItem = '' #now item can be modified
+#            self.editItemVar.set('')
+#            self.editItemName.set('')
+            self.tree.focus_set()
+            self.comboItem.lower(self.editItem) #bring entry item to front
+
+
+#**function: edit dictionaryData and return modified (new) dictionary
+#**input: 
+#  settingsStructure: hierarchical settings structure, e.g., SC.visualizationSettings
+#  exu: exudyn module
+#  dictionaryName: name displayed in dialog
+#**output: returns modified dictionary, which can be used, e.g., for SC.visualizationSettings.SetDictionary(...)
+def EditDictionaryWithTypeInfo(settingsStructure, exu=None, dictionaryName='edit'):
+
+    [root, tkWindow, tkinterAlreadyRunning] = GetTkRootAndNewWindow()
+    
+    windowHeight = treeEditDefaultHeight
+    if treeEditMaxInitialHeight > treeEditDefaultHeight:
+        try:
+            #screen_width = root.winfo_screenwidth()
+            screen_height = root.winfo_screenheight()
+            #print('screen height=', screen_height)
+            if screen_height > 1.2*treeEditDefaultHeight:
+                windowHeight = int(min(treeEditMaxInitialHeight, 0.85*screen_height))
+        except:
+            print('WARNING: EditDictionaryWithTypeInfo could not determine screen size; please report error, Python version and platform as github issue')
+
+    tkWindow.geometry(str(treeEditDefaultWidth)+'x'+str(windowHeight))
+
+    guiSC = GetRendererSystemContainer()
+    updateOnChange = False
+    systemScaling = 1.35 #ideal for MacOS 
+    topmost = True
+    alphaTransparency = 1 #<1 means transparency
+    treeOpen = True
+    if guiSC != None:
+        updateOnChange = guiSC.visualizationSettings.dialogs.multiThreadedDialogs
+        systemScaling = guiSC.visualizationSettings.dialogs.fontScalingMacOS
+        topmost = guiSC.visualizationSettings.dialogs.alwaysTopmost
+        if guiSC.visualizationSettings.dialogs.alphaTransparency <= 1:
+            alphaTransparency = guiSC.visualizationSettings.dialogs.alphaTransparency
+        treeOpen = guiSC.visualizationSettings.dialogs.openTreeView
+        
+    fontFactor = systemScaling
+    if not IsApple():
+        #it seems that the font size should not be changed (what is done due to scaling internally ...)
+        fontFactor = 1
+        systemScaling = GetGUIContentScaling(root)
+
+    tkWindow.lift() #brings it to front of other; not always "strong" enough
+    if topmost:
+        root.attributes("-topmost", True) #puts window topmost (permanent)
+    if alphaTransparency <= 1:
+        tkWindow.attributes("-alpha", alphaTransparency) 
+        
+    tkWindow.title(dictionaryName)
+    tkWindow.focus_force() #window has focus
+
+    textHeight = TkTextHeight(systemScaling)
+
+    #no effect:
+    # defaultFont = tkFont.Font(root=root, family = "TkDefaultFont")
+    # defaultFont.configure(size=treeviewDefaultFontSize*fontFactor)
+        
+    style = ttk.Style(tkWindow)
+    style.configure('Treeview', rowheight=textHeight) 
+    
+    style.configure("Treeview.Heading", font=(None, int(treeviewDefaultFontSize*fontFactor) ) )
+    style.configure("Treeview", font=(None, int(treeviewDefaultFontSize*fontFactor) ))
+    
+    #style.configure("Vertical.TScrollbar", width=4)
+    
+    comboListsT = GetComboBoxListsDict(exu)
+    ex=TkinterEditDictionaryWithTypeInfo(parent=tkWindow, settingsStructure=settingsStructure, dictionaryTypesT=comboListsT, 
+                                         updateOnChange=updateOnChange, treeOpen=treeOpen, textHeight = textHeight)
+    ex.pack(fill="both", expand=True)
+
+    if not tkinterAlreadyRunning:
+        tk.mainloop()
+    else:
+        root.wait_window(tkWindow)
+    
+    settingsStructure.SetDictionary(ex.modifiedDictionary)
+    #return ex.modifiedDictionary
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#hierarchical lists, without type info:
+class TkinterEditDictionary(tk.Frame):
+    def __init__(self, parent, dictionaryData, dictionaryIsEditable=True, textHeight = 15):
+        tk.Frame.__init__(self, parent)
+        
+        self.parent = parent
+        self.dictionaryIsEditable = dictionaryIsEditable
+        self.longestColumn = 20 #min value
+        self.textHeight = textHeight
+
+        #create treeview:
+        self.tree = ttk.Treeview(self, columns=("value"), height=textHeight)
+        self.AddNodeFromDictionary(value=dictionaryData, parentNode="")
+
+        self.vsb = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview, )
+        self.hsb = ttk.Scrollbar(self, orient="horizontal", command=self.tree.xview)
+        self.tree.configure(yscrollcommand=self.vsb.set, xscrollcommand=self.hsb.set)
+
+        self.vsb.pack(side="right", fill="y")
+        self.tree.pack(side="top", fill="both", expand=True)
+
+        self.hsb.pack(side="bottom",anchor='w', fill="x",padx=10,pady=5)
+
+        self.tree.bind('<<TreeviewSelect>>', self.TreeviewSelect) #selection changed
+        self.tree.bind("<Double-1>", self.OnTreeDoubleClick) #an item has been selected for change
+        self.tree.bind("<Return>", self.OnTreeDoubleClick) #an item has been selected for change
+        self.tree.bind("<Escape>", self.OnQuit) 
+        self.tree.bind("q", self.OnQuit) 
+        
+        #create the entry field for editing the treeview value
+
+        if True:
+            self.selectedItem = '' #will change to valid item in order to change value
+            self.editItemName = tk.StringVar()
+            self.editItemVar = tk.StringVar()
+    
+            self.editName = tk.Label(self, textvariable=self.editItemName)#, width=10)
+            self.editName.pack(side="left", fill="both", expand=True)
+    
+            self.editItem = tk.Entry(self, textvariable=self.editItemVar)#, width=40)
+    #        self.editItem.grid(row=1, column=1)
+            self.editItem.pack(side="right", fill="both", expand=True)
+            self.editItem.bind('<Return>', self.OnEditEntryItem)
+            self.editItem.bind('<FocusOut>', self.OnEditEntryItem)
+            self.editItem.bind('<Escape>', self.OnEditEscapeItem)
+
+        first = self.tree.get_children('')[0]
+        self.tree.focus_set()
+        self.tree.focus(first)
+        self.tree.selection_set((first))
+        self.tree.heading('#0', text='variable', anchor='w')
+        self.tree.column("#0",minwidth=300, stretch=True)        
+        self.tree.heading('#1', text='value', anchor='w')
+        self.tree.column("#1",anchor='w', #width=200,
+                         minwidth=self.longestColumn*12,
+                         stretch=True)
+        self.hsb.config(command = self.tree.xview)
+
+        self.modifiedDictionary = self.GetDictionary('')
+
+    def IsItemIndex(self, var):
+        return (isinstance(var, exudyn.NodeIndex) or
+                isinstance(var, exudyn.ObjectIndex) or
+                isinstance(var, exudyn.MarkerIndex) or
+                isinstance(var, exudyn.LoadIndex) or
+                isinstance(var, exudyn.SensorIndex))
+    #create dictionary
+    #this is used e.g. for mouse right-button dialog
+    def AddNodeFromDictionary(self, value, parentNode="", key=None):
+        if key is None:
+            id = ""
+        else:
+            if key != 'TODO':
+                id = self.tree.insert(parentNode, "end", text=key)
+            else:
+                id = self.tree.insert(parentNode, "end", text='<unavailable>')
+
+        if isinstance(value, dict):
+            self.tree.item(id, open=True)
+            for (key, value) in value.items():
+                self.AddNodeFromDictionary(value, id, key)
+        else:
+            #print("value =", value)
+            if isinstance(value, bool) : #bool first, bool is also int
+                self.tree.item(id, values=(str(value)))
+            elif isinstance(value, int) or isinstance(value, float):
+                self.tree.item(id, values=(value))
+            elif isinstance(value, np.ndarray):
+                if (value.size < 5000):
+                    valueList = value.tolist()
+                    valueListStr = str(valueList)
+                    self.longestColumn = max(self.longestColumn,len(valueListStr))
+                    valueStr = valueListStr.replace(' ','\\ ').replace(',','\\,')
+                    self.tree.item(id, values=(valueStr))
+                else:
+                    self.tree.item(id, values=('<unavailable>'))
+            elif isinstance(value, list):
+                if np.array(value).size < 5000:
+                    valueListStr = str(value)
+                    self.longestColumn = max(self.longestColumn,len(valueListStr))
+                    valueStr = valueListStr.replace(' ','\\ ').replace(',','\\,')
+                    self.tree.item(id, values=(valueStr))
+                else:
+                    self.tree.item(id, values=('<unavailable>'))
+            elif isinstance(value, str) and value!='Get graphics data to be implemented':
+                self.longestColumn = max(self.longestColumn,len(value))
+                self.tree.item(id, values=(value.replace(' ','\\ ')))
+            elif self.IsItemIndex(value):
+                self.tree.item(id, values=(int(value)))
+            else:
+                self.tree.item(id, values=('<unavailable>'))
+
+    def GetDictionary(self, item):
+        d=dict()
+        kids = self.tree.get_children(item)
+        #print(kids)
+        for i in kids:
+            nchilds = len(self.tree.get_children(i))
+            if nchilds == 0:
+                d.update({self.tree.item(i,'text'): self.tree.item(i,'values')[0]})
+            else:
+                d.update({self.tree.item(i,'text'): self.GetDictionary(i)})
+        return d
+
+    def OnTreeDoubleClick(self,event):
+        item = self.tree.selection()[0]
+        nchilds = len(self.tree.get_children(item))
+
+        if nchilds == 0:
+            self.editItemVar.set(self.tree.item(item,'values')[0])
+            
+            s = self.tree.item(item,'text')
+            i=0
+            pItem=self.tree.parent(item)
+            while i < 3 and pItem != '':
+                i+=1
+                s = self.tree.item(pItem,'text') + '.' + s
+                pItem=self.tree.parent(pItem)
+                
+                
+            self.editItemName.set(s)
+            self.selectedItem = item #now item can be modified
+            self.editItem.focus_set()
+        else: #move to next item
+            next = self.tree.get_children(item)[0]
+            if next != '':
+                self.tree.selection_set((next))
+                self.tree.focus(next)
+                self.tree.see(next)
+            
+
+    def OnQuit(self,event): #new selection --> nothing to edit for now
+        self.parent.destroy()
+        
+    def TreeviewSelect(self,event): #new selection --> nothing to edit for now
+        #print('select')
+        self.selectedItem = '' #now item can be modified
+        self.editItemVar.set('')
+        self.editItemName.set('')
+        
+        
+    def OnEditEntryItem(self,event):
+        if self.selectedItem != '':
+            #print('edit')
+            if self.dictionaryIsEditable:
+                valueStr = self.editItemVar.get()
+                valueStr = str(valueStr).replace(' ','\\ ')
+                #print(valueStr)
+                self.tree.item(self.selectedItem, values=(valueStr))
+                currentItem = self.selectedItem
+                self.selectedItem = '' #now item can be modified
+                self.editItemVar.set('')
+                self.editItemName.set('')
+                self.tree.focus_set()
+    
+                #as return is pressed, move to next item
+                next = self.tree.next(currentItem)
+                if next != '':
+                    self.tree.selection_set((next))
+                    self.tree.focus(next)
+                    self.tree.see(next)
+                else:
+                    par = self.tree.parent(currentItem)
+                    if par != '' and self.tree.next(par) != '':
+                        next = self.tree.next(par)
+                        self.tree.selection_set(next)
+                        self.tree.focus(next)
+                        self.tree.see(next)
+                self.modifiedDictionary = self.GetDictionary('') #update stored dictionary
+
+    def OnEditEscapeItem(self,event):
+        #print('escape')
+        if self.selectedItem != '':
+            valueStr = self.tree.item(self.selectedItem,'values')[0]
+            #print(valueStr)
+            valueStr = str(valueStr).replace(' ','\\ ')
+            self.editItemVar.set(valueStr)
+            self.selectedItem = '' #now item can be modified
+#            self.editItemVar.set('')
+#            self.editItemName.set('')
+            self.tree.focus_set()
+    
+
+#edit dictionaryData and return modified (new) dictionary
+def EditDictionary(dictionaryData, dictionaryIsEditable=True, dialogName=''):
+    [root, tkWindow, tkinterAlreadyRunning] = GetTkRootAndNewWindow()
+
+    tkWindow.geometry(str(dialogDefaultWidth)+'x'+str(dialogDefaultHeight))
+
+    guiSC = GetRendererSystemContainer()
+    systemScaling = 1.35 #ideal for MacOS 
+    topmost = True
+    alphaTransparency = 1 #<1 means transparency
+    if guiSC != None:
+        systemScaling = guiSC.visualizationSettings.dialogs.fontScalingMacOS
+        topmost = guiSC.visualizationSettings.dialogs.alwaysTopmost
+        if guiSC.visualizationSettings.dialogs.alphaTransparency <= 1:
+            alphaTransparency = guiSC.visualizationSettings.dialogs.alphaTransparency
+        
+    fontFactor = systemScaling
+    if not IsApple():
+        #it seems that the font size should not be changed (what is done due to scaling internally ...)
+        fontFactor = 1
+        systemScaling = GetGUIContentScaling(root)
+
+    tkWindow.lift() #brings it to front of other; not always "strong" enough
+    if topmost:
+        tkWindow.attributes("-topmost", True) #puts window topmost (permanent)
+    if alphaTransparency:
+        tkWindow.attributes("-alpha", alphaTransparency) 
+    
+
+    textHeight = TkTextHeight(systemScaling)
+
+    #no effect:
+    # defaultFont = tkFont.Font(root=root, family = "TkDefaultFont")
+    # defaultFont.configure(size=treeviewDefaultFontSize*fontFactor)
+
+    tkWindow.title(dialogName)
+    tkWindow.focus_force() #window has focus
+
+    style = ttk.Style(tkWindow)
+    style.configure('Treeview', rowheight=textHeight) 
+    #it seems that the font size should not be changed (what is done due to scaling internally ...)
+
+    style.configure("Treeview.Heading", font=(None, int(treeviewDefaultFontSize*fontFactor) ) )
+    style.configure("Treeview", font=(None, int(treeviewDefaultFontSize*fontFactor) ) )
+
+    #this has no effect style.configure("Vertical.TScrollbar", width=4)
+
+    ex=TkinterEditDictionary(tkWindow, dictionaryData, dictionaryIsEditable, textHeight)
+    ex.pack(fill="both", expand=True)
+
+    if not tkinterAlreadyRunning:
+        tk.mainloop() #run second main loop? will crash
+    else:
+        root.wait_window(tkWindow)
+    
+    if dictionaryIsEditable:
+        return ex.modifiedDictionary
+    else:
+        return {}
+
+
+
+        
+##+++++++++++++++++++++++++++++++++++++++
+##EXAMPLE        
+
+#DATA2={'objectType': 'ConnectorSpringDamper',
+# 'markerNumbers': [1, 3],
+# 'referenceLength': 1.0,
+# 'stiffness': 1000.0,
+# 'damping': 5.0,
+# 'force': 0.0,
+# 'activeConnector': True,
+# 'springForceUserFunction': None,
+# 'name': 'spring damper0',
+# 'Vshow': True,
+# 'VdrawSize': 0.0,
+# 'Vcolor': [-1.0, -1.0, -1.0, -1.0]}
+#
+#x=EditDictionaryWithTypeInfo(DATA2)
+
```

## exudyn/__init__.py

 * *Ordering differences only*

```diff
@@ -1,153 +1,153 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN example
-#
-# Details:  Main Python library file for import of C++ module
-#
-# Author:   Johannes Gerstmayr
-# Date:     2020-08-14
-# Update:   2022-12-26
-#
-# Notes:    see https://github.com/jgerstmayr/EXUDYN for first steps
-#           see theDoc.pdf for instructions, tutorials, etc.: https://github.com/jgerstmayr/EXUDYN/blob/master/docs/theDoc/theDoc.pdf
-# Example (without visualization):
-#    import exudyn as exu
-#    from exudyn.itemInterface import * #conversion of data to exudyn dictionaries
-#    SC = exu.SystemContainer()
-#    mbs = SC.AddSystem()
-#    #add a new system to work with
-#    nMP = mbs.AddNode(NodePoint2D(referenceCoordinates=[0,0]))
-#    mbs.AddObject(ObjectMassPoint2D(physicsMass=10, nodeNumber=nMP ))
-#    mMP = mbs.AddMarker(MarkerNodePosition(nodeNumber = nMP))
-#    mbs.AddLoad(Force(markerNumber = mMP, loadVector=[0.001,0,0]))
-#    mbs.Assemble() #assemble system and solve
-#    exu.SolveDynamic(mbs, exu.SimulationSettings())
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#  Use the following workaround to define the 'fast' track, avoiding range checks in exudyn (speedup may be 30% and more);
-#  to activate the __FAST_EXUDYN_LINALG compiled version, use the following lines (must be done befor first import of exudyn):
-#import sys
-#sys.exudynFast = True
-#import exudyn #now exudyn loads with fast mode
-
-import sys
-__useExudynFast = hasattr(sys, 'exudynFast')
-if __useExudynFast:
-    __useExudynFast = sys.exudynFast #could also be False!
-
-__cpuHasAVX2 = hasattr(sys, 'exudynCPUhasAVX2')
-if __cpuHasAVX2:
-    __cpuHasAVX2 = sys.exudynCPUhasAVX2 #could also be False!
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#use numpy.core to find if AVX+AVX2 is available ...
-try:
-    if sys.platform != 'darwin' and sys.platform != 'linux': #MacOS does not support AVX2; no AVX2 for linux right now; therefore there are not non-AVX modules compiled ...
-        from numpy.core._multiarray_umath import __cpu_features__
-        if (('AVX' in __cpu_features__) and ('AVX2' in __cpu_features__) and
-            (__cpu_features__['AVX'] == True) and (__cpu_features__['AVX2'] == True)):
-            if not __cpuHasAVX2 and hasattr(sys, 'exudynCPUhasAVX2'):
-                print('WARNING: user deactivated AVX2 support, but support detected on current CPU')
-            else:
-                __cpuHasAVX2 = True
-        elif __cpuHasAVX2:
-            print('WARNING: user activated AVX2 support, but no AVX2 support has been detected on current CPU; may crash')
-    else:
-        __cpuHasAVX2 = True #for MacOS and Linux, this means that there is no exudynCPPnoAVX version!
-except:
-    print('Warning: during import of exudyn, it was detected that either numpy or the numpy.core module "_multiarray_umath" is missing')
-
-try:
-    #for regular loading in installed python package
-    if __useExudynFast and __cpuHasAVX2:
-        try:
-            from .exudynCPPfast import *
-            print('Imported exudyn fast version without range checks')
-        except:
-            __useExudynFast = False
-            print('Import of exudyn fast version failed; falling back to regular version')
-    else:
-        __useExudynFast = False #in case __useExudynFast=True but no AVX
-
-    if not __useExudynFast:
-        if __cpuHasAVX2:
-            try:
-                from .exudynCPP import *
-            except:
-                raise ImportError('Warning: Import of exudyn C++ module (with AVX2) failed; check your installation or try to import without AVX by settings sys.exudynCPUhasAVX2=False')
-        else:
-            try:
-                from .exudynCPPnoAVX import *
-            except:
-                raise ImportError('Import of exudyn C++ module (without AVX2) failed; non-AVX2 versions are only available in release versions (without .dev1 appendix); check your installation, Python version, conda environment and site-packages for exudyn; try re-installation')
-
-except:
-    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders); no exudynFast! :
-    try:
-        from exudynCPP import *
-    except:
-        raise ImportError('Import of exudyn C++ module failed; check 32/64 bits versions, restart your iPython console or try to uninstall and install exudyn')
-
-#import very useful solver functionality into exudyn module (==> available as exu.SolveStatic, etc.)
-try:
-    from .solver import SolveStatic, SolveDynamic, SolverSuccess, ComputeLinearizedSystem, ComputeSystemDegreeOfFreedom, ComputeODE2Eigenvalues
-except:
-    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
-    from solver import SolveStatic, SolveDynamic, SolverSuccess, ComputeLinearizedSystem, ComputeSystemDegreeOfFreedom, ComputeODE2Eigenvalues
-
-try:
-    from .demos import Demo1, Demo2
-except:
-    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
-    from demos import Demo1, Demo2
-
-try:
-    from .mainSystemExtensions import JointPreCheckCalc #import just some function, will assign MainSystem patches
-except:
-    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
-    from mainSystemExtensions import JointPreCheckCalc
-
-
-__version__ = GetVersionString() #add __version__ to exudyn module ...
-
-
-#add a functionality to check the current version
-def RequireVersion(requiredVersionString):
-    """
-    Parameters
-    ----------
-    requiredVersionString : string
-        Checks if the installed version is according to the required version.
-        Major, micro and minor version must agree the required level.
-    Returns
-    -------
-    None. But will raise RuntimeError, if required version is not met.
-
-    Example
-    ----------
-    RequireVersion("1.0.26")
-
-    """
-    vExudyn=GetVersionString().split('.')
-    vRequired = requiredVersionString.split('.')
-    isOk = True
-    if int(vExudyn[0]) < int(vRequired[0]):
-        isOk = False
-    elif int(vExudyn[0]) == int(vRequired[0]): #only for equal major versions
-        if int(vExudyn[1]) < int(vRequired[1]): #check minor version
-            isOk = False
-        elif int(vExudyn[1]) == int(vRequired[1]): #only for equal minor versions
-            if int(vExudyn[2]) < int(vRequired[2]): #check micro version
-                isOk = False
-    if not isOk:
-        #print("EXUDYN version "+requiredVersionString+" required, but only " + GetVersionString() + " available")
-        raise RuntimeError("EXUDYN version "+requiredVersionString+" required, but only " + GetVersionString() +
-                           " available!\nYou can install the latest development version with:\npip install -U exudyn --pre\n\n")
-    
-
-#do not import itemInterface here, as it would go into exu. scope
-#from .itemInterface import *
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN example
+#
+# Details:  Main Python library file for import of C++ module
+#
+# Author:   Johannes Gerstmayr
+# Date:     2020-08-14
+# Update:   2022-12-26
+#
+# Notes:    see https://github.com/jgerstmayr/EXUDYN for first steps
+#           see theDoc.pdf for instructions, tutorials, etc.: https://github.com/jgerstmayr/EXUDYN/blob/master/docs/theDoc/theDoc.pdf
+# Example (without visualization):
+#    import exudyn as exu
+#    from exudyn.itemInterface import * #conversion of data to exudyn dictionaries
+#    SC = exu.SystemContainer()
+#    mbs = SC.AddSystem()
+#    #add a new system to work with
+#    nMP = mbs.AddNode(NodePoint2D(referenceCoordinates=[0,0]))
+#    mbs.AddObject(ObjectMassPoint2D(physicsMass=10, nodeNumber=nMP ))
+#    mMP = mbs.AddMarker(MarkerNodePosition(nodeNumber = nMP))
+#    mbs.AddLoad(Force(markerNumber = mMP, loadVector=[0.001,0,0]))
+#    mbs.Assemble() #assemble system and solve
+#    exu.SolveDynamic(mbs, exu.SimulationSettings())
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#  Use the following workaround to define the 'fast' track, avoiding range checks in exudyn (speedup may be 30% and more);
+#  to activate the __FAST_EXUDYN_LINALG compiled version, use the following lines (must be done befor first import of exudyn):
+#import sys
+#sys.exudynFast = True
+#import exudyn #now exudyn loads with fast mode
+
+import sys
+__useExudynFast = hasattr(sys, 'exudynFast')
+if __useExudynFast:
+    __useExudynFast = sys.exudynFast #could also be False!
+
+__cpuHasAVX2 = hasattr(sys, 'exudynCPUhasAVX2')
+if __cpuHasAVX2:
+    __cpuHasAVX2 = sys.exudynCPUhasAVX2 #could also be False!
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#use numpy.core to find if AVX+AVX2 is available ...
+try:
+    if sys.platform != 'darwin' and sys.platform != 'linux': #MacOS does not support AVX2; no AVX2 for linux right now; therefore there are not non-AVX modules compiled ...
+        from numpy.core._multiarray_umath import __cpu_features__
+        if (('AVX' in __cpu_features__) and ('AVX2' in __cpu_features__) and
+            (__cpu_features__['AVX'] == True) and (__cpu_features__['AVX2'] == True)):
+            if not __cpuHasAVX2 and hasattr(sys, 'exudynCPUhasAVX2'):
+                print('WARNING: user deactivated AVX2 support, but support detected on current CPU')
+            else:
+                __cpuHasAVX2 = True
+        elif __cpuHasAVX2:
+            print('WARNING: user activated AVX2 support, but no AVX2 support has been detected on current CPU; may crash')
+    else:
+        __cpuHasAVX2 = True #for MacOS and Linux, this means that there is no exudynCPPnoAVX version!
+except:
+    print('Warning: during import of exudyn, it was detected that either numpy or the numpy.core module "_multiarray_umath" is missing')
+
+try:
+    #for regular loading in installed python package
+    if __useExudynFast and __cpuHasAVX2:
+        try:
+            from .exudynCPPfast import *
+            print('Imported exudyn fast version without range checks')
+        except:
+            __useExudynFast = False
+            print('Import of exudyn fast version failed; falling back to regular version')
+    else:
+        __useExudynFast = False #in case __useExudynFast=True but no AVX
+
+    if not __useExudynFast:
+        if __cpuHasAVX2:
+            try:
+                from .exudynCPP import *
+            except:
+                raise ImportError('Warning: Import of exudyn C++ module (with AVX2) failed; check your installation or try to import without AVX by settings sys.exudynCPUhasAVX2=False')
+        else:
+            try:
+                from .exudynCPPnoAVX import *
+            except:
+                raise ImportError('Import of exudyn C++ module (without AVX2) failed; non-AVX2 versions are only available in release versions (without .dev1 appendix); check your installation, Python version, conda environment and site-packages for exudyn; try re-installation')
+
+except:
+    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders); no exudynFast! :
+    try:
+        from exudynCPP import *
+    except:
+        raise ImportError('Import of exudyn C++ module failed; check 32/64 bits versions, restart your iPython console or try to uninstall and install exudyn')
+
+#import very useful solver functionality into exudyn module (==> available as exu.SolveStatic, etc.)
+try:
+    from .solver import SolveStatic, SolveDynamic, SolverSuccess, ComputeLinearizedSystem, ComputeSystemDegreeOfFreedom, ComputeODE2Eigenvalues
+except:
+    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
+    from solver import SolveStatic, SolveDynamic, SolverSuccess, ComputeLinearizedSystem, ComputeSystemDegreeOfFreedom, ComputeODE2Eigenvalues
+
+try:
+    from .demos import Demo1, Demo2
+except:
+    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
+    from demos import Demo1, Demo2
+
+try:
+    from .mainSystemExtensions import JointPreCheckCalc #import just some function, will assign MainSystem patches
+except:
+    #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
+    from mainSystemExtensions import JointPreCheckCalc
+
+
+__version__ = GetVersionString() #add __version__ to exudyn module ...
+
+
+#add a functionality to check the current version
+def RequireVersion(requiredVersionString):
+    """
+    Parameters
+    ----------
+    requiredVersionString : string
+        Checks if the installed version is according to the required version.
+        Major, micro and minor version must agree the required level.
+    Returns
+    -------
+    None. But will raise RuntimeError, if required version is not met.
+
+    Example
+    ----------
+    RequireVersion("1.0.26")
+
+    """
+    vExudyn=GetVersionString().split('.')
+    vRequired = requiredVersionString.split('.')
+    isOk = True
+    if int(vExudyn[0]) < int(vRequired[0]):
+        isOk = False
+    elif int(vExudyn[0]) == int(vRequired[0]): #only for equal major versions
+        if int(vExudyn[1]) < int(vRequired[1]): #check minor version
+            isOk = False
+        elif int(vExudyn[1]) == int(vRequired[1]): #only for equal minor versions
+            if int(vExudyn[2]) < int(vRequired[2]): #check micro version
+                isOk = False
+    if not isOk:
+        #print("EXUDYN version "+requiredVersionString+" required, but only " + GetVersionString() + " available")
+        raise RuntimeError("EXUDYN version "+requiredVersionString+" required, but only " + GetVersionString() +
+                           " available!\nYou can install the latest development version with:\npip install -U exudyn --pre\n\n")
+    
+
+#do not import itemInterface here, as it would go into exu. scope
+#from .itemInterface import *
+
+
```

## exudyn/__init__.pyi

```diff
@@ -1,3542 +1,3501 @@
-00000000: 0d0a 0d0a 6672 6f6d 2074 7970 696e 6720  ....from typing 
-00000010: 696d 706f 7274 2028 0d0a 2020 2020 416e  import (..    An
-00000020: 6e6f 7461 7465 642c 200d 0a20 2020 2041  notated, ..    A
-00000030: 6e79 2c0d 0a20 2020 2023 2042 7974 6553  ny,..    # ByteS
-00000040: 7472 696e 672c 0d0a 2020 2020 2320 4361  tring,..    # Ca
-00000050: 6c6c 6162 6c65 2c0d 0a20 2020 2023 2043  llable,..    # C
-00000060: 6f6e 7461 696e 6572 2c0d 0a20 2020 2043  ontainer,..    C
-00000070: 616c 6c61 626c 652c 0d0a 2020 2020 4469  allable,..    Di
-00000080: 6374 2c0d 0a20 2020 2023 2047 656e 6572  ct,..    # Gener
-00000090: 6963 2c0d 0a20 2020 2023 2049 4f2c 0d0a  ic,..    # IO,..
-000000a0: 2020 2020 2320 4974 6572 6162 6c65 2c0d      # Iterable,.
-000000b0: 0a20 2020 2023 2049 7465 7261 746f 722c  .    # Iterator,
-000000c0: 0d0a 2020 2020 4c69 7374 2c0d 0a20 2020  ..    List,..   
-000000d0: 204c 6974 6572 616c 2c0d 0a20 2020 2023   Literal,..    #
-000000e0: 204d 6170 7069 6e67 2c0d 0a20 2020 2023   Mapping,..    #
-000000f0: 204e 6f52 6574 7572 6e2c 0d0a 2020 2020   NoReturn,..    
-00000100: 2320 4f70 7469 6f6e 616c 2c0d 0a20 2020  # Optional,..   
-00000110: 206f 7665 726c 6f61 642c 0d0a 2020 2020   overload,..    
-00000120: 2320 5365 7175 656e 6365 2c0d 0a20 2020  # Sequence,..   
-00000130: 2023 2053 697a 6564 2c0d 0a20 2020 2023   # Sized,..    #
-00000140: 2053 7570 706f 7274 7343 6f6d 706c 6578   SupportsComplex
-00000150: 2c0d 0a20 2020 2023 2053 7570 706f 7274  ,..    # Support
-00000160: 7346 6c6f 6174 2c0d 0a20 2020 2023 2053  sFloat,..    # S
-00000170: 7570 706f 7274 7349 6e74 2c0d 0a20 2020  upportsInt,..   
-00000180: 2023 2054 6578 742c 0d0a 2020 2020 5475   # Text,..    Tu
-00000190: 706c 652c 2023 666f 7220 5475 706c 655b  ple, #for Tuple[
-000001a0: 696e 742c 2069 6e74 5d0d 0a20 2020 2023  int, int]..    #
-000001b0: 2054 7970 652c 0d0a 2020 2020 5479 7065   Type,..    Type
-000001c0: 5661 722c 0d0a 2020 2020 556e 696f 6e2c  Var,..    Union,
-000001d0: 0d0a 290d 0a66 726f 6d20 6e75 6d70 792e  ..)..from numpy.
-000001e0: 7479 7069 6e67 2069 6d70 6f72 7420 4172  typing import Ar
-000001f0: 7261 794c 696b 652c 204e 4441 7272 6179  rayLike, NDArray
-00000200: 0d0a 6672 6f6d 2065 6e75 6d20 696d 706f  ..from enum impo
-00000210: 7274 2045 6e75 6d0d 0a69 6d70 6f72 7420  rt Enum..import 
-00000220: 6e75 6d70 7920 6173 206e 700d 0a0d 0a0d  numpy as np.....
-00000230: 0a0d 0a54 3120 3d20 5479 7065 5661 7228  ...T1 = TypeVar(
-00000240: 2254 3122 2c20 626f 756e 643d 696e 7429  "T1", bound=int)
-00000250: 0d0a 5432 203d 2054 7970 6556 6172 2822  ..T2 = TypeVar("
-00000260: 5432 222c 2062 6f75 6e64 3d69 6e74 290d  T2", bound=int).
-00000270: 0a0d 0a53 6861 7065 203d 2054 7570 6c65  ...Shape = Tuple
-00000280: 0d0a 5368 6170 6531 4420 3d20 5368 6170  ..Shape1D = Shap
-00000290: 655b 5431 5d0d 0a53 6861 7065 3244 203d  e[T1]..Shape2D =
-000002a0: 2053 6861 7065 5b54 312c 2054 325d 0d0a   Shape[T1, T2]..
-000002b0: 0d0a 0d0a 0d0a 696d 706f 7274 2065 7875  ......import exu
-000002c0: 6479 6e0d 0a66 726f 6d20 6578 7564 796e  dyn..from exudyn
-000002d0: 2069 6d70 6f72 7420 284f 626a 6563 7449   import (ObjectI
-000002e0: 6e64 6578 2c20 4e6f 6465 496e 6465 782c  ndex, NodeIndex,
-000002f0: 204d 6172 6b65 7249 6e64 6578 2c20 4c6f   MarkerIndex, Lo
-00000300: 6164 496e 6465 782c 2053 656e 736f 7249  adIndex, SensorI
-00000310: 6e64 6578 290d 0a0d 0a66 726f 6d20 6578  ndex)....from ex
-00000320: 7564 796e 2e67 7261 7068 6963 7344 6174  udyn.graphicsDat
-00000330: 6155 7469 6c69 7469 6573 2069 6d70 6f72  aUtilities impor
-00000340: 7420 636f 6c6f 7234 7265 642c 2063 6f6c  t color4red, col
-00000350: 6f72 3464 6566 6175 6c74 0d0a 0d0a 0d0a  or4default......
-00000360: 0d0a 0d0a 0d0a 406f 7665 726c 6f61 640d  ......@overload.
-00000370: 0a64 6566 2047 6574 5665 7273 696f 6e53  .def GetVersionS
-00000380: 7472 696e 6728 6164 6444 6574 6169 6c73  tring(addDetails
-00000390: 3d46 616c 7365 2920 2d3e 2073 7472 3a20  =False) -> str: 
-000003a0: 2e2e 2e0d 0a40 6f76 6572 6c6f 6164 0d0a  .....@overload..
-000003b0: 6465 6620 4865 6c70 2829 202d 3e20 4e6f  def Help() -> No
-000003c0: 6e65 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f  ne: .....@overlo
-000003d0: 6164 0d0a 6465 6620 5265 7175 6972 6556  ad..def RequireV
-000003e0: 6572 7369 6f6e 2872 6571 7569 7265 6456  ersion(requiredV
-000003f0: 6572 7369 6f6e 5374 7269 6e67 3a20 7374  ersionString: st
-00000400: 7229 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  r) -> None: ....
-00000410: 0a40 6f76 6572 6c6f 6164 0d0a 6465 6620  .@overload..def 
-00000420: 5374 6172 7452 656e 6465 7265 7228 7665  StartRenderer(ve
-00000430: 7262 6f73 653d 3029 202d 3e20 626f 6f6c  rbose=0) -> bool
-00000440: 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f 6164  : .....@overload
-00000450: 0d0a 6465 6620 4973 5265 6e64 6572 6572  ..def IsRenderer
-00000460: 4163 7469 7665 2829 202d 3e20 626f 6f6c  Active() -> bool
-00000470: 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f 6164  : .....@overload
-00000480: 0d0a 6465 6620 446f 5265 6e64 6572 6572  ..def DoRenderer
-00000490: 4964 6c65 5461 736b 7328 7761 6974 5365  IdleTasks(waitSe
-000004a0: 636f 6e64 733d 3029 202d 3e20 4e6f 6e65  conds=0) -> None
-000004b0: 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f 6164  : .....@overload
-000004c0: 0d0a 6465 6620 536f 6c76 6553 7461 7469  ..def SolveStati
-000004d0: 6328 6d62 733a 204d 6169 6e53 7973 7465  c(mbs: MainSyste
-000004e0: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-000004f0: 7469 6e67 733a 2053 696d 756c 6174 696f  tings: Simulatio
-00000500: 6e53 6574 7469 6e67 732c 2075 7064 6174  nSettings, updat
-00000510: 6549 6e69 7469 616c 5661 6c75 6573 3d46  eInitialValues=F
-00000520: 616c 7365 2c20 7374 6f72 6553 6f6c 7665  alse, storeSolve
-00000530: 723d 5472 7565 2920 2d3e 2062 6f6f 6c3a  r=True) -> bool:
-00000540: 202e 2e2e 0d0a 406f 7665 726c 6f61 640d   .....@overload.
-00000550: 0a64 6566 2053 6f6c 7665 4479 6e61 6d69  .def SolveDynami
-00000560: 6328 6d62 733a 204d 6169 6e53 7973 7465  c(mbs: MainSyste
-00000570: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-00000580: 7469 6e67 733a 2053 696d 756c 6174 696f  tings: Simulatio
-00000590: 6e53 6574 7469 6e67 732c 2073 6f6c 7665  nSettings, solve
-000005a0: 7254 7970 653a 2044 796e 616d 6963 536f  rType: DynamicSo
-000005b0: 6c76 6572 5479 7065 2c20 7570 6461 7465  lverType, update
-000005c0: 496e 6974 6961 6c56 616c 7565 733d 4661  InitialValues=Fa
-000005d0: 6c73 652c 2073 746f 7265 536f 6c76 6572  lse, storeSolver
-000005e0: 3d54 7275 6529 202d 3e20 626f 6f6c 3a20  =True) -> bool: 
-000005f0: 2e2e 2e0d 0a40 6f76 6572 6c6f 6164 0d0a  .....@overload..
-00000600: 6465 6620 436f 6d70 7574 654f 4445 3245  def ComputeODE2E
-00000610: 6967 656e 7661 6c75 6573 286d 6273 3a20  igenvalues(mbs: 
-00000620: 4d61 696e 5379 7374 656d 2c20 7369 6d75  MainSystem, simu
-00000630: 6c61 7469 6f6e 5365 7474 696e 6773 3a20  lationSettings: 
-00000640: 5369 6d75 6c61 7469 6f6e 5365 7474 696e  SimulationSettin
-00000650: 6773 2c20 7573 6553 7061 7273 6553 6f6c  gs, useSparseSol
-00000660: 7665 723d 4661 6c73 652c 206e 756d 6265  ver=False, numbe
-00000670: 724f 6645 6967 656e 7661 6c75 6573 3d2d  rOfEigenvalues=-
-00000680: 312c 2073 6574 496e 6974 6961 6c56 616c  1, setInitialVal
-00000690: 7565 733d 5472 7565 2c20 636f 6e76 6572  ues=True, conver
-000006a0: 7432 4672 6571 7565 6e63 6965 733d 4661  t2Frequencies=Fa
-000006b0: 6c73 6529 202d 3e20 626f 6f6c 3a20 2e2e  lse) -> bool: ..
-000006c0: 2e0d 0a40 6f76 6572 6c6f 6164 0d0a 6465  ...@overload..de
-000006d0: 6620 5365 744f 7574 7075 7450 7265 6369  f SetOutputPreci
-000006e0: 7369 6f6e 286e 756d 6265 724f 6644 6967  sion(numberOfDig
-000006f0: 6974 733a 2069 6e74 2920 2d3e 204e 6f6e  its: int) -> Non
-00000700: 653a 202e 2e2e 0d0a 406f 7665 726c 6f61  e: .....@overloa
-00000710: 640d 0a64 6566 2053 6574 4c69 6e61 6c67  d..def SetLinalg
-00000720: 4f75 7470 7574 466f 726d 6174 5079 7468  OutputFormatPyth
-00000730: 6f6e 2866 6c61 6750 7974 686f 6e46 6f72  on(flagPythonFor
-00000740: 6d61 743a 2062 6f6f 6c29 202d 3e20 4e6f  mat: bool) -> No
-00000750: 6e65 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f  ne: .....@overlo
-00000760: 6164 0d0a 6465 6620 5365 7457 7269 7465  ad..def SetWrite
-00000770: 546f 436f 6e73 6f6c 6528 666c 6167 3a20  ToConsole(flag: 
-00000780: 626f 6f6c 2920 2d3e 204e 6f6e 653a 202e  bool) -> None: .
-00000790: 2e2e 0d0a 406f 7665 726c 6f61 640d 0a64  ....@overload..d
-000007a0: 6566 2053 6574 5772 6974 6554 6f46 696c  ef SetWriteToFil
-000007b0: 6528 6669 6c65 6e61 6d65 3a20 7374 722c  e(filename: str,
-000007c0: 2066 6c61 6757 7269 7465 546f 4669 6c65   flagWriteToFile
-000007d0: 3d54 7275 652c 2066 6c61 6741 7070 656e  =True, flagAppen
-000007e0: 643d 4661 6c73 6529 202d 3e20 4e6f 6e65  d=False) -> None
-000007f0: 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f 6164  : .....@overload
-00000800: 0d0a 6465 6620 5365 7450 7269 6e74 4465  ..def SetPrintDe
-00000810: 6c61 794d 696c 6c69 5365 636f 6e64 7328  layMilliSeconds(
-00000820: 6465 6c61 794d 696c 6c69 5365 636f 6e64  delayMilliSecond
-00000830: 733a 2069 6e74 2920 2d3e 204e 6f6e 653a  s: int) -> None:
-00000840: 202e 2e2e 0d0a 406f 7665 726c 6f61 640d   .....@overload.
-00000850: 0a64 6566 2050 7269 6e74 282a 6172 6773  .def Print(*args
-00000860: 3a20 416e 7929 202d 3e20 4e6f 6e65 3a20  : Any) -> None: 
-00000870: 2e2e 2e0d 0a40 6f76 6572 6c6f 6164 0d0a  .....@overload..
-00000880: 6465 6620 5375 7070 7265 7373 5761 726e  def SuppressWarn
-00000890: 696e 6773 2866 6c61 673a 2062 6f6f 6c29  ings(flag: bool)
-000008a0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a40   -> None: .....@
-000008b0: 6f76 6572 6c6f 6164 0d0a 6465 6620 496e  overload..def In
-000008c0: 666f 5374 6174 2877 7269 7465 4f75 7470  foStat(writeOutp
-000008d0: 7574 3d54 7275 6529 202d 3e20 4c69 7374  ut=True) -> List
-000008e0: 5b69 6e74 5d3a 202e 2e2e 0d0a 406f 7665  [int]: .....@ove
-000008f0: 726c 6f61 640d 0a64 6566 2047 6f28 2920  rload..def Go() 
-00000900: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 406f  -> None: .....@o
-00000910: 7665 726c 6f61 640d 0a64 6566 2044 656d  verload..def Dem
-00000920: 6f31 2873 686f 7741 6c6c 3a20 626f 6f6c  o1(showAll: bool
-00000930: 2920 2d3e 205b 4d61 696e 5379 7374 656d  ) -> [MainSystem
-00000940: 2c20 5379 7374 656d 436f 6e74 6169 6e65  , SystemContaine
-00000950: 725d 3a20 2e2e 2e0d 0a40 6f76 6572 6c6f  r]: .....@overlo
-00000960: 6164 0d0a 6465 6620 4465 6d6f 3228 7368  ad..def Demo2(sh
-00000970: 6f77 416c 6c3a 2062 6f6f 6c29 202d 3e20  owAll: bool) -> 
-00000980: 5b4d 6169 6e53 7973 7465 6d2c 2053 7973  [MainSystem, Sys
-00000990: 7465 6d43 6f6e 7461 696e 6572 5d3a 202e  temContainer]: .
-000009a0: 2e2e 0d0a 406f 7665 726c 6f61 640d 0a64  ....@overload..d
-000009b0: 6566 2049 6e76 616c 6964 496e 6465 7828  ef InvalidIndex(
-000009c0: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a5f  ) -> int: ....._
-000009d0: 5f76 6572 7369 6f6e 5f5f 3a73 7472 0d0a  _version__:str..
-000009e0: 6578 7065 7269 6d65 6e74 616c 3a45 7870  experimental:Exp
-000009f0: 6572 696d 656e 7461 6c0d 0a73 7065 6369  erimental..speci
-00000a00: 616c 3a53 7065 6369 616c 0d0a 7370 6563  al:Special..spec
-00000a10: 6961 6c2e 736f 6c76 6572 3a53 7065 6369  ial.solver:Speci
-00000a20: 616c 536f 6c76 6572 0d0a 7370 6563 6961  alSolver..specia
-00000a30: 6c2e 736f 6c76 6572 2e74 696d 656f 7574  l.solver.timeout
-00000a40: 3a66 6c6f 6174 0d0a 7661 7269 6162 6c65  :float..variable
-00000a50: 733a 6469 6374 0d0a 7379 733a 6469 6374  s:dict..sys:dict
-00000a60: 0d0a 0d0a 0d0a 636c 6173 7320 4f75 7470  ......class Outp
-00000a70: 7574 5661 7269 6162 6c65 5479 7065 2845  utVariableType(E
-00000a80: 6e75 6d29 3a0d 0a20 2020 205f 4e6f 6e65  num):..    _None
-00000a90: 203d 2069 6e74 0d0a 2020 2020 4469 7374   = int..    Dist
-00000aa0: 616e 6365 203d 2069 6e74 0d0a 2020 2020  ance = int..    
-00000ab0: 506f 7369 7469 6f6e 203d 2069 6e74 0d0a  Position = int..
-00000ac0: 2020 2020 4469 7370 6c61 6365 6d65 6e74      Displacement
-00000ad0: 203d 2069 6e74 0d0a 2020 2020 4469 7370   = int..    Disp
-00000ae0: 6c61 6365 6d65 6e74 4c6f 6361 6c20 3d20  lacementLocal = 
-00000af0: 696e 740d 0a20 2020 2056 656c 6f63 6974  int..    Velocit
-00000b00: 7920 3d20 696e 740d 0a20 2020 2056 656c  y = int..    Vel
-00000b10: 6f63 6974 794c 6f63 616c 203d 2069 6e74  ocityLocal = int
-00000b20: 0d0a 2020 2020 4163 6365 6c65 7261 7469  ..    Accelerati
-00000b30: 6f6e 203d 2069 6e74 0d0a 2020 2020 4163  on = int..    Ac
-00000b40: 6365 6c65 7261 7469 6f6e 4c6f 6361 6c20  celerationLocal 
-00000b50: 3d20 696e 740d 0a20 2020 2052 6f74 6174  = int..    Rotat
-00000b60: 696f 6e4d 6174 7269 7820 3d20 696e 740d  ionMatrix = int.
-00000b70: 0a20 2020 2052 6f74 6174 696f 6e20 3d20  .    Rotation = 
-00000b80: 696e 740d 0a20 2020 2041 6e67 756c 6172  int..    Angular
-00000b90: 5665 6c6f 6369 7479 203d 2069 6e74 0d0a  Velocity = int..
-00000ba0: 2020 2020 416e 6775 6c61 7256 656c 6f63      AngularVeloc
-00000bb0: 6974 794c 6f63 616c 203d 2069 6e74 0d0a  ityLocal = int..
-00000bc0: 2020 2020 416e 6775 6c61 7241 6363 656c      AngularAccel
-00000bd0: 6572 6174 696f 6e20 3d20 696e 740d 0a20  eration = int.. 
-00000be0: 2020 2041 6e67 756c 6172 4163 6365 6c65     AngularAccele
-00000bf0: 7261 7469 6f6e 4c6f 6361 6c20 3d20 696e  rationLocal = in
-00000c00: 740d 0a20 2020 2043 6f6f 7264 696e 6174  t..    Coordinat
-00000c10: 6573 203d 2069 6e74 0d0a 2020 2020 436f  es = int..    Co
-00000c20: 6f72 6469 6e61 7465 735f 7420 3d20 696e  ordinates_t = in
-00000c30: 740d 0a20 2020 2043 6f6f 7264 696e 6174  t..    Coordinat
-00000c40: 6573 5f74 7420 3d20 696e 740d 0a20 2020  es_tt = int..   
-00000c50: 2053 6c69 6469 6e67 436f 6f72 6469 6e61   SlidingCoordina
-00000c60: 7465 203d 2069 6e74 0d0a 2020 2020 4469  te = int..    Di
-00000c70: 7265 6374 6f72 3120 3d20 696e 740d 0a20  rector1 = int.. 
-00000c80: 2020 2044 6972 6563 746f 7232 203d 2069     Director2 = i
-00000c90: 6e74 0d0a 2020 2020 4469 7265 6374 6f72  nt..    Director
-00000ca0: 3320 3d20 696e 740d 0a20 2020 2046 6f72  3 = int..    For
-00000cb0: 6365 203d 2069 6e74 0d0a 2020 2020 466f  ce = int..    Fo
-00000cc0: 7263 654c 6f63 616c 203d 2069 6e74 0d0a  rceLocal = int..
-00000cd0: 2020 2020 546f 7271 7565 203d 2069 6e74      Torque = int
-00000ce0: 0d0a 2020 2020 546f 7271 7565 4c6f 6361  ..    TorqueLoca
-00000cf0: 6c20 3d20 696e 740d 0a20 2020 2053 7472  l = int..    Str
-00000d00: 6169 6e4c 6f63 616c 203d 2069 6e74 0d0a  ainLocal = int..
-00000d10: 2020 2020 5374 7265 7373 4c6f 6361 6c20      StressLocal 
-00000d20: 3d20 696e 740d 0a20 2020 2043 7572 7661  = int..    Curva
-00000d30: 7475 7265 4c6f 6361 6c20 3d20 696e 740d  tureLocal = int.
-00000d40: 0a20 2020 2043 6f6e 7374 7261 696e 7445  .    ConstraintE
-00000d50: 7175 6174 696f 6e20 3d20 696e 740d 0a0d  quation = int...
-00000d60: 0a0d 0a63 6c61 7373 2043 6f6e 6669 6775  ...class Configu
-00000d70: 7261 7469 6f6e 5479 7065 2845 6e75 6d29  rationType(Enum)
-00000d80: 3a0d 0a20 2020 205f 4e6f 6e65 203d 2069  :..    _None = i
-00000d90: 6e74 0d0a 2020 2020 496e 6974 6961 6c20  nt..    Initial 
-00000da0: 3d20 696e 740d 0a20 2020 2043 7572 7265  = int..    Curre
-00000db0: 6e74 203d 2069 6e74 0d0a 2020 2020 5265  nt = int..    Re
-00000dc0: 6665 7265 6e63 6520 3d20 696e 740d 0a20  ference = int.. 
-00000dd0: 2020 2053 7461 7274 4f66 5374 6570 203d     StartOfStep =
-00000de0: 2069 6e74 0d0a 2020 2020 5669 7375 616c   int..    Visual
-00000df0: 697a 6174 696f 6e20 3d20 696e 740d 0a20  ization = int.. 
-00000e00: 2020 2045 6e64 4f66 456e 756d 4c69 7374     EndOfEnumList
-00000e10: 203d 2069 6e74 0d0a 0d0a 0d0a 636c 6173   = int......clas
-00000e20: 7320 4974 656d 5479 7065 2845 6e75 6d29  s ItemType(Enum)
-00000e30: 3a0d 0a20 2020 205f 4e6f 6e65 203d 2069  :..    _None = i
-00000e40: 6e74 0d0a 2020 2020 4e6f 6465 203d 2069  nt..    Node = i
-00000e50: 6e74 0d0a 2020 2020 4f62 6a65 6374 203d  nt..    Object =
-00000e60: 2069 6e74 0d0a 2020 2020 4d61 726b 6572   int..    Marker
-00000e70: 203d 2069 6e74 0d0a 2020 2020 4c6f 6164   = int..    Load
-00000e80: 203d 2069 6e74 0d0a 2020 2020 5365 6e73   = int..    Sens
-00000e90: 6f72 203d 2069 6e74 0d0a 0d0a 0d0a 636c  or = int......cl
-00000ea0: 6173 7320 4e6f 6465 5479 7065 2845 6e75  ass NodeType(Enu
-00000eb0: 6d29 3a0d 0a20 2020 205f 4e6f 6e65 203d  m):..    _None =
-00000ec0: 2069 6e74 0d0a 2020 2020 4772 6f75 6e64   int..    Ground
-00000ed0: 203d 2069 6e74 0d0a 2020 2020 506f 7369   = int..    Posi
-00000ee0: 7469 6f6e 3244 203d 2069 6e74 0d0a 2020  tion2D = int..  
-00000ef0: 2020 4f72 6965 6e74 6174 696f 6e32 4420    Orientation2D 
-00000f00: 3d20 696e 740d 0a20 2020 2050 6f69 6e74  = int..    Point
-00000f10: 3244 536c 6f70 6531 203d 2069 6e74 0d0a  2DSlope1 = int..
-00000f20: 2020 2020 506f 7369 7469 6f6e 203d 2069      Position = i
-00000f30: 6e74 0d0a 2020 2020 4f72 6965 6e74 6174  nt..    Orientat
-00000f40: 696f 6e20 3d20 696e 740d 0a20 2020 2052  ion = int..    R
-00000f50: 6967 6964 426f 6479 203d 2069 6e74 0d0a  igidBody = int..
-00000f60: 2020 2020 526f 7461 7469 6f6e 4575 6c65      RotationEule
-00000f70: 7250 6172 616d 6574 6572 7320 3d20 696e  rParameters = in
-00000f80: 740d 0a20 2020 2052 6f74 6174 696f 6e52  t..    RotationR
-00000f90: 7879 7a20 3d20 696e 740d 0a20 2020 2052  xyz = int..    R
-00000fa0: 6f74 6174 696f 6e52 6f74 6174 696f 6e56  otationRotationV
-00000fb0: 6563 746f 7220 3d20 696e 740d 0a20 2020  ector = int..   
-00000fc0: 204c 6965 4772 6f75 7057 6974 6844 6972   LieGroupWithDir
-00000fd0: 6563 7455 7064 6174 6520 3d20 696e 740d  ectUpdate = int.
-00000fe0: 0a20 2020 2047 656e 6572 6963 4f44 4532  .    GenericODE2
-00000ff0: 203d 2069 6e74 0d0a 2020 2020 4765 6e65   = int..    Gene
-00001000: 7269 634f 4445 3120 3d20 696e 740d 0a20  ricODE1 = int.. 
-00001010: 2020 2047 656e 6572 6963 4145 203d 2069     GenericAE = i
-00001020: 6e74 0d0a 2020 2020 4765 6e65 7269 6344  nt..    GenericD
-00001030: 6174 6120 3d20 696e 740d 0a20 2020 2050  ata = int..    P
-00001040: 6f69 6e74 536c 6f70 6531 203d 2069 6e74  ointSlope1 = int
-00001050: 0d0a 2020 2020 506f 696e 7453 6c6f 7065  ..    PointSlope
-00001060: 3132 203d 2069 6e74 0d0a 2020 2020 506f  12 = int..    Po
-00001070: 696e 7453 6c6f 7065 3233 203d 2069 6e74  intSlope23 = int
-00001080: 0d0a 0d0a 0d0a 636c 6173 7320 4a6f 696e  ......class Join
-00001090: 7454 7970 6528 456e 756d 293a 0d0a 2020  tType(Enum):..  
-000010a0: 2020 5f4e 6f6e 6520 3d20 696e 740d 0a20    _None = int.. 
-000010b0: 2020 2052 6576 6f6c 7574 6558 203d 2069     RevoluteX = i
-000010c0: 6e74 0d0a 2020 2020 5265 766f 6c75 7465  nt..    Revolute
-000010d0: 5920 3d20 696e 740d 0a20 2020 2052 6576  Y = int..    Rev
-000010e0: 6f6c 7574 655a 203d 2069 6e74 0d0a 2020  oluteZ = int..  
-000010f0: 2020 5072 6973 6d61 7469 6358 203d 2069    PrismaticX = i
-00001100: 6e74 0d0a 2020 2020 5072 6973 6d61 7469  nt..    Prismati
-00001110: 6359 203d 2069 6e74 0d0a 2020 2020 5072  cY = int..    Pr
-00001120: 6973 6d61 7469 635a 203d 2069 6e74 0d0a  ismaticZ = int..
-00001130: 0d0a 0d0a 636c 6173 7320 4479 6e61 6d69  ....class Dynami
-00001140: 6353 6f6c 7665 7254 7970 6528 456e 756d  cSolverType(Enum
-00001150: 293a 0d0a 2020 2020 4765 6e65 7261 6c69  ):..    Generali
-00001160: 7a65 6441 6c70 6861 203d 2069 6e74 0d0a  zedAlpha = int..
-00001170: 2020 2020 5472 6170 657a 6f69 6461 6c49      TrapezoidalI
-00001180: 6e64 6578 3220 3d20 696e 740d 0a20 2020  ndex2 = int..   
-00001190: 2045 7870 6c69 6369 7445 756c 6572 203d   ExplicitEuler =
-000011a0: 2069 6e74 0d0a 2020 2020 4578 706c 6963   int..    Explic
-000011b0: 6974 4d69 6470 6f69 6e74 203d 2069 6e74  itMidpoint = int
-000011c0: 0d0a 2020 2020 524b 3333 203d 2069 6e74  ..    RK33 = int
-000011d0: 0d0a 2020 2020 524b 3434 203d 2069 6e74  ..    RK44 = int
-000011e0: 0d0a 2020 2020 524b 3637 203d 2069 6e74  ..    RK67 = int
-000011f0: 0d0a 2020 2020 4f44 4532 3320 3d20 696e  ..    ODE23 = in
-00001200: 740d 0a20 2020 2044 4f50 5249 3520 3d20  t..    DOPRI5 = 
-00001210: 696e 740d 0a20 2020 2044 5645 524b 3620  int..    DVERK6 
-00001220: 3d20 696e 740d 0a0d 0a0d 0a63 6c61 7373  = int......class
-00001230: 2043 726f 7373 5365 6374 696f 6e54 7970   CrossSectionTyp
-00001240: 6528 456e 756d 293a 0d0a 2020 2020 506f  e(Enum):..    Po
-00001250: 6c79 676f 6e20 3d20 696e 740d 0a20 2020  lygon = int..   
-00001260: 2043 6972 6375 6c61 7220 3d20 696e 740d   Circular = int.
-00001270: 0a0d 0a0d 0a63 6c61 7373 204b 6579 436f  .....class KeyCo
-00001280: 6465 2845 6e75 6d29 3a0d 0a20 2020 2053  de(Enum):..    S
-00001290: 5041 4345 203d 2069 6e74 0d0a 2020 2020  PACE = int..    
-000012a0: 454e 5445 5220 3d20 696e 740d 0a20 2020  ENTER = int..   
-000012b0: 2054 4142 203d 2069 6e74 0d0a 2020 2020   TAB = int..    
-000012c0: 4241 434b 5350 4143 4520 3d20 696e 740d  BACKSPACE = int.
-000012d0: 0a20 2020 2052 4947 4854 203d 2069 6e74  .    RIGHT = int
-000012e0: 0d0a 2020 2020 4c45 4654 203d 2069 6e74  ..    LEFT = int
-000012f0: 0d0a 2020 2020 444f 574e 203d 2069 6e74  ..    DOWN = int
-00001300: 0d0a 2020 2020 5550 203d 2069 6e74 0d0a  ..    UP = int..
-00001310: 2020 2020 4631 203d 2069 6e74 0d0a 2020      F1 = int..  
-00001320: 2020 4632 203d 2069 6e74 0d0a 2020 2020    F2 = int..    
-00001330: 4633 203d 2069 6e74 0d0a 2020 2020 4634  F3 = int..    F4
-00001340: 203d 2069 6e74 0d0a 2020 2020 4635 203d   = int..    F5 =
-00001350: 2069 6e74 0d0a 2020 2020 4636 203d 2069   int..    F6 = i
-00001360: 6e74 0d0a 2020 2020 4637 203d 2069 6e74  nt..    F7 = int
-00001370: 0d0a 2020 2020 4638 203d 2069 6e74 0d0a  ..    F8 = int..
-00001380: 2020 2020 4639 203d 2069 6e74 0d0a 2020      F9 = int..  
-00001390: 2020 4631 3020 3d20 696e 740d 0a0d 0a0d    F10 = int.....
-000013a0: 0a63 6c61 7373 204c 696e 6561 7253 6f6c  .class LinearSol
-000013b0: 7665 7254 7970 6528 456e 756d 293a 0d0a  verType(Enum):..
-000013c0: 2020 2020 5f4e 6f6e 6520 3d20 696e 740d      _None = int.
-000013d0: 0a20 2020 2045 5855 6465 6e73 6520 3d20  .    EXUdense = 
-000013e0: 696e 740d 0a20 2020 2045 6967 656e 5370  int..    EigenSp
-000013f0: 6172 7365 203d 2069 6e74 0d0a 2020 2020  arse = int..    
-00001400: 4569 6765 6e53 7061 7273 6553 796d 6d65  EigenSparseSymme
-00001410: 7472 6963 203d 2069 6e74 0d0a 2020 2020  tric = int..    
-00001420: 4569 6765 6e44 656e 7365 203d 2069 6e74  EigenDense = int
-00001430: 0d0a 0d0a 0d0a 636c 6173 7320 436f 6e74  ......class Cont
-00001440: 6163 7454 7970 6549 6e64 6578 2845 6e75  actTypeIndex(Enu
-00001450: 6d29 3a0d 0a20 2020 2049 6e64 6578 5370  m):..    IndexSp
-00001460: 6865 7265 734d 6172 6b65 7242 6173 6564  heresMarkerBased
-00001470: 203d 2069 6e74 0d0a 2020 2020 496e 6465   = int..    Inde
-00001480: 7841 4e43 4643 6162 6c65 3244 203d 2069  xANCFCable2D = i
-00001490: 6e74 0d0a 2020 2020 496e 6465 7854 7269  nt..    IndexTri
-000014a0: 6773 5269 6769 6442 6f64 7942 6173 6564  gsRigidBodyBased
-000014b0: 203d 2069 6e74 0d0a 2020 2020 496e 6465   = int..    Inde
-000014c0: 7845 6e64 4f66 456e 756d 4c69 7374 203d  xEndOfEnumList =
-000014d0: 2069 6e74 0d0a 0d0a 0d0a 636c 6173 7320   int......class 
-000014e0: 4d61 7472 6978 436f 6e74 6169 6e65 723a  MatrixContainer:
-000014f0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00001500: 0a20 2020 2064 6566 2053 6574 5769 7468  .    def SetWith
-00001510: 4465 6e73 654d 6174 7269 7828 7365 6c66  DenseMatrix(self
-00001520: 2c20 7079 4172 7261 793a 2041 7272 6179  , pyArray: Array
-00001530: 4c69 6b65 2c20 7573 6544 656e 7365 4d61  Like, useDenseMa
-00001540: 7472 6978 3d46 616c 7365 2920 2d3e 204e  trix=False) -> N
-00001550: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-00001560: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00001570: 2053 6574 5769 7468 5370 6172 7365 4d61   SetWithSparseMa
-00001580: 7472 6978 4353 5228 7365 6c66 2c20 6e75  trixCSR(self, nu
-00001590: 6d62 6572 4f66 526f 7773 496e 6974 3a20  mberOfRowsInit: 
-000015a0: 696e 742c 206e 756d 6265 724f 6643 6f6c  int, numberOfCol
-000015b0: 756d 6e73 496e 6974 3a20 696e 742c 2070  umnsInit: int, p
-000015c0: 7941 7272 6179 4353 523a 2041 7272 6179  yArrayCSR: Array
-000015d0: 4c69 6b65 2c20 7573 6544 656e 7365 4d61  Like, useDenseMa
-000015e0: 7472 6978 3d54 7275 6529 202d 3e20 4e6f  trix=True) -> No
-000015f0: 6e65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ne: .....    @ov
-00001600: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00001610: 4765 7450 7974 686f 6e4f 626a 6563 7428  GetPythonObject(
-00001620: 7365 6c66 2920 2d3e 2055 6e69 6f6e 5b64  self) -> Union[d
-00001630: 6963 742c 4172 7261 794c 696b 655d 3a20  ict,ArrayLike]: 
-00001640: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00001650: 6164 0d0a 2020 2020 6465 6620 436f 6e76  ad..    def Conv
-00001660: 6572 7432 4465 6e73 654d 6174 7269 7828  ert2DenseMatrix(
-00001670: 7365 6c66 2920 2d3e 2041 7272 6179 4c69  self) -> ArrayLi
-00001680: 6b65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ke: .....    @ov
-00001690: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-000016a0: 5573 6544 656e 7365 4d61 7472 6978 2873  UseDenseMatrix(s
-000016b0: 656c 6629 202d 3e20 626f 6f6c 3a20 2e2e  elf) -> bool: ..
-000016c0: 2e0d 0a0d 0a0d 0a63 6c61 7373 2056 6563  .......class Vec
-000016d0: 746f 7233 444c 6973 743a 0d0a 2020 2020  tor3DList:..    
-000016e0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-000016f0: 6566 2041 7070 656e 6428 7365 6c66 2c20  ef Append(self, 
-00001700: 7079 4172 7261 793a 205b 666c 6f61 742c  pyArray: [float,
-00001710: 666c 6f61 742c 666c 6f61 745d 2920 2d3e  float,float]) ->
-00001720: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-00001730: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00001740: 6566 2047 6574 5079 7468 6f6e 4f62 6a65  ef GetPythonObje
-00001750: 6374 2873 656c 6629 202d 3e20 4c69 7374  ct(self) -> List
-00001760: 5b5b 666c 6f61 742c 666c 6f61 742c 666c  [[float,float,fl
-00001770: 6f61 745d 5d3a 202e 2e2e 0d0a 0d0a 0d0a  oat]]: .........
-00001780: 636c 6173 7320 5665 6374 6f72 3244 4c69  class Vector2DLi
-00001790: 7374 3a0d 0a20 2020 2040 6f76 6572 6c6f  st:..    @overlo
-000017a0: 6164 0d0a 2020 2020 6465 6620 4170 7065  ad..    def Appe
-000017b0: 6e64 2873 656c 662c 2070 7941 7272 6179  nd(self, pyArray
-000017c0: 3a20 5b66 6c6f 6174 2c66 6c6f 6174 5d29  : [float,float])
-000017d0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20   -> None: ..... 
-000017e0: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-000017f0: 2020 6465 6620 4765 7450 7974 686f 6e4f    def GetPythonO
-00001800: 626a 6563 7428 7365 6c66 2920 2d3e 204c  bject(self) -> L
-00001810: 6973 745b 5b66 6c6f 6174 2c66 6c6f 6174  ist[[float,float
-00001820: 5d5d 3a20 2e2e 2e0d 0a0d 0a0d 0a63 6c61  ]]: .........cla
-00001830: 7373 2056 6563 746f 7236 444c 6973 743a  ss Vector6DList:
-00001840: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00001850: 0a20 2020 2064 6566 2041 7070 656e 6428  .    def Append(
-00001860: 7365 6c66 2c20 7079 4172 7261 793a 205b  self, pyArray: [
-00001870: 666c 6f61 742c 666c 6f61 742c 666c 6f61  float,float,floa
-00001880: 742c 666c 6f61 742c 666c 6f61 742c 666c  t,float,float,fl
-00001890: 6f61 745d 2920 2d3e 204e 6f6e 653a 202e  oat]) -> None: .
-000018a0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-000018b0: 640d 0a20 2020 2064 6566 2047 6574 5079  d..    def GetPy
-000018c0: 7468 6f6e 4f62 6a65 6374 2873 656c 6629  thonObject(self)
-000018d0: 202d 3e20 4c69 7374 5b5b 666c 6f61 742c   -> List[[float,
-000018e0: 666c 6f61 742c 666c 6f61 742c 666c 6f61  float,float,floa
-000018f0: 742c 666c 6f61 742c 666c 6f61 745d 5d3a  t,float,float]]:
-00001900: 202e 2e2e 0d0a 0d0a 0d0a 636c 6173 7320   .........class 
-00001910: 4d61 7472 6978 3344 4c69 7374 3a0d 0a20  Matrix3DList:.. 
-00001920: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00001930: 2020 6465 6620 4170 7065 6e64 2873 656c    def Append(sel
-00001940: 662c 2070 7941 7272 6179 3a20 4e44 4172  f, pyArray: NDAr
-00001950: 7261 795b 5368 6170 6532 445b 332c 335d  ray[Shape2D[3,3]
-00001960: 2c20 666c 6f61 745d 2920 2d3e 204e 6f6e  , float]) -> Non
-00001970: 653a 202e 2e2e 0d0a 2020 2020 406f 7665  e: .....    @ove
-00001980: 726c 6f61 640d 0a20 2020 2064 6566 2047  rload..    def G
-00001990: 6574 5079 7468 6f6e 4f62 6a65 6374 2873  etPythonObject(s
-000019a0: 656c 6629 202d 3e20 4c69 7374 5b4e 4441  elf) -> List[NDA
-000019b0: 7272 6179 5b53 6861 7065 3244 5b33 2c33  rray[Shape2D[3,3
-000019c0: 5d2c 2066 6c6f 6174 5d5d 3a20 2e2e 2e0d  ], float]]: ....
-000019d0: 0a0d 0a0d 0a63 6c61 7373 204d 6174 7269  .....class Matri
-000019e0: 7836 444c 6973 743a 0d0a 2020 2020 406f  x6DList:..    @o
-000019f0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00001a00: 2041 7070 656e 6428 7365 6c66 2c20 7079   Append(self, py
-00001a10: 4172 7261 793a 204e 4441 7272 6179 5b53  Array: NDArray[S
-00001a20: 6861 7065 3244 5b36 2c36 5d2c 2066 6c6f  hape2D[6,6], flo
-00001a30: 6174 5d29 202d 3e20 4e6f 6e65 3a20 2e2e  at]) -> None: ..
-00001a40: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00001a50: 0d0a 2020 2020 6465 6620 4765 7450 7974  ..    def GetPyt
-00001a60: 686f 6e4f 626a 6563 7428 7365 6c66 2920  honObject(self) 
-00001a70: 2d3e 204c 6973 745b 4e44 4172 7261 795b  -> List[NDArray[
-00001a80: 5368 6170 6532 445b 362c 365d 2c20 666c  Shape2D[6,6], fl
-00001a90: 6f61 745d 5d3a 202e 2e2e 0d0a 0d0a 0d0a  oat]]: .........
-00001aa0: 636c 6173 7320 4265 616d 5365 6374 696f  class BeamSectio
-00001ab0: 6e3a 0d0a 2020 2020 6461 6d70 696e 674d  n:..    dampingM
-00001ac0: 6174 7269 783a 2041 7272 6179 4c69 6b65  atrix: ArrayLike
-00001ad0: 0d0a 2020 2020 696e 6572 7469 613a 2041  ..    inertia: A
-00001ae0: 7272 6179 4c69 6b65 0d0a 2020 2020 6d61  rrayLike..    ma
-00001af0: 7373 5065 724c 656e 6774 683a 2066 6c6f  ssPerLength: flo
-00001b00: 6174 0d0a 2020 2020 7374 6966 666e 6573  at..    stiffnes
-00001b10: 734d 6174 7269 783a 2041 7272 6179 4c69  sMatrix: ArrayLi
-00001b20: 6b65 0d0a 0d0a 0d0a 636c 6173 7320 4265  ke......class Be
-00001b30: 616d 5365 6374 696f 6e47 656f 6d65 7472  amSectionGeometr
-00001b40: 793a 0d0a 2020 2020 6372 6f73 7353 6563  y:..    crossSec
-00001b50: 7469 6f6e 5261 6469 7573 593a 2066 6c6f  tionRadiusY: flo
-00001b60: 6174 0d0a 2020 2020 6372 6f73 7353 6563  at..    crossSec
-00001b70: 7469 6f6e 5261 6469 7573 5a3a 2066 6c6f  tionRadiusZ: flo
-00001b80: 6174 0d0a 2020 2020 6372 6f73 7353 6563  at..    crossSec
-00001b90: 7469 6f6e 5479 7065 3a20 4372 6f73 7353  tionType: CrossS
-00001ba0: 6563 7469 6f6e 5479 7065 0d0a 2020 2020  ectionType..    
-00001bb0: 706f 6c79 676f 6e61 6c50 6f69 6e74 733a  polygonalPoints:
-00001bc0: 2056 6563 746f 7232 444c 6973 740d 0a0d   Vector2DList...
-00001bd0: 0a0d 0a63 6c61 7373 2053 6f6c 7574 696f  ...class Solutio
-00001be0: 6e53 6574 7469 6e67 733a 0d0a 2020 2020  nSettings:..    
-00001bf0: 6170 7065 6e64 546f 4669 6c65 3a20 626f  appendToFile: bo
-00001c00: 6f6c 0d0a 2020 2020 6269 6e61 7279 536f  ol..    binarySo
-00001c10: 6c75 7469 6f6e 4669 6c65 3a20 626f 6f6c  lutionFile: bool
-00001c20: 0d0a 2020 2020 636f 6f72 6469 6e61 7465  ..    coordinate
-00001c30: 7353 6f6c 7574 696f 6e46 696c 654e 616d  sSolutionFileNam
-00001c40: 653a 2073 7472 0d0a 2020 2020 6578 706f  e: str..    expo
-00001c50: 7274 4163 6365 6c65 7261 7469 6f6e 733a  rtAccelerations:
-00001c60: 2062 6f6f 6c0d 0a20 2020 2065 7870 6f72   bool..    expor
-00001c70: 7441 6c67 6562 7261 6963 436f 6f72 6469  tAlgebraicCoordi
-00001c80: 6e61 7465 733a 2062 6f6f 6c0d 0a20 2020  nates: bool..   
-00001c90: 2065 7870 6f72 7444 6174 6143 6f6f 7264   exportDataCoord
-00001ca0: 696e 6174 6573 3a20 626f 6f6c 0d0a 2020  inates: bool..  
-00001cb0: 2020 6578 706f 7274 4f44 4531 5665 6c6f    exportODE1Velo
-00001cc0: 6369 7469 6573 3a20 626f 6f6c 0d0a 2020  cities: bool..  
-00001cd0: 2020 6578 706f 7274 5665 6c6f 6369 7469    exportVelociti
-00001ce0: 6573 3a20 626f 6f6c 0d0a 2020 2020 666c  es: bool..    fl
-00001cf0: 7573 6846 696c 6573 444f 463a 2069 6e74  ushFilesDOF: int
-00001d00: 0d0a 2020 2020 666c 7573 6846 696c 6573  ..    flushFiles
-00001d10: 496d 6d65 6469 6174 656c 793a 2062 6f6f  Immediately: boo
-00001d20: 6c0d 0a20 2020 206f 7574 7075 7450 7265  l..    outputPre
-00001d30: 6369 7369 6f6e 3a20 696e 740d 0a20 2020  cision: int..   
-00001d40: 2072 6563 6f72 6449 6d61 6765 7349 6e74   recordImagesInt
-00001d50: 6572 7661 6c3a 2066 6c6f 6174 0d0a 2020  erval: float..  
-00001d60: 2020 7265 7374 6172 7446 696c 654e 616d    restartFileNam
-00001d70: 653a 2073 7472 0d0a 2020 2020 7265 7374  e: str..    rest
-00001d80: 6172 7457 7269 7465 5065 7269 6f64 3a20  artWritePeriod: 
-00001d90: 666c 6f61 740d 0a20 2020 2073 656e 736f  float..    senso
-00001da0: 7273 4170 7065 6e64 546f 4669 6c65 3a20  rsAppendToFile: 
-00001db0: 626f 6f6c 0d0a 2020 2020 7365 6e73 6f72  bool..    sensor
-00001dc0: 7353 746f 7265 416e 6457 7269 7465 4669  sStoreAndWriteFi
-00001dd0: 6c65 733a 2062 6f6f 6c0d 0a20 2020 2073  les: bool..    s
-00001de0: 656e 736f 7273 5772 6974 6546 696c 6546  ensorsWriteFileF
-00001df0: 6f6f 7465 723a 2062 6f6f 6c0d 0a20 2020  ooter: bool..   
-00001e00: 2073 656e 736f 7273 5772 6974 6546 696c   sensorsWriteFil
-00001e10: 6548 6561 6465 723a 2062 6f6f 6c0d 0a20  eHeader: bool.. 
-00001e20: 2020 2073 656e 736f 7273 5772 6974 6550     sensorsWriteP
-00001e30: 6572 696f 643a 2066 6c6f 6174 0d0a 2020  eriod: float..  
-00001e40: 2020 736f 6c75 7469 6f6e 496e 666f 726d    solutionInform
-00001e50: 6174 696f 6e3a 2073 7472 0d0a 2020 2020  ation: str..    
-00001e60: 736f 6c75 7469 6f6e 5772 6974 6550 6572  solutionWritePer
-00001e70: 696f 643a 2066 6c6f 6174 0d0a 2020 2020  iod: float..    
-00001e80: 736f 6c76 6572 496e 666f 726d 6174 696f  solverInformatio
-00001e90: 6e46 696c 654e 616d 653a 2073 7472 0d0a  nFileName: str..
-00001ea0: 2020 2020 7772 6974 6546 696c 6546 6f6f      writeFileFoo
-00001eb0: 7465 723a 2062 6f6f 6c0d 0a20 2020 2077  ter: bool..    w
-00001ec0: 7269 7465 4669 6c65 4865 6164 6572 3a20  riteFileHeader: 
-00001ed0: 626f 6f6c 0d0a 2020 2020 7772 6974 6549  bool..    writeI
-00001ee0: 6e69 7469 616c 5661 6c75 6573 3a20 626f  nitialValues: bo
-00001ef0: 6f6c 0d0a 2020 2020 7772 6974 6552 6573  ol..    writeRes
-00001f00: 7461 7274 4669 6c65 3a20 626f 6f6c 0d0a  tartFile: bool..
-00001f10: 2020 2020 7772 6974 6553 6f6c 7574 696f      writeSolutio
-00001f20: 6e54 6f46 696c 653a 2062 6f6f 6c0d 0a0d  nToFile: bool...
-00001f30: 0a0d 0a63 6c61 7373 204e 756d 6572 6963  ...class Numeric
-00001f40: 616c 4469 6666 6572 656e 7469 6174 696f  alDifferentiatio
-00001f50: 6e53 6574 7469 6e67 733a 0d0a 2020 2020  nSettings:..    
-00001f60: 6164 6452 6566 6572 656e 6365 436f 6f72  addReferenceCoor
-00001f70: 6469 6e61 7465 7354 6f45 7073 696c 6f6e  dinatesToEpsilon
-00001f80: 3a20 626f 6f6c 0d0a 2020 2020 646f 5379  : bool..    doSy
-00001f90: 7374 656d 5769 6465 4469 6666 6572 656e  stemWideDifferen
-00001fa0: 7469 6174 696f 6e3a 2062 6f6f 6c0d 0a20  tiation: bool.. 
-00001fb0: 2020 2066 6f72 4145 3a20 626f 6f6c 0d0a     forAE: bool..
-00001fc0: 2020 2020 666f 724f 4445 323a 2062 6f6f      forODE2: boo
-00001fd0: 6c0d 0a20 2020 2066 6f72 4f44 4532 636f  l..    forODE2co
-00001fe0: 6e6e 6563 746f 7273 3a20 626f 6f6c 0d0a  nnectors: bool..
-00001ff0: 2020 2020 6a61 636f 6269 616e 436f 6e6e      jacobianConn
-00002000: 6563 746f 7244 6572 6976 6174 6976 653a  ectorDerivative:
-00002010: 2062 6f6f 6c0d 0a20 2020 206d 696e 696d   bool..    minim
-00002020: 756d 436f 6f72 6469 6e61 7465 5369 7a65  umCoordinateSize
-00002030: 3a20 666c 6f61 740d 0a20 2020 2072 656c  : float..    rel
-00002040: 6174 6976 6545 7073 696c 6f6e 3a20 666c  ativeEpsilon: fl
-00002050: 6f61 740d 0a0d 0a0d 0a63 6c61 7373 2044  oat......class D
-00002060: 6973 636f 6e74 696e 756f 7573 5365 7474  iscontinuousSett
-00002070: 696e 6773 3a0d 0a20 2020 2069 676e 6f72  ings:..    ignor
-00002080: 654d 6178 4974 6572 6174 696f 6e73 3a20  eMaxIterations: 
-00002090: 626f 6f6c 0d0a 2020 2020 6974 6572 6174  bool..    iterat
-000020a0: 696f 6e54 6f6c 6572 616e 6365 3a20 666c  ionTolerance: fl
-000020b0: 6f61 740d 0a20 2020 206d 6178 4974 6572  oat..    maxIter
-000020c0: 6174 696f 6e73 3a20 696e 740d 0a0d 0a0d  ations: int.....
-000020d0: 0a63 6c61 7373 204e 6577 746f 6e53 6574  .class NewtonSet
-000020e0: 7469 6e67 733a 0d0a 2020 2020 6e75 6d65  tings:..    nume
-000020f0: 7269 6361 6c44 6966 6665 7265 6e74 6961  ricalDifferentia
-00002100: 7469 6f6e 3a20 4e75 6d65 7269 6361 6c44  tion: NumericalD
-00002110: 6966 6665 7265 6e74 6961 7469 6f6e 5365  ifferentiationSe
-00002120: 7474 696e 6773 0d0a 2020 2020 6162 736f  ttings..    abso
-00002130: 6c75 7465 546f 6c65 7261 6e63 653a 2066  luteTolerance: f
-00002140: 6c6f 6174 0d0a 2020 2020 6164 6170 7449  loat..    adaptI
-00002150: 6e69 7469 616c 5265 7369 6475 616c 3a20  nitialResidual: 
-00002160: 626f 6f6c 0d0a 2020 2020 6d61 7869 6d75  bool..    maximu
-00002170: 6d53 6f6c 7574 696f 6e4e 6f72 6d3a 2066  mSolutionNorm: f
-00002180: 6c6f 6174 0d0a 2020 2020 6d61 7849 7465  loat..    maxIte
-00002190: 7261 7469 6f6e 733a 2069 6e74 0d0a 2020  rations: int..  
-000021a0: 2020 6d61 784d 6f64 6966 6965 644e 6577    maxModifiedNew
-000021b0: 746f 6e49 7465 7261 7469 6f6e 733a 2069  tonIterations: i
-000021c0: 6e74 0d0a 2020 2020 6d61 784d 6f64 6966  nt..    maxModif
-000021d0: 6965 644e 6577 746f 6e52 6573 7461 7274  iedNewtonRestart
-000021e0: 4974 6572 6174 696f 6e73 3a20 696e 740d  Iterations: int.
-000021f0: 0a20 2020 206d 6f64 6966 6965 644e 6577  .    modifiedNew
-00002200: 746f 6e43 6f6e 7472 6163 7469 7669 7479  tonContractivity
-00002210: 3a20 666c 6f61 740d 0a20 2020 206d 6f64  : float..    mod
-00002220: 6966 6965 644e 6577 746f 6e4a 6163 5570  ifiedNewtonJacUp
-00002230: 6461 7465 5065 7253 7465 703a 2062 6f6f  datePerStep: boo
-00002240: 6c0d 0a20 2020 206e 6577 746f 6e52 6573  l..    newtonRes
-00002250: 6964 7561 6c4d 6f64 653a 2069 6e74 0d0a  idualMode: int..
-00002260: 2020 2020 7265 6c61 7469 7665 546f 6c65      relativeTole
-00002270: 7261 6e63 653a 2066 6c6f 6174 0d0a 2020  rance: float..  
-00002280: 2020 7573 654d 6f64 6966 6965 644e 6577    useModifiedNew
-00002290: 746f 6e3a 2062 6f6f 6c0d 0a20 2020 2075  ton: bool..    u
-000022a0: 7365 4e65 7774 6f6e 536f 6c76 6572 3a20  seNewtonSolver: 
-000022b0: 626f 6f6c 0d0a 2020 2020 7765 6967 6874  bool..    weight
-000022c0: 546f 6c65 7261 6e63 6550 6572 436f 6f72  TolerancePerCoor
-000022d0: 6469 6e61 7465 3a20 626f 6f6c 0d0a 0d0a  dinate: bool....
-000022e0: 0d0a 636c 6173 7320 4765 6e65 7261 6c69  ..class Generali
-000022f0: 7a65 6441 6c70 6861 5365 7474 696e 6773  zedAlphaSettings
-00002300: 3a0d 0a20 2020 2063 6f6d 7075 7465 496e  :..    computeIn
-00002310: 6974 6961 6c41 6363 656c 6572 6174 696f  itialAcceleratio
-00002320: 6e73 3a20 626f 6f6c 0d0a 2020 2020 6c69  ns: bool..    li
-00002330: 6547 726f 7570 4164 6454 616e 6765 6e74  eGroupAddTangent
-00002340: 4f70 6572 6174 6f72 3a20 626f 6f6c 0d0a  Operator: bool..
-00002350: 2020 2020 6e65 776d 6172 6b42 6574 613a      newmarkBeta:
-00002360: 2066 6c6f 6174 0d0a 2020 2020 6e65 776d   float..    newm
-00002370: 6172 6b47 616d 6d61 3a20 666c 6f61 740d  arkGamma: float.
-00002380: 0a20 2020 2072 6573 6574 4163 6365 6c65  .    resetAccele
-00002390: 7261 7469 6f6e 733a 2062 6f6f 6c0d 0a20  rations: bool.. 
-000023a0: 2020 2073 7065 6374 7261 6c52 6164 6975     spectralRadiu
-000023b0: 733a 2066 6c6f 6174 0d0a 2020 2020 7573  s: float..    us
-000023c0: 6549 6e64 6578 3243 6f6e 7374 7261 696e  eIndex2Constrain
-000023d0: 7473 3a20 626f 6f6c 0d0a 2020 2020 7573  ts: bool..    us
-000023e0: 654e 6577 6d61 726b 3a20 626f 6f6c 0d0a  eNewmark: bool..
-000023f0: 0d0a 0d0a 636c 6173 7320 4578 706c 6963  ....class Explic
-00002400: 6974 496e 7465 6772 6174 696f 6e53 6574  itIntegrationSet
-00002410: 7469 6e67 733a 0d0a 2020 2020 636f 6d70  tings:..    comp
-00002420: 7574 6545 6e64 4f66 5374 6570 4163 6365  uteEndOfStepAcce
-00002430: 6c65 7261 7469 6f6e 733a 2062 6f6f 6c0d  lerations: bool.
-00002440: 0a20 2020 2063 6f6d 7075 7465 4d61 7373  .    computeMass
-00002450: 4d61 7472 6978 496e 7665 7273 6550 6572  MatrixInversePer
-00002460: 426f 6479 3a20 626f 6f6c 0d0a 2020 2020  Body: bool..    
-00002470: 6479 6e61 6d69 6353 6f6c 7665 7254 7970  dynamicSolverTyp
-00002480: 653a 2044 796e 616d 6963 536f 6c76 6572  e: DynamicSolver
-00002490: 5479 7065 0d0a 2020 2020 656c 696d 696e  Type..    elimin
-000024a0: 6174 6543 6f6e 7374 7261 696e 7473 3a20  ateConstraints: 
-000024b0: 626f 6f6c 0d0a 2020 2020 7573 654c 6965  bool..    useLie
-000024c0: 4772 6f75 7049 6e74 6567 7261 7469 6f6e  GroupIntegration
-000024d0: 3a20 626f 6f6c 0d0a 0d0a 0d0a 636c 6173  : bool......clas
-000024e0: 7320 5469 6d65 496e 7465 6772 6174 696f  s TimeIntegratio
-000024f0: 6e53 6574 7469 6e67 733a 0d0a 2020 2020  nSettings:..    
-00002500: 6469 7363 6f6e 7469 6e75 6f75 733a 2044  discontinuous: D
-00002510: 6973 636f 6e74 696e 756f 7573 5365 7474  iscontinuousSett
-00002520: 696e 6773 0d0a 2020 2020 6578 706c 6963  ings..    explic
-00002530: 6974 496e 7465 6772 6174 696f 6e3a 2045  itIntegration: E
-00002540: 7870 6c69 6369 7449 6e74 6567 7261 7469  xplicitIntegrati
-00002550: 6f6e 5365 7474 696e 6773 0d0a 2020 2020  onSettings..    
-00002560: 6765 6e65 7261 6c69 7a65 6441 6c70 6861  generalizedAlpha
-00002570: 3a20 4765 6e65 7261 6c69 7a65 6441 6c70  : GeneralizedAlp
-00002580: 6861 5365 7474 696e 6773 0d0a 2020 2020  haSettings..    
-00002590: 6e65 7774 6f6e 3a20 4e65 7774 6f6e 5365  newton: NewtonSe
-000025a0: 7474 696e 6773 0d0a 2020 2020 6162 736f  ttings..    abso
-000025b0: 6c75 7465 546f 6c65 7261 6e63 653a 2066  luteTolerance: f
-000025c0: 6c6f 6174 0d0a 2020 2020 6164 6170 7469  loat..    adapti
-000025d0: 7665 5374 6570 3a20 626f 6f6c 0d0a 2020  veStep: bool..  
-000025e0: 2020 6164 6170 7469 7665 5374 6570 4465    adaptiveStepDe
-000025f0: 6372 6561 7365 3a20 666c 6f61 740d 0a20  crease: float.. 
-00002600: 2020 2061 6461 7074 6976 6553 7465 7049     adaptiveStepI
-00002610: 6e63 7265 6173 653a 2066 6c6f 6174 0d0a  ncrease: float..
-00002620: 2020 2020 6164 6170 7469 7665 5374 6570      adaptiveStep
-00002630: 5265 636f 7665 7279 4974 6572 6174 696f  RecoveryIteratio
-00002640: 6e73 3a20 696e 740d 0a20 2020 2061 6461  ns: int..    ada
-00002650: 7074 6976 6553 7465 7052 6563 6f76 6572  ptiveStepRecover
-00002660: 7953 7465 7073 3a20 696e 740d 0a20 2020  ySteps: int..   
-00002670: 2061 7574 6f6d 6174 6963 5374 6570 5369   automaticStepSi
-00002680: 7a65 3a20 626f 6f6c 0d0a 2020 2020 636f  ze: bool..    co
-00002690: 6d70 7574 654c 6f61 6473 4a61 636f 6269  mputeLoadsJacobi
-000026a0: 616e 3a20 696e 740d 0a20 2020 2065 6e64  an: int..    end
-000026b0: 5469 6d65 3a20 666c 6f61 740d 0a20 2020  Time: float..   
-000026c0: 2069 6e69 7469 616c 5374 6570 5369 7a65   initialStepSize
-000026d0: 3a20 666c 6f61 740d 0a20 2020 206d 696e  : float..    min
-000026e0: 696d 756d 5374 6570 5369 7a65 3a20 666c  imumStepSize: fl
-000026f0: 6f61 740d 0a20 2020 206e 756d 6265 724f  oat..    numberO
-00002700: 6653 7465 7073 3a20 696e 740d 0a20 2020  fSteps: int..   
-00002710: 2072 6561 6c74 696d 6546 6163 746f 723a   realtimeFactor:
-00002720: 2066 6c6f 6174 0d0a 2020 2020 7265 616c   float..    real
-00002730: 7469 6d65 5761 6974 4d69 6372 6f73 6563  timeWaitMicrosec
-00002740: 6f6e 6473 3a20 696e 740d 0a20 2020 2072  onds: int..    r
-00002750: 656c 6174 6976 6554 6f6c 6572 616e 6365  elativeTolerance
-00002760: 3a20 666c 6f61 740d 0a20 2020 2072 6575  : float..    reu
-00002770: 7365 436f 6e73 7461 6e74 4d61 7373 4d61  seConstantMassMa
-00002780: 7472 6978 3a20 626f 6f6c 0d0a 2020 2020  trix: bool..    
-00002790: 7369 6d75 6c61 7465 496e 5265 616c 7469  simulateInRealti
-000027a0: 6d65 3a20 626f 6f6c 0d0a 2020 2020 7374  me: bool..    st
-000027b0: 6172 7454 696d 653a 2066 6c6f 6174 0d0a  artTime: float..
-000027c0: 2020 2020 7374 6570 496e 666f 726d 6174      stepInformat
-000027d0: 696f 6e3a 2069 6e74 0d0a 2020 2020 7374  ion: int..    st
-000027e0: 6570 5369 7a65 4d61 7849 6e63 7265 6173  epSizeMaxIncreas
-000027f0: 653a 2066 6c6f 6174 0d0a 2020 2020 7374  e: float..    st
-00002800: 6570 5369 7a65 5361 6665 7479 3a20 666c  epSizeSafety: fl
-00002810: 6f61 740d 0a20 2020 2076 6572 626f 7365  oat..    verbose
-00002820: 4d6f 6465 3a20 696e 740d 0a20 2020 2076  Mode: int..    v
-00002830: 6572 626f 7365 4d6f 6465 4669 6c65 3a20  erboseModeFile: 
-00002840: 696e 740d 0a0d 0a0d 0a63 6c61 7373 2053  int......class S
-00002850: 7461 7469 6353 6f6c 7665 7253 6574 7469  taticSolverSetti
-00002860: 6e67 733a 0d0a 2020 2020 6469 7363 6f6e  ngs:..    discon
-00002870: 7469 6e75 6f75 733a 2044 6973 636f 6e74  tinuous: Discont
-00002880: 696e 756f 7573 5365 7474 696e 6773 0d0a  inuousSettings..
-00002890: 2020 2020 6e65 7774 6f6e 3a20 4e65 7774      newton: Newt
-000028a0: 6f6e 5365 7474 696e 6773 0d0a 2020 2020  onSettings..    
-000028b0: 6164 6170 7469 7665 5374 6570 3a20 626f  adaptiveStep: bo
-000028c0: 6f6c 0d0a 2020 2020 6164 6170 7469 7665  ol..    adaptive
-000028d0: 5374 6570 4465 6372 6561 7365 3a20 666c  StepDecrease: fl
-000028e0: 6f61 740d 0a20 2020 2061 6461 7074 6976  oat..    adaptiv
-000028f0: 6553 7465 7049 6e63 7265 6173 653a 2066  eStepIncrease: f
-00002900: 6c6f 6174 0d0a 2020 2020 6164 6170 7469  loat..    adapti
-00002910: 7665 5374 6570 5265 636f 7665 7279 4974  veStepRecoveryIt
-00002920: 6572 6174 696f 6e73 3a20 696e 740d 0a20  erations: int.. 
-00002930: 2020 2061 6461 7074 6976 6553 7465 7052     adaptiveStepR
-00002940: 6563 6f76 6572 7953 7465 7073 3a20 696e  ecoverySteps: in
-00002950: 740d 0a20 2020 2063 6f6d 7075 7465 4c6f  t..    computeLo
-00002960: 6164 734a 6163 6f62 6961 6e3a 2062 6f6f  adsJacobian: boo
-00002970: 6c0d 0a20 2020 2063 6f6e 7374 7261 696e  l..    constrain
-00002980: 4f44 4531 636f 6f72 6469 6e61 7465 733a  ODE1coordinates:
-00002990: 2062 6f6f 6c0d 0a20 2020 206c 6f61 6453   bool..    loadS
-000029a0: 7465 7044 7572 6174 696f 6e3a 2066 6c6f  tepDuration: flo
-000029b0: 6174 0d0a 2020 2020 6c6f 6164 5374 6570  at..    loadStep
-000029c0: 4765 6f6d 6574 7269 633a 2062 6f6f 6c0d  Geometric: bool.
-000029d0: 0a20 2020 206c 6f61 6453 7465 7047 656f  .    loadStepGeo
-000029e0: 6d65 7472 6963 5261 6e67 653a 2066 6c6f  metricRange: flo
-000029f0: 6174 0d0a 2020 2020 6c6f 6164 5374 6570  at..    loadStep
-00002a00: 5374 6172 743a 2066 6c6f 6174 0d0a 2020  Start: float..  
-00002a10: 2020 6d69 6e69 6d75 6d53 7465 7053 697a    minimumStepSiz
-00002a20: 653a 2066 6c6f 6174 0d0a 2020 2020 6e75  e: float..    nu
-00002a30: 6d62 6572 4f66 4c6f 6164 5374 6570 733a  mberOfLoadSteps:
-00002a40: 2069 6e74 0d0a 2020 2020 7374 6162 696c   int..    stabil
-00002a50: 697a 6572 4f44 4532 7465 726d 3a20 666c  izerODE2term: fl
-00002a60: 6f61 740d 0a20 2020 2073 7465 7049 6e66  oat..    stepInf
-00002a70: 6f72 6d61 7469 6f6e 3a20 696e 740d 0a20  ormation: int.. 
-00002a80: 2020 2075 7365 4c6f 6164 4661 6374 6f72     useLoadFactor
-00002a90: 3a20 626f 6f6c 0d0a 2020 2020 7665 7262  : bool..    verb
-00002aa0: 6f73 654d 6f64 653a 2069 6e74 0d0a 2020  oseMode: int..  
-00002ab0: 2020 7665 7262 6f73 654d 6f64 6546 696c    verboseModeFil
-00002ac0: 653a 2069 6e74 0d0a 0d0a 0d0a 636c 6173  e: int......clas
-00002ad0: 7320 4c69 6e65 6172 536f 6c76 6572 5365  s LinearSolverSe
-00002ae0: 7474 696e 6773 3a0d 0a20 2020 2069 676e  ttings:..    ign
-00002af0: 6f72 6553 696e 6775 6c61 724a 6163 6f62  oreSingularJacob
-00002b00: 6961 6e3a 2062 6f6f 6c0d 0a20 2020 2070  ian: bool..    p
-00002b10: 6976 6f74 5468 7265 7368 6f6c 643a 2066  ivotThreshold: f
-00002b20: 6c6f 6174 0d0a 2020 2020 7265 7573 6541  loat..    reuseA
-00002b30: 6e61 6c79 7a65 6450 6174 7465 726e 3a20  nalyzedPattern: 
-00002b40: 626f 6f6c 0d0a 2020 2020 7368 6f77 4361  bool..    showCa
-00002b50: 7573 696e 6749 7465 6d73 3a20 626f 6f6c  usingItems: bool
-00002b60: 0d0a 0d0a 0d0a 636c 6173 7320 5061 7261  ......class Para
-00002b70: 6c6c 656c 3a0d 0a20 2020 206d 756c 7469  llel:..    multi
-00002b80: 7468 7265 6164 6564 4c4c 696d 6974 4a61  threadedLLimitJa
-00002b90: 636f 6269 616e 733a 2069 6e74 0d0a 2020  cobians: int..  
-00002ba0: 2020 6d75 6c74 6974 6872 6561 6465 644c    multithreadedL
-00002bb0: 4c69 6d69 744c 6f61 6473 3a20 696e 740d  LimitLoads: int.
-00002bc0: 0a20 2020 206d 756c 7469 7468 7265 6164  .    multithread
-00002bd0: 6564 4c4c 696d 6974 4d61 7373 4d61 7472  edLLimitMassMatr
-00002be0: 6963 6573 3a20 696e 740d 0a20 2020 206d  ices: int..    m
-00002bf0: 756c 7469 7468 7265 6164 6564 4c4c 696d  ultithreadedLLim
-00002c00: 6974 5265 7369 6475 616c 733a 2069 6e74  itResiduals: int
-00002c10: 0d0a 2020 2020 6e75 6d62 6572 4f66 5468  ..    numberOfTh
-00002c20: 7265 6164 733a 2069 6e74 0d0a 2020 2020  reads: int..    
-00002c30: 7461 736b 5370 6c69 744d 696e 4974 656d  taskSplitMinItem
-00002c40: 733a 2069 6e74 0d0a 2020 2020 7461 736b  s: int..    task
-00002c50: 5370 6c69 7454 6173 6b73 5065 7254 6872  SplitTasksPerThr
-00002c60: 6561 643a 2069 6e74 0d0a 0d0a 0d0a 636c  ead: int......cl
-00002c70: 6173 7320 5369 6d75 6c61 7469 6f6e 5365  ass SimulationSe
-00002c80: 7474 696e 6773 3a0d 0a20 2020 206c 696e  ttings:..    lin
-00002c90: 6561 7253 6f6c 7665 7253 6574 7469 6e67  earSolverSetting
-00002ca0: 733a 204c 696e 6561 7253 6f6c 7665 7253  s: LinearSolverS
-00002cb0: 6574 7469 6e67 730d 0a20 2020 2070 6172  ettings..    par
-00002cc0: 616c 6c65 6c3a 2050 6172 616c 6c65 6c0d  allel: Parallel.
-00002cd0: 0a20 2020 2073 6f6c 7574 696f 6e53 6574  .    solutionSet
-00002ce0: 7469 6e67 733a 2053 6f6c 7574 696f 6e53  tings: SolutionS
-00002cf0: 6574 7469 6e67 730d 0a20 2020 2073 7461  ettings..    sta
-00002d00: 7469 6353 6f6c 7665 723a 2053 7461 7469  ticSolver: Stati
-00002d10: 6353 6f6c 7665 7253 6574 7469 6e67 730d  cSolverSettings.
-00002d20: 0a20 2020 2074 696d 6549 6e74 6567 7261  .    timeIntegra
-00002d30: 7469 6f6e 3a20 5469 6d65 496e 7465 6772  tion: TimeIntegr
-00002d40: 6174 696f 6e53 6574 7469 6e67 730d 0a20  ationSettings.. 
-00002d50: 2020 2063 6c65 616e 5570 4d65 6d6f 7279     cleanUpMemory
-00002d60: 3a20 626f 6f6c 0d0a 2020 2020 6469 7370  : bool..    disp
-00002d70: 6c61 7943 6f6d 7075 7461 7469 6f6e 5469  layComputationTi
-00002d80: 6d65 3a20 626f 6f6c 0d0a 2020 2020 6469  me: bool..    di
-00002d90: 7370 6c61 7947 6c6f 6261 6c54 696d 6572  splayGlobalTimer
-00002da0: 733a 2062 6f6f 6c0d 0a20 2020 2064 6973  s: bool..    dis
-00002db0: 706c 6179 5374 6174 6973 7469 6373 3a20  playStatistics: 
-00002dc0: 626f 6f6c 0d0a 2020 2020 6c69 6e65 6172  bool..    linear
-00002dd0: 536f 6c76 6572 5479 7065 3a20 4c69 6e65  SolverType: Line
-00002de0: 6172 536f 6c76 6572 5479 7065 0d0a 2020  arSolverType..  
-00002df0: 2020 6f75 7470 7574 5072 6563 6973 696f    outputPrecisio
-00002e00: 6e3a 2069 6e74 0d0a 2020 2020 7061 7573  n: int..    paus
-00002e10: 6541 6674 6572 4561 6368 5374 6570 3a20  eAfterEachStep: 
-00002e20: 626f 6f6c 0d0a 0d0a 0d0a 636c 6173 7320  bool......class 
-00002e30: 5653 6574 7469 6e67 7347 656e 6572 616c  VSettingsGeneral
-00002e40: 3a0d 0a20 2020 2061 7574 6f46 6974 5363  :..    autoFitSc
-00002e50: 656e 653a 2062 6f6f 6c0d 0a20 2020 2061  ene: bool..    a
-00002e60: 7865 7354 696c 696e 673a 2069 6e74 0d0a  xesTiling: int..
-00002e70: 2020 2020 6261 636b 6772 6f75 6e64 436f      backgroundCo
-00002e80: 6c6f 723a 2054 7570 6c65 5b66 6c6f 6174  lor: Tuple[float
-00002e90: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
-00002ea0: 6174 5d0d 0a20 2020 2062 6163 6b67 726f  at]..    backgro
-00002eb0: 756e 6443 6f6c 6f72 426f 7474 6f6d 3a20  undColorBottom: 
-00002ec0: 5475 706c 655b 666c 6f61 742c 666c 6f61  Tuple[float,floa
-00002ed0: 742c 666c 6f61 742c 666c 6f61 745d 0d0a  t,float,float]..
-00002ee0: 2020 2020 6369 7263 6c65 5469 6c69 6e67      circleTiling
-00002ef0: 3a20 696e 740d 0a20 2020 2063 6f6f 7264  : int..    coord
-00002f00: 696e 6174 6553 7973 7465 6d53 697a 653a  inateSystemSize:
-00002f10: 2066 6c6f 6174 0d0a 2020 2020 6379 6c69   float..    cyli
-00002f20: 6e64 6572 5469 6c69 6e67 3a20 696e 740d  nderTiling: int.
-00002f30: 0a20 2020 2064 7261 7743 6f6f 7264 696e  .    drawCoordin
-00002f40: 6174 6553 7973 7465 6d3a 2062 6f6f 6c0d  ateSystem: bool.
-00002f50: 0a20 2020 2064 7261 7757 6f72 6c64 4261  .    drawWorldBa
-00002f60: 7369 733a 2062 6f6f 6c0d 0a20 2020 2067  sis: bool..    g
-00002f70: 7261 7068 6963 7355 7064 6174 6549 6e74  raphicsUpdateInt
-00002f80: 6572 7661 6c3a 2066 6c6f 6174 0d0a 2020  erval: float..  
-00002f90: 2020 6c69 6e75 7844 6973 706c 6179 5363    linuxDisplaySc
-00002fa0: 616c 6546 6163 746f 723a 2066 6c6f 6174  aleFactor: float
-00002fb0: 0d0a 2020 2020 6d69 6e53 6365 6e65 5369  ..    minSceneSi
-00002fc0: 7a65 3a20 666c 6f61 740d 0a20 2020 2070  ze: float..    p
-00002fd0: 6f69 6e74 5369 7a65 3a20 666c 6f61 740d  ointSize: float.
-00002fe0: 0a20 2020 2072 656e 6465 7265 7250 7265  .    rendererPre
-00002ff0: 6369 7369 6f6e 3a20 696e 740d 0a20 2020  cision: int..   
-00003000: 2072 656e 6465 7257 696e 646f 7753 7472   renderWindowStr
-00003010: 696e 673a 2073 7472 0d0a 2020 2020 7368  ing: str..    sh
-00003020: 6f77 436f 6d70 7574 6174 696f 6e49 6e66  owComputationInf
-00003030: 6f3a 2062 6f6f 6c0d 0a20 2020 2073 686f  o: bool..    sho
-00003040: 7748 656c 704f 6e53 7461 7274 7570 3a20  wHelpOnStartup: 
-00003050: 696e 740d 0a20 2020 2073 686f 7753 6f6c  int..    showSol
-00003060: 7574 696f 6e49 6e66 6f72 6d61 7469 6f6e  utionInformation
-00003070: 3a20 626f 6f6c 0d0a 2020 2020 7368 6f77  : bool..    show
-00003080: 536f 6c76 6572 496e 666f 726d 6174 696f  SolverInformatio
-00003090: 6e3a 2062 6f6f 6c0d 0a20 2020 2073 686f  n: bool..    sho
-000030a0: 7753 6f6c 7665 7254 696d 653a 2062 6f6f  wSolverTime: boo
-000030b0: 6c0d 0a20 2020 2073 7068 6572 6554 696c  l..    sphereTil
-000030c0: 696e 673a 2069 6e74 0d0a 2020 2020 7465  ing: int..    te
-000030d0: 7874 416c 7761 7973 496e 4672 6f6e 743a  xtAlwaysInFront:
-000030e0: 2062 6f6f 6c0d 0a20 2020 2074 6578 7443   bool..    textC
-000030f0: 6f6c 6f72 3a20 5475 706c 655b 666c 6f61  olor: Tuple[floa
-00003100: 742c 666c 6f61 742c 666c 6f61 742c 666c  t,float,float,fl
-00003110: 6f61 745d 0d0a 2020 2020 7465 7874 4861  oat]..    textHa
-00003120: 7342 6163 6b67 726f 756e 643a 2062 6f6f  sBackground: boo
-00003130: 6c0d 0a20 2020 2074 6578 744f 6666 7365  l..    textOffse
-00003140: 7446 6163 746f 723a 2066 6c6f 6174 0d0a  tFactor: float..
-00003150: 2020 2020 7465 7874 5369 7a65 3a20 666c      textSize: fl
-00003160: 6f61 740d 0a20 2020 2074 6872 6561 6453  oat..    threadS
-00003170: 6166 6547 7261 7068 6963 7355 7064 6174  afeGraphicsUpdat
-00003180: 653a 2062 6f6f 6c0d 0a20 2020 2075 7365  e: bool..    use
-00003190: 4269 746d 6170 5465 7874 3a20 626f 6f6c  BitmapText: bool
-000031a0: 0d0a 2020 2020 7573 6547 7261 6469 656e  ..    useGradien
-000031b0: 7442 6163 6b67 726f 756e 643a 2062 6f6f  tBackground: boo
-000031c0: 6c0d 0a20 2020 2075 7365 4d75 6c74 6954  l..    useMultiT
-000031d0: 6872 6561 6465 6452 656e 6465 7269 6e67  hreadedRendering
-000031e0: 3a20 626f 6f6c 0d0a 2020 2020 7573 6557  : bool..    useW
-000031f0: 696e 646f 7773 4469 7370 6c61 7953 6361  indowsDisplaySca
-00003200: 6c65 4661 6374 6f72 3a20 626f 6f6c 0d0a  leFactor: bool..
-00003210: 2020 2020 776f 726c 6442 6173 6973 5369      worldBasisSi
-00003220: 7a65 3a20 666c 6f61 740d 0a0d 0a0d 0a63  ze: float......c
-00003230: 6c61 7373 2056 5365 7474 696e 6773 436f  lass VSettingsCo
-00003240: 6e74 6f75 723a 0d0a 2020 2020 6175 746f  ntour:..    auto
-00003250: 6d61 7469 6352 616e 6765 3a20 626f 6f6c  maticRange: bool
-00003260: 0d0a 2020 2020 636f 6c6f 7242 6172 5072  ..    colorBarPr
-00003270: 6563 6973 696f 6e3a 2069 6e74 0d0a 2020  ecision: int..  
-00003280: 2020 636f 6c6f 7242 6172 5469 6c69 6e67    colorBarTiling
-00003290: 3a20 696e 740d 0a20 2020 206d 6178 5661  : int..    maxVa
-000032a0: 6c75 653a 2066 6c6f 6174 0d0a 2020 2020  lue: float..    
-000032b0: 6d69 6e56 616c 7565 3a20 666c 6f61 740d  minValue: float.
-000032c0: 0a20 2020 206e 6f64 6573 436f 6c6f 7265  .    nodesColore
-000032d0: 643a 2062 6f6f 6c0d 0a20 2020 206f 7574  d: bool..    out
-000032e0: 7075 7456 6172 6961 626c 653a 204f 7574  putVariable: Out
-000032f0: 7075 7456 6172 6961 626c 6554 7970 650d  putVariableType.
-00003300: 0a20 2020 206f 7574 7075 7456 6172 6961  .    outputVaria
-00003310: 626c 6543 6f6d 706f 6e65 6e74 3a20 696e  bleComponent: in
-00003320: 740d 0a20 2020 2072 6564 7563 6552 616e  t..    reduceRan
-00003330: 6765 3a20 626f 6f6c 0d0a 2020 2020 7269  ge: bool..    ri
-00003340: 6769 6442 6f64 6965 7343 6f6c 6f72 6564  gidBodiesColored
-00003350: 3a20 626f 6f6c 0d0a 2020 2020 7368 6f77  : bool..    show
-00003360: 436f 6c6f 7242 6172 3a20 626f 6f6c 0d0a  ColorBar: bool..
-00003370: 0d0a 0d0a 636c 6173 7320 5653 6574 7469  ....class VSetti
-00003380: 6e67 734e 6f64 6573 3a0d 0a20 2020 2062  ngsNodes:..    b
-00003390: 6173 6973 5369 7a65 3a20 666c 6f61 740d  asisSize: float.
-000033a0: 0a20 2020 2064 6566 6175 6c74 436f 6c6f  .    defaultColo
-000033b0: 723a 2054 7570 6c65 5b66 6c6f 6174 2c66  r: Tuple[float,f
-000033c0: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
-000033d0: 5d0d 0a20 2020 2064 6566 6175 6c74 5369  ]..    defaultSi
-000033e0: 7a65 3a20 666c 6f61 740d 0a20 2020 2064  ze: float..    d
-000033f0: 7261 774e 6f64 6573 4173 506f 696e 743a  rawNodesAsPoint:
-00003400: 2062 6f6f 6c0d 0a20 2020 2073 686f 773a   bool..    show:
-00003410: 2062 6f6f 6c0d 0a20 2020 2073 686f 7742   bool..    showB
-00003420: 6173 6973 3a20 626f 6f6c 0d0a 2020 2020  asis: bool..    
-00003430: 7368 6f77 4e6f 6461 6c53 6c6f 7065 733a  showNodalSlopes:
-00003440: 2069 6e74 0d0a 2020 2020 7368 6f77 4e75   int..    showNu
-00003450: 6d62 6572 733a 2062 6f6f 6c0d 0a20 2020  mbers: bool..   
-00003460: 2074 696c 696e 673a 2069 6e74 0d0a 0d0a   tiling: int....
-00003470: 0d0a 636c 6173 7320 5653 6574 7469 6e67  ..class VSetting
-00003480: 7342 6561 6d73 3a0d 0a20 2020 2061 7869  sBeams:..    axi
-00003490: 616c 5469 6c69 6e67 3a20 696e 740d 0a20  alTiling: int.. 
-000034a0: 2020 2063 726f 7373 5365 6374 696f 6e46     crossSectionF
-000034b0: 696c 6c65 643a 2062 6f6f 6c0d 0a20 2020  illed: bool..   
-000034c0: 2063 726f 7373 5365 6374 696f 6e54 696c   crossSectionTil
-000034d0: 696e 673a 2069 6e74 0d0a 2020 2020 6472  ing: int..    dr
-000034e0: 6177 5665 7274 6963 616c 3a20 626f 6f6c  awVertical: bool
-000034f0: 0d0a 2020 2020 6472 6177 5665 7274 6963  ..    drawVertic
-00003500: 616c 436f 6c6f 723a 2054 7570 6c65 5b66  alColor: Tuple[f
-00003510: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
-00003520: 2c66 6c6f 6174 5d0d 0a20 2020 2064 7261  ,float]..    dra
-00003530: 7756 6572 7469 6361 6c46 6163 746f 723a  wVerticalFactor:
-00003540: 2066 6c6f 6174 0d0a 2020 2020 6472 6177   float..    draw
-00003550: 5665 7274 6963 616c 4c69 6e65 733a 2062  VerticalLines: b
-00003560: 6f6f 6c0d 0a20 2020 2064 7261 7756 6572  ool..    drawVer
-00003570: 7469 6361 6c4f 6666 7365 743a 2066 6c6f  ticalOffset: flo
-00003580: 6174 0d0a 2020 2020 6472 6177 5665 7274  at..    drawVert
-00003590: 6963 616c 5661 6c75 6573 3a20 626f 6f6c  icalValues: bool
-000035a0: 0d0a 2020 2020 7265 6475 6365 6441 7869  ..    reducedAxi
-000035b0: 616c 496e 7465 7270 6c6f 6174 696f 6e3a  alInterploation:
-000035c0: 2062 6f6f 6c0d 0a0d 0a0d 0a63 6c61 7373   bool......class
-000035d0: 2056 5365 7474 696e 6773 4b69 6e65 6d61   VSettingsKinema
-000035e0: 7469 6354 7265 653a 0d0a 2020 2020 6672  ticTree:..    fr
-000035f0: 616d 6553 697a 653a 2066 6c6f 6174 0d0a  ameSize: float..
-00003600: 2020 2020 7368 6f77 434f 4d66 7261 6d65      showCOMframe
-00003610: 733a 2062 6f6f 6c0d 0a20 2020 2073 686f  s: bool..    sho
-00003620: 7746 7261 6d65 734e 756d 6265 7273 3a20  wFramesNumbers: 
-00003630: 626f 6f6c 0d0a 2020 2020 7368 6f77 4a6f  bool..    showJo
-00003640: 696e 7446 7261 6d65 733a 2062 6f6f 6c0d  intFrames: bool.
-00003650: 0a0d 0a0d 0a63 6c61 7373 2056 5365 7474  .....class VSett
-00003660: 696e 6773 426f 6469 6573 3a0d 0a20 2020  ingsBodies:..   
-00003670: 2062 6561 6d73 3a20 5653 6574 7469 6e67   beams: VSetting
-00003680: 7342 6561 6d73 0d0a 2020 2020 6b69 6e65  sBeams..    kine
-00003690: 6d61 7469 6354 7265 653a 2056 5365 7474  maticTree: VSett
-000036a0: 696e 6773 4b69 6e65 6d61 7469 6354 7265  ingsKinematicTre
-000036b0: 650d 0a20 2020 2064 6566 6175 6c74 436f  e..    defaultCo
-000036c0: 6c6f 723a 2054 7570 6c65 5b66 6c6f 6174  lor: Tuple[float
-000036d0: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
-000036e0: 6174 5d0d 0a20 2020 2064 6566 6175 6c74  at]..    default
-000036f0: 5369 7a65 3a20 5475 706c 655b 666c 6f61  Size: Tuple[floa
-00003700: 742c 666c 6f61 742c 666c 6f61 745d 0d0a  t,float,float]..
-00003710: 2020 2020 6465 666f 726d 6174 696f 6e53      deformationS
-00003720: 6361 6c65 4661 6374 6f72 3a20 666c 6f61  caleFactor: floa
-00003730: 740d 0a20 2020 2073 686f 773a 2062 6f6f  t..    show: boo
-00003740: 6c0d 0a20 2020 2073 686f 774e 756d 6265  l..    showNumbe
-00003750: 7273 3a20 626f 6f6c 0d0a 0d0a 0d0a 636c  rs: bool......cl
-00003760: 6173 7320 5653 6574 7469 6e67 7343 6f6e  ass VSettingsCon
-00003770: 6e65 6374 6f72 733a 0d0a 2020 2020 636f  nectors:..    co
-00003780: 6e74 6163 7450 6f69 6e74 7344 6566 6175  ntactPointsDefau
-00003790: 6c74 5369 7a65 3a20 666c 6f61 740d 0a20  ltSize: float.. 
-000037a0: 2020 2064 6566 6175 6c74 436f 6c6f 723a     defaultColor:
-000037b0: 2054 7570 6c65 5b66 6c6f 6174 2c66 6c6f   Tuple[float,flo
-000037c0: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d0d  at,float,float].
-000037d0: 0a20 2020 2064 6566 6175 6c74 5369 7a65  .    defaultSize
-000037e0: 3a20 666c 6f61 740d 0a20 2020 206a 6f69  : float..    joi
-000037f0: 6e74 4178 6573 4c65 6e67 7468 3a20 666c  ntAxesLength: fl
-00003800: 6f61 740d 0a20 2020 206a 6f69 6e74 4178  oat..    jointAx
-00003810: 6573 5261 6469 7573 3a20 666c 6f61 740d  esRadius: float.
-00003820: 0a20 2020 2073 686f 773a 2062 6f6f 6c0d  .    show: bool.
-00003830: 0a20 2020 2073 686f 7743 6f6e 7461 6374  .    showContact
-00003840: 3a20 626f 6f6c 0d0a 2020 2020 7368 6f77  : bool..    show
-00003850: 4a6f 696e 7441 7865 733a 2062 6f6f 6c0d  JointAxes: bool.
-00003860: 0a20 2020 2073 686f 774e 756d 6265 7273  .    showNumbers
-00003870: 3a20 626f 6f6c 0d0a 2020 2020 7370 7269  : bool..    spri
-00003880: 6e67 4e75 6d62 6572 4f66 5769 6e64 696e  ngNumberOfWindin
-00003890: 6773 3a20 696e 740d 0a0d 0a0d 0a63 6c61  gs: int......cla
-000038a0: 7373 2056 5365 7474 696e 6773 4d61 726b  ss VSettingsMark
-000038b0: 6572 733a 0d0a 2020 2020 6465 6661 756c  ers:..    defaul
-000038c0: 7443 6f6c 6f72 3a20 5475 706c 655b 666c  tColor: Tuple[fl
-000038d0: 6f61 742c 666c 6f61 742c 666c 6f61 742c  oat,float,float,
-000038e0: 666c 6f61 745d 0d0a 2020 2020 6465 6661  float]..    defa
-000038f0: 756c 7453 697a 653a 2066 6c6f 6174 0d0a  ultSize: float..
-00003900: 2020 2020 6472 6177 5369 6d70 6c69 6669      drawSimplifi
-00003910: 6564 3a20 626f 6f6c 0d0a 2020 2020 7368  ed: bool..    sh
-00003920: 6f77 3a20 626f 6f6c 0d0a 2020 2020 7368  ow: bool..    sh
-00003930: 6f77 4e75 6d62 6572 733a 2062 6f6f 6c0d  owNumbers: bool.
-00003940: 0a0d 0a0d 0a63 6c61 7373 2056 5365 7474  .....class VSett
-00003950: 696e 6773 4c6f 6164 733a 0d0a 2020 2020  ingsLoads:..    
-00003960: 6465 6661 756c 7443 6f6c 6f72 3a20 5475  defaultColor: Tu
-00003970: 706c 655b 666c 6f61 742c 666c 6f61 742c  ple[float,float,
-00003980: 666c 6f61 742c 666c 6f61 745d 0d0a 2020  float,float]..  
-00003990: 2020 6465 6661 756c 7452 6164 6975 733a    defaultRadius:
-000039a0: 2066 6c6f 6174 0d0a 2020 2020 6465 6661   float..    defa
-000039b0: 756c 7453 697a 653a 2066 6c6f 6174 0d0a  ultSize: float..
-000039c0: 2020 2020 6472 6177 5369 6d70 6c69 6669      drawSimplifi
-000039d0: 6564 3a20 626f 6f6c 0d0a 2020 2020 6669  ed: bool..    fi
-000039e0: 7865 644c 6f61 6453 697a 653a 2062 6f6f  xedLoadSize: boo
-000039f0: 6c0d 0a20 2020 206c 6f61 6453 697a 6546  l..    loadSizeF
-00003a00: 6163 746f 723a 2066 6c6f 6174 0d0a 2020  actor: float..  
-00003a10: 2020 7368 6f77 3a20 626f 6f6c 0d0a 2020    show: bool..  
-00003a20: 2020 7368 6f77 4e75 6d62 6572 733a 2062    showNumbers: b
-00003a30: 6f6f 6c0d 0a0d 0a0d 0a63 6c61 7373 2056  ool......class V
-00003a40: 5365 7474 696e 6773 5365 6e73 6f72 5472  SettingsSensorTr
-00003a50: 6163 6573 3a0d 0a20 2020 206c 696e 6557  aces:..    lineW
-00003a60: 6964 7468 3a20 666c 6f61 740d 0a20 2020  idth: float..   
-00003a70: 206c 6973 744f 6650 6f73 6974 696f 6e53   listOfPositionS
-00003a80: 656e 736f 7273 3a20 4172 7261 7949 6e64  ensors: ArrayInd
-00003a90: 6578 0d0a 2020 2020 6c69 7374 4f66 5472  ex..    listOfTr
-00003aa0: 6961 6453 656e 736f 7273 3a20 4172 7261  iadSensors: Arra
-00003ab0: 7949 6e64 6578 0d0a 2020 2020 6c69 7374  yIndex..    list
-00003ac0: 4f66 5665 6374 6f72 5365 6e73 6f72 733a  OfVectorSensors:
-00003ad0: 2041 7272 6179 496e 6465 780d 0a20 2020   ArrayIndex..   
-00003ae0: 2070 6f73 6974 696f 6e73 5368 6f77 4576   positionsShowEv
-00003af0: 6572 793a 2069 6e74 0d0a 2020 2020 7365  ery: int..    se
-00003b00: 6e73 6f72 734d 6273 4e75 6d62 6572 3a20  nsorsMbsNumber: 
-00003b10: 696e 740d 0a20 2020 2073 686f 7743 7572  int..    showCur
-00003b20: 7265 6e74 3a20 626f 6f6c 0d0a 2020 2020  rent: bool..    
-00003b30: 7368 6f77 4675 7475 7265 3a20 626f 6f6c  showFuture: bool
-00003b40: 0d0a 2020 2020 7368 6f77 5061 7374 3a20  ..    showPast: 
-00003b50: 626f 6f6c 0d0a 2020 2020 7368 6f77 506f  bool..    showPo
-00003b60: 7369 7469 6f6e 5472 6163 653a 2062 6f6f  sitionTrace: boo
-00003b70: 6c0d 0a20 2020 2073 686f 7754 7269 6164  l..    showTriad
-00003b80: 733a 2062 6f6f 6c0d 0a20 2020 2073 686f  s: bool..    sho
-00003b90: 7756 6563 746f 7273 3a20 626f 6f6c 0d0a  wVectors: bool..
-00003ba0: 2020 2020 7472 6163 6543 6f6c 6f72 733a      traceColors:
-00003bb0: 2041 7272 6179 466c 6f61 740d 0a20 2020   ArrayFloat..   
-00003bc0: 2074 7269 6164 5369 7a65 3a20 666c 6f61   triadSize: floa
-00003bd0: 740d 0a20 2020 2074 7269 6164 7353 686f  t..    triadsSho
-00003be0: 7745 7665 7279 3a20 696e 740d 0a20 2020  wEvery: int..   
-00003bf0: 2076 6563 746f 7253 6361 6c69 6e67 3a20   vectorScaling: 
-00003c00: 666c 6f61 740d 0a20 2020 2076 6563 746f  float..    vecto
-00003c10: 7273 5368 6f77 4576 6572 793a 2069 6e74  rsShowEvery: int
-00003c20: 0d0a 0d0a 0d0a 636c 6173 7320 5653 6574  ......class VSet
-00003c30: 7469 6e67 7353 656e 736f 7273 3a0d 0a20  tingsSensors:.. 
-00003c40: 2020 2074 7261 6365 733a 2056 5365 7474     traces: VSett
-00003c50: 696e 6773 5365 6e73 6f72 5472 6163 6573  ingsSensorTraces
-00003c60: 0d0a 2020 2020 6465 6661 756c 7443 6f6c  ..    defaultCol
-00003c70: 6f72 3a20 5475 706c 655b 666c 6f61 742c  or: Tuple[float,
-00003c80: 666c 6f61 742c 666c 6f61 742c 666c 6f61  float,float,floa
-00003c90: 745d 0d0a 2020 2020 6465 6661 756c 7453  t]..    defaultS
-00003ca0: 697a 653a 2066 6c6f 6174 0d0a 2020 2020  ize: float..    
-00003cb0: 6472 6177 5369 6d70 6c69 6669 6564 3a20  drawSimplified: 
-00003cc0: 626f 6f6c 0d0a 2020 2020 7368 6f77 3a20  bool..    show: 
-00003cd0: 626f 6f6c 0d0a 2020 2020 7368 6f77 4e75  bool..    showNu
-00003ce0: 6d62 6572 733a 2062 6f6f 6c0d 0a0d 0a0d  mbers: bool.....
-00003cf0: 0a63 6c61 7373 2056 5365 7474 696e 6773  .class VSettings
-00003d00: 436f 6e74 6163 743a 0d0a 2020 2020 636f  Contact:..    co
-00003d10: 6c6f 7242 6f75 6e64 696e 6742 6f78 6573  lorBoundingBoxes
-00003d20: 3a20 5475 706c 655b 666c 6f61 742c 666c  : Tuple[float,fl
-00003d30: 6f61 742c 666c 6f61 742c 666c 6f61 745d  oat,float,float]
-00003d40: 0d0a 2020 2020 636f 6c6f 7253 6561 7263  ..    colorSearc
-00003d50: 6854 7265 653a 2054 7570 6c65 5b66 6c6f  hTree: Tuple[flo
-00003d60: 6174 2c66 6c6f 6174 2c66 6c6f 6174 2c66  at,float,float,f
-00003d70: 6c6f 6174 5d0d 0a20 2020 2063 6f6c 6f72  loat]..    color
-00003d80: 5370 6865 7265 733a 2054 7570 6c65 5b66  Spheres: Tuple[f
-00003d90: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
-00003da0: 2c66 6c6f 6174 5d0d 0a20 2020 2063 6f6c  ,float]..    col
-00003db0: 6f72 5472 6961 6e67 6c65 733a 2054 7570  orTriangles: Tup
-00003dc0: 6c65 5b66 6c6f 6174 2c66 6c6f 6174 2c66  le[float,float,f
-00003dd0: 6c6f 6174 2c66 6c6f 6174 5d0d 0a20 2020  loat,float]..   
-00003de0: 2063 6f6e 7461 6374 466f 7263 6573 4661   contactForcesFa
-00003df0: 6374 6f72 3a20 666c 6f61 740d 0a20 2020  ctor: float..   
-00003e00: 2063 6f6e 7461 6374 506f 696e 7473 4465   contactPointsDe
-00003e10: 6661 756c 7453 697a 653a 2066 6c6f 6174  faultSize: float
-00003e20: 0d0a 2020 2020 7368 6f77 426f 756e 6469  ..    showBoundi
-00003e30: 6e67 426f 7865 733a 2062 6f6f 6c0d 0a20  ngBoxes: bool.. 
-00003e40: 2020 2073 686f 7743 6f6e 7461 6374 466f     showContactFo
-00003e50: 7263 6573 3a20 626f 6f6c 0d0a 2020 2020  rces: bool..    
-00003e60: 7368 6f77 436f 6e74 6163 7446 6f72 6365  showContactForce
-00003e70: 7356 616c 7565 733a 2062 6f6f 6c0d 0a20  sValues: bool.. 
-00003e80: 2020 2073 686f 7753 6561 7263 6854 7265     showSearchTre
-00003e90: 653a 2062 6f6f 6c0d 0a20 2020 2073 686f  e: bool..    sho
-00003ea0: 7753 6561 7263 6854 7265 6543 656c 6c73  wSearchTreeCells
-00003eb0: 3a20 626f 6f6c 0d0a 2020 2020 7368 6f77  : bool..    show
-00003ec0: 5370 6865 7265 733a 2062 6f6f 6c0d 0a20  Spheres: bool.. 
-00003ed0: 2020 2073 686f 7754 7269 616e 676c 6573     showTriangles
-00003ee0: 3a20 626f 6f6c 0d0a 2020 2020 7469 6c69  : bool..    tili
-00003ef0: 6e67 5370 6865 7265 733a 2069 6e74 0d0a  ngSpheres: int..
-00003f00: 0d0a 0d0a 636c 6173 7320 5653 6574 7469  ....class VSetti
-00003f10: 6e67 7357 696e 646f 773a 0d0a 2020 2020  ngsWindow:..    
-00003f20: 616c 7761 7973 4f6e 546f 703a 2062 6f6f  alwaysOnTop: boo
-00003f30: 6c0d 0a20 2020 2069 676e 6f72 654b 6579  l..    ignoreKey
-00003f40: 733a 2062 6f6f 6c0d 0a20 2020 206b 6579  s: bool..    key
-00003f50: 5072 6573 7355 7365 7246 756e 6374 696f  PressUserFunctio
-00003f60: 6e3a 2041 6e79 0d0a 2020 2020 6c69 6d69  n: Any..    limi
-00003f70: 7457 696e 646f 7754 6f53 6372 6565 6e53  tWindowToScreenS
-00003f80: 697a 653a 2062 6f6f 6c0d 0a20 2020 206d  ize: bool..    m
-00003f90: 6178 696d 697a 653a 2062 6f6f 6c0d 0a20  aximize: bool.. 
-00003fa0: 2020 2072 6561 6c6c 7951 7569 7454 696d     reallyQuitTim
-00003fb0: 654c 696d 6974 3a20 666c 6f61 740d 0a20  eLimit: float.. 
-00003fc0: 2020 2072 656e 6465 7257 696e 646f 7753     renderWindowS
-00003fd0: 697a 653a 2054 7570 6c65 5b69 6e74 2c69  ize: Tuple[int,i
-00003fe0: 6e74 5d0d 0a20 2020 2040 6f76 6572 6c6f  nt]..    @overlo
-00003ff0: 6164 0d0a 2020 2020 6465 6620 5265 7365  ad..    def Rese
-00004000: 744b 6579 5072 6573 7355 7365 7246 756e  tKeyPressUserFun
-00004010: 6374 696f 6e28 2920 2d3e 204e 6f6e 653a  ction() -> None:
-00004020: 202e 2e2e 0d0a 2020 2020 7368 6f77 4d6f   .....    showMo
-00004030: 7573 6543 6f6f 7264 696e 6174 6573 3a20  useCoordinates: 
-00004040: 626f 6f6c 0d0a 2020 2020 7368 6f77 5769  bool..    showWi
-00004050: 6e64 6f77 3a20 626f 6f6c 0d0a 2020 2020  ndow: bool..    
-00004060: 7374 6172 7475 7054 696d 656f 7574 3a20  startupTimeout: 
-00004070: 696e 740d 0a0d 0a0d 0a63 6c61 7373 2056  int......class V
-00004080: 5365 7474 696e 6773 4469 616c 6f67 733a  SettingsDialogs:
-00004090: 0d0a 2020 2020 616c 7068 6154 7261 6e73  ..    alphaTrans
-000040a0: 7061 7265 6e63 793a 2066 6c6f 6174 0d0a  parency: float..
-000040b0: 2020 2020 616c 7761 7973 546f 706d 6f73      alwaysTopmos
-000040c0: 743a 2062 6f6f 6c0d 0a20 2020 2066 6f6e  t: bool..    fon
-000040d0: 7453 6361 6c69 6e67 4d61 634f 533a 2066  tScalingMacOS: f
-000040e0: 6c6f 6174 0d0a 2020 2020 6d75 6c74 6954  loat..    multiT
-000040f0: 6872 6561 6465 6444 6961 6c6f 6773 3a20  hreadedDialogs: 
-00004100: 626f 6f6c 0d0a 2020 2020 6f70 656e 5472  bool..    openTr
-00004110: 6565 5669 6577 3a20 626f 6f6c 0d0a 0d0a  eeView: bool....
-00004120: 0d0a 636c 6173 7320 5653 6574 7469 6e67  ..class VSetting
-00004130: 734f 7065 6e47 4c3a 0d0a 2020 2020 6472  sOpenGL:..    dr
-00004140: 6177 4661 6365 4e6f 726d 616c 733a 2062  awFaceNormals: b
-00004150: 6f6f 6c0d 0a20 2020 2064 7261 774e 6f72  ool..    drawNor
-00004160: 6d61 6c73 4c65 6e67 7468 3a20 666c 6f61  malsLength: floa
-00004170: 740d 0a20 2020 2064 7261 7756 6572 7465  t..    drawVerte
-00004180: 784e 6f72 6d61 6c73 3a20 626f 6f6c 0d0a  xNormals: bool..
-00004190: 2020 2020 656e 6162 6c65 4c69 6768 7430      enableLight0
-000041a0: 3a20 626f 6f6c 0d0a 2020 2020 656e 6162  : bool..    enab
-000041b0: 6c65 4c69 6768 7431 3a20 626f 6f6c 0d0a  leLight1: bool..
-000041c0: 2020 2020 656e 6162 6c65 4c69 6768 7469      enableLighti
-000041d0: 6e67 3a20 626f 6f6c 0d0a 2020 2020 6661  ng: bool..    fa
-000041e0: 6365 4564 6765 7343 6f6c 6f72 3a20 5475  ceEdgesColor: Tu
-000041f0: 706c 655b 666c 6f61 742c 666c 6f61 742c  ple[float,float,
-00004200: 666c 6f61 742c 666c 6f61 745d 0d0a 2020  float,float]..  
-00004210: 2020 6661 6365 7354 7261 6e73 7061 7265    facesTranspare
-00004220: 6e74 3a20 626f 6f6c 0d0a 2020 2020 696e  nt: bool..    in
-00004230: 6974 6961 6c43 656e 7465 7250 6f69 6e74  itialCenterPoint
-00004240: 3a20 5475 706c 655b 666c 6f61 742c 666c  : Tuple[float,fl
-00004250: 6f61 742c 666c 6f61 745d 0d0a 2020 2020  oat,float]..    
-00004260: 696e 6974 6961 6c4d 6178 5363 656e 6553  initialMaxSceneS
-00004270: 697a 653a 2066 6c6f 6174 0d0a 2020 2020  ize: float..    
-00004280: 696e 6974 6961 6c4d 6f64 656c 526f 7461  initialModelRota
-00004290: 7469 6f6e 3a20 4172 7261 794c 696b 650d  tion: ArrayLike.
-000042a0: 0a20 2020 2069 6e69 7469 616c 5a6f 6f6d  .    initialZoom
-000042b0: 3a20 666c 6f61 740d 0a20 2020 206c 6967  : float..    lig
-000042c0: 6874 3061 6d62 6965 6e74 3a20 666c 6f61  ht0ambient: floa
-000042d0: 740d 0a20 2020 206c 6967 6874 3063 6f6e  t..    light0con
-000042e0: 7374 616e 7441 7474 656e 7561 7469 6f6e  stantAttenuation
-000042f0: 3a20 666c 6f61 740d 0a20 2020 206c 6967  : float..    lig
-00004300: 6874 3064 6966 6675 7365 3a20 666c 6f61  ht0diffuse: floa
-00004310: 740d 0a20 2020 206c 6967 6874 306c 696e  t..    light0lin
-00004320: 6561 7241 7474 656e 7561 7469 6f6e 3a20  earAttenuation: 
-00004330: 666c 6f61 740d 0a20 2020 206c 6967 6874  float..    light
-00004340: 3070 6f73 6974 696f 6e3a 2054 7570 6c65  0position: Tuple
-00004350: 5b66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  [float,float,flo
-00004360: 6174 2c66 6c6f 6174 5d0d 0a20 2020 206c  at,float]..    l
-00004370: 6967 6874 3071 7561 6472 6174 6963 4174  ight0quadraticAt
-00004380: 7465 6e75 6174 696f 6e3a 2066 6c6f 6174  tenuation: float
-00004390: 0d0a 2020 2020 6c69 6768 7430 7370 6563  ..    light0spec
-000043a0: 756c 6172 3a20 666c 6f61 740d 0a20 2020  ular: float..   
-000043b0: 206c 6967 6874 3161 6d62 6965 6e74 3a20   light1ambient: 
-000043c0: 666c 6f61 740d 0a20 2020 206c 6967 6874  float..    light
-000043d0: 3163 6f6e 7374 616e 7441 7474 656e 7561  1constantAttenua
-000043e0: 7469 6f6e 3a20 666c 6f61 740d 0a20 2020  tion: float..   
-000043f0: 206c 6967 6874 3164 6966 6675 7365 3a20   light1diffuse: 
-00004400: 666c 6f61 740d 0a20 2020 206c 6967 6874  float..    light
-00004410: 316c 696e 6561 7241 7474 656e 7561 7469  1linearAttenuati
-00004420: 6f6e 3a20 666c 6f61 740d 0a20 2020 206c  on: float..    l
-00004430: 6967 6874 3170 6f73 6974 696f 6e3a 2054  ight1position: T
-00004440: 7570 6c65 5b66 6c6f 6174 2c66 6c6f 6174  uple[float,float
-00004450: 2c66 6c6f 6174 2c66 6c6f 6174 5d0d 0a20  ,float,float].. 
-00004460: 2020 206c 6967 6874 3171 7561 6472 6174     light1quadrat
-00004470: 6963 4174 7465 6e75 6174 696f 6e3a 2066  icAttenuation: f
-00004480: 6c6f 6174 0d0a 2020 2020 6c69 6768 7431  loat..    light1
-00004490: 7370 6563 756c 6172 3a20 666c 6f61 740d  specular: float.
-000044a0: 0a20 2020 206c 6967 6874 4d6f 6465 6c41  .    lightModelA
-000044b0: 6d62 6965 6e74 3a20 5475 706c 655b 666c  mbient: Tuple[fl
-000044c0: 6f61 742c 666c 6f61 742c 666c 6f61 742c  oat,float,float,
-000044d0: 666c 6f61 745d 0d0a 2020 2020 6c69 6768  float]..    ligh
-000044e0: 744d 6f64 656c 4c6f 6361 6c56 6965 7765  tModelLocalViewe
-000044f0: 723a 2062 6f6f 6c0d 0a20 2020 206c 6967  r: bool..    lig
-00004500: 6874 4d6f 6465 6c54 776f 5369 6465 3a20  htModelTwoSide: 
-00004510: 626f 6f6c 0d0a 2020 2020 6c69 6e65 536d  bool..    lineSm
-00004520: 6f6f 7468 3a20 626f 6f6c 0d0a 2020 2020  ooth: bool..    
-00004530: 6c69 6e65 5769 6474 683a 2066 6c6f 6174  lineWidth: float
-00004540: 0d0a 2020 2020 6d61 7465 7269 616c 416d  ..    materialAm
-00004550: 6269 656e 7441 6e64 4469 6666 7573 653a  bientAndDiffuse:
-00004560: 2054 7570 6c65 5b66 6c6f 6174 2c66 6c6f   Tuple[float,flo
-00004570: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d0d  at,float,float].
-00004580: 0a20 2020 206d 6174 6572 6961 6c53 6869  .    materialShi
-00004590: 6e69 6e65 7373 3a20 666c 6f61 740d 0a20  niness: float.. 
-000045a0: 2020 206d 6174 6572 6961 6c53 7065 6375     materialSpecu
-000045b0: 6c61 723a 2054 7570 6c65 5b66 6c6f 6174  lar: Tuple[float
-000045c0: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
-000045d0: 6174 5d0d 0a20 2020 206d 756c 7469 5361  at]..    multiSa
-000045e0: 6d70 6c69 6e67 3a20 696e 740d 0a20 2020  mpling: int..   
-000045f0: 2070 6572 7370 6563 7469 7665 3a20 666c   perspective: fl
-00004600: 6f61 740d 0a20 2020 2070 6f6c 7967 6f6e  oat..    polygon
-00004610: 4f66 6673 6574 3a20 666c 6f61 740d 0a20  Offset: float.. 
-00004620: 2020 2073 6861 6465 4d6f 6465 6c53 6d6f     shadeModelSmo
-00004630: 6f74 683a 2062 6f6f 6c0d 0a20 2020 2073  oth: bool..    s
-00004640: 6861 646f 773a 2066 6c6f 6174 0d0a 2020  hadow: float..  
-00004650: 2020 7368 6164 6f77 506f 6c79 676f 6e4f    shadowPolygonO
-00004660: 6666 7365 743a 2066 6c6f 6174 0d0a 2020  ffset: float..  
-00004670: 2020 7368 6f77 4661 6365 4564 6765 733a    showFaceEdges:
-00004680: 2062 6f6f 6c0d 0a20 2020 2073 686f 7746   bool..    showF
-00004690: 6163 6573 3a20 626f 6f6c 0d0a 2020 2020  aces: bool..    
-000046a0: 7368 6f77 4c69 6e65 733a 2062 6f6f 6c0d  showLines: bool.
-000046b0: 0a20 2020 2073 686f 774d 6573 6845 6467  .    showMeshEdg
-000046c0: 6573 3a20 626f 6f6c 0d0a 2020 2020 7368  es: bool..    sh
-000046d0: 6f77 4d65 7368 4661 6365 733a 2062 6f6f  owMeshFaces: boo
-000046e0: 6c0d 0a20 2020 2074 6578 744c 696e 6553  l..    textLineS
-000046f0: 6d6f 6f74 683a 2062 6f6f 6c0d 0a20 2020  mooth: bool..   
-00004700: 2074 6578 744c 696e 6557 6964 7468 3a20   textLineWidth: 
-00004710: 666c 6f61 740d 0a0d 0a0d 0a63 6c61 7373  float......class
-00004720: 2056 5365 7474 696e 6773 4578 706f 7274   VSettingsExport
-00004730: 496d 6167 6573 3a0d 0a20 2020 2068 6569  Images:..    hei
-00004740: 6768 7441 6c69 676e 6d65 6e74 3a20 696e  ghtAlignment: in
-00004750: 740d 0a20 2020 2073 6176 6549 6d61 6765  t..    saveImage
-00004760: 4173 5465 7874 4369 7263 6c65 733a 2062  AsTextCircles: b
-00004770: 6f6f 6c0d 0a20 2020 2073 6176 6549 6d61  ool..    saveIma
-00004780: 6765 4173 5465 7874 4c69 6e65 733a 2062  geAsTextLines: b
-00004790: 6f6f 6c0d 0a20 2020 2073 6176 6549 6d61  ool..    saveIma
-000047a0: 6765 4173 5465 7874 5465 7874 733a 2062  geAsTextTexts: b
-000047b0: 6f6f 6c0d 0a20 2020 2073 6176 6549 6d61  ool..    saveIma
-000047c0: 6765 4173 5465 7874 5472 6961 6e67 6c65  geAsTextTriangle
-000047d0: 733a 2062 6f6f 6c0d 0a20 2020 2073 6176  s: bool..    sav
-000047e0: 6549 6d61 6765 4669 6c65 436f 756e 7465  eImageFileCounte
-000047f0: 723a 2069 6e74 0d0a 2020 2020 7361 7665  r: int..    save
-00004800: 496d 6167 6546 696c 654e 616d 653a 2073  ImageFileName: s
-00004810: 7472 0d0a 2020 2020 7361 7665 496d 6167  tr..    saveImag
-00004820: 6546 6f72 6d61 743a 2073 7472 0d0a 2020  eFormat: str..  
-00004830: 2020 7361 7665 496d 6167 6553 696e 676c    saveImageSingl
-00004840: 6546 696c 653a 2062 6f6f 6c0d 0a20 2020  eFile: bool..   
-00004850: 2073 6176 6549 6d61 6765 5469 6d65 4f75   saveImageTimeOu
-00004860: 743a 2069 6e74 0d0a 2020 2020 7769 6474  t: int..    widt
-00004870: 6841 6c69 676e 6d65 6e74 3a20 696e 740d  hAlignment: int.
-00004880: 0a0d 0a0d 0a63 6c61 7373 2056 5365 7474  .....class VSett
-00004890: 696e 6773 4f70 656e 5652 3a0d 0a20 2020  ingsOpenVR:..   
-000048a0: 2061 6374 696f 6e4d 616e 6966 6573 7446   actionManifestF
-000048b0: 696c 654e 616d 653a 2073 7472 0d0a 2020  ileName: str..  
-000048c0: 2020 656e 6162 6c65 3a20 626f 6f6c 0d0a    enable: bool..
-000048d0: 2020 2020 6c6f 674c 6576 656c 3a20 696e      logLevel: in
-000048e0: 740d 0a20 2020 2073 686f 7743 6f6d 7061  t..    showCompa
-000048f0: 6e69 6f6e 5769 6e64 6f77 3a20 626f 6f6c  nionWindow: bool
-00004900: 0d0a 0d0a 0d0a 636c 6173 7320 5653 6574  ......class VSet
-00004910: 7469 6e67 7349 6e74 6572 6163 7469 7665  tingsInteractive
-00004920: 3a0d 0a20 2020 206f 7065 6e56 523a 2056  :..    openVR: V
-00004930: 5365 7474 696e 6773 4f70 656e 5652 0d0a  SettingsOpenVR..
-00004940: 2020 2020 6869 6768 6c69 6768 7443 6f6c      highlightCol
-00004950: 6f72 3a20 5475 706c 655b 666c 6f61 742c  or: Tuple[float,
-00004960: 666c 6f61 742c 666c 6f61 742c 666c 6f61  float,float,floa
-00004970: 745d 0d0a 2020 2020 6869 6768 6c69 6768  t]..    highligh
-00004980: 7449 7465 6d49 6e64 6578 3a20 696e 740d  tItemIndex: int.
-00004990: 0a20 2020 2068 6967 686c 6967 6874 4974  .    highlightIt
-000049a0: 656d 5479 7065 3a20 4974 656d 5479 7065  emType: ItemType
-000049b0: 0d0a 2020 2020 6869 6768 6c69 6768 744d  ..    highlightM
-000049c0: 6273 4e75 6d62 6572 3a20 696e 740d 0a20  bsNumber: int.. 
-000049d0: 2020 2068 6967 686c 6967 6874 4f74 6865     highlightOthe
-000049e0: 7243 6f6c 6f72 3a20 5475 706c 655b 666c  rColor: Tuple[fl
-000049f0: 6f61 742c 666c 6f61 742c 666c 6f61 742c  oat,float,float,
-00004a00: 666c 6f61 745d 0d0a 2020 2020 6a6f 7973  float]..    joys
-00004a10: 7469 636b 5363 616c 6552 6f74 6174 696f  tickScaleRotatio
-00004a20: 6e3a 2066 6c6f 6174 0d0a 2020 2020 6a6f  n: float..    jo
-00004a30: 7973 7469 636b 5363 616c 6554 7261 6e73  ystickScaleTrans
-00004a40: 6c61 7469 6f6e 3a20 666c 6f61 740d 0a20  lation: float.. 
-00004a50: 2020 206b 6579 7072 6573 7352 6f74 6174     keypressRotat
-00004a60: 696f 6e53 7465 703a 2066 6c6f 6174 0d0a  ionStep: float..
-00004a70: 2020 2020 6b65 7970 7265 7373 5472 616e      keypressTran
-00004a80: 736c 6174 696f 6e53 7465 703a 2066 6c6f  slationStep: flo
-00004a90: 6174 0d0a 2020 2020 6c6f 636b 4d6f 6465  at..    lockMode
-00004aa0: 6c56 6965 773a 2062 6f6f 6c0d 0a20 2020  lView: bool..   
-00004ab0: 206d 6f75 7365 4d6f 7665 526f 7461 7469   mouseMoveRotati
-00004ac0: 6f6e 4661 6374 6f72 3a20 666c 6f61 740d  onFactor: float.
-00004ad0: 0a20 2020 2070 6175 7365 5769 7468 5370  .    pauseWithSp
-00004ae0: 6163 6562 6172 3a20 626f 6f6c 0d0a 2020  acebar: bool..  
-00004af0: 2020 7365 6c65 6374 696f 6e48 6967 686c    selectionHighl
-00004b00: 6967 6874 733a 2062 6f6f 6c0d 0a20 2020  ights: bool..   
-00004b10: 2073 656c 6563 7469 6f6e 4c65 6674 4d6f   selectionLeftMo
-00004b20: 7573 653a 2062 6f6f 6c0d 0a20 2020 2073  use: bool..    s
-00004b30: 656c 6563 7469 6f6e 5269 6768 744d 6f75  electionRightMou
-00004b40: 7365 3a20 626f 6f6c 0d0a 2020 2020 7365  se: bool..    se
-00004b50: 6c65 6374 696f 6e52 6967 6874 4d6f 7573  lectionRightMous
-00004b60: 6547 7261 7068 6963 7344 6174 613a 2062  eGraphicsData: b
-00004b70: 6f6f 6c0d 0a20 2020 2074 7261 636b 4d61  ool..    trackMa
-00004b80: 726b 6572 3a20 696e 740d 0a20 2020 2074  rker: int..    t
-00004b90: 7261 636b 4d61 726b 6572 4d62 734e 756d  rackMarkerMbsNum
-00004ba0: 6265 723a 2069 6e74 0d0a 2020 2020 7472  ber: int..    tr
-00004bb0: 6163 6b4d 6172 6b65 724f 7269 656e 7461  ackMarkerOrienta
-00004bc0: 7469 6f6e 3a20 5475 706c 655b 666c 6f61  tion: Tuple[floa
-00004bd0: 742c 666c 6f61 742c 666c 6f61 745d 0d0a  t,float,float]..
-00004be0: 2020 2020 7472 6163 6b4d 6172 6b65 7250      trackMarkerP
-00004bf0: 6f73 6974 696f 6e3a 2054 7570 6c65 5b66  osition: Tuple[f
-00004c00: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
-00004c10: 5d0d 0a20 2020 2075 7365 4a6f 7973 7469  ]..    useJoysti
-00004c20: 636b 496e 7075 743a 2062 6f6f 6c0d 0a20  ckInput: bool.. 
-00004c30: 2020 207a 6f6f 6d53 7465 7046 6163 746f     zoomStepFacto
-00004c40: 723a 2066 6c6f 6174 0d0a 0d0a 0d0a 636c  r: float......cl
-00004c50: 6173 7320 5669 7375 616c 697a 6174 696f  ass Visualizatio
-00004c60: 6e53 6574 7469 6e67 733a 0d0a 2020 2020  nSettings:..    
-00004c70: 626f 6469 6573 3a20 5653 6574 7469 6e67  bodies: VSetting
-00004c80: 7342 6f64 6965 730d 0a20 2020 2063 6f6e  sBodies..    con
-00004c90: 6e65 6374 6f72 733a 2056 5365 7474 696e  nectors: VSettin
-00004ca0: 6773 436f 6e6e 6563 746f 7273 0d0a 2020  gsConnectors..  
-00004cb0: 2020 636f 6e74 6163 743a 2056 5365 7474    contact: VSett
-00004cc0: 696e 6773 436f 6e74 6163 740d 0a20 2020  ingsContact..   
-00004cd0: 2063 6f6e 746f 7572 3a20 5653 6574 7469   contour: VSetti
-00004ce0: 6e67 7343 6f6e 746f 7572 0d0a 2020 2020  ngsContour..    
-00004cf0: 6469 616c 6f67 733a 2056 5365 7474 696e  dialogs: VSettin
-00004d00: 6773 4469 616c 6f67 730d 0a20 2020 2065  gsDialogs..    e
-00004d10: 7870 6f72 7449 6d61 6765 733a 2056 5365  xportImages: VSe
-00004d20: 7474 696e 6773 4578 706f 7274 496d 6167  ttingsExportImag
-00004d30: 6573 0d0a 2020 2020 6765 6e65 7261 6c3a  es..    general:
-00004d40: 2056 5365 7474 696e 6773 4765 6e65 7261   VSettingsGenera
-00004d50: 6c0d 0a20 2020 2069 6e74 6572 6163 7469  l..    interacti
-00004d60: 7665 3a20 5653 6574 7469 6e67 7349 6e74  ve: VSettingsInt
-00004d70: 6572 6163 7469 7665 0d0a 2020 2020 6c6f  eractive..    lo
-00004d80: 6164 733a 2056 5365 7474 696e 6773 4c6f  ads: VSettingsLo
-00004d90: 6164 730d 0a20 2020 206d 6172 6b65 7273  ads..    markers
-00004da0: 3a20 5653 6574 7469 6e67 734d 6172 6b65  : VSettingsMarke
-00004db0: 7273 0d0a 2020 2020 6e6f 6465 733a 2056  rs..    nodes: V
-00004dc0: 5365 7474 696e 6773 4e6f 6465 730d 0a20  SettingsNodes.. 
-00004dd0: 2020 206f 7065 6e47 4c3a 2056 5365 7474     openGL: VSett
-00004de0: 696e 6773 4f70 656e 474c 0d0a 2020 2020  ingsOpenGL..    
-00004df0: 7365 6e73 6f72 733a 2056 5365 7474 696e  sensors: VSettin
-00004e00: 6773 5365 6e73 6f72 730d 0a20 2020 2077  gsSensors..    w
-00004e10: 696e 646f 773a 2056 5365 7474 696e 6773  indow: VSettings
-00004e20: 5769 6e64 6f77 0d0a 0d0a 0d0a 636c 6173  Window......clas
-00004e30: 7320 4353 6f6c 7665 7254 696d 6572 3a0d  s CSolverTimer:.
-00004e40: 0a20 2020 2041 4552 4853 3a20 666c 6f61  .    AERHS: floa
-00004e50: 740d 0a20 2020 2065 7272 6f72 4573 7469  t..    errorEsti
-00004e60: 6d61 746f 723a 2066 6c6f 6174 0d0a 2020  mator: float..  
-00004e70: 2020 6661 6374 6f72 697a 6174 696f 6e3a    factorization:
-00004e80: 2066 6c6f 6174 0d0a 2020 2020 696e 7465   float..    inte
-00004e90: 6772 6174 696f 6e46 6f72 6d75 6c61 3a20  grationFormula: 
-00004ea0: 666c 6f61 740d 0a20 2020 206a 6163 6f62  float..    jacob
-00004eb0: 6961 6e41 453a 2066 6c6f 6174 0d0a 2020  ianAE: float..  
-00004ec0: 2020 6a61 636f 6269 616e 4f44 4531 3a20    jacobianODE1: 
-00004ed0: 666c 6f61 740d 0a20 2020 206a 6163 6f62  float..    jacob
-00004ee0: 6961 6e4f 4445 323a 2066 6c6f 6174 0d0a  ianODE2: float..
-00004ef0: 2020 2020 6a61 636f 6269 616e 4f44 4532      jacobianODE2
-00004f00: 5f74 3a20 666c 6f61 740d 0a20 2020 206d  _t: float..    m
-00004f10: 6173 734d 6174 7269 783a 2066 6c6f 6174  assMatrix: float
-00004f20: 0d0a 2020 2020 6e65 7774 6f6e 496e 6372  ..    newtonIncr
-00004f30: 656d 656e 743a 2066 6c6f 6174 0d0a 2020  ement: float..  
-00004f40: 2020 4f44 4531 5248 533a 2066 6c6f 6174    ODE1RHS: float
-00004f50: 0d0a 2020 2020 4f44 4532 5248 533a 2066  ..    ODE2RHS: f
-00004f60: 6c6f 6174 0d0a 2020 2020 6f76 6572 6865  loat..    overhe
-00004f70: 6164 3a20 666c 6f61 740d 0a20 2020 2070  ad: float..    p
-00004f80: 6f73 744e 6577 746f 6e3a 2066 6c6f 6174  ostNewton: float
-00004f90: 0d0a 2020 2020 7079 7468 6f6e 3a20 666c  ..    python: fl
-00004fa0: 6f61 740d 0a20 2020 2072 6561 6374 696f  oat..    reactio
-00004fb0: 6e46 6f72 6365 733a 2066 6c6f 6174 0d0a  nForces: float..
-00004fc0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00004fd0: 2020 2064 6566 2052 6573 6574 2875 7365     def Reset(use
-00004fe0: 536f 6c76 6572 5469 6d65 7229 202d 3e20  SolverTimer) -> 
-00004ff0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-00005000: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00005010: 6620 5374 6172 7454 696d 6572 2876 616c  f StartTimer(val
-00005020: 7565 2920 2d3e 204e 6f6e 653a 202e 2e2e  ue) -> None: ...
-00005030: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00005040: 0a20 2020 2064 6566 2053 746f 7054 696d  .    def StopTim
-00005050: 6572 2876 616c 7565 2920 2d3e 204e 6f6e  er(value) -> Non
-00005060: 653a 202e 2e2e 0d0a 2020 2020 406f 7665  e: .....    @ove
-00005070: 726c 6f61 640d 0a20 2020 2064 6566 2053  rload..    def S
-00005080: 756d 2829 202d 3e20 666c 6f61 743a 202e  um() -> float: .
-00005090: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-000050a0: 640d 0a20 2020 2064 6566 2054 6f53 7472  d..    def ToStr
-000050b0: 696e 6728 2920 2d3e 2073 7472 3a20 2e2e  ing() -> str: ..
-000050c0: 2e0d 0a20 2020 2074 6f74 616c 3a20 666c  ...    total: fl
-000050d0: 6f61 740d 0a20 2020 2074 6f74 616c 4a61  oat..    totalJa
-000050e0: 636f 6269 616e 3a20 666c 6f61 740d 0a20  cobian: float.. 
-000050f0: 2020 2075 7365 5469 6d65 723a 2062 6f6f     useTimer: boo
-00005100: 6c0d 0a20 2020 2076 6973 7561 6c69 7a61  l..    visualiza
-00005110: 7469 6f6e 3a20 666c 6f61 740d 0a20 2020  tion: float..   
-00005120: 2077 7269 7465 536f 6c75 7469 6f6e 3a20   writeSolution: 
-00005130: 666c 6f61 740d 0a0d 0a0d 0a63 6c61 7373  float......class
-00005140: 2053 6f6c 7665 7249 7465 7261 7469 6f6e   SolverIteration
-00005150: 4461 7461 3a0d 0a20 2020 2061 6461 7074  Data:..    adapt
-00005160: 6976 6553 7465 703a 2062 6f6f 6c0d 0a20  iveStep: bool.. 
-00005170: 2020 2061 7574 6f6d 6174 6963 5374 6570     automaticStep
-00005180: 5369 7a65 3a20 626f 6f6c 0d0a 2020 2020  Size: bool..    
-00005190: 6175 746f 6d61 7469 6353 7465 7053 697a  automaticStepSiz
-000051a0: 6545 7272 6f72 3a20 666c 6f61 740d 0a20  eError: float.. 
-000051b0: 2020 2063 7572 7265 6e74 5374 6570 496e     currentStepIn
-000051c0: 6465 783a 2069 6e74 0d0a 2020 2020 6375  dex: int..    cu
-000051d0: 7272 656e 7453 7465 7053 697a 653a 2066  rrentStepSize: f
-000051e0: 6c6f 6174 0d0a 2020 2020 6375 7272 656e  loat..    curren
-000051f0: 7454 696d 653a 2066 6c6f 6174 0d0a 2020  tTime: float..  
-00005200: 2020 6469 7363 6f6e 7469 6e75 6f75 7349    discontinuousI
-00005210: 7465 7261 7469 6f6e 3a20 696e 740d 0a20  teration: int.. 
-00005220: 2020 2064 6973 636f 6e74 696e 756f 7573     discontinuous
-00005230: 4974 6572 6174 696f 6e73 436f 756e 743a  IterationsCount:
-00005240: 2069 6e74 0d0a 2020 2020 656e 6454 696d   int..    endTim
-00005250: 653a 2066 6c6f 6174 0d0a 2020 2020 696e  e: float..    in
-00005260: 6974 6961 6c53 7465 7053 697a 653a 2066  itialStepSize: f
-00005270: 6c6f 6174 0d0a 2020 2020 6c61 7374 5374  loat..    lastSt
-00005280: 6570 5369 7a65 3a20 666c 6f61 740d 0a20  epSize: float.. 
-00005290: 2020 206d 6178 5374 6570 5369 7a65 3a20     maxStepSize: 
-000052a0: 666c 6f61 740d 0a20 2020 206d 696e 5374  float..    minSt
-000052b0: 6570 5369 7a65 3a20 666c 6f61 740d 0a20  epSize: float.. 
-000052c0: 2020 206e 6577 746f 6e4a 6163 6f62 6943     newtonJacobiC
-000052d0: 6f75 6e74 3a20 696e 740d 0a20 2020 206e  ount: int..    n
-000052e0: 6577 746f 6e53 7465 7073 3a20 696e 740d  ewtonSteps: int.
-000052f0: 0a20 2020 206e 6577 746f 6e53 7465 7073  .    newtonSteps
-00005300: 436f 756e 743a 2069 6e74 0d0a 2020 2020  Count: int..    
-00005310: 6e75 6d62 6572 4f66 5374 6570 733a 2069  numberOfSteps: i
-00005320: 6e74 0d0a 2020 2020 7265 636f 6d6d 656e  nt..    recommen
-00005330: 6465 6453 7465 7053 697a 653a 2066 6c6f  dedStepSize: flo
-00005340: 6174 0d0a 2020 2020 7265 6a65 6374 6564  at..    rejected
-00005350: 4175 746f 6d61 7469 6353 7465 7053 697a  AutomaticStepSiz
-00005360: 6553 7465 7073 3a20 696e 740d 0a20 2020  eSteps: int..   
-00005370: 2072 656a 6563 7465 644d 6f64 6966 6965   rejectedModifie
-00005380: 644e 6577 746f 6e53 7465 7073 3a20 696e  dNewtonSteps: in
-00005390: 740d 0a20 2020 2073 7461 7274 5469 6d65  t..    startTime
-000053a0: 3a20 666c 6f61 740d 0a20 2020 2040 6f76  : float..    @ov
-000053b0: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-000053c0: 546f 5374 7269 6e67 2829 202d 3e20 7374  ToString() -> st
-000053d0: 723a 202e 2e2e 0d0a 0d0a 0d0a 636c 6173  r: .........clas
-000053e0: 7320 536f 6c76 6572 436f 6e76 6572 6765  s SolverConverge
-000053f0: 6e63 6544 6174 613a 0d0a 2020 2020 636f  nceData:..    co
-00005400: 6e74 7261 6374 6976 6974 793a 2066 6c6f  ntractivity: flo
-00005410: 6174 0d0a 2020 2020 6469 7363 6f6e 7469  at..    disconti
-00005420: 6e75 6f75 7349 7465 7261 7469 6f6e 4572  nuousIterationEr
-00005430: 726f 723a 2066 6c6f 6174 0d0a 2020 2020  ror: float..    
-00005440: 6469 7363 6f6e 7469 6e75 6f75 7349 7465  discontinuousIte
-00005450: 7261 7469 6f6e 5375 6363 6573 7366 756c  rationSuccessful
-00005460: 3a20 626f 6f6c 0d0a 2020 2020 6572 726f  : bool..    erro
-00005470: 7243 6f6f 7264 696e 6174 6546 6163 746f  rCoordinateFacto
-00005480: 723a 2066 6c6f 6174 0d0a 2020 2020 406f  r: float..    @o
-00005490: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-000054a0: 2049 6e69 7469 616c 697a 6544 6174 6128   InitializeData(
-000054b0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0d0a  ) -> None: .....
-000054c0: 2020 2020 6a61 636f 6269 616e 5570 6461      jacobianUpda
-000054d0: 7465 5265 7175 6573 7465 643a 2062 6f6f  teRequested: boo
-000054e0: 6c0d 0a20 2020 206c 6173 7452 6573 6964  l..    lastResid
-000054f0: 7561 6c3a 2066 6c6f 6174 0d0a 2020 2020  ual: float..    
-00005500: 6c69 6e65 6172 536f 6c76 6572 4361 7573  linearSolverCaus
-00005510: 696e 6752 6f77 3a20 696e 740d 0a20 2020  ingRow: int..   
-00005520: 206c 696e 6561 7253 6f6c 7665 7246 6169   linearSolverFai
-00005530: 6c65 643a 2062 6f6f 6c0d 0a20 2020 206d  led: bool..    m
-00005540: 6173 734d 6174 7269 784e 6f74 496e 7665  assMatrixNotInve
-00005550: 7274 6962 6c65 3a20 626f 6f6c 0d0a 2020  rtible: bool..  
-00005560: 2020 6e65 7774 6f6e 436f 6e76 6572 6765    newtonConverge
-00005570: 643a 2062 6f6f 6c0d 0a20 2020 206e 6577  d: bool..    new
-00005580: 746f 6e53 6f6c 7574 696f 6e44 6976 6572  tonSolutionDiver
-00005590: 6765 643a 2062 6f6f 6c0d 0a20 2020 2072  ged: bool..    r
-000055a0: 6573 6964 7561 6c3a 2066 6c6f 6174 0d0a  esidual: float..
-000055b0: 2020 2020 7374 6570 5265 6475 6374 696f      stepReductio
-000055c0: 6e46 6169 6c65 643a 2062 6f6f 6c0d 0a20  nFailed: bool.. 
-000055d0: 2020 2073 746f 704e 6577 746f 6e3a 2062     stopNewton: b
-000055e0: 6f6f 6c0d 0a0d 0a0d 0a63 6c61 7373 2053  ool......class S
-000055f0: 6f6c 7665 724f 7574 7075 7444 6174 613a  olverOutputData:
-00005600: 0d0a 2020 2020 6370 754c 6173 7454 696d  ..    cpuLastTim
-00005610: 6550 7269 6e74 6564 3a20 666c 6f61 740d  ePrinted: float.
-00005620: 0a20 2020 2063 7075 5374 6172 7454 696d  .    cpuStartTim
-00005630: 653a 2066 6c6f 6174 0d0a 2020 2020 6669  e: float..    fi
-00005640: 6e69 7368 6564 5375 6363 6573 7366 756c  nishedSuccessful
-00005650: 6c79 3a20 626f 6f6c 0d0a 2020 2020 696e  ly: bool..    in
-00005660: 6974 6961 6c69 7a61 7469 6f6e 5375 6363  itializationSucc
-00005670: 6573 7366 756c 3a20 626f 6f6c 0d0a 2020  essful: bool..  
-00005680: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00005690: 2064 6566 2049 6e69 7469 616c 697a 6544   def InitializeD
-000056a0: 6174 6128 2920 2d3e 204e 6f6e 653a 202e  ata() -> None: .
-000056b0: 2e2e 0d0a 2020 2020 6c61 7374 4469 7363  ....    lastDisc
-000056c0: 6f6e 7469 6e75 6f75 7349 7465 7261 7469  ontinuousIterati
-000056d0: 6f6e 7343 6f75 6e74 3a20 696e 740d 0a20  onsCount: int.. 
-000056e0: 2020 206c 6173 7449 6d61 6765 5265 636f     lastImageReco
-000056f0: 7264 6564 3a20 666c 6f61 740d 0a20 2020  rded: float..   
-00005700: 206c 6173 744e 6577 746f 6e4a 6163 6f62   lastNewtonJacob
-00005710: 6943 6f75 6e74 3a20 696e 740d 0a20 2020  iCount: int..   
-00005720: 206c 6173 744e 6577 746f 6e53 7465 7073   lastNewtonSteps
-00005730: 436f 756e 743a 2069 6e74 0d0a 2020 2020  Count: int..    
-00005740: 6c61 7374 5365 6e73 6f72 7357 7269 7474  lastSensorsWritt
-00005750: 656e 3a20 666c 6f61 740d 0a20 2020 206c  en: float..    l
-00005760: 6173 7453 6f6c 7574 696f 6e57 7269 7474  astSolutionWritt
-00005770: 656e 3a20 666c 6f61 740d 0a20 2020 206c  en: float..    l
-00005780: 6173 7456 6572 626f 7365 5374 6570 496e  astVerboseStepIn
-00005790: 6465 783a 2069 6e74 0d0a 2020 2020 6d75  dex: int..    mu
-000057a0: 6c74 6954 6872 6561 6469 6e67 4d6f 6465  ltiThreadingMode
-000057b0: 3a20 696e 740d 0a20 2020 206e 756d 6265  : int..    numbe
-000057c0: 724f 6654 6872 6561 6473 5573 6564 3a20  rOfThreadsUsed: 
-000057d0: 696e 740d 0a20 2020 2073 7465 7049 6e66  int..    stepInf
-000057e0: 6f72 6d61 7469 6f6e 3a20 696e 740d 0a20  ormation: int.. 
-000057f0: 2020 2076 6572 626f 7365 4d6f 6465 3a20     verboseMode: 
-00005800: 696e 740d 0a20 2020 2076 6572 626f 7365  int..    verbose
-00005810: 4d6f 6465 4669 6c65 3a20 696e 740d 0a20  ModeFile: int.. 
-00005820: 2020 2077 7269 7465 546f 536f 6c75 7469     writeToSoluti
-00005830: 6f6e 4669 6c65 3a20 626f 6f6c 0d0a 2020  onFile: bool..  
-00005840: 2020 7772 6974 6554 6f53 6f6c 7665 7246    writeToSolverF
-00005850: 696c 653a 2062 6f6f 6c0d 0a0d 0a0d 0a63  ile: bool......c
-00005860: 6c61 7373 204d 6169 6e53 6f6c 7665 7253  lass MainSolverS
-00005870: 7461 7469 633a 0d0a 2020 2020 636f 6e76  tatic:..    conv
-00005880: 3a20 536f 6c76 6572 436f 6e76 6572 6765  : SolverConverge
-00005890: 6e63 6544 6174 610d 0a20 2020 2069 743a  nceData..    it:
-000058a0: 2053 6f6c 7665 7249 7465 7261 7469 6f6e   SolverIteration
-000058b0: 4461 7461 0d0a 2020 2020 6e65 7774 6f6e  Data..    newton
-000058c0: 3a20 4e65 7774 6f6e 5365 7474 696e 6773  : NewtonSettings
-000058d0: 0d0a 2020 2020 6f75 7470 7574 3a20 536f  ..    output: So
-000058e0: 6c76 6572 4f75 7470 7574 4461 7461 0d0a  lverOutputData..
-000058f0: 2020 2020 7469 6d65 723a 2043 536f 6c76      timer: CSolv
-00005900: 6572 5469 6d65 720d 0a20 2020 2040 6f76  erTimer..    @ov
-00005910: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00005920: 4368 6563 6b49 6e69 7469 616c 697a 6564  CheckInitialized
-00005930: 286d 6169 6e53 7973 7465 6d29 202d 3e20  (mainSystem) -> 
-00005940: 626f 6f6c 3a20 2e2e 2e0d 0a20 2020 2040  bool: .....    @
-00005950: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00005960: 6620 436f 6d70 7574 6541 6c67 6562 7261  f ComputeAlgebra
-00005970: 6963 4571 7561 7469 6f6e 7328 6d61 696e  icEquations(main
-00005980: 5379 7374 656d 2c20 7665 6c6f 6369 7479  System, velocity
-00005990: 4c65 7665 6c3d 4661 6c73 6529 202d 3e20  Level=False) -> 
-000059a0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-000059b0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000059c0: 6620 436f 6d70 7574 654a 6163 6f62 6961  f ComputeJacobia
-000059d0: 6e41 4528 6d61 696e 5379 7374 656d 2c20  nAE(mainSystem, 
-000059e0: 7363 616c 6172 4661 6374 6f72 5f4f 4445  scalarFactor_ODE
-000059f0: 323d 312e 2c20 7363 616c 6172 4661 6374  2=1., scalarFact
-00005a00: 6f72 5f4f 4445 325f 743d 302e 2c20 7363  or_ODE2_t=0., sc
-00005a10: 616c 6172 4661 6374 6f72 5f4f 4445 313d  alarFactor_ODE1=
-00005a20: 312e 2c20 7665 6c6f 6369 7479 4c65 7665  1., velocityLeve
-00005a30: 6c3d 4661 6c73 6529 202d 3e20 4e6f 6e65  l=False) -> None
-00005a40: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00005a50: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-00005a60: 6d70 7574 654a 6163 6f62 6961 6e4f 4445  mputeJacobianODE
-00005a70: 3152 4853 286d 6169 6e53 7973 7465 6d2c  1RHS(mainSystem,
-00005a80: 2073 6361 6c61 7246 6163 746f 725f 4f44   scalarFactor_OD
-00005a90: 4532 3d31 2e2c 2073 6361 6c61 7246 6163  E2=1., scalarFac
-00005aa0: 746f 725f 4f44 4532 5f74 3d30 2e2c 2073  tor_ODE2_t=0., s
-00005ab0: 6361 6c61 7246 6163 746f 725f 4f44 4531  calarFactor_ODE1
-00005ac0: 3d31 2e29 202d 3e20 4e6f 6e65 3a20 2e2e  =1.) -> None: ..
-00005ad0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00005ae0: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-00005af0: 654a 6163 6f62 6961 6e4f 4445 3252 4853  eJacobianODE2RHS
-00005b00: 286d 6169 6e53 7973 7465 6d2c 2073 6361  (mainSystem, sca
-00005b10: 6c61 7246 6163 746f 725f 4f44 4532 3d31  larFactor_ODE2=1
-00005b20: 2e2c 2073 6361 6c61 7246 6163 746f 725f  ., scalarFactor_
-00005b30: 4f44 4532 5f74 3d30 2e2c 2073 6361 6c61  ODE2_t=0., scala
-00005b40: 7246 6163 746f 725f 4f44 4531 3d31 2e2c  rFactor_ODE1=1.,
-00005b50: 2063 6f6d 7075 7465 4c6f 6164 734a 6163   computeLoadsJac
-00005b60: 6f62 6961 6e3d 3029 202d 3e20 4e6f 6e65  obian=0) -> None
-00005b70: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00005b80: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-00005b90: 6d70 7574 654c 6f61 6446 6163 746f 7228  mputeLoadFactor(
-00005ba0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-00005bb0: 6773 2920 2d3e 2066 6c6f 6174 3a20 2e2e  gs) -> float: ..
-00005bc0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00005bd0: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-00005be0: 654d 6173 734d 6174 7269 7828 6d61 696e  eMassMatrix(main
-00005bf0: 5379 7374 656d 2c20 7363 616c 6172 4661  System, scalarFa
-00005c00: 6374 6f72 3d31 2e29 202d 3e20 4e6f 6e65  ctor=1.) -> None
-00005c10: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00005c20: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-00005c30: 6d70 7574 654e 6577 746f 6e4a 6163 6f62  mputeNewtonJacob
-00005c40: 6961 6e28 6d61 696e 5379 7374 656d 2c20  ian(mainSystem, 
-00005c50: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-00005c60: 6773 2920 2d3e 204e 6f6e 653a 202e 2e2e  gs) -> None: ...
-00005c70: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00005c80: 0a20 2020 2064 6566 2043 6f6d 7075 7465  .    def Compute
-00005c90: 4e65 7774 6f6e 5265 7369 6475 616c 286d  NewtonResidual(m
-00005ca0: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00005cb0: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00005cc0: 3e20 666c 6f61 743a 202e 2e2e 0d0a 2020  > float: .....  
-00005cd0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00005ce0: 2064 6566 2043 6f6d 7075 7465 4e65 7774   def ComputeNewt
-00005cf0: 6f6e 5570 6461 7465 286d 6169 6e53 7973  onUpdate(mainSys
-00005d00: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-00005d10: 6574 7469 6e67 732c 2069 6e69 7469 616c  ettings, initial
-00005d20: 3d54 7275 6529 202d 3e20 4e6f 6e65 3a20  =True) -> None: 
-00005d30: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00005d40: 6164 0d0a 2020 2020 6465 6620 436f 6d70  ad..    def Comp
-00005d50: 7574 654f 4445 3252 4853 286d 6169 6e53  uteODE2RHS(mainS
-00005d60: 7973 7465 6d29 202d 3e20 4e6f 6e65 3a20  ystem) -> None: 
-00005d70: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00005d80: 6164 0d0a 2020 2020 6465 6620 4469 7363  ad..    def Disc
-00005d90: 6f6e 7469 6e75 6f75 7349 7465 7261 7469  ontinuousIterati
-00005da0: 6f6e 286d 6169 6e53 7973 7465 6d2c 2073  on(mainSystem, s
-00005db0: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
-00005dc0: 7329 202d 3e20 626f 6f6c 3a20 2e2e 2e0d  s) -> bool: ....
-00005dd0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00005de0: 2020 2020 6465 6620 4669 6e61 6c69 7a65      def Finalize
-00005df0: 536f 6c76 6572 286d 6169 6e53 7973 7465  Solver(mainSyste
-00005e00: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-00005e10: 7469 6e67 7329 202d 3e20 4e6f 6e65 3a20  tings) -> None: 
-00005e20: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00005e30: 6164 0d0a 2020 2020 6465 6620 4669 6e69  ad..    def Fini
-00005e40: 7368 5374 6570 286d 6169 6e53 7973 7465  shStep(mainSyste
+00000000: 0a0a 6672 6f6d 2074 7970 696e 6720 696d  ..from typing im
+00000010: 706f 7274 2028 0a20 2020 2041 6e6e 6f74  port (.    Annot
+00000020: 6174 6564 2c20 0a20 2020 2041 6e79 2c0a  ated, .    Any,.
+00000030: 2020 2020 2320 4279 7465 5374 7269 6e67      # ByteString
+00000040: 2c0a 2020 2020 2320 4361 6c6c 6162 6c65  ,.    # Callable
+00000050: 2c0a 2020 2020 2320 436f 6e74 6169 6e65  ,.    # Containe
+00000060: 722c 0a20 2020 2043 616c 6c61 626c 652c  r,.    Callable,
+00000070: 0a20 2020 2044 6963 742c 0a20 2020 2023  .    Dict,.    #
+00000080: 2047 656e 6572 6963 2c0a 2020 2020 2320   Generic,.    # 
+00000090: 494f 2c0a 2020 2020 2320 4974 6572 6162  IO,.    # Iterab
+000000a0: 6c65 2c0a 2020 2020 2320 4974 6572 6174  le,.    # Iterat
+000000b0: 6f72 2c0a 2020 2020 4c69 7374 2c0a 2020  or,.    List,.  
+000000c0: 2020 4c69 7465 7261 6c2c 0a20 2020 2023    Literal,.    #
+000000d0: 204d 6170 7069 6e67 2c0a 2020 2020 2320   Mapping,.    # 
+000000e0: 4e6f 5265 7475 726e 2c0a 2020 2020 2320  NoReturn,.    # 
+000000f0: 4f70 7469 6f6e 616c 2c0a 2020 2020 6f76  Optional,.    ov
+00000100: 6572 6c6f 6164 2c0a 2020 2020 2320 5365  erload,.    # Se
+00000110: 7175 656e 6365 2c0a 2020 2020 2320 5369  quence,.    # Si
+00000120: 7a65 642c 0a20 2020 2023 2053 7570 706f  zed,.    # Suppo
+00000130: 7274 7343 6f6d 706c 6578 2c0a 2020 2020  rtsComplex,.    
+00000140: 2320 5375 7070 6f72 7473 466c 6f61 742c  # SupportsFloat,
+00000150: 0a20 2020 2023 2053 7570 706f 7274 7349  .    # SupportsI
+00000160: 6e74 2c0a 2020 2020 2320 5465 7874 2c0a  nt,.    # Text,.
+00000170: 2020 2020 5475 706c 652c 2023 666f 7220      Tuple, #for 
+00000180: 5475 706c 655b 696e 742c 2069 6e74 5d0a  Tuple[int, int].
+00000190: 2020 2020 2320 5479 7065 2c0a 2020 2020      # Type,.    
+000001a0: 5479 7065 5661 722c 0a20 2020 2055 6e69  TypeVar,.    Uni
+000001b0: 6f6e 2c0a 290a 6672 6f6d 206e 756d 7079  on,.).from numpy
+000001c0: 2e74 7970 696e 6720 696d 706f 7274 2041  .typing import A
+000001d0: 7272 6179 4c69 6b65 2c20 4e44 4172 7261  rrayLike, NDArra
+000001e0: 790a 6672 6f6d 2065 6e75 6d20 696d 706f  y.from enum impo
+000001f0: 7274 2045 6e75 6d0a 696d 706f 7274 206e  rt Enum.import n
+00000200: 756d 7079 2061 7320 6e70 0a0a 0a0a 5431  umpy as np....T1
+00000210: 203d 2054 7970 6556 6172 2822 5431 222c   = TypeVar("T1",
+00000220: 2062 6f75 6e64 3d69 6e74 290a 5432 203d   bound=int).T2 =
+00000230: 2054 7970 6556 6172 2822 5432 222c 2062   TypeVar("T2", b
+00000240: 6f75 6e64 3d69 6e74 290a 0a53 6861 7065  ound=int)..Shape
+00000250: 203d 2054 7570 6c65 0a53 6861 7065 3144   = Tuple.Shape1D
+00000260: 203d 2053 6861 7065 5b54 315d 0a53 6861   = Shape[T1].Sha
+00000270: 7065 3244 203d 2053 6861 7065 5b54 312c  pe2D = Shape[T1,
+00000280: 2054 325d 0a0a 0a0a 696d 706f 7274 2065   T2]....import e
+00000290: 7875 6479 6e0a 6672 6f6d 2065 7875 6479  xudyn.from exudy
+000002a0: 6e20 696d 706f 7274 2028 4f62 6a65 6374  n import (Object
+000002b0: 496e 6465 782c 204e 6f64 6549 6e64 6578  Index, NodeIndex
+000002c0: 2c20 4d61 726b 6572 496e 6465 782c 204c  , MarkerIndex, L
+000002d0: 6f61 6449 6e64 6578 2c20 5365 6e73 6f72  oadIndex, Sensor
+000002e0: 496e 6465 7829 0a0a 6672 6f6d 2065 7875  Index)..from exu
+000002f0: 6479 6e2e 6772 6170 6869 6373 4461 7461  dyn.graphicsData
+00000300: 5574 696c 6974 6965 7320 696d 706f 7274  Utilities import
+00000310: 2063 6f6c 6f72 3472 6564 2c20 636f 6c6f   color4red, colo
+00000320: 7234 6465 6661 756c 740a 0a0a 0a0a 0a40  r4default......@
+00000330: 6f76 6572 6c6f 6164 0a64 6566 2047 6574  overload.def Get
+00000340: 5665 7273 696f 6e53 7472 696e 6728 6164  VersionString(ad
+00000350: 6444 6574 6169 6c73 3d46 616c 7365 2920  dDetails=False) 
+00000360: 2d3e 2073 7472 3a20 2e2e 2e0a 406f 7665  -> str: ....@ove
+00000370: 726c 6f61 640a 6465 6620 4865 6c70 2829  rload.def Help()
+00000380: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 406f   -> None: ....@o
+00000390: 7665 726c 6f61 640a 6465 6620 5265 7175  verload.def Requ
+000003a0: 6972 6556 6572 7369 6f6e 2872 6571 7569  ireVersion(requi
+000003b0: 7265 6456 6572 7369 6f6e 5374 7269 6e67  redVersionString
+000003c0: 3a20 7374 7229 202d 3e20 4e6f 6e65 3a20  : str) -> None: 
+000003d0: 2e2e 2e0a 406f 7665 726c 6f61 640a 6465  ....@overload.de
+000003e0: 6620 5374 6172 7452 656e 6465 7265 7228  f StartRenderer(
+000003f0: 7665 7262 6f73 653d 3029 202d 3e20 626f  verbose=0) -> bo
+00000400: 6f6c 3a20 2e2e 2e0a 406f 7665 726c 6f61  ol: ....@overloa
+00000410: 640a 6465 6620 4973 5265 6e64 6572 6572  d.def IsRenderer
+00000420: 4163 7469 7665 2829 202d 3e20 626f 6f6c  Active() -> bool
+00000430: 3a20 2e2e 2e0a 406f 7665 726c 6f61 640a  : ....@overload.
+00000440: 6465 6620 446f 5265 6e64 6572 6572 4964  def DoRendererId
+00000450: 6c65 5461 736b 7328 7761 6974 5365 636f  leTasks(waitSeco
+00000460: 6e64 733d 3029 202d 3e20 4e6f 6e65 3a20  nds=0) -> None: 
+00000470: 2e2e 2e0a 406f 7665 726c 6f61 640a 6465  ....@overload.de
+00000480: 6620 536f 6c76 6553 7461 7469 6328 6d62  f SolveStatic(mb
+00000490: 733a 204d 6169 6e53 7973 7465 6d2c 2073  s: MainSystem, s
+000004a0: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+000004b0: 733a 2053 696d 756c 6174 696f 6e53 6574  s: SimulationSet
+000004c0: 7469 6e67 733d 6578 7564 796e 2e53 696d  tings=exudyn.Sim
+000004d0: 756c 6174 696f 6e53 6574 7469 6e67 7328  ulationSettings(
+000004e0: 292c 2075 7064 6174 6549 6e69 7469 616c  ), updateInitial
+000004f0: 5661 6c75 6573 3d46 616c 7365 2c20 7374  Values=False, st
+00000500: 6f72 6553 6f6c 7665 723d 5472 7565 2920  oreSolver=True) 
+00000510: 2d3e 2062 6f6f 6c3a 202e 2e2e 0a40 6f76  -> bool: ....@ov
+00000520: 6572 6c6f 6164 0a64 6566 2053 6f6c 7665  erload.def Solve
+00000530: 4479 6e61 6d69 6328 6d62 733a 204d 6169  Dynamic(mbs: Mai
+00000540: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
+00000550: 696f 6e53 6574 7469 6e67 733a 2053 696d  ionSettings: Sim
+00000560: 756c 6174 696f 6e53 6574 7469 6e67 733d  ulationSettings=
+00000570: 6578 7564 796e 2e53 696d 756c 6174 696f  exudyn.Simulatio
+00000580: 6e53 6574 7469 6e67 7328 292c 2073 6f6c  nSettings(), sol
+00000590: 7665 7254 7970 653a 2044 796e 616d 6963  verType: Dynamic
+000005a0: 536f 6c76 6572 5479 7065 3d65 7875 6479  SolverType=exudy
+000005b0: 6e2e 4479 6e61 6d69 6353 6f6c 7665 7254  n.DynamicSolverT
+000005c0: 7970 652e 4765 6e65 7261 6c69 7a65 6441  ype.GeneralizedA
+000005d0: 6c70 6861 2c20 7570 6461 7465 496e 6974  lpha, updateInit
+000005e0: 6961 6c56 616c 7565 733d 4661 6c73 652c  ialValues=False,
+000005f0: 2073 746f 7265 536f 6c76 6572 3d54 7275   storeSolver=Tru
+00000600: 6529 202d 3e20 626f 6f6c 3a20 2e2e 2e0a  e) -> bool: ....
+00000610: 406f 7665 726c 6f61 640a 6465 6620 436f  @overload.def Co
+00000620: 6d70 7574 654f 4445 3245 6967 656e 7661  mputeODE2Eigenva
+00000630: 6c75 6573 286d 6273 3a20 4d61 696e 5379  lues(mbs: MainSy
+00000640: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
+00000650: 5365 7474 696e 6773 3a20 5369 6d75 6c61  Settings: Simula
+00000660: 7469 6f6e 5365 7474 696e 6773 3d65 7875  tionSettings=exu
+00000670: 6479 6e2e 5369 6d75 6c61 7469 6f6e 5365  dyn.SimulationSe
+00000680: 7474 696e 6773 2829 2c20 7573 6553 7061  ttings(), useSpa
+00000690: 7273 6553 6f6c 7665 723d 4661 6c73 652c  rseSolver=False,
+000006a0: 206e 756d 6265 724f 6645 6967 656e 7661   numberOfEigenva
+000006b0: 6c75 6573 3d2d 312c 2073 6574 496e 6974  lues=-1, setInit
+000006c0: 6961 6c56 616c 7565 733d 5472 7565 2c20  ialValues=True, 
+000006d0: 636f 6e76 6572 7432 4672 6571 7565 6e63  convert2Frequenc
+000006e0: 6965 733d 4661 6c73 6529 202d 3e20 626f  ies=False) -> bo
+000006f0: 6f6c 3a20 2e2e 2e0a 406f 7665 726c 6f61  ol: ....@overloa
+00000700: 640a 6465 6620 5365 744f 7574 7075 7450  d.def SetOutputP
+00000710: 7265 6369 7369 6f6e 286e 756d 6265 724f  recision(numberO
+00000720: 6644 6967 6974 733a 2069 6e74 2920 2d3e  fDigits: int) ->
+00000730: 204e 6f6e 653a 202e 2e2e 0a40 6f76 6572   None: ....@over
+00000740: 6c6f 6164 0a64 6566 2053 6574 4c69 6e61  load.def SetLina
+00000750: 6c67 4f75 7470 7574 466f 726d 6174 5079  lgOutputFormatPy
+00000760: 7468 6f6e 2866 6c61 6750 7974 686f 6e46  thon(flagPythonF
+00000770: 6f72 6d61 743a 2062 6f6f 6c29 202d 3e20  ormat: bool) -> 
+00000780: 4e6f 6e65 3a20 2e2e 2e0a 406f 7665 726c  None: ....@overl
+00000790: 6f61 640a 6465 6620 5365 7457 7269 7465  oad.def SetWrite
+000007a0: 546f 436f 6e73 6f6c 6528 666c 6167 3a20  ToConsole(flag: 
+000007b0: 626f 6f6c 2920 2d3e 204e 6f6e 653a 202e  bool) -> None: .
+000007c0: 2e2e 0a40 6f76 6572 6c6f 6164 0a64 6566  ...@overload.def
+000007d0: 2053 6574 5772 6974 6554 6f46 696c 6528   SetWriteToFile(
+000007e0: 6669 6c65 6e61 6d65 3a20 7374 722c 2066  filename: str, f
+000007f0: 6c61 6757 7269 7465 546f 4669 6c65 3d54  lagWriteToFile=T
+00000800: 7275 652c 2066 6c61 6741 7070 656e 643d  rue, flagAppend=
+00000810: 4661 6c73 6529 202d 3e20 4e6f 6e65 3a20  False) -> None: 
+00000820: 2e2e 2e0a 406f 7665 726c 6f61 640a 6465  ....@overload.de
+00000830: 6620 5365 7450 7269 6e74 4465 6c61 794d  f SetPrintDelayM
+00000840: 696c 6c69 5365 636f 6e64 7328 6465 6c61  illiSeconds(dela
+00000850: 794d 696c 6c69 5365 636f 6e64 733a 2069  yMilliSeconds: i
+00000860: 6e74 2920 2d3e 204e 6f6e 653a 202e 2e2e  nt) -> None: ...
+00000870: 0a40 6f76 6572 6c6f 6164 0a64 6566 2050  .@overload.def P
+00000880: 7269 6e74 282a 6172 6773 3a20 416e 7929  rint(*args: Any)
+00000890: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 406f   -> None: ....@o
+000008a0: 7665 726c 6f61 640a 6465 6620 5375 7070  verload.def Supp
+000008b0: 7265 7373 5761 726e 696e 6773 2866 6c61  ressWarnings(fla
+000008c0: 673a 2062 6f6f 6c29 202d 3e20 4e6f 6e65  g: bool) -> None
+000008d0: 3a20 2e2e 2e0a 406f 7665 726c 6f61 640a  : ....@overload.
+000008e0: 6465 6620 496e 666f 5374 6174 2877 7269  def InfoStat(wri
+000008f0: 7465 4f75 7470 7574 3d54 7275 6529 202d  teOutput=True) -
+00000900: 3e20 4c69 7374 5b69 6e74 5d3a 202e 2e2e  > List[int]: ...
+00000910: 0a40 6f76 6572 6c6f 6164 0a64 6566 2047  .@overload.def G
+00000920: 6f28 2920 2d3e 204e 6f6e 653a 202e 2e2e  o() -> None: ...
+00000930: 0a40 6f76 6572 6c6f 6164 0a64 6566 2044  .@overload.def D
+00000940: 656d 6f31 2873 686f 7741 6c6c 3a20 626f  emo1(showAll: bo
+00000950: 6f6c 2920 2d3e 205b 4d61 696e 5379 7374  ol) -> [MainSyst
+00000960: 656d 2c20 5379 7374 656d 436f 6e74 6169  em, SystemContai
+00000970: 6e65 725d 3a20 2e2e 2e0a 406f 7665 726c  ner]: ....@overl
+00000980: 6f61 640a 6465 6620 4465 6d6f 3228 7368  oad.def Demo2(sh
+00000990: 6f77 416c 6c3a 2062 6f6f 6c29 202d 3e20  owAll: bool) -> 
+000009a0: 5b4d 6169 6e53 7973 7465 6d2c 2053 7973  [MainSystem, Sys
+000009b0: 7465 6d43 6f6e 7461 696e 6572 5d3a 202e  temContainer]: .
+000009c0: 2e2e 0a40 6f76 6572 6c6f 6164 0a64 6566  ...@overload.def
+000009d0: 2049 6e76 616c 6964 496e 6465 7828 2920   InvalidIndex() 
+000009e0: 2d3e 2069 6e74 3a20 2e2e 2e0a 5f5f 7665  -> int: ....__ve
+000009f0: 7273 696f 6e5f 5f3a 7374 720a 6578 7065  rsion__:str.expe
+00000a00: 7269 6d65 6e74 616c 3a45 7870 6572 696d  rimental:Experim
+00000a10: 656e 7461 6c0a 7370 6563 6961 6c3a 5370  ental.special:Sp
+00000a20: 6563 6961 6c0a 7370 6563 6961 6c2e 736f  ecial.special.so
+00000a30: 6c76 6572 3a53 7065 6369 616c 536f 6c76  lver:SpecialSolv
+00000a40: 6572 0a73 7065 6369 616c 2e73 6f6c 7665  er.special.solve
+00000a50: 722e 7469 6d65 6f75 743a 666c 6f61 740a  r.timeout:float.
+00000a60: 7661 7269 6162 6c65 733a 6469 6374 0a73  variables:dict.s
+00000a70: 7973 3a64 6963 740a 0a0a 636c 6173 7320  ys:dict...class 
+00000a80: 4f75 7470 7574 5661 7269 6162 6c65 5479  OutputVariableTy
+00000a90: 7065 2845 6e75 6d29 3a0a 2020 2020 5f4e  pe(Enum):.    _N
+00000aa0: 6f6e 6520 3d20 696e 740a 2020 2020 4469  one = int.    Di
+00000ab0: 7374 616e 6365 203d 2069 6e74 0a20 2020  stance = int.   
+00000ac0: 2050 6f73 6974 696f 6e20 3d20 696e 740a   Position = int.
+00000ad0: 2020 2020 4469 7370 6c61 6365 6d65 6e74      Displacement
+00000ae0: 203d 2069 6e74 0a20 2020 2044 6973 706c   = int.    Displ
+00000af0: 6163 656d 656e 744c 6f63 616c 203d 2069  acementLocal = i
+00000b00: 6e74 0a20 2020 2056 656c 6f63 6974 7920  nt.    Velocity 
+00000b10: 3d20 696e 740a 2020 2020 5665 6c6f 6369  = int.    Veloci
+00000b20: 7479 4c6f 6361 6c20 3d20 696e 740a 2020  tyLocal = int.  
+00000b30: 2020 4163 6365 6c65 7261 7469 6f6e 203d    Acceleration =
+00000b40: 2069 6e74 0a20 2020 2041 6363 656c 6572   int.    Acceler
+00000b50: 6174 696f 6e4c 6f63 616c 203d 2069 6e74  ationLocal = int
+00000b60: 0a20 2020 2052 6f74 6174 696f 6e4d 6174  .    RotationMat
+00000b70: 7269 7820 3d20 696e 740a 2020 2020 526f  rix = int.    Ro
+00000b80: 7461 7469 6f6e 203d 2069 6e74 0a20 2020  tation = int.   
+00000b90: 2041 6e67 756c 6172 5665 6c6f 6369 7479   AngularVelocity
+00000ba0: 203d 2069 6e74 0a20 2020 2041 6e67 756c   = int.    Angul
+00000bb0: 6172 5665 6c6f 6369 7479 4c6f 6361 6c20  arVelocityLocal 
+00000bc0: 3d20 696e 740a 2020 2020 416e 6775 6c61  = int.    Angula
+00000bd0: 7241 6363 656c 6572 6174 696f 6e20 3d20  rAcceleration = 
+00000be0: 696e 740a 2020 2020 416e 6775 6c61 7241  int.    AngularA
+00000bf0: 6363 656c 6572 6174 696f 6e4c 6f63 616c  ccelerationLocal
+00000c00: 203d 2069 6e74 0a20 2020 2043 6f6f 7264   = int.    Coord
+00000c10: 696e 6174 6573 203d 2069 6e74 0a20 2020  inates = int.   
+00000c20: 2043 6f6f 7264 696e 6174 6573 5f74 203d   Coordinates_t =
+00000c30: 2069 6e74 0a20 2020 2043 6f6f 7264 696e   int.    Coordin
+00000c40: 6174 6573 5f74 7420 3d20 696e 740a 2020  ates_tt = int.  
+00000c50: 2020 536c 6964 696e 6743 6f6f 7264 696e    SlidingCoordin
+00000c60: 6174 6520 3d20 696e 740a 2020 2020 4469  ate = int.    Di
+00000c70: 7265 6374 6f72 3120 3d20 696e 740a 2020  rector1 = int.  
+00000c80: 2020 4469 7265 6374 6f72 3220 3d20 696e    Director2 = in
+00000c90: 740a 2020 2020 4469 7265 6374 6f72 3320  t.    Director3 
+00000ca0: 3d20 696e 740a 2020 2020 466f 7263 6520  = int.    Force 
+00000cb0: 3d20 696e 740a 2020 2020 466f 7263 654c  = int.    ForceL
+00000cc0: 6f63 616c 203d 2069 6e74 0a20 2020 2054  ocal = int.    T
+00000cd0: 6f72 7175 6520 3d20 696e 740a 2020 2020  orque = int.    
+00000ce0: 546f 7271 7565 4c6f 6361 6c20 3d20 696e  TorqueLocal = in
+00000cf0: 740a 2020 2020 5374 7261 696e 4c6f 6361  t.    StrainLoca
+00000d00: 6c20 3d20 696e 740a 2020 2020 5374 7265  l = int.    Stre
+00000d10: 7373 4c6f 6361 6c20 3d20 696e 740a 2020  ssLocal = int.  
+00000d20: 2020 4375 7276 6174 7572 654c 6f63 616c    CurvatureLocal
+00000d30: 203d 2069 6e74 0a20 2020 2043 6f6e 7374   = int.    Const
+00000d40: 7261 696e 7445 7175 6174 696f 6e20 3d20  raintEquation = 
+00000d50: 696e 740a 0a0a 636c 6173 7320 436f 6e66  int...class Conf
+00000d60: 6967 7572 6174 696f 6e54 7970 6528 456e  igurationType(En
+00000d70: 756d 293a 0a20 2020 205f 4e6f 6e65 203d  um):.    _None =
+00000d80: 2069 6e74 0a20 2020 2049 6e69 7469 616c   int.    Initial
+00000d90: 203d 2069 6e74 0a20 2020 2043 7572 7265   = int.    Curre
+00000da0: 6e74 203d 2069 6e74 0a20 2020 2052 6566  nt = int.    Ref
+00000db0: 6572 656e 6365 203d 2069 6e74 0a20 2020  erence = int.   
+00000dc0: 2053 7461 7274 4f66 5374 6570 203d 2069   StartOfStep = i
+00000dd0: 6e74 0a20 2020 2056 6973 7561 6c69 7a61  nt.    Visualiza
+00000de0: 7469 6f6e 203d 2069 6e74 0a20 2020 2045  tion = int.    E
+00000df0: 6e64 4f66 456e 756d 4c69 7374 203d 2069  ndOfEnumList = i
+00000e00: 6e74 0a0a 0a63 6c61 7373 2049 7465 6d54  nt...class ItemT
+00000e10: 7970 6528 456e 756d 293a 0a20 2020 205f  ype(Enum):.    _
+00000e20: 4e6f 6e65 203d 2069 6e74 0a20 2020 204e  None = int.    N
+00000e30: 6f64 6520 3d20 696e 740a 2020 2020 4f62  ode = int.    Ob
+00000e40: 6a65 6374 203d 2069 6e74 0a20 2020 204d  ject = int.    M
+00000e50: 6172 6b65 7220 3d20 696e 740a 2020 2020  arker = int.    
+00000e60: 4c6f 6164 203d 2069 6e74 0a20 2020 2053  Load = int.    S
+00000e70: 656e 736f 7220 3d20 696e 740a 0a0a 636c  ensor = int...cl
+00000e80: 6173 7320 4e6f 6465 5479 7065 2845 6e75  ass NodeType(Enu
+00000e90: 6d29 3a0a 2020 2020 5f4e 6f6e 6520 3d20  m):.    _None = 
+00000ea0: 696e 740a 2020 2020 4772 6f75 6e64 203d  int.    Ground =
+00000eb0: 2069 6e74 0a20 2020 2050 6f73 6974 696f   int.    Positio
+00000ec0: 6e32 4420 3d20 696e 740a 2020 2020 4f72  n2D = int.    Or
+00000ed0: 6965 6e74 6174 696f 6e32 4420 3d20 696e  ientation2D = in
+00000ee0: 740a 2020 2020 506f 696e 7432 4453 6c6f  t.    Point2DSlo
+00000ef0: 7065 3120 3d20 696e 740a 2020 2020 506f  pe1 = int.    Po
+00000f00: 7369 7469 6f6e 203d 2069 6e74 0a20 2020  sition = int.   
+00000f10: 204f 7269 656e 7461 7469 6f6e 203d 2069   Orientation = i
+00000f20: 6e74 0a20 2020 2052 6967 6964 426f 6479  nt.    RigidBody
+00000f30: 203d 2069 6e74 0a20 2020 2052 6f74 6174   = int.    Rotat
+00000f40: 696f 6e45 756c 6572 5061 7261 6d65 7465  ionEulerParamete
+00000f50: 7273 203d 2069 6e74 0a20 2020 2052 6f74  rs = int.    Rot
+00000f60: 6174 696f 6e52 7879 7a20 3d20 696e 740a  ationRxyz = int.
+00000f70: 2020 2020 526f 7461 7469 6f6e 526f 7461      RotationRota
+00000f80: 7469 6f6e 5665 6374 6f72 203d 2069 6e74  tionVector = int
+00000f90: 0a20 2020 204c 6965 4772 6f75 7057 6974  .    LieGroupWit
+00000fa0: 6844 6972 6563 7455 7064 6174 6520 3d20  hDirectUpdate = 
+00000fb0: 696e 740a 2020 2020 4765 6e65 7269 634f  int.    GenericO
+00000fc0: 4445 3220 3d20 696e 740a 2020 2020 4765  DE2 = int.    Ge
+00000fd0: 6e65 7269 634f 4445 3120 3d20 696e 740a  nericODE1 = int.
+00000fe0: 2020 2020 4765 6e65 7269 6341 4520 3d20      GenericAE = 
+00000ff0: 696e 740a 2020 2020 4765 6e65 7269 6344  int.    GenericD
+00001000: 6174 6120 3d20 696e 740a 2020 2020 506f  ata = int.    Po
+00001010: 696e 7453 6c6f 7065 3120 3d20 696e 740a  intSlope1 = int.
+00001020: 2020 2020 506f 696e 7453 6c6f 7065 3132      PointSlope12
+00001030: 203d 2069 6e74 0a20 2020 2050 6f69 6e74   = int.    Point
+00001040: 536c 6f70 6532 3320 3d20 696e 740a 0a0a  Slope23 = int...
+00001050: 636c 6173 7320 4a6f 696e 7454 7970 6528  class JointType(
+00001060: 456e 756d 293a 0a20 2020 205f 4e6f 6e65  Enum):.    _None
+00001070: 203d 2069 6e74 0a20 2020 2052 6576 6f6c   = int.    Revol
+00001080: 7574 6558 203d 2069 6e74 0a20 2020 2052  uteX = int.    R
+00001090: 6576 6f6c 7574 6559 203d 2069 6e74 0a20  evoluteY = int. 
+000010a0: 2020 2052 6576 6f6c 7574 655a 203d 2069     RevoluteZ = i
+000010b0: 6e74 0a20 2020 2050 7269 736d 6174 6963  nt.    Prismatic
+000010c0: 5820 3d20 696e 740a 2020 2020 5072 6973  X = int.    Pris
+000010d0: 6d61 7469 6359 203d 2069 6e74 0a20 2020  maticY = int.   
+000010e0: 2050 7269 736d 6174 6963 5a20 3d20 696e   PrismaticZ = in
+000010f0: 740a 0a0a 636c 6173 7320 4479 6e61 6d69  t...class Dynami
+00001100: 6353 6f6c 7665 7254 7970 6528 456e 756d  cSolverType(Enum
+00001110: 293a 0a20 2020 2047 656e 6572 616c 697a  ):.    Generaliz
+00001120: 6564 416c 7068 6120 3d20 696e 740a 2020  edAlpha = int.  
+00001130: 2020 5472 6170 657a 6f69 6461 6c49 6e64    TrapezoidalInd
+00001140: 6578 3220 3d20 696e 740a 2020 2020 4578  ex2 = int.    Ex
+00001150: 706c 6963 6974 4575 6c65 7220 3d20 696e  plicitEuler = in
+00001160: 740a 2020 2020 4578 706c 6963 6974 4d69  t.    ExplicitMi
+00001170: 6470 6f69 6e74 203d 2069 6e74 0a20 2020  dpoint = int.   
+00001180: 2052 4b33 3320 3d20 696e 740a 2020 2020   RK33 = int.    
+00001190: 524b 3434 203d 2069 6e74 0a20 2020 2052  RK44 = int.    R
+000011a0: 4b36 3720 3d20 696e 740a 2020 2020 4f44  K67 = int.    OD
+000011b0: 4532 3320 3d20 696e 740a 2020 2020 444f  E23 = int.    DO
+000011c0: 5052 4935 203d 2069 6e74 0a20 2020 2044  PRI5 = int.    D
+000011d0: 5645 524b 3620 3d20 696e 740a 0a0a 636c  VERK6 = int...cl
+000011e0: 6173 7320 4372 6f73 7353 6563 7469 6f6e  ass CrossSection
+000011f0: 5479 7065 2845 6e75 6d29 3a0a 2020 2020  Type(Enum):.    
+00001200: 506f 6c79 676f 6e20 3d20 696e 740a 2020  Polygon = int.  
+00001210: 2020 4369 7263 756c 6172 203d 2069 6e74    Circular = int
+00001220: 0a0a 0a63 6c61 7373 204b 6579 436f 6465  ...class KeyCode
+00001230: 2845 6e75 6d29 3a0a 2020 2020 5350 4143  (Enum):.    SPAC
+00001240: 4520 3d20 696e 740a 2020 2020 454e 5445  E = int.    ENTE
+00001250: 5220 3d20 696e 740a 2020 2020 5441 4220  R = int.    TAB 
+00001260: 3d20 696e 740a 2020 2020 4241 434b 5350  = int.    BACKSP
+00001270: 4143 4520 3d20 696e 740a 2020 2020 5249  ACE = int.    RI
+00001280: 4748 5420 3d20 696e 740a 2020 2020 4c45  GHT = int.    LE
+00001290: 4654 203d 2069 6e74 0a20 2020 2044 4f57  FT = int.    DOW
+000012a0: 4e20 3d20 696e 740a 2020 2020 5550 203d  N = int.    UP =
+000012b0: 2069 6e74 0a20 2020 2046 3120 3d20 696e   int.    F1 = in
+000012c0: 740a 2020 2020 4632 203d 2069 6e74 0a20  t.    F2 = int. 
+000012d0: 2020 2046 3320 3d20 696e 740a 2020 2020     F3 = int.    
+000012e0: 4634 203d 2069 6e74 0a20 2020 2046 3520  F4 = int.    F5 
+000012f0: 3d20 696e 740a 2020 2020 4636 203d 2069  = int.    F6 = i
+00001300: 6e74 0a20 2020 2046 3720 3d20 696e 740a  nt.    F7 = int.
+00001310: 2020 2020 4638 203d 2069 6e74 0a20 2020      F8 = int.   
+00001320: 2046 3920 3d20 696e 740a 2020 2020 4631   F9 = int.    F1
+00001330: 3020 3d20 696e 740a 0a0a 636c 6173 7320  0 = int...class 
+00001340: 4c69 6e65 6172 536f 6c76 6572 5479 7065  LinearSolverType
+00001350: 2845 6e75 6d29 3a0a 2020 2020 5f4e 6f6e  (Enum):.    _Non
+00001360: 6520 3d20 696e 740a 2020 2020 4558 5564  e = int.    EXUd
+00001370: 656e 7365 203d 2069 6e74 0a20 2020 2045  ense = int.    E
+00001380: 6967 656e 5370 6172 7365 203d 2069 6e74  igenSparse = int
+00001390: 0a20 2020 2045 6967 656e 5370 6172 7365  .    EigenSparse
+000013a0: 5379 6d6d 6574 7269 6320 3d20 696e 740a  Symmetric = int.
+000013b0: 2020 2020 4569 6765 6e44 656e 7365 203d      EigenDense =
+000013c0: 2069 6e74 0a0a 0a63 6c61 7373 2043 6f6e   int...class Con
+000013d0: 7461 6374 5479 7065 496e 6465 7828 456e  tactTypeIndex(En
+000013e0: 756d 293a 0a20 2020 2049 6e64 6578 5370  um):.    IndexSp
+000013f0: 6865 7265 734d 6172 6b65 7242 6173 6564  heresMarkerBased
+00001400: 203d 2069 6e74 0a20 2020 2049 6e64 6578   = int.    Index
+00001410: 414e 4346 4361 626c 6532 4420 3d20 696e  ANCFCable2D = in
+00001420: 740a 2020 2020 496e 6465 7854 7269 6773  t.    IndexTrigs
+00001430: 5269 6769 6442 6f64 7942 6173 6564 203d  RigidBodyBased =
+00001440: 2069 6e74 0a20 2020 2049 6e64 6578 456e   int.    IndexEn
+00001450: 644f 6645 6e75 6d4c 6973 7420 3d20 696e  dOfEnumList = in
+00001460: 740a 0a0a 636c 6173 7320 4d61 7472 6978  t...class Matrix
+00001470: 436f 6e74 6169 6e65 723a 0a20 2020 2040  Container:.    @
+00001480: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+00001490: 2053 6574 5769 7468 4465 6e73 654d 6174   SetWithDenseMat
+000014a0: 7269 7828 7365 6c66 2c20 7079 4172 7261  rix(self, pyArra
+000014b0: 793a 2041 7272 6179 4c69 6b65 2c20 7573  y: ArrayLike, us
+000014c0: 6544 656e 7365 4d61 7472 6978 3d46 616c  eDenseMatrix=Fal
+000014d0: 7365 2920 2d3e 204e 6f6e 653a 202e 2e2e  se) -> None: ...
+000014e0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+000014f0: 2020 2064 6566 2053 6574 5769 7468 5370     def SetWithSp
+00001500: 6172 7365 4d61 7472 6978 4353 5228 7365  arseMatrixCSR(se
+00001510: 6c66 2c20 6e75 6d62 6572 4f66 526f 7773  lf, numberOfRows
+00001520: 496e 6974 3a20 696e 742c 206e 756d 6265  Init: int, numbe
+00001530: 724f 6643 6f6c 756d 6e73 496e 6974 3a20  rOfColumnsInit: 
+00001540: 696e 742c 2070 7941 7272 6179 4353 523a  int, pyArrayCSR:
+00001550: 2041 7272 6179 4c69 6b65 2c20 7573 6544   ArrayLike, useD
+00001560: 656e 7365 4d61 7472 6978 3d54 7275 6529  enseMatrix=True)
+00001570: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+00001580: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00001590: 6465 6620 4765 7450 7974 686f 6e4f 626a  def GetPythonObj
+000015a0: 6563 7428 7365 6c66 2920 2d3e 2055 6e69  ect(self) -> Uni
+000015b0: 6f6e 5b64 6963 742c 4172 7261 794c 696b  on[dict,ArrayLik
+000015c0: 655d 3a20 2e2e 2e0a 2020 2020 406f 7665  e]: ....    @ove
+000015d0: 726c 6f61 640a 2020 2020 6465 6620 436f  rload.    def Co
+000015e0: 6e76 6572 7432 4465 6e73 654d 6174 7269  nvert2DenseMatri
+000015f0: 7828 7365 6c66 2920 2d3e 2041 7272 6179  x(self) -> Array
+00001600: 4c69 6b65 3a20 2e2e 2e0a 2020 2020 406f  Like: ....    @o
+00001610: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00001620: 5573 6544 656e 7365 4d61 7472 6978 2873  UseDenseMatrix(s
+00001630: 656c 6629 202d 3e20 626f 6f6c 3a20 2e2e  elf) -> bool: ..
+00001640: 2e0a 0a0a 636c 6173 7320 5665 6374 6f72  ....class Vector
+00001650: 3344 4c69 7374 3a0a 2020 2020 406f 7665  3DList:.    @ove
+00001660: 726c 6f61 640a 2020 2020 6465 6620 4170  rload.    def Ap
+00001670: 7065 6e64 2873 656c 662c 2070 7941 7272  pend(self, pyArr
+00001680: 6179 3a20 5b66 6c6f 6174 2c66 6c6f 6174  ay: [float,float
+00001690: 2c66 6c6f 6174 5d29 202d 3e20 4e6f 6e65  ,float]) -> None
+000016a0: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+000016b0: 6f61 640a 2020 2020 6465 6620 4765 7450  oad.    def GetP
+000016c0: 7974 686f 6e4f 626a 6563 7428 7365 6c66  ythonObject(self
+000016d0: 2920 2d3e 204c 6973 745b 5b66 6c6f 6174  ) -> List[[float
+000016e0: 2c66 6c6f 6174 2c66 6c6f 6174 5d5d 3a20  ,float,float]]: 
+000016f0: 2e2e 2e0a 0a0a 636c 6173 7320 5665 6374  ......class Vect
+00001700: 6f72 3244 4c69 7374 3a0a 2020 2020 406f  or2DList:.    @o
+00001710: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00001720: 4170 7065 6e64 2873 656c 662c 2070 7941  Append(self, pyA
+00001730: 7272 6179 3a20 5b66 6c6f 6174 2c66 6c6f  rray: [float,flo
+00001740: 6174 5d29 202d 3e20 4e6f 6e65 3a20 2e2e  at]) -> None: ..
+00001750: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+00001760: 2020 2020 6465 6620 4765 7450 7974 686f      def GetPytho
+00001770: 6e4f 626a 6563 7428 7365 6c66 2920 2d3e  nObject(self) ->
+00001780: 204c 6973 745b 5b66 6c6f 6174 2c66 6c6f   List[[float,flo
+00001790: 6174 5d5d 3a20 2e2e 2e0a 0a0a 636c 6173  at]]: ......clas
+000017a0: 7320 5665 6374 6f72 3644 4c69 7374 3a0a  s Vector6DList:.
+000017b0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+000017c0: 2020 6465 6620 4170 7065 6e64 2873 656c    def Append(sel
+000017d0: 662c 2070 7941 7272 6179 3a20 5b66 6c6f  f, pyArray: [flo
+000017e0: 6174 2c66 6c6f 6174 2c66 6c6f 6174 2c66  at,float,float,f
+000017f0: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
+00001800: 5d29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  ]) -> None: ....
+00001810: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00001820: 2020 6465 6620 4765 7450 7974 686f 6e4f    def GetPythonO
+00001830: 626a 6563 7428 7365 6c66 2920 2d3e 204c  bject(self) -> L
+00001840: 6973 745b 5b66 6c6f 6174 2c66 6c6f 6174  ist[[float,float
+00001850: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
+00001860: 6174 2c66 6c6f 6174 5d5d 3a20 2e2e 2e0a  at,float]]: ....
+00001870: 0a0a 636c 6173 7320 4d61 7472 6978 3344  ..class Matrix3D
+00001880: 4c69 7374 3a0a 2020 2020 406f 7665 726c  List:.    @overl
+00001890: 6f61 640a 2020 2020 6465 6620 4170 7065  oad.    def Appe
+000018a0: 6e64 2873 656c 662c 2070 7941 7272 6179  nd(self, pyArray
+000018b0: 3a20 4e44 4172 7261 795b 5368 6170 6532  : NDArray[Shape2
+000018c0: 445b 332c 335d 2c20 666c 6f61 745d 2920  D[3,3], float]) 
+000018d0: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+000018e0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+000018f0: 6566 2047 6574 5079 7468 6f6e 4f62 6a65  ef GetPythonObje
+00001900: 6374 2873 656c 6629 202d 3e20 4c69 7374  ct(self) -> List
+00001910: 5b4e 4441 7272 6179 5b53 6861 7065 3244  [NDArray[Shape2D
+00001920: 5b33 2c33 5d2c 2066 6c6f 6174 5d5d 3a20  [3,3], float]]: 
+00001930: 2e2e 2e0a 0a0a 636c 6173 7320 4d61 7472  ......class Matr
+00001940: 6978 3644 4c69 7374 3a0a 2020 2020 406f  ix6DList:.    @o
+00001950: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00001960: 4170 7065 6e64 2873 656c 662c 2070 7941  Append(self, pyA
+00001970: 7272 6179 3a20 4e44 4172 7261 795b 5368  rray: NDArray[Sh
+00001980: 6170 6532 445b 362c 365d 2c20 666c 6f61  ape2D[6,6], floa
+00001990: 745d 2920 2d3e 204e 6f6e 653a 202e 2e2e  t]) -> None: ...
+000019a0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+000019b0: 2020 2064 6566 2047 6574 5079 7468 6f6e     def GetPython
+000019c0: 4f62 6a65 6374 2873 656c 6629 202d 3e20  Object(self) -> 
+000019d0: 4c69 7374 5b4e 4441 7272 6179 5b53 6861  List[NDArray[Sha
+000019e0: 7065 3244 5b36 2c36 5d2c 2066 6c6f 6174  pe2D[6,6], float
+000019f0: 5d5d 3a20 2e2e 2e0a 0a0a 636c 6173 7320  ]]: ......class 
+00001a00: 4265 616d 5365 6374 696f 6e3a 0a20 2020  BeamSection:.   
+00001a10: 2064 616d 7069 6e67 4d61 7472 6978 3a20   dampingMatrix: 
+00001a20: 4172 7261 794c 696b 650a 2020 2020 696e  ArrayLike.    in
+00001a30: 6572 7469 613a 2041 7272 6179 4c69 6b65  ertia: ArrayLike
+00001a40: 0a20 2020 206d 6173 7350 6572 4c65 6e67  .    massPerLeng
+00001a50: 7468 3a20 666c 6f61 740a 2020 2020 7374  th: float.    st
+00001a60: 6966 666e 6573 734d 6174 7269 783a 2041  iffnessMatrix: A
+00001a70: 7272 6179 4c69 6b65 0a0a 0a63 6c61 7373  rrayLike...class
+00001a80: 2042 6561 6d53 6563 7469 6f6e 4765 6f6d   BeamSectionGeom
+00001a90: 6574 7279 3a0a 2020 2020 6372 6f73 7353  etry:.    crossS
+00001aa0: 6563 7469 6f6e 5261 6469 7573 593a 2066  ectionRadiusY: f
+00001ab0: 6c6f 6174 0a20 2020 2063 726f 7373 5365  loat.    crossSe
+00001ac0: 6374 696f 6e52 6164 6975 735a 3a20 666c  ctionRadiusZ: fl
+00001ad0: 6f61 740a 2020 2020 6372 6f73 7353 6563  oat.    crossSec
+00001ae0: 7469 6f6e 5479 7065 3a20 4372 6f73 7353  tionType: CrossS
+00001af0: 6563 7469 6f6e 5479 7065 0a20 2020 2070  ectionType.    p
+00001b00: 6f6c 7967 6f6e 616c 506f 696e 7473 3a20  olygonalPoints: 
+00001b10: 5665 6374 6f72 3244 4c69 7374 0a0a 0a63  Vector2DList...c
+00001b20: 6c61 7373 2053 6f6c 7574 696f 6e53 6574  lass SolutionSet
+00001b30: 7469 6e67 733a 0a20 2020 2061 7070 656e  tings:.    appen
+00001b40: 6454 6f46 696c 653a 2062 6f6f 6c0a 2020  dToFile: bool.  
+00001b50: 2020 6269 6e61 7279 536f 6c75 7469 6f6e    binarySolution
+00001b60: 4669 6c65 3a20 626f 6f6c 0a20 2020 2063  File: bool.    c
+00001b70: 6f6f 7264 696e 6174 6573 536f 6c75 7469  oordinatesSoluti
+00001b80: 6f6e 4669 6c65 4e61 6d65 3a20 7374 720a  onFileName: str.
+00001b90: 2020 2020 6578 706f 7274 4163 6365 6c65      exportAccele
+00001ba0: 7261 7469 6f6e 733a 2062 6f6f 6c0a 2020  rations: bool.  
+00001bb0: 2020 6578 706f 7274 416c 6765 6272 6169    exportAlgebrai
+00001bc0: 6343 6f6f 7264 696e 6174 6573 3a20 626f  cCoordinates: bo
+00001bd0: 6f6c 0a20 2020 2065 7870 6f72 7444 6174  ol.    exportDat
+00001be0: 6143 6f6f 7264 696e 6174 6573 3a20 626f  aCoordinates: bo
+00001bf0: 6f6c 0a20 2020 2065 7870 6f72 744f 4445  ol.    exportODE
+00001c00: 3156 656c 6f63 6974 6965 733a 2062 6f6f  1Velocities: boo
+00001c10: 6c0a 2020 2020 6578 706f 7274 5665 6c6f  l.    exportVelo
+00001c20: 6369 7469 6573 3a20 626f 6f6c 0a20 2020  cities: bool.   
+00001c30: 2066 6c75 7368 4669 6c65 7344 4f46 3a20   flushFilesDOF: 
+00001c40: 696e 740a 2020 2020 666c 7573 6846 696c  int.    flushFil
+00001c50: 6573 496d 6d65 6469 6174 656c 793a 2062  esImmediately: b
+00001c60: 6f6f 6c0a 2020 2020 6f75 7470 7574 5072  ool.    outputPr
+00001c70: 6563 6973 696f 6e3a 2069 6e74 0a20 2020  ecision: int.   
+00001c80: 2072 6563 6f72 6449 6d61 6765 7349 6e74   recordImagesInt
+00001c90: 6572 7661 6c3a 2066 6c6f 6174 0a20 2020  erval: float.   
+00001ca0: 2072 6573 7461 7274 4669 6c65 4e61 6d65   restartFileName
+00001cb0: 3a20 7374 720a 2020 2020 7265 7374 6172  : str.    restar
+00001cc0: 7457 7269 7465 5065 7269 6f64 3a20 666c  tWritePeriod: fl
+00001cd0: 6f61 740a 2020 2020 7365 6e73 6f72 7341  oat.    sensorsA
+00001ce0: 7070 656e 6454 6f46 696c 653a 2062 6f6f  ppendToFile: boo
+00001cf0: 6c0a 2020 2020 7365 6e73 6f72 7353 746f  l.    sensorsSto
+00001d00: 7265 416e 6457 7269 7465 4669 6c65 733a  reAndWriteFiles:
+00001d10: 2062 6f6f 6c0a 2020 2020 7365 6e73 6f72   bool.    sensor
+00001d20: 7357 7269 7465 4669 6c65 466f 6f74 6572  sWriteFileFooter
+00001d30: 3a20 626f 6f6c 0a20 2020 2073 656e 736f  : bool.    senso
+00001d40: 7273 5772 6974 6546 696c 6548 6561 6465  rsWriteFileHeade
+00001d50: 723a 2062 6f6f 6c0a 2020 2020 7365 6e73  r: bool.    sens
+00001d60: 6f72 7357 7269 7465 5065 7269 6f64 3a20  orsWritePeriod: 
+00001d70: 666c 6f61 740a 2020 2020 736f 6c75 7469  float.    soluti
+00001d80: 6f6e 496e 666f 726d 6174 696f 6e3a 2073  onInformation: s
+00001d90: 7472 0a20 2020 2073 6f6c 7574 696f 6e57  tr.    solutionW
+00001da0: 7269 7465 5065 7269 6f64 3a20 666c 6f61  ritePeriod: floa
+00001db0: 740a 2020 2020 736f 6c76 6572 496e 666f  t.    solverInfo
+00001dc0: 726d 6174 696f 6e46 696c 654e 616d 653a  rmationFileName:
+00001dd0: 2073 7472 0a20 2020 2077 7269 7465 4669   str.    writeFi
+00001de0: 6c65 466f 6f74 6572 3a20 626f 6f6c 0a20  leFooter: bool. 
+00001df0: 2020 2077 7269 7465 4669 6c65 4865 6164     writeFileHead
+00001e00: 6572 3a20 626f 6f6c 0a20 2020 2077 7269  er: bool.    wri
+00001e10: 7465 496e 6974 6961 6c56 616c 7565 733a  teInitialValues:
+00001e20: 2062 6f6f 6c0a 2020 2020 7772 6974 6552   bool.    writeR
+00001e30: 6573 7461 7274 4669 6c65 3a20 626f 6f6c  estartFile: bool
+00001e40: 0a20 2020 2077 7269 7465 536f 6c75 7469  .    writeSoluti
+00001e50: 6f6e 546f 4669 6c65 3a20 626f 6f6c 0a0a  onToFile: bool..
+00001e60: 0a63 6c61 7373 204e 756d 6572 6963 616c  .class Numerical
+00001e70: 4469 6666 6572 656e 7469 6174 696f 6e53  DifferentiationS
+00001e80: 6574 7469 6e67 733a 0a20 2020 2061 6464  ettings:.    add
+00001e90: 5265 6665 7265 6e63 6543 6f6f 7264 696e  ReferenceCoordin
+00001ea0: 6174 6573 546f 4570 7369 6c6f 6e3a 2062  atesToEpsilon: b
+00001eb0: 6f6f 6c0a 2020 2020 646f 5379 7374 656d  ool.    doSystem
+00001ec0: 5769 6465 4469 6666 6572 656e 7469 6174  WideDifferentiat
+00001ed0: 696f 6e3a 2062 6f6f 6c0a 2020 2020 666f  ion: bool.    fo
+00001ee0: 7241 453a 2062 6f6f 6c0a 2020 2020 666f  rAE: bool.    fo
+00001ef0: 724f 4445 323a 2062 6f6f 6c0a 2020 2020  rODE2: bool.    
+00001f00: 666f 724f 4445 3263 6f6e 6e65 6374 6f72  forODE2connector
+00001f10: 733a 2062 6f6f 6c0a 2020 2020 6a61 636f  s: bool.    jaco
+00001f20: 6269 616e 436f 6e6e 6563 746f 7244 6572  bianConnectorDer
+00001f30: 6976 6174 6976 653a 2062 6f6f 6c0a 2020  ivative: bool.  
+00001f40: 2020 6d69 6e69 6d75 6d43 6f6f 7264 696e    minimumCoordin
+00001f50: 6174 6553 697a 653a 2066 6c6f 6174 0a20  ateSize: float. 
+00001f60: 2020 2072 656c 6174 6976 6545 7073 696c     relativeEpsil
+00001f70: 6f6e 3a20 666c 6f61 740a 0a0a 636c 6173  on: float...clas
+00001f80: 7320 4469 7363 6f6e 7469 6e75 6f75 7353  s DiscontinuousS
+00001f90: 6574 7469 6e67 733a 0a20 2020 2069 676e  ettings:.    ign
+00001fa0: 6f72 654d 6178 4974 6572 6174 696f 6e73  oreMaxIterations
+00001fb0: 3a20 626f 6f6c 0a20 2020 2069 7465 7261  : bool.    itera
+00001fc0: 7469 6f6e 546f 6c65 7261 6e63 653a 2066  tionTolerance: f
+00001fd0: 6c6f 6174 0a20 2020 206d 6178 4974 6572  loat.    maxIter
+00001fe0: 6174 696f 6e73 3a20 696e 740a 0a0a 636c  ations: int...cl
+00001ff0: 6173 7320 4e65 7774 6f6e 5365 7474 696e  ass NewtonSettin
+00002000: 6773 3a0a 2020 2020 6e75 6d65 7269 6361  gs:.    numerica
+00002010: 6c44 6966 6665 7265 6e74 6961 7469 6f6e  lDifferentiation
+00002020: 3a20 4e75 6d65 7269 6361 6c44 6966 6665  : NumericalDiffe
+00002030: 7265 6e74 6961 7469 6f6e 5365 7474 696e  rentiationSettin
+00002040: 6773 0a20 2020 2061 6273 6f6c 7574 6554  gs.    absoluteT
+00002050: 6f6c 6572 616e 6365 3a20 666c 6f61 740a  olerance: float.
+00002060: 2020 2020 6164 6170 7449 6e69 7469 616c      adaptInitial
+00002070: 5265 7369 6475 616c 3a20 626f 6f6c 0a20  Residual: bool. 
+00002080: 2020 206d 6178 696d 756d 536f 6c75 7469     maximumSoluti
+00002090: 6f6e 4e6f 726d 3a20 666c 6f61 740a 2020  onNorm: float.  
+000020a0: 2020 6d61 7849 7465 7261 7469 6f6e 733a    maxIterations:
+000020b0: 2069 6e74 0a20 2020 206d 6178 4d6f 6469   int.    maxModi
+000020c0: 6669 6564 4e65 7774 6f6e 4974 6572 6174  fiedNewtonIterat
+000020d0: 696f 6e73 3a20 696e 740a 2020 2020 6d61  ions: int.    ma
+000020e0: 784d 6f64 6966 6965 644e 6577 746f 6e52  xModifiedNewtonR
+000020f0: 6573 7461 7274 4974 6572 6174 696f 6e73  estartIterations
+00002100: 3a20 696e 740a 2020 2020 6d6f 6469 6669  : int.    modifi
+00002110: 6564 4e65 7774 6f6e 436f 6e74 7261 6374  edNewtonContract
+00002120: 6976 6974 793a 2066 6c6f 6174 0a20 2020  ivity: float.   
+00002130: 206d 6f64 6966 6965 644e 6577 746f 6e4a   modifiedNewtonJ
+00002140: 6163 5570 6461 7465 5065 7253 7465 703a  acUpdatePerStep:
+00002150: 2062 6f6f 6c0a 2020 2020 6e65 7774 6f6e   bool.    newton
+00002160: 5265 7369 6475 616c 4d6f 6465 3a20 696e  ResidualMode: in
+00002170: 740a 2020 2020 7265 6c61 7469 7665 546f  t.    relativeTo
+00002180: 6c65 7261 6e63 653a 2066 6c6f 6174 0a20  lerance: float. 
+00002190: 2020 2075 7365 4d6f 6469 6669 6564 4e65     useModifiedNe
+000021a0: 7774 6f6e 3a20 626f 6f6c 0a20 2020 2075  wton: bool.    u
+000021b0: 7365 4e65 7774 6f6e 536f 6c76 6572 3a20  seNewtonSolver: 
+000021c0: 626f 6f6c 0a20 2020 2077 6569 6768 7454  bool.    weightT
+000021d0: 6f6c 6572 616e 6365 5065 7243 6f6f 7264  olerancePerCoord
+000021e0: 696e 6174 653a 2062 6f6f 6c0a 0a0a 636c  inate: bool...cl
+000021f0: 6173 7320 4765 6e65 7261 6c69 7a65 6441  ass GeneralizedA
+00002200: 6c70 6861 5365 7474 696e 6773 3a0a 2020  lphaSettings:.  
+00002210: 2020 636f 6d70 7574 6549 6e69 7469 616c    computeInitial
+00002220: 4163 6365 6c65 7261 7469 6f6e 733a 2062  Accelerations: b
+00002230: 6f6f 6c0a 2020 2020 6c69 6547 726f 7570  ool.    lieGroup
+00002240: 4164 6454 616e 6765 6e74 4f70 6572 6174  AddTangentOperat
+00002250: 6f72 3a20 626f 6f6c 0a20 2020 206e 6577  or: bool.    new
+00002260: 6d61 726b 4265 7461 3a20 666c 6f61 740a  markBeta: float.
+00002270: 2020 2020 6e65 776d 6172 6b47 616d 6d61      newmarkGamma
+00002280: 3a20 666c 6f61 740a 2020 2020 7265 7365  : float.    rese
+00002290: 7441 6363 656c 6572 6174 696f 6e73 3a20  tAccelerations: 
+000022a0: 626f 6f6c 0a20 2020 2073 7065 6374 7261  bool.    spectra
+000022b0: 6c52 6164 6975 733a 2066 6c6f 6174 0a20  lRadius: float. 
+000022c0: 2020 2075 7365 496e 6465 7832 436f 6e73     useIndex2Cons
+000022d0: 7472 6169 6e74 733a 2062 6f6f 6c0a 2020  traints: bool.  
+000022e0: 2020 7573 654e 6577 6d61 726b 3a20 626f    useNewmark: bo
+000022f0: 6f6c 0a0a 0a63 6c61 7373 2045 7870 6c69  ol...class Expli
+00002300: 6369 7449 6e74 6567 7261 7469 6f6e 5365  citIntegrationSe
+00002310: 7474 696e 6773 3a0a 2020 2020 636f 6d70  ttings:.    comp
+00002320: 7574 6545 6e64 4f66 5374 6570 4163 6365  uteEndOfStepAcce
+00002330: 6c65 7261 7469 6f6e 733a 2062 6f6f 6c0a  lerations: bool.
+00002340: 2020 2020 636f 6d70 7574 654d 6173 734d      computeMassM
+00002350: 6174 7269 7849 6e76 6572 7365 5065 7242  atrixInversePerB
+00002360: 6f64 793a 2062 6f6f 6c0a 2020 2020 6479  ody: bool.    dy
+00002370: 6e61 6d69 6353 6f6c 7665 7254 7970 653a  namicSolverType:
+00002380: 2044 796e 616d 6963 536f 6c76 6572 5479   DynamicSolverTy
+00002390: 7065 0a20 2020 2065 6c69 6d69 6e61 7465  pe.    eliminate
+000023a0: 436f 6e73 7472 6169 6e74 733a 2062 6f6f  Constraints: boo
+000023b0: 6c0a 2020 2020 7573 654c 6965 4772 6f75  l.    useLieGrou
+000023c0: 7049 6e74 6567 7261 7469 6f6e 3a20 626f  pIntegration: bo
+000023d0: 6f6c 0a0a 0a63 6c61 7373 2054 696d 6549  ol...class TimeI
+000023e0: 6e74 6567 7261 7469 6f6e 5365 7474 696e  ntegrationSettin
+000023f0: 6773 3a0a 2020 2020 6469 7363 6f6e 7469  gs:.    disconti
+00002400: 6e75 6f75 733a 2044 6973 636f 6e74 696e  nuous: Discontin
+00002410: 756f 7573 5365 7474 696e 6773 0a20 2020  uousSettings.   
+00002420: 2065 7870 6c69 6369 7449 6e74 6567 7261   explicitIntegra
+00002430: 7469 6f6e 3a20 4578 706c 6963 6974 496e  tion: ExplicitIn
+00002440: 7465 6772 6174 696f 6e53 6574 7469 6e67  tegrationSetting
+00002450: 730a 2020 2020 6765 6e65 7261 6c69 7a65  s.    generalize
+00002460: 6441 6c70 6861 3a20 4765 6e65 7261 6c69  dAlpha: Generali
+00002470: 7a65 6441 6c70 6861 5365 7474 696e 6773  zedAlphaSettings
+00002480: 0a20 2020 206e 6577 746f 6e3a 204e 6577  .    newton: New
+00002490: 746f 6e53 6574 7469 6e67 730a 2020 2020  tonSettings.    
+000024a0: 6162 736f 6c75 7465 546f 6c65 7261 6e63  absoluteToleranc
+000024b0: 653a 2066 6c6f 6174 0a20 2020 2061 6461  e: float.    ada
+000024c0: 7074 6976 6553 7465 703a 2062 6f6f 6c0a  ptiveStep: bool.
+000024d0: 2020 2020 6164 6170 7469 7665 5374 6570      adaptiveStep
+000024e0: 4465 6372 6561 7365 3a20 666c 6f61 740a  Decrease: float.
+000024f0: 2020 2020 6164 6170 7469 7665 5374 6570      adaptiveStep
+00002500: 496e 6372 6561 7365 3a20 666c 6f61 740a  Increase: float.
+00002510: 2020 2020 6164 6170 7469 7665 5374 6570      adaptiveStep
+00002520: 5265 636f 7665 7279 4974 6572 6174 696f  RecoveryIteratio
+00002530: 6e73 3a20 696e 740a 2020 2020 6164 6170  ns: int.    adap
+00002540: 7469 7665 5374 6570 5265 636f 7665 7279  tiveStepRecovery
+00002550: 5374 6570 733a 2069 6e74 0a20 2020 2061  Steps: int.    a
+00002560: 7574 6f6d 6174 6963 5374 6570 5369 7a65  utomaticStepSize
+00002570: 3a20 626f 6f6c 0a20 2020 2063 6f6d 7075  : bool.    compu
+00002580: 7465 4c6f 6164 734a 6163 6f62 6961 6e3a  teLoadsJacobian:
+00002590: 2069 6e74 0a20 2020 2065 6e64 5469 6d65   int.    endTime
+000025a0: 3a20 666c 6f61 740a 2020 2020 696e 6974  : float.    init
+000025b0: 6961 6c53 7465 7053 697a 653a 2066 6c6f  ialStepSize: flo
+000025c0: 6174 0a20 2020 206d 696e 696d 756d 5374  at.    minimumSt
+000025d0: 6570 5369 7a65 3a20 666c 6f61 740a 2020  epSize: float.  
+000025e0: 2020 6e75 6d62 6572 4f66 5374 6570 733a    numberOfSteps:
+000025f0: 2069 6e74 0a20 2020 2072 6561 6c74 696d   int.    realtim
+00002600: 6546 6163 746f 723a 2066 6c6f 6174 0a20  eFactor: float. 
+00002610: 2020 2072 6561 6c74 696d 6557 6169 744d     realtimeWaitM
+00002620: 6963 726f 7365 636f 6e64 733a 2069 6e74  icroseconds: int
+00002630: 0a20 2020 2072 656c 6174 6976 6554 6f6c  .    relativeTol
+00002640: 6572 616e 6365 3a20 666c 6f61 740a 2020  erance: float.  
+00002650: 2020 7265 7573 6543 6f6e 7374 616e 744d    reuseConstantM
+00002660: 6173 734d 6174 7269 783a 2062 6f6f 6c0a  assMatrix: bool.
+00002670: 2020 2020 7369 6d75 6c61 7465 496e 5265      simulateInRe
+00002680: 616c 7469 6d65 3a20 626f 6f6c 0a20 2020  altime: bool.   
+00002690: 2073 7461 7274 5469 6d65 3a20 666c 6f61   startTime: floa
+000026a0: 740a 2020 2020 7374 6570 496e 666f 726d  t.    stepInform
+000026b0: 6174 696f 6e3a 2069 6e74 0a20 2020 2073  ation: int.    s
+000026c0: 7465 7053 697a 654d 6178 496e 6372 6561  tepSizeMaxIncrea
+000026d0: 7365 3a20 666c 6f61 740a 2020 2020 7374  se: float.    st
+000026e0: 6570 5369 7a65 5361 6665 7479 3a20 666c  epSizeSafety: fl
+000026f0: 6f61 740a 2020 2020 7665 7262 6f73 654d  oat.    verboseM
+00002700: 6f64 653a 2069 6e74 0a20 2020 2076 6572  ode: int.    ver
+00002710: 626f 7365 4d6f 6465 4669 6c65 3a20 696e  boseModeFile: in
+00002720: 740a 0a0a 636c 6173 7320 5374 6174 6963  t...class Static
+00002730: 536f 6c76 6572 5365 7474 696e 6773 3a0a  SolverSettings:.
+00002740: 2020 2020 6469 7363 6f6e 7469 6e75 6f75      discontinuou
+00002750: 733a 2044 6973 636f 6e74 696e 756f 7573  s: Discontinuous
+00002760: 5365 7474 696e 6773 0a20 2020 206e 6577  Settings.    new
+00002770: 746f 6e3a 204e 6577 746f 6e53 6574 7469  ton: NewtonSetti
+00002780: 6e67 730a 2020 2020 6164 6170 7469 7665  ngs.    adaptive
+00002790: 5374 6570 3a20 626f 6f6c 0a20 2020 2061  Step: bool.    a
+000027a0: 6461 7074 6976 6553 7465 7044 6563 7265  daptiveStepDecre
+000027b0: 6173 653a 2066 6c6f 6174 0a20 2020 2061  ase: float.    a
+000027c0: 6461 7074 6976 6553 7465 7049 6e63 7265  daptiveStepIncre
+000027d0: 6173 653a 2066 6c6f 6174 0a20 2020 2061  ase: float.    a
+000027e0: 6461 7074 6976 6553 7465 7052 6563 6f76  daptiveStepRecov
+000027f0: 6572 7949 7465 7261 7469 6f6e 733a 2069  eryIterations: i
+00002800: 6e74 0a20 2020 2061 6461 7074 6976 6553  nt.    adaptiveS
+00002810: 7465 7052 6563 6f76 6572 7953 7465 7073  tepRecoverySteps
+00002820: 3a20 696e 740a 2020 2020 636f 6d70 7574  : int.    comput
+00002830: 654c 6f61 6473 4a61 636f 6269 616e 3a20  eLoadsJacobian: 
+00002840: 626f 6f6c 0a20 2020 2063 6f6e 7374 7261  bool.    constra
+00002850: 696e 4f44 4531 636f 6f72 6469 6e61 7465  inODE1coordinate
+00002860: 733a 2062 6f6f 6c0a 2020 2020 6c6f 6164  s: bool.    load
+00002870: 5374 6570 4475 7261 7469 6f6e 3a20 666c  StepDuration: fl
+00002880: 6f61 740a 2020 2020 6c6f 6164 5374 6570  oat.    loadStep
+00002890: 4765 6f6d 6574 7269 633a 2062 6f6f 6c0a  Geometric: bool.
+000028a0: 2020 2020 6c6f 6164 5374 6570 4765 6f6d      loadStepGeom
+000028b0: 6574 7269 6352 616e 6765 3a20 666c 6f61  etricRange: floa
+000028c0: 740a 2020 2020 6c6f 6164 5374 6570 5374  t.    loadStepSt
+000028d0: 6172 743a 2066 6c6f 6174 0a20 2020 206d  art: float.    m
+000028e0: 696e 696d 756d 5374 6570 5369 7a65 3a20  inimumStepSize: 
+000028f0: 666c 6f61 740a 2020 2020 6e75 6d62 6572  float.    number
+00002900: 4f66 4c6f 6164 5374 6570 733a 2069 6e74  OfLoadSteps: int
+00002910: 0a20 2020 2073 7461 6269 6c69 7a65 724f  .    stabilizerO
+00002920: 4445 3274 6572 6d3a 2066 6c6f 6174 0a20  DE2term: float. 
+00002930: 2020 2073 7465 7049 6e66 6f72 6d61 7469     stepInformati
+00002940: 6f6e 3a20 696e 740a 2020 2020 7573 654c  on: int.    useL
+00002950: 6f61 6446 6163 746f 723a 2062 6f6f 6c0a  oadFactor: bool.
+00002960: 2020 2020 7665 7262 6f73 654d 6f64 653a      verboseMode:
+00002970: 2069 6e74 0a20 2020 2076 6572 626f 7365   int.    verbose
+00002980: 4d6f 6465 4669 6c65 3a20 696e 740a 0a0a  ModeFile: int...
+00002990: 636c 6173 7320 4c69 6e65 6172 536f 6c76  class LinearSolv
+000029a0: 6572 5365 7474 696e 6773 3a0a 2020 2020  erSettings:.    
+000029b0: 6967 6e6f 7265 5369 6e67 756c 6172 4a61  ignoreSingularJa
+000029c0: 636f 6269 616e 3a20 626f 6f6c 0a20 2020  cobian: bool.   
+000029d0: 2070 6976 6f74 5468 7265 7368 6f6c 643a   pivotThreshold:
+000029e0: 2066 6c6f 6174 0a20 2020 2072 6575 7365   float.    reuse
+000029f0: 416e 616c 797a 6564 5061 7474 6572 6e3a  AnalyzedPattern:
+00002a00: 2062 6f6f 6c0a 2020 2020 7368 6f77 4361   bool.    showCa
+00002a10: 7573 696e 6749 7465 6d73 3a20 626f 6f6c  usingItems: bool
+00002a20: 0a0a 0a63 6c61 7373 2050 6172 616c 6c65  ...class Paralle
+00002a30: 6c3a 0a20 2020 206d 756c 7469 7468 7265  l:.    multithre
+00002a40: 6164 6564 4c4c 696d 6974 4a61 636f 6269  adedLLimitJacobi
+00002a50: 616e 733a 2069 6e74 0a20 2020 206d 756c  ans: int.    mul
+00002a60: 7469 7468 7265 6164 6564 4c4c 696d 6974  tithreadedLLimit
+00002a70: 4c6f 6164 733a 2069 6e74 0a20 2020 206d  Loads: int.    m
+00002a80: 756c 7469 7468 7265 6164 6564 4c4c 696d  ultithreadedLLim
+00002a90: 6974 4d61 7373 4d61 7472 6963 6573 3a20  itMassMatrices: 
+00002aa0: 696e 740a 2020 2020 6d75 6c74 6974 6872  int.    multithr
+00002ab0: 6561 6465 644c 4c69 6d69 7452 6573 6964  eadedLLimitResid
+00002ac0: 7561 6c73 3a20 696e 740a 2020 2020 6e75  uals: int.    nu
+00002ad0: 6d62 6572 4f66 5468 7265 6164 733a 2069  mberOfThreads: i
+00002ae0: 6e74 0a20 2020 2074 6173 6b53 706c 6974  nt.    taskSplit
+00002af0: 4d69 6e49 7465 6d73 3a20 696e 740a 2020  MinItems: int.  
+00002b00: 2020 7461 736b 5370 6c69 7454 6173 6b73    taskSplitTasks
+00002b10: 5065 7254 6872 6561 643a 2069 6e74 0a0a  PerThread: int..
+00002b20: 0a63 6c61 7373 2053 696d 756c 6174 696f  .class Simulatio
+00002b30: 6e53 6574 7469 6e67 733a 0a20 2020 206c  nSettings:.    l
+00002b40: 696e 6561 7253 6f6c 7665 7253 6574 7469  inearSolverSetti
+00002b50: 6e67 733a 204c 696e 6561 7253 6f6c 7665  ngs: LinearSolve
+00002b60: 7253 6574 7469 6e67 730a 2020 2020 7061  rSettings.    pa
+00002b70: 7261 6c6c 656c 3a20 5061 7261 6c6c 656c  rallel: Parallel
+00002b80: 0a20 2020 2073 6f6c 7574 696f 6e53 6574  .    solutionSet
+00002b90: 7469 6e67 733a 2053 6f6c 7574 696f 6e53  tings: SolutionS
+00002ba0: 6574 7469 6e67 730a 2020 2020 7374 6174  ettings.    stat
+00002bb0: 6963 536f 6c76 6572 3a20 5374 6174 6963  icSolver: Static
+00002bc0: 536f 6c76 6572 5365 7474 696e 6773 0a20  SolverSettings. 
+00002bd0: 2020 2074 696d 6549 6e74 6567 7261 7469     timeIntegrati
+00002be0: 6f6e 3a20 5469 6d65 496e 7465 6772 6174  on: TimeIntegrat
+00002bf0: 696f 6e53 6574 7469 6e67 730a 2020 2020  ionSettings.    
+00002c00: 636c 6561 6e55 704d 656d 6f72 793a 2062  cleanUpMemory: b
+00002c10: 6f6f 6c0a 2020 2020 6469 7370 6c61 7943  ool.    displayC
+00002c20: 6f6d 7075 7461 7469 6f6e 5469 6d65 3a20  omputationTime: 
+00002c30: 626f 6f6c 0a20 2020 2064 6973 706c 6179  bool.    display
+00002c40: 476c 6f62 616c 5469 6d65 7273 3a20 626f  GlobalTimers: bo
+00002c50: 6f6c 0a20 2020 2064 6973 706c 6179 5374  ol.    displaySt
+00002c60: 6174 6973 7469 6373 3a20 626f 6f6c 0a20  atistics: bool. 
+00002c70: 2020 206c 696e 6561 7253 6f6c 7665 7254     linearSolverT
+00002c80: 7970 653a 204c 696e 6561 7253 6f6c 7665  ype: LinearSolve
+00002c90: 7254 7970 650a 2020 2020 6f75 7470 7574  rType.    output
+00002ca0: 5072 6563 6973 696f 6e3a 2069 6e74 0a20  Precision: int. 
+00002cb0: 2020 2070 6175 7365 4166 7465 7245 6163     pauseAfterEac
+00002cc0: 6853 7465 703a 2062 6f6f 6c0a 0a0a 636c  hStep: bool...cl
+00002cd0: 6173 7320 5653 6574 7469 6e67 7347 656e  ass VSettingsGen
+00002ce0: 6572 616c 3a0a 2020 2020 6175 746f 4669  eral:.    autoFi
+00002cf0: 7453 6365 6e65 3a20 626f 6f6c 0a20 2020  tScene: bool.   
+00002d00: 2061 7865 7354 696c 696e 673a 2069 6e74   axesTiling: int
+00002d10: 0a20 2020 2062 6163 6b67 726f 756e 6443  .    backgroundC
+00002d20: 6f6c 6f72 3a20 5475 706c 655b 666c 6f61  olor: Tuple[floa
+00002d30: 742c 666c 6f61 742c 666c 6f61 742c 666c  t,float,float,fl
+00002d40: 6f61 745d 0a20 2020 2062 6163 6b67 726f  oat].    backgro
+00002d50: 756e 6443 6f6c 6f72 426f 7474 6f6d 3a20  undColorBottom: 
+00002d60: 5475 706c 655b 666c 6f61 742c 666c 6f61  Tuple[float,floa
+00002d70: 742c 666c 6f61 742c 666c 6f61 745d 0a20  t,float,float]. 
+00002d80: 2020 2063 6972 636c 6554 696c 696e 673a     circleTiling:
+00002d90: 2069 6e74 0a20 2020 2063 6f6f 7264 696e   int.    coordin
+00002da0: 6174 6553 7973 7465 6d53 697a 653a 2066  ateSystemSize: f
+00002db0: 6c6f 6174 0a20 2020 2063 796c 696e 6465  loat.    cylinde
+00002dc0: 7254 696c 696e 673a 2069 6e74 0a20 2020  rTiling: int.   
+00002dd0: 2064 7261 7743 6f6f 7264 696e 6174 6553   drawCoordinateS
+00002de0: 7973 7465 6d3a 2062 6f6f 6c0a 2020 2020  ystem: bool.    
+00002df0: 6472 6177 576f 726c 6442 6173 6973 3a20  drawWorldBasis: 
+00002e00: 626f 6f6c 0a20 2020 2067 7261 7068 6963  bool.    graphic
+00002e10: 7355 7064 6174 6549 6e74 6572 7661 6c3a  sUpdateInterval:
+00002e20: 2066 6c6f 6174 0a20 2020 206c 696e 7578   float.    linux
+00002e30: 4469 7370 6c61 7953 6361 6c65 4661 6374  DisplayScaleFact
+00002e40: 6f72 3a20 666c 6f61 740a 2020 2020 6d69  or: float.    mi
+00002e50: 6e53 6365 6e65 5369 7a65 3a20 666c 6f61  nSceneSize: floa
+00002e60: 740a 2020 2020 706f 696e 7453 697a 653a  t.    pointSize:
+00002e70: 2066 6c6f 6174 0a20 2020 2072 656e 6465   float.    rende
+00002e80: 7265 7250 7265 6369 7369 6f6e 3a20 696e  rerPrecision: in
+00002e90: 740a 2020 2020 7265 6e64 6572 5769 6e64  t.    renderWind
+00002ea0: 6f77 5374 7269 6e67 3a20 7374 720a 2020  owString: str.  
+00002eb0: 2020 7368 6f77 436f 6d70 7574 6174 696f    showComputatio
+00002ec0: 6e49 6e66 6f3a 2062 6f6f 6c0a 2020 2020  nInfo: bool.    
+00002ed0: 7368 6f77 4865 6c70 4f6e 5374 6172 7475  showHelpOnStartu
+00002ee0: 703a 2069 6e74 0a20 2020 2073 686f 7753  p: int.    showS
+00002ef0: 6f6c 7574 696f 6e49 6e66 6f72 6d61 7469  olutionInformati
+00002f00: 6f6e 3a20 626f 6f6c 0a20 2020 2073 686f  on: bool.    sho
+00002f10: 7753 6f6c 7665 7249 6e66 6f72 6d61 7469  wSolverInformati
+00002f20: 6f6e 3a20 626f 6f6c 0a20 2020 2073 686f  on: bool.    sho
+00002f30: 7753 6f6c 7665 7254 696d 653a 2062 6f6f  wSolverTime: boo
+00002f40: 6c0a 2020 2020 7370 6865 7265 5469 6c69  l.    sphereTili
+00002f50: 6e67 3a20 696e 740a 2020 2020 7465 7874  ng: int.    text
+00002f60: 416c 7761 7973 496e 4672 6f6e 743a 2062  AlwaysInFront: b
+00002f70: 6f6f 6c0a 2020 2020 7465 7874 436f 6c6f  ool.    textColo
+00002f80: 723a 2054 7570 6c65 5b66 6c6f 6174 2c66  r: Tuple[float,f
+00002f90: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
+00002fa0: 5d0a 2020 2020 7465 7874 4861 7342 6163  ].    textHasBac
+00002fb0: 6b67 726f 756e 643a 2062 6f6f 6c0a 2020  kground: bool.  
+00002fc0: 2020 7465 7874 4f66 6673 6574 4661 6374    textOffsetFact
+00002fd0: 6f72 3a20 666c 6f61 740a 2020 2020 7465  or: float.    te
+00002fe0: 7874 5369 7a65 3a20 666c 6f61 740a 2020  xtSize: float.  
+00002ff0: 2020 7468 7265 6164 5361 6665 4772 6170    threadSafeGrap
+00003000: 6869 6373 5570 6461 7465 3a20 626f 6f6c  hicsUpdate: bool
+00003010: 0a20 2020 2075 7365 4269 746d 6170 5465  .    useBitmapTe
+00003020: 7874 3a20 626f 6f6c 0a20 2020 2075 7365  xt: bool.    use
+00003030: 4772 6164 6965 6e74 4261 636b 6772 6f75  GradientBackgrou
+00003040: 6e64 3a20 626f 6f6c 0a20 2020 2075 7365  nd: bool.    use
+00003050: 4d75 6c74 6954 6872 6561 6465 6452 656e  MultiThreadedRen
+00003060: 6465 7269 6e67 3a20 626f 6f6c 0a20 2020  dering: bool.   
+00003070: 2075 7365 5769 6e64 6f77 7344 6973 706c   useWindowsDispl
+00003080: 6179 5363 616c 6546 6163 746f 723a 2062  ayScaleFactor: b
+00003090: 6f6f 6c0a 2020 2020 776f 726c 6442 6173  ool.    worldBas
+000030a0: 6973 5369 7a65 3a20 666c 6f61 740a 0a0a  isSize: float...
+000030b0: 636c 6173 7320 5653 6574 7469 6e67 7343  class VSettingsC
+000030c0: 6f6e 746f 7572 3a0a 2020 2020 6175 746f  ontour:.    auto
+000030d0: 6d61 7469 6352 616e 6765 3a20 626f 6f6c  maticRange: bool
+000030e0: 0a20 2020 2063 6f6c 6f72 4261 7250 7265  .    colorBarPre
+000030f0: 6369 7369 6f6e 3a20 696e 740a 2020 2020  cision: int.    
+00003100: 636f 6c6f 7242 6172 5469 6c69 6e67 3a20  colorBarTiling: 
+00003110: 696e 740a 2020 2020 6d61 7856 616c 7565  int.    maxValue
+00003120: 3a20 666c 6f61 740a 2020 2020 6d69 6e56  : float.    minV
+00003130: 616c 7565 3a20 666c 6f61 740a 2020 2020  alue: float.    
+00003140: 6e6f 6465 7343 6f6c 6f72 6564 3a20 626f  nodesColored: bo
+00003150: 6f6c 0a20 2020 206f 7574 7075 7456 6172  ol.    outputVar
+00003160: 6961 626c 653a 204f 7574 7075 7456 6172  iable: OutputVar
+00003170: 6961 626c 6554 7970 650a 2020 2020 6f75  iableType.    ou
+00003180: 7470 7574 5661 7269 6162 6c65 436f 6d70  tputVariableComp
+00003190: 6f6e 656e 743a 2069 6e74 0a20 2020 2072  onent: int.    r
+000031a0: 6564 7563 6552 616e 6765 3a20 626f 6f6c  educeRange: bool
+000031b0: 0a20 2020 2072 6967 6964 426f 6469 6573  .    rigidBodies
+000031c0: 436f 6c6f 7265 643a 2062 6f6f 6c0a 2020  Colored: bool.  
+000031d0: 2020 7368 6f77 436f 6c6f 7242 6172 3a20    showColorBar: 
+000031e0: 626f 6f6c 0a0a 0a63 6c61 7373 2056 5365  bool...class VSe
+000031f0: 7474 696e 6773 4e6f 6465 733a 0a20 2020  ttingsNodes:.   
+00003200: 2062 6173 6973 5369 7a65 3a20 666c 6f61   basisSize: floa
+00003210: 740a 2020 2020 6465 6661 756c 7443 6f6c  t.    defaultCol
+00003220: 6f72 3a20 5475 706c 655b 666c 6f61 742c  or: Tuple[float,
+00003230: 666c 6f61 742c 666c 6f61 742c 666c 6f61  float,float,floa
+00003240: 745d 0a20 2020 2064 6566 6175 6c74 5369  t].    defaultSi
+00003250: 7a65 3a20 666c 6f61 740a 2020 2020 6472  ze: float.    dr
+00003260: 6177 4e6f 6465 7341 7350 6f69 6e74 3a20  awNodesAsPoint: 
+00003270: 626f 6f6c 0a20 2020 2073 686f 773a 2062  bool.    show: b
+00003280: 6f6f 6c0a 2020 2020 7368 6f77 4261 7369  ool.    showBasi
+00003290: 733a 2062 6f6f 6c0a 2020 2020 7368 6f77  s: bool.    show
+000032a0: 4e6f 6461 6c53 6c6f 7065 733a 2069 6e74  NodalSlopes: int
+000032b0: 0a20 2020 2073 686f 774e 756d 6265 7273  .    showNumbers
+000032c0: 3a20 626f 6f6c 0a20 2020 2074 696c 696e  : bool.    tilin
+000032d0: 673a 2069 6e74 0a0a 0a63 6c61 7373 2056  g: int...class V
+000032e0: 5365 7474 696e 6773 4265 616d 733a 0a20  SettingsBeams:. 
+000032f0: 2020 2061 7869 616c 5469 6c69 6e67 3a20     axialTiling: 
+00003300: 696e 740a 2020 2020 6372 6f73 7353 6563  int.    crossSec
+00003310: 7469 6f6e 4669 6c6c 6564 3a20 626f 6f6c  tionFilled: bool
+00003320: 0a20 2020 2063 726f 7373 5365 6374 696f  .    crossSectio
+00003330: 6e54 696c 696e 673a 2069 6e74 0a20 2020  nTiling: int.   
+00003340: 2064 7261 7756 6572 7469 6361 6c3a 2062   drawVertical: b
+00003350: 6f6f 6c0a 2020 2020 6472 6177 5665 7274  ool.    drawVert
+00003360: 6963 616c 436f 6c6f 723a 2054 7570 6c65  icalColor: Tuple
+00003370: 5b66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  [float,float,flo
+00003380: 6174 2c66 6c6f 6174 5d0a 2020 2020 6472  at,float].    dr
+00003390: 6177 5665 7274 6963 616c 4661 6374 6f72  awVerticalFactor
+000033a0: 3a20 666c 6f61 740a 2020 2020 6472 6177  : float.    draw
+000033b0: 5665 7274 6963 616c 4c69 6e65 733a 2062  VerticalLines: b
+000033c0: 6f6f 6c0a 2020 2020 6472 6177 5665 7274  ool.    drawVert
+000033d0: 6963 616c 4f66 6673 6574 3a20 666c 6f61  icalOffset: floa
+000033e0: 740a 2020 2020 6472 6177 5665 7274 6963  t.    drawVertic
+000033f0: 616c 5661 6c75 6573 3a20 626f 6f6c 0a20  alValues: bool. 
+00003400: 2020 2072 6564 7563 6564 4178 6961 6c49     reducedAxialI
+00003410: 6e74 6572 706c 6f61 7469 6f6e 3a20 626f  nterploation: bo
+00003420: 6f6c 0a0a 0a63 6c61 7373 2056 5365 7474  ol...class VSett
+00003430: 696e 6773 4b69 6e65 6d61 7469 6354 7265  ingsKinematicTre
+00003440: 653a 0a20 2020 2066 7261 6d65 5369 7a65  e:.    frameSize
+00003450: 3a20 666c 6f61 740a 2020 2020 7368 6f77  : float.    show
+00003460: 434f 4d66 7261 6d65 733a 2062 6f6f 6c0a  COMframes: bool.
+00003470: 2020 2020 7368 6f77 4672 616d 6573 4e75      showFramesNu
+00003480: 6d62 6572 733a 2062 6f6f 6c0a 2020 2020  mbers: bool.    
+00003490: 7368 6f77 4a6f 696e 7446 7261 6d65 733a  showJointFrames:
+000034a0: 2062 6f6f 6c0a 0a0a 636c 6173 7320 5653   bool...class VS
+000034b0: 6574 7469 6e67 7342 6f64 6965 733a 0a20  ettingsBodies:. 
+000034c0: 2020 2062 6561 6d73 3a20 5653 6574 7469     beams: VSetti
+000034d0: 6e67 7342 6561 6d73 0a20 2020 206b 696e  ngsBeams.    kin
+000034e0: 656d 6174 6963 5472 6565 3a20 5653 6574  ematicTree: VSet
+000034f0: 7469 6e67 734b 696e 656d 6174 6963 5472  tingsKinematicTr
+00003500: 6565 0a20 2020 2064 6566 6175 6c74 436f  ee.    defaultCo
+00003510: 6c6f 723a 2054 7570 6c65 5b66 6c6f 6174  lor: Tuple[float
+00003520: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
+00003530: 6174 5d0a 2020 2020 6465 6661 756c 7453  at].    defaultS
+00003540: 697a 653a 2054 7570 6c65 5b66 6c6f 6174  ize: Tuple[float
+00003550: 2c66 6c6f 6174 2c66 6c6f 6174 5d0a 2020  ,float,float].  
+00003560: 2020 6465 666f 726d 6174 696f 6e53 6361    deformationSca
+00003570: 6c65 4661 6374 6f72 3a20 666c 6f61 740a  leFactor: float.
+00003580: 2020 2020 7368 6f77 3a20 626f 6f6c 0a20      show: bool. 
+00003590: 2020 2073 686f 774e 756d 6265 7273 3a20     showNumbers: 
+000035a0: 626f 6f6c 0a0a 0a63 6c61 7373 2056 5365  bool...class VSe
+000035b0: 7474 696e 6773 436f 6e6e 6563 746f 7273  ttingsConnectors
+000035c0: 3a0a 2020 2020 636f 6e74 6163 7450 6f69  :.    contactPoi
+000035d0: 6e74 7344 6566 6175 6c74 5369 7a65 3a20  ntsDefaultSize: 
+000035e0: 666c 6f61 740a 2020 2020 6465 6661 756c  float.    defaul
+000035f0: 7443 6f6c 6f72 3a20 5475 706c 655b 666c  tColor: Tuple[fl
+00003600: 6f61 742c 666c 6f61 742c 666c 6f61 742c  oat,float,float,
+00003610: 666c 6f61 745d 0a20 2020 2064 6566 6175  float].    defau
+00003620: 6c74 5369 7a65 3a20 666c 6f61 740a 2020  ltSize: float.  
+00003630: 2020 6a6f 696e 7441 7865 734c 656e 6774    jointAxesLengt
+00003640: 683a 2066 6c6f 6174 0a20 2020 206a 6f69  h: float.    joi
+00003650: 6e74 4178 6573 5261 6469 7573 3a20 666c  ntAxesRadius: fl
+00003660: 6f61 740a 2020 2020 7368 6f77 3a20 626f  oat.    show: bo
+00003670: 6f6c 0a20 2020 2073 686f 7743 6f6e 7461  ol.    showConta
+00003680: 6374 3a20 626f 6f6c 0a20 2020 2073 686f  ct: bool.    sho
+00003690: 774a 6f69 6e74 4178 6573 3a20 626f 6f6c  wJointAxes: bool
+000036a0: 0a20 2020 2073 686f 774e 756d 6265 7273  .    showNumbers
+000036b0: 3a20 626f 6f6c 0a20 2020 2073 7072 696e  : bool.    sprin
+000036c0: 674e 756d 6265 724f 6657 696e 6469 6e67  gNumberOfWinding
+000036d0: 733a 2069 6e74 0a0a 0a63 6c61 7373 2056  s: int...class V
+000036e0: 5365 7474 696e 6773 4d61 726b 6572 733a  SettingsMarkers:
+000036f0: 0a20 2020 2064 6566 6175 6c74 436f 6c6f  .    defaultColo
+00003700: 723a 2054 7570 6c65 5b66 6c6f 6174 2c66  r: Tuple[float,f
+00003710: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
+00003720: 5d0a 2020 2020 6465 6661 756c 7453 697a  ].    defaultSiz
+00003730: 653a 2066 6c6f 6174 0a20 2020 2064 7261  e: float.    dra
+00003740: 7753 696d 706c 6966 6965 643a 2062 6f6f  wSimplified: boo
+00003750: 6c0a 2020 2020 7368 6f77 3a20 626f 6f6c  l.    show: bool
+00003760: 0a20 2020 2073 686f 774e 756d 6265 7273  .    showNumbers
+00003770: 3a20 626f 6f6c 0a0a 0a63 6c61 7373 2056  : bool...class V
+00003780: 5365 7474 696e 6773 4c6f 6164 733a 0a20  SettingsLoads:. 
+00003790: 2020 2064 6566 6175 6c74 436f 6c6f 723a     defaultColor:
+000037a0: 2054 7570 6c65 5b66 6c6f 6174 2c66 6c6f   Tuple[float,flo
+000037b0: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d0a  at,float,float].
+000037c0: 2020 2020 6465 6661 756c 7452 6164 6975      defaultRadiu
+000037d0: 733a 2066 6c6f 6174 0a20 2020 2064 6566  s: float.    def
+000037e0: 6175 6c74 5369 7a65 3a20 666c 6f61 740a  aultSize: float.
+000037f0: 2020 2020 6472 6177 5369 6d70 6c69 6669      drawSimplifi
+00003800: 6564 3a20 626f 6f6c 0a20 2020 2066 6978  ed: bool.    fix
+00003810: 6564 4c6f 6164 5369 7a65 3a20 626f 6f6c  edLoadSize: bool
+00003820: 0a20 2020 206c 6f61 6453 697a 6546 6163  .    loadSizeFac
+00003830: 746f 723a 2066 6c6f 6174 0a20 2020 2073  tor: float.    s
+00003840: 686f 773a 2062 6f6f 6c0a 2020 2020 7368  how: bool.    sh
+00003850: 6f77 4e75 6d62 6572 733a 2062 6f6f 6c0a  owNumbers: bool.
+00003860: 0a0a 636c 6173 7320 5653 6574 7469 6e67  ..class VSetting
+00003870: 7353 656e 736f 7254 7261 6365 733a 0a20  sSensorTraces:. 
+00003880: 2020 206c 696e 6557 6964 7468 3a20 666c     lineWidth: fl
+00003890: 6f61 740a 2020 2020 6c69 7374 4f66 506f  oat.    listOfPo
+000038a0: 7369 7469 6f6e 5365 6e73 6f72 733a 2041  sitionSensors: A
+000038b0: 7272 6179 496e 6465 780a 2020 2020 6c69  rrayIndex.    li
+000038c0: 7374 4f66 5472 6961 6453 656e 736f 7273  stOfTriadSensors
+000038d0: 3a20 4172 7261 7949 6e64 6578 0a20 2020  : ArrayIndex.   
+000038e0: 206c 6973 744f 6656 6563 746f 7253 656e   listOfVectorSen
+000038f0: 736f 7273 3a20 4172 7261 7949 6e64 6578  sors: ArrayIndex
+00003900: 0a20 2020 2070 6f73 6974 696f 6e73 5368  .    positionsSh
+00003910: 6f77 4576 6572 793a 2069 6e74 0a20 2020  owEvery: int.   
+00003920: 2073 656e 736f 7273 4d62 734e 756d 6265   sensorsMbsNumbe
+00003930: 723a 2069 6e74 0a20 2020 2073 686f 7743  r: int.    showC
+00003940: 7572 7265 6e74 3a20 626f 6f6c 0a20 2020  urrent: bool.   
+00003950: 2073 686f 7746 7574 7572 653a 2062 6f6f   showFuture: boo
+00003960: 6c0a 2020 2020 7368 6f77 5061 7374 3a20  l.    showPast: 
+00003970: 626f 6f6c 0a20 2020 2073 686f 7750 6f73  bool.    showPos
+00003980: 6974 696f 6e54 7261 6365 3a20 626f 6f6c  itionTrace: bool
+00003990: 0a20 2020 2073 686f 7754 7269 6164 733a  .    showTriads:
+000039a0: 2062 6f6f 6c0a 2020 2020 7368 6f77 5665   bool.    showVe
+000039b0: 6374 6f72 733a 2062 6f6f 6c0a 2020 2020  ctors: bool.    
+000039c0: 7472 6163 6543 6f6c 6f72 733a 2041 7272  traceColors: Arr
+000039d0: 6179 466c 6f61 740a 2020 2020 7472 6961  ayFloat.    tria
+000039e0: 6453 697a 653a 2066 6c6f 6174 0a20 2020  dSize: float.   
+000039f0: 2074 7269 6164 7353 686f 7745 7665 7279   triadsShowEvery
+00003a00: 3a20 696e 740a 2020 2020 7665 6374 6f72  : int.    vector
+00003a10: 5363 616c 696e 673a 2066 6c6f 6174 0a20  Scaling: float. 
+00003a20: 2020 2076 6563 746f 7273 5368 6f77 4576     vectorsShowEv
+00003a30: 6572 793a 2069 6e74 0a0a 0a63 6c61 7373  ery: int...class
+00003a40: 2056 5365 7474 696e 6773 5365 6e73 6f72   VSettingsSensor
+00003a50: 733a 0a20 2020 2074 7261 6365 733a 2056  s:.    traces: V
+00003a60: 5365 7474 696e 6773 5365 6e73 6f72 5472  SettingsSensorTr
+00003a70: 6163 6573 0a20 2020 2064 6566 6175 6c74  aces.    default
+00003a80: 436f 6c6f 723a 2054 7570 6c65 5b66 6c6f  Color: Tuple[flo
+00003a90: 6174 2c66 6c6f 6174 2c66 6c6f 6174 2c66  at,float,float,f
+00003aa0: 6c6f 6174 5d0a 2020 2020 6465 6661 756c  loat].    defaul
+00003ab0: 7453 697a 653a 2066 6c6f 6174 0a20 2020  tSize: float.   
+00003ac0: 2064 7261 7753 696d 706c 6966 6965 643a   drawSimplified:
+00003ad0: 2062 6f6f 6c0a 2020 2020 7368 6f77 3a20   bool.    show: 
+00003ae0: 626f 6f6c 0a20 2020 2073 686f 774e 756d  bool.    showNum
+00003af0: 6265 7273 3a20 626f 6f6c 0a0a 0a63 6c61  bers: bool...cla
+00003b00: 7373 2056 5365 7474 696e 6773 436f 6e74  ss VSettingsCont
+00003b10: 6163 743a 0a20 2020 2063 6f6c 6f72 426f  act:.    colorBo
+00003b20: 756e 6469 6e67 426f 7865 733a 2054 7570  undingBoxes: Tup
+00003b30: 6c65 5b66 6c6f 6174 2c66 6c6f 6174 2c66  le[float,float,f
+00003b40: 6c6f 6174 2c66 6c6f 6174 5d0a 2020 2020  loat,float].    
+00003b50: 636f 6c6f 7253 6561 7263 6854 7265 653a  colorSearchTree:
+00003b60: 2054 7570 6c65 5b66 6c6f 6174 2c66 6c6f   Tuple[float,flo
+00003b70: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d0a  at,float,float].
+00003b80: 2020 2020 636f 6c6f 7253 7068 6572 6573      colorSpheres
+00003b90: 3a20 5475 706c 655b 666c 6f61 742c 666c  : Tuple[float,fl
+00003ba0: 6f61 742c 666c 6f61 742c 666c 6f61 745d  oat,float,float]
+00003bb0: 0a20 2020 2063 6f6c 6f72 5472 6961 6e67  .    colorTriang
+00003bc0: 6c65 733a 2054 7570 6c65 5b66 6c6f 6174  les: Tuple[float
+00003bd0: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
+00003be0: 6174 5d0a 2020 2020 636f 6e74 6163 7446  at].    contactF
+00003bf0: 6f72 6365 7346 6163 746f 723a 2066 6c6f  orcesFactor: flo
+00003c00: 6174 0a20 2020 2063 6f6e 7461 6374 506f  at.    contactPo
+00003c10: 696e 7473 4465 6661 756c 7453 697a 653a  intsDefaultSize:
+00003c20: 2066 6c6f 6174 0a20 2020 2073 686f 7742   float.    showB
+00003c30: 6f75 6e64 696e 6742 6f78 6573 3a20 626f  oundingBoxes: bo
+00003c40: 6f6c 0a20 2020 2073 686f 7743 6f6e 7461  ol.    showConta
+00003c50: 6374 466f 7263 6573 3a20 626f 6f6c 0a20  ctForces: bool. 
+00003c60: 2020 2073 686f 7743 6f6e 7461 6374 466f     showContactFo
+00003c70: 7263 6573 5661 6c75 6573 3a20 626f 6f6c  rcesValues: bool
+00003c80: 0a20 2020 2073 686f 7753 6561 7263 6854  .    showSearchT
+00003c90: 7265 653a 2062 6f6f 6c0a 2020 2020 7368  ree: bool.    sh
+00003ca0: 6f77 5365 6172 6368 5472 6565 4365 6c6c  owSearchTreeCell
+00003cb0: 733a 2062 6f6f 6c0a 2020 2020 7368 6f77  s: bool.    show
+00003cc0: 5370 6865 7265 733a 2062 6f6f 6c0a 2020  Spheres: bool.  
+00003cd0: 2020 7368 6f77 5472 6961 6e67 6c65 733a    showTriangles:
+00003ce0: 2062 6f6f 6c0a 2020 2020 7469 6c69 6e67   bool.    tiling
+00003cf0: 5370 6865 7265 733a 2069 6e74 0a0a 0a63  Spheres: int...c
+00003d00: 6c61 7373 2056 5365 7474 696e 6773 5769  lass VSettingsWi
+00003d10: 6e64 6f77 3a0a 2020 2020 616c 7761 7973  ndow:.    always
+00003d20: 4f6e 546f 703a 2062 6f6f 6c0a 2020 2020  OnTop: bool.    
+00003d30: 6967 6e6f 7265 4b65 7973 3a20 626f 6f6c  ignoreKeys: bool
+00003d40: 0a20 2020 206b 6579 5072 6573 7355 7365  .    keyPressUse
+00003d50: 7246 756e 6374 696f 6e3a 2041 6e79 0a20  rFunction: Any. 
+00003d60: 2020 206c 696d 6974 5769 6e64 6f77 546f     limitWindowTo
+00003d70: 5363 7265 656e 5369 7a65 3a20 626f 6f6c  ScreenSize: bool
+00003d80: 0a20 2020 206d 6178 696d 697a 653a 2062  .    maximize: b
+00003d90: 6f6f 6c0a 2020 2020 7265 616c 6c79 5175  ool.    reallyQu
+00003da0: 6974 5469 6d65 4c69 6d69 743a 2066 6c6f  itTimeLimit: flo
+00003db0: 6174 0a20 2020 2072 656e 6465 7257 696e  at.    renderWin
+00003dc0: 646f 7753 697a 653a 2054 7570 6c65 5b69  dowSize: Tuple[i
+00003dd0: 6e74 2c69 6e74 5d0a 2020 2020 406f 7665  nt,int].    @ove
+00003de0: 726c 6f61 640a 2020 2020 6465 6620 5265  rload.    def Re
+00003df0: 7365 744b 6579 5072 6573 7355 7365 7246  setKeyPressUserF
+00003e00: 756e 6374 696f 6e28 2920 2d3e 204e 6f6e  unction() -> Non
+00003e10: 653a 202e 2e2e 0a20 2020 2073 686f 774d  e: ....    showM
+00003e20: 6f75 7365 436f 6f72 6469 6e61 7465 733a  ouseCoordinates:
+00003e30: 2062 6f6f 6c0a 2020 2020 7368 6f77 5769   bool.    showWi
+00003e40: 6e64 6f77 3a20 626f 6f6c 0a20 2020 2073  ndow: bool.    s
+00003e50: 7461 7274 7570 5469 6d65 6f75 743a 2069  tartupTimeout: i
+00003e60: 6e74 0a0a 0a63 6c61 7373 2056 5365 7474  nt...class VSett
+00003e70: 696e 6773 4469 616c 6f67 733a 0a20 2020  ingsDialogs:.   
+00003e80: 2061 6c70 6861 5472 616e 7370 6172 656e   alphaTransparen
+00003e90: 6379 3a20 666c 6f61 740a 2020 2020 616c  cy: float.    al
+00003ea0: 7761 7973 546f 706d 6f73 743a 2062 6f6f  waysTopmost: boo
+00003eb0: 6c0a 2020 2020 666f 6e74 5363 616c 696e  l.    fontScalin
+00003ec0: 674d 6163 4f53 3a20 666c 6f61 740a 2020  gMacOS: float.  
+00003ed0: 2020 6d75 6c74 6954 6872 6561 6465 6444    multiThreadedD
+00003ee0: 6961 6c6f 6773 3a20 626f 6f6c 0a20 2020  ialogs: bool.   
+00003ef0: 206f 7065 6e54 7265 6556 6965 773a 2062   openTreeView: b
+00003f00: 6f6f 6c0a 0a0a 636c 6173 7320 5653 6574  ool...class VSet
+00003f10: 7469 6e67 734f 7065 6e47 4c3a 0a20 2020  tingsOpenGL:.   
+00003f20: 2064 7261 7746 6163 654e 6f72 6d61 6c73   drawFaceNormals
+00003f30: 3a20 626f 6f6c 0a20 2020 2064 7261 774e  : bool.    drawN
+00003f40: 6f72 6d61 6c73 4c65 6e67 7468 3a20 666c  ormalsLength: fl
+00003f50: 6f61 740a 2020 2020 6472 6177 5665 7274  oat.    drawVert
+00003f60: 6578 4e6f 726d 616c 733a 2062 6f6f 6c0a  exNormals: bool.
+00003f70: 2020 2020 656e 6162 6c65 4c69 6768 7430      enableLight0
+00003f80: 3a20 626f 6f6c 0a20 2020 2065 6e61 626c  : bool.    enabl
+00003f90: 654c 6967 6874 313a 2062 6f6f 6c0a 2020  eLight1: bool.  
+00003fa0: 2020 656e 6162 6c65 4c69 6768 7469 6e67    enableLighting
+00003fb0: 3a20 626f 6f6c 0a20 2020 2066 6163 6545  : bool.    faceE
+00003fc0: 6467 6573 436f 6c6f 723a 2054 7570 6c65  dgesColor: Tuple
+00003fd0: 5b66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  [float,float,flo
+00003fe0: 6174 2c66 6c6f 6174 5d0a 2020 2020 6661  at,float].    fa
+00003ff0: 6365 7354 7261 6e73 7061 7265 6e74 3a20  cesTransparent: 
+00004000: 626f 6f6c 0a20 2020 2069 6e69 7469 616c  bool.    initial
+00004010: 4365 6e74 6572 506f 696e 743a 2054 7570  CenterPoint: Tup
+00004020: 6c65 5b66 6c6f 6174 2c66 6c6f 6174 2c66  le[float,float,f
+00004030: 6c6f 6174 5d0a 2020 2020 696e 6974 6961  loat].    initia
+00004040: 6c4d 6178 5363 656e 6553 697a 653a 2066  lMaxSceneSize: f
+00004050: 6c6f 6174 0a20 2020 2069 6e69 7469 616c  loat.    initial
+00004060: 4d6f 6465 6c52 6f74 6174 696f 6e3a 2041  ModelRotation: A
+00004070: 7272 6179 4c69 6b65 0a20 2020 2069 6e69  rrayLike.    ini
+00004080: 7469 616c 5a6f 6f6d 3a20 666c 6f61 740a  tialZoom: float.
+00004090: 2020 2020 6c69 6768 7430 616d 6269 656e      light0ambien
+000040a0: 743a 2066 6c6f 6174 0a20 2020 206c 6967  t: float.    lig
+000040b0: 6874 3063 6f6e 7374 616e 7441 7474 656e  ht0constantAtten
+000040c0: 7561 7469 6f6e 3a20 666c 6f61 740a 2020  uation: float.  
+000040d0: 2020 6c69 6768 7430 6469 6666 7573 653a    light0diffuse:
+000040e0: 2066 6c6f 6174 0a20 2020 206c 6967 6874   float.    light
+000040f0: 306c 696e 6561 7241 7474 656e 7561 7469  0linearAttenuati
+00004100: 6f6e 3a20 666c 6f61 740a 2020 2020 6c69  on: float.    li
+00004110: 6768 7430 706f 7369 7469 6f6e 3a20 5475  ght0position: Tu
+00004120: 706c 655b 666c 6f61 742c 666c 6f61 742c  ple[float,float,
+00004130: 666c 6f61 742c 666c 6f61 745d 0a20 2020  float,float].   
+00004140: 206c 6967 6874 3071 7561 6472 6174 6963   light0quadratic
+00004150: 4174 7465 6e75 6174 696f 6e3a 2066 6c6f  Attenuation: flo
+00004160: 6174 0a20 2020 206c 6967 6874 3073 7065  at.    light0spe
+00004170: 6375 6c61 723a 2066 6c6f 6174 0a20 2020  cular: float.   
+00004180: 206c 6967 6874 3161 6d62 6965 6e74 3a20   light1ambient: 
+00004190: 666c 6f61 740a 2020 2020 6c69 6768 7431  float.    light1
+000041a0: 636f 6e73 7461 6e74 4174 7465 6e75 6174  constantAttenuat
+000041b0: 696f 6e3a 2066 6c6f 6174 0a20 2020 206c  ion: float.    l
+000041c0: 6967 6874 3164 6966 6675 7365 3a20 666c  ight1diffuse: fl
+000041d0: 6f61 740a 2020 2020 6c69 6768 7431 6c69  oat.    light1li
+000041e0: 6e65 6172 4174 7465 6e75 6174 696f 6e3a  nearAttenuation:
+000041f0: 2066 6c6f 6174 0a20 2020 206c 6967 6874   float.    light
+00004200: 3170 6f73 6974 696f 6e3a 2054 7570 6c65  1position: Tuple
+00004210: 5b66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  [float,float,flo
+00004220: 6174 2c66 6c6f 6174 5d0a 2020 2020 6c69  at,float].    li
+00004230: 6768 7431 7175 6164 7261 7469 6341 7474  ght1quadraticAtt
+00004240: 656e 7561 7469 6f6e 3a20 666c 6f61 740a  enuation: float.
+00004250: 2020 2020 6c69 6768 7431 7370 6563 756c      light1specul
+00004260: 6172 3a20 666c 6f61 740a 2020 2020 6c69  ar: float.    li
+00004270: 6768 744d 6f64 656c 416d 6269 656e 743a  ghtModelAmbient:
+00004280: 2054 7570 6c65 5b66 6c6f 6174 2c66 6c6f   Tuple[float,flo
+00004290: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d0a  at,float,float].
+000042a0: 2020 2020 6c69 6768 744d 6f64 656c 4c6f      lightModelLo
+000042b0: 6361 6c56 6965 7765 723a 2062 6f6f 6c0a  calViewer: bool.
+000042c0: 2020 2020 6c69 6768 744d 6f64 656c 5477      lightModelTw
+000042d0: 6f53 6964 653a 2062 6f6f 6c0a 2020 2020  oSide: bool.    
+000042e0: 6c69 6e65 536d 6f6f 7468 3a20 626f 6f6c  lineSmooth: bool
+000042f0: 0a20 2020 206c 696e 6557 6964 7468 3a20  .    lineWidth: 
+00004300: 666c 6f61 740a 2020 2020 6d61 7465 7269  float.    materi
+00004310: 616c 416d 6269 656e 7441 6e64 4469 6666  alAmbientAndDiff
+00004320: 7573 653a 2054 7570 6c65 5b66 6c6f 6174  use: Tuple[float
+00004330: 2c66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  ,float,float,flo
+00004340: 6174 5d0a 2020 2020 6d61 7465 7269 616c  at].    material
+00004350: 5368 696e 696e 6573 733a 2066 6c6f 6174  Shininess: float
+00004360: 0a20 2020 206d 6174 6572 6961 6c53 7065  .    materialSpe
+00004370: 6375 6c61 723a 2054 7570 6c65 5b66 6c6f  cular: Tuple[flo
+00004380: 6174 2c66 6c6f 6174 2c66 6c6f 6174 2c66  at,float,float,f
+00004390: 6c6f 6174 5d0a 2020 2020 6d75 6c74 6953  loat].    multiS
+000043a0: 616d 706c 696e 673a 2069 6e74 0a20 2020  ampling: int.   
+000043b0: 2070 6572 7370 6563 7469 7665 3a20 666c   perspective: fl
+000043c0: 6f61 740a 2020 2020 706f 6c79 676f 6e4f  oat.    polygonO
+000043d0: 6666 7365 743a 2066 6c6f 6174 0a20 2020  ffset: float.   
+000043e0: 2073 6861 6465 4d6f 6465 6c53 6d6f 6f74   shadeModelSmoot
+000043f0: 683a 2062 6f6f 6c0a 2020 2020 7368 6164  h: bool.    shad
+00004400: 6f77 3a20 666c 6f61 740a 2020 2020 7368  ow: float.    sh
+00004410: 6164 6f77 506f 6c79 676f 6e4f 6666 7365  adowPolygonOffse
+00004420: 743a 2066 6c6f 6174 0a20 2020 2073 686f  t: float.    sho
+00004430: 7746 6163 6545 6467 6573 3a20 626f 6f6c  wFaceEdges: bool
+00004440: 0a20 2020 2073 686f 7746 6163 6573 3a20  .    showFaces: 
+00004450: 626f 6f6c 0a20 2020 2073 686f 774c 696e  bool.    showLin
+00004460: 6573 3a20 626f 6f6c 0a20 2020 2073 686f  es: bool.    sho
+00004470: 774d 6573 6845 6467 6573 3a20 626f 6f6c  wMeshEdges: bool
+00004480: 0a20 2020 2073 686f 774d 6573 6846 6163  .    showMeshFac
+00004490: 6573 3a20 626f 6f6c 0a20 2020 2074 6578  es: bool.    tex
+000044a0: 744c 696e 6553 6d6f 6f74 683a 2062 6f6f  tLineSmooth: boo
+000044b0: 6c0a 2020 2020 7465 7874 4c69 6e65 5769  l.    textLineWi
+000044c0: 6474 683a 2066 6c6f 6174 0a0a 0a63 6c61  dth: float...cla
+000044d0: 7373 2056 5365 7474 696e 6773 4578 706f  ss VSettingsExpo
+000044e0: 7274 496d 6167 6573 3a0a 2020 2020 6865  rtImages:.    he
+000044f0: 6967 6874 416c 6967 6e6d 656e 743a 2069  ightAlignment: i
+00004500: 6e74 0a20 2020 2073 6176 6549 6d61 6765  nt.    saveImage
+00004510: 4173 5465 7874 4369 7263 6c65 733a 2062  AsTextCircles: b
+00004520: 6f6f 6c0a 2020 2020 7361 7665 496d 6167  ool.    saveImag
+00004530: 6541 7354 6578 744c 696e 6573 3a20 626f  eAsTextLines: bo
+00004540: 6f6c 0a20 2020 2073 6176 6549 6d61 6765  ol.    saveImage
+00004550: 4173 5465 7874 5465 7874 733a 2062 6f6f  AsTextTexts: boo
+00004560: 6c0a 2020 2020 7361 7665 496d 6167 6541  l.    saveImageA
+00004570: 7354 6578 7454 7269 616e 676c 6573 3a20  sTextTriangles: 
+00004580: 626f 6f6c 0a20 2020 2073 6176 6549 6d61  bool.    saveIma
+00004590: 6765 4669 6c65 436f 756e 7465 723a 2069  geFileCounter: i
+000045a0: 6e74 0a20 2020 2073 6176 6549 6d61 6765  nt.    saveImage
+000045b0: 4669 6c65 4e61 6d65 3a20 7374 720a 2020  FileName: str.  
+000045c0: 2020 7361 7665 496d 6167 6546 6f72 6d61    saveImageForma
+000045d0: 743a 2073 7472 0a20 2020 2073 6176 6549  t: str.    saveI
+000045e0: 6d61 6765 5369 6e67 6c65 4669 6c65 3a20  mageSingleFile: 
+000045f0: 626f 6f6c 0a20 2020 2073 6176 6549 6d61  bool.    saveIma
+00004600: 6765 5469 6d65 4f75 743a 2069 6e74 0a20  geTimeOut: int. 
+00004610: 2020 2077 6964 7468 416c 6967 6e6d 656e     widthAlignmen
+00004620: 743a 2069 6e74 0a0a 0a63 6c61 7373 2056  t: int...class V
+00004630: 5365 7474 696e 6773 4f70 656e 5652 3a0a  SettingsOpenVR:.
+00004640: 2020 2020 6163 7469 6f6e 4d61 6e69 6665      actionManife
+00004650: 7374 4669 6c65 4e61 6d65 3a20 7374 720a  stFileName: str.
+00004660: 2020 2020 656e 6162 6c65 3a20 626f 6f6c      enable: bool
+00004670: 0a20 2020 206c 6f67 4c65 7665 6c3a 2069  .    logLevel: i
+00004680: 6e74 0a20 2020 2073 686f 7743 6f6d 7061  nt.    showCompa
+00004690: 6e69 6f6e 5769 6e64 6f77 3a20 626f 6f6c  nionWindow: bool
+000046a0: 0a0a 0a63 6c61 7373 2056 5365 7474 696e  ...class VSettin
+000046b0: 6773 496e 7465 7261 6374 6976 653a 0a20  gsInteractive:. 
+000046c0: 2020 206f 7065 6e56 523a 2056 5365 7474     openVR: VSett
+000046d0: 696e 6773 4f70 656e 5652 0a20 2020 2068  ingsOpenVR.    h
+000046e0: 6967 686c 6967 6874 436f 6c6f 723a 2054  ighlightColor: T
+000046f0: 7570 6c65 5b66 6c6f 6174 2c66 6c6f 6174  uple[float,float
+00004700: 2c66 6c6f 6174 2c66 6c6f 6174 5d0a 2020  ,float,float].  
+00004710: 2020 6869 6768 6c69 6768 7449 7465 6d49    highlightItemI
+00004720: 6e64 6578 3a20 696e 740a 2020 2020 6869  ndex: int.    hi
+00004730: 6768 6c69 6768 7449 7465 6d54 7970 653a  ghlightItemType:
+00004740: 2049 7465 6d54 7970 650a 2020 2020 6869   ItemType.    hi
+00004750: 6768 6c69 6768 744d 6273 4e75 6d62 6572  ghlightMbsNumber
+00004760: 3a20 696e 740a 2020 2020 6869 6768 6c69  : int.    highli
+00004770: 6768 744f 7468 6572 436f 6c6f 723a 2054  ghtOtherColor: T
+00004780: 7570 6c65 5b66 6c6f 6174 2c66 6c6f 6174  uple[float,float
+00004790: 2c66 6c6f 6174 2c66 6c6f 6174 5d0a 2020  ,float,float].  
+000047a0: 2020 6a6f 7973 7469 636b 5363 616c 6552    joystickScaleR
+000047b0: 6f74 6174 696f 6e3a 2066 6c6f 6174 0a20  otation: float. 
+000047c0: 2020 206a 6f79 7374 6963 6b53 6361 6c65     joystickScale
+000047d0: 5472 616e 736c 6174 696f 6e3a 2066 6c6f  Translation: flo
+000047e0: 6174 0a20 2020 206b 6579 7072 6573 7352  at.    keypressR
+000047f0: 6f74 6174 696f 6e53 7465 703a 2066 6c6f  otationStep: flo
+00004800: 6174 0a20 2020 206b 6579 7072 6573 7354  at.    keypressT
+00004810: 7261 6e73 6c61 7469 6f6e 5374 6570 3a20  ranslationStep: 
+00004820: 666c 6f61 740a 2020 2020 6c6f 636b 4d6f  float.    lockMo
+00004830: 6465 6c56 6965 773a 2062 6f6f 6c0a 2020  delView: bool.  
+00004840: 2020 6d6f 7573 654d 6f76 6552 6f74 6174    mouseMoveRotat
+00004850: 696f 6e46 6163 746f 723a 2066 6c6f 6174  ionFactor: float
+00004860: 0a20 2020 2070 6175 7365 5769 7468 5370  .    pauseWithSp
+00004870: 6163 6562 6172 3a20 626f 6f6c 0a20 2020  acebar: bool.   
+00004880: 2073 656c 6563 7469 6f6e 4869 6768 6c69   selectionHighli
+00004890: 6768 7473 3a20 626f 6f6c 0a20 2020 2073  ghts: bool.    s
+000048a0: 656c 6563 7469 6f6e 4c65 6674 4d6f 7573  electionLeftMous
+000048b0: 653a 2062 6f6f 6c0a 2020 2020 7365 6c65  e: bool.    sele
+000048c0: 6374 696f 6e52 6967 6874 4d6f 7573 653a  ctionRightMouse:
+000048d0: 2062 6f6f 6c0a 2020 2020 7365 6c65 6374   bool.    select
+000048e0: 696f 6e52 6967 6874 4d6f 7573 6547 7261  ionRightMouseGra
+000048f0: 7068 6963 7344 6174 613a 2062 6f6f 6c0a  phicsData: bool.
+00004900: 2020 2020 7472 6163 6b4d 6172 6b65 723a      trackMarker:
+00004910: 2069 6e74 0a20 2020 2074 7261 636b 4d61   int.    trackMa
+00004920: 726b 6572 4d62 734e 756d 6265 723a 2069  rkerMbsNumber: i
+00004930: 6e74 0a20 2020 2074 7261 636b 4d61 726b  nt.    trackMark
+00004940: 6572 4f72 6965 6e74 6174 696f 6e3a 2054  erOrientation: T
+00004950: 7570 6c65 5b66 6c6f 6174 2c66 6c6f 6174  uple[float,float
+00004960: 2c66 6c6f 6174 5d0a 2020 2020 7472 6163  ,float].    trac
+00004970: 6b4d 6172 6b65 7250 6f73 6974 696f 6e3a  kMarkerPosition:
+00004980: 2054 7570 6c65 5b66 6c6f 6174 2c66 6c6f   Tuple[float,flo
+00004990: 6174 2c66 6c6f 6174 5d0a 2020 2020 7573  at,float].    us
+000049a0: 654a 6f79 7374 6963 6b49 6e70 7574 3a20  eJoystickInput: 
+000049b0: 626f 6f6c 0a20 2020 207a 6f6f 6d53 7465  bool.    zoomSte
+000049c0: 7046 6163 746f 723a 2066 6c6f 6174 0a0a  pFactor: float..
+000049d0: 0a63 6c61 7373 2056 6973 7561 6c69 7a61  .class Visualiza
+000049e0: 7469 6f6e 5365 7474 696e 6773 3a0a 2020  tionSettings:.  
+000049f0: 2020 626f 6469 6573 3a20 5653 6574 7469    bodies: VSetti
+00004a00: 6e67 7342 6f64 6965 730a 2020 2020 636f  ngsBodies.    co
+00004a10: 6e6e 6563 746f 7273 3a20 5653 6574 7469  nnectors: VSetti
+00004a20: 6e67 7343 6f6e 6e65 6374 6f72 730a 2020  ngsConnectors.  
+00004a30: 2020 636f 6e74 6163 743a 2056 5365 7474    contact: VSett
+00004a40: 696e 6773 436f 6e74 6163 740a 2020 2020  ingsContact.    
+00004a50: 636f 6e74 6f75 723a 2056 5365 7474 696e  contour: VSettin
+00004a60: 6773 436f 6e74 6f75 720a 2020 2020 6469  gsContour.    di
+00004a70: 616c 6f67 733a 2056 5365 7474 696e 6773  alogs: VSettings
+00004a80: 4469 616c 6f67 730a 2020 2020 6578 706f  Dialogs.    expo
+00004a90: 7274 496d 6167 6573 3a20 5653 6574 7469  rtImages: VSetti
+00004aa0: 6e67 7345 7870 6f72 7449 6d61 6765 730a  ngsExportImages.
+00004ab0: 2020 2020 6765 6e65 7261 6c3a 2056 5365      general: VSe
+00004ac0: 7474 696e 6773 4765 6e65 7261 6c0a 2020  ttingsGeneral.  
+00004ad0: 2020 696e 7465 7261 6374 6976 653a 2056    interactive: V
+00004ae0: 5365 7474 696e 6773 496e 7465 7261 6374  SettingsInteract
+00004af0: 6976 650a 2020 2020 6c6f 6164 733a 2056  ive.    loads: V
+00004b00: 5365 7474 696e 6773 4c6f 6164 730a 2020  SettingsLoads.  
+00004b10: 2020 6d61 726b 6572 733a 2056 5365 7474    markers: VSett
+00004b20: 696e 6773 4d61 726b 6572 730a 2020 2020  ingsMarkers.    
+00004b30: 6e6f 6465 733a 2056 5365 7474 696e 6773  nodes: VSettings
+00004b40: 4e6f 6465 730a 2020 2020 6f70 656e 474c  Nodes.    openGL
+00004b50: 3a20 5653 6574 7469 6e67 734f 7065 6e47  : VSettingsOpenG
+00004b60: 4c0a 2020 2020 7365 6e73 6f72 733a 2056  L.    sensors: V
+00004b70: 5365 7474 696e 6773 5365 6e73 6f72 730a  SettingsSensors.
+00004b80: 2020 2020 7769 6e64 6f77 3a20 5653 6574      window: VSet
+00004b90: 7469 6e67 7357 696e 646f 770a 0a0a 636c  tingsWindow...cl
+00004ba0: 6173 7320 4353 6f6c 7665 7254 696d 6572  ass CSolverTimer
+00004bb0: 3a0a 2020 2020 4145 5248 533a 2066 6c6f  :.    AERHS: flo
+00004bc0: 6174 0a20 2020 2065 7272 6f72 4573 7469  at.    errorEsti
+00004bd0: 6d61 746f 723a 2066 6c6f 6174 0a20 2020  mator: float.   
+00004be0: 2066 6163 746f 7269 7a61 7469 6f6e 3a20   factorization: 
+00004bf0: 666c 6f61 740a 2020 2020 696e 7465 6772  float.    integr
+00004c00: 6174 696f 6e46 6f72 6d75 6c61 3a20 666c  ationFormula: fl
+00004c10: 6f61 740a 2020 2020 6a61 636f 6269 616e  oat.    jacobian
+00004c20: 4145 3a20 666c 6f61 740a 2020 2020 6a61  AE: float.    ja
+00004c30: 636f 6269 616e 4f44 4531 3a20 666c 6f61  cobianODE1: floa
+00004c40: 740a 2020 2020 6a61 636f 6269 616e 4f44  t.    jacobianOD
+00004c50: 4532 3a20 666c 6f61 740a 2020 2020 6a61  E2: float.    ja
+00004c60: 636f 6269 616e 4f44 4532 5f74 3a20 666c  cobianODE2_t: fl
+00004c70: 6f61 740a 2020 2020 6d61 7373 4d61 7472  oat.    massMatr
+00004c80: 6978 3a20 666c 6f61 740a 2020 2020 6e65  ix: float.    ne
+00004c90: 7774 6f6e 496e 6372 656d 656e 743a 2066  wtonIncrement: f
+00004ca0: 6c6f 6174 0a20 2020 204f 4445 3152 4853  loat.    ODE1RHS
+00004cb0: 3a20 666c 6f61 740a 2020 2020 4f44 4532  : float.    ODE2
+00004cc0: 5248 533a 2066 6c6f 6174 0a20 2020 206f  RHS: float.    o
+00004cd0: 7665 7268 6561 643a 2066 6c6f 6174 0a20  verhead: float. 
+00004ce0: 2020 2070 6f73 744e 6577 746f 6e3a 2066     postNewton: f
+00004cf0: 6c6f 6174 0a20 2020 2070 7974 686f 6e3a  loat.    python:
+00004d00: 2066 6c6f 6174 0a20 2020 2072 6561 6374   float.    react
+00004d10: 696f 6e46 6f72 6365 733a 2066 6c6f 6174  ionForces: float
+00004d20: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00004d30: 2020 2064 6566 2052 6573 6574 2875 7365     def Reset(use
+00004d40: 536f 6c76 6572 5469 6d65 7229 202d 3e20  SolverTimer) -> 
+00004d50: 4e6f 6e65 3a20 2e2e 2e0a 2020 2020 406f  None: ....    @o
+00004d60: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00004d70: 5374 6172 7454 696d 6572 2876 616c 7565  StartTimer(value
+00004d80: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00004d90: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00004da0: 2064 6566 2053 746f 7054 696d 6572 2876   def StopTimer(v
+00004db0: 616c 7565 2920 2d3e 204e 6f6e 653a 202e  alue) -> None: .
+00004dc0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00004dd0: 0a20 2020 2064 6566 2053 756d 2829 202d  .    def Sum() -
+00004de0: 3e20 666c 6f61 743a 202e 2e2e 0a20 2020  > float: ....   
+00004df0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00004e00: 6566 2054 6f53 7472 696e 6728 2920 2d3e  ef ToString() ->
+00004e10: 2073 7472 3a20 2e2e 2e0a 2020 2020 746f   str: ....    to
+00004e20: 7461 6c3a 2066 6c6f 6174 0a20 2020 2074  tal: float.    t
+00004e30: 6f74 616c 4a61 636f 6269 616e 3a20 666c  otalJacobian: fl
+00004e40: 6f61 740a 2020 2020 7573 6554 696d 6572  oat.    useTimer
+00004e50: 3a20 626f 6f6c 0a20 2020 2076 6973 7561  : bool.    visua
+00004e60: 6c69 7a61 7469 6f6e 3a20 666c 6f61 740a  lization: float.
+00004e70: 2020 2020 7772 6974 6553 6f6c 7574 696f      writeSolutio
+00004e80: 6e3a 2066 6c6f 6174 0a0a 0a63 6c61 7373  n: float...class
+00004e90: 2053 6f6c 7665 7249 7465 7261 7469 6f6e   SolverIteration
+00004ea0: 4461 7461 3a0a 2020 2020 6164 6170 7469  Data:.    adapti
+00004eb0: 7665 5374 6570 3a20 626f 6f6c 0a20 2020  veStep: bool.   
+00004ec0: 2061 7574 6f6d 6174 6963 5374 6570 5369   automaticStepSi
+00004ed0: 7a65 3a20 626f 6f6c 0a20 2020 2061 7574  ze: bool.    aut
+00004ee0: 6f6d 6174 6963 5374 6570 5369 7a65 4572  omaticStepSizeEr
+00004ef0: 726f 723a 2066 6c6f 6174 0a20 2020 2063  ror: float.    c
+00004f00: 7572 7265 6e74 5374 6570 496e 6465 783a  urrentStepIndex:
+00004f10: 2069 6e74 0a20 2020 2063 7572 7265 6e74   int.    current
+00004f20: 5374 6570 5369 7a65 3a20 666c 6f61 740a  StepSize: float.
+00004f30: 2020 2020 6375 7272 656e 7454 696d 653a      currentTime:
+00004f40: 2066 6c6f 6174 0a20 2020 2064 6973 636f   float.    disco
+00004f50: 6e74 696e 756f 7573 4974 6572 6174 696f  ntinuousIteratio
+00004f60: 6e3a 2069 6e74 0a20 2020 2064 6973 636f  n: int.    disco
+00004f70: 6e74 696e 756f 7573 4974 6572 6174 696f  ntinuousIteratio
+00004f80: 6e73 436f 756e 743a 2069 6e74 0a20 2020  nsCount: int.   
+00004f90: 2065 6e64 5469 6d65 3a20 666c 6f61 740a   endTime: float.
+00004fa0: 2020 2020 696e 6974 6961 6c53 7465 7053      initialStepS
+00004fb0: 697a 653a 2066 6c6f 6174 0a20 2020 206c  ize: float.    l
+00004fc0: 6173 7453 7465 7053 697a 653a 2066 6c6f  astStepSize: flo
+00004fd0: 6174 0a20 2020 206d 6178 5374 6570 5369  at.    maxStepSi
+00004fe0: 7a65 3a20 666c 6f61 740a 2020 2020 6d69  ze: float.    mi
+00004ff0: 6e53 7465 7053 697a 653a 2066 6c6f 6174  nStepSize: float
+00005000: 0a20 2020 206e 6577 746f 6e4a 6163 6f62  .    newtonJacob
+00005010: 6943 6f75 6e74 3a20 696e 740a 2020 2020  iCount: int.    
+00005020: 6e65 7774 6f6e 5374 6570 733a 2069 6e74  newtonSteps: int
+00005030: 0a20 2020 206e 6577 746f 6e53 7465 7073  .    newtonSteps
+00005040: 436f 756e 743a 2069 6e74 0a20 2020 206e  Count: int.    n
+00005050: 756d 6265 724f 6653 7465 7073 3a20 696e  umberOfSteps: in
+00005060: 740a 2020 2020 7265 636f 6d6d 656e 6465  t.    recommende
+00005070: 6453 7465 7053 697a 653a 2066 6c6f 6174  dStepSize: float
+00005080: 0a20 2020 2072 656a 6563 7465 6441 7574  .    rejectedAut
+00005090: 6f6d 6174 6963 5374 6570 5369 7a65 5374  omaticStepSizeSt
+000050a0: 6570 733a 2069 6e74 0a20 2020 2072 656a  eps: int.    rej
+000050b0: 6563 7465 644d 6f64 6966 6965 644e 6577  ectedModifiedNew
+000050c0: 746f 6e53 7465 7073 3a20 696e 740a 2020  tonSteps: int.  
+000050d0: 2020 7374 6172 7454 696d 653a 2066 6c6f    startTime: flo
+000050e0: 6174 0a20 2020 2040 6f76 6572 6c6f 6164  at.    @overload
+000050f0: 0a20 2020 2064 6566 2054 6f53 7472 696e  .    def ToStrin
+00005100: 6728 2920 2d3e 2073 7472 3a20 2e2e 2e0a  g() -> str: ....
+00005110: 0a0a 636c 6173 7320 536f 6c76 6572 436f  ..class SolverCo
+00005120: 6e76 6572 6765 6e63 6544 6174 613a 0a20  nvergenceData:. 
+00005130: 2020 2063 6f6e 7472 6163 7469 7669 7479     contractivity
+00005140: 3a20 666c 6f61 740a 2020 2020 6469 7363  : float.    disc
+00005150: 6f6e 7469 6e75 6f75 7349 7465 7261 7469  ontinuousIterati
+00005160: 6f6e 4572 726f 723a 2066 6c6f 6174 0a20  onError: float. 
+00005170: 2020 2064 6973 636f 6e74 696e 756f 7573     discontinuous
+00005180: 4974 6572 6174 696f 6e53 7563 6365 7373  IterationSuccess
+00005190: 6675 6c3a 2062 6f6f 6c0a 2020 2020 6572  ful: bool.    er
+000051a0: 726f 7243 6f6f 7264 696e 6174 6546 6163  rorCoordinateFac
+000051b0: 746f 723a 2066 6c6f 6174 0a20 2020 2040  tor: float.    @
+000051c0: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+000051d0: 2049 6e69 7469 616c 697a 6544 6174 6128   InitializeData(
+000051e0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+000051f0: 2020 206a 6163 6f62 6961 6e55 7064 6174     jacobianUpdat
+00005200: 6552 6571 7565 7374 6564 3a20 626f 6f6c  eRequested: bool
+00005210: 0a20 2020 206c 6173 7452 6573 6964 7561  .    lastResidua
+00005220: 6c3a 2066 6c6f 6174 0a20 2020 206c 696e  l: float.    lin
+00005230: 6561 7253 6f6c 7665 7243 6175 7369 6e67  earSolverCausing
+00005240: 526f 773a 2069 6e74 0a20 2020 206c 696e  Row: int.    lin
+00005250: 6561 7253 6f6c 7665 7246 6169 6c65 643a  earSolverFailed:
+00005260: 2062 6f6f 6c0a 2020 2020 6d61 7373 4d61   bool.    massMa
+00005270: 7472 6978 4e6f 7449 6e76 6572 7469 626c  trixNotInvertibl
+00005280: 653a 2062 6f6f 6c0a 2020 2020 6e65 7774  e: bool.    newt
+00005290: 6f6e 436f 6e76 6572 6765 643a 2062 6f6f  onConverged: boo
+000052a0: 6c0a 2020 2020 6e65 7774 6f6e 536f 6c75  l.    newtonSolu
+000052b0: 7469 6f6e 4469 7665 7267 6564 3a20 626f  tionDiverged: bo
+000052c0: 6f6c 0a20 2020 2072 6573 6964 7561 6c3a  ol.    residual:
+000052d0: 2066 6c6f 6174 0a20 2020 2073 7465 7052   float.    stepR
+000052e0: 6564 7563 7469 6f6e 4661 696c 6564 3a20  eductionFailed: 
+000052f0: 626f 6f6c 0a20 2020 2073 746f 704e 6577  bool.    stopNew
+00005300: 746f 6e3a 2062 6f6f 6c0a 0a0a 636c 6173  ton: bool...clas
+00005310: 7320 536f 6c76 6572 4f75 7470 7574 4461  s SolverOutputDa
+00005320: 7461 3a0a 2020 2020 6370 754c 6173 7454  ta:.    cpuLastT
+00005330: 696d 6550 7269 6e74 6564 3a20 666c 6f61  imePrinted: floa
+00005340: 740a 2020 2020 6370 7553 7461 7274 5469  t.    cpuStartTi
+00005350: 6d65 3a20 666c 6f61 740a 2020 2020 6669  me: float.    fi
+00005360: 6e69 7368 6564 5375 6363 6573 7366 756c  nishedSuccessful
+00005370: 6c79 3a20 626f 6f6c 0a20 2020 2069 6e69  ly: bool.    ini
+00005380: 7469 616c 697a 6174 696f 6e53 7563 6365  tializationSucce
+00005390: 7373 6675 6c3a 2062 6f6f 6c0a 2020 2020  ssful: bool.    
+000053a0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+000053b0: 6620 496e 6974 6961 6c69 7a65 4461 7461  f InitializeData
+000053c0: 2829 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  () -> None: ....
+000053d0: 2020 2020 6c61 7374 4469 7363 6f6e 7469      lastDisconti
+000053e0: 6e75 6f75 7349 7465 7261 7469 6f6e 7343  nuousIterationsC
+000053f0: 6f75 6e74 3a20 696e 740a 2020 2020 6c61  ount: int.    la
+00005400: 7374 496d 6167 6552 6563 6f72 6465 643a  stImageRecorded:
+00005410: 2066 6c6f 6174 0a20 2020 206c 6173 744e   float.    lastN
+00005420: 6577 746f 6e4a 6163 6f62 6943 6f75 6e74  ewtonJacobiCount
+00005430: 3a20 696e 740a 2020 2020 6c61 7374 4e65  : int.    lastNe
+00005440: 7774 6f6e 5374 6570 7343 6f75 6e74 3a20  wtonStepsCount: 
+00005450: 696e 740a 2020 2020 6c61 7374 5365 6e73  int.    lastSens
+00005460: 6f72 7357 7269 7474 656e 3a20 666c 6f61  orsWritten: floa
+00005470: 740a 2020 2020 6c61 7374 536f 6c75 7469  t.    lastSoluti
+00005480: 6f6e 5772 6974 7465 6e3a 2066 6c6f 6174  onWritten: float
+00005490: 0a20 2020 206c 6173 7456 6572 626f 7365  .    lastVerbose
+000054a0: 5374 6570 496e 6465 783a 2069 6e74 0a20  StepIndex: int. 
+000054b0: 2020 206d 756c 7469 5468 7265 6164 696e     multiThreadin
+000054c0: 674d 6f64 653a 2069 6e74 0a20 2020 206e  gMode: int.    n
+000054d0: 756d 6265 724f 6654 6872 6561 6473 5573  umberOfThreadsUs
+000054e0: 6564 3a20 696e 740a 2020 2020 7374 6570  ed: int.    step
+000054f0: 496e 666f 726d 6174 696f 6e3a 2069 6e74  Information: int
+00005500: 0a20 2020 2076 6572 626f 7365 4d6f 6465  .    verboseMode
+00005510: 3a20 696e 740a 2020 2020 7665 7262 6f73  : int.    verbos
+00005520: 654d 6f64 6546 696c 653a 2069 6e74 0a20  eModeFile: int. 
+00005530: 2020 2077 7269 7465 546f 536f 6c75 7469     writeToSoluti
+00005540: 6f6e 4669 6c65 3a20 626f 6f6c 0a20 2020  onFile: bool.   
+00005550: 2077 7269 7465 546f 536f 6c76 6572 4669   writeToSolverFi
+00005560: 6c65 3a20 626f 6f6c 0a0a 0a63 6c61 7373  le: bool...class
+00005570: 204d 6169 6e53 6f6c 7665 7253 7461 7469   MainSolverStati
+00005580: 633a 0a20 2020 2063 6f6e 763a 2053 6f6c  c:.    conv: Sol
+00005590: 7665 7243 6f6e 7665 7267 656e 6365 4461  verConvergenceDa
+000055a0: 7461 0a20 2020 2069 743a 2053 6f6c 7665  ta.    it: Solve
+000055b0: 7249 7465 7261 7469 6f6e 4461 7461 0a20  rIterationData. 
+000055c0: 2020 206e 6577 746f 6e3a 204e 6577 746f     newton: Newto
+000055d0: 6e53 6574 7469 6e67 730a 2020 2020 6f75  nSettings.    ou
+000055e0: 7470 7574 3a20 536f 6c76 6572 4f75 7470  tput: SolverOutp
+000055f0: 7574 4461 7461 0a20 2020 2074 696d 6572  utData.    timer
+00005600: 3a20 4353 6f6c 7665 7254 696d 6572 0a20  : CSolverTimer. 
+00005610: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00005620: 2064 6566 2043 6865 636b 496e 6974 6961   def CheckInitia
+00005630: 6c69 7a65 6428 6d61 696e 5379 7374 656d  lized(mainSystem
+00005640: 2920 2d3e 2062 6f6f 6c3a 202e 2e2e 0a20  ) -> bool: .... 
+00005650: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00005660: 2064 6566 2043 6f6d 7075 7465 416c 6765   def ComputeAlge
+00005670: 6272 6169 6345 7175 6174 696f 6e73 286d  braicEquations(m
+00005680: 6169 6e53 7973 7465 6d2c 2076 656c 6f63  ainSystem, veloc
+00005690: 6974 794c 6576 656c 3d46 616c 7365 2920  ityLevel=False) 
+000056a0: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+000056b0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+000056c0: 6566 2043 6f6d 7075 7465 4a61 636f 6269  ef ComputeJacobi
+000056d0: 616e 4145 286d 6169 6e53 7973 7465 6d2c  anAE(mainSystem,
+000056e0: 2073 6361 6c61 7246 6163 746f 725f 4f44   scalarFactor_OD
+000056f0: 4532 3d31 2e2c 2073 6361 6c61 7246 6163  E2=1., scalarFac
+00005700: 746f 725f 4f44 4532 5f74 3d30 2e2c 2073  tor_ODE2_t=0., s
+00005710: 6361 6c61 7246 6163 746f 725f 4f44 4531  calarFactor_ODE1
+00005720: 3d31 2e2c 2076 656c 6f63 6974 794c 6576  =1., velocityLev
+00005730: 656c 3d46 616c 7365 2920 2d3e 204e 6f6e  el=False) -> Non
+00005740: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+00005750: 6c6f 6164 0a20 2020 2064 6566 2043 6f6d  load.    def Com
+00005760: 7075 7465 4a61 636f 6269 616e 4f44 4531  puteJacobianODE1
+00005770: 5248 5328 6d61 696e 5379 7374 656d 2c20  RHS(mainSystem, 
+00005780: 7363 616c 6172 4661 6374 6f72 5f4f 4445  scalarFactor_ODE
+00005790: 323d 312e 2c20 7363 616c 6172 4661 6374  2=1., scalarFact
+000057a0: 6f72 5f4f 4445 325f 743d 302e 2c20 7363  or_ODE2_t=0., sc
+000057b0: 616c 6172 4661 6374 6f72 5f4f 4445 313d  alarFactor_ODE1=
+000057c0: 312e 2920 2d3e 204e 6f6e 653a 202e 2e2e  1.) -> None: ...
+000057d0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+000057e0: 2020 2064 6566 2043 6f6d 7075 7465 4a61     def ComputeJa
+000057f0: 636f 6269 616e 4f44 4532 5248 5328 6d61  cobianODE2RHS(ma
+00005800: 696e 5379 7374 656d 2c20 7363 616c 6172  inSystem, scalar
+00005810: 4661 6374 6f72 5f4f 4445 323d 312e 2c20  Factor_ODE2=1., 
+00005820: 7363 616c 6172 4661 6374 6f72 5f4f 4445  scalarFactor_ODE
+00005830: 325f 743d 302e 2c20 7363 616c 6172 4661  2_t=0., scalarFa
+00005840: 6374 6f72 5f4f 4445 313d 312e 2c20 636f  ctor_ODE1=1., co
+00005850: 6d70 7574 654c 6f61 6473 4a61 636f 6269  mputeLoadsJacobi
+00005860: 616e 3d30 2920 2d3e 204e 6f6e 653a 202e  an=0) -> None: .
+00005870: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00005880: 0a20 2020 2064 6566 2043 6f6d 7075 7465  .    def Compute
+00005890: 4c6f 6164 4661 6374 6f72 2873 696d 756c  LoadFactor(simul
+000058a0: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
+000058b0: 3e20 666c 6f61 743a 202e 2e2e 0a20 2020  > float: ....   
+000058c0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+000058d0: 6566 2043 6f6d 7075 7465 4d61 7373 4d61  ef ComputeMassMa
+000058e0: 7472 6978 286d 6169 6e53 7973 7465 6d2c  trix(mainSystem,
+000058f0: 2073 6361 6c61 7246 6163 746f 723d 312e   scalarFactor=1.
+00005900: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00005910: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00005920: 2064 6566 2043 6f6d 7075 7465 4e65 7774   def ComputeNewt
+00005930: 6f6e 4a61 636f 6269 616e 286d 6169 6e53  onJacobian(mainS
+00005940: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
+00005950: 6e53 6574 7469 6e67 7329 202d 3e20 4e6f  nSettings) -> No
+00005960: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+00005970: 726c 6f61 640a 2020 2020 6465 6620 436f  rload.    def Co
+00005980: 6d70 7574 654e 6577 746f 6e52 6573 6964  mputeNewtonResid
+00005990: 7561 6c28 6d61 696e 5379 7374 656d 2c20  ual(mainSystem, 
+000059a0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+000059b0: 6773 2920 2d3e 2066 6c6f 6174 3a20 2e2e  gs) -> float: ..
+000059c0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+000059d0: 2020 2020 6465 6620 436f 6d70 7574 654e      def ComputeN
+000059e0: 6577 746f 6e55 7064 6174 6528 6d61 696e  ewtonUpdate(main
+000059f0: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00005a00: 6f6e 5365 7474 696e 6773 2c20 696e 6974  onSettings, init
+00005a10: 6961 6c3d 5472 7565 2920 2d3e 204e 6f6e  ial=True) -> Non
+00005a20: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+00005a30: 6c6f 6164 0a20 2020 2064 6566 2043 6f6d  load.    def Com
+00005a40: 7075 7465 4f44 4532 5248 5328 6d61 696e  puteODE2RHS(main
+00005a50: 5379 7374 656d 2920 2d3e 204e 6f6e 653a  System) -> None:
+00005a60: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00005a70: 6164 0a20 2020 2064 6566 2044 6973 636f  ad.    def Disco
+00005a80: 6e74 696e 756f 7573 4974 6572 6174 696f  ntinuousIteratio
+00005a90: 6e28 6d61 696e 5379 7374 656d 2c20 7369  n(mainSystem, si
+00005aa0: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00005ab0: 2920 2d3e 2062 6f6f 6c3a 202e 2e2e 0a20  ) -> bool: .... 
+00005ac0: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00005ad0: 2064 6566 2046 696e 616c 697a 6553 6f6c   def FinalizeSol
+00005ae0: 7665 7228 6d61 696e 5379 7374 656d 2c20  ver(mainSystem, 
+00005af0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+00005b00: 6773 2920 2d3e 204e 6f6e 653a 202e 2e2e  gs) -> None: ...
+00005b10: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00005b20: 2020 2064 6566 2046 696e 6973 6853 7465     def FinishSte
+00005b30: 7028 6d61 696e 5379 7374 656d 2c20 7369  p(mainSystem, si
+00005b40: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00005b50: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00005b60: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00005b70: 2064 6566 2047 6574 4145 7369 7a65 2829   def GetAEsize()
+00005b80: 202d 3e20 696e 743a 202e 2e2e 0a20 2020   -> int: ....   
+00005b90: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00005ba0: 6566 2047 6574 4461 7461 5369 7a65 2829  ef GetDataSize()
+00005bb0: 202d 3e20 696e 743a 202e 2e2e 0a20 2020   -> int: ....   
+00005bc0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00005bd0: 6566 2047 6574 4572 726f 7253 7472 696e  ef GetErrorStrin
+00005be0: 6728 2920 2d3e 2073 7472 3a20 2e2e 2e0a  g() -> str: ....
+00005bf0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00005c00: 2020 6465 6620 4765 744e 6577 746f 6e53    def GetNewtonS
+00005c10: 6f6c 7574 696f 6e28 2920 2d3e 2041 7272  olution() -> Arr
+00005c20: 6179 4c69 6b65 3a20 2e2e 2e0a 2020 2020  ayLike: ....    
+00005c30: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00005c40: 6620 4765 744f 4445 3173 697a 6528 2920  f GetODE1size() 
+00005c50: 2d3e 2069 6e74 3a20 2e2e 2e0a 2020 2020  -> int: ....    
+00005c60: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00005c70: 6620 4765 744f 4445 3273 697a 6528 2920  f GetODE2size() 
+00005c80: 2d3e 2069 6e74 3a20 2e2e 2e0a 2020 2020  -> int: ....    
+00005c90: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00005ca0: 6620 4765 7453 696d 756c 6174 696f 6e45  f GetSimulationE
+00005cb0: 6e64 5469 6d65 2873 696d 756c 6174 696f  ndTime(simulatio
+00005cc0: 6e53 6574 7469 6e67 7329 202d 3e20 666c  nSettings) -> fl
+00005cd0: 6f61 743a 202e 2e2e 0a20 2020 2040 6f76  oat: ....    @ov
+00005ce0: 6572 6c6f 6164 0a20 2020 2064 6566 2047  erload.    def G
+00005cf0: 6574 536f 6c76 6572 4e61 6d65 2829 202d  etSolverName() -
+00005d00: 3e20 7374 723a 202e 2e2e 0a20 2020 2040  > str: ....    @
+00005d10: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+00005d20: 2047 6574 5379 7374 656d 4a61 636f 6269   GetSystemJacobi
+00005d30: 616e 2829 202d 3e20 4172 7261 794c 696b  an() -> ArrayLik
+00005d40: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+00005d50: 6c6f 6164 0a20 2020 2064 6566 2047 6574  load.    def Get
+00005d60: 5379 7374 656d 4d61 7373 4d61 7472 6978  SystemMassMatrix
+00005d70: 2829 202d 3e20 4172 7261 794c 696b 653a  () -> ArrayLike:
+00005d80: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00005d90: 6164 0a20 2020 2064 6566 2047 6574 5379  ad.    def GetSy
+00005da0: 7374 656d 5265 7369 6475 616c 2829 202d  stemResidual() -
+00005db0: 3e20 4172 7261 794c 696b 653a 202e 2e2e  > ArrayLike: ...
+00005dc0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00005dd0: 2020 2064 6566 2048 6173 4175 746f 6d61     def HasAutoma
+00005de0: 7469 6353 7465 7053 697a 6543 6f6e 7472  ticStepSizeContr
+00005df0: 6f6c 286d 6169 6e53 7973 7465 6d2c 2073  ol(mainSystem, s
+00005e00: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+00005e10: 7329 202d 3e20 626f 6f6c 3a20 2e2e 2e0a  s) -> bool: ....
+00005e20: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00005e30: 2020 6465 6620 496e 6372 6561 7365 5374    def IncreaseSt
+00005e40: 6570 5369 7a65 286d 6169 6e53 7973 7465  epSize(mainSyste
 00005e50: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
 00005e60: 7469 6e67 7329 202d 3e20 4e6f 6e65 3a20  tings) -> None: 
-00005e70: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00005e80: 6164 0d0a 2020 2020 6465 6620 4765 7441  ad..    def GetA
-00005e90: 4573 697a 6528 2920 2d3e 2069 6e74 3a20  Esize() -> int: 
-00005ea0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00005eb0: 6164 0d0a 2020 2020 6465 6620 4765 7444  ad..    def GetD
-00005ec0: 6174 6153 697a 6528 2920 2d3e 2069 6e74  ataSize() -> int
-00005ed0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00005ee0: 6c6f 6164 0d0a 2020 2020 6465 6620 4765  load..    def Ge
-00005ef0: 7445 7272 6f72 5374 7269 6e67 2829 202d  tErrorString() -
-00005f00: 3e20 7374 723a 202e 2e2e 0d0a 2020 2020  > str: .....    
-00005f10: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00005f20: 6566 2047 6574 4e65 7774 6f6e 536f 6c75  ef GetNewtonSolu
-00005f30: 7469 6f6e 2829 202d 3e20 4172 7261 794c  tion() -> ArrayL
-00005f40: 696b 653a 202e 2e2e 0d0a 2020 2020 406f  ike: .....    @o
-00005f50: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00005f60: 2047 6574 4f44 4531 7369 7a65 2829 202d   GetODE1size() -
-00005f70: 3e20 696e 743a 202e 2e2e 0d0a 2020 2020  > int: .....    
-00005f80: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00005f90: 6566 2047 6574 4f44 4532 7369 7a65 2829  ef GetODE2size()
-00005fa0: 202d 3e20 696e 743a 202e 2e2e 0d0a 2020   -> int: .....  
-00005fb0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00005fc0: 2064 6566 2047 6574 5369 6d75 6c61 7469   def GetSimulati
-00005fd0: 6f6e 456e 6454 696d 6528 7369 6d75 6c61  onEndTime(simula
-00005fe0: 7469 6f6e 5365 7474 696e 6773 2920 2d3e  tionSettings) ->
-00005ff0: 2066 6c6f 6174 3a20 2e2e 2e0d 0a20 2020   float: .....   
-00006000: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00006010: 6465 6620 4765 7453 6f6c 7665 724e 616d  def GetSolverNam
-00006020: 6528 2920 2d3e 2073 7472 3a20 2e2e 2e0d  e() -> str: ....
-00006030: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00006040: 2020 2020 6465 6620 4765 7453 7973 7465      def GetSyste
-00006050: 6d4a 6163 6f62 6961 6e28 2920 2d3e 2041  mJacobian() -> A
-00006060: 7272 6179 4c69 6b65 3a20 2e2e 2e0d 0a20  rrayLike: ..... 
-00006070: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00006080: 2020 6465 6620 4765 7453 7973 7465 6d4d    def GetSystemM
-00006090: 6173 734d 6174 7269 7828 2920 2d3e 2041  assMatrix() -> A
-000060a0: 7272 6179 4c69 6b65 3a20 2e2e 2e0d 0a20  rrayLike: ..... 
-000060b0: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-000060c0: 2020 6465 6620 4765 7453 7973 7465 6d52    def GetSystemR
-000060d0: 6573 6964 7561 6c28 2920 2d3e 2041 7272  esidual() -> Arr
-000060e0: 6179 4c69 6b65 3a20 2e2e 2e0d 0a20 2020  ayLike: .....   
-000060f0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00006100: 6465 6620 4861 7341 7574 6f6d 6174 6963  def HasAutomatic
-00006110: 5374 6570 5369 7a65 436f 6e74 726f 6c28  StepSizeControl(
-00006120: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
-00006130: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
-00006140: 2d3e 2062 6f6f 6c3a 202e 2e2e 0d0a 2020  -> bool: .....  
-00006150: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00006160: 2064 6566 2049 6e63 7265 6173 6553 7465   def IncreaseSte
-00006170: 7053 697a 6528 6d61 696e 5379 7374 656d  pSize(mainSystem
-00006180: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
-00006190: 696e 6773 2920 2d3e 204e 6f6e 653a 202e  ings) -> None: .
-000061a0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-000061b0: 640d 0a20 2020 2064 6566 2049 6e69 7469  d..    def Initi
-000061c0: 616c 697a 6553 6f6c 7665 7228 6d61 696e  alizeSolver(main
-000061d0: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
-000061e0: 6f6e 5365 7474 696e 6773 2920 2d3e 2062  onSettings) -> b
-000061f0: 6f6f 6c3a 202e 2e2e 0d0a 2020 2020 406f  ool: .....    @o
-00006200: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00006210: 2049 6e69 7469 616c 697a 6553 6f6c 7665   InitializeSolve
-00006220: 7244 6174 6128 6d61 696e 5379 7374 656d  rData(mainSystem
-00006230: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
-00006240: 696e 6773 2920 2d3e 204e 6f6e 653a 202e  ings) -> None: .
-00006250: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-00006260: 640d 0a20 2020 2064 6566 2049 6e69 7469  d..    def Initi
-00006270: 616c 697a 6553 6f6c 7665 7249 6e69 7469  alizeSolverIniti
-00006280: 616c 436f 6e64 6974 696f 6e73 286d 6169  alConditions(mai
-00006290: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-000062a0: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-000062b0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-000062c0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000062d0: 6620 496e 6974 6961 6c69 7a65 536f 6c76  f InitializeSolv
-000062e0: 6572 4f75 7470 7574 286d 6169 6e53 7973  erOutput(mainSys
-000062f0: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-00006300: 6574 7469 6e67 7329 202d 3e20 4e6f 6e65  ettings) -> None
-00006310: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00006320: 6c6f 6164 0d0a 2020 2020 6465 6620 496e  load..    def In
-00006330: 6974 6961 6c69 7a65 536f 6c76 6572 5072  itializeSolverPr
-00006340: 6543 6865 636b 7328 6d61 696e 5379 7374  eChecks(mainSyst
-00006350: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
-00006360: 7474 696e 6773 2920 2d3e 2062 6f6f 6c3a  ttings) -> bool:
-00006370: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-00006380: 6f61 640d 0a20 2020 2064 6566 2049 6e69  oad..    def Ini
-00006390: 7469 616c 697a 6553 7465 7028 6d61 696e  tializeStep(main
-000063a0: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
-000063b0: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
-000063c0: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-000063d0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-000063e0: 2049 7353 7461 7469 6353 6f6c 7665 7228   IsStaticSolver(
-000063f0: 2920 2d3e 2062 6f6f 6c3a 202e 2e2e 0d0a  ) -> bool: .....
-00006400: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00006410: 2020 2064 6566 2049 7356 6572 626f 7365     def IsVerbose
-00006420: 4368 6563 6b28 6c65 7665 6c29 202d 3e20  Check(level) -> 
-00006430: 626f 6f6c 3a20 2e2e 2e0d 0a20 2020 206c  bool: .....    l
-00006440: 6f61 6453 7465 7047 656f 6d65 7472 6963  oadStepGeometric
-00006450: 4661 6374 6f72 3a20 666c 6f61 740d 0a20  Factor: float.. 
-00006460: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00006470: 2020 6465 6620 4e65 7774 6f6e 286d 6169    def Newton(mai
-00006480: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-00006490: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-000064a0: 626f 6f6c 3a20 2e2e 2e0d 0a20 2020 2040  bool: .....    @
-000064b0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000064c0: 6620 506f 7374 496e 6974 6961 6c69 7a65  f PostInitialize
-000064d0: 536f 6c76 6572 5370 6563 6966 6963 286d  SolverSpecific(m
-000064e0: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-000064f0: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00006500: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-00006510: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00006520: 6465 6620 5072 6549 6e69 7469 616c 697a  def PreInitializ
-00006530: 6553 6f6c 7665 7253 7065 6369 6669 6328  eSolverSpecific(
-00006540: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
-00006550: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
-00006560: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-00006570: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00006580: 2064 6566 2052 6564 7563 6553 7465 7053   def ReduceStepS
-00006590: 697a 6528 6d61 696e 5379 7374 656d 2c20  ize(mainSystem, 
-000065a0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-000065b0: 6773 2c20 7365 7665 7269 7479 2920 2d3e  gs, severity) ->
-000065c0: 2062 6f6f 6c3a 202e 2e2e 0d0a 2020 2020   bool: .....    
-000065d0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-000065e0: 6566 2053 6574 5379 7374 656d 4a61 636f  ef SetSystemJaco
-000065f0: 6269 616e 2873 7973 7465 6d4a 6163 6f62  bian(systemJacob
-00006600: 6961 6e29 202d 3e20 4e6f 6e65 3a20 2e2e  ian) -> None: ..
-00006610: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00006620: 0d0a 2020 2020 6465 6620 5365 7453 7973  ..    def SetSys
-00006630: 7465 6d4d 6173 734d 6174 7269 7828 7379  temMassMatrix(sy
-00006640: 7374 656d 4d61 7373 4d61 7472 6978 2920  stemMassMatrix) 
-00006650: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-00006660: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00006670: 2064 6566 2053 6574 5379 7374 656d 5265   def SetSystemRe
-00006680: 7369 6475 616c 2873 7973 7465 6d52 6573  sidual(systemRes
-00006690: 6964 7561 6c29 202d 3e20 4e6f 6e65 3a20  idual) -> None: 
-000066a0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-000066b0: 6164 0d0a 2020 2020 6465 6620 536f 6c76  ad..    def Solv
-000066c0: 6553 7465 7073 286d 6169 6e53 7973 7465  eSteps(mainSyste
-000066d0: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-000066e0: 7469 6e67 7329 202d 3e20 626f 6f6c 3a20  tings) -> bool: 
-000066f0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00006700: 6164 0d0a 2020 2020 6465 6620 536f 6c76  ad..    def Solv
-00006710: 6553 7973 7465 6d28 6d61 696e 5379 7374  eSystem(mainSyst
-00006720: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
-00006730: 7474 696e 6773 2920 2d3e 2062 6f6f 6c3a  ttings) -> bool:
-00006740: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-00006750: 6f61 640d 0a20 2020 2064 6566 2055 7064  oad..    def Upd
-00006760: 6174 6543 7572 7265 6e74 5469 6d65 286d  ateCurrentTime(m
-00006770: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00006780: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00006790: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-000067a0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-000067b0: 6465 6620 5665 7262 6f73 6557 7269 7465  def VerboseWrite
-000067c0: 286c 6576 656c 2c20 7374 7229 202d 3e20  (level, str) -> 
-000067d0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-000067e0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000067f0: 6620 5772 6974 6543 6f6f 7264 696e 6174  f WriteCoordinat
-00006800: 6573 546f 4669 6c65 286d 6169 6e53 7973  esToFile(mainSys
-00006810: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-00006820: 6574 7469 6e67 7329 202d 3e20 4e6f 6e65  ettings) -> None
-00006830: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00006840: 6c6f 6164 0d0a 2020 2020 6465 6620 5772  load..    def Wr
-00006850: 6974 6553 6f6c 7574 696f 6e46 696c 6548  iteSolutionFileH
-00006860: 6561 6465 7228 6d61 696e 5379 7374 656d  eader(mainSystem
-00006870: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
-00006880: 696e 6773 2920 2d3e 204e 6f6e 653a 202e  ings) -> None: .
-00006890: 2e2e 0d0a 0d0a 0d0a 636c 6173 7320 4d61  ........class Ma
-000068a0: 696e 536f 6c76 6572 496d 706c 6963 6974  inSolverImplicit
-000068b0: 5365 636f 6e64 4f72 6465 723a 0d0a 2020  SecondOrder:..  
-000068c0: 2020 636f 6e76 3a20 536f 6c76 6572 436f    conv: SolverCo
-000068d0: 6e76 6572 6765 6e63 6544 6174 610d 0a20  nvergenceData.. 
-000068e0: 2020 2069 743a 2053 6f6c 7665 7249 7465     it: SolverIte
-000068f0: 7261 7469 6f6e 4461 7461 0d0a 2020 2020  rationData..    
-00006900: 6e65 7774 6f6e 3a20 4e65 7774 6f6e 5365  newton: NewtonSe
-00006910: 7474 696e 6773 0d0a 2020 2020 6f75 7470  ttings..    outp
-00006920: 7574 3a20 536f 6c76 6572 4f75 7470 7574  ut: SolverOutput
-00006930: 4461 7461 0d0a 2020 2020 7469 6d65 723a  Data..    timer:
-00006940: 2043 536f 6c76 6572 5469 6d65 720d 0a20   CSolverTimer.. 
-00006950: 2020 2061 6c70 6861 463a 2066 6c6f 6174     alphaF: float
-00006960: 0d0a 2020 2020 616c 7068 614d 3a20 666c  ..    alphaM: fl
-00006970: 6f61 740d 0a20 2020 2040 6f76 6572 6c6f  oat..    @overlo
-00006980: 6164 0d0a 2020 2020 6465 6620 4368 6563  ad..    def Chec
-00006990: 6b49 6e69 7469 616c 697a 6564 286d 6169  kInitialized(mai
-000069a0: 6e53 7973 7465 6d29 202d 3e20 626f 6f6c  nSystem) -> bool
-000069b0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-000069c0: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-000069d0: 6d70 7574 6541 6c67 6562 7261 6963 4571  mputeAlgebraicEq
-000069e0: 7561 7469 6f6e 7328 6d61 696e 5379 7374  uations(mainSyst
-000069f0: 656d 2c20 7665 6c6f 6369 7479 4c65 7665  em, velocityLeve
-00006a00: 6c3d 4661 6c73 6529 202d 3e20 4e6f 6e65  l=False) -> None
-00006a10: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00006a20: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-00006a30: 6d70 7574 654a 6163 6f62 6961 6e41 4528  mputeJacobianAE(
-00006a40: 6d61 696e 5379 7374 656d 2c20 7363 616c  mainSystem, scal
-00006a50: 6172 4661 6374 6f72 5f4f 4445 323d 312e  arFactor_ODE2=1.
-00006a60: 2c20 7363 616c 6172 4661 6374 6f72 5f4f  , scalarFactor_O
-00006a70: 4445 325f 743d 302e 2c20 7363 616c 6172  DE2_t=0., scalar
-00006a80: 4661 6374 6f72 5f4f 4445 313d 312e 2c20  Factor_ODE1=1., 
-00006a90: 7665 6c6f 6369 7479 4c65 7665 6c3d 4661  velocityLevel=Fa
-00006aa0: 6c73 6529 202d 3e20 4e6f 6e65 3a20 2e2e  lse) -> None: ..
-00006ab0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00006ac0: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-00006ad0: 654a 6163 6f62 6961 6e4f 4445 3152 4853  eJacobianODE1RHS
-00006ae0: 286d 6169 6e53 7973 7465 6d2c 2073 6361  (mainSystem, sca
-00006af0: 6c61 7246 6163 746f 725f 4f44 4532 3d31  larFactor_ODE2=1
-00006b00: 2e2c 2073 6361 6c61 7246 6163 746f 725f  ., scalarFactor_
-00006b10: 4f44 4532 5f74 3d30 2e2c 2073 6361 6c61  ODE2_t=0., scala
-00006b20: 7246 6163 746f 725f 4f44 4531 3d31 2e29  rFactor_ODE1=1.)
-00006b30: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20   -> None: ..... 
-00006b40: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00006b50: 2020 6465 6620 436f 6d70 7574 654a 6163    def ComputeJac
-00006b60: 6f62 6961 6e4f 4445 3252 4853 286d 6169  obianODE2RHS(mai
-00006b70: 6e53 7973 7465 6d2c 2073 6361 6c61 7246  nSystem, scalarF
-00006b80: 6163 746f 725f 4f44 4532 3d31 2e2c 2073  actor_ODE2=1., s
-00006b90: 6361 6c61 7246 6163 746f 725f 4f44 4532  calarFactor_ODE2
-00006ba0: 5f74 3d30 2e2c 2073 6361 6c61 7246 6163  _t=0., scalarFac
-00006bb0: 746f 725f 4f44 4531 3d31 2e2c 2063 6f6d  tor_ODE1=1., com
-00006bc0: 7075 7465 4c6f 6164 734a 6163 6f62 6961  puteLoadsJacobia
-00006bd0: 6e3d 3029 202d 3e20 4e6f 6e65 3a20 2e2e  n=0) -> None: ..
-00006be0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00006bf0: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-00006c00: 654c 6f61 6446 6163 746f 7228 7369 6d75  eLoadFactor(simu
-00006c10: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
-00006c20: 2d3e 2066 6c6f 6174 3a20 2e2e 2e0d 0a20  -> float: ..... 
-00006c30: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00006c40: 2020 6465 6620 436f 6d70 7574 654d 6173    def ComputeMas
-00006c50: 734d 6174 7269 7828 6d61 696e 5379 7374  sMatrix(mainSyst
-00006c60: 656d 2c20 7363 616c 6172 4661 6374 6f72  em, scalarFactor
-00006c70: 3d31 2e29 202d 3e20 4e6f 6e65 3a20 2e2e  =1.) -> None: ..
-00006c80: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00006c90: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-00006ca0: 654e 6577 746f 6e4a 6163 6f62 6961 6e28  eNewtonJacobian(
-00006cb0: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
-00006cc0: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
-00006cd0: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-00006ce0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00006cf0: 2064 6566 2043 6f6d 7075 7465 4e65 7774   def ComputeNewt
-00006d00: 6f6e 5265 7369 6475 616c 286d 6169 6e53  onResidual(mainS
-00006d10: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
-00006d20: 6e53 6574 7469 6e67 7329 202d 3e20 666c  nSettings) -> fl
-00006d30: 6f61 743a 202e 2e2e 0d0a 2020 2020 406f  oat: .....    @o
-00006d40: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00006d50: 2043 6f6d 7075 7465 4e65 7774 6f6e 5570   ComputeNewtonUp
-00006d60: 6461 7465 286d 6169 6e53 7973 7465 6d2c  date(mainSystem,
-00006d70: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
-00006d80: 6e67 732c 2069 6e69 7469 616c 3d54 7275  ngs, initial=Tru
-00006d90: 6529 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  e) -> None: ....
-00006da0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00006db0: 2020 2020 6465 6620 436f 6d70 7574 654f      def ComputeO
-00006dc0: 4445 3152 4853 286d 6169 6e53 7973 7465  DE1RHS(mainSyste
-00006dd0: 6d29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  m) -> None: ....
-00006de0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00006df0: 2020 2020 6465 6620 436f 6d70 7574 654f      def ComputeO
-00006e00: 4445 3252 4853 286d 6169 6e53 7973 7465  DE2RHS(mainSyste
-00006e10: 6d29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  m) -> None: ....
-00006e20: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00006e30: 2020 2020 6465 6620 4469 7363 6f6e 7469      def Disconti
-00006e40: 6e75 6f75 7349 7465 7261 7469 6f6e 286d  nuousIteration(m
-00006e50: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00006e60: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00006e70: 3e20 626f 6f6c 3a20 2e2e 2e0d 0a20 2020  > bool: .....   
-00006e80: 2066 6163 744a 6163 416c 676f 7269 7468   factJacAlgorith
-00006e90: 6d69 633a 2066 6c6f 6174 0d0a 2020 2020  mic: float..    
-00006ea0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00006eb0: 6566 2046 696e 616c 697a 6553 6f6c 7665  ef FinalizeSolve
-00006ec0: 7228 6d61 696e 5379 7374 656d 2c20 7369  r(mainSystem, si
-00006ed0: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
-00006ee0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0d0a  ) -> None: .....
-00006ef0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00006f00: 2020 2064 6566 2046 696e 6973 6853 7465     def FinishSte
-00006f10: 7028 6d61 696e 5379 7374 656d 2c20 7369  p(mainSystem, si
-00006f20: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
-00006f30: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0d0a  ) -> None: .....
-00006f40: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00006f50: 2020 2064 6566 2047 6574 4141 6c67 6f72     def GetAAlgor
-00006f60: 6974 686d 6963 2829 202d 3e20 4172 7261  ithmic() -> Arra
-00006f70: 794c 696b 653a 202e 2e2e 0d0a 2020 2020  yLike: .....    
-00006f80: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00006f90: 6566 2047 6574 4145 7369 7a65 2829 202d  ef GetAEsize() -
-00006fa0: 3e20 696e 743a 202e 2e2e 0d0a 2020 2020  > int: .....    
-00006fb0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00006fc0: 6566 2047 6574 4461 7461 5369 7a65 2829  ef GetDataSize()
-00006fd0: 202d 3e20 696e 743a 202e 2e2e 0d0a 2020   -> int: .....  
-00006fe0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00006ff0: 2064 6566 2047 6574 4572 726f 7253 7472   def GetErrorStr
-00007000: 696e 6728 2920 2d3e 2073 7472 3a20 2e2e  ing() -> str: ..
-00007010: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00007020: 0d0a 2020 2020 6465 6620 4765 744e 6577  ..    def GetNew
-00007030: 746f 6e53 6f6c 7574 696f 6e28 2920 2d3e  tonSolution() ->
-00007040: 2041 7272 6179 4c69 6b65 3a20 2e2e 2e0d   ArrayLike: ....
-00007050: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00007060: 2020 2020 6465 6620 4765 744f 4445 3173      def GetODE1s
-00007070: 697a 6528 2920 2d3e 2069 6e74 3a20 2e2e  ize() -> int: ..
-00007080: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00007090: 0d0a 2020 2020 6465 6620 4765 744f 4445  ..    def GetODE
-000070a0: 3273 697a 6528 2920 2d3e 2069 6e74 3a20  2size() -> int: 
-000070b0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-000070c0: 6164 0d0a 2020 2020 6465 6620 4765 7453  ad..    def GetS
-000070d0: 696d 756c 6174 696f 6e45 6e64 5469 6d65  imulationEndTime
-000070e0: 2873 696d 756c 6174 696f 6e53 6574 7469  (simulationSetti
-000070f0: 6e67 7329 202d 3e20 666c 6f61 743a 202e  ngs) -> float: .
-00007100: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-00007110: 640d 0a20 2020 2064 6566 2047 6574 536f  d..    def GetSo
-00007120: 6c76 6572 4e61 6d65 2829 202d 3e20 7374  lverName() -> st
-00007130: 723a 202e 2e2e 0d0a 2020 2020 406f 7665  r: .....    @ove
-00007140: 726c 6f61 640d 0a20 2020 2064 6566 2047  rload..    def G
-00007150: 6574 5374 6172 744f 6653 7465 7053 7461  etStartOfStepSta
-00007160: 7465 4141 6c67 6f72 6974 686d 6963 2829  teAAlgorithmic()
-00007170: 202d 3e20 4172 7261 794c 696b 653a 202e   -> ArrayLike: .
-00007180: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-00007190: 640d 0a20 2020 2064 6566 2047 6574 5379  d..    def GetSy
-000071a0: 7374 656d 4a61 636f 6269 616e 2829 202d  stemJacobian() -
-000071b0: 3e20 4172 7261 794c 696b 653a 202e 2e2e  > ArrayLike: ...
-000071c0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-000071d0: 0a20 2020 2064 6566 2047 6574 5379 7374  .    def GetSyst
-000071e0: 656d 4d61 7373 4d61 7472 6978 2829 202d  emMassMatrix() -
-000071f0: 3e20 4172 7261 794c 696b 653a 202e 2e2e  > ArrayLike: ...
-00007200: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00007210: 0a20 2020 2064 6566 2047 6574 5379 7374  .    def GetSyst
-00007220: 656d 5265 7369 6475 616c 2829 202d 3e20  emResidual() -> 
-00007230: 4172 7261 794c 696b 653a 202e 2e2e 0d0a  ArrayLike: .....
-00007240: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00007250: 2020 2064 6566 2048 6173 4175 746f 6d61     def HasAutoma
-00007260: 7469 6353 7465 7053 697a 6543 6f6e 7472  ticStepSizeContr
-00007270: 6f6c 286d 6169 6e53 7973 7465 6d2c 2073  ol(mainSystem, s
-00007280: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
-00007290: 7329 202d 3e20 626f 6f6c 3a20 2e2e 2e0d  s) -> bool: ....
-000072a0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-000072b0: 2020 2020 6465 6620 496e 6372 6561 7365      def Increase
-000072c0: 5374 6570 5369 7a65 286d 6169 6e53 7973  StepSize(mainSys
-000072d0: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-000072e0: 6574 7469 6e67 7329 202d 3e20 4e6f 6e65  ettings) -> None
-000072f0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00007300: 6c6f 6164 0d0a 2020 2020 6465 6620 496e  load..    def In
-00007310: 6974 6961 6c69 7a65 536f 6c76 6572 286d  itializeSolver(m
-00007320: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00007330: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00007340: 3e20 626f 6f6c 3a20 2e2e 2e0d 0a20 2020  > bool: .....   
-00007350: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00007360: 6465 6620 496e 6974 6961 6c69 7a65 536f  def InitializeSo
-00007370: 6c76 6572 4461 7461 286d 6169 6e53 7973  lverData(mainSys
-00007380: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-00007390: 6574 7469 6e67 7329 202d 3e20 4e6f 6e65  ettings) -> None
-000073a0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-000073b0: 6c6f 6164 0d0a 2020 2020 6465 6620 496e  load..    def In
-000073c0: 6974 6961 6c69 7a65 536f 6c76 6572 496e  itializeSolverIn
-000073d0: 6974 6961 6c43 6f6e 6469 7469 6f6e 7328  itialConditions(
-000073e0: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
-000073f0: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
-00007400: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-00007410: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00007420: 2064 6566 2049 6e69 7469 616c 697a 6553   def InitializeS
-00007430: 6f6c 7665 724f 7574 7075 7428 6d61 696e  olverOutput(main
-00007440: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
-00007450: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
-00007460: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-00007470: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00007480: 2049 6e69 7469 616c 697a 6553 6f6c 7665   InitializeSolve
-00007490: 7250 7265 4368 6563 6b73 286d 6169 6e53  rPreChecks(mainS
-000074a0: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
-000074b0: 6e53 6574 7469 6e67 7329 202d 3e20 626f  nSettings) -> bo
-000074c0: 6f6c 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ol: .....    @ov
-000074d0: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-000074e0: 496e 6974 6961 6c69 7a65 5374 6570 286d  InitializeStep(m
-000074f0: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00007500: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00007510: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-00007520: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00007530: 6465 6620 4973 5374 6174 6963 536f 6c76  def IsStaticSolv
-00007540: 6572 2829 202d 3e20 626f 6f6c 3a20 2e2e  er() -> bool: ..
-00007550: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00007560: 0d0a 2020 2020 6465 6620 4973 5665 7262  ..    def IsVerb
-00007570: 6f73 6543 6865 636b 286c 6576 656c 2920  oseCheck(level) 
-00007580: 2d3e 2062 6f6f 6c3a 202e 2e2e 0d0a 2020  -> bool: .....  
-00007590: 2020 6e65 776d 6172 6b42 6574 613a 2066    newmarkBeta: f
-000075a0: 6c6f 6174 0d0a 2020 2020 6e65 776d 6172  loat..    newmar
-000075b0: 6b47 616d 6d61 3a20 666c 6f61 740d 0a20  kGamma: float.. 
-000075c0: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-000075d0: 2020 6465 6620 4e65 7774 6f6e 286d 6169    def Newton(mai
-000075e0: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-000075f0: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-00007600: 626f 6f6c 3a20 2e2e 2e0d 0a20 2020 2040  bool: .....    @
-00007610: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00007620: 6620 506f 7374 496e 6974 6961 6c69 7a65  f PostInitialize
-00007630: 536f 6c76 6572 5370 6563 6966 6963 286d  SolverSpecific(m
-00007640: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00007650: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00007660: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-00007670: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00007680: 6465 6620 506f 7374 4e65 7774 6f6e 286d  def PostNewton(m
-00007690: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-000076a0: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-000076b0: 3e20 666c 6f61 743a 202e 2e2e 0d0a 2020  > float: .....  
-000076c0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-000076d0: 2064 6566 2050 7265 496e 6974 6961 6c69   def PreInitiali
-000076e0: 7a65 536f 6c76 6572 5370 6563 6966 6963  zeSolverSpecific
-000076f0: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
-00007700: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
-00007710: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20   -> None: ..... 
-00007720: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00007730: 2020 6465 6620 5265 6475 6365 5374 6570    def ReduceStep
-00007740: 5369 7a65 286d 6169 6e53 7973 7465 6d2c  Size(mainSystem,
-00007750: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
-00007760: 6e67 732c 2073 6576 6572 6974 7929 202d  ngs, severity) -
-00007770: 3e20 626f 6f6c 3a20 2e2e 2e0d 0a20 2020  > bool: .....   
-00007780: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00007790: 6465 6620 5365 7453 7973 7465 6d4a 6163  def SetSystemJac
-000077a0: 6f62 6961 6e28 7379 7374 656d 4a61 636f  obian(systemJaco
-000077b0: 6269 616e 2920 2d3e 204e 6f6e 653a 202e  bian) -> None: .
-000077c0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-000077d0: 640d 0a20 2020 2064 6566 2053 6574 5379  d..    def SetSy
-000077e0: 7374 656d 4d61 7373 4d61 7472 6978 2873  stemMassMatrix(s
-000077f0: 7973 7465 6d4d 6173 734d 6174 7269 7829  ystemMassMatrix)
-00007800: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20   -> None: ..... 
-00007810: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00007820: 2020 6465 6620 5365 7453 7973 7465 6d52    def SetSystemR
-00007830: 6573 6964 7561 6c28 7379 7374 656d 5265  esidual(systemRe
-00007840: 7369 6475 616c 2920 2d3e 204e 6f6e 653a  sidual) -> None:
-00007850: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-00007860: 6f61 640d 0a20 2020 2064 6566 2053 6574  oad..    def Set
-00007870: 5573 6572 4675 6e63 7469 6f6e 436f 6d70  UserFunctionComp
-00007880: 7574 654e 6577 746f 6e4a 6163 6f62 6961  uteNewtonJacobia
-00007890: 6e28 6d61 696e 5379 7374 656d 2c20 7573  n(mainSystem, us
-000078a0: 6572 4675 6e63 7469 6f6e 2920 2d3e 204e  erFunction) -> N
-000078b0: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-000078c0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-000078d0: 2053 6574 5573 6572 4675 6e63 7469 6f6e   SetUserFunction
-000078e0: 436f 6d70 7574 654e 6577 746f 6e52 6573  ComputeNewtonRes
-000078f0: 6964 7561 6c28 6d61 696e 5379 7374 656d  idual(mainSystem
-00007900: 2c20 7573 6572 4675 6e63 7469 6f6e 2920  , userFunction) 
-00007910: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-00007920: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00007930: 2064 6566 2053 6574 5573 6572 4675 6e63   def SetUserFunc
-00007940: 7469 6f6e 436f 6d70 7574 654e 6577 746f  tionComputeNewto
-00007950: 6e55 7064 6174 6528 6d61 696e 5379 7374  nUpdate(mainSyst
-00007960: 656d 2c20 7573 6572 4675 6e63 7469 6f6e  em, userFunction
-00007970: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0d0a  ) -> None: .....
-00007980: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00007990: 2020 2064 6566 2053 6574 5573 6572 4675     def SetUserFu
-000079a0: 6e63 7469 6f6e 4469 7363 6f6e 7469 6e75  nctionDiscontinu
-000079b0: 6f75 7349 7465 7261 7469 6f6e 286d 6169  ousIteration(mai
-000079c0: 6e53 7973 7465 6d2c 2075 7365 7246 756e  nSystem, userFun
-000079d0: 6374 696f 6e29 202d 3e20 4e6f 6e65 3a20  ction) -> None: 
-000079e0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-000079f0: 6164 0d0a 2020 2020 6465 6620 5365 7455  ad..    def SetU
-00007a00: 7365 7246 756e 6374 696f 6e46 696e 6973  serFunctionFinis
-00007a10: 6853 7465 7028 6d61 696e 5379 7374 656d  hStep(mainSystem
-00007a20: 2c20 7573 6572 4675 6e63 7469 6f6e 2920  , userFunction) 
-00007a30: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-00007a40: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00007a50: 2064 6566 2053 6574 5573 6572 4675 6e63   def SetUserFunc
-00007a60: 7469 6f6e 496e 6974 6961 6c69 7a65 5374  tionInitializeSt
-00007a70: 6570 286d 6169 6e53 7973 7465 6d2c 2075  ep(mainSystem, u
-00007a80: 7365 7246 756e 6374 696f 6e29 202d 3e20  serFunction) -> 
-00007a90: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-00007aa0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00007ab0: 6620 5365 7455 7365 7246 756e 6374 696f  f SetUserFunctio
-00007ac0: 6e4e 6577 746f 6e28 6d61 696e 5379 7374  nNewton(mainSyst
-00007ad0: 656d 2c20 7573 6572 4675 6e63 7469 6f6e  em, userFunction
-00007ae0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0d0a  ) -> None: .....
-00007af0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00007b00: 2020 2064 6566 2053 6574 5573 6572 4675     def SetUserFu
-00007b10: 6e63 7469 6f6e 506f 7374 4e65 7774 6f6e  nctionPostNewton
-00007b20: 286d 6169 6e53 7973 7465 6d2c 2075 7365  (mainSystem, use
-00007b30: 7246 756e 6374 696f 6e29 202d 3e20 4e6f  rFunction) -> No
-00007b40: 6e65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ne: .....    @ov
-00007b50: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00007b60: 5365 7455 7365 7246 756e 6374 696f 6e55  SetUserFunctionU
-00007b70: 7064 6174 6543 7572 7265 6e74 5469 6d65  pdateCurrentTime
-00007b80: 286d 6169 6e53 7973 7465 6d2c 2075 7365  (mainSystem, use
-00007b90: 7246 756e 6374 696f 6e29 202d 3e20 4e6f  rFunction) -> No
-00007ba0: 6e65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ne: .....    @ov
-00007bb0: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00007bc0: 536f 6c76 6553 7465 7073 286d 6169 6e53  SolveSteps(mainS
-00007bd0: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
-00007be0: 6e53 6574 7469 6e67 7329 202d 3e20 626f  nSettings) -> bo
-00007bf0: 6f6c 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ol: .....    @ov
-00007c00: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00007c10: 536f 6c76 6553 7973 7465 6d28 6d61 696e  SolveSystem(main
-00007c20: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
-00007c30: 6f6e 5365 7474 696e 6773 2920 2d3e 2062  onSettings) -> b
-00007c40: 6f6f 6c3a 202e 2e2e 0d0a 2020 2020 7370  ool: .....    sp
-00007c50: 6563 7472 616c 5261 6469 7573 3a20 666c  ectralRadius: fl
-00007c60: 6f61 740d 0a20 2020 2040 6f76 6572 6c6f  oat..    @overlo
-00007c70: 6164 0d0a 2020 2020 6465 6620 5570 6461  ad..    def Upda
-00007c80: 7465 4375 7272 656e 7454 696d 6528 6d61  teCurrentTime(ma
-00007c90: 696e 5379 7374 656d 2c20 7369 6d75 6c61  inSystem, simula
-00007ca0: 7469 6f6e 5365 7474 696e 6773 2920 2d3e  tionSettings) ->
-00007cb0: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-00007cc0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00007cd0: 6566 2056 6572 626f 7365 5772 6974 6528  ef VerboseWrite(
-00007ce0: 6c65 7665 6c2c 2073 7472 2920 2d3e 204e  level, str) -> N
-00007cf0: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-00007d00: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00007d10: 2057 7269 7465 436f 6f72 6469 6e61 7465   WriteCoordinate
-00007d20: 7354 6f46 696c 6528 6d61 696e 5379 7374  sToFile(mainSyst
-00007d30: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
-00007d40: 7474 696e 6773 2920 2d3e 204e 6f6e 653a  ttings) -> None:
-00007d50: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-00007d60: 6f61 640d 0a20 2020 2064 6566 2057 7269  oad..    def Wri
-00007d70: 7465 536f 6c75 7469 6f6e 4669 6c65 4865  teSolutionFileHe
-00007d80: 6164 6572 286d 6169 6e53 7973 7465 6d2c  ader(mainSystem,
-00007d90: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
-00007da0: 6e67 7329 202d 3e20 4e6f 6e65 3a20 2e2e  ngs) -> None: ..
-00007db0: 2e0d 0a0d 0a0d 0a63 6c61 7373 204d 6169  .......class Mai
-00007dc0: 6e53 6f6c 7665 7245 7870 6c69 6369 743a  nSolverExplicit:
-00007dd0: 0d0a 2020 2020 636f 6e76 3a20 536f 6c76  ..    conv: Solv
-00007de0: 6572 436f 6e76 6572 6765 6e63 6544 6174  erConvergenceDat
-00007df0: 610d 0a20 2020 2069 743a 2053 6f6c 7665  a..    it: Solve
-00007e00: 7249 7465 7261 7469 6f6e 4461 7461 0d0a  rIterationData..
-00007e10: 2020 2020 6f75 7470 7574 3a20 536f 6c76      output: Solv
-00007e20: 6572 4f75 7470 7574 4461 7461 0d0a 2020  erOutputData..  
-00007e30: 2020 7469 6d65 723a 2043 536f 6c76 6572    timer: CSolver
-00007e40: 5469 6d65 720d 0a20 2020 2040 6f76 6572  Timer..    @over
-00007e50: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-00007e60: 6d70 7574 654c 6f61 6446 6163 746f 7228  mputeLoadFactor(
-00007e70: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-00007e80: 6773 2920 2d3e 2066 6c6f 6174 3a20 2e2e  gs) -> float: ..
-00007e90: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00007ea0: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-00007eb0: 654d 6173 734d 6174 7269 7828 6d61 696e  eMassMatrix(main
-00007ec0: 5379 7374 656d 2c20 7363 616c 6172 4661  System, scalarFa
-00007ed0: 6374 6f72 3d31 2e29 202d 3e20 4e6f 6e65  ctor=1.) -> None
-00007ee0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00007ef0: 6c6f 6164 0d0a 2020 2020 6465 6620 436f  load..    def Co
-00007f00: 6d70 7574 654e 6577 746f 6e4a 6163 6f62  mputeNewtonJacob
-00007f10: 6961 6e28 6d61 696e 5379 7374 656d 2c20  ian(mainSystem, 
-00007f20: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-00007f30: 6773 2920 2d3e 204e 6f6e 653a 202e 2e2e  gs) -> None: ...
-00007f40: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00007f50: 0a20 2020 2064 6566 2043 6f6d 7075 7465  .    def Compute
-00007f60: 4e65 7774 6f6e 5265 7369 6475 616c 286d  NewtonResidual(m
-00007f70: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00007f80: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00007f90: 3e20 666c 6f61 743a 202e 2e2e 0d0a 2020  > float: .....  
-00007fa0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00007fb0: 2064 6566 2043 6f6d 7075 7465 4e65 7774   def ComputeNewt
-00007fc0: 6f6e 5570 6461 7465 286d 6169 6e53 7973  onUpdate(mainSys
-00007fd0: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-00007fe0: 6574 7469 6e67 732c 2069 6e69 7469 616c  ettings, initial
-00007ff0: 3d54 7275 6529 202d 3e20 4e6f 6e65 3a20  =True) -> None: 
-00008000: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00008010: 6164 0d0a 2020 2020 6465 6620 436f 6d70  ad..    def Comp
-00008020: 7574 654f 4445 3152 4853 286d 6169 6e53  uteODE1RHS(mainS
-00008030: 7973 7465 6d29 202d 3e20 4e6f 6e65 3a20  ystem) -> None: 
-00008040: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00008050: 6164 0d0a 2020 2020 6465 6620 436f 6d70  ad..    def Comp
-00008060: 7574 654f 4445 3252 4853 286d 6169 6e53  uteODE2RHS(mainS
-00008070: 7973 7465 6d29 202d 3e20 4e6f 6e65 3a20  ystem) -> None: 
-00008080: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00008090: 6164 0d0a 2020 2020 6465 6620 4469 7363  ad..    def Disc
-000080a0: 6f6e 7469 6e75 6f75 7349 7465 7261 7469  ontinuousIterati
-000080b0: 6f6e 286d 6169 6e53 7973 7465 6d2c 2073  on(mainSystem, s
-000080c0: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
-000080d0: 7329 202d 3e20 626f 6f6c 3a20 2e2e 2e0d  s) -> bool: ....
-000080e0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-000080f0: 2020 2020 6465 6620 4669 6e61 6c69 7a65      def Finalize
-00008100: 536f 6c76 6572 286d 6169 6e53 7973 7465  Solver(mainSyste
-00008110: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-00008120: 7469 6e67 7329 202d 3e20 4e6f 6e65 3a20  tings) -> None: 
-00008130: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00008140: 6164 0d0a 2020 2020 6465 6620 4669 6e69  ad..    def Fini
-00008150: 7368 5374 6570 286d 6169 6e53 7973 7465  shStep(mainSyste
-00008160: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-00008170: 7469 6e67 7329 202d 3e20 4e6f 6e65 3a20  tings) -> None: 
-00008180: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00008190: 6164 0d0a 2020 2020 6465 6620 4765 7441  ad..    def GetA
-000081a0: 4573 697a 6528 2920 2d3e 2069 6e74 3a20  Esize() -> int: 
-000081b0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-000081c0: 6164 0d0a 2020 2020 6465 6620 4765 7444  ad..    def GetD
-000081d0: 6174 6153 697a 6528 2920 2d3e 2069 6e74  ataSize() -> int
-000081e0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-000081f0: 6c6f 6164 0d0a 2020 2020 6465 6620 4765  load..    def Ge
-00008200: 7445 7272 6f72 5374 7269 6e67 2829 202d  tErrorString() -
-00008210: 3e20 7374 723a 202e 2e2e 0d0a 2020 2020  > str: .....    
-00008220: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00008230: 6566 2047 6574 4d65 7468 6f64 4f72 6465  ef GetMethodOrde
-00008240: 7228 2920 2d3e 2069 6e74 3a20 2e2e 2e0d  r() -> int: ....
-00008250: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00008260: 2020 2020 6465 6620 4765 744e 756d 6265      def GetNumbe
-00008270: 724f 6653 7461 6765 7328 2920 2d3e 2069  rOfStages() -> i
-00008280: 6e74 3a20 2e2e 2e0d 0a20 2020 2040 6f76  nt: .....    @ov
-00008290: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-000082a0: 4765 744f 4445 3173 697a 6528 2920 2d3e  GetODE1size() ->
-000082b0: 2069 6e74 3a20 2e2e 2e0d 0a20 2020 2040   int: .....    @
-000082c0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000082d0: 6620 4765 744f 4445 3273 697a 6528 2920  f GetODE2size() 
-000082e0: 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20 2020  -> int: .....   
-000082f0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00008300: 6465 6620 4765 7453 696d 756c 6174 696f  def GetSimulatio
-00008310: 6e45 6e64 5469 6d65 2873 696d 756c 6174  nEndTime(simulat
-00008320: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-00008330: 666c 6f61 743a 202e 2e2e 0d0a 2020 2020  float: .....    
-00008340: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00008350: 6566 2047 6574 536f 6c76 6572 4e61 6d65  ef GetSolverName
-00008360: 2829 202d 3e20 7374 723a 202e 2e2e 0d0a  () -> str: .....
-00008370: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00008380: 2020 2064 6566 2047 6574 5379 7374 656d     def GetSystem
-00008390: 4d61 7373 4d61 7472 6978 2829 202d 3e20  MassMatrix() -> 
-000083a0: 4172 7261 794c 696b 653a 202e 2e2e 0d0a  ArrayLike: .....
-000083b0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-000083c0: 2020 2064 6566 2047 6574 5379 7374 656d     def GetSystem
-000083d0: 5265 7369 6475 616c 2829 202d 3e20 4172  Residual() -> Ar
-000083e0: 7261 794c 696b 653a 202e 2e2e 0d0a 2020  rayLike: .....  
-000083f0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00008400: 2064 6566 2048 6173 4175 746f 6d61 7469   def HasAutomati
-00008410: 6353 7465 7053 697a 6543 6f6e 7472 6f6c  cStepSizeControl
-00008420: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
-00008430: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
-00008440: 202d 3e20 626f 6f6c 3a20 2e2e 2e0d 0a20   -> bool: ..... 
-00008450: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00008460: 2020 6465 6620 496e 6372 6561 7365 5374    def IncreaseSt
-00008470: 6570 5369 7a65 286d 6169 6e53 7973 7465  epSize(mainSyste
-00008480: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-00008490: 7469 6e67 7329 202d 3e20 4e6f 6e65 3a20  tings) -> None: 
-000084a0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-000084b0: 6164 0d0a 2020 2020 6465 6620 496e 6974  ad..    def Init
-000084c0: 6961 6c69 7a65 536f 6c76 6572 286d 6169  ializeSolver(mai
-000084d0: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-000084e0: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-000084f0: 626f 6f6c 3a20 2e2e 2e0d 0a20 2020 2040  bool: .....    @
-00008500: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00008510: 6620 496e 6974 6961 6c69 7a65 536f 6c76  f InitializeSolv
-00008520: 6572 4461 7461 286d 6169 6e53 7973 7465  erData(mainSyste
-00008530: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
-00008540: 7469 6e67 7329 202d 3e20 4e6f 6e65 3a20  tings) -> None: 
-00008550: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00008560: 6164 0d0a 2020 2020 6465 6620 496e 6974  ad..    def Init
-00008570: 6961 6c69 7a65 536f 6c76 6572 496e 6974  ializeSolverInit
-00008580: 6961 6c43 6f6e 6469 7469 6f6e 7328 6d61  ialConditions(ma
-00008590: 696e 5379 7374 656d 2c20 7369 6d75 6c61  inSystem, simula
-000085a0: 7469 6f6e 5365 7474 696e 6773 2920 2d3e  tionSettings) ->
-000085b0: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-000085c0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-000085d0: 6566 2049 6e69 7469 616c 697a 6553 6f6c  ef InitializeSol
-000085e0: 7665 724f 7574 7075 7428 6d61 696e 5379  verOutput(mainSy
-000085f0: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
-00008600: 5365 7474 696e 6773 2920 2d3e 204e 6f6e  Settings) -> Non
-00008610: 653a 202e 2e2e 0d0a 2020 2020 406f 7665  e: .....    @ove
-00008620: 726c 6f61 640d 0a20 2020 2064 6566 2049  rload..    def I
-00008630: 6e69 7469 616c 697a 6553 6f6c 7665 7250  nitializeSolverP
-00008640: 7265 4368 6563 6b73 286d 6169 6e53 7973  reChecks(mainSys
-00008650: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
-00008660: 6574 7469 6e67 7329 202d 3e20 626f 6f6c  ettings) -> bool
-00008670: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00008680: 6c6f 6164 0d0a 2020 2020 6465 6620 496e  load..    def In
-00008690: 6974 6961 6c69 7a65 5374 6570 286d 6169  itializeStep(mai
-000086a0: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-000086b0: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-000086c0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-000086d0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000086e0: 6620 4973 5374 6174 6963 536f 6c76 6572  f IsStaticSolver
-000086f0: 2829 202d 3e20 626f 6f6c 3a20 2e2e 2e0d  () -> bool: ....
-00008700: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00008710: 2020 2020 6465 6620 4973 5665 7262 6f73      def IsVerbos
-00008720: 6543 6865 636b 286c 6576 656c 2920 2d3e  eCheck(level) ->
-00008730: 2062 6f6f 6c3a 202e 2e2e 0d0a 2020 2020   bool: .....    
-00008740: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00008750: 6566 204e 6577 746f 6e28 6d61 696e 5379  ef Newton(mainSy
-00008760: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
-00008770: 5365 7474 696e 6773 2920 2d3e 2062 6f6f  Settings) -> boo
-00008780: 6c3a 202e 2e2e 0d0a 2020 2020 406f 7665  l: .....    @ove
-00008790: 726c 6f61 640d 0a20 2020 2064 6566 2050  rload..    def P
-000087a0: 6f73 7449 6e69 7469 616c 697a 6553 6f6c  ostInitializeSol
-000087b0: 7665 7253 7065 6369 6669 6328 6d61 696e  verSpecific(main
-000087c0: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
-000087d0: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
-000087e0: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-000087f0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00008800: 2050 7265 496e 6974 6961 6c69 7a65 536f   PreInitializeSo
-00008810: 6c76 6572 5370 6563 6966 6963 286d 6169  lverSpecific(mai
-00008820: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-00008830: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-00008840: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-00008850: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00008860: 6620 5265 6475 6365 5374 6570 5369 7a65  f ReduceStepSize
-00008870: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
-00008880: 756c 6174 696f 6e53 6574 7469 6e67 732c  ulationSettings,
-00008890: 2073 6576 6572 6974 7929 202d 3e20 626f   severity) -> bo
-000088a0: 6f6c 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ol: .....    @ov
-000088b0: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-000088c0: 5365 7453 7973 7465 6d4d 6173 734d 6174  SetSystemMassMat
-000088d0: 7269 7828 7379 7374 656d 4d61 7373 4d61  rix(systemMassMa
-000088e0: 7472 6978 2920 2d3e 204e 6f6e 653a 202e  trix) -> None: .
-000088f0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-00008900: 640d 0a20 2020 2064 6566 2053 6574 5379  d..    def SetSy
-00008910: 7374 656d 5265 7369 6475 616c 2873 7973  stemResidual(sys
-00008920: 7465 6d52 6573 6964 7561 6c29 202d 3e20  temResidual) -> 
-00008930: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-00008940: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00008950: 6620 536f 6c76 6553 7465 7073 286d 6169  f SolveSteps(mai
-00008960: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
-00008970: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
-00008980: 626f 6f6c 3a20 2e2e 2e0d 0a20 2020 2040  bool: .....    @
-00008990: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-000089a0: 6620 536f 6c76 6553 7973 7465 6d28 6d61  f SolveSystem(ma
-000089b0: 696e 5379 7374 656d 2c20 7369 6d75 6c61  inSystem, simula
-000089c0: 7469 6f6e 5365 7474 696e 6773 2920 2d3e  tionSettings) ->
-000089d0: 2062 6f6f 6c3a 202e 2e2e 0d0a 2020 2020   bool: .....    
-000089e0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-000089f0: 6566 2055 7064 6174 6543 7572 7265 6e74  ef UpdateCurrent
-00008a00: 5469 6d65 286d 6169 6e53 7973 7465 6d2c  Time(mainSystem,
-00008a10: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
-00008a20: 6e67 7329 202d 3e20 4e6f 6e65 3a20 2e2e  ngs) -> None: ..
-00008a30: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00008a40: 0d0a 2020 2020 6465 6620 5665 7262 6f73  ..    def Verbos
-00008a50: 6557 7269 7465 286c 6576 656c 2c20 7374  eWrite(level, st
-00008a60: 7229 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  r) -> None: ....
-00008a70: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00008a80: 2020 2020 6465 6620 5772 6974 6543 6f6f      def WriteCoo
-00008a90: 7264 696e 6174 6573 546f 4669 6c65 286d  rdinatesToFile(m
-00008aa0: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
-00008ab0: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
-00008ac0: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-00008ad0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00008ae0: 6465 6620 5772 6974 6553 6f6c 7574 696f  def WriteSolutio
-00008af0: 6e46 696c 6548 6561 6465 7228 6d61 696e  nFileHeader(main
-00008b00: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
-00008b10: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
-00008b20: 6f6e 653a 202e 2e2e 0d0a 0d0a 0d0a 636c  one: .........cl
-00008b30: 6173 7320 5669 7375 4765 6e65 7261 6c43  ass VisuGeneralC
-00008b40: 6f6e 7461 6374 3a0d 0a20 2020 2040 6f76  ontact:..    @ov
-00008b50: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00008b60: 5265 7365 7428 7365 6c66 2920 2d3e 204e  Reset(self) -> N
-00008b70: 6f6e 653a 202e 2e2e 0d0a 0d0a 0d0a 636c  one: .........cl
-00008b80: 6173 7320 4765 6e65 7261 6c43 6f6e 7461  ass GeneralConta
-00008b90: 6374 3a0d 0a20 2020 2040 6f76 6572 6c6f  ct:..    @overlo
-00008ba0: 6164 0d0a 2020 2020 6465 6620 4765 7450  ad..    def GetP
-00008bb0: 7974 686f 6e4f 626a 6563 7428 7365 6c66  ythonObject(self
-00008bc0: 2920 2d3e 2064 6963 743a 202e 2e2e 0d0a  ) -> dict: .....
-00008bd0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00008be0: 2020 2064 6566 2052 6573 6574 2873 656c     def Reset(sel
-00008bf0: 662c 2066 7265 654d 656d 6f72 793d 5472  f, freeMemory=Tr
-00008c00: 7565 2920 2d3e 204e 6f6e 653a 202e 2e2e  ue) -> None: ...
-00008c10: 0d0a 2020 2020 6973 4163 7469 7665 3a62  ..    isActive:b
-00008c20: 6f6f 6c0d 0a20 2020 2076 6572 626f 7365  ool..    verbose
-00008c30: 4d6f 6465 3a69 6e74 0d0a 2020 2020 7669  Mode:int..    vi
-00008c40: 7375 616c 697a 6174 696f 6e3a 5669 7375  sualization:Visu
-00008c50: 4765 6e65 7261 6c43 6f6e 7461 6374 0d0a  GeneralContact..
-00008c60: 2020 2020 7265 7365 7453 6561 7263 6854      resetSearchT
-00008c70: 7265 6549 6e74 6572 7661 6c3a 696e 740d  reeInterval:int.
-00008c80: 0a20 2020 2073 7068 6572 6553 7068 6572  .    sphereSpher
-00008c90: 6543 6f6e 7461 6374 3a62 6f6f 6c0d 0a20  eContact:bool.. 
-00008ca0: 2020 2073 7068 6572 6553 7068 6572 6546     sphereSphereF
-00008cb0: 7269 6374 696f 6e52 6563 7963 6c65 3a62  rictionRecycle:b
-00008cc0: 6f6f 6c0d 0a20 2020 206d 696e 5265 6c44  ool..    minRelD
-00008cd0: 6973 7461 6e63 6553 7068 6572 6573 5472  istanceSpheresTr
-00008ce0: 6961 6e67 6c65 733a 666c 6f61 740d 0a20  iangles:float.. 
-00008cf0: 2020 2066 7269 6374 696f 6e50 726f 706f     frictionPropo
-00008d00: 7274 696f 6e61 6c5a 6f6e 653a 666c 6f61  rtionalZone:floa
-00008d10: 740d 0a20 2020 2066 7269 6374 696f 6e56  t..    frictionV
-00008d20: 656c 6f63 6974 7950 656e 616c 7479 3a66  elocityPenalty:f
-00008d30: 6c6f 6174 0d0a 2020 2020 6578 636c 7564  loat..    exclud
-00008d40: 654f 7665 726c 6170 7069 6e67 5472 6967  eOverlappingTrig
-00008d50: 5370 6865 7265 436f 6e74 6163 7473 3a62  SphereContacts:b
-00008d60: 6f6f 6c0d 0a20 2020 2065 7863 6c75 6465  ool..    exclude
-00008d70: 4475 706c 6963 6174 6564 5472 6967 5370  DuplicatedTrigSp
-00008d80: 6865 7265 436f 6e74 6163 7450 6f69 6e74  hereContactPoint
-00008d90: 733a 626f 6f6c 0d0a 2020 2020 636f 6d70  s:bool..    comp
-00008da0: 7574 6543 6f6e 7461 6374 466f 7263 6573  uteContactForces
-00008db0: 3a62 6f6f 6c0d 0a20 2020 2061 6e63 6643  :bool..    ancfC
-00008dc0: 6162 6c65 5573 6545 7861 6374 4d65 7468  ableUseExactMeth
-00008dd0: 6f64 3a62 6f6f 6c0d 0a20 2020 2061 6e63  od:bool..    anc
-00008de0: 6643 6162 6c65 4e75 6d62 6572 4f66 436f  fCableNumberOfCo
-00008df0: 6e74 6163 7453 6567 6d65 6e74 733a 696e  ntactSegments:in
-00008e00: 740d 0a20 2020 2061 6e63 6643 6162 6c65  t..    ancfCable
-00008e10: 4d65 6173 7572 696e 6753 6567 6d65 6e74  MeasuringSegment
-00008e20: 733a 696e 740d 0a20 2020 2040 6f76 6572  s:int..    @over
-00008e30: 6c6f 6164 0d0a 2020 2020 6465 6620 5365  load..    def Se
-00008e40: 7446 7269 6374 696f 6e50 6169 7269 6e67  tFrictionPairing
-00008e50: 7328 7365 6c66 2c20 6672 6963 7469 6f6e  s(self, friction
-00008e60: 5061 6972 696e 6773 3a20 4172 7261 794c  Pairings: ArrayL
-00008e70: 696b 6529 202d 3e20 4e6f 6e65 3a20 2e2e  ike) -> None: ..
-00008e80: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-00008e90: 0d0a 2020 2020 6465 6620 5365 7446 7269  ..    def SetFri
-00008ea0: 6374 696f 6e50 726f 706f 7274 696f 6e61  ctionProportiona
-00008eb0: 6c5a 6f6e 6528 7365 6c66 2c20 6672 6963  lZone(self, fric
-00008ec0: 7469 6f6e 5072 6f70 6f72 7469 6f6e 616c  tionProportional
-00008ed0: 5a6f 6e65 3a20 666c 6f61 7429 202d 3e20  Zone: float) -> 
-00008ee0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-00008ef0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00008f00: 6620 5365 7453 6561 7263 6854 7265 6543  f SetSearchTreeC
-00008f10: 656c 6c53 697a 6528 7365 6c66 2c20 6e75  ellSize(self, nu
-00008f20: 6d62 6572 4f66 4365 6c6c 733a 205b 696e  mberOfCells: [in
-00008f30: 742c 696e 742c 696e 745d 2920 2d3e 204e  t,int,int]) -> N
-00008f40: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-00008f50: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00008f60: 2053 6574 5365 6172 6368 5472 6565 426f   SetSearchTreeBo
-00008f70: 7828 7365 6c66 2c20 704d 696e 3a20 5b66  x(self, pMin: [f
-00008f80: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
-00008f90: 5d2c 2070 4d61 783a 205b 666c 6f61 742c  ], pMax: [float,
-00008fa0: 666c 6f61 742c 666c 6f61 745d 2920 2d3e  float,float]) ->
-00008fb0: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-00008fc0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00008fd0: 6566 2041 6464 5370 6865 7265 5769 7468  ef AddSphereWith
-00008fe0: 4d61 726b 6572 2873 656c 662c 206d 6172  Marker(self, mar
-00008ff0: 6b65 7249 6e64 6578 3a20 4d61 726b 6572  kerIndex: Marker
-00009000: 496e 6465 782c 2072 6164 6975 733a 2066  Index, radius: f
-00009010: 6c6f 6174 2c20 636f 6e74 6163 7453 7469  loat, contactSti
-00009020: 6666 6e65 7373 3a20 666c 6f61 742c 2063  ffness: float, c
-00009030: 6f6e 7461 6374 4461 6d70 696e 673a 2066  ontactDamping: f
-00009040: 6c6f 6174 2c20 6672 6963 7469 6f6e 4d61  loat, frictionMa
-00009050: 7465 7269 616c 496e 6465 783a 2069 6e74  terialIndex: int
-00009060: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20  ) -> int: ..... 
-00009070: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00009080: 2020 6465 6620 4164 6441 4e43 4643 6162    def AddANCFCab
-00009090: 6c65 2873 656c 662c 206f 626a 6563 7449  le(self, objectI
-000090a0: 6e64 6578 3a20 4f62 6a65 6374 496e 6465  ndex: ObjectInde
-000090b0: 782c 2068 616c 6648 6569 6768 743a 2066  x, halfHeight: f
-000090c0: 6c6f 6174 2c20 636f 6e74 6163 7453 7469  loat, contactSti
-000090d0: 6666 6e65 7373 3a20 666c 6f61 742c 2063  ffness: float, c
-000090e0: 6f6e 7461 6374 4461 6d70 696e 673a 2066  ontactDamping: f
-000090f0: 6c6f 6174 2c20 6672 6963 7469 6f6e 4d61  loat, frictionMa
-00009100: 7465 7269 616c 496e 6465 783a 2069 6e74  terialIndex: int
-00009110: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20  ) -> int: ..... 
-00009120: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00009130: 2020 6465 6620 4164 6454 7269 616e 676c    def AddTriangl
-00009140: 6573 5269 6769 6442 6f64 7942 6173 6564  esRigidBodyBased
-00009150: 2873 656c 662c 2072 6967 6964 426f 6479  (self, rigidBody
-00009160: 4d61 726b 6572 496e 6465 783a 204d 6172  MarkerIndex: Mar
-00009170: 6b65 7249 6e64 6578 2c20 636f 6e74 6163  kerIndex, contac
-00009180: 7453 7469 6666 6e65 7373 3a20 666c 6f61  tStiffness: floa
-00009190: 742c 2063 6f6e 7461 6374 4461 6d70 696e  t, contactDampin
-000091a0: 673a 2066 6c6f 6174 2c20 6672 6963 7469  g: float, fricti
-000091b0: 6f6e 4d61 7465 7269 616c 496e 6465 783a  onMaterialIndex:
-000091c0: 2069 6e74 2c20 706f 696e 744c 6973 743a   int, pointList:
-000091d0: 204c 6973 745b 5b66 6c6f 6174 2c66 6c6f   List[[float,flo
-000091e0: 6174 2c66 6c6f 6174 5d5d 2c20 7472 6961  at,float]], tria
-000091f0: 6e67 6c65 4c69 7374 3a20 4c69 7374 5b5b  ngleList: List[[
-00009200: 696e 742c 696e 742c 696e 745d 5d29 202d  int,int,int]]) -
-00009210: 3e20 696e 743a 202e 2e2e 0d0a 2020 2020  > int: .....    
-00009220: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00009230: 6566 2047 6574 4974 656d 7349 6e42 6f78  ef GetItemsInBox
-00009240: 2873 656c 662c 2070 4d69 6e3a 205b 666c  (self, pMin: [fl
-00009250: 6f61 742c 666c 6f61 742c 666c 6f61 745d  oat,float,float]
-00009260: 2c20 704d 6178 3a20 5b66 6c6f 6174 2c66  , pMax: [float,f
-00009270: 6c6f 6174 2c66 6c6f 6174 5d29 202d 3e20  loat,float]) -> 
-00009280: 556e 696f 6e5b 6469 6374 2c62 6f6f 6c5d  Union[dict,bool]
-00009290: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-000092a0: 6c6f 6164 0d0a 2020 2020 6465 6620 4765  load..    def Ge
-000092b0: 7453 7068 6572 654d 6172 6b65 7242 6173  tSphereMarkerBas
-000092c0: 6564 2873 656c 662c 206c 6f63 616c 496e  ed(self, localIn
-000092d0: 6465 783a 2069 6e74 2c20 6164 6444 6174  dex: int, addDat
-000092e0: 613a 2062 6f6f 6c29 202d 3e20 6469 6374  a: bool) -> dict
-000092f0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00009300: 6c6f 6164 0d0a 2020 2020 6465 6620 5365  load..    def Se
-00009310: 7453 7068 6572 654d 6172 6b65 7242 6173  tSphereMarkerBas
-00009320: 6564 2873 656c 662c 206c 6f63 616c 496e  ed(self, localIn
-00009330: 6465 783a 2069 6e74 2c20 636f 6e74 6163  dex: int, contac
-00009340: 7453 7469 6666 6e65 7373 3a20 666c 6f61  tStiffness: floa
-00009350: 742c 2063 6f6e 7461 6374 4461 6d70 696e  t, contactDampin
-00009360: 673a 2066 6c6f 6174 2c20 7261 6469 7573  g: float, radius
-00009370: 3a20 666c 6f61 742c 2066 7269 6374 696f  : float, frictio
-00009380: 6e4d 6174 6572 6961 6c49 6e64 6578 3a20  nMaterialIndex: 
-00009390: 696e 7429 202d 3e20 4e6f 6e65 3a20 2e2e  int) -> None: ..
-000093a0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-000093b0: 0d0a 2020 2020 6465 6620 4765 7454 7269  ..    def GetTri
-000093c0: 616e 676c 6552 6967 6964 426f 6479 4261  angleRigidBodyBa
-000093d0: 7365 6428 7365 6c66 2c20 6c6f 6361 6c49  sed(self, localI
-000093e0: 6e64 6578 3a20 696e 7429 202d 3e20 6469  ndex: int) -> di
-000093f0: 6374 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ct: .....    @ov
-00009400: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00009410: 5365 7454 7269 616e 676c 6552 6967 6964  SetTriangleRigid
-00009420: 426f 6479 4261 7365 6428 7365 6c66 2c20  BodyBased(self, 
-00009430: 6c6f 6361 6c49 6e64 6578 3a20 696e 742c  localIndex: int,
-00009440: 2070 6f69 6e74 733a 204e 4441 7272 6179   points: NDArray
-00009450: 5b53 6861 7065 3244 5b33 2c33 5d2c 2066  [Shape2D[3,3], f
-00009460: 6c6f 6174 5d2c 2063 6f6e 7461 6374 5269  loat], contactRi
-00009470: 6769 6442 6f64 7949 6e64 6578 3a20 696e  gidBodyIndex: in
-00009480: 7429 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  t) -> None: ....
-00009490: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-000094a0: 2020 2020 6465 6620 5368 6f72 7465 7374      def Shortest
-000094b0: 4469 7374 616e 6365 416c 6f6e 674c 696e  DistanceAlongLin
-000094c0: 6528 7365 6c66 2c20 7053 7461 7274 3a20  e(self, pStart: 
-000094d0: 5b66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  [float,float,flo
-000094e0: 6174 5d2c 2064 6972 6563 7469 6f6e 3a20  at], direction: 
-000094f0: 5b66 6c6f 6174 2c66 6c6f 6174 2c66 6c6f  [float,float,flo
-00009500: 6174 5d2c 206d 696e 4469 7374 616e 6365  at], minDistance
-00009510: 3a20 666c 6f61 742c 206d 6178 4469 7374  : float, maxDist
-00009520: 616e 6365 3a20 666c 6f61 742c 2061 7344  ance: float, asD
-00009530: 6963 7469 6f6e 6172 793a 2062 6f6f 6c2c  ictionary: bool,
-00009540: 2063 796c 696e 6465 7252 6164 6975 733a   cylinderRadius:
-00009550: 2066 6c6f 6174 2c20 7479 7065 496e 6465   float, typeInde
-00009560: 783a 2043 6f6e 7461 6374 5479 7065 496e  x: ContactTypeIn
-00009570: 6465 7829 202d 3e20 556e 696f 6e5b 6469  dex) -> Union[di
-00009580: 6374 2c66 6c6f 6174 5d3a 202e 2e2e 0d0a  ct,float]: .....
-00009590: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-000095a0: 2020 2064 6566 2055 7064 6174 6543 6f6e     def UpdateCon
-000095b0: 7461 6374 7328 7365 6c66 2c20 6d61 696e  tacts(self, main
-000095c0: 5379 7374 656d 3a20 4d61 696e 5379 7374  System: MainSyst
-000095d0: 656d 2920 2d3e 204e 6f6e 653a 202e 2e2e  em) -> None: ...
-000095e0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-000095f0: 0a20 2020 2064 6566 2047 6574 4163 7469  .    def GetActi
-00009600: 7665 436f 6e74 6163 7473 2873 656c 662c  veContacts(self,
-00009610: 2074 7970 6549 6e64 6578 3a20 436f 6e74   typeIndex: Cont
-00009620: 6163 7454 7970 6549 6e64 6578 2c20 6974  actTypeIndex, it
-00009630: 656d 496e 6465 783a 2069 6e74 2920 2d3e  emIndex: int) ->
-00009640: 204c 6973 745b 696e 745d 3a20 2e2e 2e0d   List[int]: ....
-00009650: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00009660: 2020 2020 6465 6620 4765 7453 7973 7465      def GetSyste
-00009670: 6d4f 4445 3252 6873 436f 6e74 6163 7446  mODE2RhsContactF
-00009680: 6f72 6365 7328 7365 6c66 2920 2d3e 204c  orces(self) -> L
-00009690: 6973 745b 666c 6f61 745d 3a20 2e2e 2e0d  ist[float]: ....
-000096a0: 0a0d 0a0d 0a63 6c61 7373 2053 7973 7465  .....class Syste
-000096b0: 6d44 6174 613a 0d0a 2020 2020 406f 7665  mData:..    @ove
-000096c0: 726c 6f61 640d 0a20 2020 2064 6566 204e  rload..    def N
-000096d0: 756d 6265 724f 664c 6f61 6473 2873 656c  umberOfLoads(sel
-000096e0: 6629 202d 3e20 696e 743a 202e 2e2e 0d0a  f) -> int: .....
-000096f0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00009700: 2020 2064 6566 204e 756d 6265 724f 664d     def NumberOfM
-00009710: 6172 6b65 7273 2873 656c 6629 202d 3e20  arkers(self) -> 
-00009720: 696e 743a 202e 2e2e 0d0a 2020 2020 406f  int: .....    @o
-00009730: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-00009740: 204e 756d 6265 724f 664e 6f64 6573 2873   NumberOfNodes(s
-00009750: 656c 6629 202d 3e20 696e 743a 202e 2e2e  elf) -> int: ...
-00009760: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00009770: 0a20 2020 2064 6566 204e 756d 6265 724f  .    def NumberO
-00009780: 664f 626a 6563 7473 2873 656c 6629 202d  fObjects(self) -
-00009790: 3e20 696e 743a 202e 2e2e 0d0a 2020 2020  > int: .....    
-000097a0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-000097b0: 6566 204e 756d 6265 724f 6653 656e 736f  ef NumberOfSenso
-000097c0: 7273 2873 656c 6629 202d 3e20 696e 743a  rs(self) -> int:
-000097d0: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-000097e0: 6f61 640d 0a20 2020 2064 6566 204f 4445  oad..    def ODE
-000097f0: 3253 697a 6528 7365 6c66 2c20 636f 6e66  2Size(self, conf
-00009800: 6967 7572 6174 696f 6e54 7970 653a 2043  igurationType: C
-00009810: 6f6e 6669 6775 7261 7469 6f6e 5479 7065  onfigurationType
-00009820: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20  ) -> int: ..... 
-00009830: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-00009840: 2020 6465 6620 4f44 4531 5369 7a65 2873    def ODE1Size(s
-00009850: 656c 662c 2063 6f6e 6669 6775 7261 7469  elf, configurati
-00009860: 6f6e 5479 7065 3d43 6f6e 6669 6775 7261  onType=Configura
-00009870: 7469 6f6e 5479 7065 2e43 7572 7265 6e74  tionType.Current
-00009880: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20  ) -> int: ..... 
-00009890: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-000098a0: 2020 6465 6620 4145 7369 7a65 2873 656c    def AEsize(sel
-000098b0: 662c 2063 6f6e 6669 6775 7261 7469 6f6e  f, configuration
-000098c0: 5479 7065 3d43 6f6e 6669 6775 7261 7469  Type=Configurati
-000098d0: 6f6e 5479 7065 2e43 7572 7265 6e74 2920  onType.Current) 
-000098e0: 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20 2020  -> int: .....   
-000098f0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00009900: 6465 6620 4461 7461 5369 7a65 2873 656c  def DataSize(sel
-00009910: 662c 2063 6f6e 6669 6775 7261 7469 6f6e  f, configuration
-00009920: 5479 7065 3d43 6f6e 6669 6775 7261 7469  Type=Configurati
-00009930: 6f6e 5479 7065 2e43 7572 7265 6e74 2920  onType.Current) 
-00009940: 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20 2020  -> int: .....   
-00009950: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00009960: 6465 6620 5379 7374 656d 5369 7a65 2873  def SystemSize(s
-00009970: 656c 662c 2063 6f6e 6669 6775 7261 7469  elf, configurati
-00009980: 6f6e 5479 7065 3d43 6f6e 6669 6775 7261  onType=Configura
-00009990: 7469 6f6e 5479 7065 2e43 7572 7265 6e74  tionType.Current
-000099a0: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20  ) -> int: ..... 
-000099b0: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-000099c0: 2020 6465 6620 4765 7454 696d 6528 7365    def GetTime(se
-000099d0: 6c66 2c20 636f 6e66 6967 7572 6174 696f  lf, configuratio
-000099e0: 6e54 7970 653d 436f 6e66 6967 7572 6174  nType=Configurat
-000099f0: 696f 6e54 7970 652e 4375 7272 656e 7429  ionType.Current)
-00009a00: 202d 3e20 666c 6f61 743a 202e 2e2e 0d0a   -> float: .....
-00009a10: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-00009a20: 2020 2064 6566 2053 6574 5469 6d65 2873     def SetTime(s
-00009a30: 656c 662c 206e 6577 5469 6d65 3a20 666c  elf, newTime: fl
-00009a40: 6f61 742c 2063 6f6e 6669 6775 7261 7469  oat, configurati
-00009a50: 6f6e 5479 7065 3a20 436f 6e66 6967 7572  onType: Configur
-00009a60: 6174 696f 6e54 7970 6529 202d 3e20 4e6f  ationType) -> No
-00009a70: 6e65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ne: .....    @ov
-00009a80: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-00009a90: 4164 644f 4445 324c 6f61 6444 6570 656e  AddODE2LoadDepen
-00009aa0: 6465 6e63 6965 7328 7365 6c66 2c20 6c6f  dencies(self, lo
-00009ab0: 6164 4e75 6d62 6572 3a20 666c 6f61 742c  adNumber: float,
-00009ac0: 2067 6c6f 6261 6c4f 4445 3263 6f6f 7264   globalODE2coord
-00009ad0: 696e 6174 6573 3a20 4c69 7374 5b69 6e74  inates: List[int
-00009ae0: 5d29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  ]) -> None: ....
-00009af0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00009b00: 2020 2020 6465 6620 496e 666f 2873 656c      def Info(sel
-00009b10: 6629 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  f) -> None: ....
-00009b20: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-00009b30: 2020 2020 6465 6620 496e 666f 4c54 4728      def InfoLTG(
-00009b40: 7365 6c66 2920 2d3e 204e 6f6e 653a 202e  self) -> None: .
-00009b50: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-00009b60: 640d 0a20 2020 2064 6566 2047 6574 4f44  d..    def GetOD
-00009b70: 4532 436f 6f72 6469 6e61 7465 7328 7365  E2Coordinates(se
-00009b80: 6c66 2c20 636f 6e66 6967 7572 6174 696f  lf, configuratio
-00009b90: 6e3a 2043 6f6e 6669 6775 7261 7469 6f6e  n: Configuration
-00009ba0: 5479 7065 2920 2d3e 204c 6973 745b 666c  Type) -> List[fl
-00009bb0: 6f61 745d 3a20 2e2e 2e0d 0a20 2020 2040  oat]: .....    @
-00009bc0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-00009bd0: 6620 5365 744f 4445 3243 6f6f 7264 696e  f SetODE2Coordin
-00009be0: 6174 6573 2873 656c 662c 2063 6f6f 7264  ates(self, coord
-00009bf0: 696e 6174 6573 3a20 4c69 7374 5b66 6c6f  inates: List[flo
-00009c00: 6174 5d2c 2063 6f6e 6669 6775 7261 7469  at], configurati
-00009c10: 6f6e 3a20 436f 6e66 6967 7572 6174 696f  on: Configuratio
-00009c20: 6e54 7970 6529 202d 3e20 4c69 7374 5b66  nType) -> List[f
-00009c30: 6c6f 6174 5d3a 202e 2e2e 0d0a 2020 2020  loat]: .....    
-00009c40: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-00009c50: 6566 2047 6574 4f44 4532 436f 6f72 6469  ef GetODE2Coordi
-00009c60: 6e61 7465 735f 7428 7365 6c66 2c20 636f  nates_t(self, co
-00009c70: 6e66 6967 7572 6174 696f 6e3a 2043 6f6e  nfiguration: Con
-00009c80: 6669 6775 7261 7469 6f6e 5479 7065 2920  figurationType) 
-00009c90: 2d3e 204c 6973 745b 666c 6f61 745d 3a20  -> List[float]: 
-00009ca0: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-00009cb0: 6164 0d0a 2020 2020 6465 6620 5365 744f  ad..    def SetO
-00009cc0: 4445 3243 6f6f 7264 696e 6174 6573 5f74  DE2Coordinates_t
-00009cd0: 2873 656c 662c 2063 6f6f 7264 696e 6174  (self, coordinat
-00009ce0: 6573 3a20 4c69 7374 5b66 6c6f 6174 5d2c  es: List[float],
-00009cf0: 2063 6f6e 6669 6775 7261 7469 6f6e 3a20   configuration: 
-00009d00: 436f 6e66 6967 7572 6174 696f 6e54 7970  ConfigurationTyp
-00009d10: 6529 202d 3e20 4c69 7374 5b66 6c6f 6174  e) -> List[float
-00009d20: 5d3a 202e 2e2e 0d0a 2020 2020 406f 7665  ]: .....    @ove
-00009d30: 726c 6f61 640d 0a20 2020 2064 6566 2047  rload..    def G
-00009d40: 6574 4f44 4532 436f 6f72 6469 6e61 7465  etODE2Coordinate
-00009d50: 735f 7474 2873 656c 662c 2063 6f6e 6669  s_tt(self, confi
-00009d60: 6775 7261 7469 6f6e 3a20 436f 6e66 6967  guration: Config
-00009d70: 7572 6174 696f 6e54 7970 6529 202d 3e20  urationType) -> 
-00009d80: 4c69 7374 5b66 6c6f 6174 5d3a 202e 2e2e  List[float]: ...
-00009d90: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-00009da0: 0a20 2020 2064 6566 2053 6574 4f44 4532  .    def SetODE2
-00009db0: 436f 6f72 6469 6e61 7465 735f 7474 2873  Coordinates_tt(s
-00009dc0: 656c 662c 2063 6f6f 7264 696e 6174 6573  elf, coordinates
-00009dd0: 3a20 4c69 7374 5b66 6c6f 6174 5d2c 2063  : List[float], c
-00009de0: 6f6e 6669 6775 7261 7469 6f6e 3a20 436f  onfiguration: Co
-00009df0: 6e66 6967 7572 6174 696f 6e54 7970 6529  nfigurationType)
-00009e00: 202d 3e20 4c69 7374 5b66 6c6f 6174 5d3a   -> List[float]:
-00009e10: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-00009e20: 6f61 640d 0a20 2020 2064 6566 2047 6574  oad..    def Get
-00009e30: 4f44 4531 436f 6f72 6469 6e61 7465 7328  ODE1Coordinates(
-00009e40: 7365 6c66 2c20 636f 6e66 6967 7572 6174  self, configurat
-00009e50: 696f 6e3a 2043 6f6e 6669 6775 7261 7469  ion: Configurati
-00009e60: 6f6e 5479 7065 2920 2d3e 204c 6973 745b  onType) -> List[
-00009e70: 666c 6f61 745d 3a20 2e2e 2e0d 0a20 2020  float]: .....   
-00009e80: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-00009e90: 6465 6620 5365 744f 4445 3143 6f6f 7264  def SetODE1Coord
-00009ea0: 696e 6174 6573 2873 656c 662c 2063 6f6f  inates(self, coo
-00009eb0: 7264 696e 6174 6573 3a20 4c69 7374 5b66  rdinates: List[f
-00009ec0: 6c6f 6174 5d2c 2063 6f6e 6669 6775 7261  loat], configura
-00009ed0: 7469 6f6e 3a20 436f 6e66 6967 7572 6174  tion: Configurat
-00009ee0: 696f 6e54 7970 6529 202d 3e20 4c69 7374  ionType) -> List
-00009ef0: 5b66 6c6f 6174 5d3a 202e 2e2e 0d0a 2020  [float]: .....  
-00009f00: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-00009f10: 2064 6566 2047 6574 4f44 4531 436f 6f72   def GetODE1Coor
-00009f20: 6469 6e61 7465 735f 7428 7365 6c66 2c20  dinates_t(self, 
-00009f30: 636f 6e66 6967 7572 6174 696f 6e3a 2043  configuration: C
-00009f40: 6f6e 6669 6775 7261 7469 6f6e 5479 7065  onfigurationType
-00009f50: 2920 2d3e 204c 6973 745b 666c 6f61 745d  ) -> List[float]
-00009f60: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-00009f70: 6c6f 6164 0d0a 2020 2020 6465 6620 5365  load..    def Se
-00009f80: 744f 4445 3143 6f6f 7264 696e 6174 6573  tODE1Coordinates
-00009f90: 5f74 2873 656c 662c 2063 6f6f 7264 696e  _t(self, coordin
-00009fa0: 6174 6573 3a20 4c69 7374 5b66 6c6f 6174  ates: List[float
-00009fb0: 5d2c 2063 6f6e 6669 6775 7261 7469 6f6e  ], configuration
-00009fc0: 3a20 436f 6e66 6967 7572 6174 696f 6e54  : ConfigurationT
-00009fd0: 7970 6529 202d 3e20 4c69 7374 5b66 6c6f  ype) -> List[flo
-00009fe0: 6174 5d3a 202e 2e2e 0d0a 2020 2020 406f  at]: .....    @o
-00009ff0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-0000a000: 2047 6574 4145 436f 6f72 6469 6e61 7465   GetAECoordinate
-0000a010: 7328 7365 6c66 2c20 636f 6e66 6967 7572  s(self, configur
-0000a020: 6174 696f 6e3a 2043 6f6e 6669 6775 7261  ation: Configura
-0000a030: 7469 6f6e 5479 7065 2920 2d3e 204c 6973  tionType) -> Lis
-0000a040: 745b 666c 6f61 745d 3a20 2e2e 2e0d 0a20  t[float]: ..... 
-0000a050: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-0000a060: 2020 6465 6620 5365 7441 4543 6f6f 7264    def SetAECoord
-0000a070: 696e 6174 6573 2873 656c 662c 2063 6f6f  inates(self, coo
-0000a080: 7264 696e 6174 6573 3a20 4c69 7374 5b66  rdinates: List[f
-0000a090: 6c6f 6174 5d2c 2063 6f6e 6669 6775 7261  loat], configura
-0000a0a0: 7469 6f6e 3a20 436f 6e66 6967 7572 6174  tion: Configurat
-0000a0b0: 696f 6e54 7970 6529 202d 3e20 4c69 7374  ionType) -> List
-0000a0c0: 5b66 6c6f 6174 5d3a 202e 2e2e 0d0a 2020  [float]: .....  
-0000a0d0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000a0e0: 2064 6566 2047 6574 4461 7461 436f 6f72   def GetDataCoor
-0000a0f0: 6469 6e61 7465 7328 7365 6c66 2c20 636f  dinates(self, co
-0000a100: 6e66 6967 7572 6174 696f 6e3a 2043 6f6e  nfiguration: Con
-0000a110: 6669 6775 7261 7469 6f6e 5479 7065 2920  figurationType) 
-0000a120: 2d3e 204c 6973 745b 666c 6f61 745d 3a20  -> List[float]: 
-0000a130: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000a140: 6164 0d0a 2020 2020 6465 6620 5365 7444  ad..    def SetD
-0000a150: 6174 6143 6f6f 7264 696e 6174 6573 2873  ataCoordinates(s
-0000a160: 656c 662c 2063 6f6f 7264 696e 6174 6573  elf, coordinates
-0000a170: 3a20 4c69 7374 5b66 6c6f 6174 5d2c 2063  : List[float], c
-0000a180: 6f6e 6669 6775 7261 7469 6f6e 3a20 436f  onfiguration: Co
-0000a190: 6e66 6967 7572 6174 696f 6e54 7970 6529  nfigurationType)
-0000a1a0: 202d 3e20 4c69 7374 5b66 6c6f 6174 5d3a   -> List[float]:
-0000a1b0: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-0000a1c0: 6f61 640d 0a20 2020 2064 6566 2047 6574  oad..    def Get
-0000a1d0: 5379 7374 656d 5374 6174 6528 7365 6c66  SystemState(self
-0000a1e0: 2c20 636f 6e66 6967 7572 6174 696f 6e3a  , configuration:
-0000a1f0: 2043 6f6e 6669 6775 7261 7469 6f6e 5479   ConfigurationTy
-0000a200: 7065 2920 2d3e 204c 6973 745b 4c69 7374  pe) -> List[List
-0000a210: 5b66 6c6f 6174 5d5d 3a20 2e2e 2e0d 0a20  [float]]: ..... 
-0000a220: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-0000a230: 2020 6465 6620 5365 7453 7973 7465 6d53    def SetSystemS
-0000a240: 7461 7465 2873 656c 662c 2073 7973 7465  tate(self, syste
-0000a250: 6d53 7461 7465 4c69 7374 3a20 4c69 7374  mStateList: List
-0000a260: 5b4c 6973 745b 666c 6f61 745d 5d2c 2063  [List[float]], c
-0000a270: 6f6e 6669 6775 7261 7469 6f6e 3a20 436f  onfiguration: Co
-0000a280: 6e66 6967 7572 6174 696f 6e54 7970 6529  nfigurationType)
-0000a290: 202d 3e20 4c69 7374 5b66 6c6f 6174 5d3a   -> List[float]:
-0000a2a0: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-0000a2b0: 6f61 640d 0a20 2020 2064 6566 2047 6574  oad..    def Get
-0000a2c0: 4f62 6a65 6374 4c54 474f 4445 3228 7365  ObjectLTGODE2(se
-0000a2d0: 6c66 2c20 6f62 6a65 6374 4e75 6d62 6572  lf, objectNumber
-0000a2e0: 3a20 696e 7429 202d 3e20 4c69 7374 5b69  : int) -> List[i
-0000a2f0: 6e74 5d3a 202e 2e2e 0d0a 2020 2020 406f  nt]: .....    @o
-0000a300: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-0000a310: 2047 6574 4f62 6a65 6374 4c54 474f 4445   GetObjectLTGODE
-0000a320: 3128 7365 6c66 2c20 6f62 6a65 6374 4e75  1(self, objectNu
-0000a330: 6d62 6572 3a20 696e 7429 202d 3e20 4c69  mber: int) -> Li
-0000a340: 7374 5b69 6e74 5d3a 202e 2e2e 0d0a 2020  st[int]: .....  
-0000a350: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000a360: 2064 6566 2047 6574 4f62 6a65 6374 4c54   def GetObjectLT
-0000a370: 4741 4528 7365 6c66 2c20 6f62 6a65 6374  GAE(self, object
-0000a380: 4e75 6d62 6572 3a20 696e 7429 202d 3e20  Number: int) -> 
-0000a390: 4c69 7374 5b69 6e74 5d3a 202e 2e2e 0d0a  List[int]: .....
-0000a3a0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000a3b0: 2020 2064 6566 2047 6574 4f62 6a65 6374     def GetObject
-0000a3c0: 4c54 4744 6174 6128 7365 6c66 2c20 6f62  LTGData(self, ob
-0000a3d0: 6a65 6374 4e75 6d62 6572 3a20 696e 7429  jectNumber: int)
-0000a3e0: 202d 3e20 4c69 7374 5b69 6e74 5d3a 202e   -> List[int]: .
-0000a3f0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000a400: 640d 0a20 2020 2064 6566 2047 6574 4e6f  d..    def GetNo
-0000a410: 6465 4c54 474f 4445 3228 7365 6c66 2c20  deLTGODE2(self, 
-0000a420: 6e6f 6465 4e75 6d62 6572 3a20 696e 7429  nodeNumber: int)
-0000a430: 202d 3e20 4c69 7374 5b69 6e74 5d3a 202e   -> List[int]: .
-0000a440: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000a450: 640d 0a20 2020 2064 6566 2047 6574 4e6f  d..    def GetNo
-0000a460: 6465 4c54 474f 4445 3128 7365 6c66 2c20  deLTGODE1(self, 
-0000a470: 6e6f 6465 4e75 6d62 6572 3a20 696e 7429  nodeNumber: int)
-0000a480: 202d 3e20 4c69 7374 5b69 6e74 5d3a 202e   -> List[int]: .
-0000a490: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000a4a0: 640d 0a20 2020 2064 6566 2047 6574 4e6f  d..    def GetNo
-0000a4b0: 6465 4c54 4741 4528 7365 6c66 2c20 6e6f  deLTGAE(self, no
-0000a4c0: 6465 4e75 6d62 6572 3a20 696e 7429 202d  deNumber: int) -
-0000a4d0: 3e20 4c69 7374 5b69 6e74 5d3a 202e 2e2e  > List[int]: ...
-0000a4e0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000a4f0: 0a20 2020 2064 6566 2047 6574 4e6f 6465  .    def GetNode
-0000a500: 4c54 4744 6174 6128 7365 6c66 2c20 6e6f  LTGData(self, no
-0000a510: 6465 4e75 6d62 6572 3a20 696e 7429 202d  deNumber: int) -
-0000a520: 3e20 4c69 7374 5b69 6e74 5d3a 202e 2e2e  > List[int]: ...
-0000a530: 0d0a 0d0a 0d0a 636c 6173 7320 4d61 696e  ......class Main
-0000a540: 5379 7374 656d 3a0d 0a20 2020 2040 6f76  System:..    @ov
-0000a550: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000a560: 4173 7365 6d62 6c65 2873 656c 6629 202d  Assemble(self) -
-0000a570: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-0000a580: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000a590: 6465 6620 4173 7365 6d62 6c65 436f 6f72  def AssembleCoor
-0000a5a0: 6469 6e61 7465 7328 7365 6c66 2920 2d3e  dinates(self) ->
-0000a5b0: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-0000a5c0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000a5d0: 6566 2041 7373 656d 626c 654c 5447 4c69  ef AssembleLTGLi
-0000a5e0: 7374 7328 7365 6c66 2920 2d3e 204e 6f6e  sts(self) -> Non
-0000a5f0: 653a 202e 2e2e 0d0a 2020 2020 406f 7665  e: .....    @ove
-0000a600: 726c 6f61 640d 0a20 2020 2064 6566 2041  rload..    def A
-0000a610: 7373 656d 626c 6549 6e69 7469 616c 697a  ssembleInitializ
-0000a620: 6553 7973 7465 6d43 6f6f 7264 696e 6174  eSystemCoordinat
-0000a630: 6573 2873 656c 6629 202d 3e20 4e6f 6e65  es(self) -> None
-0000a640: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-0000a650: 6c6f 6164 0d0a 2020 2020 6465 6620 4173  load..    def As
-0000a660: 7365 6d62 6c65 5379 7374 656d 496e 6974  sembleSystemInit
-0000a670: 6961 6c69 7a65 2873 656c 6629 202d 3e20  ialize(self) -> 
-0000a680: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-0000a690: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000a6a0: 6620 5265 7365 7428 7365 6c66 2920 2d3e  f Reset(self) ->
-0000a6b0: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-0000a6c0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000a6d0: 6566 2047 6574 5379 7374 656d 436f 6e74  ef GetSystemCont
-0000a6e0: 6169 6e65 7228 7365 6c66 2920 2d3e 2053  ainer(self) -> S
-0000a6f0: 7973 7465 6d43 6f6e 7461 696e 6572 3a20  ystemContainer: 
-0000a700: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000a710: 6164 0d0a 2020 2020 6465 6620 5761 6974  ad..    def Wait
-0000a720: 466f 7255 7365 7254 6f43 6f6e 7469 6e75  ForUserToContinu
-0000a730: 6528 7365 6c66 2c20 7072 696e 744d 6573  e(self, printMes
-0000a740: 7361 6765 3d54 7275 6529 202d 3e20 4e6f  sage=True) -> No
-0000a750: 6e65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ne: .....    @ov
-0000a760: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000a770: 5365 6e64 5265 6472 6177 5369 676e 616c  SendRedrawSignal
-0000a780: 2873 656c 6629 202d 3e20 4e6f 6e65 3a20  (self) -> None: 
-0000a790: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000a7a0: 6164 0d0a 2020 2020 6465 6620 4765 7452  ad..    def GetR
-0000a7b0: 656e 6465 7245 6e67 696e 6553 746f 7046  enderEngineStopF
-0000a7c0: 6c61 6728 7365 6c66 2920 2d3e 2062 6f6f  lag(self) -> boo
-0000a7d0: 6c3a 202e 2e2e 0d0a 2020 2020 406f 7665  l: .....    @ove
-0000a7e0: 726c 6f61 640d 0a20 2020 2064 6566 2053  rload..    def S
-0000a7f0: 6574 5265 6e64 6572 456e 6769 6e65 5374  etRenderEngineSt
-0000a800: 6f70 466c 6167 2873 656c 662c 2073 746f  opFlag(self, sto
-0000a810: 7046 6c61 673a 2062 6f6f 6c29 202d 3e20  pFlag: bool) -> 
-0000a820: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-0000a830: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000a840: 6620 4163 7469 7661 7465 5265 6e64 6572  f ActivateRender
-0000a850: 696e 6728 7365 6c66 2c20 666c 6167 3d54  ing(self, flag=T
-0000a860: 7275 6529 202d 3e20 4e6f 6e65 3a20 2e2e  rue) -> None: ..
-0000a870: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-0000a880: 0d0a 2020 2020 6465 6620 5365 7450 7265  ..    def SetPre
-0000a890: 5374 6570 5573 6572 4675 6e63 7469 6f6e  StepUserFunction
-0000a8a0: 2873 656c 662c 2076 616c 7565 3a20 4361  (self, value: Ca
-0000a8b0: 6c6c 6162 6c65 5b5b 4d61 696e 5379 7374  llable[[MainSyst
-0000a8c0: 656d 2c20 666c 6f61 745d 2c62 6f6f 6c5d  em, float],bool]
-0000a8d0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0d0a  ) -> None: .....
-0000a8e0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000a8f0: 2020 2064 6566 2047 6574 5072 6553 7465     def GetPreSte
-0000a900: 7055 7365 7246 756e 6374 696f 6e28 7365  pUserFunction(se
-0000a910: 6c66 2c20 6173 4469 6374 3a20 626f 6f6c  lf, asDict: bool
-0000a920: 2920 2d3e 2043 616c 6c61 626c 655b 5b4d  ) -> Callable[[M
-0000a930: 6169 6e53 7973 7465 6d2c 2066 6c6f 6174  ainSystem, float
-0000a940: 5d2c 626f 6f6c 5d3a 202e 2e2e 0d0a 2020  ],bool]: .....  
-0000a950: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000a960: 2064 6566 2053 6574 506f 7374 5374 6570   def SetPostStep
-0000a970: 5573 6572 4675 6e63 7469 6f6e 2873 656c  UserFunction(sel
-0000a980: 662c 2076 616c 7565 3a20 4361 6c6c 6162  f, value: Callab
-0000a990: 6c65 5b5b 4d61 696e 5379 7374 656d 2c20  le[[MainSystem, 
-0000a9a0: 666c 6f61 745d 2c62 6f6f 6c5d 2920 2d3e  float],bool]) ->
-0000a9b0: 204e 6f6e 653a 202e 2e2e 0d0a 2020 2020   None: .....    
-0000a9c0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000a9d0: 6566 2047 6574 506f 7374 5374 6570 5573  ef GetPostStepUs
-0000a9e0: 6572 4675 6e63 7469 6f6e 2873 656c 662c  erFunction(self,
-0000a9f0: 2061 7344 6963 743a 2062 6f6f 6c29 202d   asDict: bool) -
-0000aa00: 3e20 4361 6c6c 6162 6c65 5b5b 4d61 696e  > Callable[[Main
-0000aa10: 5379 7374 656d 2c20 666c 6f61 745d 2c62  System, float],b
-0000aa20: 6f6f 6c5d 3a20 2e2e 2e0d 0a20 2020 2040  ool]: .....    @
-0000aa30: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000aa40: 6620 5365 7450 6f73 744e 6577 746f 6e55  f SetPostNewtonU
-0000aa50: 7365 7246 756e 6374 696f 6e28 7365 6c66  serFunction(self
-0000aa60: 2c20 7661 6c75 653a 2043 616c 6c61 626c  , value: Callabl
-0000aa70: 655b 5b4d 6169 6e53 7973 7465 6d2c 2066  e[[MainSystem, f
-0000aa80: 6c6f 6174 5d2c 5b66 6c6f 6174 2c66 6c6f  loat],[float,flo
-0000aa90: 6174 5d5d 2920 2d3e 204e 6f6e 653a 202e  at]]) -> None: .
-0000aaa0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000aab0: 640d 0a20 2020 2064 6566 2047 6574 506f  d..    def GetPo
-0000aac0: 7374 4e65 7774 6f6e 5573 6572 4675 6e63  stNewtonUserFunc
-0000aad0: 7469 6f6e 2873 656c 662c 2061 7344 6963  tion(self, asDic
-0000aae0: 743a 2062 6f6f 6c29 202d 3e20 4361 6c6c  t: bool) -> Call
-0000aaf0: 6162 6c65 5b5b 4d61 696e 5379 7374 656d  able[[MainSystem
-0000ab00: 2c20 666c 6f61 745d 2c62 6f6f 6c5d 3a20  , float],bool]: 
-0000ab10: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000ab20: 6164 0d0a 2020 2020 6465 6620 4164 6447  ad..    def AddG
-0000ab30: 656e 6572 616c 436f 6e74 6163 7428 7365  eneralContact(se
-0000ab40: 6c66 2920 2d3e 2047 656e 6572 616c 436f  lf) -> GeneralCo
-0000ab50: 6e74 6163 743a 202e 2e2e 0d0a 2020 2020  ntact: .....    
-0000ab60: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000ab70: 6566 2047 6574 4765 6e65 7261 6c43 6f6e  ef GetGeneralCon
-0000ab80: 7461 6374 2873 656c 662c 2067 656e 6572  tact(self, gener
-0000ab90: 616c 436f 6e74 6163 744e 756d 6265 723a  alContactNumber:
-0000aba0: 2069 6e74 2920 2d3e 2047 656e 6572 616c   int) -> General
-0000abb0: 436f 6e74 6163 743a 202e 2e2e 0d0a 2020  Contact: .....  
-0000abc0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000abd0: 2064 6566 2044 656c 6574 6547 656e 6572   def DeleteGener
-0000abe0: 616c 436f 6e74 6163 7428 7365 6c66 2c20  alContact(self, 
-0000abf0: 6765 6e65 7261 6c43 6f6e 7461 6374 4e75  generalContactNu
-0000ac00: 6d62 6572 3a20 696e 7429 202d 3e20 4e6f  mber: int) -> No
-0000ac10: 6e65 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ne: .....    @ov
-0000ac20: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000ac30: 4e75 6d62 6572 4f66 4765 6e65 7261 6c43  NumberOfGeneralC
-0000ac40: 6f6e 7461 6374 7328 7365 6c66 2920 2d3e  ontacts(self) ->
-0000ac50: 2069 6e74 3a20 2e2e 2e0d 0a20 2020 2040   int: .....    @
-0000ac60: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000ac70: 6620 4765 7441 7661 696c 6162 6c65 4661  f GetAvailableFa
-0000ac80: 6374 6f72 7949 7465 6d73 2873 656c 6629  ctoryItems(self)
-0000ac90: 202d 3e20 6469 6374 3a20 2e2e 2e0d 0a20   -> dict: ..... 
-0000aca0: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-0000acb0: 2020 6465 6620 4765 7444 6963 7469 6f6e    def GetDiction
-0000acc0: 6172 7928 7365 6c66 2920 2d3e 2064 6963  ary(self) -> dic
-0000acd0: 743a 202e 2e2e 0d0a 2020 2020 406f 7665  t: .....    @ove
-0000ace0: 726c 6f61 640d 0a20 2020 2064 6566 2053  rload..    def S
-0000acf0: 6574 4469 6374 696f 6e61 7279 2873 656c  etDictionary(sel
-0000ad00: 662c 2073 7973 7465 6d44 6963 743a 2064  f, systemDict: d
-0000ad10: 6963 7429 202d 3e20 4e6f 6e65 3a20 2e2e  ict) -> None: ..
-0000ad20: 2e0d 0a20 2020 2073 7973 7465 6d49 7343  ...    systemIsC
-0000ad30: 6f6e 7369 7374 656e 743a 626f 6f6c 0d0a  onsistent:bool..
-0000ad40: 2020 2020 696e 7465 7261 6374 6976 654d      interactiveM
-0000ad50: 6f64 653a 626f 6f6c 0d0a 2020 2020 7661  ode:bool..    va
-0000ad60: 7269 6162 6c65 733a 6469 6374 0d0a 2020  riables:dict..  
-0000ad70: 2020 7379 733a 6469 6374 0d0a 2020 2020    sys:dict..    
-0000ad80: 736f 6c76 6572 5369 676e 616c 4a61 636f  solverSignalJaco
-0000ad90: 6269 616e 5570 6461 7465 3a62 6f6f 6c0d  bianUpdate:bool.
-0000ada0: 0a20 2020 2073 7973 7465 6d44 6174 613a  .    systemData:
-0000adb0: 5379 7374 656d 4461 7461 0d0a 2020 2020  SystemData..    
-0000adc0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000add0: 6566 2041 6464 4e6f 6465 2873 656c 662c  ef AddNode(self,
-0000ade0: 2070 794f 626a 6563 743a 2064 6963 7429   pyObject: dict)
-0000adf0: 202d 3e20 4e6f 6465 496e 6465 783a 202e   -> NodeIndex: .
-0000ae00: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000ae10: 640d 0a20 2020 2064 6566 2047 6574 4e6f  d..    def GetNo
-0000ae20: 6465 4e75 6d62 6572 2873 656c 662c 206e  deNumber(self, n
-0000ae30: 6f64 654e 616d 653a 2073 7472 2920 2d3e  odeName: str) ->
-0000ae40: 204e 6f64 6549 6e64 6578 3a20 2e2e 2e0d   NodeIndex: ....
-0000ae50: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000ae60: 2020 2020 6465 6620 4765 744e 6f64 6528      def GetNode(
-0000ae70: 7365 6c66 2c20 6e6f 6465 4e75 6d62 6572  self, nodeNumber
-0000ae80: 3a20 4e6f 6465 496e 6465 7829 202d 3e20  : NodeIndex) -> 
-0000ae90: 6469 6374 3a20 2e2e 2e0d 0a20 2020 2040  dict: .....    @
-0000aea0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000aeb0: 6620 4d6f 6469 6679 4e6f 6465 2873 656c  f ModifyNode(sel
-0000aec0: 662c 206e 6f64 654e 756d 6265 723a 204e  f, nodeNumber: N
-0000aed0: 6f64 6549 6e64 6578 2c20 6e6f 6465 4469  odeIndex, nodeDi
-0000aee0: 6374 3a20 6469 6374 2920 2d3e 204e 6f6e  ct: dict) -> Non
-0000aef0: 653a 202e 2e2e 0d0a 2020 2020 406f 7665  e: .....    @ove
-0000af00: 726c 6f61 640d 0a20 2020 2064 6566 2047  rload..    def G
-0000af10: 6574 4e6f 6465 4465 6661 756c 7473 2873  etNodeDefaults(s
-0000af20: 656c 662c 2074 7970 654e 616d 653a 2073  elf, typeName: s
-0000af30: 7472 2920 2d3e 2064 6963 743a 202e 2e2e  tr) -> dict: ...
-0000af40: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000af50: 0a20 2020 2064 6566 2047 6574 4e6f 6465  .    def GetNode
-0000af60: 4f75 7470 7574 2873 656c 662c 206e 6f64  Output(self, nod
-0000af70: 654e 756d 6265 723a 204e 6f64 6549 6e64  eNumber: NodeInd
-0000af80: 6578 2c20 7661 7269 6162 6c65 5479 7065  ex, variableType
-0000af90: 3a20 4f75 7470 7574 5661 7269 6162 6c65  : OutputVariable
-0000afa0: 5479 7065 2c20 636f 6e66 6967 7572 6174  Type, configurat
-0000afb0: 696f 6e3a 2043 6f6e 6669 6775 7261 7469  ion: Configurati
-0000afc0: 6f6e 5479 7065 2920 2d3e 204c 6973 745b  onType) -> List[
-0000afd0: 666c 6f61 745d 3a20 2e2e 2e0d 0a20 2020  float]: .....   
-0000afe0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000aff0: 6465 6620 4765 744e 6f64 654f 4445 3249  def GetNodeODE2I
-0000b000: 6e64 6578 2873 656c 662c 206e 6f64 654e  ndex(self, nodeN
-0000b010: 756d 6265 723a 204e 6f64 6549 6e64 6578  umber: NodeIndex
-0000b020: 2920 2d3e 2069 6e74 3a20 2e2e 2e0d 0a20  ) -> int: ..... 
-0000b030: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-0000b040: 2020 6465 6620 4765 744e 6f64 654f 4445    def GetNodeODE
-0000b050: 3149 6e64 6578 2873 656c 662c 206e 6f64  1Index(self, nod
-0000b060: 654e 756d 6265 723a 204e 6f64 6549 6e64  eNumber: NodeInd
-0000b070: 6578 2920 2d3e 2069 6e74 3a20 2e2e 2e0d  ex) -> int: ....
-0000b080: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000b090: 2020 2020 6465 6620 4765 744e 6f64 6541      def GetNodeA
-0000b0a0: 4549 6e64 6578 2873 656c 662c 206e 6f64  EIndex(self, nod
-0000b0b0: 654e 756d 6265 723a 204e 6f64 6549 6e64  eNumber: NodeInd
-0000b0c0: 6578 2920 2d3e 2069 6e74 3a20 2e2e 2e0d  ex) -> int: ....
-0000b0d0: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000b0e0: 2020 2020 6465 6620 4765 744e 6f64 6550      def GetNodeP
-0000b0f0: 6172 616d 6574 6572 2873 656c 662c 206e  arameter(self, n
-0000b100: 6f64 654e 756d 6265 723a 204e 6f64 6549  odeNumber: NodeI
-0000b110: 6e64 6578 2c20 7061 7261 6d65 7465 724e  ndex, parameterN
-0000b120: 616d 653a 2073 7472 2920 2d3e 2041 6e79  ame: str) -> Any
-0000b130: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-0000b140: 6c6f 6164 0d0a 2020 2020 6465 6620 5365  load..    def Se
-0000b150: 744e 6f64 6550 6172 616d 6574 6572 2873  tNodeParameter(s
-0000b160: 656c 662c 206e 6f64 654e 756d 6265 723a  elf, nodeNumber:
-0000b170: 204e 6f64 6549 6e64 6578 2c20 7061 7261   NodeIndex, para
-0000b180: 6d65 7465 724e 616d 653a 2073 7472 2c20  meterName: str, 
-0000b190: 7661 6c75 653a 2041 6e79 2920 2d3e 204e  value: Any) -> N
-0000b1a0: 6f6e 653a 202e 2e2e 0d0a 2020 2020 406f  one: .....    @o
-0000b1b0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-0000b1c0: 2041 6464 4f62 6a65 6374 2873 656c 662c   AddObject(self,
-0000b1d0: 2070 794f 626a 6563 743a 2064 6963 7429   pyObject: dict)
-0000b1e0: 202d 3e20 4f62 6a65 6374 496e 6465 783a   -> ObjectIndex:
-0000b1f0: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-0000b200: 6f61 640d 0a20 2020 2064 6566 2047 6574  oad..    def Get
-0000b210: 4f62 6a65 6374 4e75 6d62 6572 2873 656c  ObjectNumber(sel
-0000b220: 662c 206f 626a 6563 744e 616d 653a 2073  f, objectName: s
-0000b230: 7472 2920 2d3e 204f 626a 6563 7449 6e64  tr) -> ObjectInd
-0000b240: 6578 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ex: .....    @ov
-0000b250: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000b260: 4765 744f 626a 6563 7428 7365 6c66 2c20  GetObject(self, 
-0000b270: 6f62 6a65 6374 4e75 6d62 6572 3a20 4f62  objectNumber: Ob
-0000b280: 6a65 6374 496e 6465 782c 2061 6464 4772  jectIndex, addGr
-0000b290: 6170 6869 6373 4461 7461 3d46 616c 7365  aphicsData=False
-0000b2a0: 2920 2d3e 2064 6963 743a 202e 2e2e 0d0a  ) -> dict: .....
-0000b2b0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000b2c0: 2020 2064 6566 204d 6f64 6966 794f 626a     def ModifyObj
-0000b2d0: 6563 7428 7365 6c66 2c20 6f62 6a65 6374  ect(self, object
-0000b2e0: 4e75 6d62 6572 3a20 4f62 6a65 6374 496e  Number: ObjectIn
-0000b2f0: 6465 782c 206f 626a 6563 7444 6963 743a  dex, objectDict:
-0000b300: 2064 6963 7429 202d 3e20 4e6f 6e65 3a20   dict) -> None: 
-0000b310: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000b320: 6164 0d0a 2020 2020 6465 6620 4765 744f  ad..    def GetO
-0000b330: 626a 6563 7444 6566 6175 6c74 7328 7365  bjectDefaults(se
-0000b340: 6c66 2c20 7479 7065 4e61 6d65 3a20 7374  lf, typeName: st
-0000b350: 7229 202d 3e20 6469 6374 3a20 2e2e 2e0d  r) -> dict: ....
-0000b360: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000b370: 2020 2020 6465 6620 4765 744f 626a 6563      def GetObjec
-0000b380: 744f 7574 7075 7428 7365 6c66 2c20 6f62  tOutput(self, ob
-0000b390: 6a65 6374 4e75 6d62 6572 3a20 4f62 6a65  jectNumber: Obje
-0000b3a0: 6374 496e 6465 782c 2076 6172 6961 626c  ctIndex, variabl
-0000b3b0: 6554 7970 653a 204f 7574 7075 7456 6172  eType: OutputVar
-0000b3c0: 6961 626c 6554 7970 652c 2063 6f6e 6669  iableType, confi
-0000b3d0: 6775 7261 7469 6f6e 3a20 436f 6e66 6967  guration: Config
-0000b3e0: 7572 6174 696f 6e54 7970 6529 202d 3e20  urationType) -> 
-0000b3f0: 4c69 7374 5b66 6c6f 6174 5d3a 202e 2e2e  List[float]: ...
-0000b400: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000b410: 0a20 2020 2064 6566 2047 6574 4f62 6a65  .    def GetObje
-0000b420: 6374 4f75 7470 7574 426f 6479 2873 656c  ctOutputBody(sel
-0000b430: 662c 206f 626a 6563 744e 756d 6265 723a  f, objectNumber:
-0000b440: 204f 626a 6563 7449 6e64 6578 2c20 7661   ObjectIndex, va
-0000b450: 7269 6162 6c65 5479 7065 3a20 4f75 7470  riableType: Outp
-0000b460: 7574 5661 7269 6162 6c65 5479 7065 2c20  utVariableType, 
-0000b470: 6c6f 6361 6c50 6f73 6974 696f 6e3a 205b  localPosition: [
-0000b480: 666c 6f61 742c 666c 6f61 742c 666c 6f61  float,float,floa
-0000b490: 745d 2c20 636f 6e66 6967 7572 6174 696f  t], configuratio
-0000b4a0: 6e3a 2043 6f6e 6669 6775 7261 7469 6f6e  n: Configuration
-0000b4b0: 5479 7065 2920 2d3e 204c 6973 745b 666c  Type) -> List[fl
-0000b4c0: 6f61 745d 3a20 2e2e 2e0d 0a20 2020 2040  oat]: .....    @
-0000b4d0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000b4e0: 6620 4765 744f 626a 6563 744f 7574 7075  f GetObjectOutpu
-0000b4f0: 7453 7570 6572 456c 656d 656e 7428 7365  tSuperElement(se
-0000b500: 6c66 2c20 6f62 6a65 6374 4e75 6d62 6572  lf, objectNumber
-0000b510: 3a20 4f62 6a65 6374 496e 6465 782c 2076  : ObjectIndex, v
-0000b520: 6172 6961 626c 6554 7970 653a 204f 7574  ariableType: Out
-0000b530: 7075 7456 6172 6961 626c 6554 7970 652c  putVariableType,
-0000b540: 206d 6573 684e 6f64 654e 756d 6265 723a   meshNodeNumber:
-0000b550: 2069 6e74 2c20 636f 6e66 6967 7572 6174   int, configurat
-0000b560: 696f 6e3a 2043 6f6e 6669 6775 7261 7469  ion: Configurati
-0000b570: 6f6e 5479 7065 2920 2d3e 204c 6973 745b  onType) -> List[
-0000b580: 666c 6f61 745d 3a20 2e2e 2e0d 0a20 2020  float]: .....   
-0000b590: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000b5a0: 6465 6620 4765 744f 626a 6563 7450 6172  def GetObjectPar
-0000b5b0: 616d 6574 6572 2873 656c 662c 206f 626a  ameter(self, obj
-0000b5c0: 6563 744e 756d 6265 723a 204f 626a 6563  ectNumber: Objec
-0000b5d0: 7449 6e64 6578 2c20 7061 7261 6d65 7465  tIndex, paramete
-0000b5e0: 724e 616d 653a 2073 7472 2920 2d3e 2041  rName: str) -> A
-0000b5f0: 6e79 3a20 2e2e 2e0d 0a20 2020 2040 6f76  ny: .....    @ov
-0000b600: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000b610: 5365 744f 626a 6563 7450 6172 616d 6574  SetObjectParamet
-0000b620: 6572 2873 656c 662c 206f 626a 6563 744e  er(self, objectN
-0000b630: 756d 6265 723a 204f 626a 6563 7449 6e64  umber: ObjectInd
-0000b640: 6578 2c20 7061 7261 6d65 7465 724e 616d  ex, parameterNam
-0000b650: 653a 2073 7472 2c20 7661 6c75 653a 2041  e: str, value: A
-0000b660: 6e79 2920 2d3e 204e 6f6e 653a 202e 2e2e  ny) -> None: ...
-0000b670: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000b680: 0a20 2020 2064 6566 2041 6464 4d61 726b  .    def AddMark
-0000b690: 6572 2873 656c 662c 2070 794f 626a 6563  er(self, pyObjec
-0000b6a0: 743a 2064 6963 7429 202d 3e20 4d61 726b  t: dict) -> Mark
-0000b6b0: 6572 496e 6465 783a 202e 2e2e 0d0a 2020  erIndex: .....  
-0000b6c0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000b6d0: 2064 6566 2047 6574 4d61 726b 6572 4e75   def GetMarkerNu
-0000b6e0: 6d62 6572 2873 656c 662c 206d 6172 6b65  mber(self, marke
-0000b6f0: 724e 616d 653a 2073 7472 2920 2d3e 204d  rName: str) -> M
-0000b700: 6172 6b65 7249 6e64 6578 3a20 2e2e 2e0d  arkerIndex: ....
-0000b710: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000b720: 2020 2020 6465 6620 4765 744d 6172 6b65      def GetMarke
-0000b730: 7228 7365 6c66 2c20 6d61 726b 6572 4e75  r(self, markerNu
-0000b740: 6d62 6572 3a20 4d61 726b 6572 496e 6465  mber: MarkerInde
-0000b750: 7829 202d 3e20 6469 6374 3a20 2e2e 2e0d  x) -> dict: ....
-0000b760: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000b770: 2020 2020 6465 6620 4d6f 6469 6679 4d61      def ModifyMa
-0000b780: 726b 6572 2873 656c 662c 206d 6172 6b65  rker(self, marke
-0000b790: 724e 756d 6265 723a 204d 6172 6b65 7249  rNumber: MarkerI
-0000b7a0: 6e64 6578 2c20 6d61 726b 6572 4469 6374  ndex, markerDict
-0000b7b0: 3a20 6469 6374 2920 2d3e 204e 6f6e 653a  : dict) -> None:
-0000b7c0: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-0000b7d0: 6f61 640d 0a20 2020 2064 6566 2047 6574  oad..    def Get
-0000b7e0: 4d61 726b 6572 4465 6661 756c 7473 2873  MarkerDefaults(s
-0000b7f0: 656c 662c 2074 7970 654e 616d 653a 2073  elf, typeName: s
-0000b800: 7472 2920 2d3e 2064 6963 743a 202e 2e2e  tr) -> dict: ...
-0000b810: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000b820: 0a20 2020 2064 6566 2047 6574 4d61 726b  .    def GetMark
-0000b830: 6572 5061 7261 6d65 7465 7228 7365 6c66  erParameter(self
-0000b840: 2c20 6d61 726b 6572 4e75 6d62 6572 3a20  , markerNumber: 
-0000b850: 4d61 726b 6572 496e 6465 782c 2070 6172  MarkerIndex, par
-0000b860: 616d 6574 6572 4e61 6d65 3a20 7374 7229  ameterName: str)
-0000b870: 202d 3e20 416e 793a 202e 2e2e 0d0a 2020   -> Any: .....  
-0000b880: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000b890: 2064 6566 2053 6574 4d61 726b 6572 5061   def SetMarkerPa
-0000b8a0: 7261 6d65 7465 7228 7365 6c66 2c20 6d61  rameter(self, ma
-0000b8b0: 726b 6572 4e75 6d62 6572 3a20 4d61 726b  rkerNumber: Mark
-0000b8c0: 6572 496e 6465 782c 2070 6172 616d 6574  erIndex, paramet
-0000b8d0: 6572 4e61 6d65 3a20 7374 722c 2076 616c  erName: str, val
-0000b8e0: 7565 3a20 416e 7929 202d 3e20 4e6f 6e65  ue: Any) -> None
-0000b8f0: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-0000b900: 6c6f 6164 0d0a 2020 2020 6465 6620 4765  load..    def Ge
-0000b910: 744d 6172 6b65 724f 7574 7075 7428 7365  tMarkerOutput(se
-0000b920: 6c66 2c20 6d61 726b 6572 4e75 6d62 6572  lf, markerNumber
-0000b930: 3a20 4d61 726b 6572 496e 6465 782c 2076  : MarkerIndex, v
-0000b940: 6172 6961 626c 6554 7970 653a 204f 7574  ariableType: Out
-0000b950: 7075 7456 6172 6961 626c 6554 7970 652c  putVariableType,
-0000b960: 2063 6f6e 6669 6775 7261 7469 6f6e 3a20   configuration: 
-0000b970: 436f 6e66 6967 7572 6174 696f 6e54 7970  ConfigurationTyp
-0000b980: 6529 202d 3e20 4c69 7374 5b66 6c6f 6174  e) -> List[float
-0000b990: 5d3a 202e 2e2e 0d0a 2020 2020 406f 7665  ]: .....    @ove
-0000b9a0: 726c 6f61 640d 0a20 2020 2064 6566 2041  rload..    def A
-0000b9b0: 6464 4c6f 6164 2873 656c 662c 2070 794f  ddLoad(self, pyO
-0000b9c0: 626a 6563 743a 2064 6963 7429 202d 3e20  bject: dict) -> 
-0000b9d0: 4c6f 6164 496e 6465 783a 202e 2e2e 0d0a  LoadIndex: .....
-0000b9e0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000b9f0: 2020 2064 6566 2047 6574 4c6f 6164 4e75     def GetLoadNu
-0000ba00: 6d62 6572 2873 656c 662c 206c 6f61 644e  mber(self, loadN
-0000ba10: 616d 653a 2073 7472 2920 2d3e 204c 6f61  ame: str) -> Loa
-0000ba20: 6449 6e64 6578 3a20 2e2e 2e0d 0a20 2020  dIndex: .....   
-0000ba30: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000ba40: 6465 6620 4765 744c 6f61 6428 7365 6c66  def GetLoad(self
-0000ba50: 2c20 6c6f 6164 4e75 6d62 6572 3a20 4c6f  , loadNumber: Lo
-0000ba60: 6164 496e 6465 7829 202d 3e20 6469 6374  adIndex) -> dict
-0000ba70: 3a20 2e2e 2e0d 0a20 2020 2040 6f76 6572  : .....    @over
-0000ba80: 6c6f 6164 0d0a 2020 2020 6465 6620 4d6f  load..    def Mo
-0000ba90: 6469 6679 4c6f 6164 2873 656c 662c 206c  difyLoad(self, l
-0000baa0: 6f61 644e 756d 6265 723a 204c 6f61 6449  oadNumber: LoadI
-0000bab0: 6e64 6578 2c20 6c6f 6164 4469 6374 3a20  ndex, loadDict: 
-0000bac0: 6469 6374 2920 2d3e 204e 6f6e 653a 202e  dict) -> None: .
-0000bad0: 2e2e 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000bae0: 640d 0a20 2020 2064 6566 2047 6574 4c6f  d..    def GetLo
-0000baf0: 6164 4465 6661 756c 7473 2873 656c 662c  adDefaults(self,
-0000bb00: 2074 7970 654e 616d 653a 2073 7472 2920   typeName: str) 
-0000bb10: 2d3e 2064 6963 743a 202e 2e2e 0d0a 2020  -> dict: .....  
-0000bb20: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000bb30: 2064 6566 2047 6574 4c6f 6164 5661 6c75   def GetLoadValu
-0000bb40: 6573 2873 656c 662c 206c 6f61 644e 756d  es(self, loadNum
-0000bb50: 6265 723a 204c 6f61 6449 6e64 6578 2920  ber: LoadIndex) 
-0000bb60: 2d3e 204c 6973 745b 666c 6f61 745d 3a20  -> List[float]: 
-0000bb70: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000bb80: 6164 0d0a 2020 2020 6465 6620 4765 744c  ad..    def GetL
-0000bb90: 6f61 6450 6172 616d 6574 6572 2873 656c  oadParameter(sel
-0000bba0: 662c 206c 6f61 644e 756d 6265 723a 204c  f, loadNumber: L
-0000bbb0: 6f61 6449 6e64 6578 2c20 7061 7261 6d65  oadIndex, parame
-0000bbc0: 7465 724e 616d 653a 2073 7472 2920 2d3e  terName: str) ->
-0000bbd0: 2041 6e79 3a20 2e2e 2e0d 0a20 2020 2040   Any: .....    @
-0000bbe0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000bbf0: 6620 5365 744c 6f61 6450 6172 616d 6574  f SetLoadParamet
-0000bc00: 6572 2873 656c 662c 206c 6f61 644e 756d  er(self, loadNum
-0000bc10: 6265 723a 204c 6f61 6449 6e64 6578 2c20  ber: LoadIndex, 
-0000bc20: 7061 7261 6d65 7465 724e 616d 653a 2073  parameterName: s
-0000bc30: 7472 2c20 7661 6c75 653a 2041 6e79 2920  tr, value: Any) 
-0000bc40: 2d3e 204e 6f6e 653a 202e 2e2e 0d0a 2020  -> None: .....  
-0000bc50: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000bc60: 2064 6566 2041 6464 5365 6e73 6f72 2873   def AddSensor(s
-0000bc70: 656c 662c 2070 794f 626a 6563 743a 2064  elf, pyObject: d
-0000bc80: 6963 7429 202d 3e20 5365 6e73 6f72 496e  ict) -> SensorIn
-0000bc90: 6465 783a 202e 2e2e 0d0a 2020 2020 406f  dex: .....    @o
-0000bca0: 7665 726c 6f61 640d 0a20 2020 2064 6566  verload..    def
-0000bcb0: 2047 6574 5365 6e73 6f72 4e75 6d62 6572   GetSensorNumber
-0000bcc0: 2873 656c 662c 2073 656e 736f 724e 616d  (self, sensorNam
-0000bcd0: 653a 2073 7472 2920 2d3e 2053 656e 736f  e: str) -> Senso
-0000bce0: 7249 6e64 6578 3a20 2e2e 2e0d 0a20 2020  rIndex: .....   
-0000bcf0: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000bd00: 6465 6620 4765 7453 656e 736f 7228 7365  def GetSensor(se
-0000bd10: 6c66 2c20 7365 6e73 6f72 4e75 6d62 6572  lf, sensorNumber
-0000bd20: 3a20 5365 6e73 6f72 496e 6465 7829 202d  : SensorIndex) -
-0000bd30: 3e20 6469 6374 3a20 2e2e 2e0d 0a20 2020  > dict: .....   
-0000bd40: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000bd50: 6465 6620 4d6f 6469 6679 5365 6e73 6f72  def ModifySensor
-0000bd60: 2873 656c 662c 2073 656e 736f 724e 756d  (self, sensorNum
-0000bd70: 6265 723a 2053 656e 736f 7249 6e64 6578  ber: SensorIndex
-0000bd80: 2c20 7365 6e73 6f72 4469 6374 3a20 6469  , sensorDict: di
-0000bd90: 6374 2920 2d3e 204e 6f6e 653a 202e 2e2e  ct) -> None: ...
-0000bda0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000bdb0: 0a20 2020 2064 6566 2047 6574 5365 6e73  .    def GetSens
-0000bdc0: 6f72 4465 6661 756c 7473 2873 656c 662c  orDefaults(self,
-0000bdd0: 2074 7970 654e 616d 653a 2073 7472 2920   typeName: str) 
-0000bde0: 2d3e 2064 6963 743a 202e 2e2e 0d0a 2020  -> dict: .....  
-0000bdf0: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000be00: 2064 6566 2047 6574 5365 6e73 6f72 5661   def GetSensorVa
-0000be10: 6c75 6573 2873 656c 662c 2073 656e 736f  lues(self, senso
-0000be20: 724e 756d 6265 723a 2053 656e 736f 7249  rNumber: SensorI
-0000be30: 6e64 6578 2c20 636f 6e66 6967 7572 6174  ndex, configurat
-0000be40: 696f 6e3a 2043 6f6e 6669 6775 7261 7469  ion: Configurati
-0000be50: 6f6e 5479 7065 2920 2d3e 204c 6973 745b  onType) -> List[
-0000be60: 666c 6f61 745d 3a20 2e2e 2e0d 0a20 2020  float]: .....   
-0000be70: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000be80: 6465 6620 4765 7453 656e 736f 7253 746f  def GetSensorSto
-0000be90: 7265 6444 6174 6128 7365 6c66 2c20 7365  redData(self, se
-0000bea0: 6e73 6f72 4e75 6d62 6572 3a20 5365 6e73  nsorNumber: Sens
-0000beb0: 6f72 496e 6465 7829 202d 3e20 4172 7261  orIndex) -> Arra
-0000bec0: 794c 696b 653a 202e 2e2e 0d0a 2020 2020  yLike: .....    
-0000bed0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000bee0: 6566 2047 6574 5365 6e73 6f72 5061 7261  ef GetSensorPara
-0000bef0: 6d65 7465 7228 7365 6c66 2c20 7365 6e73  meter(self, sens
-0000bf00: 6f72 4e75 6d62 6572 3a20 5365 6e73 6f72  orNumber: Sensor
-0000bf10: 496e 6465 782c 2070 6172 616d 6574 6572  Index, parameter
-0000bf20: 4e61 6d65 3a20 7374 7229 202d 3e20 416e  Name: str) -> An
-0000bf30: 793a 202e 2e2e 0d0a 2020 2020 406f 7665  y: .....    @ove
-0000bf40: 726c 6f61 640d 0a20 2020 2064 6566 2053  rload..    def S
-0000bf50: 6574 5365 6e73 6f72 5061 7261 6d65 7465  etSensorParamete
-0000bf60: 7228 7365 6c66 2c20 7365 6e73 6f72 4e75  r(self, sensorNu
-0000bf70: 6d62 6572 3a20 5365 6e73 6f72 496e 6465  mber: SensorInde
-0000bf80: 782c 2070 6172 616d 6574 6572 4e61 6d65  x, parameterName
-0000bf90: 3a20 7374 722c 2076 616c 7565 3a20 416e  : str, value: An
-0000bfa0: 7929 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  y) -> None: ....
-0000bfb0: 0a0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-0000bfc0: 0d0a 2020 2020 6465 6620 536f 6c75 7469  ..    def Soluti
-0000bfd0: 6f6e 5669 6577 6572 2873 656c 662c 2073  onViewer(self, s
-0000bfe0: 6f6c 7574 696f 6e3d 4e6f 6e65 2c20 726f  olution=None, ro
-0000bff0: 7749 6e63 7265 6d65 6e74 3d31 2c20 7469  wIncrement=1, ti
-0000c000: 6d65 6f75 743d 302e 3034 2c20 7275 6e4f  meout=0.04, runO
-0000c010: 6e53 7461 7274 3d54 7275 652c 2072 756e  nStart=True, run
-0000c020: 4d6f 6465 3d32 2c20 666f 6e74 5369 7a65  Mode=2, fontSize
-0000c030: 3d31 322c 2074 6974 6c65 3d27 272c 2063  =12, title='', c
-0000c040: 6865 636b 5265 6e64 6572 456e 6769 6e65  heckRenderEngine
-0000c050: 5374 6f70 466c 6167 3d54 7275 6529 202d  StopFlag=True) -
-0000c060: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a0d 0a20  > None: ....... 
-0000c070: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-0000c080: 2020 6465 6620 4372 6561 7465 4772 6f75    def CreateGrou
-0000c090: 6e64 2873 656c 662c 206e 616d 653d 2727  nd(self, name=''
-0000c0a0: 2c20 7265 6665 7265 6e63 6550 6f73 6974  , referencePosit
-0000c0b0: 696f 6e3d 5b30 2e2c 302e 2c30 2e5d 2c20  ion=[0.,0.,0.], 
-0000c0c0: 7265 6665 7265 6e63 6552 6f74 6174 696f  referenceRotatio
-0000c0d0: 6e4d 6174 7269 783d 6e70 2e65 7965 2833  nMatrix=np.eye(3
-0000c0e0: 292c 2067 7261 7068 6963 7344 6174 614c  ), graphicsDataL
-0000c0f0: 6973 743d 5b5d 2c20 6772 6170 6869 6373  ist=[], graphics
-0000c100: 4461 7461 5573 6572 4675 6e63 7469 6f6e  DataUserFunction
-0000c110: 3d30 2c20 7368 6f77 3d54 7275 6529 202d  =0, show=True) -
-0000c120: 3e20 4f62 6a65 6374 496e 6465 783a 202e  > ObjectIndex: .
-0000c130: 2e2e 0d0a 0d0a 2020 2020 406f 7665 726c  ......    @overl
-0000c140: 6f61 640d 0a20 2020 2064 6566 2043 7265  oad..    def Cre
-0000c150: 6174 654d 6173 7350 6f69 6e74 2873 656c  ateMassPoint(sel
-0000c160: 662c 206e 616d 653d 2727 2c20 7265 6665  f, name='', refe
-0000c170: 7265 6e63 6550 6f73 6974 696f 6e3d 5b30  rencePosition=[0
-0000c180: 2e2c 302e 2c30 2e5d 2c20 696e 6974 6961  .,0.,0.], initia
-0000c190: 6c44 6973 706c 6163 656d 656e 743d 5b30  lDisplacement=[0
-0000c1a0: 2e2c 302e 2c30 2e5d 2c20 696e 6974 6961  .,0.,0.], initia
-0000c1b0: 6c56 656c 6f63 6974 793d 5b30 2e2c 302e  lVelocity=[0.,0.
-0000c1c0: 2c30 2e5d 2c20 7068 7973 6963 734d 6173  ,0.], physicsMas
-0000c1d0: 733d 302c 2067 7261 7669 7479 3d5b 302e  s=0, gravity=[0.
-0000c1e0: 2c30 2e2c 302e 5d2c 2067 7261 7068 6963  ,0.,0.], graphic
-0000c1f0: 7344 6174 614c 6973 743d 5b5d 2c20 6472  sDataList=[], dr
-0000c200: 6177 5369 7a65 3d2d 312c 2063 6f6c 6f72  awSize=-1, color
-0000c210: 3d5b 2d31 2e2c 2d31 2e2c 2d31 2e2c 2d31  =[-1.,-1.,-1.,-1
-0000c220: 2e5d 2c20 7368 6f77 3d54 7275 652c 2063  .], show=True, c
-0000c230: 7265 6174 6532 443d 4661 6c73 652c 2072  reate2D=False, r
-0000c240: 6574 7572 6e44 6963 743d 4661 6c73 6529  eturnDict=False)
-0000c250: 202d 3e20 556e 696f 6e5b 6469 6374 2c20   -> Union[dict, 
-0000c260: 4f62 6a65 6374 496e 6465 785d 3a20 2e2e  ObjectIndex]: ..
-0000c270: 2e0d 0a0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000c280: 6164 0d0a 2020 2020 6465 6620 4372 6561  ad..    def Crea
-0000c290: 7465 5269 6769 6442 6f64 7928 7365 6c66  teRigidBody(self
-0000c2a0: 2c20 6e61 6d65 3d27 272c 2072 6566 6572  , name='', refer
-0000c2b0: 656e 6365 506f 7369 7469 6f6e 3d5b 302e  encePosition=[0.
-0000c2c0: 2c30 2e2c 302e 5d2c 2072 6566 6572 656e  ,0.,0.], referen
-0000c2d0: 6365 526f 7461 7469 6f6e 4d61 7472 6978  ceRotationMatrix
-0000c2e0: 3d6e 702e 6579 6528 3329 2c20 696e 6974  =np.eye(3), init
-0000c2f0: 6961 6c56 656c 6f63 6974 793d 5b30 2e2c  ialVelocity=[0.,
-0000c300: 302e 2c30 2e5d 2c20 696e 6974 6961 6c41  0.,0.], initialA
-0000c310: 6e67 756c 6172 5665 6c6f 6369 7479 3d5b  ngularVelocity=[
-0000c320: 302e 2c30 2e2c 302e 5d2c 2069 6e69 7469  0.,0.,0.], initi
-0000c330: 616c 4469 7370 6c61 6365 6d65 6e74 3d4e  alDisplacement=N
-0000c340: 6f6e 652c 2069 6e69 7469 616c 526f 7461  one, initialRota
-0000c350: 7469 6f6e 4d61 7472 6978 3d4e 6f6e 652c  tionMatrix=None,
-0000c360: 2069 6e65 7274 6961 3d4e 6f6e 652c 2067   inertia=None, g
-0000c370: 7261 7669 7479 3d5b 302e 2c30 2e2c 302e  ravity=[0.,0.,0.
-0000c380: 5d2c 206e 6f64 6554 7970 653d 6578 7564  ], nodeType=exud
-0000c390: 796e 2e4e 6f64 6554 7970 652e 526f 7461  yn.NodeType.Rota
-0000c3a0: 7469 6f6e 4575 6c65 7250 6172 616d 6574  tionEulerParamet
-0000c3b0: 6572 732c 2067 7261 7068 6963 7344 6174  ers, graphicsDat
-0000c3c0: 614c 6973 743d 5b5d 2c20 6772 6170 6869  aList=[], graphi
-0000c3d0: 6373 4461 7461 5573 6572 4675 6e63 7469  csDataUserFuncti
-0000c3e0: 6f6e 3d30 2c20 6472 6177 5369 7a65 3d2d  on=0, drawSize=-
-0000c3f0: 312c 2063 6f6c 6f72 3d5b 2d31 2e2c 2d31  1, color=[-1.,-1
-0000c400: 2e2c 2d31 2e2c 2d31 2e5d 2c20 7368 6f77  .,-1.,-1.], show
-0000c410: 3d54 7275 652c 2063 7265 6174 6532 443d  =True, create2D=
-0000c420: 4661 6c73 652c 2072 6574 7572 6e44 6963  False, returnDic
-0000c430: 743d 4661 6c73 6529 202d 3e20 556e 696f  t=False) -> Unio
-0000c440: 6e5b 6469 6374 2c20 4f62 6a65 6374 496e  n[dict, ObjectIn
-0000c450: 6465 785d 3a20 2e2e 2e0d 0a0d 0a20 2020  dex]: .......   
-0000c460: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000c470: 6465 6620 4372 6561 7465 5370 7269 6e67  def CreateSpring
-0000c480: 4461 6d70 6572 2873 656c 662c 206e 616d  Damper(self, nam
-0000c490: 653d 2727 2c20 626f 6479 4c69 7374 3d5b  e='', bodyList=[
-0000c4a0: 4e6f 6e65 2c20 4e6f 6e65 5d2c 206c 6f63  None, None], loc
-0000c4b0: 616c 506f 7369 7469 6f6e 303d 5b30 2e2c  alPosition0=[0.,
-0000c4c0: 302e 2c30 2e5d 2c20 6c6f 6361 6c50 6f73  0.,0.], localPos
-0000c4d0: 6974 696f 6e31 3d5b 302e 2c30 2e2c 302e  ition1=[0.,0.,0.
-0000c4e0: 5d2c 2072 6566 6572 656e 6365 4c65 6e67  ], referenceLeng
-0000c4f0: 7468 3d4e 6f6e 652c 2073 7469 6666 6e65  th=None, stiffne
-0000c500: 7373 3d30 2e2c 2064 616d 7069 6e67 3d30  ss=0., damping=0
-0000c510: 2e2c 2066 6f72 6365 3d30 2e2c 2076 656c  ., force=0., vel
-0000c520: 6f63 6974 794f 6666 7365 743d 302e 2c20  ocityOffset=0., 
-0000c530: 7370 7269 6e67 466f 7263 6555 7365 7246  springForceUserF
-0000c540: 756e 6374 696f 6e3d 302c 2062 6f64 794f  unction=0, bodyO
-0000c550: 724e 6f64 654c 6973 743d 5b4e 6f6e 652c  rNodeList=[None,
-0000c560: 204e 6f6e 655d 2c20 7368 6f77 3d54 7275   None], show=Tru
-0000c570: 652c 2064 7261 7753 697a 653d 2d31 2c20  e, drawSize=-1, 
-0000c580: 636f 6c6f 723d 636f 6c6f 7234 6465 6661  color=color4defa
-0000c590: 756c 7429 202d 3e20 4f62 6a65 6374 496e  ult) -> ObjectIn
-0000c5a0: 6465 783a 202e 2e2e 0d0a 0d0a 2020 2020  dex: .......    
-0000c5b0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000c5c0: 6566 2043 7265 6174 6543 6172 7465 7369  ef CreateCartesi
-0000c5d0: 616e 5370 7269 6e67 4461 6d70 6572 2873  anSpringDamper(s
-0000c5e0: 656c 662c 206e 616d 653d 2727 2c20 626f  elf, name='', bo
-0000c5f0: 6479 4c69 7374 3d5b 4e6f 6e65 2c20 4e6f  dyList=[None, No
-0000c600: 6e65 5d2c 206c 6f63 616c 506f 7369 7469  ne], localPositi
-0000c610: 6f6e 303d 5b30 2e2c 302e 2c30 2e5d 2c20  on0=[0.,0.,0.], 
-0000c620: 6c6f 6361 6c50 6f73 6974 696f 6e31 3d5b  localPosition1=[
-0000c630: 302e 2c30 2e2c 302e 5d2c 2073 7469 6666  0.,0.,0.], stiff
-0000c640: 6e65 7373 3d5b 302e 2c30 2e2c 302e 5d2c  ness=[0.,0.,0.],
-0000c650: 2064 616d 7069 6e67 3d5b 302e 2c30 2e2c   damping=[0.,0.,
-0000c660: 302e 5d2c 206f 6666 7365 743d 5b30 2e2c  0.], offset=[0.,
-0000c670: 302e 2c30 2e5d 2c20 7370 7269 6e67 466f  0.,0.], springFo
-0000c680: 7263 6555 7365 7246 756e 6374 696f 6e3d  rceUserFunction=
-0000c690: 302c 2062 6f64 794f 724e 6f64 654c 6973  0, bodyOrNodeLis
-0000c6a0: 743d 5b4e 6f6e 652c 204e 6f6e 655d 2c20  t=[None, None], 
-0000c6b0: 7368 6f77 3d54 7275 652c 2064 7261 7753  show=True, drawS
-0000c6c0: 697a 653d 2d31 2c20 636f 6c6f 723d 636f  ize=-1, color=co
-0000c6d0: 6c6f 7234 6465 6661 756c 7429 202d 3e20  lor4default) -> 
-0000c6e0: 4f62 6a65 6374 496e 6465 783a 202e 2e2e  ObjectIndex: ...
-0000c6f0: 0d0a 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000c700: 640d 0a20 2020 2064 6566 2043 7265 6174  d..    def Creat
-0000c710: 6552 6967 6964 426f 6479 5370 7269 6e67  eRigidBodySpring
-0000c720: 4461 6d70 6572 2873 656c 662c 206e 616d  Damper(self, nam
-0000c730: 653d 2727 2c20 626f 6479 4c69 7374 3d5b  e='', bodyList=[
-0000c740: 4e6f 6e65 2c20 4e6f 6e65 5d2c 206c 6f63  None, None], loc
-0000c750: 616c 506f 7369 7469 6f6e 303d 5b30 2e2c  alPosition0=[0.,
-0000c760: 302e 2c30 2e5d 2c20 6c6f 6361 6c50 6f73  0.,0.], localPos
-0000c770: 6974 696f 6e31 3d5b 302e 2c30 2e2c 302e  ition1=[0.,0.,0.
-0000c780: 5d2c 2073 7469 6666 6e65 7373 3d6e 702e  ], stiffness=np.
-0000c790: 7a65 726f 7328 2836 2c36 2929 2c20 6461  zeros((6,6)), da
-0000c7a0: 6d70 696e 673d 6e70 2e7a 6572 6f73 2828  mping=np.zeros((
-0000c7b0: 362c 3629 292c 206f 6666 7365 743d 5b30  6,6)), offset=[0
-0000c7c0: 2e2c 302e 2c30 2e2c 302e 2c30 2e2c 302e  .,0.,0.,0.,0.,0.
-0000c7d0: 5d2c 2072 6f74 6174 696f 6e4d 6174 7269  ], rotationMatri
-0000c7e0: 784a 6f69 6e74 3d6e 702e 6579 6528 3329  xJoint=np.eye(3)
-0000c7f0: 2c20 7573 6547 6c6f 6261 6c46 7261 6d65  , useGlobalFrame
-0000c800: 3d54 7275 652c 2069 6e74 7269 6e73 6963  =True, intrinsic
-0000c810: 466f 726d 756c 6174 696f 6e3d 5472 7565  Formulation=True
-0000c820: 2c20 7370 7269 6e67 466f 7263 6554 6f72  , springForceTor
-0000c830: 7175 6555 7365 7246 756e 6374 696f 6e3d  queUserFunction=
-0000c840: 302c 2070 6f73 744e 6577 746f 6e53 7465  0, postNewtonSte
-0000c850: 7055 7365 7246 756e 6374 696f 6e3d 302c  pUserFunction=0,
-0000c860: 2062 6f64 794f 724e 6f64 654c 6973 743d   bodyOrNodeList=
-0000c870: 5b4e 6f6e 652c 204e 6f6e 655d 2c20 7368  [None, None], sh
-0000c880: 6f77 3d54 7275 652c 2064 7261 7753 697a  ow=True, drawSiz
-0000c890: 653d 2d31 2c20 636f 6c6f 723d 636f 6c6f  e=-1, color=colo
-0000c8a0: 7234 6465 6661 756c 7429 202d 3e20 4f62  r4default) -> Ob
-0000c8b0: 6a65 6374 496e 6465 783a 202e 2e2e 0d0a  jectIndex: .....
-0000c8c0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000c8d0: 0a20 2020 2064 6566 2043 7265 6174 6552  .    def CreateR
-0000c8e0: 6576 6f6c 7574 654a 6f69 6e74 2873 656c  evoluteJoint(sel
-0000c8f0: 662c 206e 616d 653d 2727 2c20 626f 6479  f, name='', body
-0000c900: 4e75 6d62 6572 733d 5b4e 6f6e 652c 204e  Numbers=[None, N
-0000c910: 6f6e 655d 2c20 706f 7369 7469 6f6e 3d5b  one], position=[
-0000c920: 5d2c 2061 7869 733d 5b5d 2c20 7573 6547  ], axis=[], useG
-0000c930: 6c6f 6261 6c46 7261 6d65 3d54 7275 652c  lobalFrame=True,
-0000c940: 2073 686f 773d 5472 7565 2c20 6178 6973   show=True, axis
-0000c950: 5261 6469 7573 3d30 2e31 2c20 6178 6973  Radius=0.1, axis
-0000c960: 4c65 6e67 7468 3d30 2e34 2c20 636f 6c6f  Length=0.4, colo
-0000c970: 723d 636f 6c6f 7234 6465 6661 756c 7429  r=color4default)
-0000c980: 202d 3e20 5b4f 626a 6563 7449 6e64 6578   -> [ObjectIndex
-0000c990: 2c20 4d61 726b 6572 496e 6465 782c 204d  , MarkerIndex, M
-0000c9a0: 6172 6b65 7249 6e64 6578 5d3a 202e 2e2e  arkerIndex]: ...
-0000c9b0: 0d0a 0d0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
-0000c9c0: 640d 0a20 2020 2064 6566 2043 7265 6174  d..    def Creat
-0000c9d0: 6550 7269 736d 6174 6963 4a6f 696e 7428  ePrismaticJoint(
-0000c9e0: 7365 6c66 2c20 6e61 6d65 3d27 272c 2062  self, name='', b
-0000c9f0: 6f64 794e 756d 6265 7273 3d5b 4e6f 6e65  odyNumbers=[None
-0000ca00: 2c20 4e6f 6e65 5d2c 2070 6f73 6974 696f  , None], positio
-0000ca10: 6e3d 5b5d 2c20 6178 6973 3d5b 5d2c 2075  n=[], axis=[], u
-0000ca20: 7365 476c 6f62 616c 4672 616d 653d 5472  seGlobalFrame=Tr
-0000ca30: 7565 2c20 7368 6f77 3d54 7275 652c 2061  ue, show=True, a
-0000ca40: 7869 7352 6164 6975 733d 302e 312c 2061  xisRadius=0.1, a
-0000ca50: 7869 734c 656e 6774 683d 302e 342c 2063  xisLength=0.4, c
-0000ca60: 6f6c 6f72 3d63 6f6c 6f72 3464 6566 6175  olor=color4defau
-0000ca70: 6c74 2920 2d3e 205b 4f62 6a65 6374 496e  lt) -> [ObjectIn
-0000ca80: 6465 782c 204d 6172 6b65 7249 6e64 6578  dex, MarkerIndex
-0000ca90: 2c20 4d61 726b 6572 496e 6465 785d 3a20  , MarkerIndex]: 
-0000caa0: 2e2e 2e0d 0a0d 0a20 2020 2040 6f76 6572  .......    @over
-0000cab0: 6c6f 6164 0d0a 2020 2020 6465 6620 4372  load..    def Cr
-0000cac0: 6561 7465 5370 6865 7269 6361 6c4a 6f69  eateSphericalJoi
-0000cad0: 6e74 2873 656c 662c 206e 616d 653d 2727  nt(self, name=''
-0000cae0: 2c20 626f 6479 4e75 6d62 6572 733d 5b4e  , bodyNumbers=[N
-0000caf0: 6f6e 652c 204e 6f6e 655d 2c20 706f 7369  one, None], posi
-0000cb00: 7469 6f6e 3d5b 5d2c 2063 6f6e 7374 7261  tion=[], constra
-0000cb10: 696e 6564 4178 6573 3d5b 312c 312c 315d  inedAxes=[1,1,1]
-0000cb20: 2c20 7573 6547 6c6f 6261 6c46 7261 6d65  , useGlobalFrame
-0000cb30: 3d54 7275 652c 2073 686f 773d 5472 7565  =True, show=True
-0000cb40: 2c20 6a6f 696e 7452 6164 6975 733d 302e  , jointRadius=0.
-0000cb50: 312c 2063 6f6c 6f72 3d63 6f6c 6f72 3464  1, color=color4d
-0000cb60: 6566 6175 6c74 2920 2d3e 205b 4f62 6a65  efault) -> [Obje
-0000cb70: 6374 496e 6465 782c 204d 6172 6b65 7249  ctIndex, MarkerI
-0000cb80: 6e64 6578 2c20 4d61 726b 6572 496e 6465  ndex, MarkerInde
-0000cb90: 785d 3a20 2e2e 2e0d 0a0d 0a20 2020 2040  x]: .......    @
-0000cba0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000cbb0: 6620 4372 6561 7465 4765 6e65 7269 634a  f CreateGenericJ
-0000cbc0: 6f69 6e74 2873 656c 662c 206e 616d 653d  oint(self, name=
-0000cbd0: 2727 2c20 626f 6479 4e75 6d62 6572 733d  '', bodyNumbers=
-0000cbe0: 5b4e 6f6e 652c 204e 6f6e 655d 2c20 706f  [None, None], po
-0000cbf0: 7369 7469 6f6e 3d5b 5d2c 2072 6f74 6174  sition=[], rotat
-0000cc00: 696f 6e4d 6174 7269 7841 7865 733d 6e70  ionMatrixAxes=np
-0000cc10: 2e65 7965 2833 292c 2063 6f6e 7374 7261  .eye(3), constra
-0000cc20: 696e 6564 4178 6573 3d5b 312c 312c 312c  inedAxes=[1,1,1,
-0000cc30: 2031 2c31 2c31 5d2c 2075 7365 476c 6f62   1,1,1], useGlob
-0000cc40: 616c 4672 616d 653d 5472 7565 2c20 6f66  alFrame=True, of
-0000cc50: 6673 6574 5573 6572 4675 6e63 7469 6f6e  fsetUserFunction
-0000cc60: 3d30 2c20 6f66 6673 6574 5573 6572 4675  =0, offsetUserFu
-0000cc70: 6e63 7469 6f6e 5c5f 743d 302c 2073 686f  nction\_t=0, sho
-0000cc80: 773d 5472 7565 2c20 6178 6573 5261 6469  w=True, axesRadi
-0000cc90: 7573 3d30 2e31 2c20 6178 6573 4c65 6e67  us=0.1, axesLeng
-0000cca0: 7468 3d30 2e34 2c20 636f 6c6f 723d 636f  th=0.4, color=co
-0000ccb0: 6c6f 7234 6465 6661 756c 7429 202d 3e20  lor4default) -> 
-0000ccc0: 5b4f 626a 6563 7449 6e64 6578 2c20 4d61  [ObjectIndex, Ma
-0000ccd0: 726b 6572 496e 6465 782c 204d 6172 6b65  rkerIndex, Marke
-0000cce0: 7249 6e64 6578 5d3a 202e 2e2e 0d0a 0d0a  rIndex]: .......
-0000ccf0: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000cd00: 2020 2064 6566 2043 7265 6174 6544 6973     def CreateDis
-0000cd10: 7461 6e63 6543 6f6e 7374 7261 696e 7428  tanceConstraint(
-0000cd20: 7365 6c66 2c20 6e61 6d65 3d27 272c 2062  self, name='', b
-0000cd30: 6f64 794c 6973 743d 5b4e 6f6e 652c 204e  odyList=[None, N
-0000cd40: 6f6e 655d 2c20 6c6f 6361 6c50 6f73 6974  one], localPosit
-0000cd50: 696f 6e30 3d5b 302e 2c30 2e2c 302e 5d2c  ion0=[0.,0.,0.],
-0000cd60: 206c 6f63 616c 506f 7369 7469 6f6e 313d   localPosition1=
-0000cd70: 5b30 2e2c 302e 2c30 2e5d 2c20 6469 7374  [0.,0.,0.], dist
-0000cd80: 616e 6365 3d4e 6f6e 652c 2062 6f64 794f  ance=None, bodyO
-0000cd90: 724e 6f64 654c 6973 743d 5b4e 6f6e 652c  rNodeList=[None,
-0000cda0: 204e 6f6e 655d 2c20 7368 6f77 3d54 7275   None], show=Tru
-0000cdb0: 652c 2064 7261 7753 697a 653d 2d31 2e2c  e, drawSize=-1.,
-0000cdc0: 2063 6f6c 6f72 3d63 6f6c 6f72 3464 6566   color=color4def
-0000cdd0: 6175 6c74 2920 2d3e 205b 4f62 6a65 6374  ault) -> [Object
-0000cde0: 496e 6465 782c 204d 6172 6b65 7249 6e64  Index, MarkerInd
-0000cdf0: 6578 2c20 4d61 726b 6572 496e 6465 785d  ex, MarkerIndex]
-0000ce00: 3a20 2e2e 2e0d 0a0d 0a20 2020 2040 6f76  : .......    @ov
-0000ce10: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000ce20: 4372 6561 7465 466f 7263 6528 7365 6c66  CreateForce(self
-0000ce30: 2c20 6e61 6d65 3d27 272c 2062 6f64 794e  , name='', bodyN
-0000ce40: 756d 6265 723d 4e6f 6e65 2c20 6c6f 6164  umber=None, load
-0000ce50: 5665 6374 6f72 3d5b 302e 2c30 2e2c 302e  Vector=[0.,0.,0.
-0000ce60: 5d2c 206c 6f63 616c 506f 7369 7469 6f6e  ], localPosition
-0000ce70: 3d5b 302e 2c30 2e2c 302e 5d2c 2062 6f64  =[0.,0.,0.], bod
-0000ce80: 7946 6978 6564 3d46 616c 7365 2c20 6c6f  yFixed=False, lo
-0000ce90: 6164 5665 6374 6f72 5573 6572 4675 6e63  adVectorUserFunc
-0000cea0: 7469 6f6e 3d30 2c20 7368 6f77 3d54 7275  tion=0, show=Tru
-0000ceb0: 6529 202d 3e20 4c6f 6164 496e 6465 783a  e) -> LoadIndex:
-0000cec0: 202e 2e2e 0d0a 0d0a 2020 2020 406f 7665   .......    @ove
-0000ced0: 726c 6f61 640d 0a20 2020 2064 6566 2043  rload..    def C
-0000cee0: 7265 6174 6554 6f72 7175 6528 7365 6c66  reateTorque(self
-0000cef0: 2c20 6e61 6d65 3d27 272c 2062 6f64 794e  , name='', bodyN
-0000cf00: 756d 6265 723d 4e6f 6e65 2c20 6c6f 6164  umber=None, load
-0000cf10: 5665 6374 6f72 3d5b 302e 2c30 2e2c 302e  Vector=[0.,0.,0.
-0000cf20: 5d2c 206c 6f63 616c 506f 7369 7469 6f6e  ], localPosition
-0000cf30: 3d5b 302e 2c30 2e2c 302e 5d2c 2062 6f64  =[0.,0.,0.], bod
-0000cf40: 7946 6978 6564 3d46 616c 7365 2c20 6c6f  yFixed=False, lo
-0000cf50: 6164 5665 6374 6f72 5573 6572 4675 6e63  adVectorUserFunc
-0000cf60: 7469 6f6e 3d30 2c20 7368 6f77 3d54 7275  tion=0, show=Tru
-0000cf70: 6529 202d 3e20 4c6f 6164 496e 6465 783a  e) -> LoadIndex:
-0000cf80: 202e 2e2e 0d0a 0d0a 2020 2020 406f 7665   .......    @ove
-0000cf90: 726c 6f61 640d 0a20 2020 2064 6566 2050  rload..    def P
-0000cfa0: 6c6f 7453 656e 736f 7228 7365 6c66 2c20  lotSensor(self, 
-0000cfb0: 7365 6e73 6f72 4e75 6d62 6572 733d 5b5d  sensorNumbers=[]
-0000cfc0: 2c20 636f 6d70 6f6e 656e 7473 3d30 2c20  , components=0, 
-0000cfd0: 784c 6162 656c 3d27 7469 6d65 2028 7329  xLabel='time (s)
-0000cfe0: 272c 2079 4c61 6265 6c3d 4e6f 6e65 2c20  ', yLabel=None, 
-0000cff0: 6c61 6265 6c73 3d5b 5d2c 2063 6f6c 6f72  labels=[], color
-0000d000: 436f 6465 4f66 6673 6574 3d30 2c20 6e65  CodeOffset=0, ne
-0000d010: 7746 6967 7572 653d 5472 7565 2c20 636c  wFigure=True, cl
-0000d020: 6f73 6541 6c6c 3d46 616c 7365 2c20 636f  oseAll=False, co
-0000d030: 6d70 6f6e 656e 7473 583d 5b5d 2c20 7469  mponentsX=[], ti
-0000d040: 746c 653d 2727 2c20 6669 6775 7265 4e61  tle='', figureNa
-0000d050: 6d65 3d27 272c 2066 6f6e 7453 697a 653d  me='', fontSize=
-0000d060: 3136 2c20 636f 6c6f 7273 3d5b 5d2c 206c  16, colors=[], l
-0000d070: 696e 6553 7479 6c65 733d 5b5d 2c20 6c69  ineStyles=[], li
-0000d080: 6e65 5769 6474 6873 3d5b 5d2c 206d 6172  neWidths=[], mar
-0000d090: 6b65 7253 7479 6c65 733d 5b5d 2c20 6d61  kerStyles=[], ma
-0000d0a0: 726b 6572 5369 7a65 733d 5b5d 2c20 6d61  rkerSizes=[], ma
-0000d0b0: 726b 6572 4465 6e73 6974 793d 302e 3038  rkerDensity=0.08
-0000d0c0: 2c20 7261 6e67 6558 3d5b 5d2c 2072 616e  , rangeX=[], ran
-0000d0d0: 6765 593d 5b5d 2c20 6d61 6a6f 7254 6963  geY=[], majorTic
-0000d0e0: 6b73 583d 3130 2c20 6d61 6a6f 7254 6963  ksX=10, majorTic
-0000d0f0: 6b73 593d 3130 2c20 6f66 6673 6574 733d  ksY=10, offsets=
-0000d100: 5b5d 2c20 6661 6374 6f72 733d 5b5d 2c20  [], factors=[], 
-0000d110: 7375 6250 6c6f 743d 5b5d 2c20 7369 7a65  subPlot=[], size
-0000d120: 496e 6368 6573 3d5b 362e 342c 342e 385d  Inches=[6.4,4.8]
-0000d130: 2c20 6669 6c65 4e61 6d65 3d27 272c 2075  , fileName='', u
-0000d140: 7365 5859 5a63 6f6d 706f 6e65 6e74 733d  seXYZcomponents=
-0000d150: 5472 7565 2c20 2a2a 6b77 6172 6773 2920  True, **kwargs) 
-0000d160: 2d3e 205b 416e 792c 2041 6e79 2c20 416e  -> [Any, Any, An
-0000d170: 792c 2041 6e79 5d3a 202e 2e2e 0d0a 0d0a  y, Any]: .......
-0000d180: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000d190: 2020 2064 6566 2053 6f6c 7665 5374 6174     def SolveStat
-0000d1a0: 6963 2873 656c 662c 2073 696d 756c 6174  ic(self, simulat
-0000d1b0: 696f 6e53 6574 7469 6e67 733d 6578 7564  ionSettings=exud
-0000d1c0: 796e 2e53 696d 756c 6174 696f 6e53 6574  yn.SimulationSet
-0000d1d0: 7469 6e67 7328 292c 2075 7064 6174 6549  tings(), updateI
-0000d1e0: 6e69 7469 616c 5661 6c75 6573 3d46 616c  nitialValues=Fal
-0000d1f0: 7365 2c20 7374 6f72 6553 6f6c 7665 723d  se, storeSolver=
-0000d200: 5472 7565 2c20 7368 6f77 4869 6e74 733d  True, showHints=
-0000d210: 4661 6c73 652c 2073 686f 7743 6175 7369  False, showCausi
-0000d220: 6e67 4974 656d 733d 5472 7565 2920 2d3e  ngItems=True) ->
-0000d230: 2062 6f6f 6c3a 202e 2e2e 0d0a 0d0a 2020   bool: .......  
-0000d240: 2020 406f 7665 726c 6f61 640d 0a20 2020    @overload..   
-0000d250: 2064 6566 2053 6f6c 7665 4479 6e61 6d69   def SolveDynami
-0000d260: 6328 7365 6c66 2c20 7369 6d75 6c61 7469  c(self, simulati
-0000d270: 6f6e 5365 7474 696e 6773 3d65 7875 6479  onSettings=exudy
-0000d280: 6e2e 5369 6d75 6c61 7469 6f6e 5365 7474  n.SimulationSett
-0000d290: 696e 6773 2829 2c20 736f 6c76 6572 5479  ings(), solverTy
-0000d2a0: 7065 3d65 7875 6479 6e2e 4479 6e61 6d69  pe=exudyn.Dynami
-0000d2b0: 6353 6f6c 7665 7254 7970 652e 4765 6e65  cSolverType.Gene
-0000d2c0: 7261 6c69 7a65 6441 6c70 6861 2c20 7570  ralizedAlpha, up
-0000d2d0: 6461 7465 496e 6974 6961 6c56 616c 7565  dateInitialValue
-0000d2e0: 733d 4661 6c73 652c 2073 746f 7265 536f  s=False, storeSo
-0000d2f0: 6c76 6572 3d54 7275 652c 2073 686f 7748  lver=True, showH
-0000d300: 696e 7473 3d46 616c 7365 2c20 7368 6f77  ints=False, show
-0000d310: 4361 7573 696e 6749 7465 6d73 3d54 7275  CausingItems=Tru
-0000d320: 6529 202d 3e20 626f 6f6c 3a20 2e2e 2e0d  e) -> bool: ....
-0000d330: 0a0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-0000d340: 0d0a 2020 2020 6465 6620 436f 6d70 7574  ..    def Comput
-0000d350: 654c 696e 6561 7269 7a65 6453 7973 7465  eLinearizedSyste
-0000d360: 6d28 7365 6c66 2c20 7369 6d75 6c61 7469  m(self, simulati
-0000d370: 6f6e 5365 7474 696e 6773 3d65 7875 6479  onSettings=exudy
-0000d380: 6e2e 5369 6d75 6c61 7469 6f6e 5365 7474  n.SimulationSett
-0000d390: 696e 6773 2829 2c20 7573 6553 7061 7273  ings(), useSpars
-0000d3a0: 6553 6f6c 7665 723d 4661 6c73 6529 202d  eSolver=False) -
-0000d3b0: 3e20 5b41 7272 6179 4c69 6b65 2c20 4172  > [ArrayLike, Ar
-0000d3c0: 7261 794c 696b 652c 2041 7272 6179 4c69  rayLike, ArrayLi
-0000d3d0: 6b65 5d3a 202e 2e2e 0d0a 0d0a 2020 2020  ke]: .......    
-0000d3e0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000d3f0: 6566 2043 6f6d 7075 7465 4f44 4532 4569  ef ComputeODE2Ei
-0000d400: 6765 6e76 616c 7565 7328 7365 6c66 2c20  genvalues(self, 
-0000d410: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-0000d420: 6773 3d65 7875 6479 6e2e 5369 6d75 6c61  gs=exudyn.Simula
-0000d430: 7469 6f6e 5365 7474 696e 6773 2829 2c20  tionSettings(), 
-0000d440: 7573 6553 7061 7273 6553 6f6c 7665 723d  useSparseSolver=
-0000d450: 4661 6c73 652c 206e 756d 6265 724f 6645  False, numberOfE
-0000d460: 6967 656e 7661 6c75 6573 3d30 2c20 636f  igenvalues=0, co
-0000d470: 6e73 7472 6169 6e65 6443 6f6f 7264 696e  nstrainedCoordin
-0000d480: 6174 6573 3d5b 5d2c 2063 6f6e 7665 7274  ates=[], convert
-0000d490: 3246 7265 7175 656e 6369 6573 3d46 616c  2Frequencies=Fal
-0000d4a0: 7365 2c20 7573 6541 6273 6f6c 7574 6556  se, useAbsoluteV
-0000d4b0: 616c 7565 733d 5472 7565 2c20 6967 6e6f  alues=True, igno
-0000d4c0: 7265 416c 6765 6272 6169 6345 7175 6174  reAlgebraicEquat
-0000d4d0: 696f 6e73 3d46 616c 7365 2c20 7369 6e67  ions=False, sing
-0000d4e0: 756c 6172 5661 6c75 6573 546f 6c65 7261  ularValuesTolera
-0000d4f0: 6e63 653d 3165 2d31 3229 202d 3e20 5b41  nce=1e-12) -> [A
-0000d500: 7272 6179 4c69 6b65 2c20 4172 7261 794c  rrayLike, ArrayL
-0000d510: 696b 655d 3a20 2e2e 2e0d 0a0d 0a20 2020  ike]: .......   
-0000d520: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000d530: 6465 6620 436f 6d70 7574 6553 7973 7465  def ComputeSyste
-0000d540: 6d44 6567 7265 654f 6646 7265 6564 6f6d  mDegreeOfFreedom
-0000d550: 2873 656c 662c 2073 696d 756c 6174 696f  (self, simulatio
-0000d560: 6e53 6574 7469 6e67 733d 6578 7564 796e  nSettings=exudyn
-0000d570: 2e53 696d 756c 6174 696f 6e53 6574 7469  .SimulationSetti
-0000d580: 6e67 7328 292c 2074 6872 6573 686f 6c64  ngs(), threshold
-0000d590: 3d31 652d 3132 2c20 7665 7262 6f73 653d  =1e-12, verbose=
-0000d5a0: 4661 6c73 652c 2075 7365 5356 443d 4661  False, useSVD=Fa
-0000d5b0: 6c73 6529 202d 3e20 6469 6374 3a20 2e2e  lse) -> dict: ..
-0000d5c0: 2e0d 0a0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000d5d0: 6164 0d0a 2020 2020 6465 6620 4372 6561  ad..    def Crea
-0000d5e0: 7465 4469 7374 616e 6365 5365 6e73 6f72  teDistanceSensor
-0000d5f0: 4765 6f6d 6574 7279 2873 656c 662c 206d  Geometry(self, m
-0000d600: 6573 6850 6f69 6e74 732c 206d 6573 6854  eshPoints, meshT
-0000d610: 7269 6773 2c20 7269 6769 6442 6f64 794d  rigs, rigidBodyM
-0000d620: 6172 6b65 7249 6e64 6578 2c20 7365 6172  arkerIndex, sear
-0000d630: 6368 5472 6565 4365 6c6c 5369 7a65 3d5b  chTreeCellSize=[
-0000d640: 382c 382c 385d 2920 2d3e 2069 6e74 3a20  8,8,8]) -> int: 
-0000d650: 2e2e 2e0d 0a0d 0a20 2020 2040 6f76 6572  .......    @over
-0000d660: 6c6f 6164 0d0a 2020 2020 6465 6620 4372  load..    def Cr
-0000d670: 6561 7465 4469 7374 616e 6365 5365 6e73  eateDistanceSens
-0000d680: 6f72 2873 656c 662c 2067 656e 6572 616c  or(self, general
-0000d690: 436f 6e74 6163 7449 6e64 6578 2c20 706f  ContactIndex, po
-0000d6a0: 7369 7469 6f6e 4f72 4d61 726b 6572 2c20  sitionOrMarker, 
-0000d6b0: 6469 7253 656e 736f 722c 206d 696e 4469  dirSensor, minDi
-0000d6c0: 7374 616e 6365 3d2d 3165 372c 206d 6178  stance=-1e7, max
-0000d6d0: 4469 7374 616e 6365 3d31 6537 2c20 6379  Distance=1e7, cy
-0000d6e0: 6c69 6e64 6572 5261 6469 7573 3d30 2c20  linderRadius=0, 
-0000d6f0: 7365 6c65 6374 6564 5479 7065 496e 6465  selectedTypeInde
-0000d700: 783d 6578 7564 796e 2e43 6f6e 7461 6374  x=exudyn.Contact
-0000d710: 5479 7065 496e 6465 782e 496e 6465 7845  TypeIndex.IndexE
-0000d720: 6e64 4f66 456e 756d 4c69 7374 2c20 7374  ndOfEnumList, st
-0000d730: 6f72 6549 6e74 6572 6e61 6c3d 4661 6c73  oreInternal=Fals
-0000d740: 652c 2066 696c 654e 616d 653d 2727 2c20  e, fileName='', 
-0000d750: 6d65 6173 7572 6556 656c 6f63 6974 793d  measureVelocity=
-0000d760: 4661 6c73 652c 2061 6464 4772 6170 6869  False, addGraphi
-0000d770: 6373 4f62 6a65 6374 3d46 616c 7365 2c20  csObject=False, 
-0000d780: 6472 6177 4469 7370 6c61 6365 643d 5472  drawDisplaced=Tr
-0000d790: 7565 2c20 636f 6c6f 723d 636f 6c6f 7234  ue, color=color4
-0000d7a0: 7265 6429 202d 3e20 5365 6e73 6f72 496e  red) -> SensorIn
-0000d7b0: 6465 783a 202e 2e2e 0d0a 0d0a 2020 2020  dex: .......    
-0000d7c0: 406f 7665 726c 6f61 640d 0a20 2020 2064  @overload..    d
-0000d7d0: 6566 2044 7261 7753 7973 7465 6d47 7261  ef DrawSystemGra
-0000d7e0: 7068 2873 656c 662c 2073 686f 774c 6f61  ph(self, showLoa
-0000d7f0: 6473 3d54 7275 652c 2073 686f 7753 656e  ds=True, showSen
-0000d800: 736f 7273 3d54 7275 652c 2075 7365 4974  sors=True, useIt
-0000d810: 656d 4e61 6d65 733d 4661 6c73 652c 2075  emNames=False, u
-0000d820: 7365 4974 656d 5479 7065 733d 4661 6c73  seItemTypes=Fals
-0000d830: 652c 2061 6464 4974 656d 5479 7065 4e61  e, addItemTypeNa
-0000d840: 6d65 733d 5472 7565 2c20 6d75 6c74 694c  mes=True, multiL
-0000d850: 696e 653d 5472 7565 2c20 666f 6e74 5369  ine=True, fontSi
-0000d860: 7a65 4661 6374 6f72 3d31 2e2c 206c 6179  zeFactor=1., lay
-0000d870: 6f75 7444 6973 7461 6e63 6546 6163 746f  outDistanceFacto
-0000d880: 723d 332e 2c20 6c61 796f 7574 4974 6572  r=3., layoutIter
-0000d890: 6174 696f 6e73 3d31 3030 2c20 7368 6f77  ations=100, show
-0000d8a0: 4c65 6765 6e64 3d54 7275 652c 2074 6967  Legend=True, tig
-0000d8b0: 6874 4c61 796f 7574 3d54 7275 6529 202d  htLayout=True) -
-0000d8c0: 3e20 5b41 6e79 2c20 416e 792c 2041 6e79  > [Any, Any, Any
-0000d8d0: 5d3a 202e 2e2e 0d0a 0d0a 0d0a 636c 6173  ]: .........clas
-0000d8e0: 7320 5379 7374 656d 436f 6e74 6169 6e65  s SystemContaine
-0000d8f0: 723a 0d0a 2020 2020 406f 7665 726c 6f61  r:..    @overloa
-0000d900: 640d 0a20 2020 2064 6566 2052 6573 6574  d..    def Reset
-0000d910: 2873 656c 6629 202d 3e20 4e6f 6e65 3a20  (self) -> None: 
-0000d920: 2e2e 2e0d 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
-0000d930: 6164 0d0a 2020 2020 6465 6620 4164 6453  ad..    def AddS
-0000d940: 7973 7465 6d28 7365 6c66 2920 2d3e 204d  ystem(self) -> M
-0000d950: 6169 6e53 7973 7465 6d3a 202e 2e2e 0d0a  ainSystem: .....
-0000d960: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000d970: 2020 2064 6566 2041 7070 656e 6428 7365     def Append(se
-0000d980: 6c66 2c20 6d61 696e 5379 7374 656d 3a20  lf, mainSystem: 
-0000d990: 4d61 696e 5379 7374 656d 2920 2d3e 2069  MainSystem) -> i
-0000d9a0: 6e74 3a20 2e2e 2e0d 0a20 2020 2040 6f76  nt: .....    @ov
-0000d9b0: 6572 6c6f 6164 0d0a 2020 2020 6465 6620  erload..    def 
-0000d9c0: 4e75 6d62 6572 4f66 5379 7374 656d 7328  NumberOfSystems(
-0000d9d0: 7365 6c66 2920 2d3e 2069 6e74 3a20 2e2e  self) -> int: ..
-0000d9e0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-0000d9f0: 0d0a 2020 2020 6465 6620 4765 7453 7973  ..    def GetSys
-0000da00: 7465 6d28 7365 6c66 2c20 7379 7374 656d  tem(self, system
-0000da10: 4e75 6d62 6572 3a20 696e 7429 202d 3e20  Number: int) -> 
-0000da20: 4d61 696e 5379 7374 656d 3a20 2e2e 2e0d  MainSystem: ....
-0000da30: 0a20 2020 2076 6973 7561 6c69 7a61 7469  .    visualizati
-0000da40: 6f6e 5365 7474 696e 6773 3a56 6973 7561  onSettings:Visua
-0000da50: 6c69 7a61 7469 6f6e 5365 7474 696e 6773  lizationSettings
-0000da60: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000da70: 0a20 2020 2064 6566 2047 6574 4469 6374  .    def GetDict
-0000da80: 696f 6e61 7279 2873 656c 6629 202d 3e20  ionary(self) -> 
-0000da90: 6469 6374 3a20 2e2e 2e0d 0a20 2020 2040  dict: .....    @
-0000daa0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000dab0: 6620 5365 7444 6963 7469 6f6e 6172 7928  f SetDictionary(
-0000dac0: 7365 6c66 2c20 7379 7374 656d 4469 6374  self, systemDict
-0000dad0: 3a20 6469 6374 2920 2d3e 204e 6f6e 653a  : dict) -> None:
-0000dae0: 202e 2e2e 0d0a 2020 2020 406f 7665 726c   .....    @overl
-0000daf0: 6f61 640d 0a20 2020 2064 6566 2047 6574  oad..    def Get
-0000db00: 5265 6e64 6572 5374 6174 6528 7365 6c66  RenderState(self
-0000db10: 2920 2d3e 2064 6963 743a 202e 2e2e 0d0a  ) -> dict: .....
-0000db20: 2020 2020 406f 7665 726c 6f61 640d 0a20      @overload.. 
-0000db30: 2020 2064 6566 2053 6574 5265 6e64 6572     def SetRender
-0000db40: 5374 6174 6528 7365 6c66 2c20 7265 6e64  State(self, rend
-0000db50: 6572 5374 6174 653a 2064 6963 7429 202d  erState: dict) -
-0000db60: 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020  > None: .....   
-0000db70: 2040 6f76 6572 6c6f 6164 0d0a 2020 2020   @overload..    
-0000db80: 6465 6620 5265 6472 6177 416e 6453 6176  def RedrawAndSav
-0000db90: 6549 6d61 6765 2873 656c 6629 202d 3e20  eImage(self) -> 
-0000dba0: 4e6f 6e65 3a20 2e2e 2e0d 0a20 2020 2040  None: .....    @
-0000dbb0: 6f76 6572 6c6f 6164 0d0a 2020 2020 6465  overload..    de
-0000dbc0: 6620 5761 6974 466f 7252 656e 6465 7245  f WaitForRenderE
-0000dbd0: 6e67 696e 6553 746f 7046 6c61 6728 7365  ngineStopFlag(se
-0000dbe0: 6c66 2920 2d3e 2062 6f6f 6c3a 202e 2e2e  lf) -> bool: ...
-0000dbf0: 0d0a 2020 2020 406f 7665 726c 6f61 640d  ..    @overload.
-0000dc00: 0a20 2020 2064 6566 2052 656e 6465 7245  .    def RenderE
-0000dc10: 6e67 696e 655a 6f6f 6d41 6c6c 2873 656c  ngineZoomAll(sel
-0000dc20: 6629 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d  f) -> None: ....
-0000dc30: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000dc40: 2020 2020 6465 6620 4174 7461 6368 546f      def AttachTo
-0000dc50: 5265 6e64 6572 456e 6769 6e65 2873 656c  RenderEngine(sel
-0000dc60: 6629 202d 3e20 626f 6f6c 3a20 2e2e 2e0d  f) -> bool: ....
-0000dc70: 0a20 2020 2040 6f76 6572 6c6f 6164 0d0a  .    @overload..
-0000dc80: 2020 2020 6465 6620 4465 7461 6368 4672      def DetachFr
-0000dc90: 6f6d 5265 6e64 6572 456e 6769 6e65 2873  omRenderEngine(s
-0000dca0: 656c 6629 202d 3e20 626f 6f6c 3a20 2e2e  elf) -> bool: ..
-0000dcb0: 2e0d 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
-0000dcc0: 0d0a 2020 2020 6465 6620 5365 6e64 5265  ..    def SendRe
-0000dcd0: 6472 6177 5369 676e 616c 2873 656c 6629  drawSignal(self)
-0000dce0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0d 0a20   -> None: ..... 
-0000dcf0: 2020 2040 6f76 6572 6c6f 6164 0d0a 2020     @overload..  
-0000dd00: 2020 6465 6620 4765 7443 7572 7265 6e74    def GetCurrent
-0000dd10: 4d6f 7573 6543 6f6f 7264 696e 6174 6573  MouseCoordinates
-0000dd20: 2873 656c 662c 2075 7365 4f70 656e 474c  (self, useOpenGL
-0000dd30: 636f 6f72 6469 6e61 7465 733d 4661 6c73  coordinates=Fals
-0000dd40: 6529 202d 3e20 5b66 6c6f 6174 2c66 6c6f  e) -> [float,flo
-0000dd50: 6174 5d3a 202e 2e2e 0d0a 0d0a            at]: .......
+00005e70: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00005e80: 640a 2020 2020 6465 6620 496e 6974 6961  d.    def Initia
+00005e90: 6c69 7a65 536f 6c76 6572 286d 6169 6e53  lizeSolver(mainS
+00005ea0: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
+00005eb0: 6e53 6574 7469 6e67 7329 202d 3e20 626f  nSettings) -> bo
+00005ec0: 6f6c 3a20 2e2e 2e0a 2020 2020 406f 7665  ol: ....    @ove
+00005ed0: 726c 6f61 640a 2020 2020 6465 6620 496e  rload.    def In
+00005ee0: 6974 6961 6c69 7a65 536f 6c76 6572 4461  itializeSolverDa
+00005ef0: 7461 286d 6169 6e53 7973 7465 6d2c 2073  ta(mainSystem, s
+00005f00: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+00005f10: 7329 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  s) -> None: ....
+00005f20: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00005f30: 2020 6465 6620 496e 6974 6961 6c69 7a65    def Initialize
+00005f40: 536f 6c76 6572 496e 6974 6961 6c43 6f6e  SolverInitialCon
+00005f50: 6469 7469 6f6e 7328 6d61 696e 5379 7374  ditions(mainSyst
+00005f60: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+00005f70: 7474 696e 6773 2920 2d3e 204e 6f6e 653a  ttings) -> None:
+00005f80: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00005f90: 6164 0a20 2020 2064 6566 2049 6e69 7469  ad.    def Initi
+00005fa0: 616c 697a 6553 6f6c 7665 724f 7574 7075  alizeSolverOutpu
+00005fb0: 7428 6d61 696e 5379 7374 656d 2c20 7369  t(mainSystem, si
+00005fc0: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00005fd0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00005fe0: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00005ff0: 2064 6566 2049 6e69 7469 616c 697a 6553   def InitializeS
+00006000: 6f6c 7665 7250 7265 4368 6563 6b73 286d  olverPreChecks(m
+00006010: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
+00006020: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
+00006030: 3e20 626f 6f6c 3a20 2e2e 2e0a 2020 2020  > bool: ....    
+00006040: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00006050: 6620 496e 6974 6961 6c69 7a65 5374 6570  f InitializeStep
+00006060: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+00006070: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+00006080: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+00006090: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+000060a0: 6465 6620 4973 5374 6174 6963 536f 6c76  def IsStaticSolv
+000060b0: 6572 2829 202d 3e20 626f 6f6c 3a20 2e2e  er() -> bool: ..
+000060c0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+000060d0: 2020 2020 6465 6620 4973 5665 7262 6f73      def IsVerbos
+000060e0: 6543 6865 636b 286c 6576 656c 2920 2d3e  eCheck(level) ->
+000060f0: 2062 6f6f 6c3a 202e 2e2e 0a20 2020 206c   bool: ....    l
+00006100: 6f61 6453 7465 7047 656f 6d65 7472 6963  oadStepGeometric
+00006110: 4661 6374 6f72 3a20 666c 6f61 740a 2020  Factor: float.  
+00006120: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00006130: 6465 6620 4e65 7774 6f6e 286d 6169 6e53  def Newton(mainS
+00006140: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
+00006150: 6e53 6574 7469 6e67 7329 202d 3e20 626f  nSettings) -> bo
+00006160: 6f6c 3a20 2e2e 2e0a 2020 2020 406f 7665  ol: ....    @ove
+00006170: 726c 6f61 640a 2020 2020 6465 6620 506f  rload.    def Po
+00006180: 7374 496e 6974 6961 6c69 7a65 536f 6c76  stInitializeSolv
+00006190: 6572 5370 6563 6966 6963 286d 6169 6e53  erSpecific(mainS
+000061a0: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
+000061b0: 6e53 6574 7469 6e67 7329 202d 3e20 4e6f  nSettings) -> No
+000061c0: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+000061d0: 726c 6f61 640a 2020 2020 6465 6620 5072  rload.    def Pr
+000061e0: 6549 6e69 7469 616c 697a 6553 6f6c 7665  eInitializeSolve
+000061f0: 7253 7065 6369 6669 6328 6d61 696e 5379  rSpecific(mainSy
+00006200: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
+00006210: 5365 7474 696e 6773 2920 2d3e 204e 6f6e  Settings) -> Non
+00006220: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+00006230: 6c6f 6164 0a20 2020 2064 6566 2052 6564  load.    def Red
+00006240: 7563 6553 7465 7053 697a 6528 6d61 696e  uceStepSize(main
+00006250: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00006260: 6f6e 5365 7474 696e 6773 2c20 7365 7665  onSettings, seve
+00006270: 7269 7479 2920 2d3e 2062 6f6f 6c3a 202e  rity) -> bool: .
+00006280: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00006290: 0a20 2020 2064 6566 2053 6574 5379 7374  .    def SetSyst
+000062a0: 656d 4a61 636f 6269 616e 2873 7973 7465  emJacobian(syste
+000062b0: 6d4a 6163 6f62 6961 6e29 202d 3e20 4e6f  mJacobian) -> No
+000062c0: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+000062d0: 726c 6f61 640a 2020 2020 6465 6620 5365  rload.    def Se
+000062e0: 7453 7973 7465 6d4d 6173 734d 6174 7269  tSystemMassMatri
+000062f0: 7828 7379 7374 656d 4d61 7373 4d61 7472  x(systemMassMatr
+00006300: 6978 2920 2d3e 204e 6f6e 653a 202e 2e2e  ix) -> None: ...
+00006310: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00006320: 2020 2064 6566 2053 6574 5379 7374 656d     def SetSystem
+00006330: 5265 7369 6475 616c 2873 7973 7465 6d52  Residual(systemR
+00006340: 6573 6964 7561 6c29 202d 3e20 4e6f 6e65  esidual) -> None
+00006350: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00006360: 6f61 640a 2020 2020 6465 6620 536f 6c76  oad.    def Solv
+00006370: 6553 7465 7073 286d 6169 6e53 7973 7465  eSteps(mainSyste
+00006380: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
+00006390: 7469 6e67 7329 202d 3e20 626f 6f6c 3a20  tings) -> bool: 
+000063a0: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+000063b0: 640a 2020 2020 6465 6620 536f 6c76 6553  d.    def SolveS
+000063c0: 7973 7465 6d28 6d61 696e 5379 7374 656d  ystem(mainSystem
+000063d0: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
+000063e0: 696e 6773 2920 2d3e 2062 6f6f 6c3a 202e  ings) -> bool: .
+000063f0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00006400: 0a20 2020 2064 6566 2055 7064 6174 6543  .    def UpdateC
+00006410: 7572 7265 6e74 5469 6d65 286d 6169 6e53  urrentTime(mainS
+00006420: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
+00006430: 6e53 6574 7469 6e67 7329 202d 3e20 4e6f  nSettings) -> No
+00006440: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+00006450: 726c 6f61 640a 2020 2020 6465 6620 5665  rload.    def Ve
+00006460: 7262 6f73 6557 7269 7465 286c 6576 656c  rboseWrite(level
+00006470: 2c20 7374 7229 202d 3e20 4e6f 6e65 3a20  , str) -> None: 
+00006480: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00006490: 640a 2020 2020 6465 6620 5772 6974 6543  d.    def WriteC
+000064a0: 6f6f 7264 696e 6174 6573 546f 4669 6c65  oordinatesToFile
+000064b0: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+000064c0: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+000064d0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+000064e0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+000064f0: 6465 6620 5772 6974 6553 6f6c 7574 696f  def WriteSolutio
+00006500: 6e46 696c 6548 6561 6465 7228 6d61 696e  nFileHeader(main
+00006510: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00006520: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
+00006530: 6f6e 653a 202e 2e2e 0a0a 0a63 6c61 7373  one: ......class
+00006540: 204d 6169 6e53 6f6c 7665 7249 6d70 6c69   MainSolverImpli
+00006550: 6369 7453 6563 6f6e 644f 7264 6572 3a0a  citSecondOrder:.
+00006560: 2020 2020 636f 6e76 3a20 536f 6c76 6572      conv: Solver
+00006570: 436f 6e76 6572 6765 6e63 6544 6174 610a  ConvergenceData.
+00006580: 2020 2020 6974 3a20 536f 6c76 6572 4974      it: SolverIt
+00006590: 6572 6174 696f 6e44 6174 610a 2020 2020  erationData.    
+000065a0: 6e65 7774 6f6e 3a20 4e65 7774 6f6e 5365  newton: NewtonSe
+000065b0: 7474 696e 6773 0a20 2020 206f 7574 7075  ttings.    outpu
+000065c0: 743a 2053 6f6c 7665 724f 7574 7075 7444  t: SolverOutputD
+000065d0: 6174 610a 2020 2020 7469 6d65 723a 2043  ata.    timer: C
+000065e0: 536f 6c76 6572 5469 6d65 720a 2020 2020  SolverTimer.    
+000065f0: 616c 7068 6146 3a20 666c 6f61 740a 2020  alphaF: float.  
+00006600: 2020 616c 7068 614d 3a20 666c 6f61 740a    alphaM: float.
+00006610: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00006620: 2020 6465 6620 4368 6563 6b49 6e69 7469    def CheckIniti
+00006630: 616c 697a 6564 286d 6169 6e53 7973 7465  alized(mainSyste
+00006640: 6d29 202d 3e20 626f 6f6c 3a20 2e2e 2e0a  m) -> bool: ....
+00006650: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00006660: 2020 6465 6620 436f 6d70 7574 6541 6c67    def ComputeAlg
+00006670: 6562 7261 6963 4571 7561 7469 6f6e 7328  ebraicEquations(
+00006680: 6d61 696e 5379 7374 656d 2c20 7665 6c6f  mainSystem, velo
+00006690: 6369 7479 4c65 7665 6c3d 4661 6c73 6529  cityLevel=False)
+000066a0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+000066b0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+000066c0: 6465 6620 436f 6d70 7574 654a 6163 6f62  def ComputeJacob
+000066d0: 6961 6e41 4528 6d61 696e 5379 7374 656d  ianAE(mainSystem
+000066e0: 2c20 7363 616c 6172 4661 6374 6f72 5f4f  , scalarFactor_O
+000066f0: 4445 323d 312e 2c20 7363 616c 6172 4661  DE2=1., scalarFa
+00006700: 6374 6f72 5f4f 4445 325f 743d 302e 2c20  ctor_ODE2_t=0., 
+00006710: 7363 616c 6172 4661 6374 6f72 5f4f 4445  scalarFactor_ODE
+00006720: 313d 312e 2c20 7665 6c6f 6369 7479 4c65  1=1., velocityLe
+00006730: 7665 6c3d 4661 6c73 6529 202d 3e20 4e6f  vel=False) -> No
+00006740: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+00006750: 726c 6f61 640a 2020 2020 6465 6620 436f  rload.    def Co
+00006760: 6d70 7574 654a 6163 6f62 6961 6e4f 4445  mputeJacobianODE
+00006770: 3152 4853 286d 6169 6e53 7973 7465 6d2c  1RHS(mainSystem,
+00006780: 2073 6361 6c61 7246 6163 746f 725f 4f44   scalarFactor_OD
+00006790: 4532 3d31 2e2c 2073 6361 6c61 7246 6163  E2=1., scalarFac
+000067a0: 746f 725f 4f44 4532 5f74 3d30 2e2c 2073  tor_ODE2_t=0., s
+000067b0: 6361 6c61 7246 6163 746f 725f 4f44 4531  calarFactor_ODE1
+000067c0: 3d31 2e29 202d 3e20 4e6f 6e65 3a20 2e2e  =1.) -> None: ..
+000067d0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+000067e0: 2020 2020 6465 6620 436f 6d70 7574 654a      def ComputeJ
+000067f0: 6163 6f62 6961 6e4f 4445 3252 4853 286d  acobianODE2RHS(m
+00006800: 6169 6e53 7973 7465 6d2c 2073 6361 6c61  ainSystem, scala
+00006810: 7246 6163 746f 725f 4f44 4532 3d31 2e2c  rFactor_ODE2=1.,
+00006820: 2073 6361 6c61 7246 6163 746f 725f 4f44   scalarFactor_OD
+00006830: 4532 5f74 3d30 2e2c 2073 6361 6c61 7246  E2_t=0., scalarF
+00006840: 6163 746f 725f 4f44 4531 3d31 2e2c 2063  actor_ODE1=1., c
+00006850: 6f6d 7075 7465 4c6f 6164 734a 6163 6f62  omputeLoadsJacob
+00006860: 6961 6e3d 3029 202d 3e20 4e6f 6e65 3a20  ian=0) -> None: 
+00006870: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00006880: 640a 2020 2020 6465 6620 436f 6d70 7574  d.    def Comput
+00006890: 654c 6f61 6446 6163 746f 7228 7369 6d75  eLoadFactor(simu
+000068a0: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
+000068b0: 2d3e 2066 6c6f 6174 3a20 2e2e 2e0a 2020  -> float: ....  
+000068c0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+000068d0: 6465 6620 436f 6d70 7574 654d 6173 734d  def ComputeMassM
+000068e0: 6174 7269 7828 6d61 696e 5379 7374 656d  atrix(mainSystem
+000068f0: 2c20 7363 616c 6172 4661 6374 6f72 3d31  , scalarFactor=1
+00006900: 2e29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  .) -> None: ....
+00006910: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00006920: 2020 6465 6620 436f 6d70 7574 654e 6577    def ComputeNew
+00006930: 746f 6e4a 6163 6f62 6961 6e28 6d61 696e  tonJacobian(main
+00006940: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00006950: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
+00006960: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00006970: 6572 6c6f 6164 0a20 2020 2064 6566 2043  erload.    def C
+00006980: 6f6d 7075 7465 4e65 7774 6f6e 5265 7369  omputeNewtonResi
+00006990: 6475 616c 286d 6169 6e53 7973 7465 6d2c  dual(mainSystem,
+000069a0: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
+000069b0: 6e67 7329 202d 3e20 666c 6f61 743a 202e  ngs) -> float: .
+000069c0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+000069d0: 0a20 2020 2064 6566 2043 6f6d 7075 7465  .    def Compute
+000069e0: 4e65 7774 6f6e 5570 6461 7465 286d 6169  NewtonUpdate(mai
+000069f0: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
+00006a00: 696f 6e53 6574 7469 6e67 732c 2069 6e69  ionSettings, ini
+00006a10: 7469 616c 3d54 7275 6529 202d 3e20 4e6f  tial=True) -> No
+00006a20: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+00006a30: 726c 6f61 640a 2020 2020 6465 6620 436f  rload.    def Co
+00006a40: 6d70 7574 654f 4445 3152 4853 286d 6169  mputeODE1RHS(mai
+00006a50: 6e53 7973 7465 6d29 202d 3e20 4e6f 6e65  nSystem) -> None
+00006a60: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00006a70: 6f61 640a 2020 2020 6465 6620 436f 6d70  oad.    def Comp
+00006a80: 7574 654f 4445 3252 4853 286d 6169 6e53  uteODE2RHS(mainS
+00006a90: 7973 7465 6d29 202d 3e20 4e6f 6e65 3a20  ystem) -> None: 
+00006aa0: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00006ab0: 640a 2020 2020 6465 6620 4469 7363 6f6e  d.    def Discon
+00006ac0: 7469 6e75 6f75 7349 7465 7261 7469 6f6e  tinuousIteration
+00006ad0: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+00006ae0: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+00006af0: 202d 3e20 626f 6f6c 3a20 2e2e 2e0a 2020   -> bool: ....  
+00006b00: 2020 6661 6374 4a61 6341 6c67 6f72 6974    factJacAlgorit
+00006b10: 686d 6963 3a20 666c 6f61 740a 2020 2020  hmic: float.    
+00006b20: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00006b30: 6620 4669 6e61 6c69 7a65 536f 6c76 6572  f FinalizeSolver
+00006b40: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+00006b50: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+00006b60: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+00006b70: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00006b80: 6465 6620 4669 6e69 7368 5374 6570 286d  def FinishStep(m
+00006b90: 6169 6e53 7973 7465 6d2c 2073 696d 756c  ainSystem, simul
+00006ba0: 6174 696f 6e53 6574 7469 6e67 7329 202d  ationSettings) -
+00006bb0: 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020 2020  > None: ....    
+00006bc0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00006bd0: 6620 4765 7441 416c 676f 7269 7468 6d69  f GetAAlgorithmi
+00006be0: 6328 2920 2d3e 2041 7272 6179 4c69 6b65  c() -> ArrayLike
+00006bf0: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00006c00: 6f61 640a 2020 2020 6465 6620 4765 7441  oad.    def GetA
+00006c10: 4573 697a 6528 2920 2d3e 2069 6e74 3a20  Esize() -> int: 
+00006c20: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00006c30: 640a 2020 2020 6465 6620 4765 7444 6174  d.    def GetDat
+00006c40: 6153 697a 6528 2920 2d3e 2069 6e74 3a20  aSize() -> int: 
+00006c50: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00006c60: 640a 2020 2020 6465 6620 4765 7445 7272  d.    def GetErr
+00006c70: 6f72 5374 7269 6e67 2829 202d 3e20 7374  orString() -> st
+00006c80: 723a 202e 2e2e 0a20 2020 2040 6f76 6572  r: ....    @over
+00006c90: 6c6f 6164 0a20 2020 2064 6566 2047 6574  load.    def Get
+00006ca0: 4e65 7774 6f6e 536f 6c75 7469 6f6e 2829  NewtonSolution()
+00006cb0: 202d 3e20 4172 7261 794c 696b 653a 202e   -> ArrayLike: .
+00006cc0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00006cd0: 0a20 2020 2064 6566 2047 6574 4f44 4531  .    def GetODE1
+00006ce0: 7369 7a65 2829 202d 3e20 696e 743a 202e  size() -> int: .
+00006cf0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00006d00: 0a20 2020 2064 6566 2047 6574 4f44 4532  .    def GetODE2
+00006d10: 7369 7a65 2829 202d 3e20 696e 743a 202e  size() -> int: .
+00006d20: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00006d30: 0a20 2020 2064 6566 2047 6574 5369 6d75  .    def GetSimu
+00006d40: 6c61 7469 6f6e 456e 6454 696d 6528 7369  lationEndTime(si
+00006d50: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00006d60: 2920 2d3e 2066 6c6f 6174 3a20 2e2e 2e0a  ) -> float: ....
+00006d70: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00006d80: 2020 6465 6620 4765 7453 6f6c 7665 724e    def GetSolverN
+00006d90: 616d 6528 2920 2d3e 2073 7472 3a20 2e2e  ame() -> str: ..
+00006da0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+00006db0: 2020 2020 6465 6620 4765 7453 7461 7274      def GetStart
+00006dc0: 4f66 5374 6570 5374 6174 6541 416c 676f  OfStepStateAAlgo
+00006dd0: 7269 7468 6d69 6328 2920 2d3e 2041 7272  rithmic() -> Arr
+00006de0: 6179 4c69 6b65 3a20 2e2e 2e0a 2020 2020  ayLike: ....    
+00006df0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00006e00: 6620 4765 7453 7973 7465 6d4a 6163 6f62  f GetSystemJacob
+00006e10: 6961 6e28 2920 2d3e 2041 7272 6179 4c69  ian() -> ArrayLi
+00006e20: 6b65 3a20 2e2e 2e0a 2020 2020 406f 7665  ke: ....    @ove
+00006e30: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+00006e40: 7453 7973 7465 6d4d 6173 734d 6174 7269  tSystemMassMatri
+00006e50: 7828 2920 2d3e 2041 7272 6179 4c69 6b65  x() -> ArrayLike
+00006e60: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00006e70: 6f61 640a 2020 2020 6465 6620 4765 7453  oad.    def GetS
+00006e80: 7973 7465 6d52 6573 6964 7561 6c28 2920  ystemResidual() 
+00006e90: 2d3e 2041 7272 6179 4c69 6b65 3a20 2e2e  -> ArrayLike: ..
+00006ea0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+00006eb0: 2020 2020 6465 6620 4861 7341 7574 6f6d      def HasAutom
+00006ec0: 6174 6963 5374 6570 5369 7a65 436f 6e74  aticStepSizeCont
+00006ed0: 726f 6c28 6d61 696e 5379 7374 656d 2c20  rol(mainSystem, 
+00006ee0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+00006ef0: 6773 2920 2d3e 2062 6f6f 6c3a 202e 2e2e  gs) -> bool: ...
+00006f00: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00006f10: 2020 2064 6566 2049 6e63 7265 6173 6553     def IncreaseS
+00006f20: 7465 7053 697a 6528 6d61 696e 5379 7374  tepSize(mainSyst
+00006f30: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+00006f40: 7474 696e 6773 2920 2d3e 204e 6f6e 653a  ttings) -> None:
+00006f50: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00006f60: 6164 0a20 2020 2064 6566 2049 6e69 7469  ad.    def Initi
+00006f70: 616c 697a 6553 6f6c 7665 7228 6d61 696e  alizeSolver(main
+00006f80: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00006f90: 6f6e 5365 7474 696e 6773 2920 2d3e 2062  onSettings) -> b
+00006fa0: 6f6f 6c3a 202e 2e2e 0a20 2020 2040 6f76  ool: ....    @ov
+00006fb0: 6572 6c6f 6164 0a20 2020 2064 6566 2049  erload.    def I
+00006fc0: 6e69 7469 616c 697a 6553 6f6c 7665 7244  nitializeSolverD
+00006fd0: 6174 6128 6d61 696e 5379 7374 656d 2c20  ata(mainSystem, 
+00006fe0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+00006ff0: 6773 2920 2d3e 204e 6f6e 653a 202e 2e2e  gs) -> None: ...
+00007000: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00007010: 2020 2064 6566 2049 6e69 7469 616c 697a     def Initializ
+00007020: 6553 6f6c 7665 7249 6e69 7469 616c 436f  eSolverInitialCo
+00007030: 6e64 6974 696f 6e73 286d 6169 6e53 7973  nditions(mainSys
+00007040: 7465 6d2c 2073 696d 756c 6174 696f 6e53  tem, simulationS
+00007050: 6574 7469 6e67 7329 202d 3e20 4e6f 6e65  ettings) -> None
+00007060: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00007070: 6f61 640a 2020 2020 6465 6620 496e 6974  oad.    def Init
+00007080: 6961 6c69 7a65 536f 6c76 6572 4f75 7470  ializeSolverOutp
+00007090: 7574 286d 6169 6e53 7973 7465 6d2c 2073  ut(mainSystem, s
+000070a0: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+000070b0: 7329 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  s) -> None: ....
+000070c0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+000070d0: 2020 6465 6620 496e 6974 6961 6c69 7a65    def Initialize
+000070e0: 536f 6c76 6572 5072 6543 6865 636b 7328  SolverPreChecks(
+000070f0: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
+00007100: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
+00007110: 2d3e 2062 6f6f 6c3a 202e 2e2e 0a20 2020  -> bool: ....   
+00007120: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00007130: 6566 2049 6e69 7469 616c 697a 6553 7465  ef InitializeSte
+00007140: 7028 6d61 696e 5379 7374 656d 2c20 7369  p(mainSystem, si
+00007150: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00007160: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00007170: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00007180: 2064 6566 2049 7353 7461 7469 6353 6f6c   def IsStaticSol
+00007190: 7665 7228 2920 2d3e 2062 6f6f 6c3a 202e  ver() -> bool: .
+000071a0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+000071b0: 0a20 2020 2064 6566 2049 7356 6572 626f  .    def IsVerbo
+000071c0: 7365 4368 6563 6b28 6c65 7665 6c29 202d  seCheck(level) -
+000071d0: 3e20 626f 6f6c 3a20 2e2e 2e0a 2020 2020  > bool: ....    
+000071e0: 6e65 776d 6172 6b42 6574 613a 2066 6c6f  newmarkBeta: flo
+000071f0: 6174 0a20 2020 206e 6577 6d61 726b 4761  at.    newmarkGa
+00007200: 6d6d 613a 2066 6c6f 6174 0a20 2020 2040  mma: float.    @
+00007210: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+00007220: 204e 6577 746f 6e28 6d61 696e 5379 7374   Newton(mainSyst
+00007230: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+00007240: 7474 696e 6773 2920 2d3e 2062 6f6f 6c3a  ttings) -> bool:
+00007250: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00007260: 6164 0a20 2020 2064 6566 2050 6f73 7449  ad.    def PostI
+00007270: 6e69 7469 616c 697a 6553 6f6c 7665 7253  nitializeSolverS
+00007280: 7065 6369 6669 6328 6d61 696e 5379 7374  pecific(mainSyst
+00007290: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+000072a0: 7474 696e 6773 2920 2d3e 204e 6f6e 653a  ttings) -> None:
+000072b0: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+000072c0: 6164 0a20 2020 2064 6566 2050 6f73 744e  ad.    def PostN
+000072d0: 6577 746f 6e28 6d61 696e 5379 7374 656d  ewton(mainSystem
+000072e0: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
+000072f0: 696e 6773 2920 2d3e 2066 6c6f 6174 3a20  ings) -> float: 
+00007300: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00007310: 640a 2020 2020 6465 6620 5072 6549 6e69  d.    def PreIni
+00007320: 7469 616c 697a 6553 6f6c 7665 7253 7065  tializeSolverSpe
+00007330: 6369 6669 6328 6d61 696e 5379 7374 656d  cific(mainSystem
+00007340: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
+00007350: 696e 6773 2920 2d3e 204e 6f6e 653a 202e  ings) -> None: .
+00007360: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00007370: 0a20 2020 2064 6566 2052 6564 7563 6553  .    def ReduceS
+00007380: 7465 7053 697a 6528 6d61 696e 5379 7374  tepSize(mainSyst
+00007390: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+000073a0: 7474 696e 6773 2c20 7365 7665 7269 7479  ttings, severity
+000073b0: 2920 2d3e 2062 6f6f 6c3a 202e 2e2e 0a20  ) -> bool: .... 
+000073c0: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+000073d0: 2064 6566 2053 6574 5379 7374 656d 4a61   def SetSystemJa
+000073e0: 636f 6269 616e 2873 7973 7465 6d4a 6163  cobian(systemJac
+000073f0: 6f62 6961 6e29 202d 3e20 4e6f 6e65 3a20  obian) -> None: 
+00007400: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00007410: 640a 2020 2020 6465 6620 5365 7453 7973  d.    def SetSys
+00007420: 7465 6d4d 6173 734d 6174 7269 7828 7379  temMassMatrix(sy
+00007430: 7374 656d 4d61 7373 4d61 7472 6978 2920  stemMassMatrix) 
+00007440: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+00007450: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00007460: 6566 2053 6574 5379 7374 656d 5265 7369  ef SetSystemResi
+00007470: 6475 616c 2873 7973 7465 6d52 6573 6964  dual(systemResid
+00007480: 7561 6c29 202d 3e20 4e6f 6e65 3a20 2e2e  ual) -> None: ..
+00007490: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+000074a0: 2020 2020 6465 6620 5365 7455 7365 7246      def SetUserF
+000074b0: 756e 6374 696f 6e43 6f6d 7075 7465 4e65  unctionComputeNe
+000074c0: 7774 6f6e 4a61 636f 6269 616e 286d 6169  wtonJacobian(mai
+000074d0: 6e53 7973 7465 6d2c 2075 7365 7246 756e  nSystem, userFun
+000074e0: 6374 696f 6e29 202d 3e20 4e6f 6e65 3a20  ction) -> None: 
+000074f0: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00007500: 640a 2020 2020 6465 6620 5365 7455 7365  d.    def SetUse
+00007510: 7246 756e 6374 696f 6e43 6f6d 7075 7465  rFunctionCompute
+00007520: 4e65 7774 6f6e 5265 7369 6475 616c 286d  NewtonResidual(m
+00007530: 6169 6e53 7973 7465 6d2c 2075 7365 7246  ainSystem, userF
+00007540: 756e 6374 696f 6e29 202d 3e20 4e6f 6e65  unction) -> None
+00007550: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00007560: 6f61 640a 2020 2020 6465 6620 5365 7455  oad.    def SetU
+00007570: 7365 7246 756e 6374 696f 6e43 6f6d 7075  serFunctionCompu
+00007580: 7465 4e65 7774 6f6e 5570 6461 7465 286d  teNewtonUpdate(m
+00007590: 6169 6e53 7973 7465 6d2c 2075 7365 7246  ainSystem, userF
+000075a0: 756e 6374 696f 6e29 202d 3e20 4e6f 6e65  unction) -> None
+000075b0: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+000075c0: 6f61 640a 2020 2020 6465 6620 5365 7455  oad.    def SetU
+000075d0: 7365 7246 756e 6374 696f 6e44 6973 636f  serFunctionDisco
+000075e0: 6e74 696e 756f 7573 4974 6572 6174 696f  ntinuousIteratio
+000075f0: 6e28 6d61 696e 5379 7374 656d 2c20 7573  n(mainSystem, us
+00007600: 6572 4675 6e63 7469 6f6e 2920 2d3e 204e  erFunction) -> N
+00007610: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00007620: 6572 6c6f 6164 0a20 2020 2064 6566 2053  erload.    def S
+00007630: 6574 5573 6572 4675 6e63 7469 6f6e 4669  etUserFunctionFi
+00007640: 6e69 7368 5374 6570 286d 6169 6e53 7973  nishStep(mainSys
+00007650: 7465 6d2c 2075 7365 7246 756e 6374 696f  tem, userFunctio
+00007660: 6e29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  n) -> None: ....
+00007670: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00007680: 2020 6465 6620 5365 7455 7365 7246 756e    def SetUserFun
+00007690: 6374 696f 6e49 6e69 7469 616c 697a 6553  ctionInitializeS
+000076a0: 7465 7028 6d61 696e 5379 7374 656d 2c20  tep(mainSystem, 
+000076b0: 7573 6572 4675 6e63 7469 6f6e 2920 2d3e  userFunction) ->
+000076c0: 204e 6f6e 653a 202e 2e2e 0a20 2020 2040   None: ....    @
+000076d0: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+000076e0: 2053 6574 5573 6572 4675 6e63 7469 6f6e   SetUserFunction
+000076f0: 4e65 7774 6f6e 286d 6169 6e53 7973 7465  Newton(mainSyste
+00007700: 6d2c 2075 7365 7246 756e 6374 696f 6e29  m, userFunction)
+00007710: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+00007720: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00007730: 6465 6620 5365 7455 7365 7246 756e 6374  def SetUserFunct
+00007740: 696f 6e50 6f73 744e 6577 746f 6e28 6d61  ionPostNewton(ma
+00007750: 696e 5379 7374 656d 2c20 7573 6572 4675  inSystem, userFu
+00007760: 6e63 7469 6f6e 2920 2d3e 204e 6f6e 653a  nction) -> None:
+00007770: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00007780: 6164 0a20 2020 2064 6566 2053 6574 5573  ad.    def SetUs
+00007790: 6572 4675 6e63 7469 6f6e 5570 6461 7465  erFunctionUpdate
+000077a0: 4375 7272 656e 7454 696d 6528 6d61 696e  CurrentTime(main
+000077b0: 5379 7374 656d 2c20 7573 6572 4675 6e63  System, userFunc
+000077c0: 7469 6f6e 2920 2d3e 204e 6f6e 653a 202e  tion) -> None: .
+000077d0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+000077e0: 0a20 2020 2064 6566 2053 6f6c 7665 5374  .    def SolveSt
+000077f0: 6570 7328 6d61 696e 5379 7374 656d 2c20  eps(mainSystem, 
+00007800: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+00007810: 6773 2920 2d3e 2062 6f6f 6c3a 202e 2e2e  gs) -> bool: ...
+00007820: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00007830: 2020 2064 6566 2053 6f6c 7665 5379 7374     def SolveSyst
+00007840: 656d 286d 6169 6e53 7973 7465 6d2c 2073  em(mainSystem, s
+00007850: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+00007860: 7329 202d 3e20 626f 6f6c 3a20 2e2e 2e0a  s) -> bool: ....
+00007870: 2020 2020 7370 6563 7472 616c 5261 6469      spectralRadi
+00007880: 7573 3a20 666c 6f61 740a 2020 2020 406f  us: float.    @o
+00007890: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+000078a0: 5570 6461 7465 4375 7272 656e 7454 696d  UpdateCurrentTim
+000078b0: 6528 6d61 696e 5379 7374 656d 2c20 7369  e(mainSystem, si
+000078c0: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+000078d0: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+000078e0: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+000078f0: 2064 6566 2056 6572 626f 7365 5772 6974   def VerboseWrit
+00007900: 6528 6c65 7665 6c2c 2073 7472 2920 2d3e  e(level, str) ->
+00007910: 204e 6f6e 653a 202e 2e2e 0a20 2020 2040   None: ....    @
+00007920: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+00007930: 2057 7269 7465 436f 6f72 6469 6e61 7465   WriteCoordinate
+00007940: 7354 6f46 696c 6528 6d61 696e 5379 7374  sToFile(mainSyst
+00007950: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+00007960: 7474 696e 6773 2920 2d3e 204e 6f6e 653a  ttings) -> None:
+00007970: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00007980: 6164 0a20 2020 2064 6566 2057 7269 7465  ad.    def Write
+00007990: 536f 6c75 7469 6f6e 4669 6c65 4865 6164  SolutionFileHead
+000079a0: 6572 286d 6169 6e53 7973 7465 6d2c 2073  er(mainSystem, s
+000079b0: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+000079c0: 7329 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  s) -> None: ....
+000079d0: 0a0a 636c 6173 7320 4d61 696e 536f 6c76  ..class MainSolv
+000079e0: 6572 4578 706c 6963 6974 3a0a 2020 2020  erExplicit:.    
+000079f0: 636f 6e76 3a20 536f 6c76 6572 436f 6e76  conv: SolverConv
+00007a00: 6572 6765 6e63 6544 6174 610a 2020 2020  ergenceData.    
+00007a10: 6974 3a20 536f 6c76 6572 4974 6572 6174  it: SolverIterat
+00007a20: 696f 6e44 6174 610a 2020 2020 6f75 7470  ionData.    outp
+00007a30: 7574 3a20 536f 6c76 6572 4f75 7470 7574  ut: SolverOutput
+00007a40: 4461 7461 0a20 2020 2074 696d 6572 3a20  Data.    timer: 
+00007a50: 4353 6f6c 7665 7254 696d 6572 0a20 2020  CSolverTimer.   
+00007a60: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00007a70: 6566 2043 6f6d 7075 7465 4c6f 6164 4661  ef ComputeLoadFa
+00007a80: 6374 6f72 2873 696d 756c 6174 696f 6e53  ctor(simulationS
+00007a90: 6574 7469 6e67 7329 202d 3e20 666c 6f61  ettings) -> floa
+00007aa0: 743a 202e 2e2e 0a20 2020 2040 6f76 6572  t: ....    @over
+00007ab0: 6c6f 6164 0a20 2020 2064 6566 2043 6f6d  load.    def Com
+00007ac0: 7075 7465 4d61 7373 4d61 7472 6978 286d  puteMassMatrix(m
+00007ad0: 6169 6e53 7973 7465 6d2c 2073 6361 6c61  ainSystem, scala
+00007ae0: 7246 6163 746f 723d 312e 2920 2d3e 204e  rFactor=1.) -> N
+00007af0: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00007b00: 6572 6c6f 6164 0a20 2020 2064 6566 2043  erload.    def C
+00007b10: 6f6d 7075 7465 4e65 7774 6f6e 4a61 636f  omputeNewtonJaco
+00007b20: 6269 616e 286d 6169 6e53 7973 7465 6d2c  bian(mainSystem,
+00007b30: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
+00007b40: 6e67 7329 202d 3e20 4e6f 6e65 3a20 2e2e  ngs) -> None: ..
+00007b50: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+00007b60: 2020 2020 6465 6620 436f 6d70 7574 654e      def ComputeN
+00007b70: 6577 746f 6e52 6573 6964 7561 6c28 6d61  ewtonResidual(ma
+00007b80: 696e 5379 7374 656d 2c20 7369 6d75 6c61  inSystem, simula
+00007b90: 7469 6f6e 5365 7474 696e 6773 2920 2d3e  tionSettings) ->
+00007ba0: 2066 6c6f 6174 3a20 2e2e 2e0a 2020 2020   float: ....    
+00007bb0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00007bc0: 6620 436f 6d70 7574 654e 6577 746f 6e55  f ComputeNewtonU
+00007bd0: 7064 6174 6528 6d61 696e 5379 7374 656d  pdate(mainSystem
+00007be0: 2c20 7369 6d75 6c61 7469 6f6e 5365 7474  , simulationSett
+00007bf0: 696e 6773 2c20 696e 6974 6961 6c3d 5472  ings, initial=Tr
+00007c00: 7565 2920 2d3e 204e 6f6e 653a 202e 2e2e  ue) -> None: ...
+00007c10: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00007c20: 2020 2064 6566 2043 6f6d 7075 7465 4f44     def ComputeOD
+00007c30: 4531 5248 5328 6d61 696e 5379 7374 656d  E1RHS(mainSystem
+00007c40: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00007c50: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00007c60: 2064 6566 2043 6f6d 7075 7465 4f44 4532   def ComputeODE2
+00007c70: 5248 5328 6d61 696e 5379 7374 656d 2920  RHS(mainSystem) 
+00007c80: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+00007c90: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00007ca0: 6566 2044 6973 636f 6e74 696e 756f 7573  ef Discontinuous
+00007cb0: 4974 6572 6174 696f 6e28 6d61 696e 5379  Iteration(mainSy
+00007cc0: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
+00007cd0: 5365 7474 696e 6773 2920 2d3e 2062 6f6f  Settings) -> boo
+00007ce0: 6c3a 202e 2e2e 0a20 2020 2040 6f76 6572  l: ....    @over
+00007cf0: 6c6f 6164 0a20 2020 2064 6566 2046 696e  load.    def Fin
+00007d00: 616c 697a 6553 6f6c 7665 7228 6d61 696e  alizeSolver(main
+00007d10: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00007d20: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
+00007d30: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00007d40: 6572 6c6f 6164 0a20 2020 2064 6566 2046  erload.    def F
+00007d50: 696e 6973 6853 7465 7028 6d61 696e 5379  inishStep(mainSy
+00007d60: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
+00007d70: 5365 7474 696e 6773 2920 2d3e 204e 6f6e  Settings) -> Non
+00007d80: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+00007d90: 6c6f 6164 0a20 2020 2064 6566 2047 6574  load.    def Get
+00007da0: 4145 7369 7a65 2829 202d 3e20 696e 743a  AEsize() -> int:
+00007db0: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00007dc0: 6164 0a20 2020 2064 6566 2047 6574 4461  ad.    def GetDa
+00007dd0: 7461 5369 7a65 2829 202d 3e20 696e 743a  taSize() -> int:
+00007de0: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00007df0: 6164 0a20 2020 2064 6566 2047 6574 4572  ad.    def GetEr
+00007e00: 726f 7253 7472 696e 6728 2920 2d3e 2073  rorString() -> s
+00007e10: 7472 3a20 2e2e 2e0a 2020 2020 406f 7665  tr: ....    @ove
+00007e20: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+00007e30: 744d 6574 686f 644f 7264 6572 2829 202d  tMethodOrder() -
+00007e40: 3e20 696e 743a 202e 2e2e 0a20 2020 2040  > int: ....    @
+00007e50: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+00007e60: 2047 6574 4e75 6d62 6572 4f66 5374 6167   GetNumberOfStag
+00007e70: 6573 2829 202d 3e20 696e 743a 202e 2e2e  es() -> int: ...
+00007e80: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00007e90: 2020 2064 6566 2047 6574 4f44 4531 7369     def GetODE1si
+00007ea0: 7a65 2829 202d 3e20 696e 743a 202e 2e2e  ze() -> int: ...
+00007eb0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00007ec0: 2020 2064 6566 2047 6574 4f44 4532 7369     def GetODE2si
+00007ed0: 7a65 2829 202d 3e20 696e 743a 202e 2e2e  ze() -> int: ...
+00007ee0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00007ef0: 2020 2064 6566 2047 6574 5369 6d75 6c61     def GetSimula
+00007f00: 7469 6f6e 456e 6454 696d 6528 7369 6d75  tionEndTime(simu
+00007f10: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
+00007f20: 2d3e 2066 6c6f 6174 3a20 2e2e 2e0a 2020  -> float: ....  
+00007f30: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00007f40: 6465 6620 4765 7453 6f6c 7665 724e 616d  def GetSolverNam
+00007f50: 6528 2920 2d3e 2073 7472 3a20 2e2e 2e0a  e() -> str: ....
+00007f60: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00007f70: 2020 6465 6620 4765 7453 7973 7465 6d4d    def GetSystemM
+00007f80: 6173 734d 6174 7269 7828 2920 2d3e 2041  assMatrix() -> A
+00007f90: 7272 6179 4c69 6b65 3a20 2e2e 2e0a 2020  rrayLike: ....  
+00007fa0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00007fb0: 6465 6620 4765 7453 7973 7465 6d52 6573  def GetSystemRes
+00007fc0: 6964 7561 6c28 2920 2d3e 2041 7272 6179  idual() -> Array
+00007fd0: 4c69 6b65 3a20 2e2e 2e0a 2020 2020 406f  Like: ....    @o
+00007fe0: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00007ff0: 4861 7341 7574 6f6d 6174 6963 5374 6570  HasAutomaticStep
+00008000: 5369 7a65 436f 6e74 726f 6c28 6d61 696e  SizeControl(main
+00008010: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00008020: 6f6e 5365 7474 696e 6773 2920 2d3e 2062  onSettings) -> b
+00008030: 6f6f 6c3a 202e 2e2e 0a20 2020 2040 6f76  ool: ....    @ov
+00008040: 6572 6c6f 6164 0a20 2020 2064 6566 2049  erload.    def I
+00008050: 6e63 7265 6173 6553 7465 7053 697a 6528  ncreaseStepSize(
+00008060: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
+00008070: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
+00008080: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+00008090: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+000080a0: 6566 2049 6e69 7469 616c 697a 6553 6f6c  ef InitializeSol
+000080b0: 7665 7228 6d61 696e 5379 7374 656d 2c20  ver(mainSystem, 
+000080c0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+000080d0: 6773 2920 2d3e 2062 6f6f 6c3a 202e 2e2e  gs) -> bool: ...
+000080e0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+000080f0: 2020 2064 6566 2049 6e69 7469 616c 697a     def Initializ
+00008100: 6553 6f6c 7665 7244 6174 6128 6d61 696e  eSolverData(main
+00008110: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+00008120: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
+00008130: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00008140: 6572 6c6f 6164 0a20 2020 2064 6566 2049  erload.    def I
+00008150: 6e69 7469 616c 697a 6553 6f6c 7665 7249  nitializeSolverI
+00008160: 6e69 7469 616c 436f 6e64 6974 696f 6e73  nitialConditions
+00008170: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+00008180: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+00008190: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+000081a0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+000081b0: 6465 6620 496e 6974 6961 6c69 7a65 536f  def InitializeSo
+000081c0: 6c76 6572 4f75 7470 7574 286d 6169 6e53  lverOutput(mainS
+000081d0: 7973 7465 6d2c 2073 696d 756c 6174 696f  ystem, simulatio
+000081e0: 6e53 6574 7469 6e67 7329 202d 3e20 4e6f  nSettings) -> No
+000081f0: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+00008200: 726c 6f61 640a 2020 2020 6465 6620 496e  rload.    def In
+00008210: 6974 6961 6c69 7a65 536f 6c76 6572 5072  itializeSolverPr
+00008220: 6543 6865 636b 7328 6d61 696e 5379 7374  eChecks(mainSyst
+00008230: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+00008240: 7474 696e 6773 2920 2d3e 2062 6f6f 6c3a  ttings) -> bool:
+00008250: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00008260: 6164 0a20 2020 2064 6566 2049 6e69 7469  ad.    def Initi
+00008270: 616c 697a 6553 7465 7028 6d61 696e 5379  alizeStep(mainSy
+00008280: 7374 656d 2c20 7369 6d75 6c61 7469 6f6e  stem, simulation
+00008290: 5365 7474 696e 6773 2920 2d3e 204e 6f6e  Settings) -> Non
+000082a0: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+000082b0: 6c6f 6164 0a20 2020 2064 6566 2049 7353  load.    def IsS
+000082c0: 7461 7469 6353 6f6c 7665 7228 2920 2d3e  taticSolver() ->
+000082d0: 2062 6f6f 6c3a 202e 2e2e 0a20 2020 2040   bool: ....    @
+000082e0: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+000082f0: 2049 7356 6572 626f 7365 4368 6563 6b28   IsVerboseCheck(
+00008300: 6c65 7665 6c29 202d 3e20 626f 6f6c 3a20  level) -> bool: 
+00008310: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00008320: 640a 2020 2020 6465 6620 4e65 7774 6f6e  d.    def Newton
+00008330: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+00008340: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+00008350: 202d 3e20 626f 6f6c 3a20 2e2e 2e0a 2020   -> bool: ....  
+00008360: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00008370: 6465 6620 506f 7374 496e 6974 6961 6c69  def PostInitiali
+00008380: 7a65 536f 6c76 6572 5370 6563 6966 6963  zeSolverSpecific
+00008390: 286d 6169 6e53 7973 7465 6d2c 2073 696d  (mainSystem, sim
+000083a0: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+000083b0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+000083c0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+000083d0: 6465 6620 5072 6549 6e69 7469 616c 697a  def PreInitializ
+000083e0: 6553 6f6c 7665 7253 7065 6369 6669 6328  eSolverSpecific(
+000083f0: 6d61 696e 5379 7374 656d 2c20 7369 6d75  mainSystem, simu
+00008400: 6c61 7469 6f6e 5365 7474 696e 6773 2920  lationSettings) 
+00008410: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+00008420: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00008430: 6566 2052 6564 7563 6553 7465 7053 697a  ef ReduceStepSiz
+00008440: 6528 6d61 696e 5379 7374 656d 2c20 7369  e(mainSystem, si
+00008450: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00008460: 2c20 7365 7665 7269 7479 2920 2d3e 2062  , severity) -> b
+00008470: 6f6f 6c3a 202e 2e2e 0a20 2020 2040 6f76  ool: ....    @ov
+00008480: 6572 6c6f 6164 0a20 2020 2064 6566 2053  erload.    def S
+00008490: 6574 5379 7374 656d 4d61 7373 4d61 7472  etSystemMassMatr
+000084a0: 6978 2873 7973 7465 6d4d 6173 734d 6174  ix(systemMassMat
+000084b0: 7269 7829 202d 3e20 4e6f 6e65 3a20 2e2e  rix) -> None: ..
+000084c0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+000084d0: 2020 2020 6465 6620 5365 7453 7973 7465      def SetSyste
+000084e0: 6d52 6573 6964 7561 6c28 7379 7374 656d  mResidual(system
+000084f0: 5265 7369 6475 616c 2920 2d3e 204e 6f6e  Residual) -> Non
+00008500: 653a 202e 2e2e 0a20 2020 2040 6f76 6572  e: ....    @over
+00008510: 6c6f 6164 0a20 2020 2064 6566 2053 6f6c  load.    def Sol
+00008520: 7665 5374 6570 7328 6d61 696e 5379 7374  veSteps(mainSyst
+00008530: 656d 2c20 7369 6d75 6c61 7469 6f6e 5365  em, simulationSe
+00008540: 7474 696e 6773 2920 2d3e 2062 6f6f 6c3a  ttings) -> bool:
+00008550: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00008560: 6164 0a20 2020 2064 6566 2053 6f6c 7665  ad.    def Solve
+00008570: 5379 7374 656d 286d 6169 6e53 7973 7465  System(mainSyste
+00008580: 6d2c 2073 696d 756c 6174 696f 6e53 6574  m, simulationSet
+00008590: 7469 6e67 7329 202d 3e20 626f 6f6c 3a20  tings) -> bool: 
+000085a0: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+000085b0: 640a 2020 2020 6465 6620 5570 6461 7465  d.    def Update
+000085c0: 4375 7272 656e 7454 696d 6528 6d61 696e  CurrentTime(main
+000085d0: 5379 7374 656d 2c20 7369 6d75 6c61 7469  System, simulati
+000085e0: 6f6e 5365 7474 696e 6773 2920 2d3e 204e  onSettings) -> N
+000085f0: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00008600: 6572 6c6f 6164 0a20 2020 2064 6566 2056  erload.    def V
+00008610: 6572 626f 7365 5772 6974 6528 6c65 7665  erboseWrite(leve
+00008620: 6c2c 2073 7472 2920 2d3e 204e 6f6e 653a  l, str) -> None:
+00008630: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00008640: 6164 0a20 2020 2064 6566 2057 7269 7465  ad.    def Write
+00008650: 436f 6f72 6469 6e61 7465 7354 6f46 696c  CoordinatesToFil
+00008660: 6528 6d61 696e 5379 7374 656d 2c20 7369  e(mainSystem, si
+00008670: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+00008680: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00008690: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+000086a0: 2064 6566 2057 7269 7465 536f 6c75 7469   def WriteSoluti
+000086b0: 6f6e 4669 6c65 4865 6164 6572 286d 6169  onFileHeader(mai
+000086c0: 6e53 7973 7465 6d2c 2073 696d 756c 6174  nSystem, simulat
+000086d0: 696f 6e53 6574 7469 6e67 7329 202d 3e20  ionSettings) -> 
+000086e0: 4e6f 6e65 3a20 2e2e 2e0a 0a0a 636c 6173  None: ......clas
+000086f0: 7320 5669 7375 4765 6e65 7261 6c43 6f6e  s VisuGeneralCon
+00008700: 7461 6374 3a0a 2020 2020 406f 7665 726c  tact:.    @overl
+00008710: 6f61 640a 2020 2020 6465 6620 5265 7365  oad.    def Rese
+00008720: 7428 7365 6c66 2920 2d3e 204e 6f6e 653a  t(self) -> None:
+00008730: 202e 2e2e 0a0a 0a63 6c61 7373 2047 656e   ......class Gen
+00008740: 6572 616c 436f 6e74 6163 743a 0a20 2020  eralContact:.   
+00008750: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00008760: 6566 2047 6574 5079 7468 6f6e 4f62 6a65  ef GetPythonObje
+00008770: 6374 2873 656c 6629 202d 3e20 6469 6374  ct(self) -> dict
+00008780: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00008790: 6f61 640a 2020 2020 6465 6620 5265 7365  oad.    def Rese
+000087a0: 7428 7365 6c66 2c20 6672 6565 4d65 6d6f  t(self, freeMemo
+000087b0: 7279 3d54 7275 6529 202d 3e20 4e6f 6e65  ry=True) -> None
+000087c0: 3a20 2e2e 2e0a 2020 2020 6973 4163 7469  : ....    isActi
+000087d0: 7665 3a62 6f6f 6c0a 2020 2020 7665 7262  ve:bool.    verb
+000087e0: 6f73 654d 6f64 653a 696e 740a 2020 2020  oseMode:int.    
+000087f0: 7669 7375 616c 697a 6174 696f 6e3a 5669  visualization:Vi
+00008800: 7375 4765 6e65 7261 6c43 6f6e 7461 6374  suGeneralContact
+00008810: 0a20 2020 2072 6573 6574 5365 6172 6368  .    resetSearch
+00008820: 5472 6565 496e 7465 7276 616c 3a69 6e74  TreeInterval:int
+00008830: 0a20 2020 2073 7068 6572 6553 7068 6572  .    sphereSpher
+00008840: 6543 6f6e 7461 6374 3a62 6f6f 6c0a 2020  eContact:bool.  
+00008850: 2020 7370 6865 7265 5370 6865 7265 4672    sphereSphereFr
+00008860: 6963 7469 6f6e 5265 6379 636c 653a 626f  ictionRecycle:bo
+00008870: 6f6c 0a20 2020 206d 696e 5265 6c44 6973  ol.    minRelDis
+00008880: 7461 6e63 6553 7068 6572 6573 5472 6961  tanceSpheresTria
+00008890: 6e67 6c65 733a 666c 6f61 740a 2020 2020  ngles:float.    
+000088a0: 6672 6963 7469 6f6e 5072 6f70 6f72 7469  frictionProporti
+000088b0: 6f6e 616c 5a6f 6e65 3a66 6c6f 6174 0a20  onalZone:float. 
+000088c0: 2020 2066 7269 6374 696f 6e56 656c 6f63     frictionVeloc
+000088d0: 6974 7950 656e 616c 7479 3a66 6c6f 6174  ityPenalty:float
+000088e0: 0a20 2020 2065 7863 6c75 6465 4f76 6572  .    excludeOver
+000088f0: 6c61 7070 696e 6754 7269 6753 7068 6572  lappingTrigSpher
+00008900: 6543 6f6e 7461 6374 733a 626f 6f6c 0a20  eContacts:bool. 
+00008910: 2020 2065 7863 6c75 6465 4475 706c 6963     excludeDuplic
+00008920: 6174 6564 5472 6967 5370 6865 7265 436f  atedTrigSphereCo
+00008930: 6e74 6163 7450 6f69 6e74 733a 626f 6f6c  ntactPoints:bool
+00008940: 0a20 2020 2063 6f6d 7075 7465 436f 6e74  .    computeCont
+00008950: 6163 7446 6f72 6365 733a 626f 6f6c 0a20  actForces:bool. 
+00008960: 2020 2061 6e63 6643 6162 6c65 5573 6545     ancfCableUseE
+00008970: 7861 6374 4d65 7468 6f64 3a62 6f6f 6c0a  xactMethod:bool.
+00008980: 2020 2020 616e 6366 4361 626c 654e 756d      ancfCableNum
+00008990: 6265 724f 6643 6f6e 7461 6374 5365 676d  berOfContactSegm
+000089a0: 656e 7473 3a69 6e74 0a20 2020 2061 6e63  ents:int.    anc
+000089b0: 6643 6162 6c65 4d65 6173 7572 696e 6753  fCableMeasuringS
+000089c0: 6567 6d65 6e74 733a 696e 740a 2020 2020  egments:int.    
+000089d0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+000089e0: 6620 5365 7446 7269 6374 696f 6e50 6169  f SetFrictionPai
+000089f0: 7269 6e67 7328 7365 6c66 2c20 6672 6963  rings(self, fric
+00008a00: 7469 6f6e 5061 6972 696e 6773 3a20 4172  tionPairings: Ar
+00008a10: 7261 794c 696b 6529 202d 3e20 4e6f 6e65  rayLike) -> None
+00008a20: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00008a30: 6f61 640a 2020 2020 6465 6620 5365 7446  oad.    def SetF
+00008a40: 7269 6374 696f 6e50 726f 706f 7274 696f  rictionProportio
+00008a50: 6e61 6c5a 6f6e 6528 7365 6c66 2c20 6672  nalZone(self, fr
+00008a60: 6963 7469 6f6e 5072 6f70 6f72 7469 6f6e  ictionProportion
+00008a70: 616c 5a6f 6e65 3a20 666c 6f61 7429 202d  alZone: float) -
+00008a80: 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020 2020  > None: ....    
+00008a90: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00008aa0: 6620 5365 7453 6561 7263 6854 7265 6543  f SetSearchTreeC
+00008ab0: 656c 6c53 697a 6528 7365 6c66 2c20 6e75  ellSize(self, nu
+00008ac0: 6d62 6572 4f66 4365 6c6c 733a 205b 696e  mberOfCells: [in
+00008ad0: 742c 696e 742c 696e 745d 2920 2d3e 204e  t,int,int]) -> N
+00008ae0: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00008af0: 6572 6c6f 6164 0a20 2020 2064 6566 2053  erload.    def S
+00008b00: 6574 5365 6172 6368 5472 6565 426f 7828  etSearchTreeBox(
+00008b10: 7365 6c66 2c20 704d 696e 3a20 5b66 6c6f  self, pMin: [flo
+00008b20: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d2c  at,float,float],
+00008b30: 2070 4d61 783a 205b 666c 6f61 742c 666c   pMax: [float,fl
+00008b40: 6f61 742c 666c 6f61 745d 2920 2d3e 204e  oat,float]) -> N
+00008b50: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00008b60: 6572 6c6f 6164 0a20 2020 2064 6566 2041  erload.    def A
+00008b70: 6464 5370 6865 7265 5769 7468 4d61 726b  ddSphereWithMark
+00008b80: 6572 2873 656c 662c 206d 6172 6b65 7249  er(self, markerI
+00008b90: 6e64 6578 3a20 4d61 726b 6572 496e 6465  ndex: MarkerInde
+00008ba0: 782c 2072 6164 6975 733a 2066 6c6f 6174  x, radius: float
+00008bb0: 2c20 636f 6e74 6163 7453 7469 6666 6e65  , contactStiffne
+00008bc0: 7373 3a20 666c 6f61 742c 2063 6f6e 7461  ss: float, conta
+00008bd0: 6374 4461 6d70 696e 673a 2066 6c6f 6174  ctDamping: float
+00008be0: 2c20 6672 6963 7469 6f6e 4d61 7465 7269  , frictionMateri
+00008bf0: 616c 496e 6465 783a 2069 6e74 2920 2d3e  alIndex: int) ->
+00008c00: 2069 6e74 3a20 2e2e 2e0a 2020 2020 406f   int: ....    @o
+00008c10: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00008c20: 4164 6441 4e43 4643 6162 6c65 2873 656c  AddANCFCable(sel
+00008c30: 662c 206f 626a 6563 7449 6e64 6578 3a20  f, objectIndex: 
+00008c40: 4f62 6a65 6374 496e 6465 782c 2068 616c  ObjectIndex, hal
+00008c50: 6648 6569 6768 743a 2066 6c6f 6174 2c20  fHeight: float, 
+00008c60: 636f 6e74 6163 7453 7469 6666 6e65 7373  contactStiffness
+00008c70: 3a20 666c 6f61 742c 2063 6f6e 7461 6374  : float, contact
+00008c80: 4461 6d70 696e 673a 2066 6c6f 6174 2c20  Damping: float, 
+00008c90: 6672 6963 7469 6f6e 4d61 7465 7269 616c  frictionMaterial
+00008ca0: 496e 6465 783a 2069 6e74 2920 2d3e 2069  Index: int) -> i
+00008cb0: 6e74 3a20 2e2e 2e0a 2020 2020 406f 7665  nt: ....    @ove
+00008cc0: 726c 6f61 640a 2020 2020 6465 6620 4164  rload.    def Ad
+00008cd0: 6454 7269 616e 676c 6573 5269 6769 6442  dTrianglesRigidB
+00008ce0: 6f64 7942 6173 6564 2873 656c 662c 2072  odyBased(self, r
+00008cf0: 6967 6964 426f 6479 4d61 726b 6572 496e  igidBodyMarkerIn
+00008d00: 6465 783a 204d 6172 6b65 7249 6e64 6578  dex: MarkerIndex
+00008d10: 2c20 636f 6e74 6163 7453 7469 6666 6e65  , contactStiffne
+00008d20: 7373 3a20 666c 6f61 742c 2063 6f6e 7461  ss: float, conta
+00008d30: 6374 4461 6d70 696e 673a 2066 6c6f 6174  ctDamping: float
+00008d40: 2c20 6672 6963 7469 6f6e 4d61 7465 7269  , frictionMateri
+00008d50: 616c 496e 6465 783a 2069 6e74 2c20 706f  alIndex: int, po
+00008d60: 696e 744c 6973 743a 204c 6973 745b 5b66  intList: List[[f
+00008d70: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
+00008d80: 5d5d 2c20 7472 6961 6e67 6c65 4c69 7374  ]], triangleList
+00008d90: 3a20 4c69 7374 5b5b 696e 742c 696e 742c  : List[[int,int,
+00008da0: 696e 745d 5d29 202d 3e20 696e 743a 202e  int]]) -> int: .
+00008db0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00008dc0: 0a20 2020 2064 6566 2047 6574 4974 656d  .    def GetItem
+00008dd0: 7349 6e42 6f78 2873 656c 662c 2070 4d69  sInBox(self, pMi
+00008de0: 6e3a 205b 666c 6f61 742c 666c 6f61 742c  n: [float,float,
+00008df0: 666c 6f61 745d 2c20 704d 6178 3a20 5b66  float], pMax: [f
+00008e00: 6c6f 6174 2c66 6c6f 6174 2c66 6c6f 6174  loat,float,float
+00008e10: 5d29 202d 3e20 556e 696f 6e5b 6469 6374  ]) -> Union[dict
+00008e20: 2c62 6f6f 6c5d 3a20 2e2e 2e0a 2020 2020  ,bool]: ....    
+00008e30: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00008e40: 6620 4765 7453 7068 6572 654d 6172 6b65  f GetSphereMarke
+00008e50: 7242 6173 6564 2873 656c 662c 206c 6f63  rBased(self, loc
+00008e60: 616c 496e 6465 783a 2069 6e74 2c20 6164  alIndex: int, ad
+00008e70: 6444 6174 613a 2062 6f6f 6c3d 4661 6c73  dData: bool=Fals
+00008e80: 6529 202d 3e20 6469 6374 3a20 2e2e 2e0a  e) -> dict: ....
+00008e90: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00008ea0: 2020 6465 6620 5365 7453 7068 6572 654d    def SetSphereM
+00008eb0: 6172 6b65 7242 6173 6564 2873 656c 662c  arkerBased(self,
+00008ec0: 206c 6f63 616c 496e 6465 783a 2069 6e74   localIndex: int
+00008ed0: 2c20 636f 6e74 6163 7453 7469 6666 6e65  , contactStiffne
+00008ee0: 7373 3a20 666c 6f61 743d 2d31 2e2c 2063  ss: float=-1., c
+00008ef0: 6f6e 7461 6374 4461 6d70 696e 673a 2066  ontactDamping: f
+00008f00: 6c6f 6174 3d2d 312e 2c20 7261 6469 7573  loat=-1., radius
+00008f10: 3a20 666c 6f61 743d 2d31 2e2c 2066 7269  : float=-1., fri
+00008f20: 6374 696f 6e4d 6174 6572 6961 6c49 6e64  ctionMaterialInd
+00008f30: 6578 3a20 696e 743d 2d31 2920 2d3e 204e  ex: int=-1) -> N
+00008f40: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+00008f50: 6572 6c6f 6164 0a20 2020 2064 6566 2047  erload.    def G
+00008f60: 6574 5472 6961 6e67 6c65 5269 6769 6442  etTriangleRigidB
+00008f70: 6f64 7942 6173 6564 2873 656c 662c 206c  odyBased(self, l
+00008f80: 6f63 616c 496e 6465 783a 2069 6e74 2920  ocalIndex: int) 
+00008f90: 2d3e 2064 6963 743a 202e 2e2e 0a20 2020  -> dict: ....   
+00008fa0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00008fb0: 6566 2053 6574 5472 6961 6e67 6c65 5269  ef SetTriangleRi
+00008fc0: 6769 6442 6f64 7942 6173 6564 2873 656c  gidBodyBased(sel
+00008fd0: 662c 206c 6f63 616c 496e 6465 783a 2069  f, localIndex: i
+00008fe0: 6e74 2c20 706f 696e 7473 3a20 4e44 4172  nt, points: NDAr
+00008ff0: 7261 795b 5368 6170 6532 445b 332c 335d  ray[Shape2D[3,3]
+00009000: 2c20 666c 6f61 745d 2c20 636f 6e74 6163  , float], contac
+00009010: 7452 6967 6964 426f 6479 496e 6465 783a  tRigidBodyIndex:
+00009020: 2069 6e74 3d2d 3129 202d 3e20 4e6f 6e65   int=-1) -> None
+00009030: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+00009040: 6f61 640a 2020 2020 6465 6620 5368 6f72  oad.    def Shor
+00009050: 7465 7374 4469 7374 616e 6365 416c 6f6e  testDistanceAlon
+00009060: 674c 696e 6528 7365 6c66 2c20 7053 7461  gLine(self, pSta
+00009070: 7274 3a20 5b66 6c6f 6174 2c66 6c6f 6174  rt: [float,float
+00009080: 2c66 6c6f 6174 5d3d 5b30 2c30 2c30 5d2c  ,float]=[0,0,0],
+00009090: 2064 6972 6563 7469 6f6e 3a20 5b66 6c6f   direction: [flo
+000090a0: 6174 2c66 6c6f 6174 2c66 6c6f 6174 5d3d  at,float,float]=
+000090b0: 5b31 2c30 2c30 5d2c 206d 696e 4469 7374  [1,0,0], minDist
+000090c0: 616e 6365 3a20 666c 6f61 743d 2d31 652d  ance: float=-1e-
+000090d0: 372c 206d 6178 4469 7374 616e 6365 3a20  7, maxDistance: 
+000090e0: 666c 6f61 743d 3165 372c 2061 7344 6963  float=1e7, asDic
+000090f0: 7469 6f6e 6172 793a 2062 6f6f 6c3d 4661  tionary: bool=Fa
+00009100: 6c73 652c 2063 796c 696e 6465 7252 6164  lse, cylinderRad
+00009110: 6975 733a 2066 6c6f 6174 3d30 2c20 7479  ius: float=0, ty
+00009120: 7065 496e 6465 783a 2043 6f6e 7461 6374  peIndex: Contact
+00009130: 5479 7065 496e 6465 783d 436f 6e74 6163  TypeIndex=Contac
+00009140: 742e 496e 6465 7845 6e64 4f66 456e 756d  t.IndexEndOfEnum
+00009150: 4c69 7374 2920 2d3e 2055 6e69 6f6e 5b64  List) -> Union[d
+00009160: 6963 742c 666c 6f61 745d 3a20 2e2e 2e0a  ict,float]: ....
+00009170: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00009180: 2020 6465 6620 5570 6461 7465 436f 6e74    def UpdateCont
+00009190: 6163 7473 2873 656c 662c 206d 6169 6e53  acts(self, mainS
+000091a0: 7973 7465 6d3a 204d 6169 6e53 7973 7465  ystem: MainSyste
+000091b0: 6d29 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  m) -> None: ....
+000091c0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+000091d0: 2020 6465 6620 4765 7441 6374 6976 6543    def GetActiveC
+000091e0: 6f6e 7461 6374 7328 7365 6c66 2c20 7479  ontacts(self, ty
+000091f0: 7065 496e 6465 783a 2043 6f6e 7461 6374  peIndex: Contact
+00009200: 5479 7065 496e 6465 782c 2069 7465 6d49  TypeIndex, itemI
+00009210: 6e64 6578 3a20 696e 7429 202d 3e20 4c69  ndex: int) -> Li
+00009220: 7374 5b69 6e74 5d3a 202e 2e2e 0a20 2020  st[int]: ....   
+00009230: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00009240: 6566 2047 6574 5379 7374 656d 4f44 4532  ef GetSystemODE2
+00009250: 5268 7343 6f6e 7461 6374 466f 7263 6573  RhsContactForces
+00009260: 2873 656c 6629 202d 3e20 4c69 7374 5b66  (self) -> List[f
+00009270: 6c6f 6174 5d3a 202e 2e2e 0a0a 0a63 6c61  loat]: ......cla
+00009280: 7373 2053 7973 7465 6d44 6174 613a 0a20  ss SystemData:. 
+00009290: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+000092a0: 2064 6566 204e 756d 6265 724f 664c 6f61   def NumberOfLoa
+000092b0: 6473 2873 656c 6629 202d 3e20 696e 743a  ds(self) -> int:
+000092c0: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+000092d0: 6164 0a20 2020 2064 6566 204e 756d 6265  ad.    def Numbe
+000092e0: 724f 664d 6172 6b65 7273 2873 656c 6629  rOfMarkers(self)
+000092f0: 202d 3e20 696e 743a 202e 2e2e 0a20 2020   -> int: ....   
+00009300: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00009310: 6566 204e 756d 6265 724f 664e 6f64 6573  ef NumberOfNodes
+00009320: 2873 656c 6629 202d 3e20 696e 743a 202e  (self) -> int: .
+00009330: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00009340: 0a20 2020 2064 6566 204e 756d 6265 724f  .    def NumberO
+00009350: 664f 626a 6563 7473 2873 656c 6629 202d  fObjects(self) -
+00009360: 3e20 696e 743a 202e 2e2e 0a20 2020 2040  > int: ....    @
+00009370: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+00009380: 204e 756d 6265 724f 6653 656e 736f 7273   NumberOfSensors
+00009390: 2873 656c 6629 202d 3e20 696e 743a 202e  (self) -> int: .
+000093a0: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+000093b0: 0a20 2020 2064 6566 204f 4445 3253 697a  .    def ODE2Siz
+000093c0: 6528 7365 6c66 2c20 636f 6e66 6967 7572  e(self, configur
+000093d0: 6174 696f 6e54 7970 653a 2043 6f6e 6669  ationType: Confi
+000093e0: 6775 7261 7469 6f6e 5479 7065 3d43 6f6e  gurationType=Con
+000093f0: 6669 6775 7261 7469 6f6e 5479 7065 2e43  figurationType.C
+00009400: 7572 7265 6e74 2920 2d3e 2069 6e74 3a20  urrent) -> int: 
+00009410: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00009420: 640a 2020 2020 6465 6620 4f44 4531 5369  d.    def ODE1Si
+00009430: 7a65 2873 656c 662c 2063 6f6e 6669 6775  ze(self, configu
+00009440: 7261 7469 6f6e 5479 7065 3a20 436f 6e66  rationType: Conf
+00009450: 6967 7572 6174 696f 6e54 7970 653d 436f  igurationType=Co
+00009460: 6e66 6967 7572 6174 696f 6e54 7970 652e  nfigurationType.
+00009470: 4375 7272 656e 7429 202d 3e20 696e 743a  Current) -> int:
+00009480: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00009490: 6164 0a20 2020 2064 6566 2041 4573 697a  ad.    def AEsiz
+000094a0: 6528 7365 6c66 2c20 636f 6e66 6967 7572  e(self, configur
+000094b0: 6174 696f 6e54 7970 653a 2043 6f6e 6669  ationType: Confi
+000094c0: 6775 7261 7469 6f6e 5479 7065 3d43 6f6e  gurationType=Con
+000094d0: 6669 6775 7261 7469 6f6e 5479 7065 2e43  figurationType.C
+000094e0: 7572 7265 6e74 2920 2d3e 2069 6e74 3a20  urrent) -> int: 
+000094f0: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+00009500: 640a 2020 2020 6465 6620 4461 7461 5369  d.    def DataSi
+00009510: 7a65 2873 656c 662c 2063 6f6e 6669 6775  ze(self, configu
+00009520: 7261 7469 6f6e 5479 7065 3a20 436f 6e66  rationType: Conf
+00009530: 6967 7572 6174 696f 6e54 7970 653d 436f  igurationType=Co
+00009540: 6e66 6967 7572 6174 696f 6e54 7970 652e  nfigurationType.
+00009550: 4375 7272 656e 7429 202d 3e20 696e 743a  Current) -> int:
+00009560: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+00009570: 6164 0a20 2020 2064 6566 2053 7973 7465  ad.    def Syste
+00009580: 6d53 697a 6528 7365 6c66 2c20 636f 6e66  mSize(self, conf
+00009590: 6967 7572 6174 696f 6e54 7970 653a 2043  igurationType: C
+000095a0: 6f6e 6669 6775 7261 7469 6f6e 5479 7065  onfigurationType
+000095b0: 3d43 6f6e 6669 6775 7261 7469 6f6e 5479  =ConfigurationTy
+000095c0: 7065 2e43 7572 7265 6e74 2920 2d3e 2069  pe.Current) -> i
+000095d0: 6e74 3a20 2e2e 2e0a 2020 2020 406f 7665  nt: ....    @ove
+000095e0: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+000095f0: 7454 696d 6528 7365 6c66 2c20 636f 6e66  tTime(self, conf
+00009600: 6967 7572 6174 696f 6e54 7970 653a 2043  igurationType: C
+00009610: 6f6e 6669 6775 7261 7469 6f6e 5479 7065  onfigurationType
+00009620: 3d43 6f6e 6669 6775 7261 7469 6f6e 5479  =ConfigurationTy
+00009630: 7065 2e43 7572 7265 6e74 2920 2d3e 2066  pe.Current) -> f
+00009640: 6c6f 6174 3a20 2e2e 2e0a 2020 2020 406f  loat: ....    @o
+00009650: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+00009660: 5365 7454 696d 6528 7365 6c66 2c20 6e65  SetTime(self, ne
+00009670: 7754 696d 653a 2066 6c6f 6174 2c20 636f  wTime: float, co
+00009680: 6e66 6967 7572 6174 696f 6e54 7970 653a  nfigurationType:
+00009690: 2043 6f6e 6669 6775 7261 7469 6f6e 5479   ConfigurationTy
+000096a0: 7065 3d43 6f6e 6669 6775 7261 7469 6f6e  pe=Configuration
+000096b0: 5479 7065 2e43 7572 7265 6e74 2920 2d3e  Type.Current) ->
+000096c0: 204e 6f6e 653a 202e 2e2e 0a20 2020 2040   None: ....    @
+000096d0: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+000096e0: 2041 6464 4f44 4532 4c6f 6164 4465 7065   AddODE2LoadDepe
+000096f0: 6e64 656e 6369 6573 2873 656c 662c 206c  ndencies(self, l
+00009700: 6f61 644e 756d 6265 723a 2066 6c6f 6174  oadNumber: float
+00009710: 2c20 676c 6f62 616c 4f44 4532 636f 6f72  , globalODE2coor
+00009720: 6469 6e61 7465 733a 204c 6973 745b 696e  dinates: List[in
+00009730: 745d 2920 2d3e 204e 6f6e 653a 202e 2e2e  t]) -> None: ...
+00009740: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00009750: 2020 2064 6566 2049 6e66 6f28 7365 6c66     def Info(self
+00009760: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+00009770: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00009780: 2064 6566 2049 6e66 6f4c 5447 2873 656c   def InfoLTG(sel
+00009790: 6629 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  f) -> None: ....
+000097a0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+000097b0: 2020 6465 6620 4765 744f 4445 3243 6f6f    def GetODE2Coo
+000097c0: 7264 696e 6174 6573 2873 656c 662c 2063  rdinates(self, c
+000097d0: 6f6e 6669 6775 7261 7469 6f6e 3a20 436f  onfiguration: Co
+000097e0: 6e66 6967 7572 6174 696f 6e54 7970 653d  nfigurationType=
+000097f0: 436f 6e66 6967 7572 6174 696f 6e54 7970  ConfigurationTyp
+00009800: 652e 4375 7272 656e 7429 202d 3e20 4c69  e.Current) -> Li
+00009810: 7374 5b66 6c6f 6174 5d3a 202e 2e2e 0a20  st[float]: .... 
+00009820: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00009830: 2064 6566 2053 6574 4f44 4532 436f 6f72   def SetODE2Coor
+00009840: 6469 6e61 7465 7328 7365 6c66 2c20 636f  dinates(self, co
+00009850: 6f72 6469 6e61 7465 733a 204c 6973 745b  ordinates: List[
+00009860: 666c 6f61 745d 2c20 636f 6e66 6967 7572  float], configur
+00009870: 6174 696f 6e3a 2043 6f6e 6669 6775 7261  ation: Configura
+00009880: 7469 6f6e 5479 7065 3d43 6f6e 6669 6775  tionType=Configu
+00009890: 7261 7469 6f6e 5479 7065 2e43 7572 7265  rationType.Curre
+000098a0: 6e74 2920 2d3e 204e 6f6e 653a 202e 2e2e  nt) -> None: ...
+000098b0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+000098c0: 2020 2064 6566 2047 6574 4f44 4532 436f     def GetODE2Co
+000098d0: 6f72 6469 6e61 7465 735f 7428 7365 6c66  ordinates_t(self
+000098e0: 2c20 636f 6e66 6967 7572 6174 696f 6e3a  , configuration:
+000098f0: 2043 6f6e 6669 6775 7261 7469 6f6e 5479   ConfigurationTy
+00009900: 7065 3d43 6f6e 6669 6775 7261 7469 6f6e  pe=Configuration
+00009910: 5479 7065 2e43 7572 7265 6e74 2920 2d3e  Type.Current) ->
+00009920: 204c 6973 745b 666c 6f61 745d 3a20 2e2e   List[float]: ..
+00009930: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+00009940: 2020 2020 6465 6620 5365 744f 4445 3243      def SetODE2C
+00009950: 6f6f 7264 696e 6174 6573 5f74 2873 656c  oordinates_t(sel
+00009960: 662c 2063 6f6f 7264 696e 6174 6573 3a20  f, coordinates: 
+00009970: 4c69 7374 5b66 6c6f 6174 5d2c 2063 6f6e  List[float], con
+00009980: 6669 6775 7261 7469 6f6e 3a20 436f 6e66  figuration: Conf
+00009990: 6967 7572 6174 696f 6e54 7970 653d 436f  igurationType=Co
+000099a0: 6e66 6967 7572 6174 696f 6e54 7970 652e  nfigurationType.
+000099b0: 4375 7272 656e 7429 202d 3e20 4e6f 6e65  Current) -> None
+000099c0: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+000099d0: 6f61 640a 2020 2020 6465 6620 4765 744f  oad.    def GetO
+000099e0: 4445 3243 6f6f 7264 696e 6174 6573 5f74  DE2Coordinates_t
+000099f0: 7428 7365 6c66 2c20 636f 6e66 6967 7572  t(self, configur
+00009a00: 6174 696f 6e3a 2043 6f6e 6669 6775 7261  ation: Configura
+00009a10: 7469 6f6e 5479 7065 3d43 6f6e 6669 6775  tionType=Configu
+00009a20: 7261 7469 6f6e 5479 7065 2e43 7572 7265  rationType.Curre
+00009a30: 6e74 2920 2d3e 204c 6973 745b 666c 6f61  nt) -> List[floa
+00009a40: 745d 3a20 2e2e 2e0a 2020 2020 406f 7665  t]: ....    @ove
+00009a50: 726c 6f61 640a 2020 2020 6465 6620 5365  rload.    def Se
+00009a60: 744f 4445 3243 6f6f 7264 696e 6174 6573  tODE2Coordinates
+00009a70: 5f74 7428 7365 6c66 2c20 636f 6f72 6469  _tt(self, coordi
+00009a80: 6e61 7465 733a 204c 6973 745b 666c 6f61  nates: List[floa
+00009a90: 745d 2c20 636f 6e66 6967 7572 6174 696f  t], configuratio
+00009aa0: 6e3a 2043 6f6e 6669 6775 7261 7469 6f6e  n: Configuration
+00009ab0: 5479 7065 3d43 6f6e 6669 6775 7261 7469  Type=Configurati
+00009ac0: 6f6e 5479 7065 2e43 7572 7265 6e74 2920  onType.Current) 
+00009ad0: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+00009ae0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+00009af0: 6566 2047 6574 4f44 4531 436f 6f72 6469  ef GetODE1Coordi
+00009b00: 6e61 7465 7328 7365 6c66 2c20 636f 6e66  nates(self, conf
+00009b10: 6967 7572 6174 696f 6e3a 2043 6f6e 6669  iguration: Confi
+00009b20: 6775 7261 7469 6f6e 5479 7065 3d43 6f6e  gurationType=Con
+00009b30: 6669 6775 7261 7469 6f6e 5479 7065 2e43  figurationType.C
+00009b40: 7572 7265 6e74 2920 2d3e 204c 6973 745b  urrent) -> List[
+00009b50: 666c 6f61 745d 3a20 2e2e 2e0a 2020 2020  float]: ....    
+00009b60: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+00009b70: 6620 5365 744f 4445 3143 6f6f 7264 696e  f SetODE1Coordin
+00009b80: 6174 6573 2873 656c 662c 2063 6f6f 7264  ates(self, coord
+00009b90: 696e 6174 6573 3a20 4c69 7374 5b66 6c6f  inates: List[flo
+00009ba0: 6174 5d2c 2063 6f6e 6669 6775 7261 7469  at], configurati
+00009bb0: 6f6e 3a20 436f 6e66 6967 7572 6174 696f  on: Configuratio
+00009bc0: 6e54 7970 653d 436f 6e66 6967 7572 6174  nType=Configurat
+00009bd0: 696f 6e54 7970 652e 4375 7272 656e 7429  ionType.Current)
+00009be0: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+00009bf0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+00009c00: 6465 6620 4765 744f 4445 3143 6f6f 7264  def GetODE1Coord
+00009c10: 696e 6174 6573 5f74 2873 656c 662c 2063  inates_t(self, c
+00009c20: 6f6e 6669 6775 7261 7469 6f6e 3a20 436f  onfiguration: Co
+00009c30: 6e66 6967 7572 6174 696f 6e54 7970 653d  nfigurationType=
+00009c40: 436f 6e66 6967 7572 6174 696f 6e54 7970  ConfigurationTyp
+00009c50: 652e 4375 7272 656e 7429 202d 3e20 4c69  e.Current) -> Li
+00009c60: 7374 5b66 6c6f 6174 5d3a 202e 2e2e 0a20  st[float]: .... 
+00009c70: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00009c80: 2064 6566 2053 6574 4f44 4531 436f 6f72   def SetODE1Coor
+00009c90: 6469 6e61 7465 735f 7428 7365 6c66 2c20  dinates_t(self, 
+00009ca0: 636f 6f72 6469 6e61 7465 733a 204c 6973  coordinates: Lis
+00009cb0: 745b 666c 6f61 745d 2c20 636f 6e66 6967  t[float], config
+00009cc0: 7572 6174 696f 6e3a 2043 6f6e 6669 6775  uration: Configu
+00009cd0: 7261 7469 6f6e 5479 7065 3d43 6f6e 6669  rationType=Confi
+00009ce0: 6775 7261 7469 6f6e 5479 7065 2e43 7572  gurationType.Cur
+00009cf0: 7265 6e74 2920 2d3e 204e 6f6e 653a 202e  rent) -> None: .
+00009d00: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+00009d10: 0a20 2020 2064 6566 2047 6574 4145 436f  .    def GetAECo
+00009d20: 6f72 6469 6e61 7465 7328 7365 6c66 2c20  ordinates(self, 
+00009d30: 636f 6e66 6967 7572 6174 696f 6e3a 2043  configuration: C
+00009d40: 6f6e 6669 6775 7261 7469 6f6e 5479 7065  onfigurationType
+00009d50: 3d43 6f6e 6669 6775 7261 7469 6f6e 5479  =ConfigurationTy
+00009d60: 7065 2e43 7572 7265 6e74 2920 2d3e 204c  pe.Current) -> L
+00009d70: 6973 745b 666c 6f61 745d 3a20 2e2e 2e0a  ist[float]: ....
+00009d80: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00009d90: 2020 6465 6620 5365 7441 4543 6f6f 7264    def SetAECoord
+00009da0: 696e 6174 6573 2873 656c 662c 2063 6f6f  inates(self, coo
+00009db0: 7264 696e 6174 6573 3a20 4c69 7374 5b66  rdinates: List[f
+00009dc0: 6c6f 6174 5d2c 2063 6f6e 6669 6775 7261  loat], configura
+00009dd0: 7469 6f6e 3a20 436f 6e66 6967 7572 6174  tion: Configurat
+00009de0: 696f 6e54 7970 653d 436f 6e66 6967 7572  ionType=Configur
+00009df0: 6174 696f 6e54 7970 652e 4375 7272 656e  ationType.Curren
+00009e00: 7429 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  t) -> None: ....
+00009e10: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+00009e20: 2020 6465 6620 4765 7444 6174 6143 6f6f    def GetDataCoo
+00009e30: 7264 696e 6174 6573 2873 656c 662c 2063  rdinates(self, c
+00009e40: 6f6e 6669 6775 7261 7469 6f6e 3a20 436f  onfiguration: Co
+00009e50: 6e66 6967 7572 6174 696f 6e54 7970 653d  nfigurationType=
+00009e60: 436f 6e66 6967 7572 6174 696f 6e54 7970  ConfigurationTyp
+00009e70: 652e 4375 7272 656e 7429 202d 3e20 4c69  e.Current) -> Li
+00009e80: 7374 5b66 6c6f 6174 5d3a 202e 2e2e 0a20  st[float]: .... 
+00009e90: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+00009ea0: 2064 6566 2053 6574 4461 7461 436f 6f72   def SetDataCoor
+00009eb0: 6469 6e61 7465 7328 7365 6c66 2c20 636f  dinates(self, co
+00009ec0: 6f72 6469 6e61 7465 733a 204c 6973 745b  ordinates: List[
+00009ed0: 666c 6f61 745d 2c20 636f 6e66 6967 7572  float], configur
+00009ee0: 6174 696f 6e3a 2043 6f6e 6669 6775 7261  ation: Configura
+00009ef0: 7469 6f6e 5479 7065 3d43 6f6e 6669 6775  tionType=Configu
+00009f00: 7261 7469 6f6e 5479 7065 2e43 7572 7265  rationType.Curre
+00009f10: 6e74 2920 2d3e 204e 6f6e 653a 202e 2e2e  nt) -> None: ...
+00009f20: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+00009f30: 2020 2064 6566 2047 6574 5379 7374 656d     def GetSystem
+00009f40: 5374 6174 6528 7365 6c66 2c20 636f 6e66  State(self, conf
+00009f50: 6967 7572 6174 696f 6e3a 2043 6f6e 6669  iguration: Confi
+00009f60: 6775 7261 7469 6f6e 5479 7065 3d43 6f6e  gurationType=Con
+00009f70: 6669 6775 7261 7469 6f6e 5479 7065 2e43  figurationType.C
+00009f80: 7572 7265 6e74 2920 2d3e 204c 6973 745b  urrent) -> List[
+00009f90: 4c69 7374 5b66 6c6f 6174 5d5d 3a20 2e2e  List[float]]: ..
+00009fa0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+00009fb0: 2020 2020 6465 6620 5365 7453 7973 7465      def SetSyste
+00009fc0: 6d53 7461 7465 2873 656c 662c 2073 7973  mState(self, sys
+00009fd0: 7465 6d53 7461 7465 4c69 7374 3a20 4c69  temStateList: Li
+00009fe0: 7374 5b4c 6973 745b 666c 6f61 745d 5d2c  st[List[float]],
+00009ff0: 2063 6f6e 6669 6775 7261 7469 6f6e 3a20   configuration: 
+0000a000: 436f 6e66 6967 7572 6174 696f 6e54 7970  ConfigurationTyp
+0000a010: 653d 436f 6e66 6967 7572 6174 696f 6e54  e=ConfigurationT
+0000a020: 7970 652e 4375 7272 656e 7429 202d 3e20  ype.Current) -> 
+0000a030: 4e6f 6e65 3a20 2e2e 2e0a 2020 2020 406f  None: ....    @o
+0000a040: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000a050: 4765 744f 626a 6563 744c 5447 4f44 4532  GetObjectLTGODE2
+0000a060: 2873 656c 662c 206f 626a 6563 744e 756d  (self, objectNum
+0000a070: 6265 723a 2069 6e74 2920 2d3e 204c 6973  ber: int) -> Lis
+0000a080: 745b 696e 745d 3a20 2e2e 2e0a 2020 2020  t[int]: ....    
+0000a090: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000a0a0: 6620 4765 744f 626a 6563 744c 5447 4f44  f GetObjectLTGOD
+0000a0b0: 4531 2873 656c 662c 206f 626a 6563 744e  E1(self, objectN
+0000a0c0: 756d 6265 723a 2069 6e74 2920 2d3e 204c  umber: int) -> L
+0000a0d0: 6973 745b 696e 745d 3a20 2e2e 2e0a 2020  ist[int]: ....  
+0000a0e0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000a0f0: 6465 6620 4765 744f 626a 6563 744c 5447  def GetObjectLTG
+0000a100: 4145 2873 656c 662c 206f 626a 6563 744e  AE(self, objectN
+0000a110: 756d 6265 723a 2069 6e74 2920 2d3e 204c  umber: int) -> L
+0000a120: 6973 745b 696e 745d 3a20 2e2e 2e0a 2020  ist[int]: ....  
+0000a130: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000a140: 6465 6620 4765 744f 626a 6563 744c 5447  def GetObjectLTG
+0000a150: 4461 7461 2873 656c 662c 206f 626a 6563  Data(self, objec
+0000a160: 744e 756d 6265 723a 2069 6e74 2920 2d3e  tNumber: int) ->
+0000a170: 204c 6973 745b 696e 745d 3a20 2e2e 2e0a   List[int]: ....
+0000a180: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+0000a190: 2020 6465 6620 4765 744e 6f64 654c 5447    def GetNodeLTG
+0000a1a0: 4f44 4532 2873 656c 662c 206e 6f64 654e  ODE2(self, nodeN
+0000a1b0: 756d 6265 723a 2069 6e74 2920 2d3e 204c  umber: int) -> L
+0000a1c0: 6973 745b 696e 745d 3a20 2e2e 2e0a 2020  ist[int]: ....  
+0000a1d0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000a1e0: 6465 6620 4765 744e 6f64 654c 5447 4f44  def GetNodeLTGOD
+0000a1f0: 4531 2873 656c 662c 206e 6f64 654e 756d  E1(self, nodeNum
+0000a200: 6265 723a 2069 6e74 2920 2d3e 204c 6973  ber: int) -> Lis
+0000a210: 745b 696e 745d 3a20 2e2e 2e0a 2020 2020  t[int]: ....    
+0000a220: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000a230: 6620 4765 744e 6f64 654c 5447 4145 2873  f GetNodeLTGAE(s
+0000a240: 656c 662c 206e 6f64 654e 756d 6265 723a  elf, nodeNumber:
+0000a250: 2069 6e74 2920 2d3e 204c 6973 745b 696e   int) -> List[in
+0000a260: 745d 3a20 2e2e 2e0a 2020 2020 406f 7665  t]: ....    @ove
+0000a270: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+0000a280: 744e 6f64 654c 5447 4461 7461 2873 656c  tNodeLTGData(sel
+0000a290: 662c 206e 6f64 654e 756d 6265 723a 2069  f, nodeNumber: i
+0000a2a0: 6e74 2920 2d3e 204c 6973 745b 696e 745d  nt) -> List[int]
+0000a2b0: 3a20 2e2e 2e0a 0a0a 636c 6173 7320 4d61  : ......class Ma
+0000a2c0: 696e 5379 7374 656d 3a0a 2020 2020 406f  inSystem:.    @o
+0000a2d0: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000a2e0: 4173 7365 6d62 6c65 2873 656c 6629 202d  Assemble(self) -
+0000a2f0: 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020 2020  > None: ....    
+0000a300: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000a310: 6620 4173 7365 6d62 6c65 436f 6f72 6469  f AssembleCoordi
+0000a320: 6e61 7465 7328 7365 6c66 2920 2d3e 204e  nates(self) -> N
+0000a330: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+0000a340: 6572 6c6f 6164 0a20 2020 2064 6566 2041  erload.    def A
+0000a350: 7373 656d 626c 654c 5447 4c69 7374 7328  ssembleLTGLists(
+0000a360: 7365 6c66 2920 2d3e 204e 6f6e 653a 202e  self) -> None: .
+0000a370: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+0000a380: 0a20 2020 2064 6566 2041 7373 656d 626c  .    def Assembl
+0000a390: 6549 6e69 7469 616c 697a 6553 7973 7465  eInitializeSyste
+0000a3a0: 6d43 6f6f 7264 696e 6174 6573 2873 656c  mCoordinates(sel
+0000a3b0: 6629 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  f) -> None: ....
+0000a3c0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+0000a3d0: 2020 6465 6620 4173 7365 6d62 6c65 5379    def AssembleSy
+0000a3e0: 7374 656d 496e 6974 6961 6c69 7a65 2873  stemInitialize(s
+0000a3f0: 656c 6629 202d 3e20 4e6f 6e65 3a20 2e2e  elf) -> None: ..
+0000a400: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000a410: 2020 2020 6465 6620 5265 7365 7428 7365      def Reset(se
+0000a420: 6c66 2920 2d3e 204e 6f6e 653a 202e 2e2e  lf) -> None: ...
+0000a430: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+0000a440: 2020 2064 6566 2047 6574 5379 7374 656d     def GetSystem
+0000a450: 436f 6e74 6169 6e65 7228 7365 6c66 2920  Container(self) 
+0000a460: 2d3e 2053 7973 7465 6d43 6f6e 7461 696e  -> SystemContain
+0000a470: 6572 3a20 2e2e 2e0a 2020 2020 406f 7665  er: ....    @ove
+0000a480: 726c 6f61 640a 2020 2020 6465 6620 5761  rload.    def Wa
+0000a490: 6974 466f 7255 7365 7254 6f43 6f6e 7469  itForUserToConti
+0000a4a0: 6e75 6528 7365 6c66 2c20 7072 696e 744d  nue(self, printM
+0000a4b0: 6573 7361 6765 3d54 7275 6529 202d 3e20  essage=True) -> 
+0000a4c0: 4e6f 6e65 3a20 2e2e 2e0a 2020 2020 406f  None: ....    @o
+0000a4d0: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000a4e0: 5365 6e64 5265 6472 6177 5369 676e 616c  SendRedrawSignal
+0000a4f0: 2873 656c 6629 202d 3e20 4e6f 6e65 3a20  (self) -> None: 
+0000a500: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+0000a510: 640a 2020 2020 6465 6620 4765 7452 656e  d.    def GetRen
+0000a520: 6465 7245 6e67 696e 6553 746f 7046 6c61  derEngineStopFla
+0000a530: 6728 7365 6c66 2920 2d3e 2062 6f6f 6c3a  g(self) -> bool:
+0000a540: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+0000a550: 6164 0a20 2020 2064 6566 2053 6574 5265  ad.    def SetRe
+0000a560: 6e64 6572 456e 6769 6e65 5374 6f70 466c  nderEngineStopFl
+0000a570: 6167 2873 656c 662c 2073 746f 7046 6c61  ag(self, stopFla
+0000a580: 673a 2062 6f6f 6c29 202d 3e20 4e6f 6e65  g: bool) -> None
+0000a590: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+0000a5a0: 6f61 640a 2020 2020 6465 6620 4163 7469  oad.    def Acti
+0000a5b0: 7661 7465 5265 6e64 6572 696e 6728 7365  vateRendering(se
+0000a5c0: 6c66 2c20 666c 6167 3a20 626f 6f6c 3d54  lf, flag: bool=T
+0000a5d0: 7275 6529 202d 3e20 4e6f 6e65 3a20 2e2e  rue) -> None: ..
+0000a5e0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000a5f0: 2020 2020 6465 6620 5365 7450 7265 5374      def SetPreSt
+0000a600: 6570 5573 6572 4675 6e63 7469 6f6e 2873  epUserFunction(s
+0000a610: 656c 662c 2076 616c 7565 3a20 4361 6c6c  elf, value: Call
+0000a620: 6162 6c65 5b5b 4d61 696e 5379 7374 656d  able[[MainSystem
+0000a630: 2c20 666c 6f61 745d 2c62 6f6f 6c5d 2920  , float],bool]) 
+0000a640: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+0000a650: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000a660: 6566 2047 6574 5072 6553 7465 7055 7365  ef GetPreStepUse
+0000a670: 7246 756e 6374 696f 6e28 7365 6c66 2c20  rFunction(self, 
+0000a680: 6173 4469 6374 3a20 626f 6f6c 3d46 616c  asDict: bool=Fal
+0000a690: 7365 2920 2d3e 2043 616c 6c61 626c 655b  se) -> Callable[
+0000a6a0: 5b4d 6169 6e53 7973 7465 6d2c 2066 6c6f  [MainSystem, flo
+0000a6b0: 6174 5d2c 626f 6f6c 5d3a 202e 2e2e 0a20  at],bool]: .... 
+0000a6c0: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+0000a6d0: 2064 6566 2053 6574 506f 7374 5374 6570   def SetPostStep
+0000a6e0: 5573 6572 4675 6e63 7469 6f6e 2873 656c  UserFunction(sel
+0000a6f0: 662c 2076 616c 7565 3a20 4361 6c6c 6162  f, value: Callab
+0000a700: 6c65 5b5b 4d61 696e 5379 7374 656d 2c20  le[[MainSystem, 
+0000a710: 666c 6f61 745d 2c62 6f6f 6c5d 2920 2d3e  float],bool]) ->
+0000a720: 204e 6f6e 653a 202e 2e2e 0a20 2020 2040   None: ....    @
+0000a730: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000a740: 2047 6574 506f 7374 5374 6570 5573 6572   GetPostStepUser
+0000a750: 4675 6e63 7469 6f6e 2873 656c 662c 2061  Function(self, a
+0000a760: 7344 6963 743a 2062 6f6f 6c3d 4661 6c73  sDict: bool=Fals
+0000a770: 6529 202d 3e20 4361 6c6c 6162 6c65 5b5b  e) -> Callable[[
+0000a780: 4d61 696e 5379 7374 656d 2c20 666c 6f61  MainSystem, floa
+0000a790: 745d 2c62 6f6f 6c5d 3a20 2e2e 2e0a 2020  t],bool]: ....  
+0000a7a0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000a7b0: 6465 6620 5365 7450 6f73 744e 6577 746f  def SetPostNewto
+0000a7c0: 6e55 7365 7246 756e 6374 696f 6e28 7365  nUserFunction(se
+0000a7d0: 6c66 2c20 7661 6c75 653a 2043 616c 6c61  lf, value: Calla
+0000a7e0: 626c 655b 5b4d 6169 6e53 7973 7465 6d2c  ble[[MainSystem,
+0000a7f0: 2066 6c6f 6174 5d2c 5b66 6c6f 6174 2c66   float],[float,f
+0000a800: 6c6f 6174 5d5d 2920 2d3e 204e 6f6e 653a  loat]]) -> None:
+0000a810: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+0000a820: 6164 0a20 2020 2064 6566 2047 6574 506f  ad.    def GetPo
+0000a830: 7374 4e65 7774 6f6e 5573 6572 4675 6e63  stNewtonUserFunc
+0000a840: 7469 6f6e 2873 656c 662c 2061 7344 6963  tion(self, asDic
+0000a850: 743a 2062 6f6f 6c3d 4661 6c73 6529 202d  t: bool=False) -
+0000a860: 3e20 4361 6c6c 6162 6c65 5b5b 4d61 696e  > Callable[[Main
+0000a870: 5379 7374 656d 2c20 666c 6f61 745d 2c62  System, float],b
+0000a880: 6f6f 6c5d 3a20 2e2e 2e0a 2020 2020 406f  ool]: ....    @o
+0000a890: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000a8a0: 4164 6447 656e 6572 616c 436f 6e74 6163  AddGeneralContac
+0000a8b0: 7428 7365 6c66 2920 2d3e 2047 656e 6572  t(self) -> Gener
+0000a8c0: 616c 436f 6e74 6163 743a 202e 2e2e 0a20  alContact: .... 
+0000a8d0: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+0000a8e0: 2064 6566 2047 6574 4765 6e65 7261 6c43   def GetGeneralC
+0000a8f0: 6f6e 7461 6374 2873 656c 662c 2067 656e  ontact(self, gen
+0000a900: 6572 616c 436f 6e74 6163 744e 756d 6265  eralContactNumbe
+0000a910: 723a 2069 6e74 2920 2d3e 2047 656e 6572  r: int) -> Gener
+0000a920: 616c 436f 6e74 6163 743a 202e 2e2e 0a20  alContact: .... 
+0000a930: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+0000a940: 2064 6566 2044 656c 6574 6547 656e 6572   def DeleteGener
+0000a950: 616c 436f 6e74 6163 7428 7365 6c66 2c20  alContact(self, 
+0000a960: 6765 6e65 7261 6c43 6f6e 7461 6374 4e75  generalContactNu
+0000a970: 6d62 6572 3a20 696e 7429 202d 3e20 4e6f  mber: int) -> No
+0000a980: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+0000a990: 726c 6f61 640a 2020 2020 6465 6620 4e75  rload.    def Nu
+0000a9a0: 6d62 6572 4f66 4765 6e65 7261 6c43 6f6e  mberOfGeneralCon
+0000a9b0: 7461 6374 7328 7365 6c66 2920 2d3e 2069  tacts(self) -> i
+0000a9c0: 6e74 3a20 2e2e 2e0a 2020 2020 406f 7665  nt: ....    @ove
+0000a9d0: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+0000a9e0: 7441 7661 696c 6162 6c65 4661 6374 6f72  tAvailableFactor
+0000a9f0: 7949 7465 6d73 2873 656c 6629 202d 3e20  yItems(self) -> 
+0000aa00: 6469 6374 3a20 2e2e 2e0a 2020 2020 406f  dict: ....    @o
+0000aa10: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000aa20: 4765 7444 6963 7469 6f6e 6172 7928 7365  GetDictionary(se
+0000aa30: 6c66 2920 2d3e 2064 6963 743a 202e 2e2e  lf) -> dict: ...
+0000aa40: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+0000aa50: 2020 2064 6566 2053 6574 4469 6374 696f     def SetDictio
+0000aa60: 6e61 7279 2873 656c 662c 2073 7973 7465  nary(self, syste
+0000aa70: 6d44 6963 743a 2064 6963 7429 202d 3e20  mDict: dict) -> 
+0000aa80: 4e6f 6e65 3a20 2e2e 2e0a 2020 2020 7379  None: ....    sy
+0000aa90: 7374 656d 4973 436f 6e73 6973 7465 6e74  stemIsConsistent
+0000aaa0: 3a62 6f6f 6c0a 2020 2020 696e 7465 7261  :bool.    intera
+0000aab0: 6374 6976 654d 6f64 653a 626f 6f6c 0a20  ctiveMode:bool. 
+0000aac0: 2020 2076 6172 6961 626c 6573 3a64 6963     variables:dic
+0000aad0: 740a 2020 2020 7379 733a 6469 6374 0a20  t.    sys:dict. 
+0000aae0: 2020 2073 6f6c 7665 7253 6967 6e61 6c4a     solverSignalJ
+0000aaf0: 6163 6f62 6961 6e55 7064 6174 653a 626f  acobianUpdate:bo
+0000ab00: 6f6c 0a20 2020 2073 7973 7465 6d44 6174  ol.    systemDat
+0000ab10: 613a 5379 7374 656d 4461 7461 0a20 2020  a:SystemData.   
+0000ab20: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000ab30: 6566 2041 6464 4e6f 6465 2873 656c 662c  ef AddNode(self,
+0000ab40: 2070 794f 626a 6563 743a 2041 6e79 2920   pyObject: Any) 
+0000ab50: 2d3e 204e 6f64 6549 6e64 6578 3a20 2e2e  -> NodeIndex: ..
+0000ab60: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000ab70: 2020 2020 6465 6620 4765 744e 6f64 654e      def GetNodeN
+0000ab80: 756d 6265 7228 7365 6c66 2c20 6e6f 6465  umber(self, node
+0000ab90: 4e61 6d65 3a20 7374 7229 202d 3e20 4e6f  Name: str) -> No
+0000aba0: 6465 496e 6465 783a 202e 2e2e 0a20 2020  deIndex: ....   
+0000abb0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000abc0: 6566 2047 6574 4e6f 6465 2873 656c 662c  ef GetNode(self,
+0000abd0: 206e 6f64 654e 756d 6265 723a 204e 6f64   nodeNumber: Nod
+0000abe0: 6549 6e64 6578 2920 2d3e 2064 6963 743a  eIndex) -> dict:
+0000abf0: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+0000ac00: 6164 0a20 2020 2064 6566 204d 6f64 6966  ad.    def Modif
+0000ac10: 794e 6f64 6528 7365 6c66 2c20 6e6f 6465  yNode(self, node
+0000ac20: 4e75 6d62 6572 3a20 4e6f 6465 496e 6465  Number: NodeInde
+0000ac30: 782c 206e 6f64 6544 6963 743a 2064 6963  x, nodeDict: dic
+0000ac40: 7429 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a  t) -> None: ....
+0000ac50: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+0000ac60: 2020 6465 6620 4765 744e 6f64 6544 6566    def GetNodeDef
+0000ac70: 6175 6c74 7328 7365 6c66 2c20 7479 7065  aults(self, type
+0000ac80: 4e61 6d65 3a20 7374 7229 202d 3e20 6469  Name: str) -> di
+0000ac90: 6374 3a20 2e2e 2e0a 2020 2020 406f 7665  ct: ....    @ove
+0000aca0: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+0000acb0: 744e 6f64 654f 7574 7075 7428 7365 6c66  tNodeOutput(self
+0000acc0: 2c20 6e6f 6465 4e75 6d62 6572 3a20 4e6f  , nodeNumber: No
+0000acd0: 6465 496e 6465 782c 2076 6172 6961 626c  deIndex, variabl
+0000ace0: 6554 7970 653a 204f 7574 7075 7456 6172  eType: OutputVar
+0000acf0: 6961 626c 6554 7970 652c 2063 6f6e 6669  iableType, confi
+0000ad00: 6775 7261 7469 6f6e 3a20 436f 6e66 6967  guration: Config
+0000ad10: 7572 6174 696f 6e54 7970 653d 436f 6e66  urationType=Conf
+0000ad20: 6967 7572 6174 696f 6e54 7970 652e 4375  igurationType.Cu
+0000ad30: 7272 656e 7429 202d 3e20 4c69 7374 5b66  rrent) -> List[f
+0000ad40: 6c6f 6174 5d3a 202e 2e2e 0a20 2020 2040  loat]: ....    @
+0000ad50: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000ad60: 2047 6574 4e6f 6465 4f44 4532 496e 6465   GetNodeODE2Inde
+0000ad70: 7828 7365 6c66 2c20 6e6f 6465 4e75 6d62  x(self, nodeNumb
+0000ad80: 6572 3a20 4e6f 6465 496e 6465 7829 202d  er: NodeIndex) -
+0000ad90: 3e20 696e 743a 202e 2e2e 0a20 2020 2040  > int: ....    @
+0000ada0: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000adb0: 2047 6574 4e6f 6465 4f44 4531 496e 6465   GetNodeODE1Inde
+0000adc0: 7828 7365 6c66 2c20 6e6f 6465 4e75 6d62  x(self, nodeNumb
+0000add0: 6572 3a20 4e6f 6465 496e 6465 7829 202d  er: NodeIndex) -
+0000ade0: 3e20 696e 743a 202e 2e2e 0a20 2020 2040  > int: ....    @
+0000adf0: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000ae00: 2047 6574 4e6f 6465 4145 496e 6465 7828   GetNodeAEIndex(
+0000ae10: 7365 6c66 2c20 6e6f 6465 4e75 6d62 6572  self, nodeNumber
+0000ae20: 3a20 4e6f 6465 496e 6465 7829 202d 3e20  : NodeIndex) -> 
+0000ae30: 696e 743a 202e 2e2e 0a20 2020 2040 6f76  int: ....    @ov
+0000ae40: 6572 6c6f 6164 0a20 2020 2064 6566 2047  erload.    def G
+0000ae50: 6574 4e6f 6465 5061 7261 6d65 7465 7228  etNodeParameter(
+0000ae60: 7365 6c66 2c20 6e6f 6465 4e75 6d62 6572  self, nodeNumber
+0000ae70: 3a20 4e6f 6465 496e 6465 782c 2070 6172  : NodeIndex, par
+0000ae80: 616d 6574 6572 4e61 6d65 3a20 7374 7229  ameterName: str)
+0000ae90: 202d 3e20 416e 793a 202e 2e2e 0a20 2020   -> Any: ....   
+0000aea0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000aeb0: 6566 2053 6574 4e6f 6465 5061 7261 6d65  ef SetNodeParame
+0000aec0: 7465 7228 7365 6c66 2c20 6e6f 6465 4e75  ter(self, nodeNu
+0000aed0: 6d62 6572 3a20 4e6f 6465 496e 6465 782c  mber: NodeIndex,
+0000aee0: 2070 6172 616d 6574 6572 4e61 6d65 3a20   parameterName: 
+0000aef0: 7374 722c 2076 616c 7565 3a20 416e 7929  str, value: Any)
+0000af00: 202d 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020   -> None: ....  
+0000af10: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000af20: 6465 6620 4164 644f 626a 6563 7428 7365  def AddObject(se
+0000af30: 6c66 2c20 7079 4f62 6a65 6374 3a20 416e  lf, pyObject: An
+0000af40: 7929 202d 3e20 4f62 6a65 6374 496e 6465  y) -> ObjectInde
+0000af50: 783a 202e 2e2e 0a20 2020 2040 6f76 6572  x: ....    @over
+0000af60: 6c6f 6164 0a20 2020 2064 6566 2047 6574  load.    def Get
+0000af70: 4f62 6a65 6374 4e75 6d62 6572 2873 656c  ObjectNumber(sel
+0000af80: 662c 206f 626a 6563 744e 616d 653a 2073  f, objectName: s
+0000af90: 7472 2920 2d3e 204f 626a 6563 7449 6e64  tr) -> ObjectInd
+0000afa0: 6578 3a20 2e2e 2e0a 2020 2020 406f 7665  ex: ....    @ove
+0000afb0: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+0000afc0: 744f 626a 6563 7428 7365 6c66 2c20 6f62  tObject(self, ob
+0000afd0: 6a65 6374 4e75 6d62 6572 3a20 4f62 6a65  jectNumber: Obje
+0000afe0: 6374 496e 6465 782c 2061 6464 4772 6170  ctIndex, addGrap
+0000aff0: 6869 6373 4461 7461 3a20 626f 6f6c 3d46  hicsData: bool=F
+0000b000: 616c 7365 2920 2d3e 2064 6963 743a 202e  alse) -> dict: .
+0000b010: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+0000b020: 0a20 2020 2064 6566 204d 6f64 6966 794f  .    def ModifyO
+0000b030: 626a 6563 7428 7365 6c66 2c20 6f62 6a65  bject(self, obje
+0000b040: 6374 4e75 6d62 6572 3a20 4f62 6a65 6374  ctNumber: Object
+0000b050: 496e 6465 782c 206f 626a 6563 7444 6963  Index, objectDic
+0000b060: 743a 2064 6963 7429 202d 3e20 4e6f 6e65  t: dict) -> None
+0000b070: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+0000b080: 6f61 640a 2020 2020 6465 6620 4765 744f  oad.    def GetO
+0000b090: 626a 6563 7444 6566 6175 6c74 7328 7365  bjectDefaults(se
+0000b0a0: 6c66 2c20 7479 7065 4e61 6d65 3a20 7374  lf, typeName: st
+0000b0b0: 7229 202d 3e20 6469 6374 3a20 2e2e 2e0a  r) -> dict: ....
+0000b0c0: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+0000b0d0: 2020 6465 6620 4765 744f 626a 6563 744f    def GetObjectO
+0000b0e0: 7574 7075 7428 7365 6c66 2c20 6f62 6a65  utput(self, obje
+0000b0f0: 6374 4e75 6d62 6572 3a20 4f62 6a65 6374  ctNumber: Object
+0000b100: 496e 6465 782c 2076 6172 6961 626c 6554  Index, variableT
+0000b110: 7970 653a 204f 7574 7075 7456 6172 6961  ype: OutputVaria
+0000b120: 626c 6554 7970 652c 2063 6f6e 6669 6775  bleType, configu
+0000b130: 7261 7469 6f6e 3a20 436f 6e66 6967 7572  ration: Configur
+0000b140: 6174 696f 6e54 7970 653d 436f 6e66 6967  ationType=Config
+0000b150: 7572 6174 696f 6e54 7970 652e 4375 7272  urationType.Curr
+0000b160: 656e 7429 202d 3e20 4c69 7374 5b66 6c6f  ent) -> List[flo
+0000b170: 6174 5d3a 202e 2e2e 0a20 2020 2040 6f76  at]: ....    @ov
+0000b180: 6572 6c6f 6164 0a20 2020 2064 6566 2047  erload.    def G
+0000b190: 6574 4f62 6a65 6374 4f75 7470 7574 426f  etObjectOutputBo
+0000b1a0: 6479 2873 656c 662c 206f 626a 6563 744e  dy(self, objectN
+0000b1b0: 756d 6265 723a 204f 626a 6563 7449 6e64  umber: ObjectInd
+0000b1c0: 6578 2c20 7661 7269 6162 6c65 5479 7065  ex, variableType
+0000b1d0: 3a20 4f75 7470 7574 5661 7269 6162 6c65  : OutputVariable
+0000b1e0: 5479 7065 2c20 6c6f 6361 6c50 6f73 6974  Type, localPosit
+0000b1f0: 696f 6e3a 205b 666c 6f61 742c 666c 6f61  ion: [float,floa
+0000b200: 742c 666c 6f61 745d 3d5b 302c 302c 305d  t,float]=[0,0,0]
+0000b210: 2c20 636f 6e66 6967 7572 6174 696f 6e3a  , configuration:
+0000b220: 2043 6f6e 6669 6775 7261 7469 6f6e 5479   ConfigurationTy
+0000b230: 7065 3d43 6f6e 6669 6775 7261 7469 6f6e  pe=Configuration
+0000b240: 5479 7065 2e43 7572 7265 6e74 2920 2d3e  Type.Current) ->
+0000b250: 204c 6973 745b 666c 6f61 745d 3a20 2e2e   List[float]: ..
+0000b260: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000b270: 2020 2020 6465 6620 4765 744f 626a 6563      def GetObjec
+0000b280: 744f 7574 7075 7453 7570 6572 456c 656d  tOutputSuperElem
+0000b290: 656e 7428 7365 6c66 2c20 6f62 6a65 6374  ent(self, object
+0000b2a0: 4e75 6d62 6572 3a20 4f62 6a65 6374 496e  Number: ObjectIn
+0000b2b0: 6465 782c 2076 6172 6961 626c 6554 7970  dex, variableTyp
+0000b2c0: 653a 204f 7574 7075 7456 6172 6961 626c  e: OutputVariabl
+0000b2d0: 6554 7970 652c 206d 6573 684e 6f64 654e  eType, meshNodeN
+0000b2e0: 756d 6265 723a 2069 6e74 2c20 636f 6e66  umber: int, conf
+0000b2f0: 6967 7572 6174 696f 6e3a 2043 6f6e 6669  iguration: Confi
+0000b300: 6775 7261 7469 6f6e 5479 7065 3d43 6f6e  gurationType=Con
+0000b310: 6669 6775 7261 7469 6f6e 5479 7065 2e43  figurationType.C
+0000b320: 7572 7265 6e74 2920 2d3e 204c 6973 745b  urrent) -> List[
+0000b330: 666c 6f61 745d 3a20 2e2e 2e0a 2020 2020  float]: ....    
+0000b340: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000b350: 6620 4765 744f 626a 6563 7450 6172 616d  f GetObjectParam
+0000b360: 6574 6572 2873 656c 662c 206f 626a 6563  eter(self, objec
+0000b370: 744e 756d 6265 723a 204f 626a 6563 7449  tNumber: ObjectI
+0000b380: 6e64 6578 2c20 7061 7261 6d65 7465 724e  ndex, parameterN
+0000b390: 616d 653a 2073 7472 2920 2d3e 2041 6e79  ame: str) -> Any
+0000b3a0: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+0000b3b0: 6f61 640a 2020 2020 6465 6620 5365 744f  oad.    def SetO
+0000b3c0: 626a 6563 7450 6172 616d 6574 6572 2873  bjectParameter(s
+0000b3d0: 656c 662c 206f 626a 6563 744e 756d 6265  elf, objectNumbe
+0000b3e0: 723a 204f 626a 6563 7449 6e64 6578 2c20  r: ObjectIndex, 
+0000b3f0: 7061 7261 6d65 7465 724e 616d 653a 2073  parameterName: s
+0000b400: 7472 2c20 7661 6c75 653a 2041 6e79 2920  tr, value: Any) 
+0000b410: 2d3e 204e 6f6e 653a 202e 2e2e 0a20 2020  -> None: ....   
+0000b420: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000b430: 6566 2041 6464 4d61 726b 6572 2873 656c  ef AddMarker(sel
+0000b440: 662c 2070 794f 626a 6563 743a 2041 6e79  f, pyObject: Any
+0000b450: 2920 2d3e 204d 6172 6b65 7249 6e64 6578  ) -> MarkerIndex
+0000b460: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+0000b470: 6f61 640a 2020 2020 6465 6620 4765 744d  oad.    def GetM
+0000b480: 6172 6b65 724e 756d 6265 7228 7365 6c66  arkerNumber(self
+0000b490: 2c20 6d61 726b 6572 4e61 6d65 3a20 7374  , markerName: st
+0000b4a0: 7229 202d 3e20 4d61 726b 6572 496e 6465  r) -> MarkerInde
+0000b4b0: 783a 202e 2e2e 0a20 2020 2040 6f76 6572  x: ....    @over
+0000b4c0: 6c6f 6164 0a20 2020 2064 6566 2047 6574  load.    def Get
+0000b4d0: 4d61 726b 6572 2873 656c 662c 206d 6172  Marker(self, mar
+0000b4e0: 6b65 724e 756d 6265 723a 204d 6172 6b65  kerNumber: Marke
+0000b4f0: 7249 6e64 6578 2920 2d3e 2064 6963 743a  rIndex) -> dict:
+0000b500: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+0000b510: 6164 0a20 2020 2064 6566 204d 6f64 6966  ad.    def Modif
+0000b520: 794d 6172 6b65 7228 7365 6c66 2c20 6d61  yMarker(self, ma
+0000b530: 726b 6572 4e75 6d62 6572 3a20 4d61 726b  rkerNumber: Mark
+0000b540: 6572 496e 6465 782c 206d 6172 6b65 7244  erIndex, markerD
+0000b550: 6963 743a 2064 6963 7429 202d 3e20 4e6f  ict: dict) -> No
+0000b560: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+0000b570: 726c 6f61 640a 2020 2020 6465 6620 4765  rload.    def Ge
+0000b580: 744d 6172 6b65 7244 6566 6175 6c74 7328  tMarkerDefaults(
+0000b590: 7365 6c66 2c20 7479 7065 4e61 6d65 3a20  self, typeName: 
+0000b5a0: 7374 7229 202d 3e20 6469 6374 3a20 2e2e  str) -> dict: ..
+0000b5b0: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000b5c0: 2020 2020 6465 6620 4765 744d 6172 6b65      def GetMarke
+0000b5d0: 7250 6172 616d 6574 6572 2873 656c 662c  rParameter(self,
+0000b5e0: 206d 6172 6b65 724e 756d 6265 723a 204d   markerNumber: M
+0000b5f0: 6172 6b65 7249 6e64 6578 2c20 7061 7261  arkerIndex, para
+0000b600: 6d65 7465 724e 616d 653a 2073 7472 2920  meterName: str) 
+0000b610: 2d3e 2041 6e79 3a20 2e2e 2e0a 2020 2020  -> Any: ....    
+0000b620: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000b630: 6620 5365 744d 6172 6b65 7250 6172 616d  f SetMarkerParam
+0000b640: 6574 6572 2873 656c 662c 206d 6172 6b65  eter(self, marke
+0000b650: 724e 756d 6265 723a 204d 6172 6b65 7249  rNumber: MarkerI
+0000b660: 6e64 6578 2c20 7061 7261 6d65 7465 724e  ndex, parameterN
+0000b670: 616d 653a 2073 7472 2c20 7661 6c75 653a  ame: str, value:
+0000b680: 2041 6e79 2920 2d3e 204e 6f6e 653a 202e   Any) -> None: .
+0000b690: 2e2e 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+0000b6a0: 0a20 2020 2064 6566 2047 6574 4d61 726b  .    def GetMark
+0000b6b0: 6572 4f75 7470 7574 2873 656c 662c 206d  erOutput(self, m
+0000b6c0: 6172 6b65 724e 756d 6265 723a 204d 6172  arkerNumber: Mar
+0000b6d0: 6b65 7249 6e64 6578 2c20 7661 7269 6162  kerIndex, variab
+0000b6e0: 6c65 5479 7065 3a20 4f75 7470 7574 5661  leType: OutputVa
+0000b6f0: 7269 6162 6c65 5479 7065 2c20 636f 6e66  riableType, conf
+0000b700: 6967 7572 6174 696f 6e3a 2043 6f6e 6669  iguration: Confi
+0000b710: 6775 7261 7469 6f6e 5479 7065 3d43 6f6e  gurationType=Con
+0000b720: 6669 6775 7261 7469 6f6e 5479 7065 2e43  figurationType.C
+0000b730: 7572 7265 6e74 2920 2d3e 204c 6973 745b  urrent) -> List[
+0000b740: 666c 6f61 745d 3a20 2e2e 2e0a 2020 2020  float]: ....    
+0000b750: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000b760: 6620 4164 644c 6f61 6428 7365 6c66 2c20  f AddLoad(self, 
+0000b770: 7079 4f62 6a65 6374 3a20 416e 7929 202d  pyObject: Any) -
+0000b780: 3e20 4c6f 6164 496e 6465 783a 202e 2e2e  > LoadIndex: ...
+0000b790: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+0000b7a0: 2020 2064 6566 2047 6574 4c6f 6164 4e75     def GetLoadNu
+0000b7b0: 6d62 6572 2873 656c 662c 206c 6f61 644e  mber(self, loadN
+0000b7c0: 616d 653a 2073 7472 2920 2d3e 204c 6f61  ame: str) -> Loa
+0000b7d0: 6449 6e64 6578 3a20 2e2e 2e0a 2020 2020  dIndex: ....    
+0000b7e0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000b7f0: 6620 4765 744c 6f61 6428 7365 6c66 2c20  f GetLoad(self, 
+0000b800: 6c6f 6164 4e75 6d62 6572 3a20 4c6f 6164  loadNumber: Load
+0000b810: 496e 6465 7829 202d 3e20 6469 6374 3a20  Index) -> dict: 
+0000b820: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+0000b830: 640a 2020 2020 6465 6620 4d6f 6469 6679  d.    def Modify
+0000b840: 4c6f 6164 2873 656c 662c 206c 6f61 644e  Load(self, loadN
+0000b850: 756d 6265 723a 204c 6f61 6449 6e64 6578  umber: LoadIndex
+0000b860: 2c20 6c6f 6164 4469 6374 3a20 6469 6374  , loadDict: dict
+0000b870: 2920 2d3e 204e 6f6e 653a 202e 2e2e 0a20  ) -> None: .... 
+0000b880: 2020 2040 6f76 6572 6c6f 6164 0a20 2020     @overload.   
+0000b890: 2064 6566 2047 6574 4c6f 6164 4465 6661   def GetLoadDefa
+0000b8a0: 756c 7473 2873 656c 662c 2074 7970 654e  ults(self, typeN
+0000b8b0: 616d 653a 2073 7472 2920 2d3e 2064 6963  ame: str) -> dic
+0000b8c0: 743a 202e 2e2e 0a20 2020 2040 6f76 6572  t: ....    @over
+0000b8d0: 6c6f 6164 0a20 2020 2064 6566 2047 6574  load.    def Get
+0000b8e0: 4c6f 6164 5661 6c75 6573 2873 656c 662c  LoadValues(self,
+0000b8f0: 206c 6f61 644e 756d 6265 723a 204c 6f61   loadNumber: Loa
+0000b900: 6449 6e64 6578 2920 2d3e 204c 6973 745b  dIndex) -> List[
+0000b910: 666c 6f61 745d 3a20 2e2e 2e0a 2020 2020  float]: ....    
+0000b920: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000b930: 6620 4765 744c 6f61 6450 6172 616d 6574  f GetLoadParamet
+0000b940: 6572 2873 656c 662c 206c 6f61 644e 756d  er(self, loadNum
+0000b950: 6265 723a 204c 6f61 6449 6e64 6578 2c20  ber: LoadIndex, 
+0000b960: 7061 7261 6d65 7465 724e 616d 653a 2073  parameterName: s
+0000b970: 7472 2920 2d3e 2041 6e79 3a20 2e2e 2e0a  tr) -> Any: ....
+0000b980: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+0000b990: 2020 6465 6620 5365 744c 6f61 6450 6172    def SetLoadPar
+0000b9a0: 616d 6574 6572 2873 656c 662c 206c 6f61  ameter(self, loa
+0000b9b0: 644e 756d 6265 723a 204c 6f61 6449 6e64  dNumber: LoadInd
+0000b9c0: 6578 2c20 7061 7261 6d65 7465 724e 616d  ex, parameterNam
+0000b9d0: 653a 2073 7472 2c20 7661 6c75 653a 2041  e: str, value: A
+0000b9e0: 6e79 2920 2d3e 204e 6f6e 653a 202e 2e2e  ny) -> None: ...
+0000b9f0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+0000ba00: 2020 2064 6566 2041 6464 5365 6e73 6f72     def AddSensor
+0000ba10: 2873 656c 662c 2070 794f 626a 6563 743a  (self, pyObject:
+0000ba20: 2041 6e79 2920 2d3e 2053 656e 736f 7249   Any) -> SensorI
+0000ba30: 6e64 6578 3a20 2e2e 2e0a 2020 2020 406f  ndex: ....    @o
+0000ba40: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000ba50: 4765 7453 656e 736f 724e 756d 6265 7228  GetSensorNumber(
+0000ba60: 7365 6c66 2c20 7365 6e73 6f72 4e61 6d65  self, sensorName
+0000ba70: 3a20 7374 7229 202d 3e20 5365 6e73 6f72  : str) -> Sensor
+0000ba80: 496e 6465 783a 202e 2e2e 0a20 2020 2040  Index: ....    @
+0000ba90: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000baa0: 2047 6574 5365 6e73 6f72 2873 656c 662c   GetSensor(self,
+0000bab0: 2073 656e 736f 724e 756d 6265 723a 2053   sensorNumber: S
+0000bac0: 656e 736f 7249 6e64 6578 2920 2d3e 2064  ensorIndex) -> d
+0000bad0: 6963 743a 202e 2e2e 0a20 2020 2040 6f76  ict: ....    @ov
+0000bae0: 6572 6c6f 6164 0a20 2020 2064 6566 204d  erload.    def M
+0000baf0: 6f64 6966 7953 656e 736f 7228 7365 6c66  odifySensor(self
+0000bb00: 2c20 7365 6e73 6f72 4e75 6d62 6572 3a20  , sensorNumber: 
+0000bb10: 5365 6e73 6f72 496e 6465 782c 2073 656e  SensorIndex, sen
+0000bb20: 736f 7244 6963 743a 2064 6963 7429 202d  sorDict: dict) -
+0000bb30: 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020 2020  > None: ....    
+0000bb40: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000bb50: 6620 4765 7453 656e 736f 7244 6566 6175  f GetSensorDefau
+0000bb60: 6c74 7328 7365 6c66 2c20 7479 7065 4e61  lts(self, typeNa
+0000bb70: 6d65 3a20 7374 7229 202d 3e20 6469 6374  me: str) -> dict
+0000bb80: 3a20 2e2e 2e0a 2020 2020 406f 7665 726c  : ....    @overl
+0000bb90: 6f61 640a 2020 2020 6465 6620 4765 7453  oad.    def GetS
+0000bba0: 656e 736f 7256 616c 7565 7328 7365 6c66  ensorValues(self
+0000bbb0: 2c20 7365 6e73 6f72 4e75 6d62 6572 3a20  , sensorNumber: 
+0000bbc0: 5365 6e73 6f72 496e 6465 782c 2063 6f6e  SensorIndex, con
+0000bbd0: 6669 6775 7261 7469 6f6e 3a20 436f 6e66  figuration: Conf
+0000bbe0: 6967 7572 6174 696f 6e54 7970 653d 436f  igurationType=Co
+0000bbf0: 6e66 6967 7572 6174 696f 6e54 7970 652e  nfigurationType.
+0000bc00: 4375 7272 656e 7429 202d 3e20 4c69 7374  Current) -> List
+0000bc10: 5b66 6c6f 6174 5d3a 202e 2e2e 0a20 2020  [float]: ....   
+0000bc20: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000bc30: 6566 2047 6574 5365 6e73 6f72 5374 6f72  ef GetSensorStor
+0000bc40: 6564 4461 7461 2873 656c 662c 2073 656e  edData(self, sen
+0000bc50: 736f 724e 756d 6265 723a 2053 656e 736f  sorNumber: Senso
+0000bc60: 7249 6e64 6578 2920 2d3e 2041 7272 6179  rIndex) -> Array
+0000bc70: 4c69 6b65 3a20 2e2e 2e0a 2020 2020 406f  Like: ....    @o
+0000bc80: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000bc90: 4765 7453 656e 736f 7250 6172 616d 6574  GetSensorParamet
+0000bca0: 6572 2873 656c 662c 2073 656e 736f 724e  er(self, sensorN
+0000bcb0: 756d 6265 723a 2053 656e 736f 7249 6e64  umber: SensorInd
+0000bcc0: 6578 2c20 7061 7261 6d65 7465 724e 616d  ex, parameterNam
+0000bcd0: 653a 2073 7472 2920 2d3e 2041 6e79 3a20  e: str) -> Any: 
+0000bce0: 2e2e 2e0a 2020 2020 406f 7665 726c 6f61  ....    @overloa
+0000bcf0: 640a 2020 2020 6465 6620 5365 7453 656e  d.    def SetSen
+0000bd00: 736f 7250 6172 616d 6574 6572 2873 656c  sorParameter(sel
+0000bd10: 662c 2073 656e 736f 724e 756d 6265 723a  f, sensorNumber:
+0000bd20: 2053 656e 736f 7249 6e64 6578 2c20 7061   SensorIndex, pa
+0000bd30: 7261 6d65 7465 724e 616d 653a 2073 7472  rameterName: str
+0000bd40: 2c20 7661 6c75 653a 2041 6e79 2920 2d3e  , value: Any) ->
+0000bd50: 204e 6f6e 653a 202e 2e2e 0a0a 2020 2020   None: .....    
+0000bd60: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000bd70: 6620 536f 6c75 7469 6f6e 5669 6577 6572  f SolutionViewer
+0000bd80: 2873 656c 662c 2073 6f6c 7574 696f 6e3d  (self, solution=
+0000bd90: 4e6f 6e65 2c20 726f 7749 6e63 7265 6d65  None, rowIncreme
+0000bda0: 6e74 3d31 2c20 7469 6d65 6f75 743d 302e  nt=1, timeout=0.
+0000bdb0: 3034 2c20 7275 6e4f 6e53 7461 7274 3d54  04, runOnStart=T
+0000bdc0: 7275 652c 2072 756e 4d6f 6465 3d32 2c20  rue, runMode=2, 
+0000bdd0: 666f 6e74 5369 7a65 3d31 322c 2074 6974  fontSize=12, tit
+0000bde0: 6c65 3d27 272c 2063 6865 636b 5265 6e64  le='', checkRend
+0000bdf0: 6572 456e 6769 6e65 5374 6f70 466c 6167  erEngineStopFlag
+0000be00: 3d54 7275 6529 202d 3e20 4e6f 6e65 3a20  =True) -> None: 
+0000be10: 2e2e 2e0a 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
+0000be20: 6164 0a20 2020 2064 6566 2043 7265 6174  ad.    def Creat
+0000be30: 6547 726f 756e 6428 7365 6c66 2c20 6e61  eGround(self, na
+0000be40: 6d65 3d27 272c 2072 6566 6572 656e 6365  me='', reference
+0000be50: 506f 7369 7469 6f6e 3d5b 302e 2c30 2e2c  Position=[0.,0.,
+0000be60: 302e 5d2c 2072 6566 6572 656e 6365 526f  0.], referenceRo
+0000be70: 7461 7469 6f6e 4d61 7472 6978 3d6e 702e  tationMatrix=np.
+0000be80: 6579 6528 3329 2c20 6772 6170 6869 6373  eye(3), graphics
+0000be90: 4461 7461 4c69 7374 3d5b 5d2c 2067 7261  DataList=[], gra
+0000bea0: 7068 6963 7344 6174 6155 7365 7246 756e  phicsDataUserFun
+0000beb0: 6374 696f 6e3d 302c 2073 686f 773d 5472  ction=0, show=Tr
+0000bec0: 7565 2920 2d3e 204f 626a 6563 7449 6e64  ue) -> ObjectInd
+0000bed0: 6578 3a20 2e2e 2e0a 0a20 2020 2040 6f76  ex: .....    @ov
+0000bee0: 6572 6c6f 6164 0a20 2020 2064 6566 2043  erload.    def C
+0000bef0: 7265 6174 654d 6173 7350 6f69 6e74 2873  reateMassPoint(s
+0000bf00: 656c 662c 206e 616d 653d 2727 2c20 7265  elf, name='', re
+0000bf10: 6665 7265 6e63 6550 6f73 6974 696f 6e3d  ferencePosition=
+0000bf20: 5b30 2e2c 302e 2c30 2e5d 2c20 696e 6974  [0.,0.,0.], init
+0000bf30: 6961 6c44 6973 706c 6163 656d 656e 743d  ialDisplacement=
+0000bf40: 5b30 2e2c 302e 2c30 2e5d 2c20 696e 6974  [0.,0.,0.], init
+0000bf50: 6961 6c56 656c 6f63 6974 793d 5b30 2e2c  ialVelocity=[0.,
+0000bf60: 302e 2c30 2e5d 2c20 7068 7973 6963 734d  0.,0.], physicsM
+0000bf70: 6173 733d 302c 2067 7261 7669 7479 3d5b  ass=0, gravity=[
+0000bf80: 302e 2c30 2e2c 302e 5d2c 2067 7261 7068  0.,0.,0.], graph
+0000bf90: 6963 7344 6174 614c 6973 743d 5b5d 2c20  icsDataList=[], 
+0000bfa0: 6472 6177 5369 7a65 3d2d 312c 2063 6f6c  drawSize=-1, col
+0000bfb0: 6f72 3d5b 2d31 2e2c 2d31 2e2c 2d31 2e2c  or=[-1.,-1.,-1.,
+0000bfc0: 2d31 2e5d 2c20 7368 6f77 3d54 7275 652c  -1.], show=True,
+0000bfd0: 2063 7265 6174 6532 443d 4661 6c73 652c   create2D=False,
+0000bfe0: 2072 6574 7572 6e44 6963 743d 4661 6c73   returnDict=Fals
+0000bff0: 6529 202d 3e20 556e 696f 6e5b 6469 6374  e) -> Union[dict
+0000c000: 2c20 4f62 6a65 6374 496e 6465 785d 3a20  , ObjectIndex]: 
+0000c010: 2e2e 2e0a 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
+0000c020: 6164 0a20 2020 2064 6566 2043 7265 6174  ad.    def Creat
+0000c030: 6552 6967 6964 426f 6479 2873 656c 662c  eRigidBody(self,
+0000c040: 206e 616d 653d 2727 2c20 7265 6665 7265   name='', refere
+0000c050: 6e63 6550 6f73 6974 696f 6e3d 5b30 2e2c  ncePosition=[0.,
+0000c060: 302e 2c30 2e5d 2c20 7265 6665 7265 6e63  0.,0.], referenc
+0000c070: 6552 6f74 6174 696f 6e4d 6174 7269 783d  eRotationMatrix=
+0000c080: 6e70 2e65 7965 2833 292c 2069 6e69 7469  np.eye(3), initi
+0000c090: 616c 5665 6c6f 6369 7479 3d5b 302e 2c30  alVelocity=[0.,0
+0000c0a0: 2e2c 302e 5d2c 2069 6e69 7469 616c 416e  .,0.], initialAn
+0000c0b0: 6775 6c61 7256 656c 6f63 6974 793d 5b30  gularVelocity=[0
+0000c0c0: 2e2c 302e 2c30 2e5d 2c20 696e 6974 6961  .,0.,0.], initia
+0000c0d0: 6c44 6973 706c 6163 656d 656e 743d 4e6f  lDisplacement=No
+0000c0e0: 6e65 2c20 696e 6974 6961 6c52 6f74 6174  ne, initialRotat
+0000c0f0: 696f 6e4d 6174 7269 783d 4e6f 6e65 2c20  ionMatrix=None, 
+0000c100: 696e 6572 7469 613d 4e6f 6e65 2c20 6772  inertia=None, gr
+0000c110: 6176 6974 793d 5b30 2e2c 302e 2c30 2e5d  avity=[0.,0.,0.]
+0000c120: 2c20 6e6f 6465 5479 7065 3d65 7875 6479  , nodeType=exudy
+0000c130: 6e2e 4e6f 6465 5479 7065 2e52 6f74 6174  n.NodeType.Rotat
+0000c140: 696f 6e45 756c 6572 5061 7261 6d65 7465  ionEulerParamete
+0000c150: 7273 2c20 6772 6170 6869 6373 4461 7461  rs, graphicsData
+0000c160: 4c69 7374 3d5b 5d2c 2067 7261 7068 6963  List=[], graphic
+0000c170: 7344 6174 6155 7365 7246 756e 6374 696f  sDataUserFunctio
+0000c180: 6e3d 302c 2064 7261 7753 697a 653d 2d31  n=0, drawSize=-1
+0000c190: 2c20 636f 6c6f 723d 5b2d 312e 2c2d 312e  , color=[-1.,-1.
+0000c1a0: 2c2d 312e 2c2d 312e 5d2c 2073 686f 773d  ,-1.,-1.], show=
+0000c1b0: 5472 7565 2c20 6372 6561 7465 3244 3d46  True, create2D=F
+0000c1c0: 616c 7365 2c20 7265 7475 726e 4469 6374  alse, returnDict
+0000c1d0: 3d46 616c 7365 2920 2d3e 2055 6e69 6f6e  =False) -> Union
+0000c1e0: 5b64 6963 742c 204f 626a 6563 7449 6e64  [dict, ObjectInd
+0000c1f0: 6578 5d3a 202e 2e2e 0a0a 2020 2020 406f  ex]: .....    @o
+0000c200: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000c210: 4372 6561 7465 5370 7269 6e67 4461 6d70  CreateSpringDamp
+0000c220: 6572 2873 656c 662c 206e 616d 653d 2727  er(self, name=''
+0000c230: 2c20 626f 6479 4c69 7374 3d5b 4e6f 6e65  , bodyList=[None
+0000c240: 2c20 4e6f 6e65 5d2c 206c 6f63 616c 506f  , None], localPo
+0000c250: 7369 7469 6f6e 303d 5b30 2e2c 302e 2c30  sition0=[0.,0.,0
+0000c260: 2e5d 2c20 6c6f 6361 6c50 6f73 6974 696f  .], localPositio
+0000c270: 6e31 3d5b 302e 2c30 2e2c 302e 5d2c 2072  n1=[0.,0.,0.], r
+0000c280: 6566 6572 656e 6365 4c65 6e67 7468 3d4e  eferenceLength=N
+0000c290: 6f6e 652c 2073 7469 6666 6e65 7373 3d30  one, stiffness=0
+0000c2a0: 2e2c 2064 616d 7069 6e67 3d30 2e2c 2066  ., damping=0., f
+0000c2b0: 6f72 6365 3d30 2e2c 2076 656c 6f63 6974  orce=0., velocit
+0000c2c0: 794f 6666 7365 743d 302e 2c20 7370 7269  yOffset=0., spri
+0000c2d0: 6e67 466f 7263 6555 7365 7246 756e 6374  ngForceUserFunct
+0000c2e0: 696f 6e3d 302c 2062 6f64 794f 724e 6f64  ion=0, bodyOrNod
+0000c2f0: 654c 6973 743d 5b4e 6f6e 652c 204e 6f6e  eList=[None, Non
+0000c300: 655d 2c20 7368 6f77 3d54 7275 652c 2064  e], show=True, d
+0000c310: 7261 7753 697a 653d 2d31 2c20 636f 6c6f  rawSize=-1, colo
+0000c320: 723d 636f 6c6f 7234 6465 6661 756c 7429  r=color4default)
+0000c330: 202d 3e20 4f62 6a65 6374 496e 6465 783a   -> ObjectIndex:
+0000c340: 202e 2e2e 0a0a 2020 2020 406f 7665 726c   .....    @overl
+0000c350: 6f61 640a 2020 2020 6465 6620 4372 6561  oad.    def Crea
+0000c360: 7465 4361 7274 6573 6961 6e53 7072 696e  teCartesianSprin
+0000c370: 6744 616d 7065 7228 7365 6c66 2c20 6e61  gDamper(self, na
+0000c380: 6d65 3d27 272c 2062 6f64 794c 6973 743d  me='', bodyList=
+0000c390: 5b4e 6f6e 652c 204e 6f6e 655d 2c20 6c6f  [None, None], lo
+0000c3a0: 6361 6c50 6f73 6974 696f 6e30 3d5b 302e  calPosition0=[0.
+0000c3b0: 2c30 2e2c 302e 5d2c 206c 6f63 616c 506f  ,0.,0.], localPo
+0000c3c0: 7369 7469 6f6e 313d 5b30 2e2c 302e 2c30  sition1=[0.,0.,0
+0000c3d0: 2e5d 2c20 7374 6966 666e 6573 733d 5b30  .], stiffness=[0
+0000c3e0: 2e2c 302e 2c30 2e5d 2c20 6461 6d70 696e  .,0.,0.], dampin
+0000c3f0: 673d 5b30 2e2c 302e 2c30 2e5d 2c20 6f66  g=[0.,0.,0.], of
+0000c400: 6673 6574 3d5b 302e 2c30 2e2c 302e 5d2c  fset=[0.,0.,0.],
+0000c410: 2073 7072 696e 6746 6f72 6365 5573 6572   springForceUser
+0000c420: 4675 6e63 7469 6f6e 3d30 2c20 626f 6479  Function=0, body
+0000c430: 4f72 4e6f 6465 4c69 7374 3d5b 4e6f 6e65  OrNodeList=[None
+0000c440: 2c20 4e6f 6e65 5d2c 2073 686f 773d 5472  , None], show=Tr
+0000c450: 7565 2c20 6472 6177 5369 7a65 3d2d 312c  ue, drawSize=-1,
+0000c460: 2063 6f6c 6f72 3d63 6f6c 6f72 3464 6566   color=color4def
+0000c470: 6175 6c74 2920 2d3e 204f 626a 6563 7449  ault) -> ObjectI
+0000c480: 6e64 6578 3a20 2e2e 2e0a 0a20 2020 2040  ndex: .....    @
+0000c490: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000c4a0: 2043 7265 6174 6552 6967 6964 426f 6479   CreateRigidBody
+0000c4b0: 5370 7269 6e67 4461 6d70 6572 2873 656c  SpringDamper(sel
+0000c4c0: 662c 206e 616d 653d 2727 2c20 626f 6479  f, name='', body
+0000c4d0: 4c69 7374 3d5b 4e6f 6e65 2c20 4e6f 6e65  List=[None, None
+0000c4e0: 5d2c 206c 6f63 616c 506f 7369 7469 6f6e  ], localPosition
+0000c4f0: 303d 5b30 2e2c 302e 2c30 2e5d 2c20 6c6f  0=[0.,0.,0.], lo
+0000c500: 6361 6c50 6f73 6974 696f 6e31 3d5b 302e  calPosition1=[0.
+0000c510: 2c30 2e2c 302e 5d2c 2073 7469 6666 6e65  ,0.,0.], stiffne
+0000c520: 7373 3d6e 702e 7a65 726f 7328 2836 2c36  ss=np.zeros((6,6
+0000c530: 2929 2c20 6461 6d70 696e 673d 6e70 2e7a  )), damping=np.z
+0000c540: 6572 6f73 2828 362c 3629 292c 206f 6666  eros((6,6)), off
+0000c550: 7365 743d 5b30 2e2c 302e 2c30 2e2c 302e  set=[0.,0.,0.,0.
+0000c560: 2c30 2e2c 302e 5d2c 2072 6f74 6174 696f  ,0.,0.], rotatio
+0000c570: 6e4d 6174 7269 784a 6f69 6e74 3d6e 702e  nMatrixJoint=np.
+0000c580: 6579 6528 3329 2c20 7573 6547 6c6f 6261  eye(3), useGloba
+0000c590: 6c46 7261 6d65 3d54 7275 652c 2069 6e74  lFrame=True, int
+0000c5a0: 7269 6e73 6963 466f 726d 756c 6174 696f  rinsicFormulatio
+0000c5b0: 6e3d 5472 7565 2c20 7370 7269 6e67 466f  n=True, springFo
+0000c5c0: 7263 6554 6f72 7175 6555 7365 7246 756e  rceTorqueUserFun
+0000c5d0: 6374 696f 6e3d 302c 2070 6f73 744e 6577  ction=0, postNew
+0000c5e0: 746f 6e53 7465 7055 7365 7246 756e 6374  tonStepUserFunct
+0000c5f0: 696f 6e3d 302c 2062 6f64 794f 724e 6f64  ion=0, bodyOrNod
+0000c600: 654c 6973 743d 5b4e 6f6e 652c 204e 6f6e  eList=[None, Non
+0000c610: 655d 2c20 7368 6f77 3d54 7275 652c 2064  e], show=True, d
+0000c620: 7261 7753 697a 653d 2d31 2c20 636f 6c6f  rawSize=-1, colo
+0000c630: 723d 636f 6c6f 7234 6465 6661 756c 7429  r=color4default)
+0000c640: 202d 3e20 4f62 6a65 6374 496e 6465 783a   -> ObjectIndex:
+0000c650: 202e 2e2e 0a0a 2020 2020 406f 7665 726c   .....    @overl
+0000c660: 6f61 640a 2020 2020 6465 6620 4372 6561  oad.    def Crea
+0000c670: 7465 5265 766f 6c75 7465 4a6f 696e 7428  teRevoluteJoint(
+0000c680: 7365 6c66 2c20 6e61 6d65 3d27 272c 2062  self, name='', b
+0000c690: 6f64 794e 756d 6265 7273 3d5b 4e6f 6e65  odyNumbers=[None
+0000c6a0: 2c20 4e6f 6e65 5d2c 2070 6f73 6974 696f  , None], positio
+0000c6b0: 6e3d 5b5d 2c20 6178 6973 3d5b 5d2c 2075  n=[], axis=[], u
+0000c6c0: 7365 476c 6f62 616c 4672 616d 653d 5472  seGlobalFrame=Tr
+0000c6d0: 7565 2c20 7368 6f77 3d54 7275 652c 2061  ue, show=True, a
+0000c6e0: 7869 7352 6164 6975 733d 302e 312c 2061  xisRadius=0.1, a
+0000c6f0: 7869 734c 656e 6774 683d 302e 342c 2063  xisLength=0.4, c
+0000c700: 6f6c 6f72 3d63 6f6c 6f72 3464 6566 6175  olor=color4defau
+0000c710: 6c74 2920 2d3e 205b 4f62 6a65 6374 496e  lt) -> [ObjectIn
+0000c720: 6465 782c 204d 6172 6b65 7249 6e64 6578  dex, MarkerIndex
+0000c730: 2c20 4d61 726b 6572 496e 6465 785d 3a20  , MarkerIndex]: 
+0000c740: 2e2e 2e0a 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
+0000c750: 6164 0a20 2020 2064 6566 2043 7265 6174  ad.    def Creat
+0000c760: 6550 7269 736d 6174 6963 4a6f 696e 7428  ePrismaticJoint(
+0000c770: 7365 6c66 2c20 6e61 6d65 3d27 272c 2062  self, name='', b
+0000c780: 6f64 794e 756d 6265 7273 3d5b 4e6f 6e65  odyNumbers=[None
+0000c790: 2c20 4e6f 6e65 5d2c 2070 6f73 6974 696f  , None], positio
+0000c7a0: 6e3d 5b5d 2c20 6178 6973 3d5b 5d2c 2075  n=[], axis=[], u
+0000c7b0: 7365 476c 6f62 616c 4672 616d 653d 5472  seGlobalFrame=Tr
+0000c7c0: 7565 2c20 7368 6f77 3d54 7275 652c 2061  ue, show=True, a
+0000c7d0: 7869 7352 6164 6975 733d 302e 312c 2061  xisRadius=0.1, a
+0000c7e0: 7869 734c 656e 6774 683d 302e 342c 2063  xisLength=0.4, c
+0000c7f0: 6f6c 6f72 3d63 6f6c 6f72 3464 6566 6175  olor=color4defau
+0000c800: 6c74 2920 2d3e 205b 4f62 6a65 6374 496e  lt) -> [ObjectIn
+0000c810: 6465 782c 204d 6172 6b65 7249 6e64 6578  dex, MarkerIndex
+0000c820: 2c20 4d61 726b 6572 496e 6465 785d 3a20  , MarkerIndex]: 
+0000c830: 2e2e 2e0a 0a20 2020 2040 6f76 6572 6c6f  .....    @overlo
+0000c840: 6164 0a20 2020 2064 6566 2043 7265 6174  ad.    def Creat
+0000c850: 6553 7068 6572 6963 616c 4a6f 696e 7428  eSphericalJoint(
+0000c860: 7365 6c66 2c20 6e61 6d65 3d27 272c 2062  self, name='', b
+0000c870: 6f64 794e 756d 6265 7273 3d5b 4e6f 6e65  odyNumbers=[None
+0000c880: 2c20 4e6f 6e65 5d2c 2070 6f73 6974 696f  , None], positio
+0000c890: 6e3d 5b5d 2c20 636f 6e73 7472 6169 6e65  n=[], constraine
+0000c8a0: 6441 7865 733d 5b31 2c31 2c31 5d2c 2075  dAxes=[1,1,1], u
+0000c8b0: 7365 476c 6f62 616c 4672 616d 653d 5472  seGlobalFrame=Tr
+0000c8c0: 7565 2c20 7368 6f77 3d54 7275 652c 206a  ue, show=True, j
+0000c8d0: 6f69 6e74 5261 6469 7573 3d30 2e31 2c20  ointRadius=0.1, 
+0000c8e0: 636f 6c6f 723d 636f 6c6f 7234 6465 6661  color=color4defa
+0000c8f0: 756c 7429 202d 3e20 5b4f 626a 6563 7449  ult) -> [ObjectI
+0000c900: 6e64 6578 2c20 4d61 726b 6572 496e 6465  ndex, MarkerInde
+0000c910: 782c 204d 6172 6b65 7249 6e64 6578 5d3a  x, MarkerIndex]:
+0000c920: 202e 2e2e 0a0a 2020 2020 406f 7665 726c   .....    @overl
+0000c930: 6f61 640a 2020 2020 6465 6620 4372 6561  oad.    def Crea
+0000c940: 7465 4765 6e65 7269 634a 6f69 6e74 2873  teGenericJoint(s
+0000c950: 656c 662c 206e 616d 653d 2727 2c20 626f  elf, name='', bo
+0000c960: 6479 4e75 6d62 6572 733d 5b4e 6f6e 652c  dyNumbers=[None,
+0000c970: 204e 6f6e 655d 2c20 706f 7369 7469 6f6e   None], position
+0000c980: 3d5b 5d2c 2072 6f74 6174 696f 6e4d 6174  =[], rotationMat
+0000c990: 7269 7841 7865 733d 6e70 2e65 7965 2833  rixAxes=np.eye(3
+0000c9a0: 292c 2063 6f6e 7374 7261 696e 6564 4178  ), constrainedAx
+0000c9b0: 6573 3d5b 312c 312c 312c 2031 2c31 2c31  es=[1,1,1, 1,1,1
+0000c9c0: 5d2c 2075 7365 476c 6f62 616c 4672 616d  ], useGlobalFram
+0000c9d0: 653d 5472 7565 2c20 6f66 6673 6574 5573  e=True, offsetUs
+0000c9e0: 6572 4675 6e63 7469 6f6e 3d30 2c20 6f66  erFunction=0, of
+0000c9f0: 6673 6574 5573 6572 4675 6e63 7469 6f6e  fsetUserFunction
+0000ca00: 5f74 3d30 2c20 7368 6f77 3d54 7275 652c  _t=0, show=True,
+0000ca10: 2061 7865 7352 6164 6975 733d 302e 312c   axesRadius=0.1,
+0000ca20: 2061 7865 734c 656e 6774 683d 302e 342c   axesLength=0.4,
+0000ca30: 2063 6f6c 6f72 3d63 6f6c 6f72 3464 6566   color=color4def
+0000ca40: 6175 6c74 2920 2d3e 205b 4f62 6a65 6374  ault) -> [Object
+0000ca50: 496e 6465 782c 204d 6172 6b65 7249 6e64  Index, MarkerInd
+0000ca60: 6578 2c20 4d61 726b 6572 496e 6465 785d  ex, MarkerIndex]
+0000ca70: 3a20 2e2e 2e0a 0a20 2020 2040 6f76 6572  : .....    @over
+0000ca80: 6c6f 6164 0a20 2020 2064 6566 2043 7265  load.    def Cre
+0000ca90: 6174 6544 6973 7461 6e63 6543 6f6e 7374  ateDistanceConst
+0000caa0: 7261 696e 7428 7365 6c66 2c20 6e61 6d65  raint(self, name
+0000cab0: 3d27 272c 2062 6f64 794c 6973 743d 5b4e  ='', bodyList=[N
+0000cac0: 6f6e 652c 204e 6f6e 655d 2c20 6c6f 6361  one, None], loca
+0000cad0: 6c50 6f73 6974 696f 6e30 3d5b 302e 2c30  lPosition0=[0.,0
+0000cae0: 2e2c 302e 5d2c 206c 6f63 616c 506f 7369  .,0.], localPosi
+0000caf0: 7469 6f6e 313d 5b30 2e2c 302e 2c30 2e5d  tion1=[0.,0.,0.]
+0000cb00: 2c20 6469 7374 616e 6365 3d4e 6f6e 652c  , distance=None,
+0000cb10: 2062 6f64 794f 724e 6f64 654c 6973 743d   bodyOrNodeList=
+0000cb20: 5b4e 6f6e 652c 204e 6f6e 655d 2c20 7368  [None, None], sh
+0000cb30: 6f77 3d54 7275 652c 2064 7261 7753 697a  ow=True, drawSiz
+0000cb40: 653d 2d31 2e2c 2063 6f6c 6f72 3d63 6f6c  e=-1., color=col
+0000cb50: 6f72 3464 6566 6175 6c74 2920 2d3e 205b  or4default) -> [
+0000cb60: 4f62 6a65 6374 496e 6465 782c 204d 6172  ObjectIndex, Mar
+0000cb70: 6b65 7249 6e64 6578 2c20 4d61 726b 6572  kerIndex, Marker
+0000cb80: 496e 6465 785d 3a20 2e2e 2e0a 0a20 2020  Index]: .....   
+0000cb90: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000cba0: 6566 2043 7265 6174 6546 6f72 6365 2873  ef CreateForce(s
+0000cbb0: 656c 662c 206e 616d 653d 2727 2c20 626f  elf, name='', bo
+0000cbc0: 6479 4e75 6d62 6572 3d4e 6f6e 652c 206c  dyNumber=None, l
+0000cbd0: 6f61 6456 6563 746f 723d 5b30 2e2c 302e  oadVector=[0.,0.
+0000cbe0: 2c30 2e5d 2c20 6c6f 6361 6c50 6f73 6974  ,0.], localPosit
+0000cbf0: 696f 6e3d 5b30 2e2c 302e 2c30 2e5d 2c20  ion=[0.,0.,0.], 
+0000cc00: 626f 6479 4669 7865 643d 4661 6c73 652c  bodyFixed=False,
+0000cc10: 206c 6f61 6456 6563 746f 7255 7365 7246   loadVectorUserF
+0000cc20: 756e 6374 696f 6e3d 302c 2073 686f 773d  unction=0, show=
+0000cc30: 5472 7565 2920 2d3e 204c 6f61 6449 6e64  True) -> LoadInd
+0000cc40: 6578 3a20 2e2e 2e0a 0a20 2020 2040 6f76  ex: .....    @ov
+0000cc50: 6572 6c6f 6164 0a20 2020 2064 6566 2043  erload.    def C
+0000cc60: 7265 6174 6554 6f72 7175 6528 7365 6c66  reateTorque(self
+0000cc70: 2c20 6e61 6d65 3d27 272c 2062 6f64 794e  , name='', bodyN
+0000cc80: 756d 6265 723d 4e6f 6e65 2c20 6c6f 6164  umber=None, load
+0000cc90: 5665 6374 6f72 3d5b 302e 2c30 2e2c 302e  Vector=[0.,0.,0.
+0000cca0: 5d2c 206c 6f63 616c 506f 7369 7469 6f6e  ], localPosition
+0000ccb0: 3d5b 302e 2c30 2e2c 302e 5d2c 2062 6f64  =[0.,0.,0.], bod
+0000ccc0: 7946 6978 6564 3d46 616c 7365 2c20 6c6f  yFixed=False, lo
+0000ccd0: 6164 5665 6374 6f72 5573 6572 4675 6e63  adVectorUserFunc
+0000cce0: 7469 6f6e 3d30 2c20 7368 6f77 3d54 7275  tion=0, show=Tru
+0000ccf0: 6529 202d 3e20 4c6f 6164 496e 6465 783a  e) -> LoadIndex:
+0000cd00: 202e 2e2e 0a0a 2020 2020 406f 7665 726c   .....    @overl
+0000cd10: 6f61 640a 2020 2020 6465 6620 506c 6f74  oad.    def Plot
+0000cd20: 5365 6e73 6f72 2873 656c 662c 2073 656e  Sensor(self, sen
+0000cd30: 736f 724e 756d 6265 7273 3d5b 5d2c 2063  sorNumbers=[], c
+0000cd40: 6f6d 706f 6e65 6e74 733d 302c 2078 4c61  omponents=0, xLa
+0000cd50: 6265 6c3d 2774 696d 6520 2873 2927 2c20  bel='time (s)', 
+0000cd60: 794c 6162 656c 3d4e 6f6e 652c 206c 6162  yLabel=None, lab
+0000cd70: 656c 733d 5b5d 2c20 636f 6c6f 7243 6f64  els=[], colorCod
+0000cd80: 654f 6666 7365 743d 302c 206e 6577 4669  eOffset=0, newFi
+0000cd90: 6775 7265 3d54 7275 652c 2063 6c6f 7365  gure=True, close
+0000cda0: 416c 6c3d 4661 6c73 652c 2063 6f6d 706f  All=False, compo
+0000cdb0: 6e65 6e74 7358 3d5b 5d2c 2074 6974 6c65  nentsX=[], title
+0000cdc0: 3d27 272c 2066 6967 7572 654e 616d 653d  ='', figureName=
+0000cdd0: 2727 2c20 666f 6e74 5369 7a65 3d31 362c  '', fontSize=16,
+0000cde0: 2063 6f6c 6f72 733d 5b5d 2c20 6c69 6e65   colors=[], line
+0000cdf0: 5374 796c 6573 3d5b 5d2c 206c 696e 6557  Styles=[], lineW
+0000ce00: 6964 7468 733d 5b5d 2c20 6d61 726b 6572  idths=[], marker
+0000ce10: 5374 796c 6573 3d5b 5d2c 206d 6172 6b65  Styles=[], marke
+0000ce20: 7253 697a 6573 3d5b 5d2c 206d 6172 6b65  rSizes=[], marke
+0000ce30: 7244 656e 7369 7479 3d30 2e30 382c 2072  rDensity=0.08, r
+0000ce40: 616e 6765 583d 5b5d 2c20 7261 6e67 6559  angeX=[], rangeY
+0000ce50: 3d5b 5d2c 206d 616a 6f72 5469 636b 7358  =[], majorTicksX
+0000ce60: 3d31 302c 206d 616a 6f72 5469 636b 7359  =10, majorTicksY
+0000ce70: 3d31 302c 206f 6666 7365 7473 3d5b 5d2c  =10, offsets=[],
+0000ce80: 2066 6163 746f 7273 3d5b 5d2c 2073 7562   factors=[], sub
+0000ce90: 506c 6f74 3d5b 5d2c 2073 697a 6549 6e63  Plot=[], sizeInc
+0000cea0: 6865 733d 5b36 2e34 2c34 2e38 5d2c 2066  hes=[6.4,4.8], f
+0000ceb0: 696c 654e 616d 653d 2727 2c20 7573 6558  ileName='', useX
+0000cec0: 595a 636f 6d70 6f6e 656e 7473 3d54 7275  YZcomponents=Tru
+0000ced0: 652c 202a 2a6b 7761 7267 7329 202d 3e20  e, **kwargs) -> 
+0000cee0: 5b41 6e79 2c20 416e 792c 2041 6e79 2c20  [Any, Any, Any, 
+0000cef0: 416e 795d 3a20 2e2e 2e0a 0a20 2020 2040  Any]: .....    @
+0000cf00: 6f76 6572 6c6f 6164 0a20 2020 2064 6566  overload.    def
+0000cf10: 2053 6f6c 7665 5374 6174 6963 2873 656c   SolveStatic(sel
+0000cf20: 662c 2073 696d 756c 6174 696f 6e53 6574  f, simulationSet
+0000cf30: 7469 6e67 733d 6578 7564 796e 2e53 696d  tings=exudyn.Sim
+0000cf40: 756c 6174 696f 6e53 6574 7469 6e67 7328  ulationSettings(
+0000cf50: 292c 2075 7064 6174 6549 6e69 7469 616c  ), updateInitial
+0000cf60: 5661 6c75 6573 3d46 616c 7365 2c20 7374  Values=False, st
+0000cf70: 6f72 6553 6f6c 7665 723d 5472 7565 2c20  oreSolver=True, 
+0000cf80: 7368 6f77 4869 6e74 733d 4661 6c73 652c  showHints=False,
+0000cf90: 2073 686f 7743 6175 7369 6e67 4974 656d   showCausingItem
+0000cfa0: 733d 5472 7565 2920 2d3e 2062 6f6f 6c3a  s=True) -> bool:
+0000cfb0: 202e 2e2e 0a0a 2020 2020 406f 7665 726c   .....    @overl
+0000cfc0: 6f61 640a 2020 2020 6465 6620 536f 6c76  oad.    def Solv
+0000cfd0: 6544 796e 616d 6963 2873 656c 662c 2073  eDynamic(self, s
+0000cfe0: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
+0000cff0: 733d 6578 7564 796e 2e53 696d 756c 6174  s=exudyn.Simulat
+0000d000: 696f 6e53 6574 7469 6e67 7328 292c 2073  ionSettings(), s
+0000d010: 6f6c 7665 7254 7970 653d 6578 7564 796e  olverType=exudyn
+0000d020: 2e44 796e 616d 6963 536f 6c76 6572 5479  .DynamicSolverTy
+0000d030: 7065 2e47 656e 6572 616c 697a 6564 416c  pe.GeneralizedAl
+0000d040: 7068 612c 2075 7064 6174 6549 6e69 7469  pha, updateIniti
+0000d050: 616c 5661 6c75 6573 3d46 616c 7365 2c20  alValues=False, 
+0000d060: 7374 6f72 6553 6f6c 7665 723d 5472 7565  storeSolver=True
+0000d070: 2c20 7368 6f77 4869 6e74 733d 4661 6c73  , showHints=Fals
+0000d080: 652c 2073 686f 7743 6175 7369 6e67 4974  e, showCausingIt
+0000d090: 656d 733d 5472 7565 2920 2d3e 2062 6f6f  ems=True) -> boo
+0000d0a0: 6c3a 202e 2e2e 0a0a 2020 2020 406f 7665  l: .....    @ove
+0000d0b0: 726c 6f61 640a 2020 2020 6465 6620 436f  rload.    def Co
+0000d0c0: 6d70 7574 654c 696e 6561 7269 7a65 6453  mputeLinearizedS
+0000d0d0: 7973 7465 6d28 7365 6c66 2c20 7369 6d75  ystem(self, simu
+0000d0e0: 6c61 7469 6f6e 5365 7474 696e 6773 3d65  lationSettings=e
+0000d0f0: 7875 6479 6e2e 5369 6d75 6c61 7469 6f6e  xudyn.Simulation
+0000d100: 5365 7474 696e 6773 2829 2c20 7573 6553  Settings(), useS
+0000d110: 7061 7273 6553 6f6c 7665 723d 4661 6c73  parseSolver=Fals
+0000d120: 6529 202d 3e20 5b41 7272 6179 4c69 6b65  e) -> [ArrayLike
+0000d130: 2c20 4172 7261 794c 696b 652c 2041 7272  , ArrayLike, Arr
+0000d140: 6179 4c69 6b65 5d3a 202e 2e2e 0a0a 2020  ayLike]: .....  
+0000d150: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000d160: 6465 6620 436f 6d70 7574 654f 4445 3245  def ComputeODE2E
+0000d170: 6967 656e 7661 6c75 6573 2873 656c 662c  igenvalues(self,
+0000d180: 2073 696d 756c 6174 696f 6e53 6574 7469   simulationSetti
+0000d190: 6e67 733d 6578 7564 796e 2e53 696d 756c  ngs=exudyn.Simul
+0000d1a0: 6174 696f 6e53 6574 7469 6e67 7328 292c  ationSettings(),
+0000d1b0: 2075 7365 5370 6172 7365 536f 6c76 6572   useSparseSolver
+0000d1c0: 3d46 616c 7365 2c20 6e75 6d62 6572 4f66  =False, numberOf
+0000d1d0: 4569 6765 6e76 616c 7565 733d 302c 2063  Eigenvalues=0, c
+0000d1e0: 6f6e 7374 7261 696e 6564 436f 6f72 6469  onstrainedCoordi
+0000d1f0: 6e61 7465 733d 5b5d 2c20 636f 6e76 6572  nates=[], conver
+0000d200: 7432 4672 6571 7565 6e63 6965 733d 4661  t2Frequencies=Fa
+0000d210: 6c73 652c 2075 7365 4162 736f 6c75 7465  lse, useAbsolute
+0000d220: 5661 6c75 6573 3d54 7275 652c 2063 6f6d  Values=True, com
+0000d230: 7075 7465 436f 6d70 6c65 7845 6967 656e  puteComplexEigen
+0000d240: 7661 6c75 6573 3d46 616c 7365 2c20 6967  values=False, ig
+0000d250: 6e6f 7265 416c 6765 6272 6169 6345 7175  noreAlgebraicEqu
+0000d260: 6174 696f 6e73 3d46 616c 7365 2c20 7369  ations=False, si
+0000d270: 6e67 756c 6172 5661 6c75 6573 546f 6c65  ngularValuesTole
+0000d280: 7261 6e63 653d 3165 2d31 3229 202d 3e20  rance=1e-12) -> 
+0000d290: 5b41 7272 6179 4c69 6b65 2c20 4172 7261  [ArrayLike, Arra
+0000d2a0: 794c 696b 655d 3a20 2e2e 2e0a 0a20 2020  yLike]: .....   
+0000d2b0: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000d2c0: 6566 2043 6f6d 7075 7465 5379 7374 656d  ef ComputeSystem
+0000d2d0: 4465 6772 6565 4f66 4672 6565 646f 6d28  DegreeOfFreedom(
+0000d2e0: 7365 6c66 2c20 7369 6d75 6c61 7469 6f6e  self, simulation
+0000d2f0: 5365 7474 696e 6773 3d65 7875 6479 6e2e  Settings=exudyn.
+0000d300: 5369 6d75 6c61 7469 6f6e 5365 7474 696e  SimulationSettin
+0000d310: 6773 2829 2c20 7468 7265 7368 6f6c 643d  gs(), threshold=
+0000d320: 3165 2d31 322c 2076 6572 626f 7365 3d46  1e-12, verbose=F
+0000d330: 616c 7365 2c20 7573 6553 5644 3d46 616c  alse, useSVD=Fal
+0000d340: 7365 2920 2d3e 2064 6963 743a 202e 2e2e  se) -> dict: ...
+0000d350: 0a0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000d360: 2020 2020 6465 6620 4372 6561 7465 4469      def CreateDi
+0000d370: 7374 616e 6365 5365 6e73 6f72 4765 6f6d  stanceSensorGeom
+0000d380: 6574 7279 2873 656c 662c 206d 6573 6850  etry(self, meshP
+0000d390: 6f69 6e74 732c 206d 6573 6854 7269 6773  oints, meshTrigs
+0000d3a0: 2c20 7269 6769 6442 6f64 794d 6172 6b65  , rigidBodyMarke
+0000d3b0: 7249 6e64 6578 2c20 7365 6172 6368 5472  rIndex, searchTr
+0000d3c0: 6565 4365 6c6c 5369 7a65 3d5b 382c 382c  eeCellSize=[8,8,
+0000d3d0: 385d 2920 2d3e 2069 6e74 3a20 2e2e 2e0a  8]) -> int: ....
+0000d3e0: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+0000d3f0: 2020 2064 6566 2043 7265 6174 6544 6973     def CreateDis
+0000d400: 7461 6e63 6553 656e 736f 7228 7365 6c66  tanceSensor(self
+0000d410: 2c20 6765 6e65 7261 6c43 6f6e 7461 6374  , generalContact
+0000d420: 496e 6465 782c 2070 6f73 6974 696f 6e4f  Index, positionO
+0000d430: 724d 6172 6b65 722c 2064 6972 5365 6e73  rMarker, dirSens
+0000d440: 6f72 2c20 6d69 6e44 6973 7461 6e63 653d  or, minDistance=
+0000d450: 2d31 6537 2c20 6d61 7844 6973 7461 6e63  -1e7, maxDistanc
+0000d460: 653d 3165 372c 2063 796c 696e 6465 7252  e=1e7, cylinderR
+0000d470: 6164 6975 733d 302c 2073 656c 6563 7465  adius=0, selecte
+0000d480: 6454 7970 6549 6e64 6578 3d65 7875 6479  dTypeIndex=exudy
+0000d490: 6e2e 436f 6e74 6163 7454 7970 6549 6e64  n.ContactTypeInd
+0000d4a0: 6578 2e49 6e64 6578 456e 644f 6645 6e75  ex.IndexEndOfEnu
+0000d4b0: 6d4c 6973 742c 2073 746f 7265 496e 7465  mList, storeInte
+0000d4c0: 726e 616c 3d46 616c 7365 2c20 6669 6c65  rnal=False, file
+0000d4d0: 4e61 6d65 3d27 272c 206d 6561 7375 7265  Name='', measure
+0000d4e0: 5665 6c6f 6369 7479 3d46 616c 7365 2c20  Velocity=False, 
+0000d4f0: 6164 6447 7261 7068 6963 734f 626a 6563  addGraphicsObjec
+0000d500: 743d 4661 6c73 652c 2064 7261 7744 6973  t=False, drawDis
+0000d510: 706c 6163 6564 3d54 7275 652c 2063 6f6c  placed=True, col
+0000d520: 6f72 3d63 6f6c 6f72 3472 6564 2920 2d3e  or=color4red) ->
+0000d530: 2053 656e 736f 7249 6e64 6578 3a20 2e2e   SensorIndex: ..
+0000d540: 2e0a 0a20 2020 2040 6f76 6572 6c6f 6164  ...    @overload
+0000d550: 0a20 2020 2064 6566 2044 7261 7753 7973  .    def DrawSys
+0000d560: 7465 6d47 7261 7068 2873 656c 662c 2073  temGraph(self, s
+0000d570: 686f 774c 6f61 6473 3d54 7275 652c 2073  howLoads=True, s
+0000d580: 686f 7753 656e 736f 7273 3d54 7275 652c  howSensors=True,
+0000d590: 2075 7365 4974 656d 4e61 6d65 733d 4661   useItemNames=Fa
+0000d5a0: 6c73 652c 2075 7365 4974 656d 5479 7065  lse, useItemType
+0000d5b0: 733d 4661 6c73 652c 2061 6464 4974 656d  s=False, addItem
+0000d5c0: 5479 7065 4e61 6d65 733d 5472 7565 2c20  TypeNames=True, 
+0000d5d0: 6d75 6c74 694c 696e 653d 5472 7565 2c20  multiLine=True, 
+0000d5e0: 666f 6e74 5369 7a65 4661 6374 6f72 3d31  fontSizeFactor=1
+0000d5f0: 2e2c 206c 6179 6f75 7444 6973 7461 6e63  ., layoutDistanc
+0000d600: 6546 6163 746f 723d 332e 2c20 6c61 796f  eFactor=3., layo
+0000d610: 7574 4974 6572 6174 696f 6e73 3d31 3030  utIterations=100
+0000d620: 2c20 7368 6f77 4c65 6765 6e64 3d54 7275  , showLegend=Tru
+0000d630: 652c 2074 6967 6874 4c61 796f 7574 3d54  e, tightLayout=T
+0000d640: 7275 6529 202d 3e20 5b41 6e79 2c20 416e  rue) -> [Any, An
+0000d650: 792c 2041 6e79 5d3a 202e 2e2e 0a0a 0a63  y, Any]: ......c
+0000d660: 6c61 7373 2053 7973 7465 6d43 6f6e 7461  lass SystemConta
+0000d670: 696e 6572 3a0a 2020 2020 406f 7665 726c  iner:.    @overl
+0000d680: 6f61 640a 2020 2020 6465 6620 5265 7365  oad.    def Rese
+0000d690: 7428 7365 6c66 2920 2d3e 204e 6f6e 653a  t(self) -> None:
+0000d6a0: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+0000d6b0: 6164 0a20 2020 2064 6566 2041 6464 5379  ad.    def AddSy
+0000d6c0: 7374 656d 2873 656c 6629 202d 3e20 4d61  stem(self) -> Ma
+0000d6d0: 696e 5379 7374 656d 3a20 2e2e 2e0a 2020  inSystem: ....  
+0000d6e0: 2020 406f 7665 726c 6f61 640a 2020 2020    @overload.    
+0000d6f0: 6465 6620 4170 7065 6e64 2873 656c 662c  def Append(self,
+0000d700: 206d 6169 6e53 7973 7465 6d3a 204d 6169   mainSystem: Mai
+0000d710: 6e53 7973 7465 6d29 202d 3e20 696e 743a  nSystem) -> int:
+0000d720: 202e 2e2e 0a20 2020 2040 6f76 6572 6c6f   ....    @overlo
+0000d730: 6164 0a20 2020 2064 6566 204e 756d 6265  ad.    def Numbe
+0000d740: 724f 6653 7973 7465 6d73 2873 656c 6629  rOfSystems(self)
+0000d750: 202d 3e20 696e 743a 202e 2e2e 0a20 2020   -> int: ....   
+0000d760: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000d770: 6566 2047 6574 5379 7374 656d 2873 656c  ef GetSystem(sel
+0000d780: 662c 2073 7973 7465 6d4e 756d 6265 723a  f, systemNumber:
+0000d790: 2069 6e74 2920 2d3e 204d 6169 6e53 7973   int) -> MainSys
+0000d7a0: 7465 6d3a 202e 2e2e 0a20 2020 2076 6973  tem: ....    vis
+0000d7b0: 7561 6c69 7a61 7469 6f6e 5365 7474 696e  ualizationSettin
+0000d7c0: 6773 3a56 6973 7561 6c69 7a61 7469 6f6e  gs:Visualization
+0000d7d0: 5365 7474 696e 6773 0a20 2020 2040 6f76  Settings.    @ov
+0000d7e0: 6572 6c6f 6164 0a20 2020 2064 6566 2047  erload.    def G
+0000d7f0: 6574 4469 6374 696f 6e61 7279 2873 656c  etDictionary(sel
+0000d800: 6629 202d 3e20 6469 6374 3a20 2e2e 2e0a  f) -> dict: ....
+0000d810: 2020 2020 406f 7665 726c 6f61 640a 2020      @overload.  
+0000d820: 2020 6465 6620 5365 7444 6963 7469 6f6e    def SetDiction
+0000d830: 6172 7928 7365 6c66 2c20 7379 7374 656d  ary(self, system
+0000d840: 4469 6374 3a20 6469 6374 2920 2d3e 204e  Dict: dict) -> N
+0000d850: 6f6e 653a 202e 2e2e 0a20 2020 2040 6f76  one: ....    @ov
+0000d860: 6572 6c6f 6164 0a20 2020 2064 6566 2047  erload.    def G
+0000d870: 6574 5265 6e64 6572 5374 6174 6528 7365  etRenderState(se
+0000d880: 6c66 2920 2d3e 2064 6963 743a 202e 2e2e  lf) -> dict: ...
+0000d890: 0a20 2020 2040 6f76 6572 6c6f 6164 0a20  .    @overload. 
+0000d8a0: 2020 2064 6566 2053 6574 5265 6e64 6572     def SetRender
+0000d8b0: 5374 6174 6528 7365 6c66 2c20 7265 6e64  State(self, rend
+0000d8c0: 6572 5374 6174 653a 2064 6963 7429 202d  erState: dict) -
+0000d8d0: 3e20 4e6f 6e65 3a20 2e2e 2e0a 2020 2020  > None: ....    
+0000d8e0: 406f 7665 726c 6f61 640a 2020 2020 6465  @overload.    de
+0000d8f0: 6620 5265 6472 6177 416e 6453 6176 6549  f RedrawAndSaveI
+0000d900: 6d61 6765 2873 656c 6629 202d 3e20 4e6f  mage(self) -> No
+0000d910: 6e65 3a20 2e2e 2e0a 2020 2020 406f 7665  ne: ....    @ove
+0000d920: 726c 6f61 640a 2020 2020 6465 6620 5761  rload.    def Wa
+0000d930: 6974 466f 7252 656e 6465 7245 6e67 696e  itForRenderEngin
+0000d940: 6553 746f 7046 6c61 6728 7365 6c66 2920  eStopFlag(self) 
+0000d950: 2d3e 2062 6f6f 6c3a 202e 2e2e 0a20 2020  -> bool: ....   
+0000d960: 2040 6f76 6572 6c6f 6164 0a20 2020 2064   @overload.    d
+0000d970: 6566 2052 656e 6465 7245 6e67 696e 655a  ef RenderEngineZ
+0000d980: 6f6f 6d41 6c6c 2873 656c 6629 202d 3e20  oomAll(self) -> 
+0000d990: 4e6f 6e65 3a20 2e2e 2e0a 2020 2020 406f  None: ....    @o
+0000d9a0: 7665 726c 6f61 640a 2020 2020 6465 6620  verload.    def 
+0000d9b0: 4174 7461 6368 546f 5265 6e64 6572 456e  AttachToRenderEn
+0000d9c0: 6769 6e65 2873 656c 6629 202d 3e20 626f  gine(self) -> bo
+0000d9d0: 6f6c 3a20 2e2e 2e0a 2020 2020 406f 7665  ol: ....    @ove
+0000d9e0: 726c 6f61 640a 2020 2020 6465 6620 4465  rload.    def De
+0000d9f0: 7461 6368 4672 6f6d 5265 6e64 6572 456e  tachFromRenderEn
+0000da00: 6769 6e65 2873 656c 6629 202d 3e20 626f  gine(self) -> bo
+0000da10: 6f6c 3a20 2e2e 2e0a 2020 2020 406f 7665  ol: ....    @ove
+0000da20: 726c 6f61 640a 2020 2020 6465 6620 5365  rload.    def Se
+0000da30: 6e64 5265 6472 6177 5369 676e 616c 2873  ndRedrawSignal(s
+0000da40: 656c 6629 202d 3e20 4e6f 6e65 3a20 2e2e  elf) -> None: ..
+0000da50: 2e0a 2020 2020 406f 7665 726c 6f61 640a  ..    @overload.
+0000da60: 2020 2020 6465 6620 4765 7443 7572 7265      def GetCurre
+0000da70: 6e74 4d6f 7573 6543 6f6f 7264 696e 6174  ntMouseCoordinat
+0000da80: 6573 2873 656c 662c 2075 7365 4f70 656e  es(self, useOpen
+0000da90: 474c 636f 6f72 6469 6e61 7465 733a 2062  GLcoordinates: b
+0000daa0: 6f6f 6c3d 4661 6c73 6529 202d 3e20 5b66  ool=False) -> [f
+0000dab0: 6c6f 6174 2c66 6c6f 6174 5d3a 202e 2e2e  loat,float]: ...
+0000dac0: 0a0a                                     ..
```

## exudyn/advancedUtilities.py

```diff
@@ -1,550 +1,558 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Advanced utility functions only depending on numpy or specified exudyn modules;
-#           Here, we gather special functions, which are depending on other modules and do not fit into exudyn.utilities as they cannot be imported e.g. in rigidBodyUtilities
-#
-# Author:   Johannes Gerstmayr
-# Date:     2023-01-06 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-from math import sin, cos, pi, sqrt
-from enum import Enum
-import copy 
-
-import exudyn
-from exudyn.itemInterface import userFunctionArgsDict
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#GENERAL FUNCTIONS
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**function: helper functions for matplotlib, returns a list of 28 line codes to be used in plot, e.g. 'r-' for red solid line
-#**input: index in range(0:28)
-#**output: a color and line style code for matplotlib plot
-def PlotLineCode(index):
-    CC = ['r-','g-','b-','k-','c-','m-','y-','r:','g:','b:','k:','c:','m:','y:','r--','g--','b--','k--','c--','m--','y--','r-.','g-.','b-.','k-.','c-.','m-.','y-.']
-    if index < len(CC):
-        return CC[index]
-    else:
-        return 'k:' #black line
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#INSPECTION, needs numpy and exudyn:
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        
-#**function: simple function to find object index i within the local or global scope of variables
-#**input: i, the integer object number and  globalVariables=globals()
-#**example:
-# FindObjectIndex(2, locals() )  #usually sufficient
-# FindObjectIndex(2, globals() ) #wider search
-def FindObjectIndex(i, globalVariables):
-    #run through all variables and check if an object index exists
-    found = False
-    for varname in globalVariables:
-        if type(globalVariables[varname]) == exudyn.ObjectIndex:
-            if int(globalVariables[varname]) == int(i):
-                print("variable '"+varname+"' links to object "+str(i) )
-                found = True
-    if not found:
-        print("no according variable found")
-
-#**function: simple function to find node index i within the local or global scope of variables
-#**input: i, the integer node number and  globalVariables=globals()
-#**example:
-# FindObjectIndex(2, locals() )  #usually sufficient
-# FindObjectIndex(2, globals() ) #wider search
-def FindNodeIndex(i, globalVariables):
-    #run through all variables and check if an object index exists
-    found = False
-    for varname in globalVariables:
-        if type(globalVariables[varname]) == exudyn.NodeIndex:
-            if int(globalVariables[varname]) == int(i):
-                print("variable '"+varname+"' links to node "+str(i) )
-                found = True
-    if not found:
-        print("no according variable found")
-
-#**function: checks, if data is of type list or np.array; used in functions to check input data
-#**input:
-#  data: any type, preferrably list or numpy.array
-#  checkIfNoneEmpty: if True, function only returns True if type is list or array AND if length is non-zero
-#**output: returns True/False
-def IsListOrArray(data, checkIfNoneEmpty=False):
-    if isinstance(data,list) or isinstance(data,np.ndarray):
-        if checkIfNoneEmpty and len(data) == 0:
-            return False
-        return True
-    else:
-        return False
-
-
-#**class: internal type which is used for type checking in exudyn Python user functions; used to create unique error messages
-class ExpectedType(Enum):
-    _None = 0
-    Positive = 1
-    Unsigned = 2
-    Bool = 4
-    Int = 8
-    PInt = 8+1
-    UInt = 8+2
-    Real = 16
-    PReal = 16+1
-    UReal = 16+2
-    Vector = 32
-    IntVector = 32+8
-    Matrix = 64
-    RigidBodyInertia = 128
-    NodeIndex = 256
-    ObjectIndex = 512
-    MarkerIndex = 1024
-    LoadIndex = 2048
-    SensorIndex = 4096
-    String = 8192
-
-#**function: internal function which is used to raise common errors in case of wrong types; dim is used for vectors and square matrices, cols is used for non-square matrices
-def RaiseTypeError(where='', argumentName='', received = None, expectedType = None, dim=None, cols=None):
-    t = copy.copy(expectedType)
-    
-    errStr = 'ERROR in ' + where + ' in argument ' + argumentName + ': '
-    
-    if type(t) != str:
-        errStr += 'expected type=' + t.name
-        if t == ExpectedType.Vector or t == ExpectedType.IntVector:
-            errStr += ' (as list or numpy array)'
-        elif t == ExpectedType.Matrix:
-            errStr += ' (as list of lists or numpy array)'
-        
-        if dim != None:
-            ncols = cols
-            if t == ExpectedType.Matrix and cols == None: 
-                ncols = dim  #square Matrix
-            if ncols != None:
-                errStr += ', expected size = (' + str(dim) + ',' + str(ncols) + ')'
-            else:
-                errStr += ', expected size = ' + str(dim) 
-    else:
-        errStr += expectedType
-            
-    receivedStr = ', <argument can not be converted to string>'
-    try:
-        receivedStr  = ', but received "' + str(received) + '"'
-    except:
-        pass
-    errStr += receivedStr
-
-    raise ValueError(errStr)
-
-#**function: return True, if x is int, float, np.double, np.integer or similar types that can be automatically casted to pybind11
-def IsValidBool(x):
-    if (isinstance(x, bool)
-        or isinstance(x, int)
-        or isinstance(x, np.integer)
-        ):
-        return True
-    return False
-
-#**function: return True, if x is int, float, np.double, np.integer or similar types that can be automatically casted to pybind11
-def IsValidRealInt(x):
-    if (isinstance(x, float) 
-        or isinstance(x, int)
-        or isinstance(x, np.double)
-        or isinstance(x, np.integer)
-        ):
-        return True
-    return False
-
-#**function: return True, if x is valid Real/Int and positive
-def IsValidPRealInt(x):
-    if IsValidRealInt(x) and x > 0:
-        return True
-    return False
-
-#**function: return True, if x is valid Real/Int and unsigned (non-negative)
-def IsValidURealInt(x):
-    if IsValidRealInt(x) and x >= 0:
-        return True
-    return False
-
-#**function: return True, if x is any python or numpy float type; could also be called IsFloat(), but Real has special meaning in Exudyn
-def IsReal(x):
-    if isinstance(x, (np.floating, float)): 
-        return True
-    else:
-        return False
-
-#**function: return True, if x is any python or numpy float type
-def IsInteger(x):
-    if isinstance(x, (np.integer, int)): 
-        return True
-    else:
-        return False
-
-#**function: check if v is a valid vector with floats or ints; if expectedSize!=None, the length is also checked
-def IsVector(v, expectedSize=None):
-    if type(v) != list and type(v) != np.ndarray:
-        return False
-
-    if expectedSize!=None:
-        if len(v) != expectedSize:
-            return False
-
-    for x in v:
-        if not IsValidRealInt(x): return False
-
-    return True
-
-#**function: check if v is a valid vector with floats or ints; if expectedSize!=None, the length is also checked
-def IsIntVector(v, expectedSize=None):
-    if type(v) != list and type(v) != np.ndarray:
-        return False
-
-    if expectedSize!=None:
-        if len(v) != expectedSize:
-            return False
-
-    for x in v:
-        if not IsInteger(x): return False
-
-    return True
-
-
-#**function: check if v is a valid vector with floats or ints; if expectedSize!=None, the length is also checked
-def IsSquareMatrix(m, expectedSize=None):
-    if type(m) != list and type(m) != np.ndarray:
-        return False
-
-    if expectedSize!=None:
-        if len(m) != expectedSize:
-            return False
-
-    for y in m: #works both in list of lists and np.array (over rows)
-        if expectedSize!=None and len(y) != expectedSize: 
-            return False
-        for x in y:
-            if not IsValidRealInt(x): return False
-
-    return True
-
-#**function: return True, if x is valid exudyn object index
-def IsValidObjectIndex(x):
-    if isinstance(x, int) or isinstance(x, np.integer) or isinstance(x, exudyn.ObjectIndex):
-        return True
-    return False
-
-#**function: return True, if x is valid exudyn node index
-def IsValidNodeIndex(x):
-    if isinstance(x, int) or isinstance(x, np.integer) or isinstance(x, exudyn.NodeIndex):
-        return True
-    return False
-
-#**function: return True, if x is valid exudyn marker index
-def IsValidMarkerIndex(x):
-    if isinstance(x, int) or isinstance(x, np.integer) or isinstance(x, exudyn.MarkerIndex):
-        return True
-    return False
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: fill submatrix into given destinationMatrix; all matrices must be numpy arrays 
-#**input: 
-#  subMatrix: input matrix, which is filled into destinationMatrix
-#  destinationMatrix: the subMatrix is entered here
-#  destRow: row destination of subMatrix
-#  destColumn: column destination of subMatrix
-#**notes: may be erased in future!
-#**output: destinationMatrix is changed after function call
-def FillInSubMatrix(subMatrix, destinationMatrix, destRow, destColumn):
-    nRows = subMatrix.shape[0]
-    nColumns = subMatrix.shape[1]
-
-    destinationMatrix[destRow:destRow+nRows, destColumn:destColumn+nColumns] = subMatrix
-
-    #for i in range(nRows):
-    #    for j in range(nColumns):
-    #        destinationMatrix[i+destRow, j+destColumn] = subMatrix[i,j]
-
-
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute sin sweep at given time t
-#**input: 
-#  t: evaluate of sweep at time t
-#  t1: end time of sweep frequency range
-#  f0: start of frequency interval [f0,f1] in Hz
-#  f1: end of frequency interval [f0,f1] in Hz
-#**output: evaluation of sin sweep (in range -1..+1)
-def SweepSin(t, t1, f0, f1):
-    k = (f1-f0)/t1
-    return sin(2*pi*(f0+k*0.5*t)*t) #take care of factor 0.5 in k*0.5*t, in order to obtain correct frequencies!!!
-
-#**function: compute cos sweep at given time t
-#**input: 
-#  t: evaluate of sweep at time t
-#  t1: end time of sweep frequency range
-#  f0: start of frequency interval [f0,f1] in Hz
-#  f1: end of frequency interval [f0,f1] in Hz
-#**output: evaluation of cos sweep (in range -1..+1)
-def SweepCos(t, t1, f0, f1):
-    k = (f1-f0)/t1
-    return cos(2*pi*(f0+k*0.5*t)*t) #take care of factor 0.5 in k*0.5*t, in order to obtain correct frequencies!!!
-
-#**function: frequency according to given sweep functions SweepSin, SweepCos
-#**input: 
-#  t: evaluate of frequency at time t
-#  t1: end time of sweep frequency range
-#  f0: start of frequency interval [f0,f1] in Hz
-#  f1: end of frequency interval [f0,f1] in Hz
-#**output: frequency in Hz
-def FrequencySweep(t, t1, f0, f1):
-    return t*(f1-f0)/t1 + f0
-
-#**function: step function with smooth transition from value0 to value1; transition is computed with cos function
-#**input:
-#  x: argument at which function is evaluated
-#  x0: start of step (f(x) = value0)
-#  x1: end of step (f(x) = value1)
-#  value0: value before smooth step
-#  value1: value at end of smooth step
-#**output: returns f(x)
-def SmoothStep(x, x0, x1, value0, value1): 
-    loadValue = value0
-
-    if x > x0:
-        if x < x1:
-            dx = x1-x0
-            loadValue = value0 + (value1-value0) * 0.5*(1-cos((x-x0)/dx*pi)) 
-        else:
-            loadValue = value1
-    return loadValue
-
-#**function: derivative of SmoothStep using same arguments
-#**input:
-#  x: argument at which function is evaluated
-#  x0: start of step (f(x) = value0)
-#  x1: end of step (f(x) = value1)
-#  value0: value before smooth step
-#  value1: value at end of smooth step
-#**output: returns d/dx(f(x))
-def SmoothStepDerivative(x, x0, x1, value0, value1): 
-    loadValue = 0
-
-    if x > x0 and x < x1:
-        dx = x1-x0
-        loadValue = (value1-value0) * 0.5*(pi/dx*sin((x-x0)/dx*pi)) 
-    return loadValue
-
-#**function: get index from value in given data vector (numpy array); usually used to get specific index of time vector; this function is slow (linear search), if sampling rate is non-constant; otherwise set assumeConstantSampleRate=True!
-#**input: 
-#  data: containing (almost) equidistant values of time
-#  value: e.g., time to be found in data
-#  tolerance: tolerance, which is accepted (default: tolerance=1e-7)
-#  rangeWarning: warn, if index returns out of range; if warning is deactivated, function uses the closest value
-#**notes: to obtain the interpolated value of a time-signal array, use GetInterpolatedSignalValue() in exudyn.signalProcessing
-#**output: index
-def IndexFromValue(data, value, tolerance=1e-7, assumeConstantSampleRate=False, rangeWarning=True):
-    index  = -1
-    
-    if assumeConstantSampleRate and len(data) > 1:
-        dt = data[1] - data[0]
-        if dt == 0.:
-            raise ValueError('IndexFromValue: sample rate is zero!')
-        index = int((value-data[0]) / dt)
-        if index < 0:
-            index = 0
-            if rangeWarning:
-                print('Warning: IndexFromValue: index returned smaller than 0; using 0 instead')
-        elif index >= len(data):
-            if rangeWarning:
-                print('Warning: IndexFromValue: index returned larger than array length-1; using array max length-1 instead')
-            index = len(data)-1
-            
-    else:
-        bestTol = 1e37
-        for i in range(len(data)):
-            if abs(data[i] - value) < min(bestTol, tolerance):
-                index = i
-                bestTol = abs(data[i] - value)
-
-    if index == -1:
-        raise ValueError("IndexFromValue: value not found with given tolerance")
-    return index
-
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: set all entries in matrix to zero which are smaller than given treshold; operates directly on matrix
-#**input: matrix as np.array, treshold as positive value
-#**output: changes matrix
-def RoundMatrix(matrix, treshold = 1e-14):
-    (rows, cols) = matrix.shape
-    for i in range (rows):
-        for j in range(cols):
-            if abs(matrix[i,j]) < treshold:
-                matrix[i,j]=0
-
-
-
-#**function: Internal function to convert a Python user function into a dictionary containing the symbolic representation;
-#  this function is under development and should be used with care
-#**input:
-#  mbs: MainSystem, needed currently for interface
-#  function: Python function with interface according to desired user function
-#  itemIndex: item index, such as ObjectIndex or LoadIndex; -1 indicates MainSystem; if None, itemTypeName must be provided instead
-#  itemTypeName: use of type name, such as ObjectConnectorSpringDamper; in this case, itemIndex must be None
-#  itemIndex: item index, such as ObjectIndex or LoadIndex; -1 indicates MainSystem
-#  userFunctionName: name of user function item, see documentation; this is required, because some items have several user functions, which need to be distinguished
-#  verbose: if > 0, according output is printed
-#**output: return dictionary with 'functionName', 'argList', and 'returnList'
-def ConvertFunctionToSymbolic(mbs, function, userFunctionName, itemIndex=None, itemTypeName=None, verbose=0):
-    fnName = function.__name__
-    fnArgs = function.__code__.co_varnames
-    #fnAnnotations = function.__annotations__ #not necessarily present
-    if verbose:
-        #print("Annotations:", fnAnnotations)
-        print("Function Name:", fnName)
-        # print("Docstring:", function.__doc__)
-        print("Number of Arguments:", function.__code__.co_argcount)
-        print("Argument Names:", fnArgs)
-
-
-    if itemTypeName != None:
-        itemTypeNameCopy = itemTypeName
-        if itemIndex != None: raise ValueError('ConvertFunctionToSymbolic: if itemTypeName is provided, itemIndex must be None')
-    elif itemIndex == -1: #MainSystem or other function
-        itemTypeNameCopy = 'MainSystem'
-    else:
-        #regular item
-        try:
-            typeString = itemIndex.GetTypeString()
-        except:
-            raise ValueError('ConvertFunctionToSymbolic: itemIndex must be a valid exudyn ItemIndex or itemTypeName has to be provided instead')
-        
-        itemTypeNameCopy = None
-        # itemClass = None
-        if typeString == 'ObjectIndex':
-            itemTypeNameCopy = 'Object'+mbs.GetObject(itemIndex)['objectType']
-        elif typeString == 'LoadIndex':
-            itemTypeNameCopy = 'Load'+mbs.GetLoad(itemIndex)['loadType']
-        else:
-            raise ValueError('ConvertFunctionToSymbolic: itemIndex has unsupported type')
-
-    recStored = exudyn.symbolic.GetRecording()
-    exudyn.symbolic.SetRecording(True)
-
-    #create args as dict
-    fnDict = {}
-    argList = []
-    argTypeList = []
-    
-    functionArgs = userFunctionArgsDict[itemTypeNameCopy+','+userFunctionName]
-    returnType = functionArgs[2][0]
-    nArgs = len(functionArgs[0])
-    if nArgs != function.__code__.co_argcount:
-        
-        sFunctionInterface = 'F('
-        sReturn = ' -> '+returnType+': ...'
-        sep = ''
-        for i in range(nArgs):
-            sFunctionInterface+=sep+functionArgs[1][i]+': '+functionArgs[0][i].replace('MainSystem','exudyn.MainSystem').replace('Real','float').replace('Index','int')
-            sep = ', '
-        sFunctionInterface += ')\n'
-
-        raise ValueError('ConvertFunctionToSymbolic: function "'+fnName+'" does not meet correct number of arguments; '+
-                         'user function should read:\n'+sFunctionInterface+sReturn)
-    
-    for i in range(nArgs):
-        varType = functionArgs[0][i]
-        arg = fnArgs[i] #functionArgs[1][i] 
-        if varType == 'Real':
-            var = exudyn.symbolic.Real(arg, 0.)
-        elif varType == 'Index':
-            var = exudyn.symbolic.Real(arg, 0)
-        elif (varType == 'StdVector3D'
-              or varType == 'StdVector6D'
-              or varType == 'StdVector'
-              ):
-            l = 0
-            if '3D' in varType: l = 3
-            if '6D' in varType: l = 6
-            var = exudyn.symbolic.Vector(arg,[0.]*l)
-        elif (varType == 'NumpyMatrix'
-              or varType == 'StdMatrix3D'
-              or varType == 'StdMatrix6D'
-              ):
-            rowsColumns=1 #zero list would not work for matrix ...
-            if '3D' in varType: rowsColumns = 3
-            if '6D' in varType: rowsColumns = 6
-            var = exudyn.symbolic.Matrix(arg,np.zeros((rowsColumns,rowsColumns)).tolist())
-        elif varType == 'MainSystem':
-            var = mbs
-        else:
-            raise ValueError("ConvertFunctionToSymbolic: unrecognized type in user function; type probably implemented")
-    
-        argList += [var] #float, int, MainSystem, Vector3D, etc.
-        argTypeList += [varType] #float, int, MainSystem, Vector3D, etc.
-        fnDict[arg] = var
-        
-    if verbose > 1:
-        print('\nargList=[mbs]+', argList[1:])
-        print('\nfnDict=', fnDict)
-
-    #now we record the function:
-    returnValue = function(**fnDict)
-    exudyn.symbolic.SetRecording(recStored)
-
-
-    if type(returnValue) is list:
-        #in this case, we create a SymbolicRealVector such that the user also can work with lists ...
-        returnValue = exudyn.symbolic.Vector(returnValue) #create vector from list
-
-    if verbose:
-        print('return value=', returnValue)
-
-    return {'functionName': fnName, 
-            'argList': argList, 
-            'argTypeList': argTypeList,
-            'returnValue': returnValue,
-            'returnType': returnType}
-
-
-#**function: Helper function to convert a Python user function into a symbolic user function;
-#  this function is under development and should be used with care
-#**input:
-#  mbs: MainSystem, needed currently for interface
-#  function: Python function with interface according to desired user function
-#  itemIndex: item index, such as ObjectIndex or LoadIndex; -1 indicates MainSystem; if None, itemTypeName must be provided instead
-#  itemTypeName: use of type name, such as ObjectConnectorSpringDamper; in this case, itemIndex must be None
-#  userFunctionName: name of user function item, see documentation; this is required, because some items have several user functions, which need to be distinguished
-#  verbose: if > 0, according output may be printed
-#**output: returns symbolic user function; this can be transfered into an item using TransferUserFunction2Item
-#**notes: keep the return value alive in a variable (or list), as it contains the expression tree which must exist for the lifetime of the user function
-#**example:
-# oGround = mbs.AddObject(ObjectGround())
-#
-# node = mbs.AddNode(NodePoint(referenceCoordinates = [1.05,0,0]))
-# oMassPoint = mbs.AddObject(MassPoint(nodeNumber = node, physicsMass=1))
-#
-# symbolicFunc = CreateSymbolicUserFunction(mbs, function=springForceUserFunction, 
-#                                           userFunctionName='springForceUserFunction', 
-#                                           itemTypeName='ObjectConnectorSpringDamper')
-#
-# m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=oGround, localPosition=[0,0,0]))
-# m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=oMassPoint, localPosition=[0,0,0]))
-# co = mbs.AddObject(ObjectConnectorSpringDamper(markerNumbers=[m0,m1],
-#                    referenceLength = 1, stiffness = 100, damping = 1, 
-#                    springForceUserFunction=symbolicFunc))
-#
-# print(symbolicFunc.Evaluate(mbs, 0., 0, 1.1, 0.,  100., 0., 13.) )
-def CreateSymbolicUserFunction(mbs, function, userFunctionName, itemIndex=None, itemTypeName=None, verbose=0):
-    fnDict = ConvertFunctionToSymbolic(mbs, function, userFunctionName, itemIndex, itemTypeName, verbose)
-    symbolicFunc = exudyn.symbolic.UserFunction()
-    symbolicFunc.SetUserFunctionFromDict(mbs, fnDict, userFunctionName, itemIndex, str(itemTypeName))
-    return symbolicFunc
-    
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Advanced utility functions only depending on numpy or specified exudyn modules;
+#           Here, we gather special functions, which are depending on other modules and do not fit into exudyn.utilities as they cannot be imported e.g. in rigidBodyUtilities
+#
+# Author:   Johannes Gerstmayr
+# Date:     2023-01-06 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+from math import sin, cos, pi, sqrt
+from enum import Enum
+import copy 
+
+import exudyn
+from exudyn.itemInterface import userFunctionArgsDict
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#GENERAL FUNCTIONS
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**function: helper functions for matplotlib, returns a list of 28 line codes to be used in plot, e.g. 'r-' for red solid line
+#**input: index in range(0:28)
+#**output: a color and line style code for matplotlib plot
+def PlotLineCode(index):
+    CC = ['r-','g-','b-','k-','c-','m-','y-','r:','g:','b:','k:','c:','m:','y:','r--','g--','b--','k--','c--','m--','y--','r-.','g-.','b-.','k-.','c-.','m-.','y-.']
+    if index < len(CC):
+        return CC[index]
+    else:
+        return 'k:' #black line
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#INSPECTION, needs numpy and exudyn:
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        
+#**function: simple function to find object index i within the local or global scope of variables
+#**input: i, the integer object number and  globalVariables=globals()
+#**example:
+# FindObjectIndex(2, locals() )  #usually sufficient
+# FindObjectIndex(2, globals() ) #wider search
+def FindObjectIndex(i, globalVariables):
+    #run through all variables and check if an object index exists
+    found = False
+    for varname in globalVariables:
+        if type(globalVariables[varname]) == exudyn.ObjectIndex:
+            if int(globalVariables[varname]) == int(i):
+                print("variable '"+varname+"' links to object "+str(i) )
+                found = True
+    if not found:
+        print("no according variable found")
+
+#**function: simple function to find node index i within the local or global scope of variables
+#**input: i, the integer node number and  globalVariables=globals()
+#**example:
+# FindObjectIndex(2, locals() )  #usually sufficient
+# FindObjectIndex(2, globals() ) #wider search
+def FindNodeIndex(i, globalVariables):
+    #run through all variables and check if an object index exists
+    found = False
+    for varname in globalVariables:
+        if type(globalVariables[varname]) == exudyn.NodeIndex:
+            if int(globalVariables[varname]) == int(i):
+                print("variable '"+varname+"' links to node "+str(i) )
+                found = True
+    if not found:
+        print("no according variable found")
+
+#**function: checks, if data is of type list or np.array; used in functions to check input data
+#**input:
+#  data: any type, preferrably list or numpy.array
+#  checkIfNoneEmpty: if True, function only returns True if type is list or array AND if length is non-zero
+#**output: returns True/False
+def IsListOrArray(data, checkIfNoneEmpty=False):
+    if isinstance(data,list) or isinstance(data,np.ndarray):
+        if checkIfNoneEmpty and len(data) == 0:
+            return False
+        return True
+    else:
+        return False
+
+
+#**class: internal type which is used for type checking in exudyn Python user functions; used to create unique error messages
+class ExpectedType(Enum):
+    _None = 0
+    Positive = 1
+    Unsigned = 2
+    Bool = 4
+    Int = 8
+    PInt = 8+1
+    UInt = 8+2
+    Real = 16
+    PReal = 16+1
+    UReal = 16+2
+    Vector = 32
+    IntVector = 32+8
+    Matrix = 64
+    RigidBodyInertia = 128
+    NodeIndex = 256
+    ObjectIndex = 512
+    MarkerIndex = 1024
+    LoadIndex = 2048
+    SensorIndex = 4096
+    String = 8192
+
+#**function: internal function which is used to raise common errors in case of wrong types; dim is used for vectors and square matrices, cols is used for non-square matrices
+def RaiseTypeError(where='', argumentName='', received = None, expectedType = None, dim=None, cols=None):
+    t = copy.copy(expectedType)
+    
+    errStr = 'ERROR in ' + where + ' in argument ' + argumentName + ': '
+    
+    if type(t) != str:
+        errStr += 'expected type=' + t.name
+        if t == ExpectedType.Vector or t == ExpectedType.IntVector:
+            errStr += ' (as list or numpy array)'
+        elif t == ExpectedType.Matrix:
+            errStr += ' (as list of lists or numpy array)'
+        
+        if dim != None:
+            ncols = cols
+            if t == ExpectedType.Matrix and cols == None: 
+                ncols = dim  #square Matrix
+            if ncols != None:
+                errStr += ', expected size = (' + str(dim) + ',' + str(ncols) + ')'
+            else:
+                errStr += ', expected size = ' + str(dim) 
+    else:
+        errStr += expectedType
+            
+    receivedStr = ', <argument can not be converted to string>'
+    try:
+        receivedStr  = ', but received "' + str(received) + '"'
+    except:
+        pass
+    errStr += receivedStr
+
+    raise ValueError(errStr)
+
+#**function: return True, if x is None; works also for numpy arrays or structures
+def IsNone(x):
+    return (x is None)
+
+#**function: return True, if x is not None; works also for numpy arrays or structures
+def IsNotNone(x):
+    return (x is not None)
+
+#**function: return True, if x is int, float, np.double, np.integer or similar types that can be automatically casted to pybind11
+def IsValidBool(x):
+    if (isinstance(x, bool)
+        or isinstance(x, int)
+        or isinstance(x, np.integer)
+        ):
+        return True
+    return False
+
+#**function: return True, if x is int, float, np.double, np.integer or similar types that can be automatically casted to pybind11
+def IsValidRealInt(x):
+    if (isinstance(x, float) 
+        or isinstance(x, int)
+        or isinstance(x, np.double)
+        or isinstance(x, np.integer)
+        ):
+        return True
+    return False
+
+#**function: return True, if x is valid Real/Int and positive
+def IsValidPRealInt(x):
+    if IsValidRealInt(x) and x > 0:
+        return True
+    return False
+
+#**function: return True, if x is valid Real/Int and unsigned (non-negative)
+def IsValidURealInt(x):
+    if IsValidRealInt(x) and x >= 0:
+        return True
+    return False
+
+#**function: return True, if x is any python or numpy float type; could also be called IsFloat(), but Real has special meaning in Exudyn
+def IsReal(x):
+    if isinstance(x, (np.floating, float)): 
+        return True
+    else:
+        return False
+
+#**function: return True, if x is any python or numpy float type
+def IsInteger(x):
+    if isinstance(x, (np.integer, int)): 
+        return True
+    else:
+        return False
+
+#**function: check if v is a valid vector with floats or ints; if expectedSize!=None, the length is also checked
+def IsVector(v, expectedSize=None):
+    if type(v) != list and type(v) != np.ndarray:
+        return False
+
+    if expectedSize!=None:
+        if len(v) != expectedSize:
+            return False
+
+    for x in v:
+        if not IsValidRealInt(x): return False
+
+    return True
+
+#**function: check if v is a valid vector with floats or ints; if expectedSize!=None, the length is also checked
+def IsIntVector(v, expectedSize=None):
+    if type(v) != list and type(v) != np.ndarray:
+        return False
+
+    if expectedSize!=None:
+        if len(v) != expectedSize:
+            return False
+
+    for x in v:
+        if not IsInteger(x): return False
+
+    return True
+
+
+#**function: check if v is a valid vector with floats or ints; if expectedSize!=None, the length is also checked
+def IsSquareMatrix(m, expectedSize=None):
+    if type(m) != list and type(m) != np.ndarray:
+        return False
+
+    if expectedSize!=None:
+        if len(m) != expectedSize:
+            return False
+
+    for y in m: #works both in list of lists and np.array (over rows)
+        if expectedSize!=None and len(y) != expectedSize: 
+            return False
+        for x in y:
+            if not IsValidRealInt(x): return False
+
+    return True
+
+#**function: return True, if x is valid exudyn object index
+def IsValidObjectIndex(x):
+    if isinstance(x, int) or isinstance(x, np.integer) or isinstance(x, exudyn.ObjectIndex):
+        return True
+    return False
+
+#**function: return True, if x is valid exudyn node index
+def IsValidNodeIndex(x):
+    if isinstance(x, int) or isinstance(x, np.integer) or isinstance(x, exudyn.NodeIndex):
+        return True
+    return False
+
+#**function: return True, if x is valid exudyn marker index
+def IsValidMarkerIndex(x):
+    if isinstance(x, int) or isinstance(x, np.integer) or isinstance(x, exudyn.MarkerIndex):
+        return True
+    return False
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: fill submatrix into given destinationMatrix; all matrices must be numpy arrays 
+#**input: 
+#  subMatrix: input matrix, which is filled into destinationMatrix
+#  destinationMatrix: the subMatrix is entered here
+#  destRow: row destination of subMatrix
+#  destColumn: column destination of subMatrix
+#**notes: may be erased in future!
+#**output: destinationMatrix is changed after function call
+def FillInSubMatrix(subMatrix, destinationMatrix, destRow, destColumn):
+    nRows = subMatrix.shape[0]
+    nColumns = subMatrix.shape[1]
+
+    destinationMatrix[destRow:destRow+nRows, destColumn:destColumn+nColumns] = subMatrix
+
+    #for i in range(nRows):
+    #    for j in range(nColumns):
+    #        destinationMatrix[i+destRow, j+destColumn] = subMatrix[i,j]
+
+
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute sin sweep at given time t
+#**input: 
+#  t: evaluate of sweep at time t
+#  t1: end time of sweep frequency range
+#  f0: start of frequency interval [f0,f1] in Hz
+#  f1: end of frequency interval [f0,f1] in Hz
+#**output: evaluation of sin sweep (in range -1..+1)
+def SweepSin(t, t1, f0, f1):
+    k = (f1-f0)/t1
+    return sin(2*pi*(f0+k*0.5*t)*t) #take care of factor 0.5 in k*0.5*t, in order to obtain correct frequencies!!!
+
+#**function: compute cos sweep at given time t
+#**input: 
+#  t: evaluate of sweep at time t
+#  t1: end time of sweep frequency range
+#  f0: start of frequency interval [f0,f1] in Hz
+#  f1: end of frequency interval [f0,f1] in Hz
+#**output: evaluation of cos sweep (in range -1..+1)
+def SweepCos(t, t1, f0, f1):
+    k = (f1-f0)/t1
+    return cos(2*pi*(f0+k*0.5*t)*t) #take care of factor 0.5 in k*0.5*t, in order to obtain correct frequencies!!!
+
+#**function: frequency according to given sweep functions SweepSin, SweepCos
+#**input: 
+#  t: evaluate of frequency at time t
+#  t1: end time of sweep frequency range
+#  f0: start of frequency interval [f0,f1] in Hz
+#  f1: end of frequency interval [f0,f1] in Hz
+#**output: frequency in Hz
+def FrequencySweep(t, t1, f0, f1):
+    return t*(f1-f0)/t1 + f0
+
+#**function: step function with smooth transition from value0 to value1; transition is computed with cos function
+#**input:
+#  x: argument at which function is evaluated
+#  x0: start of step (f(x) = value0)
+#  x1: end of step (f(x) = value1)
+#  value0: value before smooth step
+#  value1: value at end of smooth step
+#**output: returns f(x)
+def SmoothStep(x, x0, x1, value0, value1): 
+    loadValue = value0
+
+    if x > x0:
+        if x < x1:
+            dx = x1-x0
+            loadValue = value0 + (value1-value0) * 0.5*(1-cos((x-x0)/dx*pi)) 
+        else:
+            loadValue = value1
+    return loadValue
+
+#**function: derivative of SmoothStep using same arguments
+#**input:
+#  x: argument at which function is evaluated
+#  x0: start of step (f(x) = value0)
+#  x1: end of step (f(x) = value1)
+#  value0: value before smooth step
+#  value1: value at end of smooth step
+#**output: returns d/dx(f(x))
+def SmoothStepDerivative(x, x0, x1, value0, value1): 
+    loadValue = 0
+
+    if x > x0 and x < x1:
+        dx = x1-x0
+        loadValue = (value1-value0) * 0.5*(pi/dx*sin((x-x0)/dx*pi)) 
+    return loadValue
+
+#**function: get index from value in given data vector (numpy array); usually used to get specific index of time vector; this function is slow (linear search), if sampling rate is non-constant; otherwise set assumeConstantSampleRate=True!
+#**input: 
+#  data: containing (almost) equidistant values of time
+#  value: e.g., time to be found in data
+#  tolerance: tolerance, which is accepted (default: tolerance=1e-7)
+#  rangeWarning: warn, if index returns out of range; if warning is deactivated, function uses the closest value
+#**notes: to obtain the interpolated value of a time-signal array, use GetInterpolatedSignalValue() in exudyn.signalProcessing
+#**output: index
+def IndexFromValue(data, value, tolerance=1e-7, assumeConstantSampleRate=False, rangeWarning=True):
+    index  = -1
+    
+    if assumeConstantSampleRate and len(data) > 1:
+        dt = data[1] - data[0]
+        if dt == 0.:
+            raise ValueError('IndexFromValue: sample rate is zero!')
+        index = int((value-data[0]) / dt)
+        if index < 0:
+            index = 0
+            if rangeWarning:
+                print('Warning: IndexFromValue: index returned smaller than 0; using 0 instead')
+        elif index >= len(data):
+            if rangeWarning:
+                print('Warning: IndexFromValue: index returned larger than array length-1; using array max length-1 instead')
+            index = len(data)-1
+            
+    else:
+        bestTol = 1e37
+        for i in range(len(data)):
+            if abs(data[i] - value) < min(bestTol, tolerance):
+                index = i
+                bestTol = abs(data[i] - value)
+
+    if index == -1:
+        raise ValueError("IndexFromValue: value not found with given tolerance")
+    return index
+
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: set all entries in matrix to zero which are smaller than given treshold; operates directly on matrix
+#**input: matrix as np.array, treshold as positive value
+#**output: changes matrix
+def RoundMatrix(matrix, treshold = 1e-14):
+    (rows, cols) = matrix.shape
+    for i in range (rows):
+        for j in range(cols):
+            if abs(matrix[i,j]) < treshold:
+                matrix[i,j]=0
+
+
+
+#**function: Internal function to convert a Python user function into a dictionary containing the symbolic representation;
+#  this function is under development and should be used with care
+#**input:
+#  mbs: MainSystem, needed currently for interface
+#  function: Python function with interface according to desired user function
+#  itemIndex: item index, such as ObjectIndex or LoadIndex; -1 indicates MainSystem; if None, itemTypeName must be provided instead
+#  itemTypeName: use of type name, such as ObjectConnectorSpringDamper; in this case, itemIndex must be None
+#  itemIndex: item index, such as ObjectIndex or LoadIndex; -1 indicates MainSystem
+#  userFunctionName: name of user function item, see documentation; this is required, because some items have several user functions, which need to be distinguished
+#  verbose: if > 0, according output is printed
+#**output: return dictionary with 'functionName', 'argList', and 'returnList'
+def ConvertFunctionToSymbolic(mbs, function, userFunctionName, itemIndex=None, itemTypeName=None, verbose=0):
+    fnName = function.__name__
+    fnArgs = function.__code__.co_varnames
+    #fnAnnotations = function.__annotations__ #not necessarily present
+    if verbose:
+        #print("Annotations:", fnAnnotations)
+        print("Function Name:", fnName)
+        # print("Docstring:", function.__doc__)
+        print("Number of Arguments:", function.__code__.co_argcount)
+        print("Argument Names:", fnArgs)
+
+
+    if itemTypeName != None:
+        itemTypeNameCopy = itemTypeName
+        if itemIndex != None: raise ValueError('ConvertFunctionToSymbolic: if itemTypeName is provided, itemIndex must be None')
+    elif itemIndex == -1: #MainSystem or other function
+        itemTypeNameCopy = 'MainSystem'
+    else:
+        #regular item
+        try:
+            typeString = itemIndex.GetTypeString()
+        except:
+            raise ValueError('ConvertFunctionToSymbolic: itemIndex must be a valid exudyn ItemIndex or itemTypeName has to be provided instead')
+        
+        itemTypeNameCopy = None
+        # itemClass = None
+        if typeString == 'ObjectIndex':
+            itemTypeNameCopy = 'Object'+mbs.GetObject(itemIndex)['objectType']
+        elif typeString == 'LoadIndex':
+            itemTypeNameCopy = 'Load'+mbs.GetLoad(itemIndex)['loadType']
+        else:
+            raise ValueError('ConvertFunctionToSymbolic: itemIndex has unsupported type')
+
+    recStored = exudyn.symbolic.GetRecording()
+    exudyn.symbolic.SetRecording(True)
+
+    #create args as dict
+    fnDict = {}
+    argList = []
+    argTypeList = []
+    
+    functionArgs = userFunctionArgsDict[itemTypeNameCopy+','+userFunctionName]
+    returnType = functionArgs[2][0]
+    nArgs = len(functionArgs[0])
+    if nArgs != function.__code__.co_argcount:
+        
+        sFunctionInterface = 'F('
+        sReturn = ' -> '+returnType+': ...'
+        sep = ''
+        for i in range(nArgs):
+            sFunctionInterface+=sep+functionArgs[1][i]+': '+functionArgs[0][i].replace('MainSystem','exudyn.MainSystem').replace('Real','float').replace('Index','int')
+            sep = ', '
+        sFunctionInterface += ')\n'
+
+        raise ValueError('ConvertFunctionToSymbolic: function "'+fnName+'" does not meet correct number of arguments; '+
+                         'user function should read:\n'+sFunctionInterface+sReturn)
+    
+    for i in range(nArgs):
+        varType = functionArgs[0][i]
+        arg = fnArgs[i] #functionArgs[1][i] 
+        if varType == 'Real':
+            var = exudyn.symbolic.Real(arg, 0.)
+        elif varType == 'Index':
+            var = exudyn.symbolic.Real(arg, 0)
+        elif (varType == 'StdVector3D'
+              or varType == 'StdVector6D'
+              or varType == 'StdVector'
+              ):
+            l = 0
+            if '3D' in varType: l = 3
+            if '6D' in varType: l = 6
+            var = exudyn.symbolic.Vector(arg,[0.]*l)
+        elif (varType == 'NumpyMatrix'
+              or varType == 'StdMatrix3D'
+              or varType == 'StdMatrix6D'
+              ):
+            rowsColumns=1 #zero list would not work for matrix ...
+            if '3D' in varType: rowsColumns = 3
+            if '6D' in varType: rowsColumns = 6
+            var = exudyn.symbolic.Matrix(arg,np.zeros((rowsColumns,rowsColumns)).tolist())
+        elif varType == 'MainSystem':
+            var = mbs
+        else:
+            raise ValueError("ConvertFunctionToSymbolic: unrecognized type in user function; type probably implemented")
+    
+        argList += [var] #float, int, MainSystem, Vector3D, etc.
+        argTypeList += [varType] #float, int, MainSystem, Vector3D, etc.
+        fnDict[arg] = var
+        
+    if verbose > 1:
+        print('\nargList=[mbs]+', argList[1:])
+        print('\nfnDict=', fnDict)
+
+    #now we record the function:
+    returnValue = function(**fnDict)
+    exudyn.symbolic.SetRecording(recStored)
+
+
+    if type(returnValue) is list:
+        #in this case, we create a SymbolicRealVector such that the user also can work with lists ...
+        returnValue = exudyn.symbolic.Vector(returnValue) #create vector from list
+
+    if verbose:
+        print('return value=', returnValue)
+
+    return {'functionName': fnName, 
+            'argList': argList, 
+            'argTypeList': argTypeList,
+            'returnValue': returnValue,
+            'returnType': returnType}
+
+
+#**function: Helper function to convert a Python user function into a symbolic user function;
+#  this function is under development and should be used with care
+#**input:
+#  mbs: MainSystem, needed currently for interface
+#  function: Python function with interface according to desired user function
+#  itemIndex: item index, such as ObjectIndex or LoadIndex; -1 indicates MainSystem; if None, itemTypeName must be provided instead
+#  itemTypeName: use of type name, such as ObjectConnectorSpringDamper; in this case, itemIndex must be None
+#  userFunctionName: name of user function item, see documentation; this is required, because some items have several user functions, which need to be distinguished
+#  verbose: if > 0, according output may be printed
+#**output: returns symbolic user function; this can be transfered into an item using TransferUserFunction2Item
+#**notes: keep the return value alive in a variable (or list), as it contains the expression tree which must exist for the lifetime of the user function
+#**example:
+# oGround = mbs.AddObject(ObjectGround())
+#
+# node = mbs.AddNode(NodePoint(referenceCoordinates = [1.05,0,0]))
+# oMassPoint = mbs.AddObject(MassPoint(nodeNumber = node, physicsMass=1))
+#
+# symbolicFunc = CreateSymbolicUserFunction(mbs, function=springForceUserFunction, 
+#                                           userFunctionName='springForceUserFunction', 
+#                                           itemTypeName='ObjectConnectorSpringDamper')
+#
+# m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=oGround, localPosition=[0,0,0]))
+# m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=oMassPoint, localPosition=[0,0,0]))
+# co = mbs.AddObject(ObjectConnectorSpringDamper(markerNumbers=[m0,m1],
+#                    referenceLength = 1, stiffness = 100, damping = 1, 
+#                    springForceUserFunction=symbolicFunc))
+#
+# print(symbolicFunc.Evaluate(mbs, 0., 0, 1.1, 0.,  100., 0., 13.) )
+def CreateSymbolicUserFunction(mbs, function, userFunctionName, itemIndex=None, itemTypeName=None, verbose=0):
+    fnDict = ConvertFunctionToSymbolic(mbs, function, userFunctionName, itemIndex, itemTypeName, verbose)
+    symbolicFunc = exudyn.symbolic.UserFunction()
+    symbolicFunc.SetUserFunctionFromDict(mbs, fnDict, userFunctionName, itemIndex, str(itemTypeName))
+    return symbolicFunc
+    
+
+
+
```

## exudyn/artificialIntelligence.py

 * *Ordering differences only*

```diff
@@ -1,289 +1,289 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python artificial intelligence library
-#
-# Details:  This library collects interfaces and functionality for artificial intelligence
-#           This library is under construction (2022-05);
-#           To make use of this libraries, you need to install openAI gym with 'pip install gym';
-#           For standard machine learning algorithms, install e.g. stable\_baselines3 using 'pip install stable\_baselines3'
-#
-# Author:   Johannes Gerstmayr
-# Date:     2022-05-21 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#to be able to use this library, please:
-#pip install gym
-##optional: pip install pygame
-
-import exudyn as exu
-from exudyn.advancedUtilities import IsReal, IsInteger
-from typing import Optional #, Union
-
-import numpy as np
-
-#import gym #not needed here
-from gym import logger, spaces, Env
-
-
-#**class: interface class to set up Exudyn model which can be used as model in open AI gym;
-#         see specific class functions which contain 'OVERRIDE' to integrate your model;
-#         in general, set up a model with CreateMBS(), map state to initial values, initial values to state and action to mbs;
-class OpenAIGymInterfaceEnv(Env):
-    metadata = {'render_modes': ['human'], 'render_fps': 50}
-    #**classFunction: internal function to initialize model; store self.mbs and self.simulationSettings; special arguments **kwargs are passed to CreateMBS
-    def __init__(self, **kwargs):
-
-        #some general gym initialization
-        self.state = None
-
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #some settings, which may be changed after creation of environment:
-        self.rendererRunning=None
-        self.useRenderer = False #turn this on if needed
-        
-        #this is the high/low range of randomizer for state initialization
-        #it may also be defined as list, having the length according to the number of states
-        self.randomInitializationValue = 0.05 
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        
-        #mbs initialization        
-        self.SC = exu.SystemContainer()
-        self.mbs = self.SC.AddSystem()
-        self.simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-        
-        #add name to settings and show in animation:
-        self.simulationSettings.solutionSettings.solutionInformation = str(self.__class__).split('.')[1].split("'")[0]
-        
-        self.stateSize = self.CreateMBS(self.SC, self.mbs, self.simulationSettings, **kwargs)
-
-        self.SetupSpaces() #in future, there may be a more convenient way to do so!
-
-        #THIS NEEDS TO BE CALLED AT THE END:
-        self.PreInitializeSolver()
-        #++++++++++++++++++++++++++++
-        #now system is ready to go!
-        
-    #**classFunction: OVERRIDE this function to create multibody system mbs and setup simulationSettings; call Assemble() at the end!
-    #                 you may also change SC.visualizationSettings() individually; kwargs may be used for special setup
-    def CreateMBS(self, SC, mbs, simulationSettings, **kwargs):
-        return 0#override this class and return state size!
-
-    #**classFunction: OVERRIDE this function to set up self.action\_space and self.observation\_space
-    def SetupSpaces(self):
-        pass #override this class!
-
-
-    #**classFunction: OVERRIDE this function to map the action given by learning algorithm to the multibody system, e.g. as a load parameter
-    def MapAction2MBS(self, action):
-        pass #override this class!
-
-    #**classFunction: OVERRIDE this function to collect output of simulation and map to self.state tuple
-    #**output: return bool done which contains information if system state is outside valid range
-    def Output2StateAndDone(self):
-        return False#override this class!
-
-    
-    #**classFunction: OVERRIDE this function to maps the current state to mbs initial values
-    #**output: return [initialValues, initialValues\_t] where initialValues[\_t] are ODE2 vectors of coordinates[\_t] for the mbs
-    def State2InitialValues(self):
-        return [[0],[0]]#override this class and return the two vectors!
-
-
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #HELPER functions
-    #**classFunction: test model by running in simulation environment having several options
-    #**input: 
-    #  numberOfSteps: number of steps to test MBS and model (with or without learned model); with renderer, press 'Q' in render window to stop simulation
-    #  seed: seed value for reset function; this value initializes the randomizer; use e.g. time to obtain non-reproducible results
-    #  model: either None to just test the MBS model without learned model, or containing a learned model, e.g., with A2C; use A2C.save(...) and A2C.load(...) for storing and retrieving models
-    #  solutionFileName: if given, the MBS internal states are written to the file with given name, which can be loaded with solution viewer and visualized; solution is written every period given in simulationSettings.solutionSettings.solutionWritePeriod
-    #  useRenderer: if set True, the internal renderer is used and model updates are shown in visualization of Exudyn
-    #  return_info: internal value in reset function
-    #  sleepTime: sleep time between time steps to obtain certain frame rate for visualization
-    #  stopIfDone: if set to True, the simulation will reset as soon as the defined observation limits are reached and done is set True
-    #  showTimeSpent: if True, the total time spent is measured; this helps to check the performance of the model (e.g. how many steps can be computed per second)
-    def TestModel(self, numberOfSteps=500, seed=0, model = None, solutionFileName = None,
-                  useRenderer=True, sleepTime=0.01, stopIfDone=False, showTimeSpent=True, **kwargs):
-        import time
-
-        writeToFile = solutionFileName != None
-        self.simulationSettings.solutionSettings.writeSolutionToFile = writeToFile
-        if writeToFile:
-            self.simulationSettings.solutionSettings.coordinatesSolutionFileName = solutionFileName
-
-        storeRenderer = self.useRenderer 
-        self.useRenderer = useRenderer #set this true to show visualization
-        self.flagNan = False
-        observation, info = self.reset(seed=seed, return_info=True)
-    
-        ts = -time.time()
-        for _ in range(numberOfSteps):
-            if model != None: #use model to predict action (e.g., controller)
-                action, _state = model.predict(observation, deterministic=True)
-            else:
-                action = self.action_space.sample()
-
-            if np.isnan(self.state).any(): 
-                self.flagNan = True
-                break # 
-            observation, reward, done, info = self.step(action)
-            self.render()
-            if self.mbs.GetRenderEngineStopFlag(): #user presses quit
-                break
-            if stopIfDone and done:
-                observation, info = self.reset(return_info=True)
-            if useRenderer and sleepTime!=0:
-                time.sleep(sleepTime)        
-        if showTimeSpent:
-            print('time spent=',ts+time.time())
-
-        self.close()
-        self.useRenderer = storeRenderer #restore
-
-    #**classFunction: use solverType = exudyn.DynamicSolverType.[...] to define solver (choose between implicit and explicit solvers!)
-    def SetSolver(self, solverType):
-        self.simulationSettings == solverType
-        if solverType==exu.DynamicSolverType.TrapezoidalIndex2 or solverType==exu.DynamicSolverType.GeneralizedAlpha:
-            useIndex2 = False
-            if solverType == exu.DynamicSolverType.TrapezoidalIndex2:
-                useIndex2 = True
-
-            #manually override settings for integrator
-            self.simulationSettings.timeIntegration.generalizedAlpha.useNewmark = useIndex2
-            self.simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints = useIndex2
-        
-            self.dynamicSolver = exu.MainSolverImplicitSecondOrder()
-            self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings)
-            self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings) #to initialize all data
-        else:
-            #explicit integration:
-            self.simulationSettings.timeIntegration.explicitIntegration.dynamicSolverType = solverType
-            self.dynamicSolver = exu.MainSolverExplicit()
-            self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings)
-            self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings) #to initialize all data
-
-
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #INTERNAL FUNCTIONS!
-    #**classFunction: internal function which initializes dynamic solver; adapt in special cases; this function has some overhead and should not be called during reset() or step()
-    def PreInitializeSolver(self):
-        self.SetSolver(exu.DynamicSolverType.GeneralizedAlpha)
-        # self.dynamicSolver = exu.MainSolverImplicitSecondOrder()
-        # self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings)
-        # self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings) #to initialize all data
-
-    #**classFunction: internal function which is called to solve for one step
-    def IntegrateStep(self):
-        #exudyn simulation part
-        #index 2 solver (may have some drift, but can be restarted easily)
-
-        #progress integration time
-        currentTime = self.simulationSettings.timeIntegration.endTime
-        self.simulationSettings.timeIntegration.startTime = currentTime
-        self.simulationSettings.timeIntegration.endTime = currentTime+self.stepUpdateTime
-
-        # exu.SolveDynamic(self.mbs, self.simulationSettings, solverType=exu.DynamicSolverType.TrapezoidalIndex2,
-        #                  updateInitialValues=True) #use final value as new initial values
-        self.dynamicSolver.InitializeSolverInitialConditions(self.mbs, self.simulationSettings)
-        self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings)
-        currentState = self.mbs.systemData.GetSystemState() #get current values
-        self.mbs.systemData.SetSystemState(systemStateList=currentState, 
-                                        configuration = exu.ConfigurationType.Initial)
-        self.mbs.systemData.SetODE2Coordinates_tt(coordinates = self.mbs.systemData.GetODE2Coordinates_tt(), 
-                                                configuration = exu.ConfigurationType.Initial)
-
-    #**classFunction: openAI gym interface function which is called to compute one step
-    def step(self, action):
-        err_msg = f"{action!r} ({type(action)}) invalid"
-        assert self.action_space.contains(action), err_msg
-        assert self.state is not None, "Call reset before using step method."
-        
-        #++++++++++++++++++++++++++++++++++++++++++++++++++
-        #main steps:
-        [initialValues,initialValues_t] = self.State2InitialValues()
-        self.mbs.systemData.SetODE2Coordinates(initialValues, exu.ConfigurationType.Initial)
-        self.mbs.systemData.SetODE2Coordinates_t(initialValues_t, exu.ConfigurationType.Initial)
-
-        self.MapAction2MBS(action)
-        
-        #this may be time consuming for larger models!
-        self.IntegrateStep()
-        
-        done = self.Output2StateAndDone()
-
-        #++++++++++++++++++++++++++++++++++++++++++++++++++
-        #compute reward and done
-        if not done:
-            reward = 1.0
-        elif self.steps_beyond_done is None:
-            # Arm1 just fell!
-            self.steps_beyond_done = 0
-            reward = 1.0
-        else:
-            if self.steps_beyond_done == 0:
-                logger.warn(
-                    "You are calling 'step()' even though this "
-                    "environment has already returned done = True. You "
-                    "should always call 'reset()' once you receive 'done = "
-                    "True' -- any further steps are undefined behavior."
-                )
-            self.steps_beyond_done += 1
-            reward = 0.0
-
-        return np.array(self.state, dtype=np.float32), reward, done, {}
-
-
-    #**classFunction: openAI gym function which resets the system
-    def reset(
-        self,
-        *,
-        seed: Optional[int] = None,
-        return_info: bool = False,
-        options: Optional[dict] = None,
-    ):
-        #super().reset(seed=seed)
-        randSize = (self.stateSize)
-        #randomInitializationValue could also be a vector!
-        if not(IsReal(self.randomInitializationValue)) and not(IsInteger(self.randomInitializationValue)): 
-            # if the randomInitializationValue is not a float/int/np.floating it should be a 
-            # list or np.array to pass different initialization values for different states (thereby the list must have )
-            randSize = None
-            if type(self.randomInitializationValue) == list:  
-                # cast to array to obtain -self.randomInitializationValue
-                self.randomInitializationValue = np.array(self.randomInitializationValue)
-        self.state = np.random.uniform(low=-self.randomInitializationValue, 
-                                   high=self.randomInitializationValue, size=randSize)
-        self.steps_beyond_done = None
-
-
-        #+++++++++++++++++++++++++++++++++++++++++++++
-        #set state into initial values:
-        self.State2InitialValues()
-
-        self.simulationSettings.timeIntegration.endTime = 0
-        self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings) #needed to update initial conditions
-
-        #+++++++++++++++++++++++++++++++++++++++++++++
-
-        if not return_info:
-            return np.array(self.state, dtype=np.float32)
-        else:
-            return np.array(self.state, dtype=np.float32), {}
-
-    #**classFunction: openAI gym interface function to render the system
-    def render(self, mode="human"):
-        if self.rendererRunning==None and self.useRenderer:
-            exu.StartRenderer()
-            self.rendererRunning = True
-
-    #**classFunction: openAI gym interface function to close system after learning or simulation
-    def close(self):
-        self.dynamicSolver.FinalizeSolver(self.mbs, self.simulationSettings)
-        if self.rendererRunning==True:
-            # SC.WaitForRenderEngineStopFlag()
-            exu.StopRenderer() #safely close rendering window!
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python artificial intelligence library
+#
+# Details:  This library collects interfaces and functionality for artificial intelligence
+#           This library is under construction (2022-05);
+#           To make use of this libraries, you need to install openAI gym with 'pip install gym';
+#           For standard machine learning algorithms, install e.g. stable\_baselines3 using 'pip install stable\_baselines3'
+#
+# Author:   Johannes Gerstmayr
+# Date:     2022-05-21 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#to be able to use this library, please:
+#pip install gym
+##optional: pip install pygame
+
+import exudyn as exu
+from exudyn.advancedUtilities import IsReal, IsInteger
+from typing import Optional #, Union
+
+import numpy as np
+
+#import gym #not needed here
+from gym import logger, spaces, Env
+
+
+#**class: interface class to set up Exudyn model which can be used as model in open AI gym;
+#         see specific class functions which contain 'OVERRIDE' to integrate your model;
+#         in general, set up a model with CreateMBS(), map state to initial values, initial values to state and action to mbs;
+class OpenAIGymInterfaceEnv(Env):
+    metadata = {'render_modes': ['human'], 'render_fps': 50}
+    #**classFunction: internal function to initialize model; store self.mbs and self.simulationSettings; special arguments **kwargs are passed to CreateMBS
+    def __init__(self, **kwargs):
+
+        #some general gym initialization
+        self.state = None
+
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #some settings, which may be changed after creation of environment:
+        self.rendererRunning=None
+        self.useRenderer = False #turn this on if needed
+        
+        #this is the high/low range of randomizer for state initialization
+        #it may also be defined as list, having the length according to the number of states
+        self.randomInitializationValue = 0.05 
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        
+        #mbs initialization        
+        self.SC = exu.SystemContainer()
+        self.mbs = self.SC.AddSystem()
+        self.simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+        
+        #add name to settings and show in animation:
+        self.simulationSettings.solutionSettings.solutionInformation = str(self.__class__).split('.')[1].split("'")[0]
+        
+        self.stateSize = self.CreateMBS(self.SC, self.mbs, self.simulationSettings, **kwargs)
+
+        self.SetupSpaces() #in future, there may be a more convenient way to do so!
+
+        #THIS NEEDS TO BE CALLED AT THE END:
+        self.PreInitializeSolver()
+        #++++++++++++++++++++++++++++
+        #now system is ready to go!
+        
+    #**classFunction: OVERRIDE this function to create multibody system mbs and setup simulationSettings; call Assemble() at the end!
+    #                 you may also change SC.visualizationSettings() individually; kwargs may be used for special setup
+    def CreateMBS(self, SC, mbs, simulationSettings, **kwargs):
+        return 0#override this class and return state size!
+
+    #**classFunction: OVERRIDE this function to set up self.action\_space and self.observation\_space
+    def SetupSpaces(self):
+        pass #override this class!
+
+
+    #**classFunction: OVERRIDE this function to map the action given by learning algorithm to the multibody system, e.g. as a load parameter
+    def MapAction2MBS(self, action):
+        pass #override this class!
+
+    #**classFunction: OVERRIDE this function to collect output of simulation and map to self.state tuple
+    #**output: return bool done which contains information if system state is outside valid range
+    def Output2StateAndDone(self):
+        return False#override this class!
+
+    
+    #**classFunction: OVERRIDE this function to maps the current state to mbs initial values
+    #**output: return [initialValues, initialValues\_t] where initialValues[\_t] are ODE2 vectors of coordinates[\_t] for the mbs
+    def State2InitialValues(self):
+        return [[0],[0]]#override this class and return the two vectors!
+
+
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #HELPER functions
+    #**classFunction: test model by running in simulation environment having several options
+    #**input: 
+    #  numberOfSteps: number of steps to test MBS and model (with or without learned model); with renderer, press 'Q' in render window to stop simulation
+    #  seed: seed value for reset function; this value initializes the randomizer; use e.g. time to obtain non-reproducible results
+    #  model: either None to just test the MBS model without learned model, or containing a learned model, e.g., with A2C; use A2C.save(...) and A2C.load(...) for storing and retrieving models
+    #  solutionFileName: if given, the MBS internal states are written to the file with given name, which can be loaded with solution viewer and visualized; solution is written every period given in simulationSettings.solutionSettings.solutionWritePeriod
+    #  useRenderer: if set True, the internal renderer is used and model updates are shown in visualization of Exudyn
+    #  return_info: internal value in reset function
+    #  sleepTime: sleep time between time steps to obtain certain frame rate for visualization
+    #  stopIfDone: if set to True, the simulation will reset as soon as the defined observation limits are reached and done is set True
+    #  showTimeSpent: if True, the total time spent is measured; this helps to check the performance of the model (e.g. how many steps can be computed per second)
+    def TestModel(self, numberOfSteps=500, seed=0, model = None, solutionFileName = None,
+                  useRenderer=True, sleepTime=0.01, stopIfDone=False, showTimeSpent=True, **kwargs):
+        import time
+
+        writeToFile = solutionFileName != None
+        self.simulationSettings.solutionSettings.writeSolutionToFile = writeToFile
+        if writeToFile:
+            self.simulationSettings.solutionSettings.coordinatesSolutionFileName = solutionFileName
+
+        storeRenderer = self.useRenderer 
+        self.useRenderer = useRenderer #set this true to show visualization
+        self.flagNan = False
+        observation, info = self.reset(seed=seed, return_info=True)
+    
+        ts = -time.time()
+        for _ in range(numberOfSteps):
+            if model != None: #use model to predict action (e.g., controller)
+                action, _state = model.predict(observation, deterministic=True)
+            else:
+                action = self.action_space.sample()
+
+            if np.isnan(self.state).any(): 
+                self.flagNan = True
+                break # 
+            observation, reward, done, info = self.step(action)
+            self.render()
+            if self.mbs.GetRenderEngineStopFlag(): #user presses quit
+                break
+            if stopIfDone and done:
+                observation, info = self.reset(return_info=True)
+            if useRenderer and sleepTime!=0:
+                time.sleep(sleepTime)        
+        if showTimeSpent:
+            print('time spent=',ts+time.time())
+
+        self.close()
+        self.useRenderer = storeRenderer #restore
+
+    #**classFunction: use solverType = exudyn.DynamicSolverType.[...] to define solver (choose between implicit and explicit solvers!)
+    def SetSolver(self, solverType):
+        self.simulationSettings == solverType
+        if solverType==exu.DynamicSolverType.TrapezoidalIndex2 or solverType==exu.DynamicSolverType.GeneralizedAlpha:
+            useIndex2 = False
+            if solverType == exu.DynamicSolverType.TrapezoidalIndex2:
+                useIndex2 = True
+
+            #manually override settings for integrator
+            self.simulationSettings.timeIntegration.generalizedAlpha.useNewmark = useIndex2
+            self.simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints = useIndex2
+        
+            self.dynamicSolver = exu.MainSolverImplicitSecondOrder()
+            self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings)
+            self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings) #to initialize all data
+        else:
+            #explicit integration:
+            self.simulationSettings.timeIntegration.explicitIntegration.dynamicSolverType = solverType
+            self.dynamicSolver = exu.MainSolverExplicit()
+            self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings)
+            self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings) #to initialize all data
+
+
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #INTERNAL FUNCTIONS!
+    #**classFunction: internal function which initializes dynamic solver; adapt in special cases; this function has some overhead and should not be called during reset() or step()
+    def PreInitializeSolver(self):
+        self.SetSolver(exu.DynamicSolverType.GeneralizedAlpha)
+        # self.dynamicSolver = exu.MainSolverImplicitSecondOrder()
+        # self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings)
+        # self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings) #to initialize all data
+
+    #**classFunction: internal function which is called to solve for one step
+    def IntegrateStep(self):
+        #exudyn simulation part
+        #index 2 solver (may have some drift, but can be restarted easily)
+
+        #progress integration time
+        currentTime = self.simulationSettings.timeIntegration.endTime
+        self.simulationSettings.timeIntegration.startTime = currentTime
+        self.simulationSettings.timeIntegration.endTime = currentTime+self.stepUpdateTime
+
+        # exu.SolveDynamic(self.mbs, self.simulationSettings, solverType=exu.DynamicSolverType.TrapezoidalIndex2,
+        #                  updateInitialValues=True) #use final value as new initial values
+        self.dynamicSolver.InitializeSolverInitialConditions(self.mbs, self.simulationSettings)
+        self.dynamicSolver.SolveSteps(self.mbs, self.simulationSettings)
+        currentState = self.mbs.systemData.GetSystemState() #get current values
+        self.mbs.systemData.SetSystemState(systemStateList=currentState, 
+                                        configuration = exu.ConfigurationType.Initial)
+        self.mbs.systemData.SetODE2Coordinates_tt(coordinates = self.mbs.systemData.GetODE2Coordinates_tt(), 
+                                                configuration = exu.ConfigurationType.Initial)
+
+    #**classFunction: openAI gym interface function which is called to compute one step
+    def step(self, action):
+        err_msg = f"{action!r} ({type(action)}) invalid"
+        assert self.action_space.contains(action), err_msg
+        assert self.state is not None, "Call reset before using step method."
+        
+        #++++++++++++++++++++++++++++++++++++++++++++++++++
+        #main steps:
+        [initialValues,initialValues_t] = self.State2InitialValues()
+        self.mbs.systemData.SetODE2Coordinates(initialValues, exu.ConfigurationType.Initial)
+        self.mbs.systemData.SetODE2Coordinates_t(initialValues_t, exu.ConfigurationType.Initial)
+
+        self.MapAction2MBS(action)
+        
+        #this may be time consuming for larger models!
+        self.IntegrateStep()
+        
+        done = self.Output2StateAndDone()
+
+        #++++++++++++++++++++++++++++++++++++++++++++++++++
+        #compute reward and done
+        if not done:
+            reward = 1.0
+        elif self.steps_beyond_done is None:
+            # Arm1 just fell!
+            self.steps_beyond_done = 0
+            reward = 1.0
+        else:
+            if self.steps_beyond_done == 0:
+                logger.warn(
+                    "You are calling 'step()' even though this "
+                    "environment has already returned done = True. You "
+                    "should always call 'reset()' once you receive 'done = "
+                    "True' -- any further steps are undefined behavior."
+                )
+            self.steps_beyond_done += 1
+            reward = 0.0
+
+        return np.array(self.state, dtype=np.float32), reward, done, {}
+
+
+    #**classFunction: openAI gym function which resets the system
+    def reset(
+        self,
+        *,
+        seed: Optional[int] = None,
+        return_info: bool = False,
+        options: Optional[dict] = None,
+    ):
+        #super().reset(seed=seed)
+        randSize = (self.stateSize)
+        #randomInitializationValue could also be a vector!
+        if not(IsReal(self.randomInitializationValue)) and not(IsInteger(self.randomInitializationValue)): 
+            # if the randomInitializationValue is not a float/int/np.floating it should be a 
+            # list or np.array to pass different initialization values for different states (thereby the list must have )
+            randSize = None
+            if type(self.randomInitializationValue) == list:  
+                # cast to array to obtain -self.randomInitializationValue
+                self.randomInitializationValue = np.array(self.randomInitializationValue)
+        self.state = np.random.uniform(low=-self.randomInitializationValue, 
+                                   high=self.randomInitializationValue, size=randSize)
+        self.steps_beyond_done = None
+
+
+        #+++++++++++++++++++++++++++++++++++++++++++++
+        #set state into initial values:
+        self.State2InitialValues()
+
+        self.simulationSettings.timeIntegration.endTime = 0
+        self.dynamicSolver.InitializeSolver(self.mbs, self.simulationSettings) #needed to update initial conditions
+
+        #+++++++++++++++++++++++++++++++++++++++++++++
+
+        if not return_info:
+            return np.array(self.state, dtype=np.float32)
+        else:
+            return np.array(self.state, dtype=np.float32), {}
+
+    #**classFunction: openAI gym interface function to render the system
+    def render(self, mode="human"):
+        if self.rendererRunning==None and self.useRenderer:
+            exu.StartRenderer()
+            self.rendererRunning = True
+
+    #**classFunction: openAI gym interface function to close system after learning or simulation
+    def close(self):
+        self.dynamicSolver.FinalizeSolver(self.mbs, self.simulationSettings)
+        if self.rendererRunning==True:
+            # SC.WaitForRenderEngineStopFlag()
+            exu.StopRenderer() #safely close rendering window!
+
```

## exudyn/basicUtilities.py

 * *Ordering differences only*

```diff
@@ -1,283 +1,283 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Basic utility functions and constants, not depending on numpy or other python modules.
-#
-# Author:   Johannes Gerstmayr
-# Date:     2020-03-10 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-# Notes:    Additional constants are defined: \\
-#           pi = 3.1415926535897932 \\
-#           sqrt2 = 2**0.5\\
-#           g=9.81\\
-#           eye2D (2x2 diagonal matrix)\\
-#           eye3D (3x3 diagonal matrix)\\
-#           Two variables 'gaussIntegrationPoints' and 'gaussIntegrationWeights' define integration points and weights for function GaussIntegrate(...)
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import math #always available in Python
-
-#define some constants which would require external libraries
-#pi = 3.1415926535897932 #define pi in order to avoid importing large libraries; identical to from math import pi
-pi = math.pi
-sqrt2 = 2.**0.5
-g = 9.81 #gravity constant
-
-
-#**function: clear all workspace variables except for system variables with '\_' at beginning, 
-#           'func' or 'module' in name; it also deletes all items in exudyn.sys and exudyn.variables, 
-#           EXCEPT from exudyn.sys['renderState'] for pertaining the previous view of the renderer
-#**notes:   Use this function with CARE! In Spyder, it is certainly safer to add the preference Run$\ra$'remove all variables before execution'. It is recommended to call ClearWorkspace() at the very beginning of your models, to avoid that variables still exist from previous computations which may destroy repeatability of results
-#**example:
-#import exudyn as exu
-#import exudyn.utilities
-##clear workspace at the very beginning, before loading other modules and potentially destroying unwanted things ...
-#ClearWorkspace()       #cleanup
-#
-##now continue with other code
-#from exudyn.itemInterface import *
-#SC = exu.SystemContainer()
-#mbs = SC.AddSystem()
-#...
-def ClearWorkspace():
-    #if __name__ == "__main__":  #this won't work as the function is not running in __main__, but in exudyn.basicUtilities
-    gl = globals().copy()
-    #print(globals())
-
-    for var in gl:
-        if var[0] == '_': continue
-        if 'func' in str(globals()[var]): continue
-        if 'module' in str(globals()[var]): continue
-        #print('delete var=', var)
-        del globals()[var]
-
-    import inspect
-    fglobals = inspect.stack()[1][0].f_globals
-    gl2 = fglobals.copy() #these are the globals of the caller
-    for var in gl2:
-        if var[0] == '_': continue
-        if 'func' in str(fglobals[var]): continue
-        if 'module' in str(fglobals[var]): continue
-        #print('delete caller file var=', var)
-        del fglobals[var]
-
-
-    import sys
-    if 'exudyn' in sys.modules:
-        import exudyn #previously, it may have been loaded under another name (e.g., exu)
-        # print('cleanup exudyn')
-        sysCopy = exudyn.sys.copy()
-        for (key,value) in sysCopy.items():
-            if (#key != 'currentRendererSystemContainer' and
-                key != 'renderState'):
-                # print('key=', key)
-                del exudyn.sys[key]
-        variablesCopy = exudyn.variables.copy()
-        for (key,value) in variablesCopy.items():
-            del exudyn.variables[key]
-
-    if 'matplotlib' in sys.modules: #if already imported, we check if there are open figures (which would be lost otherwise)
-        import matplotlib.pyplot as plt
-        plt.close('all')
-
-#**function: round to max number of digits; may give more digits if this is shorter; using in general the format() with '.g' option, but keeping decimal point and using exponent where necessary
-def SmartRound2String(x, prec=3):
-    s = ("{:.0"+str(prec)+"g}").format(x)
-    if abs(x) > 1 and x != int(x) and '.' not in s and 'e' not in s:
-        s = s+'.'
-    if x == int(x) and len(s) > len(str(x)):
-        s = str(x)
-    return s
-        
-
-
-#**function: create a diagonal or identity matrix; used for interface.py, avoiding the need for numpy
-#**input: 
-#       rowsColumns: provides the number of rows and columns
-#       value: initialization value for diagonal terms
-#**output: list of lists representing a matrix
-def DiagonalMatrix(rowsColumns, value=1):
-    m = []
-    for i in range(rowsColumns):
-        m += [rowsColumns*[0]]
-        m[i][i] = value
-    return m
-
-eye2D = DiagonalMatrix(rowsColumns=2,value=1.) #2x2 identity matrix
-eye3D = DiagonalMatrix(rowsColumns=3,value=1.) #3x3 identity matrix
-#eye4D = DiagonalMatrix(rowsColumns=4,value=1.) #4x4 identity matrix
-
-#**function: compute L2 norm for vectors without switching to numpy or math module
-#**input: vector as list or in numpy format
-#**output: L2-norm of vector
-def NormL2(vector):
-    value = 0
-    for x in vector:
-        value += x**2
-    return value**0.5
-
-#**function: compute sum of all values of vector
-#**input: vector as list or in numpy format
-#**output: sum of all components of vector
-def VSum(vector):
-    value = 0
-    for x in vector:
-        value += x
-    return value
-
-#**function: add two vectors instead using numpy
-#**input: vectors v0 and v1 as list or in numpy format
-#**output: component-wise sum of v0 and v1
-def VAdd(v0, v1):
-    if len(v0) != len(v1): print("ERROR in VAdd: incompatible vectors!")
-    n = len(v0)
-    v = [0]*n
-    for i in range(n):
-        v[i] = v0[i]+v1[i]
-    return v
-
-#**function: subtract two vectors instead using numpy: result = v0-v1
-#**input: vectors v0 and v1 as list or in numpy format
-#**output: component-wise difference of v0 and v1
-def VSub(v0, v1):
-    if len(v0) != len(v1): print("ERROR in VSub: incompatible vectors!")
-    n = len(v0)
-    v = [0]*n
-    for i in range(n):
-        v[i] = v0[i]-v1[i]
-    return v
-
-#**function: scalar multiplication of two vectors instead using numpy: result = v0' * v1
-#**input: vectors v0 and v1 as list or in numpy format
-#**output: sum of all component wise products: c0[0]*v1[0] + v0[1]*v1[0] + ...
-def VMult(v0, v1):
-    if len(v0) != len(v1): print("ERROR in VMult: incompatible vectors!")
-    r = 0
-    for i in range(len(v0)):
-        r += v0[i]*v1[i]
-    return r
-
-#**function: multiplication vectors with scalar: result = scalar * v
-#**input: value {\it scalar} and vector {\it v} as list or in numpy format
-#**output: scalar multiplication of all components of v: [scalar*v[0], scalar*v[1], ...]
-def ScalarMult(scalar, v):
-    res=[0]*len(v)
-    for i in range(len(v)):
-        res[i] += scalar*v[i]
-    return res
-
-#**function: take a 3D vector and return a normalized 3D vector (L2Norm=1)
-#**input: vector v as list or in numpy format
-#**output: vector v multiplied with scalar such that L2-norm of vector is 1
-def Normalize(v):
-    #v=copy.deepcopy(vector) #copy, such that vector is not changed
-    v2=[0]*len(v)
-
-    fact = NormL2(v)
-    if fact != 0:
-        fact = 1./fact
-
-    for i in range(len(v2)): 
-        v2[i]=fact*v[i]
-    return v2
-    
-#**function: apply tilde operator (skew) to 3D-vector and return skew matrix
-#**input: 3D vector v as list or in numpy format
-#**output: matrix as list of lists with the skew-symmetric matrix from v: 
-#  $\left[\!\! \begin{array}{ccc} 0 & -v[2] & v[1] \\ v[2] & 0 & -v[0] \\ -v[1] & v[0] & 0  \end{array} \!\!\right]$
-def Vec2Tilde(v):
-    print('Vec2Tilde is deprecated; use exudyn.rigidBodyUtilities.Skew(...)')
-    return [[0.,-v[2],v[1]],[v[2],0.,-v[0]],[-v[1],v[0],0.]]
-
-#**function: take skew symmetric matrix and return vector (inverse of Skew(...))
-#**input: list of lists containing a skew-symmetric matrix (3x3)
-#**output: list containing the vector v (inverse function of Vec2Tilde(...))
-def Tilde2Vec(m):
-    print('Tilde2Vec is deprecated; use exudyn.rigidBodyUtilities.Skew2Vec(...)')
-    return [-m[1][2], m[0][2], -m[0][1]]
-
-#integration points per integration order (1, 3, ...); for interval [-1,1]
-gaussIntegrationPoints=[[0],
-                        [-(1. / 3.)**0.5, (1. / 3.)**0.5],
-                        [-(3. / 5.)**0.5, 0., (3. / 5.)**0.5],
-                        [-(3. / 7. + (120.)**0.5 / 35.)**0.5, -(3. / 7. - (120.)**0.5 / 35.)**0.5, (3. / 7. - (120.)**0.5 / 35.)**0.5, (3. / 7. + (120.)**0.5 / 35.)**0.5],
-                        [-0.906179845938664, -0.5384693101056831, 0., 0.5384693101056831, 0.906179845938664],
-                        ]
-
-#integration weights per integration order (1, 3, ...); for interval [-1,1]
-gaussIntegrationWeights=[[2],
-                         [1., 1.],
-                         [5. / 9., 8. / 9., 5. / 9.],
-                         [1. / 2. - 5. / (3.*(120.)**0.5), 1. / 2. + 5. / (3.*(120.)**0.5), 1. / 2. + 5. / (3.*(120.)**0.5), 1. / 2. - 5. / (3.*(120.)**0.5)],
-                         [0.23692688505618914, 0.47862867049936636, 0.5688888888888889, 0.47862867049936636, 0.23692688505618914],
-                         ]
-
-#**function: compute numerical integration of functionOfX in interval [a,b] using Gaussian integration
-#**input: 
-#  functionOfX: scalar, vector or matrix-valued function with scalar argument (X or other variable)
-#  integrationOrder: odd number in \{1,3,5,7,9\}; currently maximum order is 9
-#  a: integration range start 
-#  b: integration range end 
-#**output: (scalar or vectorized) integral value
-def GaussIntegrate(functionOfX, integrationOrder, a, b):
-    cnt = 0
-    value = 0*functionOfX(0) #initialize value with correct shape
-    if integrationOrder > 9:
-        raise ValueError("GaussIntegrate: maximum implemented integration order is 9!")
-    if integrationOrder%2 != 1 or integrationOrder < 1:
-        raise ValueError("GaussIntegrate: integration order must be odd (1,3,5,...) and > 0")
-    
-    points = gaussIntegrationPoints[int(integrationOrder/2)]
-    weights = gaussIntegrationWeights[int(integrationOrder/2)]
-    
-    for p in points:
-        x = 0.5*(b - a)*p + 0.5*(b + a)
-        value += 0.5*(b - a)*weights[cnt]*functionOfX(x);
-        cnt += 1
-
-    return value
-
-
-#integration points per integration order (1, 3, ...); for interval [-1,1]
-lobattoIntegrationPoints=[[-1.,1.],
-                          [-1., 0., 1.],
-                          [-1., -(1./5.)**0.5, (1./5.)**0.5, 1.]]
-
-#integration weights per integration order (1, 3, ...); for interval [-1,1]
-lobattoIntegrationWeights=[[ 1., 1.],
-                           [ 1./3., 4./3., 1./3.],
-                           [ 1./6., 5./6., 5./6., 1./6.]]
-
-#**function: compute numerical integration of functionOfX in interval [a,b] using Lobatto integration
-#**input: 
-#  functionOfX: scalar, vector or matrix-valued function with scalar argument (X or other variable)
-#  integrationOrder: odd number in \{1,3,5\}; currently maximum order is 5
-#  a: integration range start 
-#  b: integration range end 
-#**output: (scalar or vectorized) integral value
-def LobattoIntegrate(functionOfX, integrationOrder, a, b):
-    cnt = 0
-    value = 0*functionOfX(0) #initialize value with correct shape
-    if integrationOrder > 5:
-        raise ValueError("LobattoIntegrate: maximum implemented integration order is 5!")
-    if integrationOrder%2 != 1 or integrationOrder < 1:
-        raise ValueError("LobattoIntegrate: integration order must be odd (1,3,5,...) and >= 1")
-    
-    points = lobattoIntegrationPoints[int(integrationOrder/2)]
-    weights = lobattoIntegrationWeights[int(integrationOrder/2)]
-    
-    for p in points:
-        x = 0.5*(b - a)*p + 0.5*(b + a)
-        value += 0.5*(b - a)*weights[cnt]*functionOfX(x);
-        cnt += 1
-
-    return value
-
-
-
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Basic utility functions and constants, not depending on numpy or other python modules.
+#
+# Author:   Johannes Gerstmayr
+# Date:     2020-03-10 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+# Notes:    Additional constants are defined: \\
+#           pi = 3.1415926535897932 \\
+#           sqrt2 = 2**0.5\\
+#           g=9.81\\
+#           eye2D (2x2 diagonal matrix)\\
+#           eye3D (3x3 diagonal matrix)\\
+#           Two variables 'gaussIntegrationPoints' and 'gaussIntegrationWeights' define integration points and weights for function GaussIntegrate(...)
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import math #always available in Python
+
+#define some constants which would require external libraries
+#pi = 3.1415926535897932 #define pi in order to avoid importing large libraries; identical to from math import pi
+pi = math.pi
+sqrt2 = 2.**0.5
+g = 9.81 #gravity constant
+
+
+#**function: clear all workspace variables except for system variables with '\_' at beginning, 
+#           'func' or 'module' in name; it also deletes all items in exudyn.sys and exudyn.variables, 
+#           EXCEPT from exudyn.sys['renderState'] for pertaining the previous view of the renderer
+#**notes:   Use this function with CARE! In Spyder, it is certainly safer to add the preference Run$\ra$'remove all variables before execution'. It is recommended to call ClearWorkspace() at the very beginning of your models, to avoid that variables still exist from previous computations which may destroy repeatability of results
+#**example:
+#import exudyn as exu
+#import exudyn.utilities
+##clear workspace at the very beginning, before loading other modules and potentially destroying unwanted things ...
+#ClearWorkspace()       #cleanup
+#
+##now continue with other code
+#from exudyn.itemInterface import *
+#SC = exu.SystemContainer()
+#mbs = SC.AddSystem()
+#...
+def ClearWorkspace():
+    #if __name__ == "__main__":  #this won't work as the function is not running in __main__, but in exudyn.basicUtilities
+    gl = globals().copy()
+    #print(globals())
+
+    for var in gl:
+        if var[0] == '_': continue
+        if 'func' in str(globals()[var]): continue
+        if 'module' in str(globals()[var]): continue
+        #print('delete var=', var)
+        del globals()[var]
+
+    import inspect
+    fglobals = inspect.stack()[1][0].f_globals
+    gl2 = fglobals.copy() #these are the globals of the caller
+    for var in gl2:
+        if var[0] == '_': continue
+        if 'func' in str(fglobals[var]): continue
+        if 'module' in str(fglobals[var]): continue
+        #print('delete caller file var=', var)
+        del fglobals[var]
+
+
+    import sys
+    if 'exudyn' in sys.modules:
+        import exudyn #previously, it may have been loaded under another name (e.g., exu)
+        # print('cleanup exudyn')
+        sysCopy = exudyn.sys.copy()
+        for (key,value) in sysCopy.items():
+            if (#key != 'currentRendererSystemContainer' and
+                key != 'renderState'):
+                # print('key=', key)
+                del exudyn.sys[key]
+        variablesCopy = exudyn.variables.copy()
+        for (key,value) in variablesCopy.items():
+            del exudyn.variables[key]
+
+    if 'matplotlib' in sys.modules: #if already imported, we check if there are open figures (which would be lost otherwise)
+        import matplotlib.pyplot as plt
+        plt.close('all')
+
+#**function: round to max number of digits; may give more digits if this is shorter; using in general the format() with '.g' option, but keeping decimal point and using exponent where necessary
+def SmartRound2String(x, prec=3):
+    s = ("{:.0"+str(prec)+"g}").format(x)
+    if abs(x) > 1 and x != int(x) and '.' not in s and 'e' not in s:
+        s = s+'.'
+    if x == int(x) and len(s) > len(str(x)):
+        s = str(x)
+    return s
+        
+
+
+#**function: create a diagonal or identity matrix; used for interface.py, avoiding the need for numpy
+#**input: 
+#       rowsColumns: provides the number of rows and columns
+#       value: initialization value for diagonal terms
+#**output: list of lists representing a matrix
+def DiagonalMatrix(rowsColumns, value=1):
+    m = []
+    for i in range(rowsColumns):
+        m += [rowsColumns*[0]]
+        m[i][i] = value
+    return m
+
+eye2D = DiagonalMatrix(rowsColumns=2,value=1.) #2x2 identity matrix
+eye3D = DiagonalMatrix(rowsColumns=3,value=1.) #3x3 identity matrix
+#eye4D = DiagonalMatrix(rowsColumns=4,value=1.) #4x4 identity matrix
+
+#**function: compute L2 norm for vectors without switching to numpy or math module
+#**input: vector as list or in numpy format
+#**output: L2-norm of vector
+def NormL2(vector):
+    value = 0
+    for x in vector:
+        value += x**2
+    return value**0.5
+
+#**function: compute sum of all values of vector
+#**input: vector as list or in numpy format
+#**output: sum of all components of vector
+def VSum(vector):
+    value = 0
+    for x in vector:
+        value += x
+    return value
+
+#**function: add two vectors instead using numpy
+#**input: vectors v0 and v1 as list or in numpy format
+#**output: component-wise sum of v0 and v1
+def VAdd(v0, v1):
+    if len(v0) != len(v1): print("ERROR in VAdd: incompatible vectors!")
+    n = len(v0)
+    v = [0]*n
+    for i in range(n):
+        v[i] = v0[i]+v1[i]
+    return v
+
+#**function: subtract two vectors instead using numpy: result = v0-v1
+#**input: vectors v0 and v1 as list or in numpy format
+#**output: component-wise difference of v0 and v1
+def VSub(v0, v1):
+    if len(v0) != len(v1): print("ERROR in VSub: incompatible vectors!")
+    n = len(v0)
+    v = [0]*n
+    for i in range(n):
+        v[i] = v0[i]-v1[i]
+    return v
+
+#**function: scalar multiplication of two vectors instead using numpy: result = v0' * v1
+#**input: vectors v0 and v1 as list or in numpy format
+#**output: sum of all component wise products: c0[0]*v1[0] + v0[1]*v1[0] + ...
+def VMult(v0, v1):
+    if len(v0) != len(v1): print("ERROR in VMult: incompatible vectors!")
+    r = 0
+    for i in range(len(v0)):
+        r += v0[i]*v1[i]
+    return r
+
+#**function: multiplication vectors with scalar: result = scalar * v
+#**input: value {\it scalar} and vector {\it v} as list or in numpy format
+#**output: scalar multiplication of all components of v: [scalar*v[0], scalar*v[1], ...]
+def ScalarMult(scalar, v):
+    res=[0]*len(v)
+    for i in range(len(v)):
+        res[i] += scalar*v[i]
+    return res
+
+#**function: take a 3D vector and return a normalized 3D vector (L2Norm=1)
+#**input: vector v as list or in numpy format
+#**output: vector v multiplied with scalar such that L2-norm of vector is 1
+def Normalize(v):
+    #v=copy.deepcopy(vector) #copy, such that vector is not changed
+    v2=[0]*len(v)
+
+    fact = NormL2(v)
+    if fact != 0:
+        fact = 1./fact
+
+    for i in range(len(v2)): 
+        v2[i]=fact*v[i]
+    return v2
+    
+#**function: apply tilde operator (skew) to 3D-vector and return skew matrix
+#**input: 3D vector v as list or in numpy format
+#**output: matrix as list of lists with the skew-symmetric matrix from v: 
+#  $\left[\!\! \begin{array}{ccc} 0 & -v[2] & v[1] \\ v[2] & 0 & -v[0] \\ -v[1] & v[0] & 0  \end{array} \!\!\right]$
+def Vec2Tilde(v):
+    print('Vec2Tilde is deprecated; use exudyn.rigidBodyUtilities.Skew(...)')
+    return [[0.,-v[2],v[1]],[v[2],0.,-v[0]],[-v[1],v[0],0.]]
+
+#**function: take skew symmetric matrix and return vector (inverse of Skew(...))
+#**input: list of lists containing a skew-symmetric matrix (3x3)
+#**output: list containing the vector v (inverse function of Vec2Tilde(...))
+def Tilde2Vec(m):
+    print('Tilde2Vec is deprecated; use exudyn.rigidBodyUtilities.Skew2Vec(...)')
+    return [-m[1][2], m[0][2], -m[0][1]]
+
+#integration points per integration order (1, 3, ...); for interval [-1,1]
+gaussIntegrationPoints=[[0],
+                        [-(1. / 3.)**0.5, (1. / 3.)**0.5],
+                        [-(3. / 5.)**0.5, 0., (3. / 5.)**0.5],
+                        [-(3. / 7. + (120.)**0.5 / 35.)**0.5, -(3. / 7. - (120.)**0.5 / 35.)**0.5, (3. / 7. - (120.)**0.5 / 35.)**0.5, (3. / 7. + (120.)**0.5 / 35.)**0.5],
+                        [-0.906179845938664, -0.5384693101056831, 0., 0.5384693101056831, 0.906179845938664],
+                        ]
+
+#integration weights per integration order (1, 3, ...); for interval [-1,1]
+gaussIntegrationWeights=[[2],
+                         [1., 1.],
+                         [5. / 9., 8. / 9., 5. / 9.],
+                         [1. / 2. - 5. / (3.*(120.)**0.5), 1. / 2. + 5. / (3.*(120.)**0.5), 1. / 2. + 5. / (3.*(120.)**0.5), 1. / 2. - 5. / (3.*(120.)**0.5)],
+                         [0.23692688505618914, 0.47862867049936636, 0.5688888888888889, 0.47862867049936636, 0.23692688505618914],
+                         ]
+
+#**function: compute numerical integration of functionOfX in interval [a,b] using Gaussian integration
+#**input: 
+#  functionOfX: scalar, vector or matrix-valued function with scalar argument (X or other variable)
+#  integrationOrder: odd number in \{1,3,5,7,9\}; currently maximum order is 9
+#  a: integration range start 
+#  b: integration range end 
+#**output: (scalar or vectorized) integral value
+def GaussIntegrate(functionOfX, integrationOrder, a, b):
+    cnt = 0
+    value = 0*functionOfX(0) #initialize value with correct shape
+    if integrationOrder > 9:
+        raise ValueError("GaussIntegrate: maximum implemented integration order is 9!")
+    if integrationOrder%2 != 1 or integrationOrder < 1:
+        raise ValueError("GaussIntegrate: integration order must be odd (1,3,5,...) and > 0")
+    
+    points = gaussIntegrationPoints[int(integrationOrder/2)]
+    weights = gaussIntegrationWeights[int(integrationOrder/2)]
+    
+    for p in points:
+        x = 0.5*(b - a)*p + 0.5*(b + a)
+        value += 0.5*(b - a)*weights[cnt]*functionOfX(x);
+        cnt += 1
+
+    return value
+
+
+#integration points per integration order (1, 3, ...); for interval [-1,1]
+lobattoIntegrationPoints=[[-1.,1.],
+                          [-1., 0., 1.],
+                          [-1., -(1./5.)**0.5, (1./5.)**0.5, 1.]]
+
+#integration weights per integration order (1, 3, ...); for interval [-1,1]
+lobattoIntegrationWeights=[[ 1., 1.],
+                           [ 1./3., 4./3., 1./3.],
+                           [ 1./6., 5./6., 5./6., 1./6.]]
+
+#**function: compute numerical integration of functionOfX in interval [a,b] using Lobatto integration
+#**input: 
+#  functionOfX: scalar, vector or matrix-valued function with scalar argument (X or other variable)
+#  integrationOrder: odd number in \{1,3,5\}; currently maximum order is 5
+#  a: integration range start 
+#  b: integration range end 
+#**output: (scalar or vectorized) integral value
+def LobattoIntegrate(functionOfX, integrationOrder, a, b):
+    cnt = 0
+    value = 0*functionOfX(0) #initialize value with correct shape
+    if integrationOrder > 5:
+        raise ValueError("LobattoIntegrate: maximum implemented integration order is 5!")
+    if integrationOrder%2 != 1 or integrationOrder < 1:
+        raise ValueError("LobattoIntegrate: integration order must be odd (1,3,5,...) and >= 1")
+    
+    points = lobattoIntegrationPoints[int(integrationOrder/2)]
+    weights = lobattoIntegrationWeights[int(integrationOrder/2)]
+    
+    for p in points:
+        x = 0.5*(b - a)*p + 0.5*(b + a)
+        value += 0.5*(b - a)*weights[cnt]*functionOfX(x);
+        cnt += 1
+
+    return value
+
+
+
+
+
+
+
```

## exudyn/beams.py

 * *Ordering differences only*

```diff
@@ -1,793 +1,793 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Beam utility functions, e.g. for creation of sequences of straight or curved beams.
-#
-# Author:   Johannes Gerstmayr
-# Date:     2022-01-30 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-# Notes:    For a list of plot colors useful for matplotlib, see also utilities.PlotLineCode(...)
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-from math import sin, cos, pi, asin, atan2 #, sqrt, acos
-import copy 
-import numpy as np #for loading
-import exudyn #for sensor index
-import exudyn.itemInterface as eii
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate 2D ANCF cable elements along straight line given by two points; applies discretization (numberOfElements) and may apply gravity as well as nodal constraints
-#**input:
-#  mbs: the system where ANCF cables are added
-#  positionOfNode0: 3D position (list or np.array) for starting point of line
-#  positionOfNode1: 3D position (list or np.array) for end point of line
-#  numberOfElements: for discretization of line
-#  cableTemplate: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
-#  massProportionalLoad: a 3D list or np.array, containing the gravity vector or zero
-#  fixedConstraintsNode0: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope); use None in order to apply no constraints
-#  fixedConstraintsNode1: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope); use None in order to apply no constraints
-#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
-#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
-#**output: returns a list containing created items [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-#**notes: use GenerateStraightBeam instead
-#**example: 
-# see Examples/ANCF_cantilever_test.py
-def GenerateStraightLineANCFCable2D(mbs, positionOfNode0, positionOfNode1, numberOfElements, cableTemplate,
-                                massProportionalLoad=[0,0,0], 
-                                fixedConstraintsNode0=[0,0,0,0], fixedConstraintsNode1=[0,0,0,0],
-                                nodeNumber0=-1, nodeNumber1=-1):
-
-    return GenerateStraightBeam(mbs=mbs, positionOfNode0=positionOfNode0, positionOfNode1=positionOfNode1, 
-                                numberOfElements=numberOfElements, beamTemplate=cableTemplate,
-                                gravity=massProportionalLoad, 
-                                fixedConstraintsNode0=fixedConstraintsNode0, fixedConstraintsNode1=fixedConstraintsNode1,
-                                nodeNumber0=nodeNumber0, nodeNumber1=nodeNumber1)
-    
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate 3D ANCF cable elements along straight line given by two points; applies discretization (numberOfElements) and may apply gravity as well as nodal constraints
-#**input:
-#  mbs: the system where ANCF cables are added
-#  positionOfNode0: 3D position (list or np.array) for starting point of line
-#  positionOfNode1: 3D position (list or np.array) for end point of line
-#  numberOfElements: for discretization of line
-#  cableTemplate: a ObjectANCFCable object, containing the desired cable properties; cable length and node numbers are set automatically
-#  massProportionalLoad: a 3D list or np.array, containing the gravity vector or zero
-#  fixedConstraintsNode0: a list of binary values, indicating the coordinate contraints on the first node (position and slope); 4 coordinates for 2D and 6 coordinates for 3D node; use None in order to apply no constraints
-#  fixedConstraintsNode1: a list of binary values, indicating the coordinate contraints on the last node (position and slope); 4 coordinates for 2D and 6 coordinates for 3D node; use None in order to apply no constraints
-#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
-#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
-#**output: returns a list containing created items [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-#**example: 
-# see Examples/ANCF_cantilever_test.py
-def GenerateStraightLineANCFCable(mbs, positionOfNode0, positionOfNode1, numberOfElements, cableTemplate,
-                                massProportionalLoad=[0,0,0], fixedConstraintsNode0=[0,0,0, 0,0,0], fixedConstraintsNode1=[0,0,0, 0,0,0],
-                                nodeNumber0=-1, nodeNumber1=-1):
-    return GenerateStraightBeam(mbs=mbs, positionOfNode0=positionOfNode0, positionOfNode1=positionOfNode1, 
-                                numberOfElements=numberOfElements, beamTemplate=cableTemplate,
-                                gravity=massProportionalLoad, 
-                                fixedConstraintsNode0=fixedConstraintsNode0, fixedConstraintsNode1=fixedConstraintsNode1,
-                                nodeNumber0=nodeNumber0, nodeNumber1=nodeNumber1)
-    
-    
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generic function to create beam elements along straight line given by two points; applies discretization (numberOfElements) and may apply gravity as well as nodal constraints
-#**input:
-#  mbs: the system where beam elements are added
-#  positionOfNode0: 3D position (list or np.array) for starting point of line
-#  positionOfNode1: 3D position (list or np.array) for end point of line
-#  numberOfElements: for discretization of line
-#  beamTemplate: a Beam object (ObjectANCFCable2D, ObjectBeamGeometricallyExact2D, ObjectALEANCFCable2D, etc.), containing the desired beam type and properties; finite (beam) element length and node numbers are set automatically; for ALE element, the beamTemplate.nodeNumbers[2] must be set in the template and will not be overwritten
-#  gravity: a 3D list or np.array, containing the gravity vector or zero
-#  fixedConstraintsNode0: a list of binary values, indicating the coordinate contraints on the first node (position and slope); must agree with the number of coordinates in the node; use None to add no constraints
-#  fixedConstraintsNode1: a list of binary values, indicating the coordinate contraints on the last node (position and slope); must agree with the number of coordinates in the node; use None to add no constraints
-#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
-#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
-#**output: returns a list containing created items [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-#**example: 
-# import exudyn as exu
-# from exudyn.utilities import * #includes exudyn.beams
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# #example of flexible pendulum
-# beamTemplate = ObjectBeamGeometricallyExact2D(physicsMassPerLength=0.02,
-#                     physicsCrossSectionInertia=8e-9,
-#                     physicsBendingStiffness=8e-4,
-#                     physicsAxialStiffness=2000,
-#                     physicsShearStiffness=650,
-#                     visualization=VObjectBeamGeometricallyExact2D(drawHeight = 0.002))
-# 
-# #create straight beam with 10 elements, apply gravity and fix (x,y) position of node 0 (rotation left free)
-# beamInfo = GenerateStraightBeam(mbs, positionOfNode0=[0,0,0], positionOfNode1=[0.5,0,0], 
-#                                 numberOfElements=10, beamTemplate=beamTemplate,
-#                                 gravity=[0,-9.81,0], fixedConstraintsNode0=[1,1,0],)
-# #beamInfo contains nodes, beamObjects, loads, etc.
-# #Assemble and solve
-def GenerateStraightBeam(mbs, positionOfNode0, positionOfNode1, numberOfElements, beamTemplate,
-                         gravity=[0,0,0], fixedConstraintsNode0=None, fixedConstraintsNode1=None,
-                         nodeNumber0=-1, nodeNumber1=-1):
-    
-    beamNodeList=[]
-    beamNodePositionList=[positionOfNode0]
-    beamObjectList=[]
-    loadList=[]
-    beamCoordinateConstraintList=[]
-    
-    if len(positionOfNode0) != 3:
-        exudyn.Print('WARNING: GenerateStraightBeam: positionOfNode0 should be a 3D vector')
-    if len(positionOfNode1) != 3:
-        exudyn.Print('WARNING: GenerateStraightBeam: positionOfNode1 should be a 3D vector')
-
-    
-    if '__class__' in beamTemplate.__dir__():
-        className = str(beamTemplate.__class__.__name__)
-        is2D = False
-        isGeomExact = False
-        if className == 'ObjectANCFCable2D' or className == 'ObjectALEANCFCable2D':
-            NodeTemplate = eii.NodePoint2DSlope1
-            nDOFnode = 4
-            is2D = True
-        elif className == 'ObjectANCFCable':
-            NodeTemplate = eii.NodePointSlope1
-            nDOFnode = 6
-        elif className == 'ObjectBeamGeometricallyExact2D':
-            NodeTemplate = eii.NodeRigidBody2D
-            nDOFnode = 3
-            is2D = True
-            isGeomExact = True
-        else:
-            raise ValueError('GenerateStraightBeam: invalid beamTemplate "'+className+'" (maybe not implemented)')
-            
-        if is2D and (positionOfNode0[2] != 0 or positionOfNode1[2] != 0):
-            ValueError('GenerateStraightBeam: positionOfNode0 and positionOfNode1 must have zero z-components for 2D beam elements')
-        
-        if not(fixedConstraintsNode0 is None) and len(fixedConstraintsNode0) != nDOFnode:
-            ValueError('GenerateStraightBeam: fixedConstraintsNode0 incompatible has incompatible size')
-        if not(fixedConstraintsNode1 is None) and len(fixedConstraintsNode1) != nDOFnode:
-            ValueError('GenerateStraightBeam: fixedConstraintsNode1 incompatible has incompatible size')
-    else:
-        raise ValueError('GenerateStraightBeam: beamTemplate may is invalid')
-
-    #helper function to convert position into list for 2D or 3D
-    def ConvertVector(pos, is2D):
-        if is2D: return list(pos[0:2])
-        else: return list(pos)
-
-    # length of one element, calculated from first and last node position:
-    vDiff = np.array(positionOfNode1)-np.array(positionOfNode0)
-    lDiff = np.linalg.norm(vDiff)
-    if (numberOfElements <= 0 or numberOfElements != int(numberOfElements)): 
-        raise ValueError('GenerateStraightBeam: number of elements must be integer, non-zero and positive')
-
-    beamLength = lDiff/numberOfElements
-    
-    # slope of elements in reference position, calculated from first and last node position:
-    if (lDiff == 0.): 
-        raise ValueError('GenerateStraightBeam: distance between positionOfNode0 and positionOfNode1 is zero; terminating')
-    beamSlopeVec = (1./lDiff)*vDiff
-    
-    if isGeomExact:
-        if not is2D: 
-            raise ValueError('GenerateStraightBeam: only works for 2D geometrically exact beam for now!')
-        beamRotations = [atan2(beamSlopeVec[1], beamSlopeVec[0])]
-    else:
-        beamRotations = ConvertVector(beamSlopeVec, is2D)
-   
-    # add first ANCF node (straight reference configuration):
-    if (nodeNumber0!=-1):
-        beamNodeList+=[nodeNumber0]
-        nBeam0=nodeNumber0
-    else:
-        nBeam0 = mbs.AddNode(NodeTemplate(referenceCoordinates=ConvertVector(positionOfNode0, is2D) + beamRotations)) 
-        beamNodeList+=[nBeam0]
-    
-    beamTemplate.physicsLength = beamLength
-    
-    # add all other ANCF nodes (straight reference configuration) and attach Gravity marker to them:
-    for i in range(numberOfElements): 
-        
-        positionOfCurrentNode = (np.array(positionOfNode0)+beamLength*beamSlopeVec*(i+1)).tolist()
-        # positionOfCurrentNode=[positionOfNode0[0]+beamLength*beamSlopeVec[0]*(i+1),
-        #                        positionOfNode0[1]+beamLength*beamSlopeVec[1]*(i+1), 
-        #                        positionOfNode0[2]+beamLength*beamSlopeVec[2]*(i+1), 
-        #                        ]
-        #if is2D: positionOfCurrentNode[2] = 0
-        
-        beamNodePositionList+=[positionOfCurrentNode]
-        
-        if (i==numberOfElements-1 and nodeNumber1!=-1):
-            nBeamLast = nodeNumber1
-        else:
-            nBeamLast = mbs.AddNode(NodeTemplate(referenceCoordinates=ConvertVector(positionOfCurrentNode, is2D) + beamRotations)) 
-            # if is2D:
-            #     nBeamLast = mbs.AddNode(eii.NodePoint2DSlope1(referenceCoordinates=[positionOfCurrentNode[0],positionOfCurrentNode[1],beamSlopeVec[0],beamSlopeVec[1]]))
-            # else:
-            #     nBeamLast = mbs.AddNode(eii.NodePointSlope1(referenceCoordinates=list(positionOfCurrentNode) + list(beamSlopeVec) ))
-        
-        beamNodeList+=[nBeamLast]
-        
-        #do not override all node numbers, as nodeNumbers[2] may be ALE node
-        beamTemplate.nodeNumbers[0:2]=[beamNodeList[i],beamNodeList[i+1]]
-            
-        oBeam=mbs.AddObject(beamTemplate)
-        beamObjectList+=[oBeam]
-
-        if np.linalg.norm(gravity) != 0:
-            mBodyMassLast = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=oBeam))
-            lLoadLast=mbs.AddLoad(eii.Gravity(markerNumber=mBodyMassLast,loadVector=gravity))
-            loadList+=[lLoadLast]
-        
-    
-    if not(fixedConstraintsNode0 is None):
-        # ground "node" at first node:
-        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=positionOfNode0)) 
-        # add marker to ground "node": 
-        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
-
-        for j in range(len(fixedConstraintsNode0)):            
-            if fixedConstraintsNode0[j] != 0:
-                #fix ANCF coordinates of first node
-                mBeamCoordinateConstraint0 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nBeam0, coordinate=j)) #add marker
-                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mBeamCoordinateConstraint0])) #add constraint
-                beamCoordinateConstraintList+=[cBoundaryCondition]
-            
-    if not(fixedConstraintsNode1 is None):
-        # ground "node" at first node:
-        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=positionOfNode1)) 
-        # add marker to ground "node": 
-        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
-
-        for j in range(len(fixedConstraintsNode1)):            
-            if fixedConstraintsNode1[j] != 0:
-                # fix right end position coordinates, i.e., add markers and constraints:
-                mBeamCoordinateConstraint1 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nBeamLast, coordinate=j))#add marker
-                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mBeamCoordinateConstraint1])) #add constraint  
-                beamCoordinateConstraintList+=[cBoundaryCondition]
-            
-    
-    return [beamNodeList, beamObjectList, loadList, beamNodePositionList, beamCoordinateConstraintList]
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate cable elements along circular arc with given start point, radius, start angle (measured relative to $x$-axis, in positive rotation sense) and angle of arc
-#**input:
-#  mbs: the system where ANCF cables are added
-#  positionOfNode0: 3D position (list or np.array) for starting point of line
-#  radius: radius of arc
-#  startAngle: start angle of arc in radians  ($0 \ldots 2 \pi$), defines the direction of the slope vector, measured relative to $x$-axis, in positive rotation sense
-#  arcAngle: total angle of arc in radians ($0 \ldots 2 \pi$), measured in positive rotation sense (negative angle reverts curvature and center point of circle)
-#  numberOfElements: for discretization of arc
-#  cableTemplate: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
-#  massProportionalLoad: a 3D list or np.array, containing the gravity vector or zero
-#  fixedConstraintsNode0: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope)
-#  fixedConstraintsNode1: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope)
-#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
-#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
-#  setCurvedReferenceConfiguration: if True, the curvature +/-(1/radius) is set as a reference configuration (sign depends on arcAngle); if False, the reference configuration is straight
-#  verboseMode: if True, prints out information on created nodes
-#**output: returns a list [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-def GenerateCircularArcANCFCable2D(mbs, positionOfNode0, radius, startAngle, arcAngle, 
-                                   numberOfElements, cableTemplate,
-                                   massProportionalLoad=[0,0,0], fixedConstraintsNode0=[0,0,0,0], fixedConstraintsNode1=[0,0,0,0],
-                                   nodeNumber0=-1, nodeNumber1=-1, setCurvedReferenceConfiguration=True, verboseMode=False):
-    
-
-    cableNodeList=[]
-    cableNodePositionList=[positionOfNode0]
-    cableObjectList=[]
-    loadList=[]
-    cableCoordinateConstraintList=[]
-    if len(positionOfNode0) != 3:
-        exudyn.Print('WARNING: GenerateCircularArcANCFCable2D: positionOfNode0 should be a 3D vector')
-
-    if (numberOfElements <= 0 or numberOfElements != int(numberOfElements)): 
-        raise ValueError('GenerateCircularArcANCFCable2D: number of elements must be integer, non-zero and positive')
-
-    if (radius <= 0.): 
-        raise ValueError('GenerateCircularArcANCFCable2D: radius must be > 0')
-
-    if (arcAngle == 0.): 
-        raise ValueError('GenerateCircularArcANCFCable2D: arcAngle must be non-zero')
-
-    #length of one element:
-    cableLength = radius*abs(arcAngle)/numberOfElements
-    # exudyn.Print('cableLength=',cableLength)
-    # exudyn.Print('p0=', positionOfNode0)
-    
-    #reverse normal and slope, means changing the curvature and center point of arc
-    arcSign = 1.
-    if arcAngle < 0.:
-        arcSign = -1.
-
-    # slope vector of first node
-    cableSlopeVec = np.array([ np.cos(startAngle),np.sin(startAngle),0.])
-    cableNormal =   np.array([-np.sin(startAngle),np.cos(startAngle),0.])
-    
-    #center point of circle for creation of arc:
-    pCenter = arcSign*radius*cableNormal + np.array(positionOfNode0)
-    # exudyn.Print('pCenter=',pCenter)
-
-    # add first ANCF node (straight reference configuration):
-    if (nodeNumber0!=-1):
-        cableNodeList+=[nodeNumber0]
-    else:
-        nCable0 = mbs.AddNode(eii.Point2DS1(referenceCoordinates=[positionOfNode0[0],positionOfNode0[1],cableSlopeVec[0],cableSlopeVec[1]])) 
-        cableNodeList+=[nCable0]
-        if verboseMode:
-            exudyn.Print('  node 0: pos=', positionOfNode0[0],',',positionOfNode0[1],', slope=',cableSlopeVec[0],',',cableSlopeVec[1])
-    
-    cableTemplate.physicsLength = cableLength
-
-    oldReferenceCurvature = cableTemplate.physicsReferenceCurvature 
-    if setCurvedReferenceConfiguration:
-        cableTemplate.physicsReferenceCurvature = arcSign/radius #set reference curvature, such that beam is pre-curved
-    
-    # add all other ANCF nodes (straight reference configuration) and attach Gravity marker to them:
-    for i in range(numberOfElements): 
-        phi = (i+1)*arcAngle/float(numberOfElements)
-        #new node:
-        pArc = pCenter + arcSign*radius*np.sin(phi)*cableSlopeVec - arcSign*radius*np.cos(phi)*cableNormal
-        #new slope:
-        vArc = np.cos(phi)*cableSlopeVec + np.sin(phi)*cableNormal
-        # exudyn.Print('pArc'+str(i)+'=',pArc)
-        # exudyn.Print('vArc'+str(i)+'=',vArc)
-        
-        positionOfCurrentNode=[pArc[0],pArc[1],0.]
-        cableNodePositionList+=[positionOfCurrentNode]
-
-        if verboseMode:
-            exudyn.Print('  node '+str(i+1)+': pos=', positionOfCurrentNode[0],',',positionOfCurrentNode[1],', slope=',vArc[0],',',vArc[1])
-        
-        if (i==numberOfElements-1 and nodeNumber1!=-1):
-            nCableLast = nodeNumber1
-        else:
-            nCableLast = mbs.AddNode(eii.Point2DS1(referenceCoordinates=[positionOfCurrentNode[0],positionOfCurrentNode[1],
-                                                                     vArc[0],vArc[1]]))
-
-        # exudyn.Print('cableNodeList=',cableNodeList)
-        
-        cableNodeList+=[nCableLast]
-        
-        cableTemplate.nodeNumbers[0:2]=[cableNodeList[i],cableNodeList[i+1]]
-            
-        oCable=mbs.AddObject(cableTemplate)
-        cableObjectList+=[oCable]
-
-        if np.linalg.norm(massProportionalLoad) != 0:
-            mBodyMassLast = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=oCable))
-            lLoadLast=mbs.AddLoad(eii.Gravity(markerNumber=mBodyMassLast,loadVector=massProportionalLoad))
-            loadList+=[lLoadLast]
-        
-    
-    if (np.linalg.norm(list(fixedConstraintsNode0)+list(fixedConstraintsNode1)) ) != 0:
-        # ground "node" at 0,0,0:
-        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=[0,0,0])) 
-        # add marker to ground "node": 
-        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
-    
-
-        for j in range(4):            
-            if fixedConstraintsNode0[j] != 0:            
-                #fix ANCF coordinates of first node
-                mCableCoordinateConstraint0 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nCable0, coordinate=j)) #add marker
-                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint0])) #add constraint
-                cableCoordinateConstraintList+=[cBoundaryCondition]
-            
-        for j in range(4):            
-            if fixedConstraintsNode1[j] != 0:                 
-                # fix right end position coordinates, i.e., add markers and constraints:
-                mCableCoordinateConstraint1 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nCableLast, coordinate=j))#add marker
-                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint1])) #add constraint  
-                cableCoordinateConstraintList+=[cBoundaryCondition]
-
-     
-    if setCurvedReferenceConfiguration:
-        cableTemplate.physicsReferenceCurvature = oldReferenceCurvature        
-    
-    return [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-
-
-
-
-
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: CreateReevingCurve for creating the geometry of a reeving system based on circles with radius and left/right side of passing the circles; left/right is seen in the direction passing from one to the next circle
-#**input:
-#  circleList: list containing center position, radius and 'L' (left) or 'R' (right) passing of circle
-#  radialOffset: additional offset added to circles to account for half height of rope or beam
-#  closedCurve: if True, the system adds circleList[0] and  circleList[1] at end of list and sets removeLastLine=True and removeFirstLine=False, in order to generate a closed curve according to given circles; furthermore, the number of nodes becomes equal to the number of elements in this case
-#  drawingLinesPerCircle: number of lines in lineData per one revolution
-#  numberOfANCFnodes: if not -1, function also generates nodes with equidistant distribution along curve!
-#  graphicsElementsPerCircle: number of drawing lines generated in graphicsDataLines per circle revolution (larger generates better approximation of circles)
-#  graphicsNodeSize: if not 0, addes graphics representation of nodes generated; for check if mesh is correct
-#  removeFirstLine: removes first line generated, which may be unwanted
-#  removeLastLine: removes last line generated, which may be unwanted
-#  colorCircles: RGBA color for circles
-#  colorLines: RGBA color for lines
-#**output: return a dictionary with {'ancfPointsSlopes':ancfPointsSlopes, 'elementLengths':elementLengths, 'elementCurvatures':elementCurvatures, 'totalLength':totalLength, 'circleData':circle2D, 'graphicsDataLines':graphicsDataLines, 'graphicsDataCircles':graphicsDataCircles }; 'ancfPointsSlopes' denotes 4-dimensional vector with (x/y) position and (x/y) slope coordinates in a row; 'elementLengths' is the list of curved lengths for elements between nodes (size is 1 smaller than number of nodes), 'elementCurvatures' is the list of scalar curvatures between nodes (according to list of elementLengths), 'totalLength' is the total length of the reeving line, 'circleData' represents the lines and arcs calculated for the reeving system, 'graphicsDataLines' is the graphicsData for the lines and 'graphicsDataCircles' represents the graphicsData for the circles
-#**example:
-# #list with circle center, radius and side at which rope runs
-# circleList = [[[0,0],0.2,'L'],
-#               [[0,1],0.2,'L'],
-#               [[0.8,0.8],0.4,'L'],
-#               [[1,0],0.2,'L'],
-#               [[0,0],0.2,'L'],
-#               [[0,1],0.2,'L'],
-#               ]
-# [] = CreateReevingCurve(circleList, 
-#                         removeLastLine=True, #allows closed curve
-#                         numberOfANCFnodes=50)
-def CreateReevingCurve(circleList, drawingLinesPerCircle = 64, numberOfANCFnodes=-1, 
-                       removeLastLine=False, removeFirstLine=False,
-                       radialOffset = 0., closedCurve=False,
-                       graphicsElementsPerCircle=64, graphicsNodeSize=0,
-                       colorCircles=[0.,0.5,1.,1.], colorLines=[1.,0.5,0.,1.]):
-
-    nodesANCFcreated = numberOfANCFnodes
-    minP=np.array([ 1e30, 1e30, 1e30])
-    maxP=np.array([-1e30,-1e30,-1e30])
-    
-    circleListExt = copy.deepcopy(circleList)
-    
-    if closedCurve:
-        circleListExt += [circleList[0]]
-        circleListExt += [circleList[1]]
-        removeLastLine=True 
-        removeFirstLine=False
-        if nodesANCFcreated!=-1:
-            nodesANCFcreated += 1
-    
-    graphicsDataCircles = [] #optional graphics for circles
-    for circle in circleListExt:
-        #exudyn.Print(circle)
-        pos = [circle[0][0],circle[0][1],0]
-        r = circle[1]+radialOffset
-        if circle[1] <= 0.:
-            raise ValueError('CreateReevingCurve: radius in circleList may not be zero or negative!')
-
-        graphicsDataCircles += [{'type':'Circle', 'color':colorCircles,
-                  'position':pos,'radius':r}]
-        minP = np.minimum(minP, np.array(pos)-[r,r,0])
-        maxP = np.maximum(maxP, np.array(pos)+[r,r,0])
-    
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #create list of lines and arcs:
-    
-    #list of dictionaries for lines and arcs; everything in 2D
-    #lines: {'type':'LINE', 'point0':np.array([0,0]), 'point1':np.array([0,0])}
-    #circularArcs: {'type':'ARC', 'point0':np.array([0,0]), 'center':np.array([0,0]), 'radius':1, 'startAngle':angle0, 'arcAngle':angle1}
-    curve2D = []
-
-    #start points from circle 0:
-    circle = circleListExt[0]
-    pos0 = np.array([circle[0][0],circle[0][1]])
-    r0 = circle[1]+radialOffset
-    side0=circle[2]
-    p1Last = [] #point from last arc; empty if no arc to continue
-    # pos0 = np.array([-1,-0.8])
-    # r0 = 0.2
-    # side0='L'
-    # p1Last = [] #point from last arc; empty if no arc to continue
-
-
-    totalLength = 0.
-    
-    for i, circle in enumerate(circleListExt):
-        #exudyn.Print(circle)
-        if i==0: #first circle is used already
-            continue 
-    
-        pos1 = np.array([circle[0][0],circle[0][1]])
-        r1 = circle[1]+radialOffset
-        side1 = circle[2]
-        if r0 < 0. or r1 < 0.: continue
-    
-        vv = pos1-pos0
-        L = np.linalg.norm(vv)
-        if L==0: 
-            raise ValueError('CreateReevingCurve: distance of circles is zero')
-        vv0 = (1./L)*vv
-        nv0 = np.array([-vv0[1],vv0[0]])
-    
-        sign0 = 1
-        sign1 = 1
-        if side0 == 'R':
-            sign0 = -1
-        if side1 == 'R':
-            sign1 = -1
-        alpha = asin((sign1*r1 - sign0*r0)/L)
-    
-        p0 = pos0+sign0*nv0*cos(alpha)*r0+vv0*sin(-sign0*alpha)*r0
-        p1 = pos1+sign1*nv0*cos(alpha)*r1+vv0*sin(-sign1*alpha)*r1
-        
-        # exudyn.Print('circle',i,', alpha=',alpha,', p0=',p0,', p1=',p1)
-        # exudyn.Print('  vv0=',vv0,', nv0=', nv0, ', sign0=',sign0, ', sign1=',sign1)
-        # exudyn.Print('  r0=',r0,', r1=', r1,', pos0=', pos0,', pos1=', pos1)
-    
-    
-        #add arc from end of last line
-        if list(p1Last) != []:
-            vr0 = p1Last-pos0
-            angle0=atan2(vr0[1],vr0[0])-sign0*0.5*pi
-            vr1 = p0-pos0
-            angle1=atan2(vr1[1],vr1[0])-sign0*0.5*pi
-            arcAngle = (angle1-angle0)
-            if arcAngle < 0 and side0=='R':
-                arcAngle+=2.*pi
-            if arcAngle > 0 and side0=='L':
-                arcAngle-=2.*pi
-            # exudyn.Print('aa=',arcAngle)
-            curve2D+=[{'type':'ARC', 'point0':p1Last, 
-                       'radius':r0, 'startAngle':angle0, 'endAngle':angle1, 'arcAngle':arcAngle}]
-            totalLength += abs(r0*arcAngle)
-    
-        #only add this line, if not excluded!
-        if not ((removeFirstLine and i==1) or
-                (removeLastLine and i==len(circleListExt)-1)):
-            segmentLength = np.linalg.norm(p1-p0)
-            if segmentLength == 0.:
-                print('WARNING: CreateReevingCurve: curve seems to be degenerated, check location of circles')
-            curve2D += [{'type':'LINE', 'point0':p0, 'point1':p1}]
-            totalLength += segmentLength
-    
-        #for next circle:
-        p1Last = copy.deepcopy(p1)
-        pos0 = copy.deepcopy(pos1)
-        r0 = copy.deepcopy(r1)
-        side0 = copy.deepcopy(side1)
-    
-    #create single line:
-    lineData=[]
-    
-    if nodesANCFcreated > 0 and nodesANCFcreated < 2:
-        raise ValueError('CreateReevingCurve: numberOfANCFnodes must be either -1 [deactivated] or > 2 !')
-
-    numberOfElements = nodesANCFcreated-1
-    lElem = totalLength/numberOfElements
-    ancfPointsSlopes = [] #list of 4D vectors with nodal points+slopes
-    elementLengths = [] #curved length for elements stored
-    elementCurvatures = [] #curvature of element i, between nodes i and i+1
-    
-    arcCoord = 0 #remember how far already gone!
-    nextArcCoord = 0 #this is the acrCoord with the next node
-    tol = 1e-10 #make sure to add last node, which can have some round-off errors
-    
-    #now create nodes for ANCF elements:
-    
-    for item in curve2D:
-        if item['type']=='LINE':
-            p0 = item['point0']
-            p1 = item['point1']
-            lineData+=list(p0)+[0]
-            lineData+=list(p1)+[0]
-            L = np.linalg.norm(p1-p0)
-            startCoord = arcCoord  #this is the arcCoordinate of the start of this line/curve
-            endCoord = arcCoord+L  #this is the arcCoordinate of the end of this line/curve
-            while nextArcCoord <= endCoord*(1.+tol):
-                slope = (1/L)*(p1-p0)
-                p = p0 + (nextArcCoord-startCoord)*slope
-                ancfPointsSlopes+=[list(p)+list(slope)]
-                if nextArcCoord != 0:
-                    elementLengths += [lElem]
-                    elementCurvatures += [0.] #represents straight line!
-                nextArcCoord += lElem
-            arcCoord = endCoord
-        elif item['type']=='ARC':
-            startAngle = item['startAngle']
-            arcAngle = item['arcAngle']
-            p0 = item['point0']
-            r = item['radius']
-    
-            arcSign = 1.
-            if arcAngle < 0.:
-                arcSign = -1.
-    
-            # slope vector of first node
-            vv0 = np.array([ np.cos(startAngle),np.sin(startAngle)])
-            nv0=   np.array([-np.sin(startAngle),np.cos(startAngle)])
-    
-            #center point of circle for creation of arc:
-            pCenter = arcSign*r*nv0 + p0
-
-            nARC = int(abs(arcAngle)*graphicsElementsPerCircle/(2*pi))+1
-        
-            for i in range(nARC):
-                phi = (i+1)*arcAngle/float(nARC)
-                #new node:
-                pArc = pCenter + arcSign*r*np.sin(phi)*vv0 - arcSign*r*np.cos(phi)*nv0
-                lineData+=list(pArc)+[0]
-            
-            L = abs(r*arcAngle)
-            startCoord = arcCoord  #this is the arcCoordinate of the start of this line/curve
-            endCoord = arcCoord+L  #this is the arcCoordinate of the end of this line/curve
-            while nextArcCoord <= endCoord*(1.+tol):
-                phi = (nextArcCoord-startCoord)/L*arcAngle
-    
-                pArc = pCenter + arcSign*r*np.sin(phi)*vv0 - arcSign*r*np.cos(phi)*nv0
-                vArc = np.cos(phi)*vv0 + np.sin(phi)*nv0
-    
-                ancfPointsSlopes+=[list(pArc)+list(vArc)]
-                if nextArcCoord != 0:
-                    elementLengths += [lElem]
-                    curvature = arcSign*1./r #correct sign, whether it is left or right
-                    #print('curvature=',curvature, ', sign=',arcSign)
-                    elementCurvatures += [curvature] #r may not be zero!
-                nextArcCoord += lElem
-            
-            arcCoord = endCoord
-    
-    exudyn.Print('Reeving system total length=', totalLength)
-    # exudyn.Print('ANCF nodes=', ancfPointsSlopes)
-    
-    graphicsDataLines = [{'type':'Line', 'color':colorLines, 
-                  'data':lineData} ]
-
-    if graphicsNodeSize!= 0:
-        for ps in ancfPointsSlopes:
-            graphicsDataLines += [{'type':'Circle', 'color':colorLines,
-                  'position':[ps[0],ps[1],0],'radius':graphicsNodeSize}]
-
-    return {'ancfPointsSlopes':ancfPointsSlopes, 'elementLengths':elementLengths, 
-            'elementCurvatures':elementCurvatures, 'totalLength':totalLength, 'circleData':curve2D, 
-            'lineData':lineData, 'graphicsDataLines':graphicsDataLines, 'graphicsDataCircles':graphicsDataCircles }
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Create nodes and ANCFCable2D elements in MainSystem mbs from a given set of nodes, elements lengths and a template for the cable, based on output of function CreateReevingCurve(...); function works similar to GenerateStraightLineANCFCable2D, but for arbitrary geometry (curved elements); optionally add loads and constraints
-#**input:
-#  mbs: the system where ANCF elements and nodes are added
-#  ancfPointsSlopes: list of position and slopes for nodes, provided as 4D numpy arrays, as returned by CreateReevingCurve(...)
-#  elementLengths: list of element lengths per element, as returned by CreateReevingCurve(...)
-#  cableTemplate: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
-#  massProportionalLoad: a 3D list or np.array, containing the gravity vector to be applied to all elements or zero
-#  fixedConstraintsNode0: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope)
-#  fixedConstraintsNode1: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope)
-#  firstNodeIsLastNode: if True, then the last node is using the node number of the first node and the curve is closed; otherwise, the first and last nodes are different, and the curve is open
-#  elementCurvatures: optional list of pre-curvatures of elements, used to override the cableTemplate entry 'physicsReferenceCurvature'; use 0. for straight lines!
-#  graphicsSizeConstraints: if set other than -1, it will be used as the size for drawing applied coordinate constraints
-#**output: returns a list [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-def PointsAndSlopes2ANCFCable2D(mbs, ancfPointsSlopes, elementLengths, cableTemplate, massProportionalLoad=[0,0,0], 
-                                fixedConstraintsNode0=[0,0,0,0], fixedConstraintsNode1=[0,0,0,0], firstNodeIsLastNode=True,
-                                elementCurvatures=[], graphicsSizeConstraints=-1):
-
-    cableNodeList=[]
-    cableNodePositionList=[]
-    cableObjectList=[]
-    loadList=[]
-    cableCoordinateConstraintList=[]
-    
-    # add first ANCF node (straight reference configuration):
-    nodeNumber0 = mbs.AddNode(eii.Point2DS1(referenceCoordinates=ancfPointsSlopes[0])) 
-    cableNodeList+=[nodeNumber0]
-    cableNodePositionList+=[ancfPointsSlopes[0][0],ancfPointsSlopes[0][1],0] #3D
-    numberOfElements = len(ancfPointsSlopes)-1
-    
-    # add all other ANCF nodes (straight reference configuration) and attach Gravity marker to them:
-    for i in range(numberOfElements): 
-        # pointSlope0 = ancfPointsSlopes[i]
-        # pointSlope1 = ancfPointsSlopes[i+1]
-
-        cableTemplate.physicsLength = elementLengths[i]
-        if elementCurvatures != []:
-            cableTemplate.physicsReferenceCurvature = elementCurvatures[i]
-        
-        if (i==numberOfElements-1 and firstNodeIsLastNode):
-            nodeNumberLast = nodeNumber0
-        else:
-            nodeNumberLast = mbs.AddNode(eii.Point2DS1(referenceCoordinates=ancfPointsSlopes[i+1]))
-        cableNodeList+=[nodeNumberLast]
-
-        cableNodePositionList+=[ancfPointsSlopes[i+1][0],ancfPointsSlopes[i+1][1],0] #3D
-       
-        
-        cableTemplate.nodeNumbers[0:2]=[cableNodeList[i],cableNodeList[i+1]]
-            
-        oCable=mbs.AddObject(cableTemplate)
-        cableObjectList+=[oCable]
-
-        if np.linalg.norm(massProportionalLoad) != 0:
-            mBodyMassLast = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=oCable))
-            lLoadLast=mbs.AddLoad(eii.Gravity(markerNumber=mBodyMassLast,loadVector=massProportionalLoad))
-            loadList+=[lLoadLast]
-        
-    
-    if (np.linalg.norm(list(fixedConstraintsNode0)+list(fixedConstraintsNode1)) ) != 0:
-        # ground "node" at 0,0,0:
-        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=[0,0,0])) 
-        # add marker to ground "node": 
-        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
-    
-        if (firstNodeIsLastNode and
-            np.linalg.norm(fixedConstraintsNode1)  != 0):
-            raise ValueError('PointsAndSlopes2ANCFCable2D: fixedConstraintsNode1 must be [0,0,0,0] in case t firstNodeIsLastNode==True')
-
-        for j in range(4):            
-            if fixedConstraintsNode0[j] != 0:            
-                #fix ANCF coordinates of first node
-                mCableCoordinateConstraint0 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nodeNumber0, coordinate=j)) #add marker
-                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint0],
-                                                                      visualization=eii.VCoordinateConstraint(drawSize=graphicsSizeConstraints))) #add constraint
-                cableCoordinateConstraintList+=[cBoundaryCondition]
-            
-        for j in range(4):            
-            if fixedConstraintsNode1[j] != 0:                 
-                # fix right end position coordinates, i.e., add markers and constraints:
-                mCableCoordinateConstraint1 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nodeNumberLast, 
-                                                                                 coordinate=j))#add marker
-                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint1],
-                                                                      visualization=eii.VCoordinateConstraint(drawSize=graphicsSizeConstraints))) #add constraint
-                cableCoordinateConstraintList+=[cBoundaryCondition]
-            
-    
-    return [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
-
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#sliding joint utilities
-
-#**function: generate a sliding joint from a list of cables, marker to a sliding body, etc.
-#**output: returns the sliding joint object
-def GenerateSlidingJoint(mbs,cableObjectList,markerBodyPositionOfSlidingBody,localMarkerIndexOfStartCable=0,slidingCoordinateStartPosition=0):
-
-    cableMarkerList = []#list of Cable2DCoordinates markers
-    offsetList = []     #list of offsets counted from first cable element; needed in sliding joint
-    offset = 0          #first cable element has offset 0
-    
-    for item in cableObjectList: #create markers for cable elements
-        m = mbs.AddMarker(eii.MarkerBodyCable2DCoordinates(bodyNumber = item))
-        cableMarkerList += [m]
-        offsetList += [offset]  
-        offset += mbs.GetObjectParameter(item,'physicsLength')
-    
-    nodeDataSlidingJoint = mbs.AddNode(eii.NodeGenericData(initialCoordinates=[localMarkerIndexOfStartCable,slidingCoordinateStartPosition],numberOfDataCoordinates=2)) #initial index in cable list
-    
-    oSlidingJoint = mbs.AddObject(eii.ObjectJointSliding2D(markerNumbers=[markerBodyPositionOfSlidingBody,cableMarkerList[localMarkerIndexOfStartCable]], 
-                                                      slidingMarkerNumbers=cableMarkerList, 
-                                                      slidingMarkerOffsets=offsetList, 
-                                                      nodeNumber=nodeDataSlidingJoint))
-
-    return [oSlidingJoint]
-
-
-
-
-
-#**function: generate an ALE sliding joint from a list of cables, marker to a sliding body, etc.
-#**output: returns the sliding joint object
-def GenerateAleSlidingJoint(mbs,cableObjectList,markerBodyPositionOfSlidingBody,AleNode,
-                            localMarkerIndexOfStartCable=0,AleSlidingOffset=0,
-                            activeConnector=True, penaltyStiffness=0):
-
-    cableMarkerList = []#list of Cable2DCoordinates markers
-    offsetList = []     #list of offsets counted from first cable element; needed in sliding joint
-    offset = 0          #first cable element has offset 0
-    usePenalty = (penaltyStiffness!=0) #penaltyStiffness=0 ==> no penalty formulation!
-    
-    for item in cableObjectList: #create markers for cable elements
-        m = mbs.AddMarker(eii.MarkerBodyCable2DCoordinates(bodyNumber = item))
-        cableMarkerList += [m]
-        offsetList += [offset]  
-        offset += mbs.GetObjectParameter(item,'physicsLength')
-    
-    nodeDataAleSlidingJoint = mbs.AddNode(eii.NodeGenericData(initialCoordinates=[localMarkerIndexOfStartCable],numberOfDataCoordinates=1)) #initial index in cable list   
-    oAleSlidingJoint = mbs.AddObject(eii.ObjectJointALEMoving2D(markerNumbers=[markerBodyPositionOfSlidingBody,cableMarkerList[localMarkerIndexOfStartCable]], 
-                                                      slidingMarkerNumbers=cableMarkerList, slidingMarkerOffsets=offsetList,
-                                                      nodeNumbers=[nodeDataAleSlidingJoint, AleNode], slidingOffset=AleSlidingOffset,activeConnector=activeConnector,
-                                                      usePenaltyFormulation = usePenalty, penaltyStiffness=penaltyStiffness))
-
-
-    return [oAleSlidingJoint]
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Beam utility functions, e.g. for creation of sequences of straight or curved beams.
+#
+# Author:   Johannes Gerstmayr
+# Date:     2022-01-30 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+# Notes:    For a list of plot colors useful for matplotlib, see also utilities.PlotLineCode(...)
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+from math import sin, cos, pi, asin, atan2 #, sqrt, acos
+import copy 
+import numpy as np #for loading
+import exudyn #for sensor index
+import exudyn.itemInterface as eii
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate 2D ANCF cable elements along straight line given by two points; applies discretization (numberOfElements) and may apply gravity as well as nodal constraints
+#**input:
+#  mbs: the system where ANCF cables are added
+#  positionOfNode0: 3D position (list or np.array) for starting point of line
+#  positionOfNode1: 3D position (list or np.array) for end point of line
+#  numberOfElements: for discretization of line
+#  cableTemplate: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
+#  massProportionalLoad: a 3D list or np.array, containing the gravity vector or zero
+#  fixedConstraintsNode0: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope); use None in order to apply no constraints
+#  fixedConstraintsNode1: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope); use None in order to apply no constraints
+#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
+#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
+#**output: returns a list containing created items [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+#**notes: use GenerateStraightBeam instead
+#**example: 
+# see Examples/ANCF_cantilever_test.py
+def GenerateStraightLineANCFCable2D(mbs, positionOfNode0, positionOfNode1, numberOfElements, cableTemplate,
+                                massProportionalLoad=[0,0,0], 
+                                fixedConstraintsNode0=[0,0,0,0], fixedConstraintsNode1=[0,0,0,0],
+                                nodeNumber0=-1, nodeNumber1=-1):
+
+    return GenerateStraightBeam(mbs=mbs, positionOfNode0=positionOfNode0, positionOfNode1=positionOfNode1, 
+                                numberOfElements=numberOfElements, beamTemplate=cableTemplate,
+                                gravity=massProportionalLoad, 
+                                fixedConstraintsNode0=fixedConstraintsNode0, fixedConstraintsNode1=fixedConstraintsNode1,
+                                nodeNumber0=nodeNumber0, nodeNumber1=nodeNumber1)
+    
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate 3D ANCF cable elements along straight line given by two points; applies discretization (numberOfElements) and may apply gravity as well as nodal constraints
+#**input:
+#  mbs: the system where ANCF cables are added
+#  positionOfNode0: 3D position (list or np.array) for starting point of line
+#  positionOfNode1: 3D position (list or np.array) for end point of line
+#  numberOfElements: for discretization of line
+#  cableTemplate: a ObjectANCFCable object, containing the desired cable properties; cable length and node numbers are set automatically
+#  massProportionalLoad: a 3D list or np.array, containing the gravity vector or zero
+#  fixedConstraintsNode0: a list of binary values, indicating the coordinate contraints on the first node (position and slope); 4 coordinates for 2D and 6 coordinates for 3D node; use None in order to apply no constraints
+#  fixedConstraintsNode1: a list of binary values, indicating the coordinate contraints on the last node (position and slope); 4 coordinates for 2D and 6 coordinates for 3D node; use None in order to apply no constraints
+#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
+#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
+#**output: returns a list containing created items [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+#**example: 
+# see Examples/ANCF_cantilever_test.py
+def GenerateStraightLineANCFCable(mbs, positionOfNode0, positionOfNode1, numberOfElements, cableTemplate,
+                                massProportionalLoad=[0,0,0], fixedConstraintsNode0=[0,0,0, 0,0,0], fixedConstraintsNode1=[0,0,0, 0,0,0],
+                                nodeNumber0=-1, nodeNumber1=-1):
+    return GenerateStraightBeam(mbs=mbs, positionOfNode0=positionOfNode0, positionOfNode1=positionOfNode1, 
+                                numberOfElements=numberOfElements, beamTemplate=cableTemplate,
+                                gravity=massProportionalLoad, 
+                                fixedConstraintsNode0=fixedConstraintsNode0, fixedConstraintsNode1=fixedConstraintsNode1,
+                                nodeNumber0=nodeNumber0, nodeNumber1=nodeNumber1)
+    
+    
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generic function to create beam elements along straight line given by two points; applies discretization (numberOfElements) and may apply gravity as well as nodal constraints
+#**input:
+#  mbs: the system where beam elements are added
+#  positionOfNode0: 3D position (list or np.array) for starting point of line
+#  positionOfNode1: 3D position (list or np.array) for end point of line
+#  numberOfElements: for discretization of line
+#  beamTemplate: a Beam object (ObjectANCFCable2D, ObjectBeamGeometricallyExact2D, ObjectALEANCFCable2D, etc.), containing the desired beam type and properties; finite (beam) element length and node numbers are set automatically; for ALE element, the beamTemplate.nodeNumbers[2] must be set in the template and will not be overwritten
+#  gravity: a 3D list or np.array, containing the gravity vector or zero
+#  fixedConstraintsNode0: a list of binary values, indicating the coordinate contraints on the first node (position and slope); must agree with the number of coordinates in the node; use None to add no constraints
+#  fixedConstraintsNode1: a list of binary values, indicating the coordinate contraints on the last node (position and slope); must agree with the number of coordinates in the node; use None to add no constraints
+#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
+#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
+#**output: returns a list containing created items [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+#**example: 
+# import exudyn as exu
+# from exudyn.utilities import * #includes exudyn.beams
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# #example of flexible pendulum
+# beamTemplate = ObjectBeamGeometricallyExact2D(physicsMassPerLength=0.02,
+#                     physicsCrossSectionInertia=8e-9,
+#                     physicsBendingStiffness=8e-4,
+#                     physicsAxialStiffness=2000,
+#                     physicsShearStiffness=650,
+#                     visualization=VObjectBeamGeometricallyExact2D(drawHeight = 0.002))
+# 
+# #create straight beam with 10 elements, apply gravity and fix (x,y) position of node 0 (rotation left free)
+# beamInfo = GenerateStraightBeam(mbs, positionOfNode0=[0,0,0], positionOfNode1=[0.5,0,0], 
+#                                 numberOfElements=10, beamTemplate=beamTemplate,
+#                                 gravity=[0,-9.81,0], fixedConstraintsNode0=[1,1,0],)
+# #beamInfo contains nodes, beamObjects, loads, etc.
+# #Assemble and solve
+def GenerateStraightBeam(mbs, positionOfNode0, positionOfNode1, numberOfElements, beamTemplate,
+                         gravity=[0,0,0], fixedConstraintsNode0=None, fixedConstraintsNode1=None,
+                         nodeNumber0=-1, nodeNumber1=-1):
+    
+    beamNodeList=[]
+    beamNodePositionList=[positionOfNode0]
+    beamObjectList=[]
+    loadList=[]
+    beamCoordinateConstraintList=[]
+    
+    if len(positionOfNode0) != 3:
+        exudyn.Print('WARNING: GenerateStraightBeam: positionOfNode0 should be a 3D vector')
+    if len(positionOfNode1) != 3:
+        exudyn.Print('WARNING: GenerateStraightBeam: positionOfNode1 should be a 3D vector')
+
+    
+    if '__class__' in beamTemplate.__dir__():
+        className = str(beamTemplate.__class__.__name__)
+        is2D = False
+        isGeomExact = False
+        if className == 'ObjectANCFCable2D' or className == 'ObjectALEANCFCable2D':
+            NodeTemplate = eii.NodePoint2DSlope1
+            nDOFnode = 4
+            is2D = True
+        elif className == 'ObjectANCFCable':
+            NodeTemplate = eii.NodePointSlope1
+            nDOFnode = 6
+        elif className == 'ObjectBeamGeometricallyExact2D':
+            NodeTemplate = eii.NodeRigidBody2D
+            nDOFnode = 3
+            is2D = True
+            isGeomExact = True
+        else:
+            raise ValueError('GenerateStraightBeam: invalid beamTemplate "'+className+'" (maybe not implemented)')
+            
+        if is2D and (positionOfNode0[2] != 0 or positionOfNode1[2] != 0):
+            ValueError('GenerateStraightBeam: positionOfNode0 and positionOfNode1 must have zero z-components for 2D beam elements')
+        
+        if not(fixedConstraintsNode0 is None) and len(fixedConstraintsNode0) != nDOFnode:
+            ValueError('GenerateStraightBeam: fixedConstraintsNode0 incompatible has incompatible size')
+        if not(fixedConstraintsNode1 is None) and len(fixedConstraintsNode1) != nDOFnode:
+            ValueError('GenerateStraightBeam: fixedConstraintsNode1 incompatible has incompatible size')
+    else:
+        raise ValueError('GenerateStraightBeam: beamTemplate may is invalid')
+
+    #helper function to convert position into list for 2D or 3D
+    def ConvertVector(pos, is2D):
+        if is2D: return list(pos[0:2])
+        else: return list(pos)
+
+    # length of one element, calculated from first and last node position:
+    vDiff = np.array(positionOfNode1)-np.array(positionOfNode0)
+    lDiff = np.linalg.norm(vDiff)
+    if (numberOfElements <= 0 or numberOfElements != int(numberOfElements)): 
+        raise ValueError('GenerateStraightBeam: number of elements must be integer, non-zero and positive')
+
+    beamLength = lDiff/numberOfElements
+    
+    # slope of elements in reference position, calculated from first and last node position:
+    if (lDiff == 0.): 
+        raise ValueError('GenerateStraightBeam: distance between positionOfNode0 and positionOfNode1 is zero; terminating')
+    beamSlopeVec = (1./lDiff)*vDiff
+    
+    if isGeomExact:
+        if not is2D: 
+            raise ValueError('GenerateStraightBeam: only works for 2D geometrically exact beam for now!')
+        beamRotations = [atan2(beamSlopeVec[1], beamSlopeVec[0])]
+    else:
+        beamRotations = ConvertVector(beamSlopeVec, is2D)
+   
+    # add first ANCF node (straight reference configuration):
+    if (nodeNumber0!=-1):
+        beamNodeList+=[nodeNumber0]
+        nBeam0=nodeNumber0
+    else:
+        nBeam0 = mbs.AddNode(NodeTemplate(referenceCoordinates=ConvertVector(positionOfNode0, is2D) + beamRotations)) 
+        beamNodeList+=[nBeam0]
+    
+    beamTemplate.physicsLength = beamLength
+    
+    # add all other ANCF nodes (straight reference configuration) and attach Gravity marker to them:
+    for i in range(numberOfElements): 
+        
+        positionOfCurrentNode = (np.array(positionOfNode0)+beamLength*beamSlopeVec*(i+1)).tolist()
+        # positionOfCurrentNode=[positionOfNode0[0]+beamLength*beamSlopeVec[0]*(i+1),
+        #                        positionOfNode0[1]+beamLength*beamSlopeVec[1]*(i+1), 
+        #                        positionOfNode0[2]+beamLength*beamSlopeVec[2]*(i+1), 
+        #                        ]
+        #if is2D: positionOfCurrentNode[2] = 0
+        
+        beamNodePositionList+=[positionOfCurrentNode]
+        
+        if (i==numberOfElements-1 and nodeNumber1!=-1):
+            nBeamLast = nodeNumber1
+        else:
+            nBeamLast = mbs.AddNode(NodeTemplate(referenceCoordinates=ConvertVector(positionOfCurrentNode, is2D) + beamRotations)) 
+            # if is2D:
+            #     nBeamLast = mbs.AddNode(eii.NodePoint2DSlope1(referenceCoordinates=[positionOfCurrentNode[0],positionOfCurrentNode[1],beamSlopeVec[0],beamSlopeVec[1]]))
+            # else:
+            #     nBeamLast = mbs.AddNode(eii.NodePointSlope1(referenceCoordinates=list(positionOfCurrentNode) + list(beamSlopeVec) ))
+        
+        beamNodeList+=[nBeamLast]
+        
+        #do not override all node numbers, as nodeNumbers[2] may be ALE node
+        beamTemplate.nodeNumbers[0:2]=[beamNodeList[i],beamNodeList[i+1]]
+            
+        oBeam=mbs.AddObject(beamTemplate)
+        beamObjectList+=[oBeam]
+
+        if np.linalg.norm(gravity) != 0:
+            mBodyMassLast = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=oBeam))
+            lLoadLast=mbs.AddLoad(eii.Gravity(markerNumber=mBodyMassLast,loadVector=gravity))
+            loadList+=[lLoadLast]
+        
+    
+    if not(fixedConstraintsNode0 is None):
+        # ground "node" at first node:
+        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=positionOfNode0)) 
+        # add marker to ground "node": 
+        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
+
+        for j in range(len(fixedConstraintsNode0)):            
+            if fixedConstraintsNode0[j] != 0:
+                #fix ANCF coordinates of first node
+                mBeamCoordinateConstraint0 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nBeam0, coordinate=j)) #add marker
+                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mBeamCoordinateConstraint0])) #add constraint
+                beamCoordinateConstraintList+=[cBoundaryCondition]
+            
+    if not(fixedConstraintsNode1 is None):
+        # ground "node" at first node:
+        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=positionOfNode1)) 
+        # add marker to ground "node": 
+        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
+
+        for j in range(len(fixedConstraintsNode1)):            
+            if fixedConstraintsNode1[j] != 0:
+                # fix right end position coordinates, i.e., add markers and constraints:
+                mBeamCoordinateConstraint1 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nBeamLast, coordinate=j))#add marker
+                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mBeamCoordinateConstraint1])) #add constraint  
+                beamCoordinateConstraintList+=[cBoundaryCondition]
+            
+    
+    return [beamNodeList, beamObjectList, loadList, beamNodePositionList, beamCoordinateConstraintList]
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate cable elements along circular arc with given start point, radius, start angle (measured relative to $x$-axis, in positive rotation sense) and angle of arc
+#**input:
+#  mbs: the system where ANCF cables are added
+#  positionOfNode0: 3D position (list or np.array) for starting point of line
+#  radius: radius of arc
+#  startAngle: start angle of arc in radians  ($0 \ldots 2 \pi$), defines the direction of the slope vector, measured relative to $x$-axis, in positive rotation sense
+#  arcAngle: total angle of arc in radians ($0 \ldots 2 \pi$), measured in positive rotation sense (negative angle reverts curvature and center point of circle)
+#  numberOfElements: for discretization of arc
+#  cableTemplate: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
+#  massProportionalLoad: a 3D list or np.array, containing the gravity vector or zero
+#  fixedConstraintsNode0: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope)
+#  fixedConstraintsNode1: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope)
+#  nodeNumber0: if set other than -1, this node number defines the node that shall be used at positionOfNode0
+#  nodeNumber1: if set other than -1, this node number defines the node that shall be used at positionOfNode1
+#  setCurvedReferenceConfiguration: if True, the curvature +/-(1/radius) is set as a reference configuration (sign depends on arcAngle); if False, the reference configuration is straight
+#  verboseMode: if True, prints out information on created nodes
+#**output: returns a list [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+def GenerateCircularArcANCFCable2D(mbs, positionOfNode0, radius, startAngle, arcAngle, 
+                                   numberOfElements, cableTemplate,
+                                   massProportionalLoad=[0,0,0], fixedConstraintsNode0=[0,0,0,0], fixedConstraintsNode1=[0,0,0,0],
+                                   nodeNumber0=-1, nodeNumber1=-1, setCurvedReferenceConfiguration=True, verboseMode=False):
+    
+
+    cableNodeList=[]
+    cableNodePositionList=[positionOfNode0]
+    cableObjectList=[]
+    loadList=[]
+    cableCoordinateConstraintList=[]
+    if len(positionOfNode0) != 3:
+        exudyn.Print('WARNING: GenerateCircularArcANCFCable2D: positionOfNode0 should be a 3D vector')
+
+    if (numberOfElements <= 0 or numberOfElements != int(numberOfElements)): 
+        raise ValueError('GenerateCircularArcANCFCable2D: number of elements must be integer, non-zero and positive')
+
+    if (radius <= 0.): 
+        raise ValueError('GenerateCircularArcANCFCable2D: radius must be > 0')
+
+    if (arcAngle == 0.): 
+        raise ValueError('GenerateCircularArcANCFCable2D: arcAngle must be non-zero')
+
+    #length of one element:
+    cableLength = radius*abs(arcAngle)/numberOfElements
+    # exudyn.Print('cableLength=',cableLength)
+    # exudyn.Print('p0=', positionOfNode0)
+    
+    #reverse normal and slope, means changing the curvature and center point of arc
+    arcSign = 1.
+    if arcAngle < 0.:
+        arcSign = -1.
+
+    # slope vector of first node
+    cableSlopeVec = np.array([ np.cos(startAngle),np.sin(startAngle),0.])
+    cableNormal =   np.array([-np.sin(startAngle),np.cos(startAngle),0.])
+    
+    #center point of circle for creation of arc:
+    pCenter = arcSign*radius*cableNormal + np.array(positionOfNode0)
+    # exudyn.Print('pCenter=',pCenter)
+
+    # add first ANCF node (straight reference configuration):
+    if (nodeNumber0!=-1):
+        cableNodeList+=[nodeNumber0]
+    else:
+        nCable0 = mbs.AddNode(eii.Point2DS1(referenceCoordinates=[positionOfNode0[0],positionOfNode0[1],cableSlopeVec[0],cableSlopeVec[1]])) 
+        cableNodeList+=[nCable0]
+        if verboseMode:
+            exudyn.Print('  node 0: pos=', positionOfNode0[0],',',positionOfNode0[1],', slope=',cableSlopeVec[0],',',cableSlopeVec[1])
+    
+    cableTemplate.physicsLength = cableLength
+
+    oldReferenceCurvature = cableTemplate.physicsReferenceCurvature 
+    if setCurvedReferenceConfiguration:
+        cableTemplate.physicsReferenceCurvature = arcSign/radius #set reference curvature, such that beam is pre-curved
+    
+    # add all other ANCF nodes (straight reference configuration) and attach Gravity marker to them:
+    for i in range(numberOfElements): 
+        phi = (i+1)*arcAngle/float(numberOfElements)
+        #new node:
+        pArc = pCenter + arcSign*radius*np.sin(phi)*cableSlopeVec - arcSign*radius*np.cos(phi)*cableNormal
+        #new slope:
+        vArc = np.cos(phi)*cableSlopeVec + np.sin(phi)*cableNormal
+        # exudyn.Print('pArc'+str(i)+'=',pArc)
+        # exudyn.Print('vArc'+str(i)+'=',vArc)
+        
+        positionOfCurrentNode=[pArc[0],pArc[1],0.]
+        cableNodePositionList+=[positionOfCurrentNode]
+
+        if verboseMode:
+            exudyn.Print('  node '+str(i+1)+': pos=', positionOfCurrentNode[0],',',positionOfCurrentNode[1],', slope=',vArc[0],',',vArc[1])
+        
+        if (i==numberOfElements-1 and nodeNumber1!=-1):
+            nCableLast = nodeNumber1
+        else:
+            nCableLast = mbs.AddNode(eii.Point2DS1(referenceCoordinates=[positionOfCurrentNode[0],positionOfCurrentNode[1],
+                                                                     vArc[0],vArc[1]]))
+
+        # exudyn.Print('cableNodeList=',cableNodeList)
+        
+        cableNodeList+=[nCableLast]
+        
+        cableTemplate.nodeNumbers[0:2]=[cableNodeList[i],cableNodeList[i+1]]
+            
+        oCable=mbs.AddObject(cableTemplate)
+        cableObjectList+=[oCable]
+
+        if np.linalg.norm(massProportionalLoad) != 0:
+            mBodyMassLast = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=oCable))
+            lLoadLast=mbs.AddLoad(eii.Gravity(markerNumber=mBodyMassLast,loadVector=massProportionalLoad))
+            loadList+=[lLoadLast]
+        
+    
+    if (np.linalg.norm(list(fixedConstraintsNode0)+list(fixedConstraintsNode1)) ) != 0:
+        # ground "node" at 0,0,0:
+        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=[0,0,0])) 
+        # add marker to ground "node": 
+        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
+    
+
+        for j in range(4):            
+            if fixedConstraintsNode0[j] != 0:            
+                #fix ANCF coordinates of first node
+                mCableCoordinateConstraint0 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nCable0, coordinate=j)) #add marker
+                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint0])) #add constraint
+                cableCoordinateConstraintList+=[cBoundaryCondition]
+            
+        for j in range(4):            
+            if fixedConstraintsNode1[j] != 0:                 
+                # fix right end position coordinates, i.e., add markers and constraints:
+                mCableCoordinateConstraint1 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nCableLast, coordinate=j))#add marker
+                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint1])) #add constraint  
+                cableCoordinateConstraintList+=[cBoundaryCondition]
+
+     
+    if setCurvedReferenceConfiguration:
+        cableTemplate.physicsReferenceCurvature = oldReferenceCurvature        
+    
+    return [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+
+
+
+
+
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: CreateReevingCurve for creating the geometry of a reeving system based on circles with radius and left/right side of passing the circles; left/right is seen in the direction passing from one to the next circle
+#**input:
+#  circleList: list containing center position, radius and 'L' (left) or 'R' (right) passing of circle
+#  radialOffset: additional offset added to circles to account for half height of rope or beam
+#  closedCurve: if True, the system adds circleList[0] and  circleList[1] at end of list and sets removeLastLine=True and removeFirstLine=False, in order to generate a closed curve according to given circles; furthermore, the number of nodes becomes equal to the number of elements in this case
+#  drawingLinesPerCircle: number of lines in lineData per one revolution
+#  numberOfANCFnodes: if not -1, function also generates nodes with equidistant distribution along curve!
+#  graphicsElementsPerCircle: number of drawing lines generated in graphicsDataLines per circle revolution (larger generates better approximation of circles)
+#  graphicsNodeSize: if not 0, addes graphics representation of nodes generated; for check if mesh is correct
+#  removeFirstLine: removes first line generated, which may be unwanted
+#  removeLastLine: removes last line generated, which may be unwanted
+#  colorCircles: RGBA color for circles
+#  colorLines: RGBA color for lines
+#**output: return a dictionary with {'ancfPointsSlopes':ancfPointsSlopes, 'elementLengths':elementLengths, 'elementCurvatures':elementCurvatures, 'totalLength':totalLength, 'circleData':circle2D, 'graphicsDataLines':graphicsDataLines, 'graphicsDataCircles':graphicsDataCircles }; 'ancfPointsSlopes' denotes 4-dimensional vector with (x/y) position and (x/y) slope coordinates in a row; 'elementLengths' is the list of curved lengths for elements between nodes (size is 1 smaller than number of nodes), 'elementCurvatures' is the list of scalar curvatures between nodes (according to list of elementLengths), 'totalLength' is the total length of the reeving line, 'circleData' represents the lines and arcs calculated for the reeving system, 'graphicsDataLines' is the graphicsData for the lines and 'graphicsDataCircles' represents the graphicsData for the circles
+#**example:
+# #list with circle center, radius and side at which rope runs
+# circleList = [[[0,0],0.2,'L'],
+#               [[0,1],0.2,'L'],
+#               [[0.8,0.8],0.4,'L'],
+#               [[1,0],0.2,'L'],
+#               [[0,0],0.2,'L'],
+#               [[0,1],0.2,'L'],
+#               ]
+# [] = CreateReevingCurve(circleList, 
+#                         removeLastLine=True, #allows closed curve
+#                         numberOfANCFnodes=50)
+def CreateReevingCurve(circleList, drawingLinesPerCircle = 64, numberOfANCFnodes=-1, 
+                       removeLastLine=False, removeFirstLine=False,
+                       radialOffset = 0., closedCurve=False,
+                       graphicsElementsPerCircle=64, graphicsNodeSize=0,
+                       colorCircles=[0.,0.5,1.,1.], colorLines=[1.,0.5,0.,1.]):
+
+    nodesANCFcreated = numberOfANCFnodes
+    minP=np.array([ 1e30, 1e30, 1e30])
+    maxP=np.array([-1e30,-1e30,-1e30])
+    
+    circleListExt = copy.deepcopy(circleList)
+    
+    if closedCurve:
+        circleListExt += [circleList[0]]
+        circleListExt += [circleList[1]]
+        removeLastLine=True 
+        removeFirstLine=False
+        if nodesANCFcreated!=-1:
+            nodesANCFcreated += 1
+    
+    graphicsDataCircles = [] #optional graphics for circles
+    for circle in circleListExt:
+        #exudyn.Print(circle)
+        pos = [circle[0][0],circle[0][1],0]
+        r = circle[1]+radialOffset
+        if circle[1] <= 0.:
+            raise ValueError('CreateReevingCurve: radius in circleList may not be zero or negative!')
+
+        graphicsDataCircles += [{'type':'Circle', 'color':colorCircles,
+                  'position':pos,'radius':r}]
+        minP = np.minimum(minP, np.array(pos)-[r,r,0])
+        maxP = np.maximum(maxP, np.array(pos)+[r,r,0])
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #create list of lines and arcs:
+    
+    #list of dictionaries for lines and arcs; everything in 2D
+    #lines: {'type':'LINE', 'point0':np.array([0,0]), 'point1':np.array([0,0])}
+    #circularArcs: {'type':'ARC', 'point0':np.array([0,0]), 'center':np.array([0,0]), 'radius':1, 'startAngle':angle0, 'arcAngle':angle1}
+    curve2D = []
+
+    #start points from circle 0:
+    circle = circleListExt[0]
+    pos0 = np.array([circle[0][0],circle[0][1]])
+    r0 = circle[1]+radialOffset
+    side0=circle[2]
+    p1Last = [] #point from last arc; empty if no arc to continue
+    # pos0 = np.array([-1,-0.8])
+    # r0 = 0.2
+    # side0='L'
+    # p1Last = [] #point from last arc; empty if no arc to continue
+
+
+    totalLength = 0.
+    
+    for i, circle in enumerate(circleListExt):
+        #exudyn.Print(circle)
+        if i==0: #first circle is used already
+            continue 
+    
+        pos1 = np.array([circle[0][0],circle[0][1]])
+        r1 = circle[1]+radialOffset
+        side1 = circle[2]
+        if r0 < 0. or r1 < 0.: continue
+    
+        vv = pos1-pos0
+        L = np.linalg.norm(vv)
+        if L==0: 
+            raise ValueError('CreateReevingCurve: distance of circles is zero')
+        vv0 = (1./L)*vv
+        nv0 = np.array([-vv0[1],vv0[0]])
+    
+        sign0 = 1
+        sign1 = 1
+        if side0 == 'R':
+            sign0 = -1
+        if side1 == 'R':
+            sign1 = -1
+        alpha = asin((sign1*r1 - sign0*r0)/L)
+    
+        p0 = pos0+sign0*nv0*cos(alpha)*r0+vv0*sin(-sign0*alpha)*r0
+        p1 = pos1+sign1*nv0*cos(alpha)*r1+vv0*sin(-sign1*alpha)*r1
+        
+        # exudyn.Print('circle',i,', alpha=',alpha,', p0=',p0,', p1=',p1)
+        # exudyn.Print('  vv0=',vv0,', nv0=', nv0, ', sign0=',sign0, ', sign1=',sign1)
+        # exudyn.Print('  r0=',r0,', r1=', r1,', pos0=', pos0,', pos1=', pos1)
+    
+    
+        #add arc from end of last line
+        if list(p1Last) != []:
+            vr0 = p1Last-pos0
+            angle0=atan2(vr0[1],vr0[0])-sign0*0.5*pi
+            vr1 = p0-pos0
+            angle1=atan2(vr1[1],vr1[0])-sign0*0.5*pi
+            arcAngle = (angle1-angle0)
+            if arcAngle < 0 and side0=='R':
+                arcAngle+=2.*pi
+            if arcAngle > 0 and side0=='L':
+                arcAngle-=2.*pi
+            # exudyn.Print('aa=',arcAngle)
+            curve2D+=[{'type':'ARC', 'point0':p1Last, 
+                       'radius':r0, 'startAngle':angle0, 'endAngle':angle1, 'arcAngle':arcAngle}]
+            totalLength += abs(r0*arcAngle)
+    
+        #only add this line, if not excluded!
+        if not ((removeFirstLine and i==1) or
+                (removeLastLine and i==len(circleListExt)-1)):
+            segmentLength = np.linalg.norm(p1-p0)
+            if segmentLength == 0.:
+                print('WARNING: CreateReevingCurve: curve seems to be degenerated, check location of circles')
+            curve2D += [{'type':'LINE', 'point0':p0, 'point1':p1}]
+            totalLength += segmentLength
+    
+        #for next circle:
+        p1Last = copy.deepcopy(p1)
+        pos0 = copy.deepcopy(pos1)
+        r0 = copy.deepcopy(r1)
+        side0 = copy.deepcopy(side1)
+    
+    #create single line:
+    lineData=[]
+    
+    if nodesANCFcreated > 0 and nodesANCFcreated < 2:
+        raise ValueError('CreateReevingCurve: numberOfANCFnodes must be either -1 [deactivated] or > 2 !')
+
+    numberOfElements = nodesANCFcreated-1
+    lElem = totalLength/numberOfElements
+    ancfPointsSlopes = [] #list of 4D vectors with nodal points+slopes
+    elementLengths = [] #curved length for elements stored
+    elementCurvatures = [] #curvature of element i, between nodes i and i+1
+    
+    arcCoord = 0 #remember how far already gone!
+    nextArcCoord = 0 #this is the acrCoord with the next node
+    tol = 1e-10 #make sure to add last node, which can have some round-off errors
+    
+    #now create nodes for ANCF elements:
+    
+    for item in curve2D:
+        if item['type']=='LINE':
+            p0 = item['point0']
+            p1 = item['point1']
+            lineData+=list(p0)+[0]
+            lineData+=list(p1)+[0]
+            L = np.linalg.norm(p1-p0)
+            startCoord = arcCoord  #this is the arcCoordinate of the start of this line/curve
+            endCoord = arcCoord+L  #this is the arcCoordinate of the end of this line/curve
+            while nextArcCoord <= endCoord*(1.+tol):
+                slope = (1/L)*(p1-p0)
+                p = p0 + (nextArcCoord-startCoord)*slope
+                ancfPointsSlopes+=[list(p)+list(slope)]
+                if nextArcCoord != 0:
+                    elementLengths += [lElem]
+                    elementCurvatures += [0.] #represents straight line!
+                nextArcCoord += lElem
+            arcCoord = endCoord
+        elif item['type']=='ARC':
+            startAngle = item['startAngle']
+            arcAngle = item['arcAngle']
+            p0 = item['point0']
+            r = item['radius']
+    
+            arcSign = 1.
+            if arcAngle < 0.:
+                arcSign = -1.
+    
+            # slope vector of first node
+            vv0 = np.array([ np.cos(startAngle),np.sin(startAngle)])
+            nv0=   np.array([-np.sin(startAngle),np.cos(startAngle)])
+    
+            #center point of circle for creation of arc:
+            pCenter = arcSign*r*nv0 + p0
+
+            nARC = int(abs(arcAngle)*graphicsElementsPerCircle/(2*pi))+1
+        
+            for i in range(nARC):
+                phi = (i+1)*arcAngle/float(nARC)
+                #new node:
+                pArc = pCenter + arcSign*r*np.sin(phi)*vv0 - arcSign*r*np.cos(phi)*nv0
+                lineData+=list(pArc)+[0]
+            
+            L = abs(r*arcAngle)
+            startCoord = arcCoord  #this is the arcCoordinate of the start of this line/curve
+            endCoord = arcCoord+L  #this is the arcCoordinate of the end of this line/curve
+            while nextArcCoord <= endCoord*(1.+tol):
+                phi = (nextArcCoord-startCoord)/L*arcAngle
+    
+                pArc = pCenter + arcSign*r*np.sin(phi)*vv0 - arcSign*r*np.cos(phi)*nv0
+                vArc = np.cos(phi)*vv0 + np.sin(phi)*nv0
+    
+                ancfPointsSlopes+=[list(pArc)+list(vArc)]
+                if nextArcCoord != 0:
+                    elementLengths += [lElem]
+                    curvature = arcSign*1./r #correct sign, whether it is left or right
+                    #print('curvature=',curvature, ', sign=',arcSign)
+                    elementCurvatures += [curvature] #r may not be zero!
+                nextArcCoord += lElem
+            
+            arcCoord = endCoord
+    
+    exudyn.Print('Reeving system total length=', totalLength)
+    # exudyn.Print('ANCF nodes=', ancfPointsSlopes)
+    
+    graphicsDataLines = [{'type':'Line', 'color':colorLines, 
+                  'data':lineData} ]
+
+    if graphicsNodeSize!= 0:
+        for ps in ancfPointsSlopes:
+            graphicsDataLines += [{'type':'Circle', 'color':colorLines,
+                  'position':[ps[0],ps[1],0],'radius':graphicsNodeSize}]
+
+    return {'ancfPointsSlopes':ancfPointsSlopes, 'elementLengths':elementLengths, 
+            'elementCurvatures':elementCurvatures, 'totalLength':totalLength, 'circleData':curve2D, 
+            'lineData':lineData, 'graphicsDataLines':graphicsDataLines, 'graphicsDataCircles':graphicsDataCircles }
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Create nodes and ANCFCable2D elements in MainSystem mbs from a given set of nodes, elements lengths and a template for the cable, based on output of function CreateReevingCurve(...); function works similar to GenerateStraightLineANCFCable2D, but for arbitrary geometry (curved elements); optionally add loads and constraints
+#**input:
+#  mbs: the system where ANCF elements and nodes are added
+#  ancfPointsSlopes: list of position and slopes for nodes, provided as 4D numpy arrays, as returned by CreateReevingCurve(...)
+#  elementLengths: list of element lengths per element, as returned by CreateReevingCurve(...)
+#  cableTemplate: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
+#  massProportionalLoad: a 3D list or np.array, containing the gravity vector to be applied to all elements or zero
+#  fixedConstraintsNode0: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope)
+#  fixedConstraintsNode1: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope)
+#  firstNodeIsLastNode: if True, then the last node is using the node number of the first node and the curve is closed; otherwise, the first and last nodes are different, and the curve is open
+#  elementCurvatures: optional list of pre-curvatures of elements, used to override the cableTemplate entry 'physicsReferenceCurvature'; use 0. for straight lines!
+#  graphicsSizeConstraints: if set other than -1, it will be used as the size for drawing applied coordinate constraints
+#**output: returns a list [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+def PointsAndSlopes2ANCFCable2D(mbs, ancfPointsSlopes, elementLengths, cableTemplate, massProportionalLoad=[0,0,0], 
+                                fixedConstraintsNode0=[0,0,0,0], fixedConstraintsNode1=[0,0,0,0], firstNodeIsLastNode=True,
+                                elementCurvatures=[], graphicsSizeConstraints=-1):
+
+    cableNodeList=[]
+    cableNodePositionList=[]
+    cableObjectList=[]
+    loadList=[]
+    cableCoordinateConstraintList=[]
+    
+    # add first ANCF node (straight reference configuration):
+    nodeNumber0 = mbs.AddNode(eii.Point2DS1(referenceCoordinates=ancfPointsSlopes[0])) 
+    cableNodeList+=[nodeNumber0]
+    cableNodePositionList+=[ancfPointsSlopes[0][0],ancfPointsSlopes[0][1],0] #3D
+    numberOfElements = len(ancfPointsSlopes)-1
+    
+    # add all other ANCF nodes (straight reference configuration) and attach Gravity marker to them:
+    for i in range(numberOfElements): 
+        # pointSlope0 = ancfPointsSlopes[i]
+        # pointSlope1 = ancfPointsSlopes[i+1]
+
+        cableTemplate.physicsLength = elementLengths[i]
+        if elementCurvatures != []:
+            cableTemplate.physicsReferenceCurvature = elementCurvatures[i]
+        
+        if (i==numberOfElements-1 and firstNodeIsLastNode):
+            nodeNumberLast = nodeNumber0
+        else:
+            nodeNumberLast = mbs.AddNode(eii.Point2DS1(referenceCoordinates=ancfPointsSlopes[i+1]))
+        cableNodeList+=[nodeNumberLast]
+
+        cableNodePositionList+=[ancfPointsSlopes[i+1][0],ancfPointsSlopes[i+1][1],0] #3D
+       
+        
+        cableTemplate.nodeNumbers[0:2]=[cableNodeList[i],cableNodeList[i+1]]
+            
+        oCable=mbs.AddObject(cableTemplate)
+        cableObjectList+=[oCable]
+
+        if np.linalg.norm(massProportionalLoad) != 0:
+            mBodyMassLast = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=oCable))
+            lLoadLast=mbs.AddLoad(eii.Gravity(markerNumber=mBodyMassLast,loadVector=massProportionalLoad))
+            loadList+=[lLoadLast]
+        
+    
+    if (np.linalg.norm(list(fixedConstraintsNode0)+list(fixedConstraintsNode1)) ) != 0:
+        # ground "node" at 0,0,0:
+        nGround = mbs.AddNode(eii.NodePointGround(referenceCoordinates=[0,0,0])) 
+        # add marker to ground "node": 
+        mGround = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nGround, coordinate=0))
+    
+        if (firstNodeIsLastNode and
+            np.linalg.norm(fixedConstraintsNode1)  != 0):
+            raise ValueError('PointsAndSlopes2ANCFCable2D: fixedConstraintsNode1 must be [0,0,0,0] in case t firstNodeIsLastNode==True')
+
+        for j in range(4):            
+            if fixedConstraintsNode0[j] != 0:            
+                #fix ANCF coordinates of first node
+                mCableCoordinateConstraint0 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nodeNumber0, coordinate=j)) #add marker
+                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint0],
+                                                                      visualization=eii.VCoordinateConstraint(drawSize=graphicsSizeConstraints))) #add constraint
+                cableCoordinateConstraintList+=[cBoundaryCondition]
+            
+        for j in range(4):            
+            if fixedConstraintsNode1[j] != 0:                 
+                # fix right end position coordinates, i.e., add markers and constraints:
+                mCableCoordinateConstraint1 = mbs.AddMarker(eii.MarkerNodeCoordinate(nodeNumber = nodeNumberLast, 
+                                                                                 coordinate=j))#add marker
+                cBoundaryCondition=mbs.AddObject(eii.CoordinateConstraint(markerNumbers=[mGround,mCableCoordinateConstraint1],
+                                                                      visualization=eii.VCoordinateConstraint(drawSize=graphicsSizeConstraints))) #add constraint
+                cableCoordinateConstraintList+=[cBoundaryCondition]
+            
+    
+    return [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]
+
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#sliding joint utilities
+
+#**function: generate a sliding joint from a list of cables, marker to a sliding body, etc.
+#**output: returns the sliding joint object
+def GenerateSlidingJoint(mbs,cableObjectList,markerBodyPositionOfSlidingBody,localMarkerIndexOfStartCable=0,slidingCoordinateStartPosition=0):
+
+    cableMarkerList = []#list of Cable2DCoordinates markers
+    offsetList = []     #list of offsets counted from first cable element; needed in sliding joint
+    offset = 0          #first cable element has offset 0
+    
+    for item in cableObjectList: #create markers for cable elements
+        m = mbs.AddMarker(eii.MarkerBodyCable2DCoordinates(bodyNumber = item))
+        cableMarkerList += [m]
+        offsetList += [offset]  
+        offset += mbs.GetObjectParameter(item,'physicsLength')
+    
+    nodeDataSlidingJoint = mbs.AddNode(eii.NodeGenericData(initialCoordinates=[localMarkerIndexOfStartCable,slidingCoordinateStartPosition],numberOfDataCoordinates=2)) #initial index in cable list
+    
+    oSlidingJoint = mbs.AddObject(eii.ObjectJointSliding2D(markerNumbers=[markerBodyPositionOfSlidingBody,cableMarkerList[localMarkerIndexOfStartCable]], 
+                                                      slidingMarkerNumbers=cableMarkerList, 
+                                                      slidingMarkerOffsets=offsetList, 
+                                                      nodeNumber=nodeDataSlidingJoint))
+
+    return [oSlidingJoint]
+
+
+
+
+
+#**function: generate an ALE sliding joint from a list of cables, marker to a sliding body, etc.
+#**output: returns the sliding joint object
+def GenerateAleSlidingJoint(mbs,cableObjectList,markerBodyPositionOfSlidingBody,AleNode,
+                            localMarkerIndexOfStartCable=0,AleSlidingOffset=0,
+                            activeConnector=True, penaltyStiffness=0):
+
+    cableMarkerList = []#list of Cable2DCoordinates markers
+    offsetList = []     #list of offsets counted from first cable element; needed in sliding joint
+    offset = 0          #first cable element has offset 0
+    usePenalty = (penaltyStiffness!=0) #penaltyStiffness=0 ==> no penalty formulation!
+    
+    for item in cableObjectList: #create markers for cable elements
+        m = mbs.AddMarker(eii.MarkerBodyCable2DCoordinates(bodyNumber = item))
+        cableMarkerList += [m]
+        offsetList += [offset]  
+        offset += mbs.GetObjectParameter(item,'physicsLength')
+    
+    nodeDataAleSlidingJoint = mbs.AddNode(eii.NodeGenericData(initialCoordinates=[localMarkerIndexOfStartCable],numberOfDataCoordinates=1)) #initial index in cable list   
+    oAleSlidingJoint = mbs.AddObject(eii.ObjectJointALEMoving2D(markerNumbers=[markerBodyPositionOfSlidingBody,cableMarkerList[localMarkerIndexOfStartCable]], 
+                                                      slidingMarkerNumbers=cableMarkerList, slidingMarkerOffsets=offsetList,
+                                                      nodeNumbers=[nodeDataAleSlidingJoint, AleNode], slidingOffset=AleSlidingOffset,activeConnector=activeConnector,
+                                                      usePenaltyFormulation = usePenalty, penaltyStiffness=penaltyStiffness))
+
+
+    return [oAleSlidingJoint]
+
+
+
+
```

## exudyn/demos.py

 * *Ordering differences only*

```diff
@@ -1,165 +1,165 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  The demos library includes basic demos which are available directly after installation;
-#           For advanced demos, see main/pythonDev/Examples and main/pythonDev/TestModels
-#
-# Authors:  Johannes Gerstmayr
-# Date:     2023-01-12
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-import exudyn as exu
-
-def DemoInfo():
-    print('\n************************************')
-    print('for advanced demos github page:')
-    print('https://github.com/jgerstmayr/EXUDYN')
-    print('look under main/pythonDev/Examples')
-    print('and main/pythonDev/TestModels')
-    print('************************************\n')
-    
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: very simple demo to show that exudyn is correctly installed; does not require graphics; similar to Examples/myFirstExample.py
-def Demo1(showAll = True):
-    if showAll:
-        print('start demo1: verify that exudyn is running')
-    import exudyn as exu               #EXUDYN package including C++ core part
-    import exudyn.itemInterface as eii #conversion of data to exudyn dictionaries
-    
-    SC = exu.SystemContainer()         #container of systems
-    mbs = SC.AddSystem()               #add a new system to work with
-    
-    nMP = mbs.AddNode(eii.NodePoint2D(referenceCoordinates=[0,0]))
-    mbs.AddObject(eii.ObjectMassPoint2D(physicsMass=10, nodeNumber=nMP ))
-    mMP = mbs.AddMarker(eii.MarkerNodePosition(nodeNumber = nMP))
-    mbs.AddLoad(eii.Force(markerNumber = mMP, loadVector=[0.001,0,0]))
-    
-    mbs.Assemble()                     #assemble system and solve
-    simulationSettings = exu.SimulationSettings()
-    simulationSettings.timeIntegration.verboseMode=1 #provide some output
-    simulationSettings.solutionSettings.coordinatesSolutionFileName = 'solution/demo1.txt'
-
-    mbs.SolveDynamic(simulationSettings)
-    if showAll:
-        print('results can be found in local directory: solution/demo1.txt')
-    
-        DemoInfo()
-    
-    return [mbs, SC]
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: advanced demo, showing that graphics is available; similar to Examples/rigid3Dexample.py
-def Demo2(showAll = True):
-    import exudyn as exu
-    import exudyn.itemInterface as eii #conversion of data to exudyn dictionaries
-    from exudyn.utilities import GraphicsDataCheckerBoard, eulerParameters0, GraphicsDataSphere, \
-                                 GraphicsDataOrthoCubePoint, AngularVelocity2EulerParameters_t, \
-                                     color4dodgerblue, color4darkgrey
-    
-    SC = exu.SystemContainer()
-    mbs = SC.AddSystem()
-    
-    if showAll:
-        print('EXUDYN version='+exu.GetVersionString())
-    
-    #%%+++++++++++++++++++++++++++++++++++
-    #background
-    color = [0.1,0.1,0.8,1]
-    zz = 2  #max size
-    s = 0.1 #size of cube
-    sx = 3*s #x-size
-    cPosZ = 0.1 #offset of constraint in z-direction, to get more arbitrary motion
-
-    background0 = GraphicsDataCheckerBoard(point=[0,-2*zz,-0.5*zz],size=8*zz, size2=6.4*zz, nTiles2=8)
-    oGround=mbs.AddObject(eii.ObjectGround(referencePosition= [0,0,0], 
-                                       visualization=eii.VObjectGround(graphicsData= [background0])))
-    mPosLast = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber = oGround, 
-                                                localPosition=[0,0,cPosZ]))
-    
-    #%%+++++++++++++++++++++++++++++++++++
-    #create a chain of 6 bodies:
-    for i in range(12):
-        #print("Build Object", i)
-        ep0 = eulerParameters0 #no rotation
-        p0 = [sx+i*2*sx,0.,0] #reference position
-    
-        nRB = mbs.AddNode(eii.NodeRigidBodyEP(referenceCoordinates=p0+ep0))
-        oGraphics = GraphicsDataOrthoCubePoint(size=[1.8*sx, 2*s, 2*s], color= color4dodgerblue, addEdges=True)
-        oGraphicsJoint = GraphicsDataSphere(point=[-sx,0,cPosZ], radius = 0.6*s, color=color4darkgrey, 
-                                            nTiles=24)
-        oRB = mbs.AddObject(eii.ObjectRigidBody(physicsMass=2, 
-                                            physicsInertia=[6,1,6,0,0,0], 
-                                            nodeNumber=nRB, 
-                                            visualization=eii.VObjectRigidBody(graphicsData=[oGraphics, oGraphicsJoint])))
-    
-        mMassRB = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber = oRB))
-        mbs.AddLoad(eii.Gravity(markerNumber = mMassRB, loadVector=[0.,-9.81,0.])) #gravity in negative z-direction
-    
-        mPos = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber = oRB, localPosition = [-sx,0.,cPosZ]))
-        mbs.AddObject(eii.SphericalJoint(markerNumbers = [mPosLast, mPos]))
-        mPosLast = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber = oRB, localPosition = [sx,0.,cPosZ]))
-    
-    #%%+++++++++++++++++++++++++++++++++++
-    mbs.Assemble()
-    # print(mbs)
-    
-    simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-    
-    fact = 2000*(1+9*showAll) #10000
-    simulationSettings.timeIntegration.numberOfSteps = 1*fact
-    simulationSettings.timeIntegration.endTime = 0.001*fact*0.5*4
-    simulationSettings.solutionSettings.solutionWritePeriod = simulationSettings.timeIntegration.endTime/fact*20
-    simulationSettings.solutionSettings.coordinatesSolutionFileName = 'solution/chain.txt'
-    simulationSettings.timeIntegration.verboseMode = 1
-    simulationSettings.linearSolverType = exu.LinearSolverType.EigenSparse
-
-    simulationSettings.timeIntegration.newton.useModifiedNewton = True
-    simulationSettings.timeIntegration.generalizedAlpha.spectralRadius = 0.6 #0.6 works well 
-    
-    SC.visualizationSettings.general.renderWindowString = "rigid body chain: press 'V' for drawing settings and 'Q' to stop"
-    SC.visualizationSettings.nodes.defaultSize = 0.05
-    SC.visualizationSettings.general.graphicsUpdateInterval = 0.02
-
-    SC.visualizationSettings.openGL.multiSampling = 4
-    SC.visualizationSettings.openGL.lineWidth = 2
-    
-    SC.visualizationSettings.openGL.shadow = 0.3
-    SC.visualizationSettings.openGL.light0position = [4,4,10,0]
-    
-    if showAll:
-        exu.StartRenderer()
-        mbs.WaitForUserToContinue()
-    
-    simulationSettings.timeIntegration.numberOfSteps = 1*fact
-    simulationSettings.timeIntegration.endTime = 0.001*fact*0.5*4
-    mbs.SolveDynamic(simulationSettings)
-    
-    if showAll:
-        SC.WaitForRenderEngineStopFlag()
-        exu.StopRenderer() #safely close rendering window!
-
-    if showAll:
-        input("Press Enter to start SolutionViewer...")
-    
-        from exudyn.interactive import SolutionViewer
-        mbs.SolutionViewer()
-
-        DemoInfo()
-
-    return [mbs, SC]
-
-
-#%%++++++++++++++++++++++++
-#testing of demos
-if __name__ == '__main__':
-    
-    Demo1()
-    input("Press Enter for Demo2 ...")
-    
-    Demo2()
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  The demos library includes basic demos which are available directly after installation;
+#           For advanced demos, see main/pythonDev/Examples and main/pythonDev/TestModels
+#
+# Authors:  Johannes Gerstmayr
+# Date:     2023-01-12
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+import exudyn as exu
+
+def DemoInfo():
+    print('\n************************************')
+    print('for advanced demos github page:')
+    print('https://github.com/jgerstmayr/EXUDYN')
+    print('look under main/pythonDev/Examples')
+    print('and main/pythonDev/TestModels')
+    print('************************************\n')
+    
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: very simple demo to show that exudyn is correctly installed; does not require graphics; similar to Examples/myFirstExample.py
+def Demo1(showAll = True):
+    if showAll:
+        print('start demo1: verify that exudyn is running')
+    import exudyn as exu               #EXUDYN package including C++ core part
+    import exudyn.itemInterface as eii #conversion of data to exudyn dictionaries
+    
+    SC = exu.SystemContainer()         #container of systems
+    mbs = SC.AddSystem()               #add a new system to work with
+    
+    nMP = mbs.AddNode(eii.NodePoint2D(referenceCoordinates=[0,0]))
+    mbs.AddObject(eii.ObjectMassPoint2D(physicsMass=10, nodeNumber=nMP ))
+    mMP = mbs.AddMarker(eii.MarkerNodePosition(nodeNumber = nMP))
+    mbs.AddLoad(eii.Force(markerNumber = mMP, loadVector=[0.001,0,0]))
+    
+    mbs.Assemble()                     #assemble system and solve
+    simulationSettings = exu.SimulationSettings()
+    simulationSettings.timeIntegration.verboseMode=1 #provide some output
+    simulationSettings.solutionSettings.coordinatesSolutionFileName = 'solution/demo1.txt'
+
+    mbs.SolveDynamic(simulationSettings)
+    if showAll:
+        print('results can be found in local directory: solution/demo1.txt')
+    
+        DemoInfo()
+    
+    return [mbs, SC]
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: advanced demo, showing that graphics is available; similar to Examples/rigid3Dexample.py
+def Demo2(showAll = True):
+    import exudyn as exu
+    import exudyn.itemInterface as eii #conversion of data to exudyn dictionaries
+    from exudyn.utilities import GraphicsDataCheckerBoard, eulerParameters0, GraphicsDataSphere, \
+                                 GraphicsDataOrthoCubePoint, AngularVelocity2EulerParameters_t, \
+                                     color4dodgerblue, color4darkgrey
+    
+    SC = exu.SystemContainer()
+    mbs = SC.AddSystem()
+    
+    if showAll:
+        print('EXUDYN version='+exu.GetVersionString())
+    
+    #%%+++++++++++++++++++++++++++++++++++
+    #background
+    color = [0.1,0.1,0.8,1]
+    zz = 2  #max size
+    s = 0.1 #size of cube
+    sx = 3*s #x-size
+    cPosZ = 0.1 #offset of constraint in z-direction, to get more arbitrary motion
+
+    background0 = GraphicsDataCheckerBoard(point=[0,-2*zz,-0.5*zz],size=8*zz, size2=6.4*zz, nTiles2=8)
+    oGround=mbs.AddObject(eii.ObjectGround(referencePosition= [0,0,0], 
+                                       visualization=eii.VObjectGround(graphicsData= [background0])))
+    mPosLast = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber = oGround, 
+                                                localPosition=[0,0,cPosZ]))
+    
+    #%%+++++++++++++++++++++++++++++++++++
+    #create a chain of 6 bodies:
+    for i in range(12):
+        #print("Build Object", i)
+        ep0 = eulerParameters0 #no rotation
+        p0 = [sx+i*2*sx,0.,0] #reference position
+    
+        nRB = mbs.AddNode(eii.NodeRigidBodyEP(referenceCoordinates=p0+ep0))
+        oGraphics = GraphicsDataOrthoCubePoint(size=[1.8*sx, 2*s, 2*s], color= color4dodgerblue, addEdges=True)
+        oGraphicsJoint = GraphicsDataSphere(point=[-sx,0,cPosZ], radius = 0.6*s, color=color4darkgrey, 
+                                            nTiles=24)
+        oRB = mbs.AddObject(eii.ObjectRigidBody(physicsMass=2, 
+                                            physicsInertia=[6,1,6,0,0,0], 
+                                            nodeNumber=nRB, 
+                                            visualization=eii.VObjectRigidBody(graphicsData=[oGraphics, oGraphicsJoint])))
+    
+        mMassRB = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber = oRB))
+        mbs.AddLoad(eii.Gravity(markerNumber = mMassRB, loadVector=[0.,-9.81,0.])) #gravity in negative z-direction
+    
+        mPos = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber = oRB, localPosition = [-sx,0.,cPosZ]))
+        mbs.AddObject(eii.SphericalJoint(markerNumbers = [mPosLast, mPos]))
+        mPosLast = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber = oRB, localPosition = [sx,0.,cPosZ]))
+    
+    #%%+++++++++++++++++++++++++++++++++++
+    mbs.Assemble()
+    # print(mbs)
+    
+    simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+    
+    fact = 2000*(1+9*showAll) #10000
+    simulationSettings.timeIntegration.numberOfSteps = 1*fact
+    simulationSettings.timeIntegration.endTime = 0.001*fact*0.5*4
+    simulationSettings.solutionSettings.solutionWritePeriod = simulationSettings.timeIntegration.endTime/fact*20
+    simulationSettings.solutionSettings.coordinatesSolutionFileName = 'solution/chain.txt'
+    simulationSettings.timeIntegration.verboseMode = 1
+    simulationSettings.linearSolverType = exu.LinearSolverType.EigenSparse
+
+    simulationSettings.timeIntegration.newton.useModifiedNewton = True
+    simulationSettings.timeIntegration.generalizedAlpha.spectralRadius = 0.6 #0.6 works well 
+    
+    SC.visualizationSettings.general.renderWindowString = "rigid body chain: press 'V' for drawing settings and 'Q' to stop"
+    SC.visualizationSettings.nodes.defaultSize = 0.05
+    SC.visualizationSettings.general.graphicsUpdateInterval = 0.02
+
+    SC.visualizationSettings.openGL.multiSampling = 4
+    SC.visualizationSettings.openGL.lineWidth = 2
+    
+    SC.visualizationSettings.openGL.shadow = 0.3
+    SC.visualizationSettings.openGL.light0position = [4,4,10,0]
+    
+    if showAll:
+        exu.StartRenderer()
+        mbs.WaitForUserToContinue()
+    
+    simulationSettings.timeIntegration.numberOfSteps = 1*fact
+    simulationSettings.timeIntegration.endTime = 0.001*fact*0.5*4
+    mbs.SolveDynamic(simulationSettings)
+    
+    if showAll:
+        SC.WaitForRenderEngineStopFlag()
+        exu.StopRenderer() #safely close rendering window!
+
+    if showAll:
+        input("Press Enter to start SolutionViewer...")
+    
+        from exudyn.interactive import SolutionViewer
+        mbs.SolutionViewer()
+
+        DemoInfo()
+
+    return [mbs, SC]
+
+
+#%%++++++++++++++++++++++++
+#testing of demos
+if __name__ == '__main__':
+    
+    Demo1()
+    input("Press Enter for Demo2 ...")
+    
+    Demo2()
```

## exudyn/graphicsDataUtilities.py

 * *Ordering differences only*

```diff
@@ -1,1937 +1,1937 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Utility functions for visualization, which provides functions for basic shapes
-#           like cube, cylinder, sphere, solid of revolution. Functions generate dictionaries
-#           which contain line, text or triangle primitives for drawing in Exudyn using OpenGL.
-#
-# Author:   Johannes Gerstmayr
-# Date:     2020-07-26 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-# Notes:    Some useful colors are defined, using RGBA (Red, Green, Blue and Alpha = opacity) channels
-#           in the range [0,1], e.g., red = [1,0,0,1].\\
-#           Available colors are: color4red, color4green, color4blue, color4cyan, color4magenta, color4yellow, color4orange, color4pink, color4lawngreen, color4violet, color4springgreen, color4dodgerblue, color4grey, color4darkgrey, color4lightgrey, color4lightred, color4lightgreen, color4steelblue, color4brown, color4black, color4darkgrey2, color4lightgrey2, color4white\\
-#           Additionally, a list of 16 colors 'color4list' is available, which is intended to be used, e.g., for creating n bodies with different colors
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import exudyn.basicUtilities as ebu
-from exudyn.rigidBodyUtilities import ComputeOrthonormalBasisVectors, HomogeneousTransformation, \
-                                      HT2rotationMatrix, HT2translation
-
-#constants and fixed structures:
-import numpy as np #LoadSolutionFile
-import copy as copy #to be able to copy e.g. lists
-from math import pi, sin, cos
-#import time        #AnimateSolution
-
-# color definitions
-color4red = [1.,0.,0.,1.]
-color4green = [0.,1.,0.,1.]
-color4blue = [0.,0.,1.,1.]
-
-color4cyan = [0.,1.,1.,1.]
-color4magenta = [1.,0.,1.,1.]
-color4yellow = [1.,1.,0.,1.]
-
-color4orange = [1.,0.5,0.,1.]
-color4pink = [1.,0.,0.5,1.]
-color4lawngreen = [0.5,1.,0.,1.]
-
-color4springgreen = [0.,1.,0.5,1.]
-color4violet = [0.5,0.,1.,1.]
-color4dodgerblue = [0.,0.5,1.,1.]
-
-
-color4lightred = [0.9,0.4,0.4,1.]
-color4lightgreen = [0.4,0.9,0.4,1.]
-color4steelblue = [0.4,0.4,0.9,1.]
-color4brown = [0.65,0.2,0.2,1.]
-
-color4black =      [0.,0.,0.,1.]
-color4darkgrey =   [0.2,0.2,0.2,1.]
-color4darkgrey2 =  [0.35,0.35,0.35,1.]
-color4grey =       [0.5,0.5,0.5,1.]
-color4lightgrey =  [0.7,0.7,0.7,1.]
-color4lightgrey2 = [0.85,0.85,0.85,1.]
-color4white =      [1.,1.,1.,1.]
-
-color4default =    [-1.,-1.,-1.,-1.] #indicates that default color is used
-
-#define a list of 16 colors for numbered colors
-color4list = [color4red, color4green, color4blue, 
-              color4cyan, color4magenta, color4yellow,
-              color4orange, color4pink, color4lawngreen,
-              color4violet, color4springgreen, color4dodgerblue,
-              color4grey, color4darkgrey, color4lightgrey,
-              #color4lightred, color4lightgreen, color4steelblue, 
-              color4brown]
-
-color4listSize = len(color4list) #maximum number of colors in color4list
-
-normalsFactor = 1. #this is a factor being either -1. [original normals pointing inside; until 2022-06-27], while +1. gives corrected normals pointing outside
-switchTriangleOrder = False #this is the old ordering of triangles in some Sphere or Cylinder functions, causing computed normals to point inside
-
-#**function: helper function to switch order of three items in a list; mostly used for reverting normals in triangles
-#**input: 3D vector as list or as np.array
-#**output: interchanged 2nd and 3rd component of list
-def SwitchTripletOrder(vector):
-    v=list(vector) #copy, such that vector is not changed
-    a = v[2]
-    v[2] = v[1]
-    v[1] = a
-    return v
-
-#**function: compute normalized normal for 3 triangle points
-#**input: 3D vector as list or as np.array
-#**output: normal as np.array
-def ComputeTriangleNormal(p0,p1,p2):
-    v0 = np.array(p1) - np.array(p0)
-    v1 = np.array(p2) - np.array(p0)
-    # print(v0,v1)
-    n = np.cross(v0,v1)
-    ln = np.linalg.norm(n)
-    if ln != 0.:
-        n /= ln
-    return n
-
-#**function: compute area of triangle given by 3 points
-#**input: 3D vector as list or as np.array
-#**output: area as float
-def ComputeTriangleArea(p0,p1,p2):
-    return 0.5*np.linalg.norm(np.cross(np.array(p1) - np.array(p0), np.array(p2) - np.array(p0)))
-
-#************************************************
-#**function: convert graphics data into list of points and list of triangle indices (triplets)
-#**input: g contains a GraphicsData with type TriangleList
-#**output: returns [points, triangles], with points as list of np.array with 3 floats per point and triangles as a list of np.array with 3 int per triangle (0-based indices to points)
-def GraphicsData2PointsAndTrigs(g):
-    if g['type'] == 'TriangleList':
-        nPoints=int(len(g['points'])/3)
-        points = [np.zeros(3)]*nPoints
-        for i in range(nPoints):
-            points[i] = np.array(g['points'][i*3:i*3+3])
-        
-        nTrigs=int(len(g['triangles'])/3)
-        triangles = [np.zeros(3, dtype=int)]*nTrigs
-        for i in range(nTrigs):
-            triangles[i] = np.array(g['triangles'][i*3:i*3+3], dtype=int)
-    else:
-        raise ValueError ('ERROR: GraphicsData2TrigsAndPoints(...) only takes GraphicsData of type TriangleList but found: '+
-                          g['type'] )
-
-    return [points, triangles]
-
-#**function: convert triangles and points as returned from GraphicsData2TrigsAndPoints(...) 
-#**input: 
-#  points: list of np.array with 3 floats per point 
-#  triangles: list of np.array with 3 int per triangle (0-based indices to triangles)
-#  color: provided as list of 4 RGBA values or single list of (number of points)*[4 RGBA values]
-#**output: returns GraphicsData with type TriangleList
-def GraphicsDataFromPointsAndTrigs(points, triangles, color=[0.,0.,0.,1.]):
-    pointList = list(np.array(points).flatten())
-    triangleList = list(np.array(triangles).flatten())
-    nPoints = int(len(pointList)/3)
-    if len(color) == 4*nPoints:
-        colorList = list(color) #without list() potential problem with mutable default value
-    elif len(color) == 4:
-        colorList = list(color)*nPoints
-    else:
-        print('number of points=', nPoints)
-        print('number of trigs=', len(triangleList)/3)
-        print('number of colors=', len(color))
-        raise ValueError('GraphicsDataFromPointsAndTrigs: color must have either 4 RGBA values or 4*(number of points) RGBA values as a list')
-    data = {'type':'TriangleList', 
-            'colors': colorList, 
-            'points':pointList, 
-            'triangles':triangleList}
-    return data
-
-#************************************************
-#**function: refine triangle mesh; every triangle is subdivided into 4 triangles
-#**input:
-#  points: list of np.array with 3 floats per point 
-#  triangles: list of np.array with 3 int per triangle (0-based indices to triangles)
-#**output: returns [points2, triangles2] containing the refined mesh; if the original mesh is consistent, no points are duplicated; if the mesh is not consistent, some mesh points are duplicated!
-#**notes: becomes slow for meshes with more than 5000 points
-def RefineMesh(points, triangles):
-    # 2
-    # |\
-    # a c
-    # |  \
-    # 0-b-1
-    points2 = copy.deepcopy(points)
-    triangles2 = []
-    
-    #build point2trig list for efficiency, at most, per triangle 3 new points:
-    trigsPerPoint = [ [] for _ in range(len(points) + len(triangles)*3) ]
-    # for (ti, trig) in enumerate(triangles):
-    #     for i in trig:
-    #         trigsPerPoint[i] += [ti]
-
-    #print(trigsPerPoint)
-    pnew = [0,0,0] #a,b,c
-    for (ti, trig) in enumerate(triangles):
-        # print('process trig', ti)
-        for j in range(3):
-            pointNew = 0.5*(np.array(points[trig[j]])+np.array(points[trig[j-1]]))
-            found = -1
-            #search all points (SLOW):
-            # for (i, p) in enumerate(points2):
-            #     if np.linalg.norm(pointNew-p) <= 1e-12:
-            #         found = i
-            #go through all triangles at one point, if new (refined) trig exists, it contains the new point:
-            for (i, ti2) in enumerate(trigsPerPoint[trig[j]]):
-                # print('  i, ti2=', i, ti2)
-                for pointIndex in triangles2[ti2]:
-                    if np.linalg.norm(pointNew-points2[pointIndex]) <= 1e-12:
-                        found = pointIndex
-
-            if found==-1:
-                pnew[j] = len(points2)
-                # print('add new point ', pnew[j])
-                points2 += [pointNew]
-            else:
-                pnew[j] = found
-        toff = len(triangles2)
-        triangles2 += [np.array([trig[0],pnew[1],pnew[0]],dtype=int)]
-        triangles2 += [np.array([trig[1],pnew[2],pnew[1]],dtype=int)]
-        triangles2 += [np.array([trig[2],pnew[0],pnew[2]],dtype=int)]
-        triangles2 += [np.array([pnew[0],pnew[1],pnew[2]],dtype=int)]
-        #add new triangles to trigsPerPoint:
-        for (ti, trig) in enumerate(triangles2[-4:]):
-            for i in trig:
-                trigsPerPoint[i] += [toff+ti]
-    # print('trigs per point=',trigsPerPoint)
-    return [points2, triangles2]
-
-#************************************************
-#**function: shrink mesh using triangle normals; every point is at least moved a distance 'distance' normal from boundary
-#**input:
-#  points: list of np.array with 3 floats per point 
-#  triangles: list of np.array with 3 int per triangle (0-based indices to triangles)
-#  distance: float value of minimum distance
-#**output: returns [points2, triangles2] containing the refined mesh; currently the points of the subdivided triangles are duplicated!
-#**notes: ONLY works for consistent meshes (no duplicated points!)
-def ShrinkMeshNormalToSurface(points, triangles, distance):
-    points2 = copy.deepcopy(points)
-    triangles2 = copy.deepcopy(triangles)
-    #disp = [np.zeros(3).copy()]*len(points2) #copy, otherwise linked!!!
-    disp = copy.deepcopy(points)
-    for i in range(len(points2)):
-        disp[i] *= 0.
-    
-    for trig in triangles:
-        n = ComputeTriangleNormal(points[trig[0]],points[trig[1]],points[trig[2]])
-        # print(n)
-        for i in range(3):
-            dn = -distance*n
-            # print('move',trig[i],'=',dn, ', disp=',disp[trig[i]])
-            for j in range(3):
-                if abs(dn[j]) > abs(disp[trig[i]][j]):
-                    disp[trig[i]][j] = dn[j]
-                    # print('==>disp',trig[i],'=',disp[trig[i]])
-
-    # print('disp=', disp)
-
-    for i in range(len(points2)):
-        points2[i] += disp[i]
-
-    return [points2, triangles2]
-
-
-#************************************************
-#**function: add rigid body transformation to GraphicsData, using position offset (global) pOff (list or np.array) and rotation Aoff (transforms local to global coordinates; list of lists or np.array); see Aoff how to scale coordinates!
-#**input:
-#  g: graphicsData to be transformed
-#  pOff: 3D offset as list or numpy.array added to rotated points
-#  Aoff: 3D rotation matrix as list of lists or numpy.array with shape (3,3); if A is scaled by factor, e.g. using 0.001*np.eye(3), you can also scale the coordinates!!!
-#**output: returns new graphcsData object to be used for drawing in objects
-#**notes: transformation corresponds to HomogeneousTransformation(Aoff, pOff), transforming original coordinates v into vNew = pOff + Aoff @ v
-def MoveGraphicsData(g, pOff, Aoff):
-    p0 = np.array(pOff)
-    A0 = np.array(Aoff)
-    
-    if g['type'] == 'TriangleList': 
-        gNew = {'type':'TriangleList'}
-        gNew['colors'] = copy.copy(g['colors'])
-        gNew['triangles'] = copy.copy(g['triangles'])
-        if 'edges' in g:
-            gNew['edges'] = copy.copy(g['edges'])
-        if 'edgeColor' in g:
-            gNew['edgeColor'] = copy.copy(g['edgeColor'])
-
-        n=int(len(g['points'])/3)
-        v0 = np.array(g['points'])
-        v = np.kron(np.ones(n),p0) + (A0 @ v0.reshape((n,3)).T).T.flatten()
-        
-        gNew['points'] = list(v)
-        if 'normals' in g:
-            n0 = np.array(g['normals'])
-            gNew['normals'] = list((A0 @ n0.reshape((n,3)).T).T.flatten() )
-        
-        # #original, slow:
-        # for i in range(n):
-        #     v = gNew['points'][i*3:i*3+3]
-        #     v = p0 + A0 @ v
-        #     gNew['points'][i*3:i*3+3] = list(v)
-        # if 'normals' in gNew:
-        #     n=int(len(g['normals'])/3)
-        #     for i in range(n):
-        #         v = gNew['normals'][i*3:i*3+3]
-        #         v = A0 @ v
-        #         gNew['normals'][i*3:i*3+3] = list(v)
-    elif g['type'] == 'Line':
-        gNew = copy.deepcopy(g)
-        n=int(len(g['data'])/3)
-        for i in range(n):
-            v = gNew['data'][i*3:i*3+3]
-            v = p0 + A0 @ v
-            gNew['data'][i*3:i*3+3] = list(v)
-    elif g['type'] == 'Text':
-        gNew = copy.deepcopy(g)
-        v = p0 + A0 @ gNew['position']
-        gNew['position'] = list(v)
-    elif g['type'] == 'Circle':
-        gNew = copy.deepcopy(g)
-        v = p0 + A0 @ gNew['position']
-        gNew['position'] = list(v)
-        if 'normal' in gNew:
-            v = A0 @ gNew['normal']
-            gNew['normal'] = list(v)
-    else:
-        raise ValueError('MoveGraphicsData: unsupported graphics data type')
-    return gNew
-
-#************************************************
-#**function: merge 2 different graphics data with triangle lists
-#**input: graphicsData dictionaries g1 and g2 obtained from GraphicsData functions
-#**output: one graphicsData dictionary with single triangle lists and compatible points and normals, to be used in visualization of EXUDYN objects; edges are merged; edgeColor is taken from graphicsData g1
-def MergeGraphicsDataTriangleList(g1,g2):
-    np = int(len(g1['points'])/3) #number of points
-    useNormals = False
-    if 'normals' in g1 and 'normals' in g2:
-        useNormals = True
-
-    if np*4 != len(g1['colors']):
-        raise ValueError('MergeGraphicsDataTriangleList: incompatible colors and points in lists')
-
-    if useNormals:
-        if np*3 != len(g1['normals']):
-            raise ValueError('MergeGraphicsDataTriangleList: incompatible normals and points in lists')
-        data = {'type':'TriangleList', 'colors':copy.copy(g1['colors']), 'normals':copy.copy(g1['normals']), 
-                'points': copy.copy(g1['points']), 'triangles': copy.copy(g1['triangles'])}
-
-        data['normals'] += g2['normals']
-    else:
-        data = {'type':'TriangleList', 'colors':copy.copy(g1['colors']),
-                'points': copy.copy(g1['points']), 'triangles': copy.copy(g1['triangles'])}
-    
-    data['colors'] += g2['colors']
-    data['points'] += g2['points']
-
-    #copy and merge edges; edges can be available only in one triangle list
-    if 'edges' in g1:
-        data['edges'] = copy.copy(g1['edges'])
-    if 'edges' in g2:
-        edges2 = copy.copy(g2['edges'])
-        if 'edges' not in data:
-            data['edges'] = []
-        else:
-            for i in range(len(edges2)):
-                edges2[i] += np #add point offset
-        
-        data['edges'] += edges2
-    if 'edgeColor' in g1:
-        data['edgeColor'] = copy.copy(g1['edgeColor']) #only taken from g1
-    elif 'edgeColor' in g2:
-        data['edgeColor'] = copy.copy(g2['edgeColor']) #only taken from g1
-
-    for p in g2['triangles']:
-        data['triangles'] += [int(p + np)] #add point offset for correct connectivity
-
-    return data
-
-
-#************************************************
-#**function: generate graphics data for lines, given by list of points and color; transforms to GraphicsData dictionary
-#**input: 
-#  pList: list of 3D numpy arrays or lists (to achieve closed curve, set last point equal to first point)
-#  color: provided as list of 4 RGBA values
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-#**example:
-##create simple 3-point lines
-#gLine=GraphicsDataLine([[0,0,0],[1,0,0],[2,0.5,0]], color=color4red)
-def GraphicsDataLine(pList, color=[0.,0.,0.,1.]): 
-    data = [0]*(len(pList)*3)
-    for i, p in enumerate(pList):
-        data[i*3:i*3+3] = list(p)
-    dataRect = {'type':'Line', 'color': list(color), 'data':data}
-
-    return dataRect
-
-#************************************************
-#**function: generate graphics data for a single circle; currently the plane normal = [0,0,1], just allowing to draw planar circles -- this may be extended in future!
-#**input: 
-#  point: center point of circle
-#  radius: radius of circle
-#  color: provided as list of 4 RGBA values
-#**notes: the tiling (number of segments to draw circle) can be adjusted by visualizationSettings.general.circleTiling
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataCircle(point=[0,0,0], radius=1, color=[0.,0.,0.,1.]): 
-    return {'type':'Circle', 'color': list(color), 'radius': radius, 'position':list(point)}
-
-#************************************************
-#**function: generate graphics data for a text drawn at a 3D position
-#**input: 
-#  point: position of text
-#  text: string representing text
-#  color: provided as list of 4 RGBA values
-#**nodes: text size can be adjusted with visualizationSettings.general.textSize, which affects the text size (=font size) globally
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataText(point=[0,0,0], text='', color=[0.,0.,0.,1.]): 
-    return {'type':'Text', 'color': list(color), 'text':text, 'position':list(point)}
-
-#************************************************
-#**function: generate graphics data for 2D rectangle
-#**input: minimal and maximal cartesian coordinates in (x/y) plane; color provided as list of 4 RGBA values
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataRectangle(xMin, yMin, xMax, yMax, color=[0.,0.,0.,1.]): 
-
-    rect = [xMin, yMin,xMax,yMax]
-    dataRect = {'type':'Line', 'color': list(color), 'data':[rect[0],rect[1],0, rect[2],rect[1],0, rect[2],rect[3],0, rect[0],rect[3],0, rect[0],rect[1],0]}
-
-    return dataRect
-
-#************************************************
-#**function: generate graphics data for orthogonal block drawn with lines
-#**input: minimal and maximal cartesian coordinates for orthogonal cube; color provided as list of 4 RGBA values
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataOrthoCubeLines(xMin, yMin, zMin, xMax, yMax, zMax, color=[0.,0.,0.,1.]): 
-
-    dataRect = {'type':'Line', 'color': list(color), 'data':[xMin,yMin,zMin, xMin,yMax,zMin, xMin,yMin,zMin, xMax,yMin,zMin, xMax,yMax,zMin, xMax,yMin,zMin, 
-                                                       xMax,yMin,zMax, xMax,yMax,zMax, xMax,yMin,zMax, xMin,yMin,zMax, xMin,yMax,zMax, xMin,yMin,zMax, 
-                                                       xMin,yMin,zMin, xMin,yMax,zMin, xMax,yMax,zMin, xMax,yMax,zMax, xMin,yMax,zMax, xMin,yMax,zMin]}
-
-    return dataRect
-
-#**function: generate graphics data for orthogonal 3D block with min and max dimensions
-#**input: 
-#  x/y/z/Min/Max: minimal and maximal cartesian coordinates for orthogonal cube
-#  color: list of 4 RGBA values
-#  addNormals: add face normals to triangle information
-#  addEdges: if True, edges are added in TriangleList of GraphicsData 
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataOrthoCube(xMin, yMin, zMin, xMax, yMax, zMax, color=[0.,0.,0.,1.], addNormals=False, addEdges=False, edgeColor=color4black, addFaces=True): 
-    
-    pList = [[xMin,yMin,zMin], [xMax,yMin,zMin], [xMax,yMax,zMin], [xMin,yMax,zMin],
-             [xMin,yMin,zMax], [xMax,yMin,zMax], [xMax,yMax,zMax], [xMin,yMax,zMax]]
-    return GraphicsDataCube(pList, list(color), addNormals=addNormals, addEdges=addEdges, edgeColor=edgeColor, addFaces=addFaces)
-
-#**function: generate graphics data forfor orthogonal 3D block with center point and size
-#**input: 
-#  centerPoint: center of cube as 3D list or np.array
-#  size: size as 3D list or np.array
-#  color: list of 4 RGBA values
-#  addNormals: add face normals to triangle information
-#  addEdges: if True, edges are added in TriangleList of GraphicsData 
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects; if addEdges=True, it returns a list of two dictionaries
-def GraphicsDataOrthoCubePoint(centerPoint=[0,0,0], size=[0.1,0.1,0.1], color=[0.,0.,0.,1.], addNormals=False, addEdges=False, edgeColor=color4black, addFaces=True): 
-    
-    xMin = centerPoint[0] - 0.5*size[0]
-    yMin = centerPoint[1] - 0.5*size[1]
-    zMin = centerPoint[2] - 0.5*size[2]
-    xMax = centerPoint[0] + 0.5*size[0]
-    yMax = centerPoint[1] + 0.5*size[1]
-    zMax = centerPoint[2] + 0.5*size[2]
-
-    gCube = GraphicsDataOrthoCube(xMin, yMin, zMin, xMax, yMax, zMax, color, 
-                                  addNormals=addNormals, addEdges=addEdges, edgeColor=edgeColor, addFaces=addFaces)
-    if addEdges:
-        gCube['edgeColor'] = list(edgeColor)
-        gCube['edges'] = [0,1, 1,2, 2,3, 3,0,  0,4, 1,5, 2,6, 3,7,  4,5, 5,6, 6,7, 7,4]
-        #print('new2')
-    return gCube
-
-#**function: generate graphics data for general block with endpoints, according to given vertex definition
-#**input: 
-#  pList: is a list of points [[x0,y0,z0],[x1,y1,z1],...]
-#  color: provided as list of 4 RGBA values
-#  faces: includes the list of six binary values (0/1), denoting active faces (value=1); set index to zero to hide face
-#  addNormals: if True, normals are added and there are separate points for every triangle
-#  addEdges: if True, edges are added in TriangleList of GraphicsData 
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataCube(pList, color=[0.,0.,0.,1.], faces=[1,1,1,1,1,1], addNormals=False, addEdges=False, edgeColor=color4black, addFaces=True): 
-# bottom: (z goes upwards from node 0 to node 4)
-# ^y
-# |
-# 3---2
-# |   |
-# |   |
-# 0---1-->x
-#
-# top:
-# ^y
-# |
-# 7---6
-# |   |
-# |   |
-# 4---5-->x
-#
-# faces: bottom, top, sideface0, sideface1, sideface2, sideface3 (sideface0 has nodes 0,1,4,5)
-
-    colors=[]
-    for i in range(8):
-        colors=colors+color
-
-    points = []
-    for p in pList:
-        points += p
-#    points = [xMin,yMin,zMin, xMax,yMin,zMin, xMax,yMax,zMin, xMin,yMax,zMin,
-#              xMin,yMin,zMax, xMax,yMin,zMax, xMax,yMax,zMax, xMin,yMax,zMax]
-
-    #1-based ... triangles = [1,3,2, 1,4,3, 5,6,7, 5,7,8, 1,2,5, 2,6,5, 2,3,6, 3,7,6, 3,4,7, 4,8,7, 4,1,8, 1,5,8 ]
-    #triangles = [0,2,1, 0,3,2, 6,4,5, 6,7,4, 0,1,4, 1,5,4, 1,2,5, 2,6,5, 2,3,6, 3,7,6, 3,0,7, 0,4,7]
-
-    trigList = [[0,2,1], [0,3,2], #
-                [6,4,5], [6,7,4], #
-                [0,1,4], [1,5,4], #
-                [1,2,5], [2,6,5], #
-                [2,3,6], [3,7,6], #
-                [3,0,7], [0,4,7]] #
-    triangles = []
-    # print('addNormals=',addNormals)
-    if not addNormals:
-        for i in range(6):
-            if faces[i]:
-                for j in range(2):
-                    if addFaces:
-                        triangles += trigList[i*2+j]
-        data = {'type':'TriangleList', 'colors': colors, 'points':points, 'triangles':triangles}
-    else:
-        normals = []
-        points2 = []
-        
-        cnt = 0
-        for i in range(6):
-            if faces[i]:
-                for j in range(2):
-                    trig = trigList[i*2+j]
-                    normal = ComputeTriangleNormal(pList[trig[0]],pList[trig[1]],pList[trig[2]])
-                    normals+=list(normal)*3 #add normal for every point
-                    for k in range(3):
-                        if addFaces:
-                            triangles += [cnt] #new point for every triangle
-                        points2 += list(pList[trig[k]])
-                        cnt+=1
-        
-        data = {'type':'TriangleList', 'colors': color*cnt, 'normals':normals, 'points':points2, 'triangles':triangles}
-
-    if addEdges:
-        edges = [0,1, 1,2, 2,3, 3,0,
-                 4,5, 5,6, 6,7, 7,4,
-                 0,4, 1,5, 2,6, 3,7 ]
-        
-        data['edges'] = edges
-        data['edgeColor'] = list(edgeColor)
-        
-    return data
-
-#**function: generate graphics data for a sphere with point p and radius
-#**input:
-#  point: center of sphere (3D list or np.array)
-#  radius: positive value
-#  color: provided as list of 4 RGBA values
-#  nTiles: used to determine resolution of sphere >=3; use larger values for finer resolution
-#  addEdges: True or number of edges along sphere shell (under development); for optimal drawing, nTiles shall be multiple of 4 or 8
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataSphere(point=[0,0,0], radius=0.1, color=[0.,0.,0.,1.], nTiles = 8, 
-                       addEdges = False, edgeColor=color4black, addFaces=True):
-    if nTiles < 3: print("WARNING: GraphicsDataSphere: nTiles < 3: set nTiles=3")
-    
-    p = np.array(point)
-    r = radius
-    #orthonormal basis:
-    e0=np.array([1,0,0])
-    e1=np.array([0,1,0])
-    e2=np.array([0,0,1])
-
-    points = []
-    normals = []
-    colors = []
-    triangles = []
-    
-    #create points for circles around z-axis with tiling
-    for i0 in range(nTiles+1):
-        for iphi in range(nTiles):
-            z = -r*cos(pi*i0/nTiles)    #runs from -r .. r (this is the coordinate of the axis of circles)
-            phi = 2*pi*iphi/nTiles #angle
-            fact = sin(pi*i0/nTiles)
-
-            x = fact*r*sin(phi)
-            y = fact*r*cos(phi)
-
-            vv = x*e0 + y*e1 + z*e2
-            points += list(p + vv)
-            
-            n = ebu.Normalize(vv) #2022-06-27: corrected to (vv) to point outwards
-            #print(n)
-            normals += n
-            
-            colors += color
-
-    
-    if addFaces:
-        for i0 in range(nTiles):
-            for iphi in range(nTiles):
-                p0 = i0*nTiles+iphi
-                p1 = (i0+1)*nTiles+iphi
-                iphi1 = iphi + 1
-                if iphi1 >= nTiles: 
-                    iphi1 = 0
-                p2 = i0*nTiles+iphi1
-                p3 = (i0+1)*nTiles+iphi1
-    
-                if switchTriangleOrder:
-                    triangles += [p0,p3,p1, p0,p2,p3]
-                else:
-                    triangles += [p0,p1,p3, p0,p3,p2]
-            
-    data = {'type':'TriangleList', 'colors':colors, 
-            'normals':normals, 
-            'points':points, 
-            'triangles':triangles}
-    
-    if type(addEdges) == bool and addEdges == True:
-        addEdges = 3
-
-    if addEdges > 0:
-        data['edgeColor'] = list(edgeColor)
-
-        edges = []
-        hEdges = [] #edges at half of iphi
-        nt = 2
-        if addEdges > 1:
-            nt = 4
-        if addEdges > 3:
-            nt = 8
-        for j in range(nt):
-            hEdges += [[]]
-        hTiles = int(nTiles/nt)
-        # hLast = [None]*nt
-        # hFirst = [None]*nt
-        sTiles = max(addEdges-1,1) #non-negative
-        nStep = int(nTiles/sTiles)
-        
-        for i0 in range(nTiles):
-            for iphi in range(nTiles):
-                p0 = i0*nTiles+iphi
-                p1 = (i0+1)*nTiles+iphi
-                if i0%nStep == 0:
-                    iphi1 = iphi + 1
-                    if iphi1 >= nTiles: 
-                        iphi1 = 0
-                    p2 = i0*nTiles+iphi1
-                    if addEdges>1:
-                        edges += [p0, p2]
-                if hTiles != 0:
-                    if iphi%hTiles == 0:
-                        j = int(iphi/hTiles)
-                        if j < nt:
-                            hEdges[j] += [p0,p1]
-                            # if hLast[j] == None:
-                            #     hLast[j] = p0
-                            #     hFirst[j] = p0
-                            # else:
-                            #     hEdges[j] += [hLast[j], p0]
-                            #     hLast[j] = p0
-        
-        for j in range(nt):
-            #print('j=',j, hEdges[j], ', hFirst=',hFirst)
-            if nt%2 == 0: #close edges only for even nt
-                hEdges[j] += [hEdges[j][-1], hEdges[(j+int(nt/2))%nt][-1]]
-                
-            edges += hEdges[j]
-
-        data['edges'] = edges
-    
-    return data
-            
-#**function: generate graphics data for a cylinder with given axis, radius and color; nTiles gives the number of tiles (minimum=3)
-#**input:
-#  pAxis: axis point of one face of cylinder (3D list or np.array)
-#  vAxis: vector representing the cylinder's axis (3D list or np.array)
-#  radius: positive value representing radius of cylinder
-#  color: provided as list of 4 RGBA values
-#  nTiles: used to determine resolution of cylinder >=3; use larger values for finer resolution
-#  angleRange: given in rad, to draw only part of cylinder (halfcylinder, etc.); for full range use [0..2 * pi]
-#  lastFace: if angleRange != [0,2*pi], then the faces of the open cylinder are shown with lastFace = True
-#  cutPlain: only used for angleRange != [0,2*pi]; if True, a plane is cut through the part of the cylinder; if False, the cylinder becomes a cake shape ...
-#  addEdges: if True, edges are added in TriangleList of GraphicsData; if addEdges is integer, additional int(addEdges) lines are added on the cylinder mantle
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#  alternatingColor: if given, optionally another color in order to see rotation of solid; only works, if angleRange=[0,2*pi]
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataCylinder(pAxis=[0,0,0], vAxis=[0,0,1], radius=0.1, color=[0.,0.,0.,1.], nTiles = 16, 
-                         angleRange=[0,2*pi], lastFace = True, cutPlain = True, 
-                         addEdges=False, edgeColor=color4black,
-                         addFaces=True, **kwargs):  
-
-    if nTiles < 3: print("WARNING: GraphicsDataCylinder: nTiles < 3: set nTiles=3")
-    
-    #create points at left and right face
-    points0=list(pAxis) #[pAxis[0],pAxis[1],pAxis[2]] #avoid change of pAxis
-    pAxis1=[pAxis[0]+vAxis[0],pAxis[1]+vAxis[1],pAxis[2]+vAxis[2]]
-    points1=list(pAxis1) #[pAxis[0]+vAxis[0],pAxis[1]+vAxis[1],pAxis[2]+vAxis[2]] #copy in order to avoid change of pAxis1 for use lateron
-    
-    p0 = np.array(pAxis)
-    p1 = np.array(pAxis) + np.array(vAxis)
-    
-    basis = ComputeOrthonormalBasisVectors(vAxis)
-    #v0 = basis[0]
-    n1 = basis[1]
-    n2 = basis[2]
-    r=radius
-    
-    nf = normalsFactor #-1 original; -1 points inside
-
-    #create normals at left and right face (pointing inwards)
-    normals0 = ebu.Normalize([-vAxis[0],-vAxis[1],-vAxis[2]])
-    normals1 = ebu.Normalize(vAxis)
-
-    points2 = []
-    points3 = []
-    
-    alpha = angleRange[1]-angleRange[0] #angular range
-    alpha0 = angleRange[0]
-
-    fact = nTiles #create correct part of cylinder
-    if alpha < 2.*pi: 
-        fact = nTiles-1
-
-    # pointsCyl0 = []
-    # pointsCyl1 = []
-    
-    for i in range(nTiles):
-        phi = alpha0 + i*alpha/fact
-        x = r*sin(phi)
-        y = r*cos(phi)
-        vv = x*n1 + y*n2
-        pz0 = p0 + vv
-        pz1 = p1 + vv
-        points0 += list(pz0)
-        points1 += list(pz1)
-        points2 += list(pz0) #other points for side faces (different normals)
-        points3 += list(pz1) #other points for side faces (different normals)
-        # pointsCyl0 += list(pz0) #for edges
-        # pointsCyl1 += list(pz1) #for edges
-        n = ebu.Normalize(list(nf*vv))
-        normals0 = normals0 + n
-        normals1 = normals1 + n
-        
-    
-    points0 += points1+points2+points3
-    normals0 += normals1
-
-    for i in range(nTiles):
-        normals0 += ebu.Normalize([-nf*vAxis[0],-nf*vAxis[1],-nf*vAxis[2]])
-    for i in range(nTiles):
-        normals0 += ebu.Normalize([nf*vAxis[0],nf*vAxis[1],nf*vAxis[2]])
-
-    n = nTiles+1 #number of points of one ring+midpoint
-    color2 = list(color) #alternating color
-    if 'alternatingColor' in kwargs:
-        color2 = kwargs['alternatingColor']
-
-    colors=[]
-    #for i in range(2*n+2*nTiles):
-    #    colors += color
-    n2 = int(nTiles/2)    
-    for i in range(2):
-        colors += color
-    for j in range(4):
-        for i in range(n2):
-            colors += color
-        for i in range(nTiles-n2):
-            colors += color2
-
-    triangles = []
-    #circumference:
-    for i in range(nTiles):
-        if switchTriangleOrder:
-            if i != nTiles-1:
-                triangles += [1+i,n+1+i+1,n+1+i]
-                triangles += [1+i,1+i+1,n+1+i+1]
-            else:
-                if lastFace and cutPlain:
-                    triangles += [1+i,n+1,n+1+i]
-                    triangles += [1+i,1,n+1]
-        else:
-            if i != nTiles-1:
-                triangles += [1+i,n+1+i,n+1+i+1]
-                triangles += [1+i,n+1+i+1,1+i+1]
-            else:
-                if lastFace and cutPlain:
-                    triangles += [1+i,n+1+i,n+1]
-                    triangles += [1+i,n+1,1]
-            
-    #sides faces left and right:
-    nn=2*n #offset
-    for i in range(nTiles):
-        if switchTriangleOrder:
-            if i != nTiles-1:
-                triangles += [0,nn+i,nn+i+1]
-                triangles += [n,nn+nTiles+i+1,nn+nTiles+i]
-            else:
-                if cutPlain:
-                    triangles += [0,nn+i,nn]
-                    triangles += [n,nn+nTiles,nn+nTiles+i]
-        else:
-            if i != nTiles-1:
-                triangles += [0,nn+i,nn+i+1]
-                triangles += [n,nn+nTiles+i+1,nn+nTiles+i]
-            else:
-                if cutPlain:
-                    triangles += [0,nn+i,nn]
-                    triangles += [n,nn+nTiles,nn+nTiles+i]
-
-    #if angles are not 2*pi, add closing face
-    if lastFace and not(cutPlain):
-        s = int(len(points0)/3) #starting index for side triangles
-        p2 = points2[0:3]
-        p3 = points3[0:3]
-        p4 = points2[len(points2)-3:len(points2)]
-        p5 = points3[len(points3)-3:len(points3)]
-        points0 += pAxis + pAxis1 + p2 + p3 + pAxis + pAxis1 + p4 + p5
-        n1=np.cross(ebu.VSub(pAxis,pAxis1),ebu.VSub(p3,pAxis))
-        n1=list(ebu.Normalize(-nf*n1))
-        n2=np.cross(ebu.VSub(pAxis1,pAxis),ebu.VSub(p4,pAxis))
-        n2=list(ebu.Normalize(-nf*n2))
-        normals0 += n1+n1+n1+n1+n2+n2+n2+n2  #8 additional normals
-        if switchTriangleOrder:
-            triangles += [s+0,s+3,s+1, s+0,s+2,s+3, 
-                          s+5,s+6,s+4, s+5,s+7,s+6]
-        else:
-            triangles += [s+0,s+1,s+3, s+0,s+3,s+2, 
-                          s+5,s+4,s+6, s+5,s+6,s+7]
-            
-        for i in range(8): #8 additional colors
-            colors += color
-
-    # print('points len=', len(points0))
-    # print('normals len=', len(normals0))
-    if not addFaces:
-        triangles = []
-
-    #triangle normals point inwards to object ...
-    data = {'type':'TriangleList', 'colors':colors, 
-            'normals':normals0, 
-            'points':points0, 'triangles':triangles}
-
-    if addEdges:
-        data['edgeColor'] = list(edgeColor)
-        
-        faceEdges = 0
-        if type(addEdges) != bool:
-            faceEdges = int(addEdges)
-        
-        edges = []
-        pLast = nTiles
-        for i in range(nTiles):
-            edges += [pLast, i+1]
-            pLast = i+1
-        
-        pLast = nTiles + (nTiles+1)
-        for i in range(nTiles):
-            edges += [pLast, i+1+(nTiles+1)]
-            pLast = i+1+(nTiles+1)
-        
-        if faceEdges > 0:
-            nStep = int(nTiles/faceEdges)
-            pLast0 = 1
-            pLast1 = 1+(nTiles+1)
-            for i in range(faceEdges):
-                edges += [pLast0, pLast1]
-                pLast0 += nStep
-                pLast1 += nStep
-        
-        data['edges'] = edges
-
-    return data
-
-#**function: generate graphics data for a planar Link between the two joint positions, having two axes
-#**input:
-#  p0: joint0 center position
-#  p1: joint1 center position
-#  axis0: direction of rotation axis at p0, if drawn as a cylinder; [0,0,0] otherwise
-#  axis1: direction of rotation axis of p1, if drawn as a cylinder; [0,0,0] otherwise
-#  radius: list of two radii [radius0, radius1], being the two radii of the joints drawn by a cylinder or sphere    
-#  width: list of two widths [width0, width1], being the two widths of the joints drawn by a cylinder; ignored for sphere    
-#  thickness: the thickness of the link (shaft) between the two joint positions; thickness in z-direction or diameter (cylinder)
-#  color: provided as list of 4 RGBA values
-#  nTiles: used to determine resolution of cylinder >=3; use larger values for finer resolution
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataRigidLink(p0,p1,axis0=[0,0,0], axis1=[0,0,0], radius=[0.1,0.1], 
-                          thickness=0.05, width=[0.05,0.05], color=[0.,0.,0.,1.], nTiles = 16):
-    linkAxis = ebu.VSub(p1,p0)
-    #linkAxis0 = ebu.Normalize(linkAxis)
-    a0=list(axis0)
-    a1=list(axis1)
-    
-    data0 = GraphicsDataCylinder(p0, linkAxis, 0.5*thickness, color, nTiles)
-    data1 = {}
-    data2 = {}
-
-    if ebu.NormL2(axis0) == 0:
-        data1 = GraphicsDataSphere(p0, radius[0], color, nTiles)
-    else:
-        a0=ebu.Normalize(a0)
-        data1 = GraphicsDataCylinder(list(np.array(p0)-0.5*width[0]*np.array(a0)), 
-                                     list(width[0]*np.array(a0)), 
-                                     radius[0], color, nTiles)
-        
-    if ebu.NormL2(axis1) == 0:
-        data2 = GraphicsDataSphere(p1, radius[1], color, nTiles)
-    else:
-        a1=ebu.Normalize(a1)
-        data2 = GraphicsDataCylinder(list(np.array(p1)-0.5*width[1]*np.array(a1)), 
-                                     list(width[1]*np.array(a1)), radius[1], color, nTiles)
-
-    #now merge lists, including appropriate indices of triangle points!
-    np0 = int(len(data0['points'])/3) #number of points of first point list ==> this is the offset for next list
-    np1 = np0 + int(len(data1['points'])/3) #number of points of first point list ==> this is the offset for next list
-
-    triangles = data0['triangles']
-    trigs1 = np.array(data1['triangles'])
-    trigs1 += np0
-    triangles += list(trigs1)
-    
-    trigs2 = np.array(data2['triangles'])
-    trigs2 += np1
-    triangles += list(trigs2)
-    
-    points = data0['points'] + data1['points'] + data2['points']
-    normals = data0['normals'] + data1['normals'] + data2['normals']
-    colors = data0['colors'] + data1['colors'] + data2['colors']
-    
-    data = {'type':'TriangleList', 'colors':colors, 
-            'normals':normals, 
-            'points':points, 'triangles':triangles}
-    return data
-
-
-#**function: generate graphics data from STL file (text format!) and use color for visualization; this function is slow, use stl binary files with GraphicsDataFromSTLfile(...)
-#**input:
-#  fileName: string containing directory and filename of STL-file (in text / SCII format) to load
-#  color: provided as list of 4 RGBA values
-#  verbose: if True, useful information is provided during reading
-#  invertNormals: if True, orientation of normals (usually pointing inwards in STL mesh) are inverted for compatibility in Exudyn
-#  invertTriangles: if True, triangle orientation (based on local indices) is inverted for compatibility in Exudyn
-#**output: creates graphicsData, inverting the STL graphics regarding normals and triangle orientations (interchanged 2nd and 3rd component of triangle index)
-def GraphicsDataFromSTLfileTxt(fileName, color=[0.,0.,0.,1.], verbose=False, invertNormals=True, invertTriangles=True): 
-#file format, just one triangle, using GOMinspect:
-#solid solidName
-#facet normal -0.979434 0.000138 -0.201766
-# outer loop
-#    vertex 9.237351 7.700452 -9.816338
-#    vertex 9.237478 10.187849 -9.815249
-#    vertex 9.706021 10.170116 -12.089709
-# endloop
-#endfacet
-#...
-#endsolid solidName
-    if verbose: print("read STL file: "+fileName)
-
-    fileLines = []
-    try: #still close file if crashes
-        file=open(fileName,'r') 
-        fileLines = file.readlines()
-    finally:
-        file.close()    
-
-    colors=[]
-    points = []
-    normals = []
-    triangles = []
-
-    nf = 1.-2.*int(invertNormals) #+1 or -1 (inverted)
-    indOff = int(invertTriangles) #0 or 1 (inverted)
-
-    nLines = len(fileLines)
-    lineCnt = 0
-    if fileLines[lineCnt][0:5] != 'solid':
-        raise ValueError("GraphicsDataFromSTLfileTxt: expected 'solid ...' in first line, but received: " + fileLines[lineCnt])
-    lineCnt+=1
-    
-    if nLines > 500000:
-        print('large ascii STL file; switch to numpy-stl and binary format for faster loading!')
-
-    while lineCnt < nLines and fileLines[lineCnt].strip().split()[0] != 'endsolid':
-        if lineCnt%100000 == 0 and lineCnt !=0: 
-            if verbose: print("  read line",lineCnt," / ", len(fileLines))
-
-        normalLine = fileLines[lineCnt].split()
-        if normalLine[0] != 'facet' or normalLine[1] != 'normal':
-            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'facet normal ...' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-        if len(normalLine) != 5:
-            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'facet normal n0 n1 n2' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-        
-        normal = [nf*float(normalLine[2]),nf*float(normalLine[3]),nf*float(normalLine[4])]
-
-        lineCnt+=1
-        loopLine = fileLines[lineCnt].strip()
-        if loopLine != 'outer loop':
-            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'outer loop' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-
-        ind = int(len(points)/3) #index for points of this triangle
-        #get 3 vertices:
-        lineCnt+=1
-        for i in range(3):
-            readLine = fileLines[lineCnt].strip().split()
-            if readLine[0] != 'vertex':
-                raise ValueError("GraphicsDataFromSTLfileTxt: expected 'vertex ...' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-            if len(readLine) != 4:
-                raise ValueError("GraphicsDataFromSTLfileTxt: expected 'vertex v0 v1 v2' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-            
-            points+=[float(readLine[1]),float(readLine[2]),float(readLine[3])]
-            normals+=normal
-            colors+=color
-            lineCnt+=1
-            
-        triangles+=[ind,ind+1+indOff,ind+2-indOff] #indices of points; flip indices to match definition in EXUDYN
-
-        loopLine = fileLines[lineCnt].strip()
-        if loopLine != 'endloop':
-            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'endloop' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-        lineCnt+=1
-        loopLine = fileLines[lineCnt].strip()
-        if loopLine != 'endfacet':
-            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'endfacet' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
-        lineCnt+=1
-    
-    data = {'type':'TriangleList', 'colors':colors, 'normals':normals, 'points':points, 'triangles':triangles}
-    return data
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate graphics data from STL file, allowing text or binary format; requires numpy-stl to be installed; additionally can scale, rotate and translate
-#**input:
-#  fileName: string containing directory and filename of STL-file (in text / SCII format) to load
-#  color: provided as list of 4 RGBA values
-#  verbose: if True, useful information is provided during reading
-#  density: if given and if verbose, mass, volume, inertia, etc. are computed
-#  scale: point coordinates are transformed by scaling factor
-#  invertNormals: if True, orientation of normals (usually pointing inwards in STL mesh) are inverted for compatibility in Exudyn
-#  invertTriangles: if True, triangle orientation (based on local indices) is inverted for compatibility in Exudyn
-#**output: creates graphicsData, inverting the STL graphics regarding normals and triangle orientations (interchanged 2nd and 3rd component of triangle index)
-#**notes: the model is first scaled, then rotated, then the offset pOff is added; finally min, max, mass, volume, inertia, com are computed!
-def GraphicsDataFromSTLfile(fileName, color=[0.,0.,0.,1.], verbose=False, density=0., scale=1., Aoff=[], pOff=[], invertNormals=True, invertTriangles=True):
-    
-    try:
-        from stl import mesh
-    except:
-        raise ValueError('GraphicsDataFromSTLfile requires installation of numpy-stl; try "pip install numpy-stl"')
-    
-    data=mesh.Mesh.from_file(fileName)
-    nPoints = 3*len(data.points) #data.points has shape (nTrigs,9), one triangle has 3 points!
-    
-    if scale != 1.:
-        data.points *= scale
-    
-    p = copy.copy(pOff)
-    A = copy.deepcopy(Aoff) #deepcopy for list of lists
-    
-    if p != [] or A != []:
-        from exudyn.rigidBodyUtilities import HomogeneousTransformation
-        if p == []: p=[0,0,0]
-        if A == []: A=np.eye(3)
-        HT = HomogeneousTransformation(A, p)
-        
-        data.transform(HT)
-        
-    dictData = {}
-    if verbose:
-        print('GraphicsDataFromSTLfile:')
-        print('  max point=', list(data.max_))
-        print('  min point=', list(data.min_))
-        print('  STL points=', nPoints)
-    if density != 0:
-        [volume, mass, COM, inertia] = data.get_mass_properties_with_density(density)
-        dictData = {'minPos':data.min_,
-                    'maxPos':data.max_,
-                    'volume':volume,
-                    'mass':mass,
-                    'COM':COM,
-                    'inertia':inertia
-                    }
-    if verbose:
-        print('  volume =', volume)
-        print('  center of mass =', list(COM))
-        print('  inertia =', list(inertia))
-    
-    # print('STL points3=', nPoints3)
-    
-    colors = color*nPoints
-    #triangles = list(np.arange(0,nPoints))#wrong orientation ==> reverse
-    if invertTriangles:
-        triangles = list(np.arange(nPoints-1,-1,-1))#inverted sorting
-    else:
-        triangles = list(np.arange(0,nPoints))      #unmodified sorting of indices
-    points = list(data.points.flatten())
-    nf = 1.-2.*int(invertNormals) #+1 or -1 (inverted)
-    normals = list(np.kron([nf,nf,nf],data.normals).flatten()) #normals must be per point
-
-    dictGraphics = {'type':'TriangleList', 'colors':colors, 'normals':normals, 'points':points, 'triangles':triangles}
-    if density == 0:
-        return dictGraphics 
-    else:
-        return [dictGraphics, dictData]
-
-
-#**function: compute and return GraphicsData with edges and smoothend normals for mesh consisting of points and triangles (e.g., as returned from GraphicsData2PointsAndTrigs)
-#  graphicsData: single GraphicsData object of type TriangleList; existing edges are ignored
-#  edgeColor: optional color for edges
-#  edgeAngle: angle above which edges are added to geometry
-#  roundDigits: number of digits, relative to max dimensions of object, at which points are assumed to be equal
-#  smoothNormals: if True, algorithm tries to smoothen normals at vertices; otherwise, uses triangle normals
-#  addEdges: if True, edges are added in TriangleList of GraphicsData 
-#  triangleColor: if triangleColor is set to a RGBA color, this color is used for the new triangle mesh throughout
-#**output: returns GraphicsData with added edges and smoothed normals
-#**notes: this function is suitable for STL import; it assumes that all colors in graphicsData are the same and only takes the first color!
-def AddEdgesAndSmoothenNormals(graphicsData, edgeColor = color4black, edgeAngle = 0.25*pi,
-                           pointTolerance=5, addEdges=True, smoothNormals=True, roundDigits=5, 
-                           triangleColor = []):
-    from math import acos # ,sin, cos
-
-    oldColors = copy.copy(graphicsData['colors']) #2022-12-06: accepts now all colors; graphicsData['colors'][0:4]    
-    [points, trigs]=GraphicsData2PointsAndTrigs(graphicsData)
-    # [points, trigs]=RefineMesh(points, trigs)
-
-    nPoints = len(points)
-    nColors = int(len(oldColors)/4)
-
-    triangleColorNew = list(triangleColor)
-
-    if nColors != nPoints:
-        print('WARNING: AddEdgesAndSmoothenNormals: found inconsistent colors; they must match the point list in graphics data')
-        if triangleColorNew == []:
-            triangleColorNew = graphicsData['colors'][0:4]
-
-    if len(triangleColorNew) != 4 and len(triangleColorNew) != 0:
-        triangleColorNew = [1,0,0,1]
-        print('WARNING: AddEdgesAndSmoothenNormals: colors invalid; using default')
-
-    if len(triangleColorNew) == 4:
-        oldColors = list(triangleColorNew)*nPoints
-
-    colors = [np.zeros(4)]*nPoints
-    for i in range(nPoints):
-        colors[i] = np.array(oldColors[i*4:i*4+4])
-    
-    points = np.array(points)
-    trigs = np.array(trigs)
-    colors = np.array(colors)
-    pMax = np.max(points, axis=0)
-    pMin = np.min(points, axis=0)
-    maxDim = np.linalg.norm(pMax-pMin)
-    if maxDim == 0: maxDim = 1.
-
-    points = maxDim * np.round(points*(1./maxDim),roundDigits)
-    # print('smoothen np=', nPoints)
-    
-    sortIndices = np.lexsort((points[:,2], points[:,1], points[:,0]))
-    #sortedPoints = points[sortIndices]
-    
-    #now eliminate duplicate points:
-    remap = np.zeros(nPoints,dtype=int)#np.int64)
-    remap[0] = 0
-    newPoints = [points[sortIndices[0],:]] #first point
-    newColors = [colors[sortIndices[0],:]]
-    
-    cnt = 0
-    for i in range(len(sortIndices)-1):
-        nextIndex = sortIndices[i+1]
-        if (points[nextIndex] != points[sortIndices[i]]).any():
-            # newIndices.append(nextIndex)
-            cnt+=1
-            remap[nextIndex] = cnt#i+1
-            newPoints.append(points[nextIndex,:])
-            newColors.append(colors[nextIndex,:])
-        else:
-            remap[nextIndex] = cnt#newIndices[sortIndices[i]]
-            # newIndices.append(newIndices[-1])
-    newPoints = np.array(newPoints)
-    newTrigs = remap[trigs]
-    
-    #==> now we (hopefully have connected triangle lists)
-    
-    nPoints = len(newPoints)
-    nTrigs = len(newTrigs)
-    
-    #create points2trigs lists:
-    points2trigs = [[] for i in range(nPoints)] #[[]]*nPoints does not work!!!!
-    for cntTrig, trig in enumerate(newTrigs):
-        for ind in trig:
-            points2trigs[ind].append(cntTrig)
-    
-    #now find neighbours, compute triangle normals:
-    neighbours = np.zeros((nTrigs,3),dtype=int)
-    # neighbours[:,:] = -1#check if all neighbours found
-    normals = np.zeros((nTrigs,3)) #per triangle
-    areas = np.zeros(nTrigs)
-    for cntTrig, trig in enumerate(newTrigs):
-        normals[cntTrig,:] = ComputeTriangleNormal(newPoints[trig[0]], newPoints[trig[1]], newPoints[trig[2]])
-        areas[cntTrig] = ComputeTriangleArea(newPoints[trig[0]], newPoints[trig[1]], newPoints[trig[2]])
-        for cntNode in range(3):
-            ind  = trig[cntNode]
-            ind2 = trig[(cntNode+1)%3]
-            for t in points2trigs[ind]:
-                #if t <= cntTrig: continue #too much sorted out; check why
-                trig2=newTrigs[t]
-                found = False
-                for cntNode2 in range(3):
-                    if trig2[cntNode2] == ind2 and trig2[(cntNode2+1)%3] == ind:
-                        neighbours[cntTrig, cntNode] = t
-                        found = True
-                        #print('neighbours ', cntTrig, t)
-                        break
-                if found: break
-    
-    #create edges:
-    edges = [] #list of edge points
-    pointHasEdge = [False]*nPoints
-    for cntTrig, trig in enumerate(newTrigs):
-        for cntNode in range(3):
-            ind1  = trig[cntNode]
-            ind2 = trig[(cntNode+1)%3]
-            if ind1 > ind2:
-                val = normals[cntTrig] @ normals[neighbours[cntTrig,cntNode]]
-                if abs(val) > 1: val = np.sign(val) #because of float32 problems
-                angle = acos(val)
-                if angle >= edgeAngle:
-                    edges+=[ind1, ind2]
-                    pointHasEdge[ind1] = True
-                    pointHasEdge[ind2] = True
-    
-    
-    #smooth normals:
-    #we simply do not smooth at points that have edges
-    if smoothNormals:
-        pointNormals = np.zeros((nPoints,3))
-        for i in range(nPoints):
-            if not pointHasEdge[i]:
-                normal = np.zeros(3)
-                for t in points2trigs[i]:
-                    normal += areas[t]*normals[t]
-                
-                pointNormals[i] = ebu.Normalize(normal)
-
-        
-        finalTrigs = []
-        newPoints = list(newPoints)
-        newColors = list(newColors)
-        pointNormals = list(pointNormals)
-        for cnt, trig in enumerate(newTrigs):
-            trigNew = [0,0,0]
-            for i in range(3):
-                if not pointHasEdge[trig[i]]:
-                    trigNew[i] = trig[i]
-                else:
-                    trigNew[i] = len(newPoints)
-                    newPoints.append(newPoints[trig[i]])
-                    pointNormals.append(normals[cnt])
-                    newColors.append(newColors[trig[i]])
-            finalTrigs += [trigNew]
-    else:
-        finalTrigs = newTrigs
-    
-    graphicsData2 = GraphicsDataFromPointsAndTrigs(newPoints, finalTrigs, list(np.array(newColors).flatten()))
-    if addEdges:
-        graphicsData2['edges'] = edges
-        graphicsData2['edgeColor'] = list(edgeColor)
-
-    if smoothNormals:
-        graphicsData2['normals'] = list(np.array(pointNormals).flatten())
-    
-    return graphicsData2
-
-#**function: export given graphics data (only type TriangleList allowed!) to STL ascii file using fileName
-#**input:
-#  graphicsData: a single GraphicsData dictionary with type='TriangleList', no list of GraphicsData
-#  fileName: file name including (local) path to export STL file
-#  solidName: optional name used in STL file
-#  invertNormals: if True, orientation of normals (usually pointing inwards in STL mesh) are inverted for compatibility in Exudyn
-#  invertTriangles: if True, triangle orientation (based on local indices) is inverted for compatibility in Exudyn
-def ExportGraphicsData2STL(graphicsData, fileName, solidName='ExudynSolid', invertNormals=True, invertTriangles=True):
-    if graphicsData['type'] != 'TriangleList':
-        raise ValueError('ExportGraphicsData2STL: invalid graphics data type; only TriangleList allowed')
-        
-    with open(fileName, 'w') as f:
-        f.write('solid '+solidName+'\n')
-
-        nTrig = int(len(graphicsData['triangles'])/3)
-        triangles = graphicsData['triangles']
-    
-        for k in range(nTrig):
-            p = [] #triangle points
-            for i in range(3):
-                ind = triangles[k*3+i]
-                p += [np.array(graphicsData['points'][ind*3:ind*3+3])]
-   
-            n = ComputeTriangleNormal(p[0], p[1], p[2])
-            
-            f.write('facet normal '+str(-n[0]) + ' ' + str(-n[1]) + ' ' + str(-n[2]) + '\n') #normals inverted
-            f.write('outer loop\n')
-            f.write('vertex '+str(p[0][0]) + ' ' + str(p[0][1]) + ' ' + str(p[0][2]) + '\n')
-            f.write('vertex '+str(p[2][0]) + ' ' + str(p[2][1]) + ' ' + str(p[2][2]) + '\n') #point index reversed!
-            f.write('vertex '+str(p[1][0]) + ' ' + str(p[1][1]) + ' ' + str(p[1][2]) + '\n')
-                
-            f.write('endloop\n')
-            f.write('endfacet\n')
-
-        f.write('endsolid '+solidName+'\n')
-
-            
-    # data = {'type':'TriangleList', 'colors':colors, 
-    #         'normals':normals, 
-    #         'points':points, 'triangles':triangles}
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#   unused argument yet: contourNormals: if provided as list of 2D vectors, they prescribe the normals to the contour for smooth visualization; otherwise, contour is drawn flat
-#**function: generate graphics data for a solid of revolution with given 3D point and axis, 2D point list for contour, (optional)2D normals and color; 
-#**input:
-#  pAxis: axis point of one face of solid of revolution (3D list or np.array)
-#  vAxis: vector representing the solid of revolution's axis (3D list or np.array)
-#  contour: a list of 2D-points, specifying the contour (x=axis, y=radius), e.g.: [[0,0],[0,0.1],[1,0.1]]
-#  color: provided as list of 4 RGBA values
-#  nTiles: used to determine resolution of solid; use larger values for finer resolution
-#  smoothContour: if True, the contour is made smooth by auto-computing normals to the contour
-#  addEdges: True or number of edges along revolution mantle; for optimal drawing, nTiles shall be multiple addEdges
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#  alternatingColor: add a second color, which enables to see the rotation of the solid
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-#**example:
-##simple contour, using list of 2D points:
-#contour=[[0,0.2],[0.3,0.2],[0.5,0.3],[0.7,0.4],[1,0.4],[1,0.]]
-#rev1 = GraphicsDataSolidOfRevolution(pAxis=[0,0.5,0], vAxis=[1,0,0], 
-#                                     contour=contour, color=color4red,
-#                                     alternatingColor=color4grey)
-##draw torus:
-#contour=[]
-#r = 0.2 #small radius of torus
-#R = 0.5 #big radius of torus
-#nc = 16 #discretization of torus
-#for i in range(nc+3): #+3 in order to remove boundary effects
-#    contour+=[[r*cos(i/nc*pi*2),R+r*sin(i/nc*pi*2)]]
-#
-##use smoothContour to make torus looking smooth
-#rev2 = GraphicsDataSolidOfRevolution(pAxis=[0,0.5,0], vAxis=[1,0,0], 
-#                                     contour=contour, color=color4red, 
-#                                     nTiles = 64, smoothContour=True)
-def GraphicsDataSolidOfRevolution(pAxis, vAxis, contour, color=[0.,0.,0.,1.], nTiles = 16, smoothContour = False, 
-                                  addEdges = False, edgeColor=color4black, addFaces=True, **kwargs):  
-
-    if len(contour) < 2: 
-        raise ValueError("ERROR: GraphicsDataSolidOfRevolution: contour must contain at least 2 points")
-    if nTiles < 3: 
-        print("WARNING: GraphicsDataSolidOfRevolution: nTiles < 3: set nTiles=3")
-
-    p0 = np.array(pAxis)
-    #local coordinate system:
-    [v,n1,n2] = ComputeOrthonormalBasisVectors(vAxis)
-
-    color2 = list(color)
-    if 'alternatingColor' in kwargs:
-        color2 = kwargs['alternatingColor']
-
-    #compute contour normals, assuming flat cones
-    contourNormals = []
-    for j in range(len(contour)-1):
-        pc0 = np.array(contour[j])
-        pc1 = np.array(contour[j+1])
-        vc = pc1-pc0
-        nc = ebu.Normalize([-vc[1],vc[0]])
-        contourNormals += [nc]
-    contourNormals += [contourNormals[-1]] #normal for last point same as previous
-
-    if smoothContour:
-        contourNormals2 = [contourNormals[0]]
-        for j in range(len(contour)-1):
-            ns = ebu.Normalize(np.array(contourNormals[j]) + np.array(contourNormals[j+1])) #not fully correct, but sufficient
-            contourNormals2 += [list(ns)]
-        contourNormals = contourNormals2
-
-    points = []
-    normals = []
-    colors = []
-    nT2 = int(nTiles/2)
-    nf = normalsFactor #factor for normals (inwards/outwards)
-
-    for j in range(len(contour)-1):
-        pc0 = np.array(contour[j])
-        pc1 = np.array(contour[j+1])
-        points0 = []
-        points1 = []
-        normals0 = []
-        normals1 = []
-        for i in range(nTiles):
-            phi = i*2*pi/nTiles
-            x0 = pc0[1]*sin(phi)
-            y0 = pc0[1]*cos(phi)
-            vv0 = x0*n1 + y0*n2
-
-            x1 = pc1[1]*sin(phi)
-            y1 = pc1[1]*cos(phi)
-            vv1 = x1*n1 + y1*n2
-
-            pz0 = p0 + vv0 + pc0[0]*v
-            pz1 = p0 + vv1 + pc1[0]*v
-            points0 += list(pz0)
-            points1 += list(pz1)
-
-            #vc = pc1-pc0
-            #nc = [-vc[1],vc[0]]
-            nc0 = contourNormals[j]
-            nUnit0 = ebu.Normalize(nf*nc0[1]*sin(phi)*n1 + nf*nc0[1]*cos(phi)*n2+nf*nc0[0]*v)
-            nUnit1 = nUnit0
-            if smoothContour:
-                nc1 = contourNormals[j+1]
-                nUnit1 = ebu.Normalize(nf*nc1[1]*sin(phi)*n1 + nf*nc1[1]*cos(phi)*n2+nf*nc1[0]*v)
-
-            normals0 = normals0 + nUnit0
-            normals1 = normals1 + nUnit1
-
-        cList = list(color)*nT2 + list(color2)*(nTiles-nT2)
-        colors += cList+cList
-        points += points0 + points1
-        normals += normals0 + normals1
-    
-    triangles = []
-    n = nTiles
-    #circumference:
-    if addFaces:
-        for j in range(len(contour)-1):
-            k = j*2*n
-            for i in range(nTiles):
-                if i < nTiles-1:
-                    triangles += [i+k,n+i+k+1,n+i+k]
-                    triangles += [i+k,i+1+k,n+i+k+1]
-                else:
-                    triangles += [i+k,n+k,n+i+k]
-                    triangles += [i+k,k,n+k]
-
-    #triangle normals point inwards to object ...
-    data = {'type':'TriangleList', 'colors':colors, 
-            'normals':normals, 
-            'points':points, 'triangles':triangles}
-
-
-    if addEdges > 0:
-        data['edgeColor'] = list(edgeColor)
-        edges = []
-
-        cntEdges = 0        
-        nSteps = nTiles
-        if type(addEdges) != bool and addEdges > 0:
-            cntEdges = int(addEdges)
-            nSteps = int(nTiles/cntEdges)
-        
-        hEdges = []
-        for j in range(cntEdges):
-            hEdges += [[]]
-
-        for j in range(len(contour)-1):
-            k = j*2*n
-            for i in range(nTiles):
-                edges += [i+k, (i+1)%nTiles+k]
-                if i%nSteps==0:
-                    j=int(i/nSteps)
-                    if j < cntEdges:
-                        hEdges[j] += [i+k, i+k+n]
-
-        for j in range(cntEdges):
-            edges += hEdges[j]
-
-        data['edges'] = edges
-
-    return data
-
-
-#**function: generate graphics data for an arrow with given origin, axis, shaft radius, optional size factors for head and color; nTiles gives the number of tiles (minimum=3)
-#**input:
-#  pAxis: axis point of the origin (base) of the arrow (3D list or np.array)
-#  vAxis: vector representing the vector pointing from the origin to the tip (head) of the error (3D list or np.array)
-#  radius: positive value representing radius of shaft cylinder
-#  headFactor: positive value representing the ratio between head's radius and the shaft radius
-#  headStretch: positive value representing the ratio between the head's radius and the head's length
-#  color: provided as list of 4 RGBA values
-#  nTiles: used to determine resolution of arrow (of revolution object) >=3; use larger values for finer resolution
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataArrow(pAxis, vAxis, radius, color=[0.,0.,0.,1.], headFactor = 2, headStretch = 4, nTiles = 12):  
-    L = ebu.NormL2(vAxis)
-    rHead = radius * headFactor
-    xHead = L - headStretch*rHead
-    contour=[[0,0],[0,radius],[xHead,radius],[xHead,rHead],[L,0]]
-    return GraphicsDataSolidOfRevolution(pAxis=pAxis, vAxis=vAxis, contour=contour, color=color, nTiles=nTiles)
-
-#**function: generate graphics data for three arrows representing an orthogonal basis with point of origin, shaft radius, optional size factors for head and colors; nTiles gives the number of tiles (minimum=3)
-#**input:
-#  origin: point of the origin of the base (3D list or np.array)
-#  rotationMatrix: optional transformation, which rotates the basis vectors
-#  length: positive value representing lengths of arrows for basis
-#  colors: provided as list of 3 colors (list of 4 RGBA values)
-#  headFactor: positive value representing the ratio between head's radius and the shaft radius
-#  headStretch: positive value representing the ratio between the head's radius and the head's length
-#  nTiles: used to determine resolution of arrows of basis (of revolution object) >=3; use larger values for finer resolution
-#  radius: positive value representing radius of arrows; default: radius = 0.01*length
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataBasis(origin=[0,0,0], rotationMatrix = np.eye(3), length = 1, colors=[color4red, color4green, color4blue], 
-                      headFactor = 2, headStretch = 4, nTiles = 12, **kwargs):  
-    radius = 0.01*length
-    if 'radius' in kwargs:
-        radius = kwargs['radius']
-
-    A = np.array(rotationMatrix)
-    g1 = GraphicsDataArrow(origin,A@[length,0,0],radius, colors[0], headFactor, headStretch, nTiles)
-    g2 = GraphicsDataArrow(origin,A@[0,length,0],radius, colors[1], headFactor, headStretch, nTiles)
-    g3 = GraphicsDataArrow(origin,A@[0,0,length],radius, colors[2], headFactor, headStretch, nTiles)
-
-    return MergeGraphicsDataTriangleList(MergeGraphicsDataTriangleList(g1,g2),g3)
-
-#**function: generate graphics data for frame (similar to GraphicsDataBasis), showing three arrows representing an orthogonal basis for the homogeneous transformation HT; optional shaft radius, optional size factors for head and colors; nTiles gives the number of tiles (minimum=3)
-#**input:
-#  HT: homogeneous transformation representing frame
-#  length: positive value representing lengths of arrows for basis
-#  colors: provided as list of 3 colors (list of 4 RGBA values)
-#  headFactor: positive value representing the ratio between head's radius and the shaft radius
-#  headStretch: positive value representing the ratio between the head's radius and the head's length
-#  nTiles: used to determine resolution of arrows of basis (of revolution object) >=3; use larger values for finer resolution
-#  radius: positive value representing radius of arrows; default: radius = 0.01*length
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataFrame(HT=np.eye(4), length = 1, colors=[color4red, color4green, color4blue], 
-                      headFactor = 2, headStretch = 4, nTiles = 12, **kwargs):  
-    radius = 0.01*length
-    if 'radius' in kwargs:
-        radius = kwargs['radius']
-
-    
-    A = HT2rotationMatrix(HT)
-    origin = HT2translation(HT)
-    
-    g1 = GraphicsDataArrow(origin,A@[length,0,0],radius, colors[0], headFactor, headStretch, nTiles)
-    g2 = GraphicsDataArrow(origin,A@[0,length,0],radius, colors[1], headFactor, headStretch, nTiles)
-    g3 = GraphicsDataArrow(origin,A@[0,0,length],radius, colors[2], headFactor, headStretch, nTiles)
-
-    return MergeGraphicsDataTriangleList(MergeGraphicsDataTriangleList(g1,g2),g3)
-
-
-#**function: generate graphics data for simple quad with option for checkerboard pattern;
-#  points are arranged counter-clock-wise, e.g.: p0=[0,0,0], p1=[1,0,0], p2=[1,1,0], p3=[0,1,0]
-#**input: 
-#  pList: list of 4 quad points [[x0,y0,z0],[x1,y1,z1],...]
-#  color: provided as list of 4 RGBA values
-#  alternatingColor: second color; if defined, a checkerboard pattern (default: 10x10) is drawn with color and alternatingColor
-#  nTiles: number of tiles for checkerboard pattern (default: 10)
-#  nTilesY: if defined, use number of tiles in y-direction different from x-direction (=nTiles)
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-#**example:
-#plane = GraphicsDataQuad([[-8, 0, -8],[ 8, 0, -8,],[ 8, 0, 8],[-8, 0, 8]], 
-#                         color4darkgrey, nTiles=8, 
-#                         alternatingColor=color4lightgrey)
-#oGround=mbs.AddObject(ObjectGround(referencePosition=[0,0,0],
-#                      visualization=VObjectGround(graphicsData=[plane])))
-def GraphicsDataQuad(pList, color=[0.,0.,0.,1.], **kwargs): 
-
-    color2 = list(color)
-    nTiles = 1
-    if 'alternatingColor' in kwargs:
-        color2 = kwargs['alternatingColor']
-        nTiles = 10
-
-    if 'nTiles' in kwargs:
-        nTiles = kwargs['nTiles']
-    nTilesY= nTiles
-    if 'nTilesY' in kwargs:
-        nTilesY = kwargs['nTilesY']
-
-    p0 = np.array(pList[0])
-    p1 = np.array(pList[1])
-    p2 = np.array(pList[2])
-    p3 = np.array(pList[3])
-
-    points = []
-    triangles = []
-    #points are given always for 1 quad of checkerboard pattern
-    ind = 0
-    for j in range(nTilesY):
-        for i in range(nTiles):
-            f0 = j/(nTilesY)
-            f1 = (j+1)/(nTilesY)
-            pBottom0 = (nTiles-i)/nTiles  *((1-f0)*p0 + f0*p3) + (i)/nTiles  *((1-f0)*p1 + f0*p2)
-            pBottom1 = (nTiles-i-1)/nTiles*((1-f0)*p0 + f0*p3) + (i+1)/nTiles*((1-f0)*p1 + f0*p2)
-            pTop0 = (nTiles-i)/nTiles  *((1-f1)*p0 + f1*p3) + (i)/nTiles  *((1-f1)*p1 + f1*p2)
-            pTop1 = (nTiles-i-1)/nTiles*((1-f1)*p0 + f1*p3) + (i+1)/nTiles*((1-f1)*p1 + f1*p2)
-            points += list(pBottom0)+list(pBottom1)+list(pTop1)+list(pTop0)
-            #points += list(p0)+list(p1)+list(p2)+list(p3)
-            triangles += [0+ind,1+ind,2+ind,  0+ind,2+ind,3+ind]
-            ind+=4
-
-    colors=[]
-    for j in range(nTilesY):
-        for i in range(nTiles):
-            a=1
-            if i%2 == 1:
-                a=-1
-            if j%2 == 1:
-                a=-1*a
-            if a==1:
-                c = list(color) #if no checkerboard pattern, just this color
-            else:
-                c = color2
-            colors=colors+c+c+c+c #4 colors for one sub-quad
-
-    data = {'type':'TriangleList', 'colors': colors, 'points':points, 'triangles':triangles}
-    #print(data)
-    return data
-
-
-#**function: function to generate checkerboard background;
-#  points are arranged counter-clock-wise, e.g.: 
-#**input: 
-#  point: midpoint of pattern provided as list or np.array
-#  normal: normal to plane provided as list or np.array
-#  size: dimension of first side length of quad
-#  size2: dimension of second side length of quad
-#  color: provided as list of 4 RGBA values
-#  alternatingColor: second color; if defined, a checkerboard pattern (default: 10x10) is drawn with color and alternatingColor
-#  nTiles: number of tiles for checkerboard pattern in first direction
-#  nTiles2: number of tiles for checkerboard pattern in second direction; default: nTiles
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-#**example:
-#plane = GraphicsDataCheckerBoard(normal=[0,0,1], size=5)
-#oGround=mbs.AddObject(ObjectGround(referencePosition=[0,0,0],
-#                      visualization=VObjectGround(graphicsData=[plane])))
-def GraphicsDataCheckerBoard(point=[0,0,0], normal=[0,0,1], size = 1,
-                             color=color4lightgrey, alternatingColor=color4lightgrey2, nTiles=10, **kwargs):
-    nTiles2 = nTiles
-    if 'nTiles2' in kwargs:
-        nTiles2 = kwargs['nTiles2']
-    size2 = size
-    if 'size2' in kwargs:
-        size2 = kwargs['size2']
-
-    [v,n1,n2] = ComputeOrthonormalBasisVectors(normal)
-    p0=np.array(point)
-    points = [list(p0-0.5*size*n1-0.5*size2*n2),
-              list(p0+0.5*size*n1-0.5*size2*n2),
-              list(p0+0.5*size*n1+0.5*size2*n2),
-              list(p0-0.5*size*n1+0.5*size2*n2)]
-
-    return GraphicsDataQuad(points, color=list(color), alternatingColor=alternatingColor, 
-                            nTiles=nTiles, nTilesY=nTiles2)
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to compute triangular mesh from list of vertices (=points) and segments;
-#   computes triangular meshes for non-convex case. In order to make it efficient, it first computes
-#   neighbors and then defines triangles at segments to be inside/outside. Finally neighboring
-#   relations are used to define all triangles inside/outside
-#   finally only returns triangles that are inside the segments
-#**input:
-#  vertices: list of pairs of coordinates of vertices in mesh [x,y]
-#  segments: list of segments, which are pairs of node numbers [i,j], defining the boundary of the mesh;
-#            the ordering of the nodes is such that left triangle = inside, right triangle = outside, compare example with segment [V1,V2]:\\
-#  
-#     inside
-#  V1         V2
-#  O----------O
-#    outside
-#**output:
-#  triangulation structure of Delaunay(...), see scipy.spatial.Delaunaystructure, containing all simplices (=triangles)
-#**notes: Delauney will not work if points are duplicated; you must first create point lists without duplicated points!
-#**example:
-# points = np.array([[0, 0], [0, 2], [2, 2], [2, 1], [1, 1], [0, 1], [1, 0]])
-# segments = [len(points)-1,0]
-# for i in range(len(points)-1):
-#     segments += [i,i+1]
-# tri = ComputeTriangularMesh(points, segments)
-# print(tri.simplices)
-def ComputeTriangularMesh(vertices, segments):
-    from scipy.spatial import Delaunay
-    from copy import deepcopy
-
-    nVertices = len(vertices)
-    tri = Delaunay(np.array(vertices))
-    trigs = deepcopy(tri.simplices)
-    
-    #+++++++++++++++++++++++++++++++++
-    #compute vertices2simplices list:
-    vertices2simplices = [[]]*nVertices
-    cnt = 0
-    for trig in trigs:
-        for i in trig:
-            alist=list(vertices2simplices[i])
-            alist.append(cnt)
-            vertices2simplices[i] = alist    
-        cnt += 1 #trig counter
-        
-    #print(trigs)
-    #print(vertices2simplices)
-    
-    #+++++++++++++++++++++++++++++++++
-    #compute neighbors:
-    trigNeighbors = 0*trigs #-1 means no neighbor trig!
-    trigNeighbors[:,:] = -1
-    #run over all triangles
-    for i in range(len(trigs)):
-        for j in range(3):
-            i0 = trigs[i,j]
-            i1 = trigs[i,(j+1)%3]
-            #actSeg = [i0, i1]
-            listTest = vertices2simplices[i0] + vertices2simplices[i1]
-            for trigIndex in listTest:
-                if trigIndex < i:
-                    for k in range(3):
-                        t0 = trigs[trigIndex, k]
-                        t1 = trigs[trigIndex, (k+1)%3]
-                        if (i0 == t1) and (i1 == t0): #opposite trig orientation is reversed ...
-                            trigNeighbors[i,j] = trigIndex
-                            trigNeighbors[trigIndex,k] = i
-
-    #print("neighbors=", trigNeighbors)                
-
-    #+++++++++++++++++++++++++++++++++
-    #compute inside triangles:
-    trianglesInside = [-1]*len(trigs) #-1 is undefined, 0=outside, 1=inside
-    
-    for seg in segments: #triangles left to segment are inside
-        listTest = vertices2simplices[seg[0]] + vertices2simplices[seg[1]]
-        for trigIndex in listTest:
-            for k in range(3):
-                t0 = trigs[trigIndex, k]
-                t1 = trigs[trigIndex, (k+1)%3]
-                if (seg[0] == t0) and (seg[1] == t1): #inside triangle
-                    trianglesInside[trigIndex] = 1
-                elif (seg[0] == t1) and (seg[1] == t0): #outside triangle
-                    trianglesInside[trigIndex] = 0
-    #print(trianglesInside)
-
-    #finally find remaining triangles (usually all triangles are on boundary, so nothing remains):
-    undefinedTrigs = True
-    while undefinedTrigs: #iterate as long as there are undefined triangles; usually only few iterations necessary
-        undefinedTrigs = False
-        #print("iterate neighbors")
-        for i in range(len(trigs)):
-            if trianglesInside[i] == -1: #still undefined
-                found = False
-                for j in range(3): #look at all neighbors
-                    tn = trigNeighbors[i, j]
-                    if trianglesInside[tn] != -1:
-                        trianglesInside[i] = trianglesInside[tn]
-                        found = True
-                if not found:
-                    undefinedTrigs = True
-
-    #now create new list of interior triangles
-    interiorTrigs = []
-    for i in range(len(trigs)):
-        if trianglesInside[i] == 1: 
-            interiorTrigs += [list(trigs[i])]
-    #print("interiorTrigs=",interiorTrigs)
-    
-    tri.simplices = np.array(interiorTrigs)
-    
-    return tri
-
-#**function: convert point list into segments (indices to points); point indices start with pointIndexOffset
-#**input:
-#  invert: True: circle defines outter boundary; False: circle cuts out geometry inside a geometry
-#  pointIndexOffset: point indices start with pointIndexOffset
-#**output: return segments, containing list of lists of point indices for segments
-def SegmentsFromPoints(points, pointIndexOffset = 0, invert=False, closeCurve=True):
-    n = len(points)
-    segments = np.zeros((n,2),dtype=int)
-    if invert:
-        for i in reversed(range(n-1)):
-            segments[i,:] = [i+1, i]
-    else:
-        for i in range(n-1):
-            segments[i,:] = [i, i+1]
-
-    if closeCurve:
-        if invert:
-            segments[n-1,:] = [0, n-1] #close segments
-        else:
-            segments[n-1,:] = [n-1, 0] #close segments
-
-    return segments
-
-#**function: create points and segments, used in GraphicsDataSolidExtrusion(...) for circle with given parameters
-#**input:
-#  center: 2D center point (list/numpy array) for circle center
-#  radius: radius of circle
-#  invert: True: circle defines outter boundary; False: circle cuts out geometry inside a geometry
-#  pointIndexOffset: point indices start with pointIndexOffset
-#  nTiles: number of tiles/segments for circle creation (higher is finer)
-#**output: return [points, segments], both containing lists of lists
-#**notes: geometries may not intersect!
-def CirclePointsAndSegments(center=[0,0], radius=0.1, invert = False, pointIndexOffset=0, nTiles=16):
-    segments = np.zeros((nTiles,2),dtype=int)
-    points = np.zeros((nTiles,2))
-    
-    if invert:
-        myRange = reversed(range(nTiles))
-    else:
-        myRange = range(nTiles)
-        
-    for i in range(nTiles):
-        phi = i/nTiles*2*pi
-        points[i,:] = [radius*sin(phi)+center[0], radius*cos(phi)+center[1]]
-        segments[i,:] = [(i+int(invert))%nTiles+pointIndexOffset, (i+1-int(invert))%nTiles+pointIndexOffset]
-
-    segments = segments.tolist()
-    points = points.tolist()
-        
-    return [points, segments]
-
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: create graphicsData for solid extrusion based on 2D points and segments; by default, the extrusion is performed in z-direction;
-#            additional transformations are possible to translate and rotate the extruded body;
-#**input:
-#  vertices: list of pairs of coordinates of vertices in mesh [x,y], see ComputeTriangularMesh(...)
-#  segments: list of segments, which are pairs of node numbers [i,j], defining the boundary of the mesh;
-#            the ordering of the nodes is such that left triangle = inside, right triangle = outside; see ComputeTriangularMesh(...)
-#  height:   height of extruded object
-#  rot:      rotation matrix, which the extruded object point coordinates are multiplied with before adding offset
-#  pOff:     3D offset vector added to extruded coordinates; the z-coordinate of the extrusion object obtains 0 for the base plane, z=height for the top plane
-#  smoothNormals: if True, algorithm tries to smoothen normals at vertices and normals are added; creates more points; if False, triangle normals are used internally 
-#  addEdges: if True or 1, edges at bottom/top are included in the GraphicsData dictionary; if 2, also mantle edges are included
-#  edgeColor: optional color for edges
-#  addFaces: if False, no faces are added (only edges)
-#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
-def GraphicsDataSolidExtrusion(vertices, segments, height, rot = np.diag([1,1,1]), pOff = [0,0,0], color = [0,0,0,1],
-                               smoothNormals = False, addEdges = False, edgeColor=color4black, addFaces=True):
-    n = len(vertices)
-    n2 = n*2 #total number of vertices
-    ns = len(segments)
-    colors=[]
-    for i in range(n2):
-        colors+=color
-
-    edges = []
-    mantleEdges = (addEdges == 2)
-
-    points = [[]]*n2
-    for i in range(n):
-        points[i] = [vertices[i][0],vertices[i][1],0]
-    for i in range(n):
-        points[i+n] = [vertices[i][0],vertices[i][1],height]
-
-    if addEdges: #second set of points for top/bottom faces
-        edges = [[]]*(ns*2)
-        for cnt, seg in enumerate(segments):
-            edges[cnt] = [seg[0], seg[1]]
-            edges[cnt+ns] = [seg[0]+n, seg[1]+n]
-
-    edges = list(np.array(edges).flatten())
-    if smoothNormals: #second set of points for top/bottom faces
-        #pointNormals = [[]]*(2*n2)
-        for i in range(n2):
-            colors+=color
-        pointNormals = np.zeros((2*n2,3))
-
-        #add normals from segments:
-        for seg in segments:
-            dirSeg = ebu.Normalize(np.array(vertices[seg[1]]) - np.array(vertices[seg[0]]))
-            dirSeg3D = [dirSeg[1], -dirSeg[0], 0.] #this way points outwards ...
-            pointNormals[seg[0]+2*n,:] += dirSeg3D
-            pointNormals[seg[1]+2*n,:] += dirSeg3D
-            pointNormals[seg[0]+3*n,:] += dirSeg3D
-            pointNormals[seg[1]+3*n,:] += dirSeg3D
-        
-        for i in range(n2):
-            lenSeg = ebu.NormL2(pointNormals[i,:])
-            if lenSeg != 0.:
-                pointNormals[i,:] = (1/lenSeg)*pointNormals[i,:]
-            
-        points2 = [[]]*n2
-        for i in range(n):
-            points2[i] = [vertices[i][0],vertices[i][1],0.]
-            pointNormals[i+0*n,:] = [0.,0.,-1.]
-            #pointNormals[i+2*n,:] = [0,0,-1]
-        for i in range(n):
-            points2[i+n] = [vertices[i][0],vertices[i][1],height]
-            pointNormals[i+1*n,:] = [0.,0.,1.]
-            #pointNormals[i+3*n,:] = [0,0,1]
-        
-
-    #transform points:
-    pointsTransformed = []
-    npRot = np.array(rot)
-    npPoff = np.array(pOff)
-
-    for i in range(n2):
-        p = np.array(npRot @ points[i] + npPoff)
-        pointsTransformed += list(p)
-    
-    if smoothNormals: #these are the points with normals from top/bottom surface
-        for i in range(n2):
-            p = np.array(npRot @ points2[i] + npPoff)
-            pointsTransformed += list(p)
-
-    #compute triangulation:
-    tri = ComputeTriangularMesh(vertices, segments)
-    trigs = tri.simplices
-    nt =len(trigs)
-    trigList = [[]] * (nt*2+ns*2) #top trigs, bottom trigs, circumference trigs (2 per quad)
-    
-    for i in range(nt):
-        #print(list(trigs[i]))
-        # trigList[i] = list(trigs[i])
-        t = list(trigs[i])
-        t.reverse()
-        trigList[i] = copy.copy(t)
-    for i in range(nt):
-        t = list(trigs[i]+n)
-        # t.reverse()
-        trigList[i+nt] = copy.copy(t)
-        
-    #print("ns=",ns)
-    #print("nt=",nt)
-    off = n2*int(smoothNormals)
-    for i in range(ns):
-        trigList[2*nt+2*i  ] = [segments[i][0]+off,segments[i][1]+off,  segments[i][1]+n+off]
-        trigList[2*nt+2*i+1] = [segments[i][0]+off,segments[i][1]+n+off,segments[i][0]+n+off]
-
-        if mantleEdges:
-            edges += [segments[i][0]+off,segments[i][0]+n+off]
-
-    #print("trigList=",trigList)
-    triangles = []
-    if addFaces:
-        for t in trigList:
-            triangles += t
-   
-    data = {'type':'TriangleList', 'colors': colors, 'points':pointsTransformed, 'triangles':triangles}
-    if addEdges:
-        data['edgeColor'] = list(edgeColor)
-        data['edges'] = edges
-
-    if smoothNormals:
-        data['normals'] = list(pointNormals.flatten())
-
-    return data
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Utility functions for visualization, which provides functions for basic shapes
+#           like cube, cylinder, sphere, solid of revolution. Functions generate dictionaries
+#           which contain line, text or triangle primitives for drawing in Exudyn using OpenGL.
+#
+# Author:   Johannes Gerstmayr
+# Date:     2020-07-26 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+# Notes:    Some useful colors are defined, using RGBA (Red, Green, Blue and Alpha = opacity) channels
+#           in the range [0,1], e.g., red = [1,0,0,1].\\
+#           Available colors are: color4red, color4green, color4blue, color4cyan, color4magenta, color4yellow, color4orange, color4pink, color4lawngreen, color4violet, color4springgreen, color4dodgerblue, color4grey, color4darkgrey, color4lightgrey, color4lightred, color4lightgreen, color4steelblue, color4brown, color4black, color4darkgrey2, color4lightgrey2, color4white\\
+#           Additionally, a list of 16 colors 'color4list' is available, which is intended to be used, e.g., for creating n bodies with different colors
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import exudyn.basicUtilities as ebu
+from exudyn.rigidBodyUtilities import ComputeOrthonormalBasisVectors, HomogeneousTransformation, \
+                                      HT2rotationMatrix, HT2translation
+
+#constants and fixed structures:
+import numpy as np #LoadSolutionFile
+import copy as copy #to be able to copy e.g. lists
+from math import pi, sin, cos
+#import time        #AnimateSolution
+
+# color definitions
+color4red = [1.,0.,0.,1.]
+color4green = [0.,1.,0.,1.]
+color4blue = [0.,0.,1.,1.]
+
+color4cyan = [0.,1.,1.,1.]
+color4magenta = [1.,0.,1.,1.]
+color4yellow = [1.,1.,0.,1.]
+
+color4orange = [1.,0.5,0.,1.]
+color4pink = [1.,0.,0.5,1.]
+color4lawngreen = [0.5,1.,0.,1.]
+
+color4springgreen = [0.,1.,0.5,1.]
+color4violet = [0.5,0.,1.,1.]
+color4dodgerblue = [0.,0.5,1.,1.]
+
+
+color4lightred = [0.9,0.4,0.4,1.]
+color4lightgreen = [0.4,0.9,0.4,1.]
+color4steelblue = [0.4,0.4,0.9,1.]
+color4brown = [0.65,0.2,0.2,1.]
+
+color4black =      [0.,0.,0.,1.]
+color4darkgrey =   [0.2,0.2,0.2,1.]
+color4darkgrey2 =  [0.35,0.35,0.35,1.]
+color4grey =       [0.5,0.5,0.5,1.]
+color4lightgrey =  [0.7,0.7,0.7,1.]
+color4lightgrey2 = [0.85,0.85,0.85,1.]
+color4white =      [1.,1.,1.,1.]
+
+color4default =    [-1.,-1.,-1.,-1.] #indicates that default color is used
+
+#define a list of 16 colors for numbered colors
+color4list = [color4red, color4green, color4blue, 
+              color4cyan, color4magenta, color4yellow,
+              color4orange, color4pink, color4lawngreen,
+              color4violet, color4springgreen, color4dodgerblue,
+              color4grey, color4darkgrey, color4lightgrey,
+              #color4lightred, color4lightgreen, color4steelblue, 
+              color4brown]
+
+color4listSize = len(color4list) #maximum number of colors in color4list
+
+normalsFactor = 1. #this is a factor being either -1. [original normals pointing inside; until 2022-06-27], while +1. gives corrected normals pointing outside
+switchTriangleOrder = False #this is the old ordering of triangles in some Sphere or Cylinder functions, causing computed normals to point inside
+
+#**function: helper function to switch order of three items in a list; mostly used for reverting normals in triangles
+#**input: 3D vector as list or as np.array
+#**output: interchanged 2nd and 3rd component of list
+def SwitchTripletOrder(vector):
+    v=list(vector) #copy, such that vector is not changed
+    a = v[2]
+    v[2] = v[1]
+    v[1] = a
+    return v
+
+#**function: compute normalized normal for 3 triangle points
+#**input: 3D vector as list or as np.array
+#**output: normal as np.array
+def ComputeTriangleNormal(p0,p1,p2):
+    v0 = np.array(p1) - np.array(p0)
+    v1 = np.array(p2) - np.array(p0)
+    # print(v0,v1)
+    n = np.cross(v0,v1)
+    ln = np.linalg.norm(n)
+    if ln != 0.:
+        n /= ln
+    return n
+
+#**function: compute area of triangle given by 3 points
+#**input: 3D vector as list or as np.array
+#**output: area as float
+def ComputeTriangleArea(p0,p1,p2):
+    return 0.5*np.linalg.norm(np.cross(np.array(p1) - np.array(p0), np.array(p2) - np.array(p0)))
+
+#************************************************
+#**function: convert graphics data into list of points and list of triangle indices (triplets)
+#**input: g contains a GraphicsData with type TriangleList
+#**output: returns [points, triangles], with points as list of np.array with 3 floats per point and triangles as a list of np.array with 3 int per triangle (0-based indices to points)
+def GraphicsData2PointsAndTrigs(g):
+    if g['type'] == 'TriangleList':
+        nPoints=int(len(g['points'])/3)
+        points = [np.zeros(3)]*nPoints
+        for i in range(nPoints):
+            points[i] = np.array(g['points'][i*3:i*3+3])
+        
+        nTrigs=int(len(g['triangles'])/3)
+        triangles = [np.zeros(3, dtype=int)]*nTrigs
+        for i in range(nTrigs):
+            triangles[i] = np.array(g['triangles'][i*3:i*3+3], dtype=int)
+    else:
+        raise ValueError ('ERROR: GraphicsData2TrigsAndPoints(...) only takes GraphicsData of type TriangleList but found: '+
+                          g['type'] )
+
+    return [points, triangles]
+
+#**function: convert triangles and points as returned from GraphicsData2TrigsAndPoints(...) 
+#**input: 
+#  points: list of np.array with 3 floats per point 
+#  triangles: list of np.array with 3 int per triangle (0-based indices to triangles)
+#  color: provided as list of 4 RGBA values or single list of (number of points)*[4 RGBA values]
+#**output: returns GraphicsData with type TriangleList
+def GraphicsDataFromPointsAndTrigs(points, triangles, color=[0.,0.,0.,1.]):
+    pointList = list(np.array(points).flatten())
+    triangleList = list(np.array(triangles).flatten())
+    nPoints = int(len(pointList)/3)
+    if len(color) == 4*nPoints:
+        colorList = list(color) #without list() potential problem with mutable default value
+    elif len(color) == 4:
+        colorList = list(color)*nPoints
+    else:
+        print('number of points=', nPoints)
+        print('number of trigs=', len(triangleList)/3)
+        print('number of colors=', len(color))
+        raise ValueError('GraphicsDataFromPointsAndTrigs: color must have either 4 RGBA values or 4*(number of points) RGBA values as a list')
+    data = {'type':'TriangleList', 
+            'colors': colorList, 
+            'points':pointList, 
+            'triangles':triangleList}
+    return data
+
+#************************************************
+#**function: refine triangle mesh; every triangle is subdivided into 4 triangles
+#**input:
+#  points: list of np.array with 3 floats per point 
+#  triangles: list of np.array with 3 int per triangle (0-based indices to triangles)
+#**output: returns [points2, triangles2] containing the refined mesh; if the original mesh is consistent, no points are duplicated; if the mesh is not consistent, some mesh points are duplicated!
+#**notes: becomes slow for meshes with more than 5000 points
+def RefineMesh(points, triangles):
+    # 2
+    # |\
+    # a c
+    # |  \
+    # 0-b-1
+    points2 = copy.deepcopy(points)
+    triangles2 = []
+    
+    #build point2trig list for efficiency, at most, per triangle 3 new points:
+    trigsPerPoint = [ [] for _ in range(len(points) + len(triangles)*3) ]
+    # for (ti, trig) in enumerate(triangles):
+    #     for i in trig:
+    #         trigsPerPoint[i] += [ti]
+
+    #print(trigsPerPoint)
+    pnew = [0,0,0] #a,b,c
+    for (ti, trig) in enumerate(triangles):
+        # print('process trig', ti)
+        for j in range(3):
+            pointNew = 0.5*(np.array(points[trig[j]])+np.array(points[trig[j-1]]))
+            found = -1
+            #search all points (SLOW):
+            # for (i, p) in enumerate(points2):
+            #     if np.linalg.norm(pointNew-p) <= 1e-12:
+            #         found = i
+            #go through all triangles at one point, if new (refined) trig exists, it contains the new point:
+            for (i, ti2) in enumerate(trigsPerPoint[trig[j]]):
+                # print('  i, ti2=', i, ti2)
+                for pointIndex in triangles2[ti2]:
+                    if np.linalg.norm(pointNew-points2[pointIndex]) <= 1e-12:
+                        found = pointIndex
+
+            if found==-1:
+                pnew[j] = len(points2)
+                # print('add new point ', pnew[j])
+                points2 += [pointNew]
+            else:
+                pnew[j] = found
+        toff = len(triangles2)
+        triangles2 += [np.array([trig[0],pnew[1],pnew[0]],dtype=int)]
+        triangles2 += [np.array([trig[1],pnew[2],pnew[1]],dtype=int)]
+        triangles2 += [np.array([trig[2],pnew[0],pnew[2]],dtype=int)]
+        triangles2 += [np.array([pnew[0],pnew[1],pnew[2]],dtype=int)]
+        #add new triangles to trigsPerPoint:
+        for (ti, trig) in enumerate(triangles2[-4:]):
+            for i in trig:
+                trigsPerPoint[i] += [toff+ti]
+    # print('trigs per point=',trigsPerPoint)
+    return [points2, triangles2]
+
+#************************************************
+#**function: shrink mesh using triangle normals; every point is at least moved a distance 'distance' normal from boundary
+#**input:
+#  points: list of np.array with 3 floats per point 
+#  triangles: list of np.array with 3 int per triangle (0-based indices to triangles)
+#  distance: float value of minimum distance
+#**output: returns [points2, triangles2] containing the refined mesh; currently the points of the subdivided triangles are duplicated!
+#**notes: ONLY works for consistent meshes (no duplicated points!)
+def ShrinkMeshNormalToSurface(points, triangles, distance):
+    points2 = copy.deepcopy(points)
+    triangles2 = copy.deepcopy(triangles)
+    #disp = [np.zeros(3).copy()]*len(points2) #copy, otherwise linked!!!
+    disp = copy.deepcopy(points)
+    for i in range(len(points2)):
+        disp[i] *= 0.
+    
+    for trig in triangles:
+        n = ComputeTriangleNormal(points[trig[0]],points[trig[1]],points[trig[2]])
+        # print(n)
+        for i in range(3):
+            dn = -distance*n
+            # print('move',trig[i],'=',dn, ', disp=',disp[trig[i]])
+            for j in range(3):
+                if abs(dn[j]) > abs(disp[trig[i]][j]):
+                    disp[trig[i]][j] = dn[j]
+                    # print('==>disp',trig[i],'=',disp[trig[i]])
+
+    # print('disp=', disp)
+
+    for i in range(len(points2)):
+        points2[i] += disp[i]
+
+    return [points2, triangles2]
+
+
+#************************************************
+#**function: add rigid body transformation to GraphicsData, using position offset (global) pOff (list or np.array) and rotation Aoff (transforms local to global coordinates; list of lists or np.array); see Aoff how to scale coordinates!
+#**input:
+#  g: graphicsData to be transformed
+#  pOff: 3D offset as list or numpy.array added to rotated points
+#  Aoff: 3D rotation matrix as list of lists or numpy.array with shape (3,3); if A is scaled by factor, e.g. using 0.001*np.eye(3), you can also scale the coordinates!!!
+#**output: returns new graphcsData object to be used for drawing in objects
+#**notes: transformation corresponds to HomogeneousTransformation(Aoff, pOff), transforming original coordinates v into vNew = pOff + Aoff @ v
+def MoveGraphicsData(g, pOff, Aoff):
+    p0 = np.array(pOff)
+    A0 = np.array(Aoff)
+    
+    if g['type'] == 'TriangleList': 
+        gNew = {'type':'TriangleList'}
+        gNew['colors'] = copy.copy(g['colors'])
+        gNew['triangles'] = copy.copy(g['triangles'])
+        if 'edges' in g:
+            gNew['edges'] = copy.copy(g['edges'])
+        if 'edgeColor' in g:
+            gNew['edgeColor'] = copy.copy(g['edgeColor'])
+
+        n=int(len(g['points'])/3)
+        v0 = np.array(g['points'])
+        v = np.kron(np.ones(n),p0) + (A0 @ v0.reshape((n,3)).T).T.flatten()
+        
+        gNew['points'] = list(v)
+        if 'normals' in g:
+            n0 = np.array(g['normals'])
+            gNew['normals'] = list((A0 @ n0.reshape((n,3)).T).T.flatten() )
+        
+        # #original, slow:
+        # for i in range(n):
+        #     v = gNew['points'][i*3:i*3+3]
+        #     v = p0 + A0 @ v
+        #     gNew['points'][i*3:i*3+3] = list(v)
+        # if 'normals' in gNew:
+        #     n=int(len(g['normals'])/3)
+        #     for i in range(n):
+        #         v = gNew['normals'][i*3:i*3+3]
+        #         v = A0 @ v
+        #         gNew['normals'][i*3:i*3+3] = list(v)
+    elif g['type'] == 'Line':
+        gNew = copy.deepcopy(g)
+        n=int(len(g['data'])/3)
+        for i in range(n):
+            v = gNew['data'][i*3:i*3+3]
+            v = p0 + A0 @ v
+            gNew['data'][i*3:i*3+3] = list(v)
+    elif g['type'] == 'Text':
+        gNew = copy.deepcopy(g)
+        v = p0 + A0 @ gNew['position']
+        gNew['position'] = list(v)
+    elif g['type'] == 'Circle':
+        gNew = copy.deepcopy(g)
+        v = p0 + A0 @ gNew['position']
+        gNew['position'] = list(v)
+        if 'normal' in gNew:
+            v = A0 @ gNew['normal']
+            gNew['normal'] = list(v)
+    else:
+        raise ValueError('MoveGraphicsData: unsupported graphics data type')
+    return gNew
+
+#************************************************
+#**function: merge 2 different graphics data with triangle lists
+#**input: graphicsData dictionaries g1 and g2 obtained from GraphicsData functions
+#**output: one graphicsData dictionary with single triangle lists and compatible points and normals, to be used in visualization of EXUDYN objects; edges are merged; edgeColor is taken from graphicsData g1
+def MergeGraphicsDataTriangleList(g1,g2):
+    np = int(len(g1['points'])/3) #number of points
+    useNormals = False
+    if 'normals' in g1 and 'normals' in g2:
+        useNormals = True
+
+    if np*4 != len(g1['colors']):
+        raise ValueError('MergeGraphicsDataTriangleList: incompatible colors and points in lists')
+
+    if useNormals:
+        if np*3 != len(g1['normals']):
+            raise ValueError('MergeGraphicsDataTriangleList: incompatible normals and points in lists')
+        data = {'type':'TriangleList', 'colors':copy.copy(g1['colors']), 'normals':copy.copy(g1['normals']), 
+                'points': copy.copy(g1['points']), 'triangles': copy.copy(g1['triangles'])}
+
+        data['normals'] += g2['normals']
+    else:
+        data = {'type':'TriangleList', 'colors':copy.copy(g1['colors']),
+                'points': copy.copy(g1['points']), 'triangles': copy.copy(g1['triangles'])}
+    
+    data['colors'] += g2['colors']
+    data['points'] += g2['points']
+
+    #copy and merge edges; edges can be available only in one triangle list
+    if 'edges' in g1:
+        data['edges'] = copy.copy(g1['edges'])
+    if 'edges' in g2:
+        edges2 = copy.copy(g2['edges'])
+        if 'edges' not in data:
+            data['edges'] = []
+        else:
+            for i in range(len(edges2)):
+                edges2[i] += np #add point offset
+        
+        data['edges'] += edges2
+    if 'edgeColor' in g1:
+        data['edgeColor'] = copy.copy(g1['edgeColor']) #only taken from g1
+    elif 'edgeColor' in g2:
+        data['edgeColor'] = copy.copy(g2['edgeColor']) #only taken from g1
+
+    for p in g2['triangles']:
+        data['triangles'] += [int(p + np)] #add point offset for correct connectivity
+
+    return data
+
+
+#************************************************
+#**function: generate graphics data for lines, given by list of points and color; transforms to GraphicsData dictionary
+#**input: 
+#  pList: list of 3D numpy arrays or lists (to achieve closed curve, set last point equal to first point)
+#  color: provided as list of 4 RGBA values
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+#**example:
+##create simple 3-point lines
+#gLine=GraphicsDataLine([[0,0,0],[1,0,0],[2,0.5,0]], color=color4red)
+def GraphicsDataLine(pList, color=[0.,0.,0.,1.]): 
+    data = [0]*(len(pList)*3)
+    for i, p in enumerate(pList):
+        data[i*3:i*3+3] = list(p)
+    dataRect = {'type':'Line', 'color': list(color), 'data':data}
+
+    return dataRect
+
+#************************************************
+#**function: generate graphics data for a single circle; currently the plane normal = [0,0,1], just allowing to draw planar circles -- this may be extended in future!
+#**input: 
+#  point: center point of circle
+#  radius: radius of circle
+#  color: provided as list of 4 RGBA values
+#**notes: the tiling (number of segments to draw circle) can be adjusted by visualizationSettings.general.circleTiling
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataCircle(point=[0,0,0], radius=1, color=[0.,0.,0.,1.]): 
+    return {'type':'Circle', 'color': list(color), 'radius': radius, 'position':list(point)}
+
+#************************************************
+#**function: generate graphics data for a text drawn at a 3D position
+#**input: 
+#  point: position of text
+#  text: string representing text
+#  color: provided as list of 4 RGBA values
+#**nodes: text size can be adjusted with visualizationSettings.general.textSize, which affects the text size (=font size) globally
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataText(point=[0,0,0], text='', color=[0.,0.,0.,1.]): 
+    return {'type':'Text', 'color': list(color), 'text':text, 'position':list(point)}
+
+#************************************************
+#**function: generate graphics data for 2D rectangle
+#**input: minimal and maximal cartesian coordinates in (x/y) plane; color provided as list of 4 RGBA values
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataRectangle(xMin, yMin, xMax, yMax, color=[0.,0.,0.,1.]): 
+
+    rect = [xMin, yMin,xMax,yMax]
+    dataRect = {'type':'Line', 'color': list(color), 'data':[rect[0],rect[1],0, rect[2],rect[1],0, rect[2],rect[3],0, rect[0],rect[3],0, rect[0],rect[1],0]}
+
+    return dataRect
+
+#************************************************
+#**function: generate graphics data for orthogonal block drawn with lines
+#**input: minimal and maximal cartesian coordinates for orthogonal cube; color provided as list of 4 RGBA values
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataOrthoCubeLines(xMin, yMin, zMin, xMax, yMax, zMax, color=[0.,0.,0.,1.]): 
+
+    dataRect = {'type':'Line', 'color': list(color), 'data':[xMin,yMin,zMin, xMin,yMax,zMin, xMin,yMin,zMin, xMax,yMin,zMin, xMax,yMax,zMin, xMax,yMin,zMin, 
+                                                       xMax,yMin,zMax, xMax,yMax,zMax, xMax,yMin,zMax, xMin,yMin,zMax, xMin,yMax,zMax, xMin,yMin,zMax, 
+                                                       xMin,yMin,zMin, xMin,yMax,zMin, xMax,yMax,zMin, xMax,yMax,zMax, xMin,yMax,zMax, xMin,yMax,zMin]}
+
+    return dataRect
+
+#**function: generate graphics data for orthogonal 3D block with min and max dimensions
+#**input: 
+#  x/y/z/Min/Max: minimal and maximal cartesian coordinates for orthogonal cube
+#  color: list of 4 RGBA values
+#  addNormals: add face normals to triangle information
+#  addEdges: if True, edges are added in TriangleList of GraphicsData 
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataOrthoCube(xMin, yMin, zMin, xMax, yMax, zMax, color=[0.,0.,0.,1.], addNormals=False, addEdges=False, edgeColor=color4black, addFaces=True): 
+    
+    pList = [[xMin,yMin,zMin], [xMax,yMin,zMin], [xMax,yMax,zMin], [xMin,yMax,zMin],
+             [xMin,yMin,zMax], [xMax,yMin,zMax], [xMax,yMax,zMax], [xMin,yMax,zMax]]
+    return GraphicsDataCube(pList, list(color), addNormals=addNormals, addEdges=addEdges, edgeColor=edgeColor, addFaces=addFaces)
+
+#**function: generate graphics data forfor orthogonal 3D block with center point and size
+#**input: 
+#  centerPoint: center of cube as 3D list or np.array
+#  size: size as 3D list or np.array
+#  color: list of 4 RGBA values
+#  addNormals: add face normals to triangle information
+#  addEdges: if True, edges are added in TriangleList of GraphicsData 
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects; if addEdges=True, it returns a list of two dictionaries
+def GraphicsDataOrthoCubePoint(centerPoint=[0,0,0], size=[0.1,0.1,0.1], color=[0.,0.,0.,1.], addNormals=False, addEdges=False, edgeColor=color4black, addFaces=True): 
+    
+    xMin = centerPoint[0] - 0.5*size[0]
+    yMin = centerPoint[1] - 0.5*size[1]
+    zMin = centerPoint[2] - 0.5*size[2]
+    xMax = centerPoint[0] + 0.5*size[0]
+    yMax = centerPoint[1] + 0.5*size[1]
+    zMax = centerPoint[2] + 0.5*size[2]
+
+    gCube = GraphicsDataOrthoCube(xMin, yMin, zMin, xMax, yMax, zMax, color, 
+                                  addNormals=addNormals, addEdges=addEdges, edgeColor=edgeColor, addFaces=addFaces)
+    if addEdges:
+        gCube['edgeColor'] = list(edgeColor)
+        gCube['edges'] = [0,1, 1,2, 2,3, 3,0,  0,4, 1,5, 2,6, 3,7,  4,5, 5,6, 6,7, 7,4]
+        #print('new2')
+    return gCube
+
+#**function: generate graphics data for general block with endpoints, according to given vertex definition
+#**input: 
+#  pList: is a list of points [[x0,y0,z0],[x1,y1,z1],...]
+#  color: provided as list of 4 RGBA values
+#  faces: includes the list of six binary values (0/1), denoting active faces (value=1); set index to zero to hide face
+#  addNormals: if True, normals are added and there are separate points for every triangle
+#  addEdges: if True, edges are added in TriangleList of GraphicsData 
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataCube(pList, color=[0.,0.,0.,1.], faces=[1,1,1,1,1,1], addNormals=False, addEdges=False, edgeColor=color4black, addFaces=True): 
+# bottom: (z goes upwards from node 0 to node 4)
+# ^y
+# |
+# 3---2
+# |   |
+# |   |
+# 0---1-->x
+#
+# top:
+# ^y
+# |
+# 7---6
+# |   |
+# |   |
+# 4---5-->x
+#
+# faces: bottom, top, sideface0, sideface1, sideface2, sideface3 (sideface0 has nodes 0,1,4,5)
+
+    colors=[]
+    for i in range(8):
+        colors=colors+color
+
+    points = []
+    for p in pList:
+        points += p
+#    points = [xMin,yMin,zMin, xMax,yMin,zMin, xMax,yMax,zMin, xMin,yMax,zMin,
+#              xMin,yMin,zMax, xMax,yMin,zMax, xMax,yMax,zMax, xMin,yMax,zMax]
+
+    #1-based ... triangles = [1,3,2, 1,4,3, 5,6,7, 5,7,8, 1,2,5, 2,6,5, 2,3,6, 3,7,6, 3,4,7, 4,8,7, 4,1,8, 1,5,8 ]
+    #triangles = [0,2,1, 0,3,2, 6,4,5, 6,7,4, 0,1,4, 1,5,4, 1,2,5, 2,6,5, 2,3,6, 3,7,6, 3,0,7, 0,4,7]
+
+    trigList = [[0,2,1], [0,3,2], #
+                [6,4,5], [6,7,4], #
+                [0,1,4], [1,5,4], #
+                [1,2,5], [2,6,5], #
+                [2,3,6], [3,7,6], #
+                [3,0,7], [0,4,7]] #
+    triangles = []
+    # print('addNormals=',addNormals)
+    if not addNormals:
+        for i in range(6):
+            if faces[i]:
+                for j in range(2):
+                    if addFaces:
+                        triangles += trigList[i*2+j]
+        data = {'type':'TriangleList', 'colors': colors, 'points':points, 'triangles':triangles}
+    else:
+        normals = []
+        points2 = []
+        
+        cnt = 0
+        for i in range(6):
+            if faces[i]:
+                for j in range(2):
+                    trig = trigList[i*2+j]
+                    normal = ComputeTriangleNormal(pList[trig[0]],pList[trig[1]],pList[trig[2]])
+                    normals+=list(normal)*3 #add normal for every point
+                    for k in range(3):
+                        if addFaces:
+                            triangles += [cnt] #new point for every triangle
+                        points2 += list(pList[trig[k]])
+                        cnt+=1
+        
+        data = {'type':'TriangleList', 'colors': color*cnt, 'normals':normals, 'points':points2, 'triangles':triangles}
+
+    if addEdges:
+        edges = [0,1, 1,2, 2,3, 3,0,
+                 4,5, 5,6, 6,7, 7,4,
+                 0,4, 1,5, 2,6, 3,7 ]
+        
+        data['edges'] = edges
+        data['edgeColor'] = list(edgeColor)
+        
+    return data
+
+#**function: generate graphics data for a sphere with point p and radius
+#**input:
+#  point: center of sphere (3D list or np.array)
+#  radius: positive value
+#  color: provided as list of 4 RGBA values
+#  nTiles: used to determine resolution of sphere >=3; use larger values for finer resolution
+#  addEdges: True or number of edges along sphere shell (under development); for optimal drawing, nTiles shall be multiple of 4 or 8
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataSphere(point=[0,0,0], radius=0.1, color=[0.,0.,0.,1.], nTiles = 8, 
+                       addEdges = False, edgeColor=color4black, addFaces=True):
+    if nTiles < 3: print("WARNING: GraphicsDataSphere: nTiles < 3: set nTiles=3")
+    
+    p = np.array(point)
+    r = radius
+    #orthonormal basis:
+    e0=np.array([1,0,0])
+    e1=np.array([0,1,0])
+    e2=np.array([0,0,1])
+
+    points = []
+    normals = []
+    colors = []
+    triangles = []
+    
+    #create points for circles around z-axis with tiling
+    for i0 in range(nTiles+1):
+        for iphi in range(nTiles):
+            z = -r*cos(pi*i0/nTiles)    #runs from -r .. r (this is the coordinate of the axis of circles)
+            phi = 2*pi*iphi/nTiles #angle
+            fact = sin(pi*i0/nTiles)
+
+            x = fact*r*sin(phi)
+            y = fact*r*cos(phi)
+
+            vv = x*e0 + y*e1 + z*e2
+            points += list(p + vv)
+            
+            n = ebu.Normalize(vv) #2022-06-27: corrected to (vv) to point outwards
+            #print(n)
+            normals += n
+            
+            colors += color
+
+    
+    if addFaces:
+        for i0 in range(nTiles):
+            for iphi in range(nTiles):
+                p0 = i0*nTiles+iphi
+                p1 = (i0+1)*nTiles+iphi
+                iphi1 = iphi + 1
+                if iphi1 >= nTiles: 
+                    iphi1 = 0
+                p2 = i0*nTiles+iphi1
+                p3 = (i0+1)*nTiles+iphi1
+    
+                if switchTriangleOrder:
+                    triangles += [p0,p3,p1, p0,p2,p3]
+                else:
+                    triangles += [p0,p1,p3, p0,p3,p2]
+            
+    data = {'type':'TriangleList', 'colors':colors, 
+            'normals':normals, 
+            'points':points, 
+            'triangles':triangles}
+    
+    if type(addEdges) == bool and addEdges == True:
+        addEdges = 3
+
+    if addEdges > 0:
+        data['edgeColor'] = list(edgeColor)
+
+        edges = []
+        hEdges = [] #edges at half of iphi
+        nt = 2
+        if addEdges > 1:
+            nt = 4
+        if addEdges > 3:
+            nt = 8
+        for j in range(nt):
+            hEdges += [[]]
+        hTiles = int(nTiles/nt)
+        # hLast = [None]*nt
+        # hFirst = [None]*nt
+        sTiles = max(addEdges-1,1) #non-negative
+        nStep = int(nTiles/sTiles)
+        
+        for i0 in range(nTiles):
+            for iphi in range(nTiles):
+                p0 = i0*nTiles+iphi
+                p1 = (i0+1)*nTiles+iphi
+                if i0%nStep == 0:
+                    iphi1 = iphi + 1
+                    if iphi1 >= nTiles: 
+                        iphi1 = 0
+                    p2 = i0*nTiles+iphi1
+                    if addEdges>1:
+                        edges += [p0, p2]
+                if hTiles != 0:
+                    if iphi%hTiles == 0:
+                        j = int(iphi/hTiles)
+                        if j < nt:
+                            hEdges[j] += [p0,p1]
+                            # if hLast[j] == None:
+                            #     hLast[j] = p0
+                            #     hFirst[j] = p0
+                            # else:
+                            #     hEdges[j] += [hLast[j], p0]
+                            #     hLast[j] = p0
+        
+        for j in range(nt):
+            #print('j=',j, hEdges[j], ', hFirst=',hFirst)
+            if nt%2 == 0: #close edges only for even nt
+                hEdges[j] += [hEdges[j][-1], hEdges[(j+int(nt/2))%nt][-1]]
+                
+            edges += hEdges[j]
+
+        data['edges'] = edges
+    
+    return data
+            
+#**function: generate graphics data for a cylinder with given axis, radius and color; nTiles gives the number of tiles (minimum=3)
+#**input:
+#  pAxis: axis point of one face of cylinder (3D list or np.array)
+#  vAxis: vector representing the cylinder's axis (3D list or np.array)
+#  radius: positive value representing radius of cylinder
+#  color: provided as list of 4 RGBA values
+#  nTiles: used to determine resolution of cylinder >=3; use larger values for finer resolution
+#  angleRange: given in rad, to draw only part of cylinder (halfcylinder, etc.); for full range use [0..2 * pi]
+#  lastFace: if angleRange != [0,2*pi], then the faces of the open cylinder are shown with lastFace = True
+#  cutPlain: only used for angleRange != [0,2*pi]; if True, a plane is cut through the part of the cylinder; if False, the cylinder becomes a cake shape ...
+#  addEdges: if True, edges are added in TriangleList of GraphicsData; if addEdges is integer, additional int(addEdges) lines are added on the cylinder mantle
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#  alternatingColor: if given, optionally another color in order to see rotation of solid; only works, if angleRange=[0,2*pi]
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataCylinder(pAxis=[0,0,0], vAxis=[0,0,1], radius=0.1, color=[0.,0.,0.,1.], nTiles = 16, 
+                         angleRange=[0,2*pi], lastFace = True, cutPlain = True, 
+                         addEdges=False, edgeColor=color4black,
+                         addFaces=True, **kwargs):  
+
+    if nTiles < 3: print("WARNING: GraphicsDataCylinder: nTiles < 3: set nTiles=3")
+    
+    #create points at left and right face
+    points0=list(pAxis) #[pAxis[0],pAxis[1],pAxis[2]] #avoid change of pAxis
+    pAxis1=[pAxis[0]+vAxis[0],pAxis[1]+vAxis[1],pAxis[2]+vAxis[2]]
+    points1=list(pAxis1) #[pAxis[0]+vAxis[0],pAxis[1]+vAxis[1],pAxis[2]+vAxis[2]] #copy in order to avoid change of pAxis1 for use lateron
+    
+    p0 = np.array(pAxis)
+    p1 = np.array(pAxis) + np.array(vAxis)
+    
+    basis = ComputeOrthonormalBasisVectors(vAxis)
+    #v0 = basis[0]
+    n1 = basis[1]
+    n2 = basis[2]
+    r=radius
+    
+    nf = normalsFactor #-1 original; -1 points inside
+
+    #create normals at left and right face (pointing inwards)
+    normals0 = ebu.Normalize([-vAxis[0],-vAxis[1],-vAxis[2]])
+    normals1 = ebu.Normalize(vAxis)
+
+    points2 = []
+    points3 = []
+    
+    alpha = angleRange[1]-angleRange[0] #angular range
+    alpha0 = angleRange[0]
+
+    fact = nTiles #create correct part of cylinder
+    if alpha < 2.*pi: 
+        fact = nTiles-1
+
+    # pointsCyl0 = []
+    # pointsCyl1 = []
+    
+    for i in range(nTiles):
+        phi = alpha0 + i*alpha/fact
+        x = r*sin(phi)
+        y = r*cos(phi)
+        vv = x*n1 + y*n2
+        pz0 = p0 + vv
+        pz1 = p1 + vv
+        points0 += list(pz0)
+        points1 += list(pz1)
+        points2 += list(pz0) #other points for side faces (different normals)
+        points3 += list(pz1) #other points for side faces (different normals)
+        # pointsCyl0 += list(pz0) #for edges
+        # pointsCyl1 += list(pz1) #for edges
+        n = ebu.Normalize(list(nf*vv))
+        normals0 = normals0 + n
+        normals1 = normals1 + n
+        
+    
+    points0 += points1+points2+points3
+    normals0 += normals1
+
+    for i in range(nTiles):
+        normals0 += ebu.Normalize([-nf*vAxis[0],-nf*vAxis[1],-nf*vAxis[2]])
+    for i in range(nTiles):
+        normals0 += ebu.Normalize([nf*vAxis[0],nf*vAxis[1],nf*vAxis[2]])
+
+    n = nTiles+1 #number of points of one ring+midpoint
+    color2 = list(color) #alternating color
+    if 'alternatingColor' in kwargs:
+        color2 = kwargs['alternatingColor']
+
+    colors=[]
+    #for i in range(2*n+2*nTiles):
+    #    colors += color
+    n2 = int(nTiles/2)    
+    for i in range(2):
+        colors += color
+    for j in range(4):
+        for i in range(n2):
+            colors += color
+        for i in range(nTiles-n2):
+            colors += color2
+
+    triangles = []
+    #circumference:
+    for i in range(nTiles):
+        if switchTriangleOrder:
+            if i != nTiles-1:
+                triangles += [1+i,n+1+i+1,n+1+i]
+                triangles += [1+i,1+i+1,n+1+i+1]
+            else:
+                if lastFace and cutPlain:
+                    triangles += [1+i,n+1,n+1+i]
+                    triangles += [1+i,1,n+1]
+        else:
+            if i != nTiles-1:
+                triangles += [1+i,n+1+i,n+1+i+1]
+                triangles += [1+i,n+1+i+1,1+i+1]
+            else:
+                if lastFace and cutPlain:
+                    triangles += [1+i,n+1+i,n+1]
+                    triangles += [1+i,n+1,1]
+            
+    #sides faces left and right:
+    nn=2*n #offset
+    for i in range(nTiles):
+        if switchTriangleOrder:
+            if i != nTiles-1:
+                triangles += [0,nn+i,nn+i+1]
+                triangles += [n,nn+nTiles+i+1,nn+nTiles+i]
+            else:
+                if cutPlain:
+                    triangles += [0,nn+i,nn]
+                    triangles += [n,nn+nTiles,nn+nTiles+i]
+        else:
+            if i != nTiles-1:
+                triangles += [0,nn+i,nn+i+1]
+                triangles += [n,nn+nTiles+i+1,nn+nTiles+i]
+            else:
+                if cutPlain:
+                    triangles += [0,nn+i,nn]
+                    triangles += [n,nn+nTiles,nn+nTiles+i]
+
+    #if angles are not 2*pi, add closing face
+    if lastFace and not(cutPlain):
+        s = int(len(points0)/3) #starting index for side triangles
+        p2 = points2[0:3]
+        p3 = points3[0:3]
+        p4 = points2[len(points2)-3:len(points2)]
+        p5 = points3[len(points3)-3:len(points3)]
+        points0 += pAxis + pAxis1 + p2 + p3 + pAxis + pAxis1 + p4 + p5
+        n1=np.cross(ebu.VSub(pAxis,pAxis1),ebu.VSub(p3,pAxis))
+        n1=list(ebu.Normalize(-nf*n1))
+        n2=np.cross(ebu.VSub(pAxis1,pAxis),ebu.VSub(p4,pAxis))
+        n2=list(ebu.Normalize(-nf*n2))
+        normals0 += n1+n1+n1+n1+n2+n2+n2+n2  #8 additional normals
+        if switchTriangleOrder:
+            triangles += [s+0,s+3,s+1, s+0,s+2,s+3, 
+                          s+5,s+6,s+4, s+5,s+7,s+6]
+        else:
+            triangles += [s+0,s+1,s+3, s+0,s+3,s+2, 
+                          s+5,s+4,s+6, s+5,s+6,s+7]
+            
+        for i in range(8): #8 additional colors
+            colors += color
+
+    # print('points len=', len(points0))
+    # print('normals len=', len(normals0))
+    if not addFaces:
+        triangles = []
+
+    #triangle normals point inwards to object ...
+    data = {'type':'TriangleList', 'colors':colors, 
+            'normals':normals0, 
+            'points':points0, 'triangles':triangles}
+
+    if addEdges:
+        data['edgeColor'] = list(edgeColor)
+        
+        faceEdges = 0
+        if type(addEdges) != bool:
+            faceEdges = int(addEdges)
+        
+        edges = []
+        pLast = nTiles
+        for i in range(nTiles):
+            edges += [pLast, i+1]
+            pLast = i+1
+        
+        pLast = nTiles + (nTiles+1)
+        for i in range(nTiles):
+            edges += [pLast, i+1+(nTiles+1)]
+            pLast = i+1+(nTiles+1)
+        
+        if faceEdges > 0:
+            nStep = int(nTiles/faceEdges)
+            pLast0 = 1
+            pLast1 = 1+(nTiles+1)
+            for i in range(faceEdges):
+                edges += [pLast0, pLast1]
+                pLast0 += nStep
+                pLast1 += nStep
+        
+        data['edges'] = edges
+
+    return data
+
+#**function: generate graphics data for a planar Link between the two joint positions, having two axes
+#**input:
+#  p0: joint0 center position
+#  p1: joint1 center position
+#  axis0: direction of rotation axis at p0, if drawn as a cylinder; [0,0,0] otherwise
+#  axis1: direction of rotation axis of p1, if drawn as a cylinder; [0,0,0] otherwise
+#  radius: list of two radii [radius0, radius1], being the two radii of the joints drawn by a cylinder or sphere    
+#  width: list of two widths [width0, width1], being the two widths of the joints drawn by a cylinder; ignored for sphere    
+#  thickness: the thickness of the link (shaft) between the two joint positions; thickness in z-direction or diameter (cylinder)
+#  color: provided as list of 4 RGBA values
+#  nTiles: used to determine resolution of cylinder >=3; use larger values for finer resolution
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataRigidLink(p0,p1,axis0=[0,0,0], axis1=[0,0,0], radius=[0.1,0.1], 
+                          thickness=0.05, width=[0.05,0.05], color=[0.,0.,0.,1.], nTiles = 16):
+    linkAxis = ebu.VSub(p1,p0)
+    #linkAxis0 = ebu.Normalize(linkAxis)
+    a0=list(axis0)
+    a1=list(axis1)
+    
+    data0 = GraphicsDataCylinder(p0, linkAxis, 0.5*thickness, color, nTiles)
+    data1 = {}
+    data2 = {}
+
+    if ebu.NormL2(axis0) == 0:
+        data1 = GraphicsDataSphere(p0, radius[0], color, nTiles)
+    else:
+        a0=ebu.Normalize(a0)
+        data1 = GraphicsDataCylinder(list(np.array(p0)-0.5*width[0]*np.array(a0)), 
+                                     list(width[0]*np.array(a0)), 
+                                     radius[0], color, nTiles)
+        
+    if ebu.NormL2(axis1) == 0:
+        data2 = GraphicsDataSphere(p1, radius[1], color, nTiles)
+    else:
+        a1=ebu.Normalize(a1)
+        data2 = GraphicsDataCylinder(list(np.array(p1)-0.5*width[1]*np.array(a1)), 
+                                     list(width[1]*np.array(a1)), radius[1], color, nTiles)
+
+    #now merge lists, including appropriate indices of triangle points!
+    np0 = int(len(data0['points'])/3) #number of points of first point list ==> this is the offset for next list
+    np1 = np0 + int(len(data1['points'])/3) #number of points of first point list ==> this is the offset for next list
+
+    triangles = data0['triangles']
+    trigs1 = np.array(data1['triangles'])
+    trigs1 += np0
+    triangles += list(trigs1)
+    
+    trigs2 = np.array(data2['triangles'])
+    trigs2 += np1
+    triangles += list(trigs2)
+    
+    points = data0['points'] + data1['points'] + data2['points']
+    normals = data0['normals'] + data1['normals'] + data2['normals']
+    colors = data0['colors'] + data1['colors'] + data2['colors']
+    
+    data = {'type':'TriangleList', 'colors':colors, 
+            'normals':normals, 
+            'points':points, 'triangles':triangles}
+    return data
+
+
+#**function: generate graphics data from STL file (text format!) and use color for visualization; this function is slow, use stl binary files with GraphicsDataFromSTLfile(...)
+#**input:
+#  fileName: string containing directory and filename of STL-file (in text / SCII format) to load
+#  color: provided as list of 4 RGBA values
+#  verbose: if True, useful information is provided during reading
+#  invertNormals: if True, orientation of normals (usually pointing inwards in STL mesh) are inverted for compatibility in Exudyn
+#  invertTriangles: if True, triangle orientation (based on local indices) is inverted for compatibility in Exudyn
+#**output: creates graphicsData, inverting the STL graphics regarding normals and triangle orientations (interchanged 2nd and 3rd component of triangle index)
+def GraphicsDataFromSTLfileTxt(fileName, color=[0.,0.,0.,1.], verbose=False, invertNormals=True, invertTriangles=True): 
+#file format, just one triangle, using GOMinspect:
+#solid solidName
+#facet normal -0.979434 0.000138 -0.201766
+# outer loop
+#    vertex 9.237351 7.700452 -9.816338
+#    vertex 9.237478 10.187849 -9.815249
+#    vertex 9.706021 10.170116 -12.089709
+# endloop
+#endfacet
+#...
+#endsolid solidName
+    if verbose: print("read STL file: "+fileName)
+
+    fileLines = []
+    try: #still close file if crashes
+        file=open(fileName,'r') 
+        fileLines = file.readlines()
+    finally:
+        file.close()    
+
+    colors=[]
+    points = []
+    normals = []
+    triangles = []
+
+    nf = 1.-2.*int(invertNormals) #+1 or -1 (inverted)
+    indOff = int(invertTriangles) #0 or 1 (inverted)
+
+    nLines = len(fileLines)
+    lineCnt = 0
+    if fileLines[lineCnt][0:5] != 'solid':
+        raise ValueError("GraphicsDataFromSTLfileTxt: expected 'solid ...' in first line, but received: " + fileLines[lineCnt])
+    lineCnt+=1
+    
+    if nLines > 500000:
+        print('large ascii STL file; switch to numpy-stl and binary format for faster loading!')
+
+    while lineCnt < nLines and fileLines[lineCnt].strip().split()[0] != 'endsolid':
+        if lineCnt%100000 == 0 and lineCnt !=0: 
+            if verbose: print("  read line",lineCnt," / ", len(fileLines))
+
+        normalLine = fileLines[lineCnt].split()
+        if normalLine[0] != 'facet' or normalLine[1] != 'normal':
+            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'facet normal ...' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+        if len(normalLine) != 5:
+            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'facet normal n0 n1 n2' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+        
+        normal = [nf*float(normalLine[2]),nf*float(normalLine[3]),nf*float(normalLine[4])]
+
+        lineCnt+=1
+        loopLine = fileLines[lineCnt].strip()
+        if loopLine != 'outer loop':
+            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'outer loop' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+
+        ind = int(len(points)/3) #index for points of this triangle
+        #get 3 vertices:
+        lineCnt+=1
+        for i in range(3):
+            readLine = fileLines[lineCnt].strip().split()
+            if readLine[0] != 'vertex':
+                raise ValueError("GraphicsDataFromSTLfileTxt: expected 'vertex ...' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+            if len(readLine) != 4:
+                raise ValueError("GraphicsDataFromSTLfileTxt: expected 'vertex v0 v1 v2' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+            
+            points+=[float(readLine[1]),float(readLine[2]),float(readLine[3])]
+            normals+=normal
+            colors+=color
+            lineCnt+=1
+            
+        triangles+=[ind,ind+1+indOff,ind+2-indOff] #indices of points; flip indices to match definition in EXUDYN
+
+        loopLine = fileLines[lineCnt].strip()
+        if loopLine != 'endloop':
+            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'endloop' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+        lineCnt+=1
+        loopLine = fileLines[lineCnt].strip()
+        if loopLine != 'endfacet':
+            raise ValueError("GraphicsDataFromSTLfileTxt: expected 'endfacet' in line "+str(lineCnt)+", but received: " + fileLines[lineCnt])
+        lineCnt+=1
+    
+    data = {'type':'TriangleList', 'colors':colors, 'normals':normals, 'points':points, 'triangles':triangles}
+    return data
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate graphics data from STL file, allowing text or binary format; requires numpy-stl to be installed; additionally can scale, rotate and translate
+#**input:
+#  fileName: string containing directory and filename of STL-file (in text / SCII format) to load
+#  color: provided as list of 4 RGBA values
+#  verbose: if True, useful information is provided during reading
+#  density: if given and if verbose, mass, volume, inertia, etc. are computed
+#  scale: point coordinates are transformed by scaling factor
+#  invertNormals: if True, orientation of normals (usually pointing inwards in STL mesh) are inverted for compatibility in Exudyn
+#  invertTriangles: if True, triangle orientation (based on local indices) is inverted for compatibility in Exudyn
+#**output: creates graphicsData, inverting the STL graphics regarding normals and triangle orientations (interchanged 2nd and 3rd component of triangle index)
+#**notes: the model is first scaled, then rotated, then the offset pOff is added; finally min, max, mass, volume, inertia, com are computed!
+def GraphicsDataFromSTLfile(fileName, color=[0.,0.,0.,1.], verbose=False, density=0., scale=1., Aoff=[], pOff=[], invertNormals=True, invertTriangles=True):
+    
+    try:
+        from stl import mesh
+    except:
+        raise ValueError('GraphicsDataFromSTLfile requires installation of numpy-stl; try "pip install numpy-stl"')
+    
+    data=mesh.Mesh.from_file(fileName)
+    nPoints = 3*len(data.points) #data.points has shape (nTrigs,9), one triangle has 3 points!
+    
+    if scale != 1.:
+        data.points *= scale
+    
+    p = copy.copy(pOff)
+    A = copy.deepcopy(Aoff) #deepcopy for list of lists
+    
+    if p != [] or A != []:
+        from exudyn.rigidBodyUtilities import HomogeneousTransformation
+        if p == []: p=[0,0,0]
+        if A == []: A=np.eye(3)
+        HT = HomogeneousTransformation(A, p)
+        
+        data.transform(HT)
+        
+    dictData = {}
+    if verbose:
+        print('GraphicsDataFromSTLfile:')
+        print('  max point=', list(data.max_))
+        print('  min point=', list(data.min_))
+        print('  STL points=', nPoints)
+    if density != 0:
+        [volume, mass, COM, inertia] = data.get_mass_properties_with_density(density)
+        dictData = {'minPos':data.min_,
+                    'maxPos':data.max_,
+                    'volume':volume,
+                    'mass':mass,
+                    'COM':COM,
+                    'inertia':inertia
+                    }
+    if verbose:
+        print('  volume =', volume)
+        print('  center of mass =', list(COM))
+        print('  inertia =', list(inertia))
+    
+    # print('STL points3=', nPoints3)
+    
+    colors = color*nPoints
+    #triangles = list(np.arange(0,nPoints))#wrong orientation ==> reverse
+    if invertTriangles:
+        triangles = list(np.arange(nPoints-1,-1,-1))#inverted sorting
+    else:
+        triangles = list(np.arange(0,nPoints))      #unmodified sorting of indices
+    points = list(data.points.flatten())
+    nf = 1.-2.*int(invertNormals) #+1 or -1 (inverted)
+    normals = list(np.kron([nf,nf,nf],data.normals).flatten()) #normals must be per point
+
+    dictGraphics = {'type':'TriangleList', 'colors':colors, 'normals':normals, 'points':points, 'triangles':triangles}
+    if density == 0:
+        return dictGraphics 
+    else:
+        return [dictGraphics, dictData]
+
+
+#**function: compute and return GraphicsData with edges and smoothend normals for mesh consisting of points and triangles (e.g., as returned from GraphicsData2PointsAndTrigs)
+#  graphicsData: single GraphicsData object of type TriangleList; existing edges are ignored
+#  edgeColor: optional color for edges
+#  edgeAngle: angle above which edges are added to geometry
+#  roundDigits: number of digits, relative to max dimensions of object, at which points are assumed to be equal
+#  smoothNormals: if True, algorithm tries to smoothen normals at vertices; otherwise, uses triangle normals
+#  addEdges: if True, edges are added in TriangleList of GraphicsData 
+#  triangleColor: if triangleColor is set to a RGBA color, this color is used for the new triangle mesh throughout
+#**output: returns GraphicsData with added edges and smoothed normals
+#**notes: this function is suitable for STL import; it assumes that all colors in graphicsData are the same and only takes the first color!
+def AddEdgesAndSmoothenNormals(graphicsData, edgeColor = color4black, edgeAngle = 0.25*pi,
+                           pointTolerance=5, addEdges=True, smoothNormals=True, roundDigits=5, 
+                           triangleColor = []):
+    from math import acos # ,sin, cos
+
+    oldColors = copy.copy(graphicsData['colors']) #2022-12-06: accepts now all colors; graphicsData['colors'][0:4]    
+    [points, trigs]=GraphicsData2PointsAndTrigs(graphicsData)
+    # [points, trigs]=RefineMesh(points, trigs)
+
+    nPoints = len(points)
+    nColors = int(len(oldColors)/4)
+
+    triangleColorNew = list(triangleColor)
+
+    if nColors != nPoints:
+        print('WARNING: AddEdgesAndSmoothenNormals: found inconsistent colors; they must match the point list in graphics data')
+        if triangleColorNew == []:
+            triangleColorNew = graphicsData['colors'][0:4]
+
+    if len(triangleColorNew) != 4 and len(triangleColorNew) != 0:
+        triangleColorNew = [1,0,0,1]
+        print('WARNING: AddEdgesAndSmoothenNormals: colors invalid; using default')
+
+    if len(triangleColorNew) == 4:
+        oldColors = list(triangleColorNew)*nPoints
+
+    colors = [np.zeros(4)]*nPoints
+    for i in range(nPoints):
+        colors[i] = np.array(oldColors[i*4:i*4+4])
+    
+    points = np.array(points)
+    trigs = np.array(trigs)
+    colors = np.array(colors)
+    pMax = np.max(points, axis=0)
+    pMin = np.min(points, axis=0)
+    maxDim = np.linalg.norm(pMax-pMin)
+    if maxDim == 0: maxDim = 1.
+
+    points = maxDim * np.round(points*(1./maxDim),roundDigits)
+    # print('smoothen np=', nPoints)
+    
+    sortIndices = np.lexsort((points[:,2], points[:,1], points[:,0]))
+    #sortedPoints = points[sortIndices]
+    
+    #now eliminate duplicate points:
+    remap = np.zeros(nPoints,dtype=int)#np.int64)
+    remap[0] = 0
+    newPoints = [points[sortIndices[0],:]] #first point
+    newColors = [colors[sortIndices[0],:]]
+    
+    cnt = 0
+    for i in range(len(sortIndices)-1):
+        nextIndex = sortIndices[i+1]
+        if (points[nextIndex] != points[sortIndices[i]]).any():
+            # newIndices.append(nextIndex)
+            cnt+=1
+            remap[nextIndex] = cnt#i+1
+            newPoints.append(points[nextIndex,:])
+            newColors.append(colors[nextIndex,:])
+        else:
+            remap[nextIndex] = cnt#newIndices[sortIndices[i]]
+            # newIndices.append(newIndices[-1])
+    newPoints = np.array(newPoints)
+    newTrigs = remap[trigs]
+    
+    #==> now we (hopefully have connected triangle lists)
+    
+    nPoints = len(newPoints)
+    nTrigs = len(newTrigs)
+    
+    #create points2trigs lists:
+    points2trigs = [[] for i in range(nPoints)] #[[]]*nPoints does not work!!!!
+    for cntTrig, trig in enumerate(newTrigs):
+        for ind in trig:
+            points2trigs[ind].append(cntTrig)
+    
+    #now find neighbours, compute triangle normals:
+    neighbours = np.zeros((nTrigs,3),dtype=int)
+    # neighbours[:,:] = -1#check if all neighbours found
+    normals = np.zeros((nTrigs,3)) #per triangle
+    areas = np.zeros(nTrigs)
+    for cntTrig, trig in enumerate(newTrigs):
+        normals[cntTrig,:] = ComputeTriangleNormal(newPoints[trig[0]], newPoints[trig[1]], newPoints[trig[2]])
+        areas[cntTrig] = ComputeTriangleArea(newPoints[trig[0]], newPoints[trig[1]], newPoints[trig[2]])
+        for cntNode in range(3):
+            ind  = trig[cntNode]
+            ind2 = trig[(cntNode+1)%3]
+            for t in points2trigs[ind]:
+                #if t <= cntTrig: continue #too much sorted out; check why
+                trig2=newTrigs[t]
+                found = False
+                for cntNode2 in range(3):
+                    if trig2[cntNode2] == ind2 and trig2[(cntNode2+1)%3] == ind:
+                        neighbours[cntTrig, cntNode] = t
+                        found = True
+                        #print('neighbours ', cntTrig, t)
+                        break
+                if found: break
+    
+    #create edges:
+    edges = [] #list of edge points
+    pointHasEdge = [False]*nPoints
+    for cntTrig, trig in enumerate(newTrigs):
+        for cntNode in range(3):
+            ind1  = trig[cntNode]
+            ind2 = trig[(cntNode+1)%3]
+            if ind1 > ind2:
+                val = normals[cntTrig] @ normals[neighbours[cntTrig,cntNode]]
+                if abs(val) > 1: val = np.sign(val) #because of float32 problems
+                angle = acos(val)
+                if angle >= edgeAngle:
+                    edges+=[ind1, ind2]
+                    pointHasEdge[ind1] = True
+                    pointHasEdge[ind2] = True
+    
+    
+    #smooth normals:
+    #we simply do not smooth at points that have edges
+    if smoothNormals:
+        pointNormals = np.zeros((nPoints,3))
+        for i in range(nPoints):
+            if not pointHasEdge[i]:
+                normal = np.zeros(3)
+                for t in points2trigs[i]:
+                    normal += areas[t]*normals[t]
+                
+                pointNormals[i] = ebu.Normalize(normal)
+
+        
+        finalTrigs = []
+        newPoints = list(newPoints)
+        newColors = list(newColors)
+        pointNormals = list(pointNormals)
+        for cnt, trig in enumerate(newTrigs):
+            trigNew = [0,0,0]
+            for i in range(3):
+                if not pointHasEdge[trig[i]]:
+                    trigNew[i] = trig[i]
+                else:
+                    trigNew[i] = len(newPoints)
+                    newPoints.append(newPoints[trig[i]])
+                    pointNormals.append(normals[cnt])
+                    newColors.append(newColors[trig[i]])
+            finalTrigs += [trigNew]
+    else:
+        finalTrigs = newTrigs
+    
+    graphicsData2 = GraphicsDataFromPointsAndTrigs(newPoints, finalTrigs, list(np.array(newColors).flatten()))
+    if addEdges:
+        graphicsData2['edges'] = edges
+        graphicsData2['edgeColor'] = list(edgeColor)
+
+    if smoothNormals:
+        graphicsData2['normals'] = list(np.array(pointNormals).flatten())
+    
+    return graphicsData2
+
+#**function: export given graphics data (only type TriangleList allowed!) to STL ascii file using fileName
+#**input:
+#  graphicsData: a single GraphicsData dictionary with type='TriangleList', no list of GraphicsData
+#  fileName: file name including (local) path to export STL file
+#  solidName: optional name used in STL file
+#  invertNormals: if True, orientation of normals (usually pointing inwards in STL mesh) are inverted for compatibility in Exudyn
+#  invertTriangles: if True, triangle orientation (based on local indices) is inverted for compatibility in Exudyn
+def ExportGraphicsData2STL(graphicsData, fileName, solidName='ExudynSolid', invertNormals=True, invertTriangles=True):
+    if graphicsData['type'] != 'TriangleList':
+        raise ValueError('ExportGraphicsData2STL: invalid graphics data type; only TriangleList allowed')
+        
+    with open(fileName, 'w') as f:
+        f.write('solid '+solidName+'\n')
+
+        nTrig = int(len(graphicsData['triangles'])/3)
+        triangles = graphicsData['triangles']
+    
+        for k in range(nTrig):
+            p = [] #triangle points
+            for i in range(3):
+                ind = triangles[k*3+i]
+                p += [np.array(graphicsData['points'][ind*3:ind*3+3])]
+   
+            n = ComputeTriangleNormal(p[0], p[1], p[2])
+            
+            f.write('facet normal '+str(-n[0]) + ' ' + str(-n[1]) + ' ' + str(-n[2]) + '\n') #normals inverted
+            f.write('outer loop\n')
+            f.write('vertex '+str(p[0][0]) + ' ' + str(p[0][1]) + ' ' + str(p[0][2]) + '\n')
+            f.write('vertex '+str(p[2][0]) + ' ' + str(p[2][1]) + ' ' + str(p[2][2]) + '\n') #point index reversed!
+            f.write('vertex '+str(p[1][0]) + ' ' + str(p[1][1]) + ' ' + str(p[1][2]) + '\n')
+                
+            f.write('endloop\n')
+            f.write('endfacet\n')
+
+        f.write('endsolid '+solidName+'\n')
+
+            
+    # data = {'type':'TriangleList', 'colors':colors, 
+    #         'normals':normals, 
+    #         'points':points, 'triangles':triangles}
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#   unused argument yet: contourNormals: if provided as list of 2D vectors, they prescribe the normals to the contour for smooth visualization; otherwise, contour is drawn flat
+#**function: generate graphics data for a solid of revolution with given 3D point and axis, 2D point list for contour, (optional)2D normals and color; 
+#**input:
+#  pAxis: axis point of one face of solid of revolution (3D list or np.array)
+#  vAxis: vector representing the solid of revolution's axis (3D list or np.array)
+#  contour: a list of 2D-points, specifying the contour (x=axis, y=radius), e.g.: [[0,0],[0,0.1],[1,0.1]]
+#  color: provided as list of 4 RGBA values
+#  nTiles: used to determine resolution of solid; use larger values for finer resolution
+#  smoothContour: if True, the contour is made smooth by auto-computing normals to the contour
+#  addEdges: True or number of edges along revolution mantle; for optimal drawing, nTiles shall be multiple addEdges
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#  alternatingColor: add a second color, which enables to see the rotation of the solid
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+#**example:
+##simple contour, using list of 2D points:
+#contour=[[0,0.2],[0.3,0.2],[0.5,0.3],[0.7,0.4],[1,0.4],[1,0.]]
+#rev1 = GraphicsDataSolidOfRevolution(pAxis=[0,0.5,0], vAxis=[1,0,0], 
+#                                     contour=contour, color=color4red,
+#                                     alternatingColor=color4grey)
+##draw torus:
+#contour=[]
+#r = 0.2 #small radius of torus
+#R = 0.5 #big radius of torus
+#nc = 16 #discretization of torus
+#for i in range(nc+3): #+3 in order to remove boundary effects
+#    contour+=[[r*cos(i/nc*pi*2),R+r*sin(i/nc*pi*2)]]
+#
+##use smoothContour to make torus looking smooth
+#rev2 = GraphicsDataSolidOfRevolution(pAxis=[0,0.5,0], vAxis=[1,0,0], 
+#                                     contour=contour, color=color4red, 
+#                                     nTiles = 64, smoothContour=True)
+def GraphicsDataSolidOfRevolution(pAxis, vAxis, contour, color=[0.,0.,0.,1.], nTiles = 16, smoothContour = False, 
+                                  addEdges = False, edgeColor=color4black, addFaces=True, **kwargs):  
+
+    if len(contour) < 2: 
+        raise ValueError("ERROR: GraphicsDataSolidOfRevolution: contour must contain at least 2 points")
+    if nTiles < 3: 
+        print("WARNING: GraphicsDataSolidOfRevolution: nTiles < 3: set nTiles=3")
+
+    p0 = np.array(pAxis)
+    #local coordinate system:
+    [v,n1,n2] = ComputeOrthonormalBasisVectors(vAxis)
+
+    color2 = list(color)
+    if 'alternatingColor' in kwargs:
+        color2 = kwargs['alternatingColor']
+
+    #compute contour normals, assuming flat cones
+    contourNormals = []
+    for j in range(len(contour)-1):
+        pc0 = np.array(contour[j])
+        pc1 = np.array(contour[j+1])
+        vc = pc1-pc0
+        nc = ebu.Normalize([-vc[1],vc[0]])
+        contourNormals += [nc]
+    contourNormals += [contourNormals[-1]] #normal for last point same as previous
+
+    if smoothContour:
+        contourNormals2 = [contourNormals[0]]
+        for j in range(len(contour)-1):
+            ns = ebu.Normalize(np.array(contourNormals[j]) + np.array(contourNormals[j+1])) #not fully correct, but sufficient
+            contourNormals2 += [list(ns)]
+        contourNormals = contourNormals2
+
+    points = []
+    normals = []
+    colors = []
+    nT2 = int(nTiles/2)
+    nf = normalsFactor #factor for normals (inwards/outwards)
+
+    for j in range(len(contour)-1):
+        pc0 = np.array(contour[j])
+        pc1 = np.array(contour[j+1])
+        points0 = []
+        points1 = []
+        normals0 = []
+        normals1 = []
+        for i in range(nTiles):
+            phi = i*2*pi/nTiles
+            x0 = pc0[1]*sin(phi)
+            y0 = pc0[1]*cos(phi)
+            vv0 = x0*n1 + y0*n2
+
+            x1 = pc1[1]*sin(phi)
+            y1 = pc1[1]*cos(phi)
+            vv1 = x1*n1 + y1*n2
+
+            pz0 = p0 + vv0 + pc0[0]*v
+            pz1 = p0 + vv1 + pc1[0]*v
+            points0 += list(pz0)
+            points1 += list(pz1)
+
+            #vc = pc1-pc0
+            #nc = [-vc[1],vc[0]]
+            nc0 = contourNormals[j]
+            nUnit0 = ebu.Normalize(nf*nc0[1]*sin(phi)*n1 + nf*nc0[1]*cos(phi)*n2+nf*nc0[0]*v)
+            nUnit1 = nUnit0
+            if smoothContour:
+                nc1 = contourNormals[j+1]
+                nUnit1 = ebu.Normalize(nf*nc1[1]*sin(phi)*n1 + nf*nc1[1]*cos(phi)*n2+nf*nc1[0]*v)
+
+            normals0 = normals0 + nUnit0
+            normals1 = normals1 + nUnit1
+
+        cList = list(color)*nT2 + list(color2)*(nTiles-nT2)
+        colors += cList+cList
+        points += points0 + points1
+        normals += normals0 + normals1
+    
+    triangles = []
+    n = nTiles
+    #circumference:
+    if addFaces:
+        for j in range(len(contour)-1):
+            k = j*2*n
+            for i in range(nTiles):
+                if i < nTiles-1:
+                    triangles += [i+k,n+i+k+1,n+i+k]
+                    triangles += [i+k,i+1+k,n+i+k+1]
+                else:
+                    triangles += [i+k,n+k,n+i+k]
+                    triangles += [i+k,k,n+k]
+
+    #triangle normals point inwards to object ...
+    data = {'type':'TriangleList', 'colors':colors, 
+            'normals':normals, 
+            'points':points, 'triangles':triangles}
+
+
+    if addEdges > 0:
+        data['edgeColor'] = list(edgeColor)
+        edges = []
+
+        cntEdges = 0        
+        nSteps = nTiles
+        if type(addEdges) != bool and addEdges > 0:
+            cntEdges = int(addEdges)
+            nSteps = int(nTiles/cntEdges)
+        
+        hEdges = []
+        for j in range(cntEdges):
+            hEdges += [[]]
+
+        for j in range(len(contour)-1):
+            k = j*2*n
+            for i in range(nTiles):
+                edges += [i+k, (i+1)%nTiles+k]
+                if i%nSteps==0:
+                    j=int(i/nSteps)
+                    if j < cntEdges:
+                        hEdges[j] += [i+k, i+k+n]
+
+        for j in range(cntEdges):
+            edges += hEdges[j]
+
+        data['edges'] = edges
+
+    return data
+
+
+#**function: generate graphics data for an arrow with given origin, axis, shaft radius, optional size factors for head and color; nTiles gives the number of tiles (minimum=3)
+#**input:
+#  pAxis: axis point of the origin (base) of the arrow (3D list or np.array)
+#  vAxis: vector representing the vector pointing from the origin to the tip (head) of the error (3D list or np.array)
+#  radius: positive value representing radius of shaft cylinder
+#  headFactor: positive value representing the ratio between head's radius and the shaft radius
+#  headStretch: positive value representing the ratio between the head's radius and the head's length
+#  color: provided as list of 4 RGBA values
+#  nTiles: used to determine resolution of arrow (of revolution object) >=3; use larger values for finer resolution
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataArrow(pAxis, vAxis, radius, color=[0.,0.,0.,1.], headFactor = 2, headStretch = 4, nTiles = 12):  
+    L = ebu.NormL2(vAxis)
+    rHead = radius * headFactor
+    xHead = L - headStretch*rHead
+    contour=[[0,0],[0,radius],[xHead,radius],[xHead,rHead],[L,0]]
+    return GraphicsDataSolidOfRevolution(pAxis=pAxis, vAxis=vAxis, contour=contour, color=color, nTiles=nTiles)
+
+#**function: generate graphics data for three arrows representing an orthogonal basis with point of origin, shaft radius, optional size factors for head and colors; nTiles gives the number of tiles (minimum=3)
+#**input:
+#  origin: point of the origin of the base (3D list or np.array)
+#  rotationMatrix: optional transformation, which rotates the basis vectors
+#  length: positive value representing lengths of arrows for basis
+#  colors: provided as list of 3 colors (list of 4 RGBA values)
+#  headFactor: positive value representing the ratio between head's radius and the shaft radius
+#  headStretch: positive value representing the ratio between the head's radius and the head's length
+#  nTiles: used to determine resolution of arrows of basis (of revolution object) >=3; use larger values for finer resolution
+#  radius: positive value representing radius of arrows; default: radius = 0.01*length
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataBasis(origin=[0,0,0], rotationMatrix = np.eye(3), length = 1, colors=[color4red, color4green, color4blue], 
+                      headFactor = 2, headStretch = 4, nTiles = 12, **kwargs):  
+    radius = 0.01*length
+    if 'radius' in kwargs:
+        radius = kwargs['radius']
+
+    A = np.array(rotationMatrix)
+    g1 = GraphicsDataArrow(origin,A@[length,0,0],radius, colors[0], headFactor, headStretch, nTiles)
+    g2 = GraphicsDataArrow(origin,A@[0,length,0],radius, colors[1], headFactor, headStretch, nTiles)
+    g3 = GraphicsDataArrow(origin,A@[0,0,length],radius, colors[2], headFactor, headStretch, nTiles)
+
+    return MergeGraphicsDataTriangleList(MergeGraphicsDataTriangleList(g1,g2),g3)
+
+#**function: generate graphics data for frame (similar to GraphicsDataBasis), showing three arrows representing an orthogonal basis for the homogeneous transformation HT; optional shaft radius, optional size factors for head and colors; nTiles gives the number of tiles (minimum=3)
+#**input:
+#  HT: homogeneous transformation representing frame
+#  length: positive value representing lengths of arrows for basis
+#  colors: provided as list of 3 colors (list of 4 RGBA values)
+#  headFactor: positive value representing the ratio between head's radius and the shaft radius
+#  headStretch: positive value representing the ratio between the head's radius and the head's length
+#  nTiles: used to determine resolution of arrows of basis (of revolution object) >=3; use larger values for finer resolution
+#  radius: positive value representing radius of arrows; default: radius = 0.01*length
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataFrame(HT=np.eye(4), length = 1, colors=[color4red, color4green, color4blue], 
+                      headFactor = 2, headStretch = 4, nTiles = 12, **kwargs):  
+    radius = 0.01*length
+    if 'radius' in kwargs:
+        radius = kwargs['radius']
+
+    
+    A = HT2rotationMatrix(HT)
+    origin = HT2translation(HT)
+    
+    g1 = GraphicsDataArrow(origin,A@[length,0,0],radius, colors[0], headFactor, headStretch, nTiles)
+    g2 = GraphicsDataArrow(origin,A@[0,length,0],radius, colors[1], headFactor, headStretch, nTiles)
+    g3 = GraphicsDataArrow(origin,A@[0,0,length],radius, colors[2], headFactor, headStretch, nTiles)
+
+    return MergeGraphicsDataTriangleList(MergeGraphicsDataTriangleList(g1,g2),g3)
+
+
+#**function: generate graphics data for simple quad with option for checkerboard pattern;
+#  points are arranged counter-clock-wise, e.g.: p0=[0,0,0], p1=[1,0,0], p2=[1,1,0], p3=[0,1,0]
+#**input: 
+#  pList: list of 4 quad points [[x0,y0,z0],[x1,y1,z1],...]
+#  color: provided as list of 4 RGBA values
+#  alternatingColor: second color; if defined, a checkerboard pattern (default: 10x10) is drawn with color and alternatingColor
+#  nTiles: number of tiles for checkerboard pattern (default: 10)
+#  nTilesY: if defined, use number of tiles in y-direction different from x-direction (=nTiles)
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+#**example:
+#plane = GraphicsDataQuad([[-8, 0, -8],[ 8, 0, -8,],[ 8, 0, 8],[-8, 0, 8]], 
+#                         color4darkgrey, nTiles=8, 
+#                         alternatingColor=color4lightgrey)
+#oGround=mbs.AddObject(ObjectGround(referencePosition=[0,0,0],
+#                      visualization=VObjectGround(graphicsData=[plane])))
+def GraphicsDataQuad(pList, color=[0.,0.,0.,1.], **kwargs): 
+
+    color2 = list(color)
+    nTiles = 1
+    if 'alternatingColor' in kwargs:
+        color2 = kwargs['alternatingColor']
+        nTiles = 10
+
+    if 'nTiles' in kwargs:
+        nTiles = kwargs['nTiles']
+    nTilesY= nTiles
+    if 'nTilesY' in kwargs:
+        nTilesY = kwargs['nTilesY']
+
+    p0 = np.array(pList[0])
+    p1 = np.array(pList[1])
+    p2 = np.array(pList[2])
+    p3 = np.array(pList[3])
+
+    points = []
+    triangles = []
+    #points are given always for 1 quad of checkerboard pattern
+    ind = 0
+    for j in range(nTilesY):
+        for i in range(nTiles):
+            f0 = j/(nTilesY)
+            f1 = (j+1)/(nTilesY)
+            pBottom0 = (nTiles-i)/nTiles  *((1-f0)*p0 + f0*p3) + (i)/nTiles  *((1-f0)*p1 + f0*p2)
+            pBottom1 = (nTiles-i-1)/nTiles*((1-f0)*p0 + f0*p3) + (i+1)/nTiles*((1-f0)*p1 + f0*p2)
+            pTop0 = (nTiles-i)/nTiles  *((1-f1)*p0 + f1*p3) + (i)/nTiles  *((1-f1)*p1 + f1*p2)
+            pTop1 = (nTiles-i-1)/nTiles*((1-f1)*p0 + f1*p3) + (i+1)/nTiles*((1-f1)*p1 + f1*p2)
+            points += list(pBottom0)+list(pBottom1)+list(pTop1)+list(pTop0)
+            #points += list(p0)+list(p1)+list(p2)+list(p3)
+            triangles += [0+ind,1+ind,2+ind,  0+ind,2+ind,3+ind]
+            ind+=4
+
+    colors=[]
+    for j in range(nTilesY):
+        for i in range(nTiles):
+            a=1
+            if i%2 == 1:
+                a=-1
+            if j%2 == 1:
+                a=-1*a
+            if a==1:
+                c = list(color) #if no checkerboard pattern, just this color
+            else:
+                c = color2
+            colors=colors+c+c+c+c #4 colors for one sub-quad
+
+    data = {'type':'TriangleList', 'colors': colors, 'points':points, 'triangles':triangles}
+    #print(data)
+    return data
+
+
+#**function: function to generate checkerboard background;
+#  points are arranged counter-clock-wise, e.g.: 
+#**input: 
+#  point: midpoint of pattern provided as list or np.array
+#  normal: normal to plane provided as list or np.array
+#  size: dimension of first side length of quad
+#  size2: dimension of second side length of quad
+#  color: provided as list of 4 RGBA values
+#  alternatingColor: second color; if defined, a checkerboard pattern (default: 10x10) is drawn with color and alternatingColor
+#  nTiles: number of tiles for checkerboard pattern in first direction
+#  nTiles2: number of tiles for checkerboard pattern in second direction; default: nTiles
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+#**example:
+#plane = GraphicsDataCheckerBoard(normal=[0,0,1], size=5)
+#oGround=mbs.AddObject(ObjectGround(referencePosition=[0,0,0],
+#                      visualization=VObjectGround(graphicsData=[plane])))
+def GraphicsDataCheckerBoard(point=[0,0,0], normal=[0,0,1], size = 1,
+                             color=color4lightgrey, alternatingColor=color4lightgrey2, nTiles=10, **kwargs):
+    nTiles2 = nTiles
+    if 'nTiles2' in kwargs:
+        nTiles2 = kwargs['nTiles2']
+    size2 = size
+    if 'size2' in kwargs:
+        size2 = kwargs['size2']
+
+    [v,n1,n2] = ComputeOrthonormalBasisVectors(normal)
+    p0=np.array(point)
+    points = [list(p0-0.5*size*n1-0.5*size2*n2),
+              list(p0+0.5*size*n1-0.5*size2*n2),
+              list(p0+0.5*size*n1+0.5*size2*n2),
+              list(p0-0.5*size*n1+0.5*size2*n2)]
+
+    return GraphicsDataQuad(points, color=list(color), alternatingColor=alternatingColor, 
+                            nTiles=nTiles, nTilesY=nTiles2)
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to compute triangular mesh from list of vertices (=points) and segments;
+#   computes triangular meshes for non-convex case. In order to make it efficient, it first computes
+#   neighbors and then defines triangles at segments to be inside/outside. Finally neighboring
+#   relations are used to define all triangles inside/outside
+#   finally only returns triangles that are inside the segments
+#**input:
+#  vertices: list of pairs of coordinates of vertices in mesh [x,y]
+#  segments: list of segments, which are pairs of node numbers [i,j], defining the boundary of the mesh;
+#            the ordering of the nodes is such that left triangle = inside, right triangle = outside, compare example with segment [V1,V2]:\\
+#  
+#     inside
+#  V1         V2
+#  O----------O
+#    outside
+#**output:
+#  triangulation structure of Delaunay(...), see scipy.spatial.Delaunaystructure, containing all simplices (=triangles)
+#**notes: Delauney will not work if points are duplicated; you must first create point lists without duplicated points!
+#**example:
+# points = np.array([[0, 0], [0, 2], [2, 2], [2, 1], [1, 1], [0, 1], [1, 0]])
+# segments = [len(points)-1,0]
+# for i in range(len(points)-1):
+#     segments += [i,i+1]
+# tri = ComputeTriangularMesh(points, segments)
+# print(tri.simplices)
+def ComputeTriangularMesh(vertices, segments):
+    from scipy.spatial import Delaunay
+    from copy import deepcopy
+
+    nVertices = len(vertices)
+    tri = Delaunay(np.array(vertices))
+    trigs = deepcopy(tri.simplices)
+    
+    #+++++++++++++++++++++++++++++++++
+    #compute vertices2simplices list:
+    vertices2simplices = [[]]*nVertices
+    cnt = 0
+    for trig in trigs:
+        for i in trig:
+            alist=list(vertices2simplices[i])
+            alist.append(cnt)
+            vertices2simplices[i] = alist    
+        cnt += 1 #trig counter
+        
+    #print(trigs)
+    #print(vertices2simplices)
+    
+    #+++++++++++++++++++++++++++++++++
+    #compute neighbors:
+    trigNeighbors = 0*trigs #-1 means no neighbor trig!
+    trigNeighbors[:,:] = -1
+    #run over all triangles
+    for i in range(len(trigs)):
+        for j in range(3):
+            i0 = trigs[i,j]
+            i1 = trigs[i,(j+1)%3]
+            #actSeg = [i0, i1]
+            listTest = vertices2simplices[i0] + vertices2simplices[i1]
+            for trigIndex in listTest:
+                if trigIndex < i:
+                    for k in range(3):
+                        t0 = trigs[trigIndex, k]
+                        t1 = trigs[trigIndex, (k+1)%3]
+                        if (i0 == t1) and (i1 == t0): #opposite trig orientation is reversed ...
+                            trigNeighbors[i,j] = trigIndex
+                            trigNeighbors[trigIndex,k] = i
+
+    #print("neighbors=", trigNeighbors)                
+
+    #+++++++++++++++++++++++++++++++++
+    #compute inside triangles:
+    trianglesInside = [-1]*len(trigs) #-1 is undefined, 0=outside, 1=inside
+    
+    for seg in segments: #triangles left to segment are inside
+        listTest = vertices2simplices[seg[0]] + vertices2simplices[seg[1]]
+        for trigIndex in listTest:
+            for k in range(3):
+                t0 = trigs[trigIndex, k]
+                t1 = trigs[trigIndex, (k+1)%3]
+                if (seg[0] == t0) and (seg[1] == t1): #inside triangle
+                    trianglesInside[trigIndex] = 1
+                elif (seg[0] == t1) and (seg[1] == t0): #outside triangle
+                    trianglesInside[trigIndex] = 0
+    #print(trianglesInside)
+
+    #finally find remaining triangles (usually all triangles are on boundary, so nothing remains):
+    undefinedTrigs = True
+    while undefinedTrigs: #iterate as long as there are undefined triangles; usually only few iterations necessary
+        undefinedTrigs = False
+        #print("iterate neighbors")
+        for i in range(len(trigs)):
+            if trianglesInside[i] == -1: #still undefined
+                found = False
+                for j in range(3): #look at all neighbors
+                    tn = trigNeighbors[i, j]
+                    if trianglesInside[tn] != -1:
+                        trianglesInside[i] = trianglesInside[tn]
+                        found = True
+                if not found:
+                    undefinedTrigs = True
+
+    #now create new list of interior triangles
+    interiorTrigs = []
+    for i in range(len(trigs)):
+        if trianglesInside[i] == 1: 
+            interiorTrigs += [list(trigs[i])]
+    #print("interiorTrigs=",interiorTrigs)
+    
+    tri.simplices = np.array(interiorTrigs)
+    
+    return tri
+
+#**function: convert point list into segments (indices to points); point indices start with pointIndexOffset
+#**input:
+#  invert: True: circle defines outter boundary; False: circle cuts out geometry inside a geometry
+#  pointIndexOffset: point indices start with pointIndexOffset
+#**output: return segments, containing list of lists of point indices for segments
+def SegmentsFromPoints(points, pointIndexOffset = 0, invert=False, closeCurve=True):
+    n = len(points)
+    segments = np.zeros((n,2),dtype=int)
+    if invert:
+        for i in reversed(range(n-1)):
+            segments[i,:] = [i+1, i]
+    else:
+        for i in range(n-1):
+            segments[i,:] = [i, i+1]
+
+    if closeCurve:
+        if invert:
+            segments[n-1,:] = [0, n-1] #close segments
+        else:
+            segments[n-1,:] = [n-1, 0] #close segments
+
+    return segments
+
+#**function: create points and segments, used in GraphicsDataSolidExtrusion(...) for circle with given parameters
+#**input:
+#  center: 2D center point (list/numpy array) for circle center
+#  radius: radius of circle
+#  invert: True: circle defines outter boundary; False: circle cuts out geometry inside a geometry
+#  pointIndexOffset: point indices start with pointIndexOffset
+#  nTiles: number of tiles/segments for circle creation (higher is finer)
+#**output: return [points, segments], both containing lists of lists
+#**notes: geometries may not intersect!
+def CirclePointsAndSegments(center=[0,0], radius=0.1, invert = False, pointIndexOffset=0, nTiles=16):
+    segments = np.zeros((nTiles,2),dtype=int)
+    points = np.zeros((nTiles,2))
+    
+    if invert:
+        myRange = reversed(range(nTiles))
+    else:
+        myRange = range(nTiles)
+        
+    for i in range(nTiles):
+        phi = i/nTiles*2*pi
+        points[i,:] = [radius*sin(phi)+center[0], radius*cos(phi)+center[1]]
+        segments[i,:] = [(i+int(invert))%nTiles+pointIndexOffset, (i+1-int(invert))%nTiles+pointIndexOffset]
+
+    segments = segments.tolist()
+    points = points.tolist()
+        
+    return [points, segments]
+
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: create graphicsData for solid extrusion based on 2D points and segments; by default, the extrusion is performed in z-direction;
+#            additional transformations are possible to translate and rotate the extruded body;
+#**input:
+#  vertices: list of pairs of coordinates of vertices in mesh [x,y], see ComputeTriangularMesh(...)
+#  segments: list of segments, which are pairs of node numbers [i,j], defining the boundary of the mesh;
+#            the ordering of the nodes is such that left triangle = inside, right triangle = outside; see ComputeTriangularMesh(...)
+#  height:   height of extruded object
+#  rot:      rotation matrix, which the extruded object point coordinates are multiplied with before adding offset
+#  pOff:     3D offset vector added to extruded coordinates; the z-coordinate of the extrusion object obtains 0 for the base plane, z=height for the top plane
+#  smoothNormals: if True, algorithm tries to smoothen normals at vertices and normals are added; creates more points; if False, triangle normals are used internally 
+#  addEdges: if True or 1, edges at bottom/top are included in the GraphicsData dictionary; if 2, also mantle edges are included
+#  edgeColor: optional color for edges
+#  addFaces: if False, no faces are added (only edges)
+#**output: graphicsData dictionary, to be used in visualization of EXUDYN objects
+def GraphicsDataSolidExtrusion(vertices, segments, height, rot = np.diag([1,1,1]), pOff = [0,0,0], color = [0,0,0,1],
+                               smoothNormals = False, addEdges = False, edgeColor=color4black, addFaces=True):
+    n = len(vertices)
+    n2 = n*2 #total number of vertices
+    ns = len(segments)
+    colors=[]
+    for i in range(n2):
+        colors+=color
+
+    edges = []
+    mantleEdges = (addEdges == 2)
+
+    points = [[]]*n2
+    for i in range(n):
+        points[i] = [vertices[i][0],vertices[i][1],0]
+    for i in range(n):
+        points[i+n] = [vertices[i][0],vertices[i][1],height]
+
+    if addEdges: #second set of points for top/bottom faces
+        edges = [[]]*(ns*2)
+        for cnt, seg in enumerate(segments):
+            edges[cnt] = [seg[0], seg[1]]
+            edges[cnt+ns] = [seg[0]+n, seg[1]+n]
+
+    edges = list(np.array(edges).flatten())
+    if smoothNormals: #second set of points for top/bottom faces
+        #pointNormals = [[]]*(2*n2)
+        for i in range(n2):
+            colors+=color
+        pointNormals = np.zeros((2*n2,3))
+
+        #add normals from segments:
+        for seg in segments:
+            dirSeg = ebu.Normalize(np.array(vertices[seg[1]]) - np.array(vertices[seg[0]]))
+            dirSeg3D = [dirSeg[1], -dirSeg[0], 0.] #this way points outwards ...
+            pointNormals[seg[0]+2*n,:] += dirSeg3D
+            pointNormals[seg[1]+2*n,:] += dirSeg3D
+            pointNormals[seg[0]+3*n,:] += dirSeg3D
+            pointNormals[seg[1]+3*n,:] += dirSeg3D
+        
+        for i in range(n2):
+            lenSeg = ebu.NormL2(pointNormals[i,:])
+            if lenSeg != 0.:
+                pointNormals[i,:] = (1/lenSeg)*pointNormals[i,:]
+            
+        points2 = [[]]*n2
+        for i in range(n):
+            points2[i] = [vertices[i][0],vertices[i][1],0.]
+            pointNormals[i+0*n,:] = [0.,0.,-1.]
+            #pointNormals[i+2*n,:] = [0,0,-1]
+        for i in range(n):
+            points2[i+n] = [vertices[i][0],vertices[i][1],height]
+            pointNormals[i+1*n,:] = [0.,0.,1.]
+            #pointNormals[i+3*n,:] = [0,0,1]
+        
+
+    #transform points:
+    pointsTransformed = []
+    npRot = np.array(rot)
+    npPoff = np.array(pOff)
+
+    for i in range(n2):
+        p = np.array(npRot @ points[i] + npPoff)
+        pointsTransformed += list(p)
+    
+    if smoothNormals: #these are the points with normals from top/bottom surface
+        for i in range(n2):
+            p = np.array(npRot @ points2[i] + npPoff)
+            pointsTransformed += list(p)
+
+    #compute triangulation:
+    tri = ComputeTriangularMesh(vertices, segments)
+    trigs = tri.simplices
+    nt =len(trigs)
+    trigList = [[]] * (nt*2+ns*2) #top trigs, bottom trigs, circumference trigs (2 per quad)
+    
+    for i in range(nt):
+        #print(list(trigs[i]))
+        # trigList[i] = list(trigs[i])
+        t = list(trigs[i])
+        t.reverse()
+        trigList[i] = copy.copy(t)
+    for i in range(nt):
+        t = list(trigs[i]+n)
+        # t.reverse()
+        trigList[i+nt] = copy.copy(t)
+        
+    #print("ns=",ns)
+    #print("nt=",nt)
+    off = n2*int(smoothNormals)
+    for i in range(ns):
+        trigList[2*nt+2*i  ] = [segments[i][0]+off,segments[i][1]+off,  segments[i][1]+n+off]
+        trigList[2*nt+2*i+1] = [segments[i][0]+off,segments[i][1]+n+off,segments[i][0]+n+off]
+
+        if mantleEdges:
+            edges += [segments[i][0]+off,segments[i][0]+n+off]
+
+    #print("trigList=",trigList)
+    triangles = []
+    if addFaces:
+        for t in trigList:
+            triangles += t
+   
+    data = {'type':'TriangleList', 'colors': colors, 'points':pointsTransformed, 'triangles':triangles}
+    if addEdges:
+        data['edgeColor'] = list(edgeColor)
+        data['edges'] = edges
+
+    if smoothNormals:
+        data['normals'] = list(pointNormals.flatten())
+
+    return data
+
+
```

## exudyn/interactive.py

 * *Ordering differences only*

```diff
@@ -1,922 +1,922 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Utilities for interactive simulation and results monitoring; NOTE: does not work on MacOS!
-#
-# Author:   Johannes Gerstmayr
-# Date:     2021-01-17 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# Utility functions and structures for Exudyn
-
-import numpy as np #LoadSolutionFile
-from math import sin, pi #for animation
-#import time        
-import copy           #copy numpy objects
-import exudyn
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**class: create an interactive dialog, which allows to interact with simulations
-#the dialog has a 'Run' button, which initiates the simulation and a 'Stop' button which stops/pauses simulation; 'Quit' closes the simulation model
-#for examples, see \texttt{simulateInteractively.py} and \texttt{massSpringFrictionInteractive.py}
-#use \_\_init\_\_ method to setup this class with certain buttons, edit boxes and sliders
-#**example:
-# #the following example is only demonstrating the structure of dialogItems and plots
-# #dialogItems structure:
-# #general items: 
-# #    'type' can be out of:
-# #               'label' (simple text), 
-# #               'button' (button with callback function),
-# #               'radio' (a radio button with several alternative options),
-# #               'slider' (with an adjustable range to choose a value)
-# #    'grid': (row, col, colspan) specifies the row, column and (optionally) the span of columns the item is placed at;
-# #            exception in 'radio', where grid is a list of (row, col) for every choice
-# #    'options': text options, where 'L' means flush left, 'R' means flush right
-# #suboptions of 'label':
-# #               'text': a text to be drawn
-# #suboptions of 'button':
-# #               'text': a text to be drawn on button
-# #               'callFunction': function which is called on button-press
-# #suboptions of 'radio':
-# #               'textValueList': [('text1',0),('text2',1)] a list of texts with according values
-# #               'value': default value (choice) of radio buttons
-# #               'variable': according variable in mbs.variables (or mbs.sys), which is set to current radio button value
-# #suboptions of 'slider':
-# #               'range': (min, max) a tuple containing minimum and maximum value of slider
-# #               'value': default value of slider
-# #               'steps': number of steps in slider
-# #               'variable': according variable in mbs.variables (or mbs.sys), which is set to current slider value
-# #example:
-# dialogItems = [{'type':'label', 'text':'Nonlinear oscillation simulator', 'grid':(0,0,2), 'options':['L']},
-#                {'type':'button', 'text':'test button','callFunction':ButtonCall, 'grid':(1,0,2)},
-#                {'type':'radio', 'textValueList':[('linear',0),('nonlinear',1)], 'value':0, 'variable':'mode', 'grid': [(2,0),(2,1)]},
-#                {'type':'label', 'text':'excitation frequency (Hz):', 'grid':(5,0)},
-#                {'type':'slider', 'range':(3*f1/800, 3*f1), 'value':omegaInit/(2*pi), 'steps':800, 'variable':'frequency', 'grid':(5,1)},
-#                {'type':'label', 'text':'damping:', 'grid':(6,0)},
-#                {'type':'slider', 'range': (0, 40), 'value':damper, 'steps':800, 'variable':'damping', 'grid':(6,1)},
-#                {'type':'label', 'text':'stiffness:', 'grid':(7,0)},
-#                {'type':'slider', 'range':(0, 10000), 'value':spring, 'steps':800, 'variable':'stiffness', 'grid':(7,1)}]
-#
-# #plots structure:
-# plots={'nPoints':500,              #number of stored points in subplots (higher means slower drawing)
-#        'subplots':(2,1),           #(rows, columns) arrangement of subplots (for every sensor)
-#        #sensors defines per subplot (sensor, coordinate), xlabel and ylabel; if coordinate=0, time is used:
-#        'sensors':[[(sensPos,0),(sensPos,1),'time','mass position'], 
-#                   [(sensFreq,0),(sensFreq,1),'time','excitation frequency']],
-#        'limitsX':[(0,2),(-5,5)],   #x-range per subplot; if not provided, autoscale is applied
-#        'limitsY':[(-5,5),(0,10),], #y-range per subplot; if not provided, autoscale is applied
-#        'fontSize':16,              #custom font size for figure
-#        'subplots':False,           #if not specified, subplots are created; if False, all plots go into one window 
-#        'lineStyles':['r-','b-'],    #if not specified, uses default '-b', otherwise define list of line styles [string for matplotlib.pyplot.plot] per sensor
-#        'sizeInches':(12,12)}       #specific x and y size of figure in inches (using 100 dpi)
-class InteractiveDialog:
-    #**classFunction: initialize an InteractiveDialog
-    #**input: 
-    #  mbs: a multibody system to be simulated
-    #  simulationSettings: exudyn.SimulationSettings() according to user settings
-    #  simulationFunction: a user function(mbs, self) which is called before a simulation for the short period is started (e.g, assign special values, etc.); the arguments are the MainSystem mbs and the InteractiveDialog (self)
-    #  dialogItems: a list of dictionaries, which describe the contents of the interactive items, where every dict has the structure {'type':[label, entry, button, slider, check] ... according to tkinter widgets, 'callFunction': a function to be called, if item is changed/button pressed, 'grid': (row,col) of item to be placed, 'rowSpan': number of rows to be used, 'columnSpan': number of columns to be used; for special item options see notes}
-    #  plots: list of dictionaries to specify a sensor to be plotted live, see example; otherwise use default None
-    #  period: a simulation time span in seconds which is simulated with the simulationFunction in every iteration
-    #  realtimeFactor: if 1, the simulation is nearly performed in realtime (except for computation time); if > 1, it runs faster than realtime, if < 1, than it is slower
-    #  userStartSimulation: a function F(flag) which is called every time after Run/Stop is pressed. The argument flag = False if button "Run" has been pressed, flag = True, if "Stop" has been pressed
-    #  title: title text for interactive dialog
-    #  showTime: shows current time in dialog
-    #  fontSize: adjust font size for all dialog items
-    #  doTimeIntegration: performs internal time integration with given parameters
-    #  runOnStart: immediately activate 'Run' button on start
-    #  addLabelStringVariables: True: adds a list labelStringVariables containing the (modifiable) list of string variables for label (text) widgets
-    #  addSliderVariables: True: adds a list sliderVariables containing the (modifiable) list of variables for slider (=tkinter scale) widgets; this is not necessarily needed for changing slider values, as they can also be modified with dialog.widgets[..].set(...) method
-    #  checkRenderEngineStopFlag: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
-    #  userOnChange: a user function(mbs, self) which is called after period, if widget values are different from values stored in mbs.variables; this usually occurs if buttons are pressed or sliders are moved; the arguments are the MainSystem mbs and the InteractiveDialog (self)
-    #  useSysVariables: for internal visualization functions: in this case, variables are written to mbs.sys instead of mbs.variables
-    #**notes: detailed description of dialogItems and plots list/dictionary is given in commented the example below
-    def __init__(self, mbs, simulationSettings, simulationFunction, 
-                 dialogItems, plots = None, period = 0.04, 
-                 realtimeFactor = 1, userStartSimulation=None, 
-                 title='',  showTime=False, fontSize = 12,
-                 doTimeIntegration = True, runOnStart = False, 
-                 addLabelStringVariables=False, addSliderVariables=False, 
-                 checkRenderEngineStopFlag = True, userOnChange=None, useSysVariables=False):
-        
-        try:
-            import tkinter
-            import tkinter.font as tkFont
-            from exudyn.GUI import GetTkRootAndNewWindow
-        except:
-            raise ValueError('ERROR: InteractiveDialog: tkinter is not installed; InteractiveDialog or SolutionViewer are therefore not available')
-
-        
-        #store init arguments
-        self.mbs = mbs
-        self.simulationFunction = simulationFunction
-        self.simulationSettings = simulationSettings
-        self.title = title
-        self.dialogItems = dialogItems
-        self.period = period
-        self.realtimeFactor = realtimeFactor
-        self.stepSize = simulationSettings.timeIntegration.endTime/simulationSettings.timeIntegration.numberOfSteps
-        self.doTimeIntegration = doTimeIntegration
-
-        self.plots = plots
-        self.userStartSimulation = userStartSimulation
-        self.userOnChange = userOnChange
-        self.showTime = showTime
-        self.fontSize = fontSize
-        self.useSysVariables = useSysVariables
-        
-        self.checkRenderStop = checkRenderEngineStopFlag
-
-        if self.plots is None:
-            self.plots = []
-
-        if self.mbs.GetRenderEngineStopFlag() and self.checkRenderStop: #avoid immediate quit
-            self.mbs.SetRenderEngineStopFlag(False)
-
-
-        #create tkinter instance
-        [self.root, self.tkWindow, tkRuns] = GetTkRootAndNewWindow()
-
-        # root = self.root = tkinter.Tk()
-        #exudyn.sys['tkinterRoot'] = root #not needed anymore, as GUI.GetTkRootAndNewWindow() is used
-        self.tkWindow.protocol("WM_DELETE_WINDOW", self.OnQuit) #always leave app with OnQuit
-        self.tkWindow.title(title)
-        try:
-            systemScaling = self.tkWindow.call('tk', 'scaling') #obtains current scaling?
-        except:
-            pass
-        #print('systemScaling=',systemScaling)
-        systemScaling = 1
-
-        if (self.doTimeIntegration 
-            and self.simulationSettings.solutionSettings.writeInitialValues == True 
-            and mbs.systemData.AEsize() != 0):
-            print('WARNING: InteractiveDialog:\nyou should set simulationSettings.solutionSettings.writeInitialValues = False in order to avoid erroneous constraint outputs during time integration periods.\n')
-
-        #change global font size
-        if True:
-            defaultFont = tkFont.Font(root=self.tkWindow, family = "TkDefaultFont")#,weight = "bold")
-            defaultFont.configure(size=int(systemScaling*self.fontSize))
-            self.tkWindow.option_add("*Font", "TkDefaultFont") #all widgets should use TkDefaultFont; does not work
-        
-        self.counter = 0 #counter for simulationFunction
-        self.simulationStopped = True
-        self.variableList = [] #list of tuples: (widget, mbs variable name); value obtained with widget.get()
-
-        self.itemBorder = 2 #common border to items
-
-        tkinterNESW = tkinter.N+tkinter.E+tkinter.S+tkinter.W
-        
-        self.widgets = [] #store tk widgets as list, for later access
-        self.labelStringVariables = [] #store string variables to modify widget text hereafter
-        self.sliderVariables = [] #store string variables to modify widget text hereafter
-
-        for item in dialogItems:
-            text = ''
-            setGrid = False
-            # sticky = 'NSEW'
-           
-            if 'text' in item:
-                text = item['text']
-            # if 'sticky' in item:
-            #     sticky = item['sticky']
-            #++++++++++++++++++++++++++++++++++
-            if item['type'] == 'label':
-                setGrid = True
-                if addLabelStringVariables:
-                    stringVar = tkinter.StringVar()
-                    widget = tkinter.Label(self.tkWindow, textvariable = stringVar, 
-                                           borderwidth = self.itemBorder, 
-                                           #justify=tkinter.LEFT, #needed?
-                                           font=defaultFont)
-                    stringVar.set(text)
-                    self.labelStringVariables += [stringVar] #store in list
-                else:
-                    widget = tkinter.Label(self.tkWindow, text = text, 
-                                           borderwidth = self.itemBorder, 
-                                           font=defaultFont)
-
-            #++++++++++++++++++++++++++++++++++
-            elif item['type'] == 'button':
-                setGrid = True
-                widget = tkinter.Button(self.tkWindow, text = text, 
-                                       borderwidth = self.itemBorder, 
-                                       font=defaultFont)
-                if 'callFunction' in item:
-                    widget['command'] = item['callFunction']
-            #++++++++++++++++++++++++++++++++++
-            elif item['type'] == 'slider':
-                setGrid = True
-                steps = 400
-                minValue = 0
-                maxValue = 1
-                initialValue = 0.5
-                if 'steps' in item:
-                    steps = item['steps']
-                if 'range' in item:
-                    minValue = item['range'][0]
-                    maxValue = item['range'][1]
-                if 'value' in item:
-                    initialValue = item['value']
-                if initialValue < minValue or initialValue > maxValue:
-                    initialValue = 0.5*(minValue+maxValue)
-                resolutionItem = (maxValue-minValue)/max(1,(steps-1))
-                if 'resolution' in item: #resolution is needed, if we want to do bi-directional set/get of slider values (otherwise digits are lost)
-                     resolutionItem = item['resolution']
-
-                nDigits = 4
-                if maxValue-minValue == steps-1:
-                    nDigits = 0
-                
-                if not addSliderVariables:
-                    widget = tkinter.Scale(self.tkWindow, from_=minValue, to=maxValue,
-                                           length = steps, digits=nDigits, resolution=resolutionItem,
-                                           orient=tkinter.HORIZONTAL,
-                                           font=defaultFont)
-                    widget.set(initialValue)
-                else:
-                    #add option to modify scale from outside
-                    tkVariable = tkinter.DoubleVar()
-                    tkVariable.set(initialValue)
-                    widget = tkinter.Scale(self.tkWindow, from_=minValue, to=maxValue,
-                                           length = steps, digits=nDigits, resolution=resolutionItem,
-                                           orient=tkinter.HORIZONTAL,
-                                           variable=tkVariable,
-                                           font=defaultFont)
-                    self.sliderVariables += [tkVariable]
-                    #but using widget.set(..) also allows to adjust widget from external function!
-                    
-                if 'callFunction' in item:
-                    widget['command'] = self.item['callFunction']
-                if 'variable' in item:
-                    self.variableList += [(widget, item['variable'])]
-
-            #++++++++++++++++++++++++++++++++++
-            elif item['type'] == 'radio':
-                var = tkinter.IntVar()
-                var.set(item['value'])
-                cnt = 0
-                for opt in item['textValueList']:
-                    widget = tkinter.Radiobutton(self.tkWindow, 
-                                                text=opt[0],
-                                                padx = 20, 
-                                                variable=var, 
-                                                value=opt[1], 
-                                                #height=1, width=1, 
-                                                indicatoron=0, #use highlighting instead of checkboxes
-                                                font=defaultFont)
-                    if 'grid' in item:
-                        grid = item['grid'][cnt] #must be list of grid values
-                        if len(grid) == 2:
-                            widget.grid(row=grid[0], column=grid[1], sticky=tkinterNESW)
-                        elif len(grid) == 3:
-                            widget.grid(row=grid[0], column=grid[1], columnspan=grid[2], sticky=tkinterNESW)
-                    # not needed, all flush left
-                    # if 'options' in item:
-                    #     if 'L' in item['options']:
-                    #         widget['anchor'] = 'w'
-                    #     if 'R' in item['options']:
-                    #         widget['anchor'] = 'e'
-                    else:
-                        widget.grid(column=0, sticky=tkinter.W)
-                    cnt+=1
-                self.variableList += [(var, item['variable'])] #store widget variable and mbs variable
-            #++++++++++++++++++++++++++++++++++
-            if setGrid:
-                if 'grid' in item:
-                    grid = item['grid']
-                    if len(grid) == 2:
-                        widget.grid(row=grid[0], column=grid[1], sticky=tkinterNESW)
-                    elif len(grid) == 3:
-                        widget.grid(row=grid[0], column=grid[1], columnspan=grid[2], sticky=tkinterNESW)
-                    elif len(grid) == 4:
-                        widget.grid(row=grid[0], column=grid[1], columnspan=grid[2], rowspan=grid[3], sticky=tkinterNESW)
-                    else:
-                        raise ValueError("ERROR: InteractiveDialog: grid must have 2, 3, or 4 components")
-                else:
-                    widget.grid(column=0, sticky=tkinterNESW)
-                if 'options' in item:
-                    if 'L' in item['options']:
-                        widget['anchor'] = 'w'
-                    if 'R' in item['options']:
-                        widget['anchor'] = 'e'
-            self.widgets += [widget]
-            # if item['type'] == 'entry' and firstEntry: #entry may get focus
-            #     firstEntry = False
-            #     widget.focus_set() #set focus to first item
-                
-        #show current time 
-        if self.showTime:
-            self.currentTime = tkinter.StringVar()
-            widget = tkinter.Label(self.tkWindow, textvariable = self.currentTime, 
-                                   borderwidth = self.itemBorder, justify=tkinter.LEFT,
-                                   font=defaultFont)
-            self.currentTime.set('t = ')
-            widget.grid(column=0, sticky=tkinter.W)
-
-        #add run button into last row:
-        self.RunButtonText = tkinter.StringVar()
-        self.Run = tkinter.Button(self.tkWindow, textvariable=self.RunButtonText,
-                                  borderwidth = self.itemBorder, font=defaultFont)
-        self.RunButtonText.set('Run')
-        
-        self.Run.grid(column=0, sticky=tkinterNESW)#, row=maxRow+1)
-        self.Run['command'] = self.StartSimulation
-        self.Run.focus_set() #does not work
-        
-        self.tkWindow.bind('<space>', func=self.StartSimulation) #if focus is not set to button ...
-        self.tkWindow.bind('<Escape>', self.OnQuit) #Escape causes immediate quit (no further checks)
-        self.tkWindow.bind('q', self.OnQuit) #Button 'Q' causes immediate quit (no further checks)
-
-        self.tkWindow.update()
-        if self.tkWindow.winfo_width() < 320:
-            self.tkWindow.minsize(320,self.tkWindow.winfo_height())
-        #self.tkWindow.minsize(280,50) #will create windows which are too small
-
-        self.InitializeSolver() #solver gets ready to be called repeatedly
-        self.InitializePlots()  #set up all structures for plots
-        self.UpdatePlots()      #update all subplots with new sensor values
-
-        if runOnStart:          #immediately activate run function on startup
-            self.StartSimulation()
-        self.tkWindow.deiconify()
-        # self.tkWindow.mainloop()
-        tkinter.mainloop()
-
-    #**classFunction: function called when pressing escape or closing dialog
-    def OnQuit(self, event=None):
-        self.simulationStopped = True
-        self.RunButtonText.set('Stop')
-        self.FinalizeSolver()
-        #del exudyn.sys['tkinterRoot'] #this is not thread safe, but interuption should not happen ...
-        self.tkWindow.quit()
-        self.tkWindow.destroy()
-
-    #**classFunction: function called on button 'Run'
-    def StartSimulation(self, event=None):
-        self.simulationStopped = not self.simulationStopped
-        if not self.simulationStopped:
-            self.RunButtonText.set('Stop')
-        else:
-            self.RunButtonText.set('Run')
-
-        if self.userStartSimulation != None:
-            self.userStartSimulation(self.simulationStopped)
-        #self.ProcessWidgetStates() #do this finally, to update states, which may have changed in last step (SolutionViewer!)
-        self.ContinuousRunFunction()
-
-    #**classFunction: assign current values of radio buttons and sliders to mbs.variables or mbs.sys
-    def ProcessWidgetStates(self):
-        changed = False
-        for var in self.variableList:
-            v = var[0].get()
-            if self.useSysVariables:
-                destinationDict = self.mbs.sys #this is a link!
-            else:
-                destinationDict = self.mbs.variables
-            if not var[1] in destinationDict or v != destinationDict[var[1]]:
-                destinationDict[var[1]] = v
-                changed = True
-        if changed and self.userOnChange != None:
-            self.userOnChange(self.mbs, self) #this user function is called every time a value has changed, within update period
-
-    #**classFunction: function which is repeatedly called when button 'Run' is pressed
-    def ContinuousRunFunction(self, event=None):
-        if not self.simulationStopped:
-            self.ProcessWidgetStates()
-            exudyn.DoRendererIdleTasks() #for MacOS, but also to open visualization dialog, etc.
-            #print(".")
-            if self.mbs.GetRenderEngineStopFlag() and self.checkRenderStop:
-                self.OnQuit()
-            else:
-                t = self.RunSimulationPeriod()
-                if self.showTime:
-                    self.currentTime.set('t = '+str(round(t,6)))
-                self.counter += 1
-                delay = max(1, int(self.period*1000/self.realtimeFactor))
-                self.tkWindow.after(delay, self.ContinuousRunFunction)
-                # self.Run.after(delay, self.ContinuousRunFunction)
-
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: initialize figure and subplots for plots structure
-    def InitializePlots(self):
-        if len(self.plots) != 0:
-            import matplotlib.pyplot as plt
-            plt.rcParams.update({'font.size': self.plots['fontSize']})
-        
-            fig = plt.figure()
-            fig.dpi = 100 #in terminal, initially set to 200
-            fig.tight_layout()
-            if 'sizeInches' in self.plots: #otherwise use default figure size
-                fig.set_size_inches(self.plots['sizeInches'][0], self.plots['sizeInches'][1], forward=True)
-            nPoints = self.plots['nPoints']
-            self.plots['fig'] = fig
-            self.plots['currentIndex'] = 0
-            nSensors = len(self.plots['sensors'])
-            self.plots['data'] = [np.zeros((nPoints,2))]*nSensors
-            self.plots['line'] = [0]*nSensors
-            self.plots['marker'] = [0]*nSensors
-            self.plots['ax'] = [0]*nSensors
-            lineStyle = 'b-'
-            doSubplots = True
-            if 'subplots' in self.plots:
-                doSubplots = self.plots['subplots']
-            if not doSubplots:
-                axPlot = fig.add_subplot(1,1,1)
-        
-            for j in range(nSensors):
-                if doSubplots:
-                    self.plots['ax'][j] = fig.add_subplot(self.plots['subplots'][0],self.plots['subplots'][1],j+1)
-                else:
-                    self.plots['ax'][j] = axPlot
-                self.plots['ax'][j].grid(True, 'major', 'both')
-                self.plots['ax'][j].set_xlabel(self.plots['sensors'][j][2])
-                self.plots['ax'][j].set_ylabel(self.plots['sensors'][j][3])
-                
-                data = np.zeros((nPoints,2))
-                if self.plots['sensors'][j][0][1] == 0: #time of sensor
-                    data[:,0] = np.linspace(self.period,nPoints*self.period,num=nPoints)
-                #data[:,1] = 0 #not needed
-                self.plots['data'][j] = copy.deepcopy(data)
-                
-                if 'lineStyles' in self.plots:
-                    lineStyle = self.plots['lineStyles'][j]
-                self.plots['line'][j], = self.plots['ax'][j].plot(data[:,0],data[:,1], lineStyle)
-                self.plots['marker'][j], = self.plots['ax'][j].plot(0,0, 'ro') #red circle
-                self.plots['ax'][j].set_xlim(min(data[:,0]), max(data[:,0]))
-
-    #**classFunction: update all subplots with current sensor values
-    def UpdatePlots(self):
-        if len(self.plots) != 0:
-            n = self.plots['nPoints']
-            i = self.plots['currentIndex']
-            t = self.simulationSettings.timeIntegration.startTime #current time
-    
-            for j in range(len(self.plots['sensors'])):
-                data = self.plots['data'][j]
-                
-                sensorNum = [0,0]
-                sensorCoord = [0,0]
-                for k in range(2):
-                    sensorNum = self.plots['sensors'][j][k][0]
-                    sensorCoord = self.plots['sensors'][j][k][1]
-                    if sensorCoord == 0:
-                        data[i,k] = t
-                    else:
-                        value = self.mbs.GetSensorValues(sensorNum)
-                        if type(value)==np.ndarray:
-                            data[i,k] = value[sensorCoord-1]
-                        elif sensorCoord == 1:
-                            data[i,k] = value
-                        else:
-                            raise ValueError('ERROR: InteractiveDialog: plots.sensor '+str(j)+': access to invalid coordinate')
-                            
-                self.plots['line'][j].set_data(data[:,0], data[:,1]) 
-                self.plots['marker'][j].set_data(data[i,0], data[i,1]) 
-    
-                self.plots['ax'][j].set_xlim(min(data[:,0]), max(data[:,0]))
-                
-                if 'limitsX' in self.plots:
-                    if len(self.plots['limitsX'][j]):
-                        self.plots['ax'][j].set_xlim(self.plots['limitsX'][j][0],self.plots['limitsX'][j][1])
-                if 'limitsY' in self.plots:
-                    if len(self.plots['limitsY'][j]):
-                        self.plots['ax'][j].set_ylim(self.plots['limitsY'][j][0],self.plots['limitsY'][j][1])
-                #autoscale, if no limits given
-                self.plots['ax'][j].relim(visible_only=True)
-                self.plots['ax'][j].autoscale_view(tight=True)
-            
-            #update figure:
-            self.plots['fig'].canvas.draw()
-            self.plots['fig'].canvas.flush_events()
-    
-            if i < n-1:
-                self.plots['currentIndex'] += 1
-    
-            for j in range(len(self.plots['sensors'])):
-                data = self.plots['data'][j]
-                if i == n-1:
-                    data = np.roll(data, -1, axis=0)
-                self.plots['data'][j] = data #data references mbs variable
-
-
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #**classFunction: function to initialize solver for repeated calls
-    def InitializeSolver(self):
-        if self.doTimeIntegration:
-            self.mbs.sys['solver'] = exudyn.MainSolverImplicitSecondOrder()
-            self.mbs.sys['solver'].InitializeSolver(self.mbs, self.simulationSettings)
-
-    #**classFunction: stop solver (finalize correctly)
-    def FinalizeSolver(self):
-        if self.doTimeIntegration:
-            self.mbs.sys['solver'].FinalizeSolver(self.mbs, self.simulationSettings) #shut down solver correctly (finalize files, ...)
-
-
-    #**classFunction: function which performs short simulation for given period        
-    def RunSimulationPeriod(self):
-        deltaT = self.period
-        h = self.stepSize
-        mbs = self.mbs
-
-        #+++++++++++++++++++++++++++++++++++++++++
-        #this is the USER PART
-        self.simulationFunction(self.mbs, self)
-        #+++++++++++++++++++++++++++++++++++++++++
-    
-        if self.doTimeIntegration and False: #slow way, always start/stop simulation; resets sensor data ...
-            self.simulationSettings.timeIntegration.numberOfSteps = max(int(deltaT/h),1)
-            self.simulationSettings.timeIntegration.endTime = self.simulationSettings.timeIntegration.startTime+deltaT
-            exudyn.SolveDynamic(mbs, self.simulationSettings, updateInitialValues=True)
-            self.simulationSettings.timeIntegration.startTime += deltaT
-    
-        #+++++++++++++++++++++++++++++++++++++++++
-        #PLOT PART, done every time before simulation starts
-        self.UpdatePlots()
-    
-        #+++++++++++++++++++++++++++++++++++++++++
-        #TIME STEPPING PART
-        if self.doTimeIntegration and True:
-        
-            self.simulationSettings.timeIntegration.numberOfSteps = max(int(deltaT/h),1)
-            self.simulationSettings.timeIntegration.endTime = self.simulationSettings.timeIntegration.startTime+deltaT
-
-            #update 2023-01-06: also update accelerations, needed for implicit solvers!
-            #initial accelerations are set sero in initialization ...
-            initAcc = mbs.systemData.GetODE2Coordinates_tt(configuration = exudyn.ConfigurationType.Current)
-            #not needed, if simulationSettings.solutionSettings.writeInitialValues = False 
-            #initAE = mbs.systemData.GetAECoordinates(configuration = exudyn.ConfigurationType.Current) 
-
-            mbs.sys['solver'].InitializeSolverInitialConditions(mbs, self.simulationSettings) #needed to update simulationSettings in solver
-
-            mbs.systemData.SetODE2Coordinates_tt(coordinates = initAcc)
-            #mbs.systemData.SetAECoordinates(coordinates = initAE)
-
-            mbs.sys['solver'].SolveSteps(mbs, self.simulationSettings)
-            
-            #get current values and update initial conditions for next step:
-            currentState = mbs.systemData.GetSystemState()
-            mbs.systemData.SetSystemState(systemStateList=currentState, configuration = exudyn.ConfigurationType.Initial)
-            # mbs.systemData.SetODE2Coordinates_tt(coordinates = mbs.systemData.GetODE2Coordinates_tt(), 
-            #                                         configuration = exudyn.ConfigurationType.Initial)
-        
-            self.simulationSettings.timeIntegration.startTime += deltaT
-    
-        return self.simulationSettings.timeIntegration.endTime #return current time for dialog
-
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: animate modes of ObjectFFRFreducedOrder, of nodal coordinates (changes periodically one nodal coordinate) or of a list of system modes provided as list of lists; for creating snapshots, press 'Static' and 'Record animation' and press 'Run' to save one figure in the image subfolder; for creating animations for one mode, use the same procedure but use 'One Cycle'. Modes may be inverted by pressing according '+' and '-' buttons next to Amplitude.
-#**input:
-#    systemContainer: system container (usually SC) of your model, containing visualization settings
-#    mainSystem: system (usually mbs) containing your model
-#    nodeNumber: node number of which the coordinates shall be animated. In case of ObjectFFRFreducedOrder, this is the generic node, e.g., 'nGenericODE2' in the dictionary returned by the function AddObjectFFRFreducedOrderWithUserFunctions(...); if nodeNumber=None, then the systemEigenVectors list is used
-#    period: delay for animation of every frame; the default of 0.04 results in approximately 25 frames per second
-#    stepsPerPeriod: number of steps into which the animation of one cycle of the mode is split into
-#    showTime: show a virtual time running from 0 to 2*pi during one mode cycle
-#    renderWindowText: additional text written into renderwindow before 'Mode X' (use $\backslash$n to add line breaks)
-#    runOnStart: immediately go into 'Run' mode
-#    runMode: 0=continuous run, 1=static continuous, 2=one cycle, 3=static (use slider/mouse to vary time steps)
-#    scaleAmplitude: additional scaling for amplitude if necessary
-#    fontSize: define font size for labels in InteractiveDialog
-#    title: if empty, it uses default; otherwise define specific title
-#    checkRenderEngineStopFlag: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
-#    systemEigenVectors: may be a list of lists of system eigenvectors for ODE2 (and possibly ODE1) coordinates or a eigenvector matrix containing mode vectors in columns; if nodeNumber=None, these eigenvectors are then used to be animated
-#**output: opens interactive dialog with further settings
-#**notes: Uses class InteractiveDialog in the background, which can be used to adjust animation creation. If meshes are large, animation artifacts may appear, which are resolved by using a larger update period.
-#    Press 'Run' to start animation; Chose 'Mode shape', according component for contour plot; to record one cycle for animation, choose 'One cycle', run once to get the according range in the contour plot, press 'Record animation' and press 'Run', now images can be found in subfolder 'images' (for further info on animation creation see \refSection{sec:overview:basics:animations}); now deactivate 'Record animation' by pressing 'Off' and chose another mode
-def AnimateModes(systemContainer, mainSystem, nodeNumber, period = 0.04, stepsPerPeriod = 30, showTime = True, 
-                 renderWindowText = '', runOnStart = False, runMode=0, scaleAmplitude = 1, title='', fontSize = 12,
-                 checkRenderEngineStopFlag = True, systemEigenVectors=None):
-
-    SC = systemContainer
-    mbs = mainSystem
-    SC.visualizationSettings.general.graphicsUpdateInterval = 0.25*min(period, 2e-3) #set according update interval!
-    SC.visualizationSettings.general.showSolverTime = showTime
-    #SC.visualizationSettings.general.showComputationInfo = False
-    SC.visualizationSettings.general.showSolverInformation = False
-    SC.visualizationSettings.general.renderWindowString = renderWindowText+'mode 0'
-    
-    if nodeNumber != None:
-        coordIndex = mbs.GetNodeODE2Index(nodeNumber)
-        nodeCoords = mbs.GetNodeOutput(nodeNumber,exudyn.OutputVariableType.Coordinates,exudyn.ConfigurationType.Reference)
-        numberOfModes = len(nodeCoords)
-    else:
-        if type(systemEigenVectors) == np.ndarray:
-            systemEigenVectors = systemEigenVectors.T.tolist()
-
-        if type(systemEigenVectors) != list or len(systemEigenVectors)==0:
-            raise ValueError('AnimateModes: in case that nodeNumber=None, systemEigenVectors must be non-empty list of system eigenvectors, but received ',systemEigenVectors)
-                
-        numberOfModes = len(systemEigenVectors)
-        coordIndex = None #this indicates that systemEigenVectors are used
-        for vec in systemEigenVectors:
-            if type(vec) != list or len(vec) < mbs.systemData.ODE2Size():
-                raise ValueError('AnimateModes: in case that nodeNumber=None, systemEigenVectors must at least have ODE2 size components')
-
-    if (runMode < 0 or runMode > 3):
-        raise ValueError('AnimateModes: illegal run mode:', runMode)
-    
-    #use interactive dialog:
-    dialogItems = [
-                   {'type':'label', 'text':'Mode shape:', 'grid':(1,0)},
-                   {'type':'slider', 'range':(0, numberOfModes-1), 'value':0, 'steps':numberOfModes, 'variable':'modeShapeModeNumber', 'grid':(1,1)},
-                   {'type':'label', 'text':'Contour plot:', 'grid':(2,0)},
-                   {'type':'radio', 'textValueList':[('None',int(exudyn.OutputVariableType._None)),
-                                                     ('DisplacementLocal',int(exudyn.OutputVariableType.DisplacementLocal)),
-                                                      ('Displacement',int(exudyn.OutputVariableType.Displacement)),
-                                                      ('StressLocal',int(exudyn.OutputVariableType.StressLocal)),
-                                                      ('StrainLocal',int(exudyn.OutputVariableType.StrainLocal))], 
-                    'value':int(exudyn.OutputVariableType.DisplacementLocal), 'variable':'modeShapeOutputVariable', 'grid': [(3,0),(3,1),(3,2),(3,3),(3,4)]},
-                   {'type':'label', 'text':'Contour Component (use -1 for norm):', 'grid':(4,0)},
-                   {'type':'slider', 'range':(-1, 5), 'value':0, 'steps':7, 'variable':'modeShapeComponent', 'grid':(4,1)},
-                   {'type':'label', 'text':'Amplitude:', 'grid':(5,0)},
-                   {'type':'slider', 'range':(0, 1), 'value':0.05, 'steps':501, 'variable':'modeShapeAmplitude', 'grid':(5,1)},
-                   {'type':'radio', 'textValueList':[('positive',1), ('negative',-1)],'value':1, 'variable':'modeSignAmplitude', 'grid': [(5,2),(5,3)]},
-                   {'type':'label', 'text':'update period:', 'grid':(6,0)},
-                   {'type':'slider', 'range':(0.01, 2), 'value':0.04, 'steps':200, 'variable':'modeShapePeriod', 'grid':(6,1)},
-                   {'type':'radio', 'textValueList':[('Continuous run',0), ('Static continuous',1), ('One cycle',2), ('Static once',3)],'value':runMode, 'variable':'modeShapeRunModus', 'grid': [(7,0),(7,1),(7,2),(7,3)]},
-                   {'type':'radio', 'textValueList':[('Mesh+Faces',3), ('Faces only',1), ('Mesh only',2)],'value':3, 'variable':'modeShapeMesh', 'grid': [(8,0),(8,1),(8,2)]},
-                   {'type':'radio', 'textValueList':[('Record animation',0), ('No recording',1)],'value':1, 'variable':'modeShapeSaveImages', 'grid': [(9,0),(9,1)]},
-                   ]
-
-    mbs.sys['modeShapePeriod'] = period
-    mbs.sys['modeShapeStepsPerPeriod'] = stepsPerPeriod
-    mbs.sys['modeShapeTimeIndex'] = 0
-    mbs.sys['modeShapeLastSetting'] = [-1,0,0,0]
-    mbs.sys['modeShapeNodeCoordIndex'] = coordIndex
-    mbs.sys['modeShapeSystemEigenVectors'] = systemEigenVectors
-    mbs.sys['modeShapeScaleAmplitude'] = scaleAmplitude
-    mbs.sys['modeSignAmplitude'] = 1
-
-    def UFshowModes(mbs, dialog):
-        i = mbs.sys['modeShapeTimeIndex']
-        mbs.sys['modeShapeTimeIndex'] += 1
-        stepsPerPeriod = mbs.sys['modeShapeStepsPerPeriod']
-        amplitude = mbs.sys['modeShapeAmplitude']*mbs.sys['modeSignAmplitude']
-        if amplitude == 0:
-            SC.visualizationSettings.bodies.deformationScaleFactor = 0
-            amplitude = 1
-        else:
-            SC.visualizationSettings.bodies.deformationScaleFactor = 1
-
-        if mbs.sys['modeShapeRunModus'] == 1 or mbs.sys['modeShapeRunModus'] == 3: #no sin(t) in static case
-            stepsPerPeriod = 1
-            t = 0
-        else:
-            t = i/stepsPerPeriod * 2 * pi
-            amplitude *= sin(t)
-        mbs.systemData.SetTime(t, exudyn.ConfigurationType.Visualization)
-        
-        selectedMode = int(mbs.sys['modeShapeModeNumber'])
-        outputVariable = exudyn.OutputVariableType(int(mbs.sys['modeShapeOutputVariable']))
-       
-        if mbs.sys['modeShapeNodeCoordIndex'] != None:
-            ode2Coords = mbs.systemData.GetODE2Coordinates()
-            ode2Coords[mbs.sys['modeShapeNodeCoordIndex']+selectedMode] = amplitude * mbs.sys['modeShapeScaleAmplitude']
-            mbs.systemData.SetODE2Coordinates(ode2Coords, exudyn.ConfigurationType.Visualization)
-        else:
-            ode2Size = mbs.systemData.ODE2Size()
-            ode1Size = mbs.systemData.ODE1Size()
-            modeVector = np.array(mbs.sys['modeShapeSystemEigenVectors'][selectedMode])
-            ode2Coords = amplitude * modeVector[0:ode2Size]
-            mbs.systemData.SetODE2Coordinates(ode2Coords, exudyn.ConfigurationType.Visualization)
-            if ode1Size != 0 and len(modeVector) >= ode2Size+ode1Size:
-                ode1Coords = amplitude * modeVector[ode2Size:ode2Size+ode1Size]
-                mbs.systemData.SetODE1Coordinates(ode1Coords, exudyn.ConfigurationType.Visualization)
-
-
-        SC.visualizationSettings.contour.reduceRange = False
-        #check, if automatic range of contour colors shall be recomputed:
-        if (  mbs.sys['modeShapeLastSetting'][0] != int(mbs.sys['modeShapeModeNumber']) or 
-              mbs.sys['modeShapeLastSetting'][1] != int(mbs.sys['modeShapeOutputVariable']) or
-              mbs.sys['modeShapeLastSetting'][2] != mbs.sys['modeShapeAmplitude'] or
-              mbs.sys['modeShapeLastSetting'][3] != int(mbs.sys['modeShapeComponent'])):
-            SC.visualizationSettings.contour.reduceRange = True
-            SC.visualizationSettings.general.renderWindowString = renderWindowText+'mode '+str(int(mbs.sys['modeShapeModeNumber']))
-        
-        mbs.sys['modeShapeLastSetting'] = [int(mbs.sys['modeShapeModeNumber']),
-                                           int(mbs.sys['modeShapeOutputVariable']),
-                                           mbs.sys['modeShapeAmplitude'],
-                                           int(mbs.sys['modeShapeComponent'])]
-
-
-        SC.visualizationSettings.contour.outputVariable = outputVariable
-        SC.visualizationSettings.contour.outputVariableComponent = int(mbs.sys['modeShapeComponent']) #component
-
-        #SC.visualizationSettings.openGL.showFaces = (mbs.sys['modeShapeMesh'] & 1) == 1
-        SC.visualizationSettings.openGL.showMeshFaces = (mbs.sys['modeShapeMesh'] & 1) == 1
-
-        #SC.visualizationSettings.openGL.showFaceEdges = (mbs.sys['modeShapeMesh'] & 2) == 2
-        SC.visualizationSettings.openGL.showMeshEdges = (mbs.sys['modeShapeMesh'] & 2) == 2
-        
-
-        mbs.SendRedrawSignal()
-        if not SC.visualizationSettings.general.useMultiThreadedRendering:
-            exudyn.DoRendererIdleTasks()
-        if mbs.sys['modeShapeSaveImages'] == 0:
-            SC.RedrawAndSaveImage() #create images for animation
-        else:
-            SC.visualizationSettings.exportImages.saveImageFileCounter = 0 #for next mode ...
-
-        dialog.period = mbs.sys['modeShapePeriod']
-
-        if mbs.sys['modeShapeTimeIndex']>=stepsPerPeriod:
-           mbs.sys['modeShapeTimeIndex'] = 0
-           if mbs.sys['modeShapeRunModus'] > 1: #one cylce or static once
-               dialog.StartSimulation()
-        
-    if not exudyn.IsRendererActive():
-        exudyn.StartRenderer()
-        if 'renderState' in exudyn.sys: SC.SetRenderState(exudyn.sys['renderState']) #load last model view
-
-    simulationSettings = exudyn.SimulationSettings() #not used, but needed in dialog
-     #   self.mbs.sys['solver'].InitializeSolver(self.mbs, self.simulationSettings)
-    simulationSettings.solutionSettings.solutionInformation = 'Mode X'
-
-    if not SC.visualizationSettings.general.useMultiThreadedRendering:
-        exudyn.DoRendererIdleTasks() #do an update once
-
-    titleDialog = 'Animate mode shapes'
-    if title != '': 
-        titleDialog = title
-    
-    dialog = InteractiveDialog(mbs, simulationSettings=simulationSettings, 
-                      simulationFunction=UFshowModes, 
-                      dialogItems=dialogItems,
-                      title=titleDialog,
-                      doTimeIntegration=False, period=period,
-                      showTime=False,#done in UFshowModes
-                      runOnStart=runOnStart, 
-                      checkRenderEngineStopFlag=checkRenderEngineStopFlag,
-                      fontSize=fontSize,
-                      useSysVariables=True, #use mbs.sys, not to bloat the mbs.variables of the user
-                      )
-    
-    #SC.WaitForRenderEngineStopFlag() #not needed, Render window closes when dialog is quit
-    exudyn.StopRenderer() #safely close rendering window!
-
-
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: open interactive dialog and visulation (animate) solution loaded with LoadSolutionFile(...); Change slider 'Increment' to change the automatic increment of time frames; Change mode between continuous run, one cycle (fits perfect for animation recording) or 'Static' (to change Solution steps manually with the mouse); update period also lets you change the speed of animation; Press Run / Stop button to start/stop interactive mode (updating of grpahics)
-#**input: 
-#  mainSystem: the system used for visualization of solution (solution is loaded into visualization state of that system)
-#  solution: solution dictionary previously loaded with exudyn.utilities.LoadSolutionFile(...); will be played from first to last row; if solution==None, it tries to load the file coordinatesSolutionFileName as stored in mbs.sys['simulationSettings'], which are the simulationSettings of the previous simulation
-#  rowIncrement: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
-#  timeout: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
-#  runOnStart: immediately go into 'Run' mode
-#  runMode: 0=continuous run, 1=one cycle, 2=static (use slider/mouse to vary time steps)
-#  fontSize: define font size for labels in InteractiveDialog
-#  title: if empty, it uses default; otherwise define specific title
-#  checkRenderEngineStopFlag: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
-#**output: None; updates current visualization state, renders the scene continuously (after pressing button 'Run')
-#**belongsTo: MainSystem
-#**example:
-##HERE, mbs must contain same model as solution stored in coordinatesSolution.txt
-#
-##adjust autoFitScence, otherwise it may lead to unwanted fit to scene
-#SC.visualizationSettings.general.autoFitScene = False
-#
-#from exudyn.interactive import SolutionViewer #import function
-#sol = LoadSolutionFile('coordinatesSolution.txt') #load solution: adjust to your file name
-#mbs.SolutionViewer(sol) #call via MainSystem
-def SolutionViewer(mainSystem, solution=None, rowIncrement = 1, timeout=0.04, runOnStart = True, runMode=2, 
-                   fontSize=12, title='', checkRenderEngineStopFlag=True):
-
-    from exudyn.utilities import SetSolutionState, LoadSolutionFile
-    
-    mbs = mainSystem
-    SC = mbs.GetSystemContainer()
-
-    if solution is None: #'is' also works for numpy.array
-        if not 'simulationSettings' in mbs.sys:
-            raise ValueError('SolutionViewer: no solution file found (already simulated?)!')
-        sims = mbs.sys['simulationSettings']
-        if not sims.solutionSettings.writeSolutionToFile:
-            raise ValueError('SolutionViewer: previous simulation has writeSolutionToFile==False; no solution file available!')
-        filename = sims.solutionSettings.coordinatesSolutionFileName
-        if filename.find('.')==-1:
-            if sims.solutionSettings.binarySolutionFile:
-                filename+='.sol' #this is the default ending for binary file
-            else:
-                filename+='.txt' #this is the default ending for text
-                
-        solution = LoadSolutionFile(filename) #load solution file of previous simulation
-
-    nRows = solution['nRows']
-    if nRows == 0:
-        print('ERROR in SolutionViewer: solution file is empty')
-        return
-    if (runMode != 0 and runMode != 1 and runMode != 2):
-        print('ERROR in SolutionViewer: illegal run mode:', runMode)
-        return
-    if (rowIncrement < 1) or (rowIncrement > nRows):
-        print('ERROR in SolutionViewer: rowIncrement must be at least 1 and must not be larger than the number of rows in the solution file')
-    oldUpdateInterval = SC.visualizationSettings.general.graphicsUpdateInterval
-    SC.visualizationSettings.general.graphicsUpdateInterval = 0.5*min(timeout, 2e-3) #avoid too small values to run multithreading properly
-    mbs.SetRenderEngineStopFlag(False) #not to stop right at the beginning
-
-    # runLoop = False
-    # while runLoop and not mainSystem.GetRenderEngineStopFlag():
-    #     for i in range(0,nRows,rowIncrement):
-    #         if not(mainSystem.GetRenderEngineStopFlag()):
-    #             SetSolutionState(mainSystem, solution, i, exudyn.ConfigurationType.Visualization)
-    #             exudyn.DoRendererIdleTasks(timeout)
-
-    SetSolutionState(mainSystem, solution, 0, exudyn.ConfigurationType.Visualization)
-    exudyn.DoRendererIdleTasks(timeout)
-
-    nSteps = int(nRows)              #only make these steps available in slider!
-    maxNSteps = max(500,min(nSteps,1200))     #do not allow more steps, because dialog may be too large ...
-    resolution = min(1.,maxNSteps/nSteps) #do not use values smaller than 1
-    
-    dialogItems = [
-                   {'type':'label', 'text':'Solution steps:', 'grid':(1,0)},
-                   {'type':'slider', 'range':(0, nSteps-1), 'value':0, 'steps':maxNSteps, 'variable':'solutionViewerStep','resolution': resolution, 'grid':(1,1)},
-                   {'type':'label', 'text':'Increment:', 'grid':(2,0)},
-                   {'type':'slider', 'range':(1, 200), 'value':rowIncrement, 'steps':200, 'variable':'solutionViewerRowIncrement', 'grid':(2,1)},
-                   {'type':'label', 'text':'update period:', 'grid':(3,0)},
-                   {'type':'slider', 'range':(0.005, 1), 'value':timeout, 'steps':200, 'variable':'solutionViewerPeriod', 'grid':(3,1)},
-                   {'type':'radio', 'textValueList':[('Continuous run',0), ('One cycle',1), ('Static',2)],'value':runMode, 'variable':'solutionViewerRunModus', 'grid': [(4,0),(4,1),(4,2)]},
-                   {'type':'radio', 'textValueList':[('Record animation',0), ('No recording',1)],'value':1, 'variable':'solutionViewerSaveImages', 'grid': [(5,0),(5,1)]},
-                   ]
-
-
-    mbs.sys['solutionViewerRowIncrement'] = float(rowIncrement)
-    mbs.sys['solutionViewerNSteps'] = nSteps
-    mbs.sys['solutionViewerSolution'] = solution
-    # mbs.sys['solutionViewerStep'] = 0
-    # mbs.sys['solutionViewerPeriod'] = timeout
-
-    def UFviewer(mbs, dialog):
-        i = int(mbs.sys['solutionViewerStep'])
-
-        # mbs.systemData.SetTime(t, exudyn.ConfigurationType.Visualization)
-        SetSolutionState(mainSystem, mbs.sys['solutionViewerSolution'], i, exudyn.ConfigurationType.Visualization)
-        
-        mbs.SendRedrawSignal()
-        exudyn.DoRendererIdleTasks() #as there is no simulation, we must do this for singlethreaded renderer to draw graphicsDataUserFunctions
-
-        dialog.period = mbs.sys['solutionViewerPeriod']
-
-        if mbs.sys['solutionViewerRunModus'] < 2:
-            mbs.sys['solutionViewerStep'] += mbs.sys['solutionViewerRowIncrement']
-    
-            #first variable is scale, which contains step
-            dialog.variableList[0][0].set(mbs.sys['solutionViewerStep'])
-
-        if mbs.sys['solutionViewerSaveImages'] == 0:
-            #in single-threaded renderer, this causes 2x redraw, so we could save the above exudyn.DoRendererIdleTasks() then ...!
-            SC.RedrawAndSaveImage() #create images for animation
-
-        if mbs.sys['solutionViewerStep']>mbs.sys['solutionViewerNSteps']-1.:
-            #or (mbs.sys['solutionViewerRunModus'] and mbs.sys['solutionViewerStep']==mbs.sys['solutionViewerNSteps']-1.):
-            mbs.sys['solutionViewerStep'] = 0
-            dialog.variableList[0][0].set(0)
-
-            SetSolutionState(mainSystem, mbs.sys['solutionViewerSolution'], 0, exudyn.ConfigurationType.Visualization)
-            # mbs.SendRedrawSignal()
-            # exudyn.DoRendererIdleTasks() #as there is no simulation, we must do this for graphicsDataUserFunctions
-            if mbs.sys['solutionViewerRunModus'] == 1: #one cylce ==> stop
-                dialog.StartSimulation() #start/stop simulation
-
-        
-
-    if not exudyn.IsRendererActive():
-        exudyn.StartRenderer()
-        if 'renderState' in exudyn.sys: SC.SetRenderState(exudyn.sys['renderState']) #load last model view
-
-    simulationSettings = exudyn.SimulationSettings() #not used, but needed in dialog
-     #   self.mbs.sys['solver'].InitializeSolver(self.mbs, self.simulationSettings)
-    simulationSettings.solutionSettings.solutionInformation = ''
-
-    if not SC.visualizationSettings.general.useMultiThreadedRendering:
-        exudyn.DoRendererIdleTasks() #do an update once
-
-    dialogTitle='Solution Viewer'
-    if title != '':
-        dialogTitle = title
-
-    dialog = InteractiveDialog(mbs, simulationSettings=simulationSettings, 
-                      simulationFunction=UFviewer, 
-                      dialogItems=dialogItems,
-                      fontSize=fontSize,title=dialogTitle,
-                      doTimeIntegration=False, period=timeout,
-                      showTime=True, runOnStart=runOnStart, 
-                      checkRenderEngineStopFlag=checkRenderEngineStopFlag,
-                      useSysVariables=True, #use mbs.sys, not to bloat the mbs.variables of the user
-                      )
-
-    #SC.WaitForRenderEngineStopFlag() #not needed, Render window closes when dialog is quit
-    exudyn.StopRenderer() #safely close rendering window!
-
-    SC.visualizationSettings.general.graphicsUpdateInterval = oldUpdateInterval #set values back to original
-
-
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Utilities for interactive simulation and results monitoring; NOTE: does not work on MacOS!
+#
+# Author:   Johannes Gerstmayr
+# Date:     2021-01-17 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# Utility functions and structures for Exudyn
+
+import numpy as np #LoadSolutionFile
+from math import sin, pi #for animation
+#import time        
+import copy           #copy numpy objects
+import exudyn
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**class: create an interactive dialog, which allows to interact with simulations
+#the dialog has a 'Run' button, which initiates the simulation and a 'Stop' button which stops/pauses simulation; 'Quit' closes the simulation model
+#for examples, see \texttt{simulateInteractively.py} and \texttt{massSpringFrictionInteractive.py}
+#use \_\_init\_\_ method to setup this class with certain buttons, edit boxes and sliders
+#**example:
+# #the following example is only demonstrating the structure of dialogItems and plots
+# #dialogItems structure:
+# #general items: 
+# #    'type' can be out of:
+# #               'label' (simple text), 
+# #               'button' (button with callback function),
+# #               'radio' (a radio button with several alternative options),
+# #               'slider' (with an adjustable range to choose a value)
+# #    'grid': (row, col, colspan) specifies the row, column and (optionally) the span of columns the item is placed at;
+# #            exception in 'radio', where grid is a list of (row, col) for every choice
+# #    'options': text options, where 'L' means flush left, 'R' means flush right
+# #suboptions of 'label':
+# #               'text': a text to be drawn
+# #suboptions of 'button':
+# #               'text': a text to be drawn on button
+# #               'callFunction': function which is called on button-press
+# #suboptions of 'radio':
+# #               'textValueList': [('text1',0),('text2',1)] a list of texts with according values
+# #               'value': default value (choice) of radio buttons
+# #               'variable': according variable in mbs.variables (or mbs.sys), which is set to current radio button value
+# #suboptions of 'slider':
+# #               'range': (min, max) a tuple containing minimum and maximum value of slider
+# #               'value': default value of slider
+# #               'steps': number of steps in slider
+# #               'variable': according variable in mbs.variables (or mbs.sys), which is set to current slider value
+# #example:
+# dialogItems = [{'type':'label', 'text':'Nonlinear oscillation simulator', 'grid':(0,0,2), 'options':['L']},
+#                {'type':'button', 'text':'test button','callFunction':ButtonCall, 'grid':(1,0,2)},
+#                {'type':'radio', 'textValueList':[('linear',0),('nonlinear',1)], 'value':0, 'variable':'mode', 'grid': [(2,0),(2,1)]},
+#                {'type':'label', 'text':'excitation frequency (Hz):', 'grid':(5,0)},
+#                {'type':'slider', 'range':(3*f1/800, 3*f1), 'value':omegaInit/(2*pi), 'steps':800, 'variable':'frequency', 'grid':(5,1)},
+#                {'type':'label', 'text':'damping:', 'grid':(6,0)},
+#                {'type':'slider', 'range': (0, 40), 'value':damper, 'steps':800, 'variable':'damping', 'grid':(6,1)},
+#                {'type':'label', 'text':'stiffness:', 'grid':(7,0)},
+#                {'type':'slider', 'range':(0, 10000), 'value':spring, 'steps':800, 'variable':'stiffness', 'grid':(7,1)}]
+#
+# #plots structure:
+# plots={'nPoints':500,              #number of stored points in subplots (higher means slower drawing)
+#        'subplots':(2,1),           #(rows, columns) arrangement of subplots (for every sensor)
+#        #sensors defines per subplot (sensor, coordinate), xlabel and ylabel; if coordinate=0, time is used:
+#        'sensors':[[(sensPos,0),(sensPos,1),'time','mass position'], 
+#                   [(sensFreq,0),(sensFreq,1),'time','excitation frequency']],
+#        'limitsX':[(0,2),(-5,5)],   #x-range per subplot; if not provided, autoscale is applied
+#        'limitsY':[(-5,5),(0,10),], #y-range per subplot; if not provided, autoscale is applied
+#        'fontSize':16,              #custom font size for figure
+#        'subplots':False,           #if not specified, subplots are created; if False, all plots go into one window 
+#        'lineStyles':['r-','b-'],    #if not specified, uses default '-b', otherwise define list of line styles [string for matplotlib.pyplot.plot] per sensor
+#        'sizeInches':(12,12)}       #specific x and y size of figure in inches (using 100 dpi)
+class InteractiveDialog:
+    #**classFunction: initialize an InteractiveDialog
+    #**input: 
+    #  mbs: a multibody system to be simulated
+    #  simulationSettings: exudyn.SimulationSettings() according to user settings
+    #  simulationFunction: a user function(mbs, self) which is called before a simulation for the short period is started (e.g, assign special values, etc.); the arguments are the MainSystem mbs and the InteractiveDialog (self)
+    #  dialogItems: a list of dictionaries, which describe the contents of the interactive items, where every dict has the structure {'type':[label, entry, button, slider, check] ... according to tkinter widgets, 'callFunction': a function to be called, if item is changed/button pressed, 'grid': (row,col) of item to be placed, 'rowSpan': number of rows to be used, 'columnSpan': number of columns to be used; for special item options see notes}
+    #  plots: list of dictionaries to specify a sensor to be plotted live, see example; otherwise use default None
+    #  period: a simulation time span in seconds which is simulated with the simulationFunction in every iteration
+    #  realtimeFactor: if 1, the simulation is nearly performed in realtime (except for computation time); if > 1, it runs faster than realtime, if < 1, than it is slower
+    #  userStartSimulation: a function F(flag) which is called every time after Run/Stop is pressed. The argument flag = False if button "Run" has been pressed, flag = True, if "Stop" has been pressed
+    #  title: title text for interactive dialog
+    #  showTime: shows current time in dialog
+    #  fontSize: adjust font size for all dialog items
+    #  doTimeIntegration: performs internal time integration with given parameters
+    #  runOnStart: immediately activate 'Run' button on start
+    #  addLabelStringVariables: True: adds a list labelStringVariables containing the (modifiable) list of string variables for label (text) widgets
+    #  addSliderVariables: True: adds a list sliderVariables containing the (modifiable) list of variables for slider (=tkinter scale) widgets; this is not necessarily needed for changing slider values, as they can also be modified with dialog.widgets[..].set(...) method
+    #  checkRenderEngineStopFlag: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
+    #  userOnChange: a user function(mbs, self) which is called after period, if widget values are different from values stored in mbs.variables; this usually occurs if buttons are pressed or sliders are moved; the arguments are the MainSystem mbs and the InteractiveDialog (self)
+    #  useSysVariables: for internal visualization functions: in this case, variables are written to mbs.sys instead of mbs.variables
+    #**notes: detailed description of dialogItems and plots list/dictionary is given in commented the example below
+    def __init__(self, mbs, simulationSettings, simulationFunction, 
+                 dialogItems, plots = None, period = 0.04, 
+                 realtimeFactor = 1, userStartSimulation=None, 
+                 title='',  showTime=False, fontSize = 12,
+                 doTimeIntegration = True, runOnStart = False, 
+                 addLabelStringVariables=False, addSliderVariables=False, 
+                 checkRenderEngineStopFlag = True, userOnChange=None, useSysVariables=False):
+        
+        try:
+            import tkinter
+            import tkinter.font as tkFont
+            from exudyn.GUI import GetTkRootAndNewWindow
+        except:
+            raise ValueError('ERROR: InteractiveDialog: tkinter is not installed; InteractiveDialog or SolutionViewer are therefore not available')
+
+        
+        #store init arguments
+        self.mbs = mbs
+        self.simulationFunction = simulationFunction
+        self.simulationSettings = simulationSettings
+        self.title = title
+        self.dialogItems = dialogItems
+        self.period = period
+        self.realtimeFactor = realtimeFactor
+        self.stepSize = simulationSettings.timeIntegration.endTime/simulationSettings.timeIntegration.numberOfSteps
+        self.doTimeIntegration = doTimeIntegration
+
+        self.plots = plots
+        self.userStartSimulation = userStartSimulation
+        self.userOnChange = userOnChange
+        self.showTime = showTime
+        self.fontSize = fontSize
+        self.useSysVariables = useSysVariables
+        
+        self.checkRenderStop = checkRenderEngineStopFlag
+
+        if self.plots is None:
+            self.plots = []
+
+        if self.mbs.GetRenderEngineStopFlag() and self.checkRenderStop: #avoid immediate quit
+            self.mbs.SetRenderEngineStopFlag(False)
+
+
+        #create tkinter instance
+        [self.root, self.tkWindow, tkRuns] = GetTkRootAndNewWindow()
+
+        # root = self.root = tkinter.Tk()
+        #exudyn.sys['tkinterRoot'] = root #not needed anymore, as GUI.GetTkRootAndNewWindow() is used
+        self.tkWindow.protocol("WM_DELETE_WINDOW", self.OnQuit) #always leave app with OnQuit
+        self.tkWindow.title(title)
+        try:
+            systemScaling = self.tkWindow.call('tk', 'scaling') #obtains current scaling?
+        except:
+            pass
+        #print('systemScaling=',systemScaling)
+        systemScaling = 1
+
+        if (self.doTimeIntegration 
+            and self.simulationSettings.solutionSettings.writeInitialValues == True 
+            and mbs.systemData.AEsize() != 0):
+            print('WARNING: InteractiveDialog:\nyou should set simulationSettings.solutionSettings.writeInitialValues = False in order to avoid erroneous constraint outputs during time integration periods.\n')
+
+        #change global font size
+        if True:
+            defaultFont = tkFont.Font(root=self.tkWindow, family = "TkDefaultFont")#,weight = "bold")
+            defaultFont.configure(size=int(systemScaling*self.fontSize))
+            self.tkWindow.option_add("*Font", "TkDefaultFont") #all widgets should use TkDefaultFont; does not work
+        
+        self.counter = 0 #counter for simulationFunction
+        self.simulationStopped = True
+        self.variableList = [] #list of tuples: (widget, mbs variable name); value obtained with widget.get()
+
+        self.itemBorder = 2 #common border to items
+
+        tkinterNESW = tkinter.N+tkinter.E+tkinter.S+tkinter.W
+        
+        self.widgets = [] #store tk widgets as list, for later access
+        self.labelStringVariables = [] #store string variables to modify widget text hereafter
+        self.sliderVariables = [] #store string variables to modify widget text hereafter
+
+        for item in dialogItems:
+            text = ''
+            setGrid = False
+            # sticky = 'NSEW'
+           
+            if 'text' in item:
+                text = item['text']
+            # if 'sticky' in item:
+            #     sticky = item['sticky']
+            #++++++++++++++++++++++++++++++++++
+            if item['type'] == 'label':
+                setGrid = True
+                if addLabelStringVariables:
+                    stringVar = tkinter.StringVar()
+                    widget = tkinter.Label(self.tkWindow, textvariable = stringVar, 
+                                           borderwidth = self.itemBorder, 
+                                           #justify=tkinter.LEFT, #needed?
+                                           font=defaultFont)
+                    stringVar.set(text)
+                    self.labelStringVariables += [stringVar] #store in list
+                else:
+                    widget = tkinter.Label(self.tkWindow, text = text, 
+                                           borderwidth = self.itemBorder, 
+                                           font=defaultFont)
+
+            #++++++++++++++++++++++++++++++++++
+            elif item['type'] == 'button':
+                setGrid = True
+                widget = tkinter.Button(self.tkWindow, text = text, 
+                                       borderwidth = self.itemBorder, 
+                                       font=defaultFont)
+                if 'callFunction' in item:
+                    widget['command'] = item['callFunction']
+            #++++++++++++++++++++++++++++++++++
+            elif item['type'] == 'slider':
+                setGrid = True
+                steps = 400
+                minValue = 0
+                maxValue = 1
+                initialValue = 0.5
+                if 'steps' in item:
+                    steps = item['steps']
+                if 'range' in item:
+                    minValue = item['range'][0]
+                    maxValue = item['range'][1]
+                if 'value' in item:
+                    initialValue = item['value']
+                if initialValue < minValue or initialValue > maxValue:
+                    initialValue = 0.5*(minValue+maxValue)
+                resolutionItem = (maxValue-minValue)/max(1,(steps-1))
+                if 'resolution' in item: #resolution is needed, if we want to do bi-directional set/get of slider values (otherwise digits are lost)
+                     resolutionItem = item['resolution']
+
+                nDigits = 4
+                if maxValue-minValue == steps-1:
+                    nDigits = 0
+                
+                if not addSliderVariables:
+                    widget = tkinter.Scale(self.tkWindow, from_=minValue, to=maxValue,
+                                           length = steps, digits=nDigits, resolution=resolutionItem,
+                                           orient=tkinter.HORIZONTAL,
+                                           font=defaultFont)
+                    widget.set(initialValue)
+                else:
+                    #add option to modify scale from outside
+                    tkVariable = tkinter.DoubleVar()
+                    tkVariable.set(initialValue)
+                    widget = tkinter.Scale(self.tkWindow, from_=minValue, to=maxValue,
+                                           length = steps, digits=nDigits, resolution=resolutionItem,
+                                           orient=tkinter.HORIZONTAL,
+                                           variable=tkVariable,
+                                           font=defaultFont)
+                    self.sliderVariables += [tkVariable]
+                    #but using widget.set(..) also allows to adjust widget from external function!
+                    
+                if 'callFunction' in item:
+                    widget['command'] = self.item['callFunction']
+                if 'variable' in item:
+                    self.variableList += [(widget, item['variable'])]
+
+            #++++++++++++++++++++++++++++++++++
+            elif item['type'] == 'radio':
+                var = tkinter.IntVar()
+                var.set(item['value'])
+                cnt = 0
+                for opt in item['textValueList']:
+                    widget = tkinter.Radiobutton(self.tkWindow, 
+                                                text=opt[0],
+                                                padx = 20, 
+                                                variable=var, 
+                                                value=opt[1], 
+                                                #height=1, width=1, 
+                                                indicatoron=0, #use highlighting instead of checkboxes
+                                                font=defaultFont)
+                    if 'grid' in item:
+                        grid = item['grid'][cnt] #must be list of grid values
+                        if len(grid) == 2:
+                            widget.grid(row=grid[0], column=grid[1], sticky=tkinterNESW)
+                        elif len(grid) == 3:
+                            widget.grid(row=grid[0], column=grid[1], columnspan=grid[2], sticky=tkinterNESW)
+                    # not needed, all flush left
+                    # if 'options' in item:
+                    #     if 'L' in item['options']:
+                    #         widget['anchor'] = 'w'
+                    #     if 'R' in item['options']:
+                    #         widget['anchor'] = 'e'
+                    else:
+                        widget.grid(column=0, sticky=tkinter.W)
+                    cnt+=1
+                self.variableList += [(var, item['variable'])] #store widget variable and mbs variable
+            #++++++++++++++++++++++++++++++++++
+            if setGrid:
+                if 'grid' in item:
+                    grid = item['grid']
+                    if len(grid) == 2:
+                        widget.grid(row=grid[0], column=grid[1], sticky=tkinterNESW)
+                    elif len(grid) == 3:
+                        widget.grid(row=grid[0], column=grid[1], columnspan=grid[2], sticky=tkinterNESW)
+                    elif len(grid) == 4:
+                        widget.grid(row=grid[0], column=grid[1], columnspan=grid[2], rowspan=grid[3], sticky=tkinterNESW)
+                    else:
+                        raise ValueError("ERROR: InteractiveDialog: grid must have 2, 3, or 4 components")
+                else:
+                    widget.grid(column=0, sticky=tkinterNESW)
+                if 'options' in item:
+                    if 'L' in item['options']:
+                        widget['anchor'] = 'w'
+                    if 'R' in item['options']:
+                        widget['anchor'] = 'e'
+            self.widgets += [widget]
+            # if item['type'] == 'entry' and firstEntry: #entry may get focus
+            #     firstEntry = False
+            #     widget.focus_set() #set focus to first item
+                
+        #show current time 
+        if self.showTime:
+            self.currentTime = tkinter.StringVar()
+            widget = tkinter.Label(self.tkWindow, textvariable = self.currentTime, 
+                                   borderwidth = self.itemBorder, justify=tkinter.LEFT,
+                                   font=defaultFont)
+            self.currentTime.set('t = ')
+            widget.grid(column=0, sticky=tkinter.W)
+
+        #add run button into last row:
+        self.RunButtonText = tkinter.StringVar()
+        self.Run = tkinter.Button(self.tkWindow, textvariable=self.RunButtonText,
+                                  borderwidth = self.itemBorder, font=defaultFont)
+        self.RunButtonText.set('Run')
+        
+        self.Run.grid(column=0, sticky=tkinterNESW)#, row=maxRow+1)
+        self.Run['command'] = self.StartSimulation
+        self.Run.focus_set() #does not work
+        
+        self.tkWindow.bind('<space>', func=self.StartSimulation) #if focus is not set to button ...
+        self.tkWindow.bind('<Escape>', self.OnQuit) #Escape causes immediate quit (no further checks)
+        self.tkWindow.bind('q', self.OnQuit) #Button 'Q' causes immediate quit (no further checks)
+
+        self.tkWindow.update()
+        if self.tkWindow.winfo_width() < 320:
+            self.tkWindow.minsize(320,self.tkWindow.winfo_height())
+        #self.tkWindow.minsize(280,50) #will create windows which are too small
+
+        self.InitializeSolver() #solver gets ready to be called repeatedly
+        self.InitializePlots()  #set up all structures for plots
+        self.UpdatePlots()      #update all subplots with new sensor values
+
+        if runOnStart:          #immediately activate run function on startup
+            self.StartSimulation()
+        self.tkWindow.deiconify()
+        # self.tkWindow.mainloop()
+        tkinter.mainloop()
+
+    #**classFunction: function called when pressing escape or closing dialog
+    def OnQuit(self, event=None):
+        self.simulationStopped = True
+        self.RunButtonText.set('Stop')
+        self.FinalizeSolver()
+        #del exudyn.sys['tkinterRoot'] #this is not thread safe, but interuption should not happen ...
+        self.tkWindow.quit()
+        self.tkWindow.destroy()
+
+    #**classFunction: function called on button 'Run'
+    def StartSimulation(self, event=None):
+        self.simulationStopped = not self.simulationStopped
+        if not self.simulationStopped:
+            self.RunButtonText.set('Stop')
+        else:
+            self.RunButtonText.set('Run')
+
+        if self.userStartSimulation != None:
+            self.userStartSimulation(self.simulationStopped)
+        #self.ProcessWidgetStates() #do this finally, to update states, which may have changed in last step (SolutionViewer!)
+        self.ContinuousRunFunction()
+
+    #**classFunction: assign current values of radio buttons and sliders to mbs.variables or mbs.sys
+    def ProcessWidgetStates(self):
+        changed = False
+        for var in self.variableList:
+            v = var[0].get()
+            if self.useSysVariables:
+                destinationDict = self.mbs.sys #this is a link!
+            else:
+                destinationDict = self.mbs.variables
+            if not var[1] in destinationDict or v != destinationDict[var[1]]:
+                destinationDict[var[1]] = v
+                changed = True
+        if changed and self.userOnChange != None:
+            self.userOnChange(self.mbs, self) #this user function is called every time a value has changed, within update period
+
+    #**classFunction: function which is repeatedly called when button 'Run' is pressed
+    def ContinuousRunFunction(self, event=None):
+        if not self.simulationStopped:
+            self.ProcessWidgetStates()
+            exudyn.DoRendererIdleTasks() #for MacOS, but also to open visualization dialog, etc.
+            #print(".")
+            if self.mbs.GetRenderEngineStopFlag() and self.checkRenderStop:
+                self.OnQuit()
+            else:
+                t = self.RunSimulationPeriod()
+                if self.showTime:
+                    self.currentTime.set('t = '+str(round(t,6)))
+                self.counter += 1
+                delay = max(1, int(self.period*1000/self.realtimeFactor))
+                self.tkWindow.after(delay, self.ContinuousRunFunction)
+                # self.Run.after(delay, self.ContinuousRunFunction)
+
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: initialize figure and subplots for plots structure
+    def InitializePlots(self):
+        if len(self.plots) != 0:
+            import matplotlib.pyplot as plt
+            plt.rcParams.update({'font.size': self.plots['fontSize']})
+        
+            fig = plt.figure()
+            fig.dpi = 100 #in terminal, initially set to 200
+            fig.tight_layout()
+            if 'sizeInches' in self.plots: #otherwise use default figure size
+                fig.set_size_inches(self.plots['sizeInches'][0], self.plots['sizeInches'][1], forward=True)
+            nPoints = self.plots['nPoints']
+            self.plots['fig'] = fig
+            self.plots['currentIndex'] = 0
+            nSensors = len(self.plots['sensors'])
+            self.plots['data'] = [np.zeros((nPoints,2))]*nSensors
+            self.plots['line'] = [0]*nSensors
+            self.plots['marker'] = [0]*nSensors
+            self.plots['ax'] = [0]*nSensors
+            lineStyle = 'b-'
+            doSubplots = True
+            if 'subplots' in self.plots:
+                doSubplots = self.plots['subplots']
+            if not doSubplots:
+                axPlot = fig.add_subplot(1,1,1)
+        
+            for j in range(nSensors):
+                if doSubplots:
+                    self.plots['ax'][j] = fig.add_subplot(self.plots['subplots'][0],self.plots['subplots'][1],j+1)
+                else:
+                    self.plots['ax'][j] = axPlot
+                self.plots['ax'][j].grid(True, 'major', 'both')
+                self.plots['ax'][j].set_xlabel(self.plots['sensors'][j][2])
+                self.plots['ax'][j].set_ylabel(self.plots['sensors'][j][3])
+                
+                data = np.zeros((nPoints,2))
+                if self.plots['sensors'][j][0][1] == 0: #time of sensor
+                    data[:,0] = np.linspace(self.period,nPoints*self.period,num=nPoints)
+                #data[:,1] = 0 #not needed
+                self.plots['data'][j] = copy.deepcopy(data)
+                
+                if 'lineStyles' in self.plots:
+                    lineStyle = self.plots['lineStyles'][j]
+                self.plots['line'][j], = self.plots['ax'][j].plot(data[:,0],data[:,1], lineStyle)
+                self.plots['marker'][j], = self.plots['ax'][j].plot(0,0, 'ro') #red circle
+                self.plots['ax'][j].set_xlim(min(data[:,0]), max(data[:,0]))
+
+    #**classFunction: update all subplots with current sensor values
+    def UpdatePlots(self):
+        if len(self.plots) != 0:
+            n = self.plots['nPoints']
+            i = self.plots['currentIndex']
+            t = self.simulationSettings.timeIntegration.startTime #current time
+    
+            for j in range(len(self.plots['sensors'])):
+                data = self.plots['data'][j]
+                
+                sensorNum = [0,0]
+                sensorCoord = [0,0]
+                for k in range(2):
+                    sensorNum = self.plots['sensors'][j][k][0]
+                    sensorCoord = self.plots['sensors'][j][k][1]
+                    if sensorCoord == 0:
+                        data[i,k] = t
+                    else:
+                        value = self.mbs.GetSensorValues(sensorNum)
+                        if type(value)==np.ndarray:
+                            data[i,k] = value[sensorCoord-1]
+                        elif sensorCoord == 1:
+                            data[i,k] = value
+                        else:
+                            raise ValueError('ERROR: InteractiveDialog: plots.sensor '+str(j)+': access to invalid coordinate')
+                            
+                self.plots['line'][j].set_data(data[:,0], data[:,1]) 
+                self.plots['marker'][j].set_data(data[i,0], data[i,1]) 
+    
+                self.plots['ax'][j].set_xlim(min(data[:,0]), max(data[:,0]))
+                
+                if 'limitsX' in self.plots:
+                    if len(self.plots['limitsX'][j]):
+                        self.plots['ax'][j].set_xlim(self.plots['limitsX'][j][0],self.plots['limitsX'][j][1])
+                if 'limitsY' in self.plots:
+                    if len(self.plots['limitsY'][j]):
+                        self.plots['ax'][j].set_ylim(self.plots['limitsY'][j][0],self.plots['limitsY'][j][1])
+                #autoscale, if no limits given
+                self.plots['ax'][j].relim(visible_only=True)
+                self.plots['ax'][j].autoscale_view(tight=True)
+            
+            #update figure:
+            self.plots['fig'].canvas.draw()
+            self.plots['fig'].canvas.flush_events()
+    
+            if i < n-1:
+                self.plots['currentIndex'] += 1
+    
+            for j in range(len(self.plots['sensors'])):
+                data = self.plots['data'][j]
+                if i == n-1:
+                    data = np.roll(data, -1, axis=0)
+                self.plots['data'][j] = data #data references mbs variable
+
+
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #**classFunction: function to initialize solver for repeated calls
+    def InitializeSolver(self):
+        if self.doTimeIntegration:
+            self.mbs.sys['solver'] = exudyn.MainSolverImplicitSecondOrder()
+            self.mbs.sys['solver'].InitializeSolver(self.mbs, self.simulationSettings)
+
+    #**classFunction: stop solver (finalize correctly)
+    def FinalizeSolver(self):
+        if self.doTimeIntegration:
+            self.mbs.sys['solver'].FinalizeSolver(self.mbs, self.simulationSettings) #shut down solver correctly (finalize files, ...)
+
+
+    #**classFunction: function which performs short simulation for given period        
+    def RunSimulationPeriod(self):
+        deltaT = self.period
+        h = self.stepSize
+        mbs = self.mbs
+
+        #+++++++++++++++++++++++++++++++++++++++++
+        #this is the USER PART
+        self.simulationFunction(self.mbs, self)
+        #+++++++++++++++++++++++++++++++++++++++++
+    
+        if self.doTimeIntegration and False: #slow way, always start/stop simulation; resets sensor data ...
+            self.simulationSettings.timeIntegration.numberOfSteps = max(int(deltaT/h),1)
+            self.simulationSettings.timeIntegration.endTime = self.simulationSettings.timeIntegration.startTime+deltaT
+            exudyn.SolveDynamic(mbs, self.simulationSettings, updateInitialValues=True)
+            self.simulationSettings.timeIntegration.startTime += deltaT
+    
+        #+++++++++++++++++++++++++++++++++++++++++
+        #PLOT PART, done every time before simulation starts
+        self.UpdatePlots()
+    
+        #+++++++++++++++++++++++++++++++++++++++++
+        #TIME STEPPING PART
+        if self.doTimeIntegration and True:
+        
+            self.simulationSettings.timeIntegration.numberOfSteps = max(int(deltaT/h),1)
+            self.simulationSettings.timeIntegration.endTime = self.simulationSettings.timeIntegration.startTime+deltaT
+
+            #update 2023-01-06: also update accelerations, needed for implicit solvers!
+            #initial accelerations are set sero in initialization ...
+            initAcc = mbs.systemData.GetODE2Coordinates_tt(configuration = exudyn.ConfigurationType.Current)
+            #not needed, if simulationSettings.solutionSettings.writeInitialValues = False 
+            #initAE = mbs.systemData.GetAECoordinates(configuration = exudyn.ConfigurationType.Current) 
+
+            mbs.sys['solver'].InitializeSolverInitialConditions(mbs, self.simulationSettings) #needed to update simulationSettings in solver
+
+            mbs.systemData.SetODE2Coordinates_tt(coordinates = initAcc)
+            #mbs.systemData.SetAECoordinates(coordinates = initAE)
+
+            mbs.sys['solver'].SolveSteps(mbs, self.simulationSettings)
+            
+            #get current values and update initial conditions for next step:
+            currentState = mbs.systemData.GetSystemState()
+            mbs.systemData.SetSystemState(systemStateList=currentState, configuration = exudyn.ConfigurationType.Initial)
+            # mbs.systemData.SetODE2Coordinates_tt(coordinates = mbs.systemData.GetODE2Coordinates_tt(), 
+            #                                         configuration = exudyn.ConfigurationType.Initial)
+        
+            self.simulationSettings.timeIntegration.startTime += deltaT
+    
+        return self.simulationSettings.timeIntegration.endTime #return current time for dialog
+
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: animate modes of ObjectFFRFreducedOrder, of nodal coordinates (changes periodically one nodal coordinate) or of a list of system modes provided as list of lists; for creating snapshots, press 'Static' and 'Record animation' and press 'Run' to save one figure in the image subfolder; for creating animations for one mode, use the same procedure but use 'One Cycle'. Modes may be inverted by pressing according '+' and '-' buttons next to Amplitude.
+#**input:
+#    systemContainer: system container (usually SC) of your model, containing visualization settings
+#    mainSystem: system (usually mbs) containing your model
+#    nodeNumber: node number of which the coordinates shall be animated. In case of ObjectFFRFreducedOrder, this is the generic node, e.g., 'nGenericODE2' in the dictionary returned by the function AddObjectFFRFreducedOrderWithUserFunctions(...); if nodeNumber=None, then the systemEigenVectors list is used
+#    period: delay for animation of every frame; the default of 0.04 results in approximately 25 frames per second
+#    stepsPerPeriod: number of steps into which the animation of one cycle of the mode is split into
+#    showTime: show a virtual time running from 0 to 2*pi during one mode cycle
+#    renderWindowText: additional text written into renderwindow before 'Mode X' (use $\backslash$n to add line breaks)
+#    runOnStart: immediately go into 'Run' mode
+#    runMode: 0=continuous run, 1=static continuous, 2=one cycle, 3=static (use slider/mouse to vary time steps)
+#    scaleAmplitude: additional scaling for amplitude if necessary
+#    fontSize: define font size for labels in InteractiveDialog
+#    title: if empty, it uses default; otherwise define specific title
+#    checkRenderEngineStopFlag: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
+#    systemEigenVectors: may be a list of lists of system eigenvectors for ODE2 (and possibly ODE1) coordinates or a eigenvector matrix containing mode vectors in columns; if nodeNumber=None, these eigenvectors are then used to be animated
+#**output: opens interactive dialog with further settings
+#**notes: Uses class InteractiveDialog in the background, which can be used to adjust animation creation. If meshes are large, animation artifacts may appear, which are resolved by using a larger update period.
+#    Press 'Run' to start animation; Chose 'Mode shape', according component for contour plot; to record one cycle for animation, choose 'One cycle', run once to get the according range in the contour plot, press 'Record animation' and press 'Run', now images can be found in subfolder 'images' (for further info on animation creation see \refSection{sec:overview:basics:animations}); now deactivate 'Record animation' by pressing 'Off' and chose another mode
+def AnimateModes(systemContainer, mainSystem, nodeNumber, period = 0.04, stepsPerPeriod = 30, showTime = True, 
+                 renderWindowText = '', runOnStart = False, runMode=0, scaleAmplitude = 1, title='', fontSize = 12,
+                 checkRenderEngineStopFlag = True, systemEigenVectors=None):
+
+    SC = systemContainer
+    mbs = mainSystem
+    SC.visualizationSettings.general.graphicsUpdateInterval = 0.25*min(period, 2e-3) #set according update interval!
+    SC.visualizationSettings.general.showSolverTime = showTime
+    #SC.visualizationSettings.general.showComputationInfo = False
+    SC.visualizationSettings.general.showSolverInformation = False
+    SC.visualizationSettings.general.renderWindowString = renderWindowText+'mode 0'
+    
+    if nodeNumber != None:
+        coordIndex = mbs.GetNodeODE2Index(nodeNumber)
+        nodeCoords = mbs.GetNodeOutput(nodeNumber,exudyn.OutputVariableType.Coordinates,exudyn.ConfigurationType.Reference)
+        numberOfModes = len(nodeCoords)
+    else:
+        if type(systemEigenVectors) == np.ndarray:
+            systemEigenVectors = systemEigenVectors.T.tolist()
+
+        if type(systemEigenVectors) != list or len(systemEigenVectors)==0:
+            raise ValueError('AnimateModes: in case that nodeNumber=None, systemEigenVectors must be non-empty list of system eigenvectors, but received ',systemEigenVectors)
+                
+        numberOfModes = len(systemEigenVectors)
+        coordIndex = None #this indicates that systemEigenVectors are used
+        for vec in systemEigenVectors:
+            if type(vec) != list or len(vec) < mbs.systemData.ODE2Size():
+                raise ValueError('AnimateModes: in case that nodeNumber=None, systemEigenVectors must at least have ODE2 size components')
+
+    if (runMode < 0 or runMode > 3):
+        raise ValueError('AnimateModes: illegal run mode:', runMode)
+    
+    #use interactive dialog:
+    dialogItems = [
+                   {'type':'label', 'text':'Mode shape:', 'grid':(1,0)},
+                   {'type':'slider', 'range':(0, numberOfModes-1), 'value':0, 'steps':numberOfModes, 'variable':'modeShapeModeNumber', 'grid':(1,1)},
+                   {'type':'label', 'text':'Contour plot:', 'grid':(2,0)},
+                   {'type':'radio', 'textValueList':[('None',int(exudyn.OutputVariableType._None)),
+                                                     ('DisplacementLocal',int(exudyn.OutputVariableType.DisplacementLocal)),
+                                                      ('Displacement',int(exudyn.OutputVariableType.Displacement)),
+                                                      ('StressLocal',int(exudyn.OutputVariableType.StressLocal)),
+                                                      ('StrainLocal',int(exudyn.OutputVariableType.StrainLocal))], 
+                    'value':int(exudyn.OutputVariableType.DisplacementLocal), 'variable':'modeShapeOutputVariable', 'grid': [(3,0),(3,1),(3,2),(3,3),(3,4)]},
+                   {'type':'label', 'text':'Contour Component (use -1 for norm):', 'grid':(4,0)},
+                   {'type':'slider', 'range':(-1, 5), 'value':0, 'steps':7, 'variable':'modeShapeComponent', 'grid':(4,1)},
+                   {'type':'label', 'text':'Amplitude:', 'grid':(5,0)},
+                   {'type':'slider', 'range':(0, 1), 'value':0.05, 'steps':501, 'variable':'modeShapeAmplitude', 'grid':(5,1)},
+                   {'type':'radio', 'textValueList':[('positive',1), ('negative',-1)],'value':1, 'variable':'modeSignAmplitude', 'grid': [(5,2),(5,3)]},
+                   {'type':'label', 'text':'update period:', 'grid':(6,0)},
+                   {'type':'slider', 'range':(0.01, 2), 'value':0.04, 'steps':200, 'variable':'modeShapePeriod', 'grid':(6,1)},
+                   {'type':'radio', 'textValueList':[('Continuous run',0), ('Static continuous',1), ('One cycle',2), ('Static once',3)],'value':runMode, 'variable':'modeShapeRunModus', 'grid': [(7,0),(7,1),(7,2),(7,3)]},
+                   {'type':'radio', 'textValueList':[('Mesh+Faces',3), ('Faces only',1), ('Mesh only',2)],'value':3, 'variable':'modeShapeMesh', 'grid': [(8,0),(8,1),(8,2)]},
+                   {'type':'radio', 'textValueList':[('Record animation',0), ('No recording',1)],'value':1, 'variable':'modeShapeSaveImages', 'grid': [(9,0),(9,1)]},
+                   ]
+
+    mbs.sys['modeShapePeriod'] = period
+    mbs.sys['modeShapeStepsPerPeriod'] = stepsPerPeriod
+    mbs.sys['modeShapeTimeIndex'] = 0
+    mbs.sys['modeShapeLastSetting'] = [-1,0,0,0]
+    mbs.sys['modeShapeNodeCoordIndex'] = coordIndex
+    mbs.sys['modeShapeSystemEigenVectors'] = systemEigenVectors
+    mbs.sys['modeShapeScaleAmplitude'] = scaleAmplitude
+    mbs.sys['modeSignAmplitude'] = 1
+
+    def UFshowModes(mbs, dialog):
+        i = mbs.sys['modeShapeTimeIndex']
+        mbs.sys['modeShapeTimeIndex'] += 1
+        stepsPerPeriod = mbs.sys['modeShapeStepsPerPeriod']
+        amplitude = mbs.sys['modeShapeAmplitude']*mbs.sys['modeSignAmplitude']
+        if amplitude == 0:
+            SC.visualizationSettings.bodies.deformationScaleFactor = 0
+            amplitude = 1
+        else:
+            SC.visualizationSettings.bodies.deformationScaleFactor = 1
+
+        if mbs.sys['modeShapeRunModus'] == 1 or mbs.sys['modeShapeRunModus'] == 3: #no sin(t) in static case
+            stepsPerPeriod = 1
+            t = 0
+        else:
+            t = i/stepsPerPeriod * 2 * pi
+            amplitude *= sin(t)
+        mbs.systemData.SetTime(t, exudyn.ConfigurationType.Visualization)
+        
+        selectedMode = int(mbs.sys['modeShapeModeNumber'])
+        outputVariable = exudyn.OutputVariableType(int(mbs.sys['modeShapeOutputVariable']))
+       
+        if mbs.sys['modeShapeNodeCoordIndex'] != None:
+            ode2Coords = mbs.systemData.GetODE2Coordinates()
+            ode2Coords[mbs.sys['modeShapeNodeCoordIndex']+selectedMode] = amplitude * mbs.sys['modeShapeScaleAmplitude']
+            mbs.systemData.SetODE2Coordinates(ode2Coords, exudyn.ConfigurationType.Visualization)
+        else:
+            ode2Size = mbs.systemData.ODE2Size()
+            ode1Size = mbs.systemData.ODE1Size()
+            modeVector = np.array(mbs.sys['modeShapeSystemEigenVectors'][selectedMode])
+            ode2Coords = amplitude * modeVector[0:ode2Size]
+            mbs.systemData.SetODE2Coordinates(ode2Coords, exudyn.ConfigurationType.Visualization)
+            if ode1Size != 0 and len(modeVector) >= ode2Size+ode1Size:
+                ode1Coords = amplitude * modeVector[ode2Size:ode2Size+ode1Size]
+                mbs.systemData.SetODE1Coordinates(ode1Coords, exudyn.ConfigurationType.Visualization)
+
+
+        SC.visualizationSettings.contour.reduceRange = False
+        #check, if automatic range of contour colors shall be recomputed:
+        if (  mbs.sys['modeShapeLastSetting'][0] != int(mbs.sys['modeShapeModeNumber']) or 
+              mbs.sys['modeShapeLastSetting'][1] != int(mbs.sys['modeShapeOutputVariable']) or
+              mbs.sys['modeShapeLastSetting'][2] != mbs.sys['modeShapeAmplitude'] or
+              mbs.sys['modeShapeLastSetting'][3] != int(mbs.sys['modeShapeComponent'])):
+            SC.visualizationSettings.contour.reduceRange = True
+            SC.visualizationSettings.general.renderWindowString = renderWindowText+'mode '+str(int(mbs.sys['modeShapeModeNumber']))
+        
+        mbs.sys['modeShapeLastSetting'] = [int(mbs.sys['modeShapeModeNumber']),
+                                           int(mbs.sys['modeShapeOutputVariable']),
+                                           mbs.sys['modeShapeAmplitude'],
+                                           int(mbs.sys['modeShapeComponent'])]
+
+
+        SC.visualizationSettings.contour.outputVariable = outputVariable
+        SC.visualizationSettings.contour.outputVariableComponent = int(mbs.sys['modeShapeComponent']) #component
+
+        #SC.visualizationSettings.openGL.showFaces = (mbs.sys['modeShapeMesh'] & 1) == 1
+        SC.visualizationSettings.openGL.showMeshFaces = (mbs.sys['modeShapeMesh'] & 1) == 1
+
+        #SC.visualizationSettings.openGL.showFaceEdges = (mbs.sys['modeShapeMesh'] & 2) == 2
+        SC.visualizationSettings.openGL.showMeshEdges = (mbs.sys['modeShapeMesh'] & 2) == 2
+        
+
+        mbs.SendRedrawSignal()
+        if not SC.visualizationSettings.general.useMultiThreadedRendering:
+            exudyn.DoRendererIdleTasks()
+        if mbs.sys['modeShapeSaveImages'] == 0:
+            SC.RedrawAndSaveImage() #create images for animation
+        else:
+            SC.visualizationSettings.exportImages.saveImageFileCounter = 0 #for next mode ...
+
+        dialog.period = mbs.sys['modeShapePeriod']
+
+        if mbs.sys['modeShapeTimeIndex']>=stepsPerPeriod:
+           mbs.sys['modeShapeTimeIndex'] = 0
+           if mbs.sys['modeShapeRunModus'] > 1: #one cylce or static once
+               dialog.StartSimulation()
+        
+    if not exudyn.IsRendererActive():
+        exudyn.StartRenderer()
+        if 'renderState' in exudyn.sys: SC.SetRenderState(exudyn.sys['renderState']) #load last model view
+
+    simulationSettings = exudyn.SimulationSettings() #not used, but needed in dialog
+     #   self.mbs.sys['solver'].InitializeSolver(self.mbs, self.simulationSettings)
+    simulationSettings.solutionSettings.solutionInformation = 'Mode X'
+
+    if not SC.visualizationSettings.general.useMultiThreadedRendering:
+        exudyn.DoRendererIdleTasks() #do an update once
+
+    titleDialog = 'Animate mode shapes'
+    if title != '': 
+        titleDialog = title
+    
+    dialog = InteractiveDialog(mbs, simulationSettings=simulationSettings, 
+                      simulationFunction=UFshowModes, 
+                      dialogItems=dialogItems,
+                      title=titleDialog,
+                      doTimeIntegration=False, period=period,
+                      showTime=False,#done in UFshowModes
+                      runOnStart=runOnStart, 
+                      checkRenderEngineStopFlag=checkRenderEngineStopFlag,
+                      fontSize=fontSize,
+                      useSysVariables=True, #use mbs.sys, not to bloat the mbs.variables of the user
+                      )
+    
+    #SC.WaitForRenderEngineStopFlag() #not needed, Render window closes when dialog is quit
+    exudyn.StopRenderer() #safely close rendering window!
+
+
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: open interactive dialog and visulation (animate) solution loaded with LoadSolutionFile(...); Change slider 'Increment' to change the automatic increment of time frames; Change mode between continuous run, one cycle (fits perfect for animation recording) or 'Static' (to change Solution steps manually with the mouse); update period also lets you change the speed of animation; Press Run / Stop button to start/stop interactive mode (updating of grpahics)
+#**input: 
+#  mainSystem: the system used for visualization of solution (solution is loaded into visualization state of that system)
+#  solution: solution dictionary previously loaded with exudyn.utilities.LoadSolutionFile(...); will be played from first to last row; if solution==None, it tries to load the file coordinatesSolutionFileName as stored in mbs.sys['simulationSettings'], which are the simulationSettings of the previous simulation
+#  rowIncrement: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
+#  timeout: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
+#  runOnStart: immediately go into 'Run' mode
+#  runMode: 0=continuous run, 1=one cycle, 2=static (use slider/mouse to vary time steps)
+#  fontSize: define font size for labels in InteractiveDialog
+#  title: if empty, it uses default; otherwise define specific title
+#  checkRenderEngineStopFlag: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
+#**output: None; updates current visualization state, renders the scene continuously (after pressing button 'Run')
+#**belongsTo: MainSystem
+#**example:
+##HERE, mbs must contain same model as solution stored in coordinatesSolution.txt
+#
+##adjust autoFitScence, otherwise it may lead to unwanted fit to scene
+#SC.visualizationSettings.general.autoFitScene = False
+#
+#from exudyn.interactive import SolutionViewer #import function
+#sol = LoadSolutionFile('coordinatesSolution.txt') #load solution: adjust to your file name
+#mbs.SolutionViewer(sol) #call via MainSystem
+def SolutionViewer(mainSystem, solution=None, rowIncrement = 1, timeout=0.04, runOnStart = True, runMode=2, 
+                   fontSize=12, title='', checkRenderEngineStopFlag=True):
+
+    from exudyn.utilities import SetSolutionState, LoadSolutionFile
+    
+    mbs = mainSystem
+    SC = mbs.GetSystemContainer()
+
+    if solution is None: #'is' also works for numpy.array
+        if not 'simulationSettings' in mbs.sys:
+            raise ValueError('SolutionViewer: no solution file found (already simulated?)!')
+        sims = mbs.sys['simulationSettings']
+        if not sims.solutionSettings.writeSolutionToFile:
+            raise ValueError('SolutionViewer: previous simulation has writeSolutionToFile==False; no solution file available!')
+        filename = sims.solutionSettings.coordinatesSolutionFileName
+        if filename.find('.')==-1:
+            if sims.solutionSettings.binarySolutionFile:
+                filename+='.sol' #this is the default ending for binary file
+            else:
+                filename+='.txt' #this is the default ending for text
+                
+        solution = LoadSolutionFile(filename) #load solution file of previous simulation
+
+    nRows = solution['nRows']
+    if nRows == 0:
+        print('ERROR in SolutionViewer: solution file is empty')
+        return
+    if (runMode != 0 and runMode != 1 and runMode != 2):
+        print('ERROR in SolutionViewer: illegal run mode:', runMode)
+        return
+    if (rowIncrement < 1) or (rowIncrement > nRows):
+        print('ERROR in SolutionViewer: rowIncrement must be at least 1 and must not be larger than the number of rows in the solution file')
+    oldUpdateInterval = SC.visualizationSettings.general.graphicsUpdateInterval
+    SC.visualizationSettings.general.graphicsUpdateInterval = 0.5*min(timeout, 2e-3) #avoid too small values to run multithreading properly
+    mbs.SetRenderEngineStopFlag(False) #not to stop right at the beginning
+
+    # runLoop = False
+    # while runLoop and not mainSystem.GetRenderEngineStopFlag():
+    #     for i in range(0,nRows,rowIncrement):
+    #         if not(mainSystem.GetRenderEngineStopFlag()):
+    #             SetSolutionState(mainSystem, solution, i, exudyn.ConfigurationType.Visualization)
+    #             exudyn.DoRendererIdleTasks(timeout)
+
+    SetSolutionState(mainSystem, solution, 0, exudyn.ConfigurationType.Visualization)
+    exudyn.DoRendererIdleTasks(timeout)
+
+    nSteps = int(nRows)              #only make these steps available in slider!
+    maxNSteps = max(500,min(nSteps,1200))     #do not allow more steps, because dialog may be too large ...
+    resolution = min(1.,maxNSteps/nSteps) #do not use values smaller than 1
+    
+    dialogItems = [
+                   {'type':'label', 'text':'Solution steps:', 'grid':(1,0)},
+                   {'type':'slider', 'range':(0, nSteps-1), 'value':0, 'steps':maxNSteps, 'variable':'solutionViewerStep','resolution': resolution, 'grid':(1,1)},
+                   {'type':'label', 'text':'Increment:', 'grid':(2,0)},
+                   {'type':'slider', 'range':(1, 200), 'value':rowIncrement, 'steps':200, 'variable':'solutionViewerRowIncrement', 'grid':(2,1)},
+                   {'type':'label', 'text':'update period:', 'grid':(3,0)},
+                   {'type':'slider', 'range':(0.005, 1), 'value':timeout, 'steps':200, 'variable':'solutionViewerPeriod', 'grid':(3,1)},
+                   {'type':'radio', 'textValueList':[('Continuous run',0), ('One cycle',1), ('Static',2)],'value':runMode, 'variable':'solutionViewerRunModus', 'grid': [(4,0),(4,1),(4,2)]},
+                   {'type':'radio', 'textValueList':[('Record animation',0), ('No recording',1)],'value':1, 'variable':'solutionViewerSaveImages', 'grid': [(5,0),(5,1)]},
+                   ]
+
+
+    mbs.sys['solutionViewerRowIncrement'] = float(rowIncrement)
+    mbs.sys['solutionViewerNSteps'] = nSteps
+    mbs.sys['solutionViewerSolution'] = solution
+    # mbs.sys['solutionViewerStep'] = 0
+    # mbs.sys['solutionViewerPeriod'] = timeout
+
+    def UFviewer(mbs, dialog):
+        i = int(mbs.sys['solutionViewerStep'])
+
+        # mbs.systemData.SetTime(t, exudyn.ConfigurationType.Visualization)
+        SetSolutionState(mainSystem, mbs.sys['solutionViewerSolution'], i, exudyn.ConfigurationType.Visualization)
+        
+        mbs.SendRedrawSignal()
+        exudyn.DoRendererIdleTasks() #as there is no simulation, we must do this for singlethreaded renderer to draw graphicsDataUserFunctions
+
+        dialog.period = mbs.sys['solutionViewerPeriod']
+
+        if mbs.sys['solutionViewerRunModus'] < 2:
+            mbs.sys['solutionViewerStep'] += mbs.sys['solutionViewerRowIncrement']
+    
+            #first variable is scale, which contains step
+            dialog.variableList[0][0].set(mbs.sys['solutionViewerStep'])
+
+        if mbs.sys['solutionViewerSaveImages'] == 0:
+            #in single-threaded renderer, this causes 2x redraw, so we could save the above exudyn.DoRendererIdleTasks() then ...!
+            SC.RedrawAndSaveImage() #create images for animation
+
+        if mbs.sys['solutionViewerStep']>mbs.sys['solutionViewerNSteps']-1.:
+            #or (mbs.sys['solutionViewerRunModus'] and mbs.sys['solutionViewerStep']==mbs.sys['solutionViewerNSteps']-1.):
+            mbs.sys['solutionViewerStep'] = 0
+            dialog.variableList[0][0].set(0)
+
+            SetSolutionState(mainSystem, mbs.sys['solutionViewerSolution'], 0, exudyn.ConfigurationType.Visualization)
+            # mbs.SendRedrawSignal()
+            # exudyn.DoRendererIdleTasks() #as there is no simulation, we must do this for graphicsDataUserFunctions
+            if mbs.sys['solutionViewerRunModus'] == 1: #one cylce ==> stop
+                dialog.StartSimulation() #start/stop simulation
+
+        
+
+    if not exudyn.IsRendererActive():
+        exudyn.StartRenderer()
+        if 'renderState' in exudyn.sys: SC.SetRenderState(exudyn.sys['renderState']) #load last model view
+
+    simulationSettings = exudyn.SimulationSettings() #not used, but needed in dialog
+     #   self.mbs.sys['solver'].InitializeSolver(self.mbs, self.simulationSettings)
+    simulationSettings.solutionSettings.solutionInformation = ''
+
+    if not SC.visualizationSettings.general.useMultiThreadedRendering:
+        exudyn.DoRendererIdleTasks() #do an update once
+
+    dialogTitle='Solution Viewer'
+    if title != '':
+        dialogTitle = title
+
+    dialog = InteractiveDialog(mbs, simulationSettings=simulationSettings, 
+                      simulationFunction=UFviewer, 
+                      dialogItems=dialogItems,
+                      fontSize=fontSize,title=dialogTitle,
+                      doTimeIntegration=False, period=timeout,
+                      showTime=True, runOnStart=runOnStart, 
+                      checkRenderEngineStopFlag=checkRenderEngineStopFlag,
+                      useSysVariables=True, #use mbs.sys, not to bloat the mbs.variables of the user
+                      )
+
+    #SC.WaitForRenderEngineStopFlag() #not needed, Render window closes when dialog is quit
+    exudyn.StopRenderer() #safely close rendering window!
+
+    SC.visualizationSettings.general.graphicsUpdateInterval = oldUpdateInterval #set values back to original
+
+
+
+
+
+
```

## exudyn/itemInterface.py

 * *Ordering differences only*

```diff
@@ -1,3619 +1,3619 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN example 
-# 
-# Details:  automatically generated file for conversion of item (node, object, marker, ...) data to dictionaries
-# 
-# Author:   Johannes Gerstmayr
-# Date:     2019-07-01
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#item interface diagonal matrix creator
-
-import exudyn #for exudyn.InvalidIndex() and other exudyn native structures needed in RigidBodySpringDamper
-import numpy as np
-import copy 
-
-#helper function for level-1 copy of dicts (for visualization default args!)
-#visualization dictionaries (which may be huge, are only flat copied, which is sufficient)
-def CopyDictLevel1(originalDict):
-    if isinstance(originalDict,dict): #copy only required if default dict is used
-        copyDict = {}
-        for key, value in originalDict.items():
-            copyDict[key] = copy.copy(value)
-        return copyDict
-    else:
-        return originalDict #fast track for everything else
-    
-#helper function diagonal matrices, not needing numpy
-def IIDiagMatrix(rowsColumns, value):
-    m = []
-    for i in range(rowsColumns):
-        m += [rowsColumns*[0]]
-        m[i][i] = value
-    return m
-
-#helper function to check valid range
-def CheckForValidUInt(value, parameterName, objectName):
-    if value < 0:
-        raise ValueError("Error in "+objectName+": (int) parameter "+parameterName + " may not be negative, but received "+str(value))
-        return 0
-    return value
-#helper function to check valid range
-def CheckForValidPInt(value, parameterName, objectName):
-    if value <= 0:
-        raise ValueError("Error in "+objectName+": (int) parameter "+parameterName + " must be positive (> 0), but received "+str(value))
-        return 1 #this position is usually not reached
-    return value
-#helper function to check valid range
-def CheckForValidUReal(value, parameterName, objectName):
-    if value < 0:
-        raise ValueError("Error in "+objectName+": (float) parameter "+parameterName + " may not be negative, but received "+str(value))
-        return 0.
-    return value
-#helper function to check valid range
-def CheckForValidPReal(value, parameterName, objectName):
-    if value <= 0:
-        raise ValueError("Error in "+objectName+": (float) parameter "+parameterName + " must be positive (> 0), but received "+str(value))
-        return 1. #this position is usually not reached
-    return value
-
-userFunctionArgsDict = {'MainSystem,preStepUserFunction': [['MainSystem', 'Real'], ['mbs', 'arg0'], ['bool']],
-        'MainSystem,postStepUserFunction': [['MainSystem', 'Real'], ['mbs', 'arg0'], ['bool']],
-        'MainSystem,postNewtonFunction': [['MainSystem', 'Real'], ['mbs', 'arg0'], ['StdVector2D']],
-        'ObjectGround,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
-        'ObjectRigidBody,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
-        'ObjectRigidBody2D,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
-        'ObjectGenericODE2,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
-        'ObjectGenericODE2,massMatrixUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['py::object']],
-        'ObjectGenericODE2,jacobianUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5'], ['py::object']],
-        'ObjectGenericODE2,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
-        'ObjectGenericODE1,rhsUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2'], ['StdVector']],
-        'ObjectKinematicTree,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
-        'ObjectFFRF,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
-        'ObjectFFRF,massMatrixUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['NumpyMatrix']],
-        'ObjectFFRFreducedOrder,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
-        'ObjectFFRFreducedOrder,massMatrixUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['NumpyMatrix']],
-        'ObjectANCFCable2D,axialForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10'], ['Real']],
-        'ObjectANCFCable2D,bendingMomentUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10'], ['Real']],
-        'ObjectConnectorSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
-        'ObjectConnectorCartesianSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['StdVector3D']],
-        'ObjectConnectorRigidBodySpringDamper,springForceTorqueUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdMatrix6D', 'StdMatrix6D', 'StdMatrix3D', 'StdMatrix3D', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10'], ['StdVector6D']],
-        'ObjectConnectorRigidBodySpringDamper,postNewtonStepUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdMatrix6D', 'StdMatrix6D', 'StdMatrix3D', 'StdMatrix3D', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10', 'arg11'], ['StdVector']],
-        'ObjectConnectorLinearSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
-        'ObjectConnectorTorsionalSpringDamper,springTorqueUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
-        'ObjectConnectorCoordinateSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
-        'ObjectConnectorCoordinateSpringDamperExt,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10', 'arg11', 'arg12'], ['Real']],
-        'ObjectConnectorCoordinate,offsetUserFunction': [['MainSystem', 'Real', 'Index', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2'], ['Real']],
-        'ObjectConnectorCoordinate,offsetUserFunction_t': [['MainSystem', 'Real', 'Index', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2'], ['Real']],
-        'ObjectConnectorCoordinateVector,constraintUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector', 'bool'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4'], ['StdVector']],
-        'ObjectConnectorCoordinateVector,jacobianUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector', 'bool'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4'], ['py::object']],
-        'ObjectJointGeneric,offsetUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2'], ['StdVector6D']],
-        'ObjectJointGeneric,offsetUserFunction_t': [['MainSystem', 'Real', 'Index', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2'], ['StdVector6D']],
-        'LoadForceVector,loadVectorUserFunction': [['MainSystem', 'Real', 'StdVector3D'], ['mbs', 'arg0', 'arg1'], ['StdVector3D']],
-        'LoadTorqueVector,loadVectorUserFunction': [['MainSystem', 'Real', 'StdVector3D'], ['mbs', 'arg0', 'arg1'], ['StdVector3D']],
-        'LoadMassProportional,loadVectorUserFunction': [['MainSystem', 'Real', 'StdVector3D'], ['mbs', 'arg0', 'arg1'], ['StdVector3D']],
-        'LoadCoordinate,loadUserFunction': [['MainSystem', 'Real', 'Real'], ['mbs', 'arg0', 'arg1'], ['Real']],
-        'SensorUserFunction,sensorUserFunction': [['MainSystem', 'Real', 'StdArrayIndex', 'StdVector', 'ConfigurationType'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']]}
-
-
-#+++++++++++++++++++++++++++++++
-#NODE
-class VNodePoint:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePoint:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.], initialCoordinates = [0.,0.,0.], initialVelocities = [0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'Point'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Point = NodePoint
-VPoint = VNodePoint
-
-class VNodePoint2D:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePoint2D:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.], initialCoordinates = [0.,0.], initialVelocities = [0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'Point2D'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Point2D = NodePoint2D
-VPoint2D = VNodePoint2D
-
-class VNodeRigidBodyEP:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeRigidBodyEP:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0., 0.,0.,0.,0.], initialCoordinates = [0.,0.,0., 0.,0.,0.,0.], initialVelocities = [0.,0.,0., 0.,0.,0.,0.], addConstraintEquation = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.addConstraintEquation = addConstraintEquation
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'RigidBodyEP'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'addConstraintEquation', self.addConstraintEquation
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RigidEP = NodeRigidBodyEP
-VRigidEP = VNodeRigidBodyEP
-
-class VNodeRigidBodyRxyz:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeRigidBodyRxyz:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0., 0.,0.,0.], initialCoordinates = [0.,0.,0., 0.,0.,0.], initialVelocities = [0.,0.,0., 0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'RigidBodyRxyz'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RigidRxyz = NodeRigidBodyRxyz
-VRigidRxyz = VNodeRigidBodyRxyz
-
-class VNodeRigidBodyRotVecLG:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeRigidBodyRotVecLG:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0., 0.,0.,0.], initialCoordinates = [0.,0.,0., 0.,0.,0.], initialVelocities = [0.,0.,0., 0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'RigidBodyRotVecLG'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RigidRotVecLG = NodeRigidBodyRotVecLG
-VRigidRotVecLG = VNodeRigidBodyRotVecLG
-
-class VNodeRigidBody2D:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeRigidBody2D:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.], initialCoordinates = [0.,0.,0.], initialVelocities = [0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'RigidBody2D'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Rigid2D = NodeRigidBody2D
-VRigid2D = VNodeRigidBody2D
-
-class VNode1D:
-    def __init__(self, show = False):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class Node1D:
-    def __init__(self, name = '', referenceCoordinates = [0.], initialCoordinates = [0.], initialVelocities = [0.], visualization = {'show': False}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', '1D'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodePoint2DSlope1:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePoint2DSlope1:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,1.,0.], initialCoordinates = [0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'Point2DSlope1'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Point2DS1 = NodePoint2DSlope1
-VPoint2DS1 = VNodePoint2DSlope1
-
-class VNodePointSlope1:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePointSlope1:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.,1.,0.,0.], initialCoordinates = [0.,0.,0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'PointSlope1'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodePointSlope12:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePointSlope12:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.,1.,0.,0.,1.,0.,0.], initialCoordinates = [0.,0.,0.,0.,0.,0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.,0.,0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'PointSlope12'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodePointSlope23:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePointSlope23:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.,1.,0.,0.,1.,0.,0.], initialCoordinates = [0.,0.,0.,0.,0.,0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.,0.,0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialVelocities = np.array(initialVelocities)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'PointSlope23'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialVelocities', self.initialVelocities
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodeGenericODE2:
-    def __init__(self, show = False):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeGenericODE2:
-    def __init__(self, name = '', referenceCoordinates = [], initialCoordinates = [], initialCoordinates_t = [], numberOfODE2Coordinates = 0, visualization = {'show': False}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.initialCoordinates_t = np.array(initialCoordinates_t)
-        self.numberOfODE2Coordinates = CheckForValidPInt(numberOfODE2Coordinates,"numberOfODE2Coordinates","NodeGenericODE2")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'GenericODE2'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'initialCoordinates_t', self.initialCoordinates_t
-        yield 'numberOfODE2Coordinates', self.numberOfODE2Coordinates
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodeGenericODE1:
-    def __init__(self, show = False):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeGenericODE1:
-    def __init__(self, name = '', referenceCoordinates = [], initialCoordinates = [], numberOfODE1Coordinates = 0, visualization = {'show': False}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.numberOfODE1Coordinates = CheckForValidPInt(numberOfODE1Coordinates,"numberOfODE1Coordinates","NodeGenericODE1")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'GenericODE1'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'numberOfODE1Coordinates', self.numberOfODE1Coordinates
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodeGenericAE:
-    def __init__(self, show = False):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeGenericAE:
-    def __init__(self, name = '', referenceCoordinates = [], initialCoordinates = [], numberOfAECoordinates = 0, visualization = {'show': False}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.numberOfAECoordinates = CheckForValidPInt(numberOfAECoordinates,"numberOfAECoordinates","NodeGenericAE")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'GenericAE'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'numberOfAECoordinates', self.numberOfAECoordinates
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodeGenericData:
-    def __init__(self, show = False):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class NodeGenericData:
-    def __init__(self, name = '', initialCoordinates = [], numberOfDataCoordinates = 0, visualization = {'show': False}):
-        self.name = name
-        self.initialCoordinates = np.array(initialCoordinates)
-        self.numberOfDataCoordinates = CheckForValidUInt(numberOfDataCoordinates,"numberOfDataCoordinates","NodeGenericData")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'GenericData'
-        yield 'name', self.name
-        yield 'initialCoordinates', self.initialCoordinates
-        yield 'numberOfDataCoordinates', self.numberOfDataCoordinates
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VNodePointGround:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class NodePointGround:
-    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.referenceCoordinates = np.array(referenceCoordinates)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'nodeType', 'PointGround'
-        yield 'name', self.name
-        yield 'referenceCoordinates', self.referenceCoordinates
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-PointGround = NodePointGround
-VPointGround = VNodePointGround
-
-#+++++++++++++++++++++++++++++++
-#OBJECT
-class VObjectGround:
-    def __init__(self, show = True, graphicsDataUserFunction = 0, graphicsData = []):
-        self.show = show
-        self.graphicsDataUserFunction = graphicsDataUserFunction
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectGround:
-    def __init__(self, name = '', referencePosition = [0.,0.,0.], referenceRotation = IIDiagMatrix(rowsColumns=3,value=1), visualization = {'show': True, 'graphicsDataUserFunction': 0, 'graphicsData': []}):
-        self.name = name
-        self.referencePosition = np.array(referencePosition)
-        self.referenceRotation = np.array(referenceRotation)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'Ground'
-        yield 'name', self.name
-        yield 'referencePosition', self.referencePosition
-        yield 'referenceRotation', self.referenceRotation
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectMassPoint:
-    def __init__(self, show = True, graphicsData = []):
-        self.show = show
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectMassPoint:
-    def __init__(self, name = '', physicsMass = 0., nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsData': []}):
-        self.name = name
-        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectMassPoint")
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'MassPoint'
-        yield 'name', self.name
-        yield 'physicsMass', self.physicsMass
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-MassPoint = ObjectMassPoint
-VMassPoint = VObjectMassPoint
-
-class VObjectMassPoint2D:
-    def __init__(self, show = True, graphicsData = []):
-        self.show = show
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectMassPoint2D:
-    def __init__(self, name = '', physicsMass = 0., nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsData': []}):
-        self.name = name
-        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectMassPoint2D")
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'MassPoint2D'
-        yield 'name', self.name
-        yield 'physicsMass', self.physicsMass
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-MassPoint2D = ObjectMassPoint2D
-VMassPoint2D = VObjectMassPoint2D
-
-class VObjectMass1D:
-    def __init__(self, show = True, graphicsData = []):
-        self.show = show
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectMass1D:
-    def __init__(self, name = '', physicsMass = 0., nodeNumber = exudyn.InvalidIndex(), referencePosition = [0.,0.,0.], referenceRotation = IIDiagMatrix(rowsColumns=3,value=1), visualization = {'show': True, 'graphicsData': []}):
-        self.name = name
-        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectMass1D")
-        self.nodeNumber = nodeNumber
-        self.referencePosition = np.array(referencePosition)
-        self.referenceRotation = np.array(referenceRotation)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'Mass1D'
-        yield 'name', self.name
-        yield 'physicsMass', self.physicsMass
-        yield 'nodeNumber', self.nodeNumber
-        yield 'referencePosition', self.referencePosition
-        yield 'referenceRotation', self.referenceRotation
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Mass1D = ObjectMass1D
-VMass1D = VObjectMass1D
-
-class VObjectRotationalMass1D:
-    def __init__(self, show = True, graphicsData = []):
-        self.show = show
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectRotationalMass1D:
-    def __init__(self, name = '', physicsInertia = 0., nodeNumber = exudyn.InvalidIndex(), referencePosition = [0.,0.,0.], referenceRotation = IIDiagMatrix(rowsColumns=3,value=1), visualization = {'show': True, 'graphicsData': []}):
-        self.name = name
-        self.physicsInertia = CheckForValidUReal(physicsInertia,"physicsInertia","ObjectRotationalMass1D")
-        self.nodeNumber = nodeNumber
-        self.referencePosition = np.array(referencePosition)
-        self.referenceRotation = np.array(referenceRotation)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'RotationalMass1D'
-        yield 'name', self.name
-        yield 'physicsInertia', self.physicsInertia
-        yield 'nodeNumber', self.nodeNumber
-        yield 'referencePosition', self.referencePosition
-        yield 'referenceRotation', self.referenceRotation
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Rotor1D = ObjectRotationalMass1D
-VRotor1D = VObjectRotationalMass1D
-
-class VObjectRigidBody:
-    def __init__(self, show = True, graphicsDataUserFunction = 0, graphicsData = []):
-        self.show = show
-        self.graphicsDataUserFunction = graphicsDataUserFunction
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectRigidBody:
-    def __init__(self, name = '', physicsMass = 0., physicsInertia = [0.,0.,0., 0.,0.,0.], physicsCenterOfMass = [0.,0.,0.], nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsDataUserFunction': 0, 'graphicsData': []}):
-        self.name = name
-        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectRigidBody")
-        self.physicsInertia = np.array(physicsInertia)
-        self.physicsCenterOfMass = np.array(physicsCenterOfMass)
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'RigidBody'
-        yield 'name', self.name
-        yield 'physicsMass', self.physicsMass
-        yield 'physicsInertia', self.physicsInertia
-        yield 'physicsCenterOfMass', self.physicsCenterOfMass
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RigidBody = ObjectRigidBody
-VRigidBody = VObjectRigidBody
-
-class VObjectRigidBody2D:
-    def __init__(self, show = True, graphicsDataUserFunction = 0, graphicsData = []):
-        self.show = show
-        self.graphicsDataUserFunction = graphicsDataUserFunction
-        self.graphicsData = copy.copy(graphicsData)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
-        yield 'graphicsData', self.graphicsData
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectRigidBody2D:
-    def __init__(self, name = '', physicsMass = 0., physicsInertia = 0., nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsDataUserFunction': 0, 'graphicsData': []}):
-        self.name = name
-        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectRigidBody2D")
-        self.physicsInertia = CheckForValidUReal(physicsInertia,"physicsInertia","ObjectRigidBody2D")
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'RigidBody2D'
-        yield 'name', self.name
-        yield 'physicsMass', self.physicsMass
-        yield 'physicsInertia', self.physicsInertia
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
-        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RigidBody2D = ObjectRigidBody2D
-VRigidBody2D = VObjectRigidBody2D
-
-class VObjectGenericODE2:
-    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.], triangleMesh = [], showNodes = False, graphicsDataUserFunction = 0):
-        self.show = show
-        self.color = np.array(color)
-        self.triangleMesh = np.array(triangleMesh)
-        self.showNodes = showNodes
-        self.graphicsDataUserFunction = graphicsDataUserFunction
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'color', self.color
-        yield 'triangleMesh', self.triangleMesh
-        yield 'showNodes', self.showNodes
-        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectGenericODE2:
-    def __init__(self, name = '', nodeNumbers = [], massMatrix = None, stiffnessMatrix = None, dampingMatrix = None, forceVector = [], forceUserFunction = 0, massMatrixUserFunction = 0, jacobianUserFunction = 0, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.], 'triangleMesh': [], 'showNodes': False, 'graphicsDataUserFunction': 0}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.massMatrix = massMatrix
-        self.stiffnessMatrix = stiffnessMatrix
-        self.dampingMatrix = dampingMatrix
-        self.forceVector = np.array(forceVector)
-        self.forceUserFunction = forceUserFunction
-        self.massMatrixUserFunction = massMatrixUserFunction
-        self.jacobianUserFunction = jacobianUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'GenericODE2'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'massMatrix', self.massMatrix
-        yield 'stiffnessMatrix', self.stiffnessMatrix
-        yield 'dampingMatrix', self.dampingMatrix
-        yield 'forceVector', self.forceVector
-        yield 'forceUserFunction', self.forceUserFunction
-        yield 'massMatrixUserFunction', self.massMatrixUserFunction
-        yield 'jacobianUserFunction', self.jacobianUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-        yield 'VtriangleMesh', dict(self.visualization)["triangleMesh"]
-        yield 'VshowNodes', dict(self.visualization)["showNodes"]
-        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectGenericODE1:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectGenericODE1:
-    def __init__(self, name = '', nodeNumbers = [], systemMatrix = [], rhsVector = [], rhsUserFunction = 0, visualization = {'show': True}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.systemMatrix = np.array(systemMatrix)
-        self.rhsVector = np.array(rhsVector)
-        self.rhsUserFunction = rhsUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'GenericODE1'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'systemMatrix', self.systemMatrix
-        yield 'rhsVector', self.rhsVector
-        yield 'rhsUserFunction', self.rhsUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectKinematicTree:
-    def __init__(self, show = True, showLinks = True, showJoints = True, color = [-1.,-1.,-1.,-1.], graphicsDataList = []):
-        self.show = show
-        self.showLinks = showLinks
-        self.showJoints = showJoints
-        self.color = np.array(color)
-        self.graphicsDataList = copy.copy(graphicsDataList)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'showLinks', self.showLinks
-        yield 'showJoints', self.showJoints
-        yield 'color', self.color
-        yield 'graphicsDataList', self.graphicsDataList
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectKinematicTree:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), gravity = [0.,0.,0.], baseOffset = [0.,0.,0.], jointTypes = [], linkParents = [], jointTransformations = None, jointOffsets = None, linkInertiasCOM = None, linkCOMs = None, linkMasses = [], linkForces = None, linkTorques = None, jointForceVector = [], jointPositionOffsetVector = [], jointVelocityOffsetVector = [], jointPControlVector = [], jointDControlVector = [], forceUserFunction = 0, visualization = {'show': True, 'showLinks': True, 'showJoints': True, 'color': [-1.,-1.,-1.,-1.], 'graphicsDataList': []}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.gravity = np.array(gravity)
-        self.baseOffset = np.array(baseOffset)
-        self.jointTypes = copy.copy(jointTypes)
-        self.linkParents = copy.copy(linkParents)
-        self.jointTransformations = jointTransformations
-        self.jointOffsets = jointOffsets
-        self.linkInertiasCOM = linkInertiasCOM
-        self.linkCOMs = linkCOMs
-        self.linkMasses = np.array(linkMasses)
-        self.linkForces = linkForces
-        self.linkTorques = linkTorques
-        self.jointForceVector = np.array(jointForceVector)
-        self.jointPositionOffsetVector = np.array(jointPositionOffsetVector)
-        self.jointVelocityOffsetVector = np.array(jointVelocityOffsetVector)
-        self.jointPControlVector = np.array(jointPControlVector)
-        self.jointDControlVector = np.array(jointDControlVector)
-        self.forceUserFunction = forceUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'KinematicTree'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'gravity', self.gravity
-        yield 'baseOffset', self.baseOffset
-        yield 'jointTypes', self.jointTypes
-        yield 'linkParents', self.linkParents
-        yield 'jointTransformations', self.jointTransformations
-        yield 'jointOffsets', self.jointOffsets
-        yield 'linkInertiasCOM', self.linkInertiasCOM
-        yield 'linkCOMs', self.linkCOMs
-        yield 'linkMasses', self.linkMasses
-        yield 'linkForces', self.linkForces
-        yield 'linkTorques', self.linkTorques
-        yield 'jointForceVector', self.jointForceVector
-        yield 'jointPositionOffsetVector', self.jointPositionOffsetVector
-        yield 'jointVelocityOffsetVector', self.jointVelocityOffsetVector
-        yield 'jointPControlVector', self.jointPControlVector
-        yield 'jointDControlVector', self.jointDControlVector
-        yield 'forceUserFunction', self.forceUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VshowLinks', dict(self.visualization)["showLinks"]
-        yield 'VshowJoints', dict(self.visualization)["showJoints"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-        yield 'VgraphicsDataList', dict(self.visualization)["graphicsDataList"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-KinematicTree = ObjectKinematicTree
-VKinematicTree = VObjectKinematicTree
-
-class VObjectFFRF:
-    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.], triangleMesh = [], showNodes = False):
-        self.show = show
-        self.color = np.array(color)
-        self.triangleMesh = np.array(triangleMesh)
-        self.showNodes = showNodes
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'color', self.color
-        yield 'triangleMesh', self.triangleMesh
-        yield 'showNodes', self.showNodes
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectFFRF:
-    def __init__(self, name = '', nodeNumbers = [], massMatrixFF = None, stiffnessMatrixFF = None, dampingMatrixFF = None, forceVector = [], forceUserFunction = 0, massMatrixUserFunction = 0, computeFFRFterms = True, objectIsInitialized = False, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.], 'triangleMesh': [], 'showNodes': False}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.massMatrixFF = massMatrixFF
-        self.stiffnessMatrixFF = stiffnessMatrixFF
-        self.dampingMatrixFF = dampingMatrixFF
-        self.forceVector = np.array(forceVector)
-        self.forceUserFunction = forceUserFunction
-        self.massMatrixUserFunction = massMatrixUserFunction
-        self.computeFFRFterms = computeFFRFterms
-        self.objectIsInitialized = objectIsInitialized
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'FFRF'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'massMatrixFF', self.massMatrixFF
-        yield 'stiffnessMatrixFF', self.stiffnessMatrixFF
-        yield 'dampingMatrixFF', self.dampingMatrixFF
-        yield 'forceVector', self.forceVector
-        yield 'forceUserFunction', self.forceUserFunction
-        yield 'massMatrixUserFunction', self.massMatrixUserFunction
-        yield 'computeFFRFterms', self.computeFFRFterms
-        yield 'objectIsInitialized', self.objectIsInitialized
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-        yield 'VtriangleMesh', dict(self.visualization)["triangleMesh"]
-        yield 'VshowNodes', dict(self.visualization)["showNodes"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectFFRFreducedOrder:
-    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.], triangleMesh = [], showNodes = False):
-        self.show = show
-        self.color = np.array(color)
-        self.triangleMesh = np.array(triangleMesh)
-        self.showNodes = showNodes
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'color', self.color
-        yield 'triangleMesh', self.triangleMesh
-        yield 'showNodes', self.showNodes
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectFFRFreducedOrder:
-    def __init__(self, name = '', nodeNumbers = [], massMatrixReduced = None, stiffnessMatrixReduced = None, dampingMatrixReduced = None, forceUserFunction = 0, massMatrixUserFunction = 0, computeFFRFterms = True, modeBasis = [], outputVariableModeBasis = [], outputVariableTypeModeBasis = 0, referencePositions = [], objectIsInitialized = False, physicsMass = 0., physicsInertia = IIDiagMatrix(rowsColumns=3,value=1), physicsCenterOfMass = [0.,0.,0.], mPsiTildePsi = [], mPsiTildePsiTilde = [], mPhitTPsi = [], mPhitTPsiTilde = [], mXRefTildePsi = [], mXRefTildePsiTilde = [], physicsCenterOfMassTilde = IIDiagMatrix(rowsColumns=3,value=0), visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.], 'triangleMesh': [], 'showNodes': False}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.massMatrixReduced = massMatrixReduced
-        self.stiffnessMatrixReduced = stiffnessMatrixReduced
-        self.dampingMatrixReduced = dampingMatrixReduced
-        self.forceUserFunction = forceUserFunction
-        self.massMatrixUserFunction = massMatrixUserFunction
-        self.computeFFRFterms = computeFFRFterms
-        self.modeBasis = np.array(modeBasis)
-        self.outputVariableModeBasis = np.array(outputVariableModeBasis)
-        self.outputVariableTypeModeBasis = outputVariableTypeModeBasis
-        self.referencePositions = np.array(referencePositions)
-        self.objectIsInitialized = objectIsInitialized
-        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectFFRFreducedOrder")
-        self.physicsInertia = np.array(physicsInertia)
-        self.physicsCenterOfMass = np.array(physicsCenterOfMass)
-        self.mPsiTildePsi = np.array(mPsiTildePsi)
-        self.mPsiTildePsiTilde = np.array(mPsiTildePsiTilde)
-        self.mPhitTPsi = np.array(mPhitTPsi)
-        self.mPhitTPsiTilde = np.array(mPhitTPsiTilde)
-        self.mXRefTildePsi = np.array(mXRefTildePsi)
-        self.mXRefTildePsiTilde = np.array(mXRefTildePsiTilde)
-        self.physicsCenterOfMassTilde = np.array(physicsCenterOfMassTilde)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'FFRFreducedOrder'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'massMatrixReduced', self.massMatrixReduced
-        yield 'stiffnessMatrixReduced', self.stiffnessMatrixReduced
-        yield 'dampingMatrixReduced', self.dampingMatrixReduced
-        yield 'forceUserFunction', self.forceUserFunction
-        yield 'massMatrixUserFunction', self.massMatrixUserFunction
-        yield 'computeFFRFterms', self.computeFFRFterms
-        yield 'modeBasis', self.modeBasis
-        yield 'outputVariableModeBasis', self.outputVariableModeBasis
-        yield 'outputVariableTypeModeBasis', self.outputVariableTypeModeBasis
-        yield 'referencePositions', self.referencePositions
-        yield 'objectIsInitialized', self.objectIsInitialized
-        yield 'physicsMass', self.physicsMass
-        yield 'physicsInertia', self.physicsInertia
-        yield 'physicsCenterOfMass', self.physicsCenterOfMass
-        yield 'mPsiTildePsi', self.mPsiTildePsi
-        yield 'mPsiTildePsiTilde', self.mPsiTildePsiTilde
-        yield 'mPhitTPsi', self.mPhitTPsi
-        yield 'mPhitTPsiTilde', self.mPhitTPsiTilde
-        yield 'mXRefTildePsi', self.mXRefTildePsi
-        yield 'mXRefTildePsiTilde', self.mXRefTildePsiTilde
-        yield 'physicsCenterOfMassTilde', self.physicsCenterOfMassTilde
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-        yield 'VtriangleMesh', dict(self.visualization)["triangleMesh"]
-        yield 'VshowNodes', dict(self.visualization)["showNodes"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-CMSobject = ObjectFFRFreducedOrder
-VCMSobject = VObjectFFRFreducedOrder
-
-class VObjectANCFCable:
-    def __init__(self, show = True, radius = 0., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.radius = radius
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'radius', self.radius
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectANCFCable:
-    def __init__(self, name = '', physicsLength = 0., physicsMassPerLength = 0., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsReferenceAxialStrain = 0., strainIsRelativeToReference = 0., nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, visualization = {'show': True, 'radius': 0., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectANCFCable")
-        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectANCFCable")
-        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectANCFCable")
-        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectANCFCable")
-        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectANCFCable")
-        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectANCFCable")
-        self.physicsReferenceAxialStrain = physicsReferenceAxialStrain
-        self.strainIsRelativeToReference = strainIsRelativeToReference
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.useReducedOrderIntegration = useReducedOrderIntegration
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ANCFCable'
-        yield 'name', self.name
-        yield 'physicsLength', self.physicsLength
-        yield 'physicsMassPerLength', self.physicsMassPerLength
-        yield 'physicsBendingStiffness', self.physicsBendingStiffness
-        yield 'physicsAxialStiffness', self.physicsAxialStiffness
-        yield 'physicsBendingDamping', self.physicsBendingDamping
-        yield 'physicsAxialDamping', self.physicsAxialDamping
-        yield 'physicsReferenceAxialStrain', self.physicsReferenceAxialStrain
-        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vradius', dict(self.visualization)["radius"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Cable = ObjectANCFCable
-VCable = VObjectANCFCable
-
-class VObjectANCFCable2D:
-    def __init__(self, show = True, drawHeight = 0., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawHeight = drawHeight
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawHeight', self.drawHeight
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectANCFCable2D:
-    def __init__(self, name = '', physicsLength = 0., physicsMassPerLength = 0., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsReferenceAxialStrain = 0., physicsReferenceCurvature = 0., strainIsRelativeToReference = 0., nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, axialForceUserFunction = 0, bendingMomentUserFunction = 0, visualization = {'show': True, 'drawHeight': 0., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectANCFCable2D")
-        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectANCFCable2D")
-        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectANCFCable2D")
-        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectANCFCable2D")
-        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectANCFCable2D")
-        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectANCFCable2D")
-        self.physicsReferenceAxialStrain = physicsReferenceAxialStrain
-        self.physicsReferenceCurvature = physicsReferenceCurvature
-        self.strainIsRelativeToReference = strainIsRelativeToReference
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.useReducedOrderIntegration = useReducedOrderIntegration
-        self.axialForceUserFunction = axialForceUserFunction
-        self.bendingMomentUserFunction = bendingMomentUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ANCFCable2D'
-        yield 'name', self.name
-        yield 'physicsLength', self.physicsLength
-        yield 'physicsMassPerLength', self.physicsMassPerLength
-        yield 'physicsBendingStiffness', self.physicsBendingStiffness
-        yield 'physicsAxialStiffness', self.physicsAxialStiffness
-        yield 'physicsBendingDamping', self.physicsBendingDamping
-        yield 'physicsAxialDamping', self.physicsAxialDamping
-        yield 'physicsReferenceAxialStrain', self.physicsReferenceAxialStrain
-        yield 'physicsReferenceCurvature', self.physicsReferenceCurvature
-        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
-        yield 'axialForceUserFunction', self.axialForceUserFunction
-        yield 'bendingMomentUserFunction', self.bendingMomentUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawHeight', dict(self.visualization)["drawHeight"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Cable2D = ObjectANCFCable2D
-VCable2D = VObjectANCFCable2D
-
-class VObjectALEANCFCable2D:
-    def __init__(self, show = True, drawHeight = 0., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawHeight = drawHeight
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawHeight', self.drawHeight
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectALEANCFCable2D:
-    def __init__(self, name = '', physicsLength = 0., physicsMassPerLength = 0., physicsMovingMassFactor = 1., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsReferenceAxialStrain = 0., physicsReferenceCurvature = 0., physicsUseCouplingTerms = True, physicsAddALEvariation = True, nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, strainIsRelativeToReference = 0., visualization = {'show': True, 'drawHeight': 0., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectALEANCFCable2D")
-        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectALEANCFCable2D")
-        self.physicsMovingMassFactor = CheckForValidUReal(physicsMovingMassFactor,"physicsMovingMassFactor","ObjectALEANCFCable2D")
-        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectALEANCFCable2D")
-        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectALEANCFCable2D")
-        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectALEANCFCable2D")
-        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectALEANCFCable2D")
-        self.physicsReferenceAxialStrain = physicsReferenceAxialStrain
-        self.physicsReferenceCurvature = physicsReferenceCurvature
-        self.physicsUseCouplingTerms = physicsUseCouplingTerms
-        self.physicsAddALEvariation = physicsAddALEvariation
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.useReducedOrderIntegration = useReducedOrderIntegration
-        self.strainIsRelativeToReference = strainIsRelativeToReference
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ALEANCFCable2D'
-        yield 'name', self.name
-        yield 'physicsLength', self.physicsLength
-        yield 'physicsMassPerLength', self.physicsMassPerLength
-        yield 'physicsMovingMassFactor', self.physicsMovingMassFactor
-        yield 'physicsBendingStiffness', self.physicsBendingStiffness
-        yield 'physicsAxialStiffness', self.physicsAxialStiffness
-        yield 'physicsBendingDamping', self.physicsBendingDamping
-        yield 'physicsAxialDamping', self.physicsAxialDamping
-        yield 'physicsReferenceAxialStrain', self.physicsReferenceAxialStrain
-        yield 'physicsReferenceCurvature', self.physicsReferenceCurvature
-        yield 'physicsUseCouplingTerms', self.physicsUseCouplingTerms
-        yield 'physicsAddALEvariation', self.physicsAddALEvariation
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
-        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawHeight', dict(self.visualization)["drawHeight"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-ALECable2D = ObjectALEANCFCable2D
-VALECable2D = VObjectALEANCFCable2D
-
-class VObjectANCFBeam:
-    def __init__(self, show = True, sectionGeometry = exudyn.BeamSectionGeometry(), color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.sectionGeometry = sectionGeometry
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'sectionGeometry', self.sectionGeometry
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectANCFBeam:
-    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., sectionData = exudyn.BeamSection(), crossSectionPenaltyFactor = [1.,1.,1.], visualization = {'show': True, 'sectionGeometry': exudyn.BeamSectionGeometry(), 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.physicsLength = CheckForValidPReal(physicsLength,"physicsLength","ObjectANCFBeam")
-        self.sectionData = sectionData
-        self.crossSectionPenaltyFactor = np.array(crossSectionPenaltyFactor)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ANCFBeam'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'physicsLength', self.physicsLength
-        yield 'sectionData', self.sectionData
-        yield 'crossSectionPenaltyFactor', self.crossSectionPenaltyFactor
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VsectionGeometry', dict(self.visualization)["sectionGeometry"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-ANCFBeam = ObjectANCFBeam
-VANCFBeam = VObjectANCFBeam
-
-class VObjectBeamGeometricallyExact2D:
-    def __init__(self, show = True, drawHeight = 0., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawHeight = drawHeight
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawHeight', self.drawHeight
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectBeamGeometricallyExact2D:
-    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., physicsMassPerLength = 0., physicsCrossSectionInertia = 0., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsShearStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsShearDamping = 0., physicsReferenceCurvature = 0., includeReferenceRotations = False, visualization = {'show': True, 'drawHeight': 0., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectBeamGeometricallyExact2D")
-        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectBeamGeometricallyExact2D")
-        self.physicsCrossSectionInertia = CheckForValidUReal(physicsCrossSectionInertia,"physicsCrossSectionInertia","ObjectBeamGeometricallyExact2D")
-        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectBeamGeometricallyExact2D")
-        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectBeamGeometricallyExact2D")
-        self.physicsShearStiffness = CheckForValidUReal(physicsShearStiffness,"physicsShearStiffness","ObjectBeamGeometricallyExact2D")
-        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectBeamGeometricallyExact2D")
-        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectBeamGeometricallyExact2D")
-        self.physicsShearDamping = CheckForValidUReal(physicsShearDamping,"physicsShearDamping","ObjectBeamGeometricallyExact2D")
-        self.physicsReferenceCurvature = physicsReferenceCurvature
-        self.includeReferenceRotations = includeReferenceRotations
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'BeamGeometricallyExact2D'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'physicsLength', self.physicsLength
-        yield 'physicsMassPerLength', self.physicsMassPerLength
-        yield 'physicsCrossSectionInertia', self.physicsCrossSectionInertia
-        yield 'physicsBendingStiffness', self.physicsBendingStiffness
-        yield 'physicsAxialStiffness', self.physicsAxialStiffness
-        yield 'physicsShearStiffness', self.physicsShearStiffness
-        yield 'physicsBendingDamping', self.physicsBendingDamping
-        yield 'physicsAxialDamping', self.physicsAxialDamping
-        yield 'physicsShearDamping', self.physicsShearDamping
-        yield 'physicsReferenceCurvature', self.physicsReferenceCurvature
-        yield 'includeReferenceRotations', self.includeReferenceRotations
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawHeight', dict(self.visualization)["drawHeight"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Beam2D = ObjectBeamGeometricallyExact2D
-VBeam2D = VObjectBeamGeometricallyExact2D
-
-class VObjectBeamGeometricallyExact:
-    def __init__(self, show = True, sectionGeometry = exudyn.BeamSectionGeometry(), color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.sectionGeometry = sectionGeometry
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'sectionGeometry', self.sectionGeometry
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectBeamGeometricallyExact:
-    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., sectionData = exudyn.BeamSection(), visualization = {'show': True, 'sectionGeometry': exudyn.BeamSectionGeometry(), 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.physicsLength = CheckForValidPReal(physicsLength,"physicsLength","ObjectBeamGeometricallyExact")
-        self.sectionData = sectionData
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'BeamGeometricallyExact'
-        yield 'name', self.name
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'physicsLength', self.physicsLength
-        yield 'sectionData', self.sectionData
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VsectionGeometry', dict(self.visualization)["sectionGeometry"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Beam3D = ObjectBeamGeometricallyExact
-VBeam3D = VObjectBeamGeometricallyExact
-
-class VObjectANCFThinPlate:
-    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectANCFThinPlate:
-    def __init__(self, name = '', physicsThickness = 0., physicsDensity = 0., physicsStrainCoefficients = IIDiagMatrix(rowsColumns=3,value=1), physicsCurvatureCoefficients = IIDiagMatrix(rowsColumns=3,value=1), strainIsRelativeToReference = 1., nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex(), exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.physicsThickness = CheckForValidUReal(physicsThickness,"physicsThickness","ObjectANCFThinPlate")
-        self.physicsDensity = CheckForValidUReal(physicsDensity,"physicsDensity","ObjectANCFThinPlate")
-        self.physicsStrainCoefficients = np.array(physicsStrainCoefficients)
-        self.physicsCurvatureCoefficients = np.array(physicsCurvatureCoefficients)
-        self.strainIsRelativeToReference = strainIsRelativeToReference
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.useReducedOrderIntegration = useReducedOrderIntegration
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ANCFThinPlate'
-        yield 'name', self.name
-        yield 'physicsThickness', self.physicsThickness
-        yield 'physicsDensity', self.physicsDensity
-        yield 'physicsStrainCoefficients', self.physicsStrainCoefficients
-        yield 'physicsCurvatureCoefficients', self.physicsCurvatureCoefficients
-        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectConnectorSpringDamper:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorSpringDamper:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], referenceLength = 0., stiffness = 0., damping = 0., force = 0., velocityOffset = 0., activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.referenceLength = CheckForValidUReal(referenceLength,"referenceLength","ObjectConnectorSpringDamper")
-        self.stiffness = CheckForValidUReal(stiffness,"stiffness","ObjectConnectorSpringDamper")
-        self.damping = CheckForValidUReal(damping,"damping","ObjectConnectorSpringDamper")
-        self.force = force
-        self.velocityOffset = velocityOffset
-        self.activeConnector = activeConnector
-        self.springForceUserFunction = springForceUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorSpringDamper'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'referenceLength', self.referenceLength
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'force', self.force
-        yield 'velocityOffset', self.velocityOffset
-        yield 'activeConnector', self.activeConnector
-        yield 'springForceUserFunction', self.springForceUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-SpringDamper = ObjectConnectorSpringDamper
-VSpringDamper = VObjectConnectorSpringDamper
-
-class VObjectConnectorCartesianSpringDamper:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorCartesianSpringDamper:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], stiffness = [0.,0.,0.], damping = [0.,0.,0.], offset = [0.,0.,0.], springForceUserFunction = 0, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.stiffness = np.array(stiffness)
-        self.damping = np.array(damping)
-        self.offset = np.array(offset)
-        self.springForceUserFunction = springForceUserFunction
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorCartesianSpringDamper'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'offset', self.offset
-        yield 'springForceUserFunction', self.springForceUserFunction
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-CartesianSpringDamper = ObjectConnectorCartesianSpringDamper
-VCartesianSpringDamper = VObjectConnectorCartesianSpringDamper
-
-class VObjectConnectorRigidBodySpringDamper:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorRigidBodySpringDamper:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), stiffness = IIDiagMatrix(rowsColumns=6,value=0.), damping = IIDiagMatrix(rowsColumns=6,value=0.), rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), offset = [0.,0.,0.,0.,0.,0.], intrinsicFormulation = False, activeConnector = True, springForceTorqueUserFunction = 0, postNewtonStepUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.stiffness = np.array(stiffness)
-        self.damping = np.array(damping)
-        self.rotationMarker0 = np.array(rotationMarker0)
-        self.rotationMarker1 = np.array(rotationMarker1)
-        self.offset = np.array(offset)
-        self.intrinsicFormulation = intrinsicFormulation
-        self.activeConnector = activeConnector
-        self.springForceTorqueUserFunction = springForceTorqueUserFunction
-        self.postNewtonStepUserFunction = postNewtonStepUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorRigidBodySpringDamper'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'rotationMarker0', self.rotationMarker0
-        yield 'rotationMarker1', self.rotationMarker1
-        yield 'offset', self.offset
-        yield 'intrinsicFormulation', self.intrinsicFormulation
-        yield 'activeConnector', self.activeConnector
-        yield 'springForceTorqueUserFunction', self.springForceTorqueUserFunction
-        yield 'postNewtonStepUserFunction', self.postNewtonStepUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RigidBodySpringDamper = ObjectConnectorRigidBodySpringDamper
-VRigidBodySpringDamper = VObjectConnectorRigidBodySpringDamper
-
-class VObjectConnectorLinearSpringDamper:
-    def __init__(self, show = True, drawSize = -1., drawAsCylinder = False, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.drawAsCylinder = drawAsCylinder
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'drawAsCylinder', self.drawAsCylinder
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorLinearSpringDamper:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], stiffness = 0., damping = 0., axisMarker0 = [1,0,0], offset = 0., velocityOffset = 0., force = 0., activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'drawAsCylinder': False, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.stiffness = stiffness
-        self.damping = damping
-        self.axisMarker0 = np.array(axisMarker0)
-        self.offset = offset
-        self.velocityOffset = velocityOffset
-        self.force = force
-        self.activeConnector = activeConnector
-        self.springForceUserFunction = springForceUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorLinearSpringDamper'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'axisMarker0', self.axisMarker0
-        yield 'offset', self.offset
-        yield 'velocityOffset', self.velocityOffset
-        yield 'force', self.force
-        yield 'activeConnector', self.activeConnector
-        yield 'springForceUserFunction', self.springForceUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'VdrawAsCylinder', dict(self.visualization)["drawAsCylinder"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-LinearSpringDamper = ObjectConnectorLinearSpringDamper
-VLinearSpringDamper = VObjectConnectorLinearSpringDamper
-
-class VObjectConnectorTorsionalSpringDamper:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorTorsionalSpringDamper:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), stiffness = 0., damping = 0., rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), offset = 0., velocityOffset = 0., torque = 0., activeConnector = True, springTorqueUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.stiffness = stiffness
-        self.damping = damping
-        self.rotationMarker0 = np.array(rotationMarker0)
-        self.rotationMarker1 = np.array(rotationMarker1)
-        self.offset = offset
-        self.velocityOffset = velocityOffset
-        self.torque = torque
-        self.activeConnector = activeConnector
-        self.springTorqueUserFunction = springTorqueUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorTorsionalSpringDamper'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'rotationMarker0', self.rotationMarker0
-        yield 'rotationMarker1', self.rotationMarker1
-        yield 'offset', self.offset
-        yield 'velocityOffset', self.velocityOffset
-        yield 'torque', self.torque
-        yield 'activeConnector', self.activeConnector
-        yield 'springTorqueUserFunction', self.springTorqueUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-TorsionalSpringDamper = ObjectConnectorTorsionalSpringDamper
-VTorsionalSpringDamper = VObjectConnectorTorsionalSpringDamper
-
-class VObjectConnectorCoordinateSpringDamper:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorCoordinateSpringDamper:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], stiffness = 0., damping = 0., offset = 0., activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.stiffness = stiffness
-        self.damping = damping
-        self.offset = offset
-        self.activeConnector = activeConnector
-        self.springForceUserFunction = springForceUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorCoordinateSpringDamper'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'offset', self.offset
-        yield 'activeConnector', self.activeConnector
-        yield 'springForceUserFunction', self.springForceUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-CoordinateSpringDamper = ObjectConnectorCoordinateSpringDamper
-VCoordinateSpringDamper = VObjectConnectorCoordinateSpringDamper
-
-class VObjectConnectorCoordinateSpringDamperExt:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorCoordinateSpringDamperExt:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), stiffness = 0., damping = 0., offset = 0., velocityOffset = 0., factor0 = 1., factor1 = 1., fDynamicFriction = 0., fStaticFrictionOffset = 0., stickingStiffness = 0., stickingDamping = 0., exponentialDecayStatic = 1.e-3, fViscousFriction = 0., frictionProportionalZone = 0., limitStopsUpper = 0., limitStopsLower = 0., limitStopsStiffness = 0., limitStopsDamping = 0., useLimitStops = False, activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.stiffness = stiffness
-        self.damping = damping
-        self.offset = offset
-        self.velocityOffset = velocityOffset
-        self.factor0 = factor0
-        self.factor1 = factor1
-        self.fDynamicFriction = CheckForValidUReal(fDynamicFriction,"fDynamicFriction","ObjectConnectorCoordinateSpringDamperExt")
-        self.fStaticFrictionOffset = CheckForValidUReal(fStaticFrictionOffset,"fStaticFrictionOffset","ObjectConnectorCoordinateSpringDamperExt")
-        self.stickingStiffness = CheckForValidUReal(stickingStiffness,"stickingStiffness","ObjectConnectorCoordinateSpringDamperExt")
-        self.stickingDamping = CheckForValidUReal(stickingDamping,"stickingDamping","ObjectConnectorCoordinateSpringDamperExt")
-        self.exponentialDecayStatic = CheckForValidPReal(exponentialDecayStatic,"exponentialDecayStatic","ObjectConnectorCoordinateSpringDamperExt")
-        self.fViscousFriction = fViscousFriction
-        self.frictionProportionalZone = CheckForValidUReal(frictionProportionalZone,"frictionProportionalZone","ObjectConnectorCoordinateSpringDamperExt")
-        self.limitStopsUpper = limitStopsUpper
-        self.limitStopsLower = limitStopsLower
-        self.limitStopsStiffness = CheckForValidUReal(limitStopsStiffness,"limitStopsStiffness","ObjectConnectorCoordinateSpringDamperExt")
-        self.limitStopsDamping = CheckForValidUReal(limitStopsDamping,"limitStopsDamping","ObjectConnectorCoordinateSpringDamperExt")
-        self.useLimitStops = useLimitStops
-        self.activeConnector = activeConnector
-        self.springForceUserFunction = springForceUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorCoordinateSpringDamperExt'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'stiffness', self.stiffness
-        yield 'damping', self.damping
-        yield 'offset', self.offset
-        yield 'velocityOffset', self.velocityOffset
-        yield 'factor0', self.factor0
-        yield 'factor1', self.factor1
-        yield 'fDynamicFriction', self.fDynamicFriction
-        yield 'fStaticFrictionOffset', self.fStaticFrictionOffset
-        yield 'stickingStiffness', self.stickingStiffness
-        yield 'stickingDamping', self.stickingDamping
-        yield 'exponentialDecayStatic', self.exponentialDecayStatic
-        yield 'fViscousFriction', self.fViscousFriction
-        yield 'frictionProportionalZone', self.frictionProportionalZone
-        yield 'limitStopsUpper', self.limitStopsUpper
-        yield 'limitStopsLower', self.limitStopsLower
-        yield 'limitStopsStiffness', self.limitStopsStiffness
-        yield 'limitStopsDamping', self.limitStopsDamping
-        yield 'useLimitStops', self.useLimitStops
-        yield 'activeConnector', self.activeConnector
-        yield 'springForceUserFunction', self.springForceUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-CoordinateSpringDamperExt = ObjectConnectorCoordinateSpringDamperExt
-VCoordinateSpringDamperExt = VObjectConnectorCoordinateSpringDamperExt
-
-class VObjectConnectorGravity:
-    def __init__(self, show = False, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorGravity:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], gravitationalConstant = 6.67430e-11, mass0 = 0., mass1 = 0., minDistanceRegularization = 0., activeConnector = True, visualization = {'show': False, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.gravitationalConstant = gravitationalConstant
-        self.mass0 = CheckForValidUReal(mass0,"mass0","ObjectConnectorGravity")
-        self.mass1 = CheckForValidUReal(mass1,"mass1","ObjectConnectorGravity")
-        self.minDistanceRegularization = CheckForValidUReal(minDistanceRegularization,"minDistanceRegularization","ObjectConnectorGravity")
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorGravity'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'gravitationalConstant', self.gravitationalConstant
-        yield 'mass0', self.mass0
-        yield 'mass1', self.mass1
-        yield 'minDistanceRegularization', self.minDistanceRegularization
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-ConnectorGravity = ObjectConnectorGravity
-VConnectorGravity = VObjectConnectorGravity
-
-class VObjectConnectorHydraulicActuatorSimple:
-    def __init__(self, show = True, cylinderRadius = 0.05, rodRadius = 0.03, pistonRadius = 0.04, pistonLength = 0.001, rodMountRadius = 0.0, baseMountRadius = 0.0, baseMountLength = 0.0, colorCylinder = [-1.,-1.,-1.,-1.], colorPiston = [0.8,0.8,0.8,1.]):
-        self.show = show
-        self.cylinderRadius = cylinderRadius
-        self.rodRadius = rodRadius
-        self.pistonRadius = pistonRadius
-        self.pistonLength = pistonLength
-        self.rodMountRadius = rodMountRadius
-        self.baseMountRadius = baseMountRadius
-        self.baseMountLength = baseMountLength
-        self.colorCylinder = np.array(colorCylinder)
-        self.colorPiston = np.array(colorPiston)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'cylinderRadius', self.cylinderRadius
-        yield 'rodRadius', self.rodRadius
-        yield 'pistonRadius', self.pistonRadius
-        yield 'pistonLength', self.pistonLength
-        yield 'rodMountRadius', self.rodMountRadius
-        yield 'baseMountRadius', self.baseMountRadius
-        yield 'baseMountLength', self.baseMountLength
-        yield 'colorCylinder', self.colorCylinder
-        yield 'colorPiston', self.colorPiston
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorHydraulicActuatorSimple:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumbers = [], offsetLength = 0., strokeLength = 0., chamberCrossSection0 = 0., chamberCrossSection1 = 0., hoseVolume0 = 0., hoseVolume1 = 0., valveOpening0 = 0., valveOpening1 = 0., actuatorDamping = 0., oilBulkModulus = 0., cylinderBulkModulus = 0., hoseBulkModulus = 0., nominalFlow = 0., systemPressure = 0., tankPressure = 0., useChamberVolumeChange = False, activeConnector = True, visualization = {'show': True, 'cylinderRadius': 0.05, 'rodRadius': 0.03, 'pistonRadius': 0.04, 'pistonLength': 0.001, 'rodMountRadius': 0.0, 'baseMountRadius': 0.0, 'baseMountLength': 0.0, 'colorCylinder': [-1.,-1.,-1.,-1.], 'colorPiston': [0.8,0.8,0.8,1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.offsetLength = CheckForValidUReal(offsetLength,"offsetLength","ObjectConnectorHydraulicActuatorSimple")
-        self.strokeLength = CheckForValidPReal(strokeLength,"strokeLength","ObjectConnectorHydraulicActuatorSimple")
-        self.chamberCrossSection0 = CheckForValidPReal(chamberCrossSection0,"chamberCrossSection0","ObjectConnectorHydraulicActuatorSimple")
-        self.chamberCrossSection1 = CheckForValidPReal(chamberCrossSection1,"chamberCrossSection1","ObjectConnectorHydraulicActuatorSimple")
-        self.hoseVolume0 = CheckForValidPReal(hoseVolume0,"hoseVolume0","ObjectConnectorHydraulicActuatorSimple")
-        self.hoseVolume1 = CheckForValidPReal(hoseVolume1,"hoseVolume1","ObjectConnectorHydraulicActuatorSimple")
-        self.valveOpening0 = valveOpening0
-        self.valveOpening1 = valveOpening1
-        self.actuatorDamping = CheckForValidUReal(actuatorDamping,"actuatorDamping","ObjectConnectorHydraulicActuatorSimple")
-        self.oilBulkModulus = CheckForValidPReal(oilBulkModulus,"oilBulkModulus","ObjectConnectorHydraulicActuatorSimple")
-        self.cylinderBulkModulus = CheckForValidUReal(cylinderBulkModulus,"cylinderBulkModulus","ObjectConnectorHydraulicActuatorSimple")
-        self.hoseBulkModulus = CheckForValidUReal(hoseBulkModulus,"hoseBulkModulus","ObjectConnectorHydraulicActuatorSimple")
-        self.nominalFlow = CheckForValidPReal(nominalFlow,"nominalFlow","ObjectConnectorHydraulicActuatorSimple")
-        self.systemPressure = systemPressure
-        self.tankPressure = tankPressure
-        self.useChamberVolumeChange = useChamberVolumeChange
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorHydraulicActuatorSimple'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'offsetLength', self.offsetLength
-        yield 'strokeLength', self.strokeLength
-        yield 'chamberCrossSection0', self.chamberCrossSection0
-        yield 'chamberCrossSection1', self.chamberCrossSection1
-        yield 'hoseVolume0', self.hoseVolume0
-        yield 'hoseVolume1', self.hoseVolume1
-        yield 'valveOpening0', self.valveOpening0
-        yield 'valveOpening1', self.valveOpening1
-        yield 'actuatorDamping', self.actuatorDamping
-        yield 'oilBulkModulus', self.oilBulkModulus
-        yield 'cylinderBulkModulus', self.cylinderBulkModulus
-        yield 'hoseBulkModulus', self.hoseBulkModulus
-        yield 'nominalFlow', self.nominalFlow
-        yield 'systemPressure', self.systemPressure
-        yield 'tankPressure', self.tankPressure
-        yield 'useChamberVolumeChange', self.useChamberVolumeChange
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VcylinderRadius', dict(self.visualization)["cylinderRadius"]
-        yield 'VrodRadius', dict(self.visualization)["rodRadius"]
-        yield 'VpistonRadius', dict(self.visualization)["pistonRadius"]
-        yield 'VpistonLength', dict(self.visualization)["pistonLength"]
-        yield 'VrodMountRadius', dict(self.visualization)["rodMountRadius"]
-        yield 'VbaseMountRadius', dict(self.visualization)["baseMountRadius"]
-        yield 'VbaseMountLength', dict(self.visualization)["baseMountLength"]
-        yield 'VcolorCylinder', dict(self.visualization)["colorCylinder"]
-        yield 'VcolorPiston', dict(self.visualization)["colorPiston"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-HydraulicActuatorSimple = ObjectConnectorHydraulicActuatorSimple
-VHydraulicActuatorSimple = VObjectConnectorHydraulicActuatorSimple
-
-class VObjectConnectorReevingSystemSprings:
-    def __init__(self, show = True, ropeRadius = 0.001, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.ropeRadius = ropeRadius
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'ropeRadius', self.ropeRadius
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorReevingSystemSprings:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], hasCoordinateMarkers = False, coordinateFactors = [1,1], stiffnessPerLength = 0., dampingPerLength = 0., dampingTorsional = 0., dampingShear = 0., regularizationForce = 0.1, referenceLength = 0., sheavesAxes = None, sheavesRadii = [], activeConnector = True, visualization = {'show': True, 'ropeRadius': 0.001, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.hasCoordinateMarkers = hasCoordinateMarkers
-        self.coordinateFactors = np.array(coordinateFactors)
-        self.stiffnessPerLength = CheckForValidUReal(stiffnessPerLength,"stiffnessPerLength","ObjectConnectorReevingSystemSprings")
-        self.dampingPerLength = CheckForValidUReal(dampingPerLength,"dampingPerLength","ObjectConnectorReevingSystemSprings")
-        self.dampingTorsional = CheckForValidUReal(dampingTorsional,"dampingTorsional","ObjectConnectorReevingSystemSprings")
-        self.dampingShear = CheckForValidUReal(dampingShear,"dampingShear","ObjectConnectorReevingSystemSprings")
-        self.regularizationForce = regularizationForce
-        self.referenceLength = referenceLength
-        self.sheavesAxes = sheavesAxes
-        self.sheavesRadii = np.array(sheavesRadii)
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorReevingSystemSprings'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'hasCoordinateMarkers', self.hasCoordinateMarkers
-        yield 'coordinateFactors', self.coordinateFactors
-        yield 'stiffnessPerLength', self.stiffnessPerLength
-        yield 'dampingPerLength', self.dampingPerLength
-        yield 'dampingTorsional', self.dampingTorsional
-        yield 'dampingShear', self.dampingShear
-        yield 'regularizationForce', self.regularizationForce
-        yield 'referenceLength', self.referenceLength
-        yield 'sheavesAxes', self.sheavesAxes
-        yield 'sheavesRadii', self.sheavesRadii
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VropeRadius', dict(self.visualization)["ropeRadius"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-ReevingSystemSprings = ObjectConnectorReevingSystemSprings
-VReevingSystemSprings = VObjectConnectorReevingSystemSprings
-
-class VObjectConnectorDistance:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorDistance:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], distance = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.distance = CheckForValidPReal(distance,"distance","ObjectConnectorDistance")
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorDistance'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'distance', self.distance
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-DistanceConstraint = ObjectConnectorDistance
-VDistanceConstraint = VObjectConnectorDistance
-
-class VObjectConnectorCoordinate:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorCoordinate:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], offset = 0., factorValue1 = 1., velocityLevel = False, offsetUserFunction = 0, offsetUserFunction_t = 0, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.offset = offset
-        self.factorValue1 = factorValue1
-        self.velocityLevel = velocityLevel
-        self.offsetUserFunction = offsetUserFunction
-        self.offsetUserFunction_t = offsetUserFunction_t
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorCoordinate'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'offset', self.offset
-        yield 'factorValue1', self.factorValue1
-        yield 'velocityLevel', self.velocityLevel
-        yield 'offsetUserFunction', self.offsetUserFunction
-        yield 'offsetUserFunction_t', self.offsetUserFunction_t
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-CoordinateConstraint = ObjectConnectorCoordinate
-VCoordinateConstraint = VObjectConnectorCoordinate
-
-class VObjectConnectorCoordinateVector:
-    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorCoordinateVector:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], scalingMarker0 = [], scalingMarker1 = [], quadraticTermMarker0 = [], quadraticTermMarker1 = [], offset = [], velocityLevel = False, constraintUserFunction = 0, jacobianUserFunction = 0, activeConnector = True, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.scalingMarker0 = np.array(scalingMarker0)
-        self.scalingMarker1 = np.array(scalingMarker1)
-        self.quadraticTermMarker0 = np.array(quadraticTermMarker0)
-        self.quadraticTermMarker1 = np.array(quadraticTermMarker1)
-        self.offset = np.array(offset)
-        self.velocityLevel = velocityLevel
-        self.constraintUserFunction = constraintUserFunction
-        self.jacobianUserFunction = jacobianUserFunction
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorCoordinateVector'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'scalingMarker0', self.scalingMarker0
-        yield 'scalingMarker1', self.scalingMarker1
-        yield 'quadraticTermMarker0', self.quadraticTermMarker0
-        yield 'quadraticTermMarker1', self.quadraticTermMarker1
-        yield 'offset', self.offset
-        yield 'velocityLevel', self.velocityLevel
-        yield 'constraintUserFunction', self.constraintUserFunction
-        yield 'jacobianUserFunction', self.jacobianUserFunction
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-CoordinateVectorConstraint = ObjectConnectorCoordinateVector
-VCoordinateVectorConstraint = VObjectConnectorCoordinateVector
-
-class VObjectConnectorRollingDiscPenalty:
-    def __init__(self, show = True, discWidth = 0.1, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.discWidth = discWidth
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'discWidth', self.discWidth
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectConnectorRollingDiscPenalty:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), discRadius = 0., discAxis = [1,0,0], planeNormal = [0,0,1], dryFrictionAngle = 0., contactStiffness = 0., contactDamping = 0., dryFriction = [0,0], dryFrictionProportionalZone = 0., viscousFriction = [0,0], rollingFrictionViscous = 0., useLinearProportionalZone = False, activeConnector = True, visualization = {'show': True, 'discWidth': 0.1, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.discRadius = CheckForValidPReal(discRadius,"discRadius","ObjectConnectorRollingDiscPenalty")
-        self.discAxis = np.array(discAxis)
-        self.planeNormal = np.array(planeNormal)
-        self.dryFrictionAngle = dryFrictionAngle
-        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectConnectorRollingDiscPenalty")
-        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectConnectorRollingDiscPenalty")
-        self.dryFriction = np.array(dryFriction)
-        self.dryFrictionProportionalZone = dryFrictionProportionalZone
-        self.viscousFriction = np.array(viscousFriction)
-        self.rollingFrictionViscous = rollingFrictionViscous
-        self.useLinearProportionalZone = useLinearProportionalZone
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ConnectorRollingDiscPenalty'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'discRadius', self.discRadius
-        yield 'discAxis', self.discAxis
-        yield 'planeNormal', self.planeNormal
-        yield 'dryFrictionAngle', self.dryFrictionAngle
-        yield 'contactStiffness', self.contactStiffness
-        yield 'contactDamping', self.contactDamping
-        yield 'dryFriction', self.dryFriction
-        yield 'dryFrictionProportionalZone', self.dryFrictionProportionalZone
-        yield 'viscousFriction', self.viscousFriction
-        yield 'rollingFrictionViscous', self.rollingFrictionViscous
-        yield 'useLinearProportionalZone', self.useLinearProportionalZone
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdiscWidth', dict(self.visualization)["discWidth"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RollingDiscPenalty = ObjectConnectorRollingDiscPenalty
-VRollingDiscPenalty = VObjectConnectorRollingDiscPenalty
-
-class VObjectContactConvexRoll:
-    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectContactConvexRoll:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), contactStiffness = 0., contactDamping = 0., dynamicFriction = 0., staticFrictionOffset = 0., viscousFriction = 0., exponentialDecayStatic = 1e-3, frictionProportionalZone = 1e-3, rollLength = 0., coefficientsHull =  [], rBoundingSphere = 0, activeConnector = True, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.contactStiffness = contactStiffness
-        self.contactDamping = contactDamping
-        self.dynamicFriction = CheckForValidUReal(dynamicFriction,"dynamicFriction","ObjectContactConvexRoll")
-        self.staticFrictionOffset = CheckForValidUReal(staticFrictionOffset,"staticFrictionOffset","ObjectContactConvexRoll")
-        self.viscousFriction = CheckForValidUReal(viscousFriction,"viscousFriction","ObjectContactConvexRoll")
-        self.exponentialDecayStatic = CheckForValidPReal(exponentialDecayStatic,"exponentialDecayStatic","ObjectContactConvexRoll")
-        self.frictionProportionalZone = CheckForValidUReal(frictionProportionalZone,"frictionProportionalZone","ObjectContactConvexRoll")
-        self.rollLength = CheckForValidUReal(rollLength,"rollLength","ObjectContactConvexRoll")
-        self.coefficientsHull = np.array(coefficientsHull)
-        self.rBoundingSphere = CheckForValidUReal(rBoundingSphere,"rBoundingSphere","ObjectContactConvexRoll")
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ContactConvexRoll'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'contactStiffness', self.contactStiffness
-        yield 'contactDamping', self.contactDamping
-        yield 'dynamicFriction', self.dynamicFriction
-        yield 'staticFrictionOffset', self.staticFrictionOffset
-        yield 'viscousFriction', self.viscousFriction
-        yield 'exponentialDecayStatic', self.exponentialDecayStatic
-        yield 'frictionProportionalZone', self.frictionProportionalZone
-        yield 'rollLength', self.rollLength
-        yield 'coefficientsHull', self.coefficientsHull
-        yield 'rBoundingSphere', self.rBoundingSphere
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectContactCoordinate:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectContactCoordinate:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), contactStiffness = 0., contactDamping = 0., offset = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactCoordinate")
-        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactCoordinate")
-        self.offset = offset
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ContactCoordinate'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'contactStiffness', self.contactStiffness
-        yield 'contactDamping', self.contactDamping
-        yield 'offset', self.offset
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectContactCircleCable2D:
-    def __init__(self, show = True, showContactCircle = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.showContactCircle = showContactCircle
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'showContactCircle', self.showContactCircle
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectContactCircleCable2D:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), numberOfContactSegments = 3, contactStiffness = 0., contactDamping = 0., circleRadius = 0., offset = 0., activeConnector = True, visualization = {'show': True, 'showContactCircle': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.numberOfContactSegments = numberOfContactSegments
-        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactCircleCable2D")
-        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactCircleCable2D")
-        self.circleRadius = CheckForValidUReal(circleRadius,"circleRadius","ObjectContactCircleCable2D")
-        self.offset = offset
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ContactCircleCable2D'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'numberOfContactSegments', self.numberOfContactSegments
-        yield 'contactStiffness', self.contactStiffness
-        yield 'contactDamping', self.contactDamping
-        yield 'circleRadius', self.circleRadius
-        yield 'offset', self.offset
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VshowContactCircle', dict(self.visualization)["showContactCircle"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectContactFrictionCircleCable2D:
-    def __init__(self, show = True, showContactCircle = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.showContactCircle = showContactCircle
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'showContactCircle', self.showContactCircle
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectContactFrictionCircleCable2D:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), numberOfContactSegments = 3, contactStiffness = 0., contactDamping = 0., frictionVelocityPenalty = 0., frictionStiffness = 0., frictionCoefficient = 0., circleRadius = 0., useSegmentNormals = True, activeConnector = True, visualization = {'show': True, 'showContactCircle': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.numberOfContactSegments = CheckForValidPInt(numberOfContactSegments,"numberOfContactSegments","ObjectContactFrictionCircleCable2D")
-        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactFrictionCircleCable2D")
-        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactFrictionCircleCable2D")
-        self.frictionVelocityPenalty = CheckForValidUReal(frictionVelocityPenalty,"frictionVelocityPenalty","ObjectContactFrictionCircleCable2D")
-        self.frictionStiffness = CheckForValidUReal(frictionStiffness,"frictionStiffness","ObjectContactFrictionCircleCable2D")
-        self.frictionCoefficient = CheckForValidUReal(frictionCoefficient,"frictionCoefficient","ObjectContactFrictionCircleCable2D")
-        self.circleRadius = CheckForValidUReal(circleRadius,"circleRadius","ObjectContactFrictionCircleCable2D")
-        self.useSegmentNormals = useSegmentNormals
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ContactFrictionCircleCable2D'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'numberOfContactSegments', self.numberOfContactSegments
-        yield 'contactStiffness', self.contactStiffness
-        yield 'contactDamping', self.contactDamping
-        yield 'frictionVelocityPenalty', self.frictionVelocityPenalty
-        yield 'frictionStiffness', self.frictionStiffness
-        yield 'frictionCoefficient', self.frictionCoefficient
-        yield 'circleRadius', self.circleRadius
-        yield 'useSegmentNormals', self.useSegmentNormals
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VshowContactCircle', dict(self.visualization)["showContactCircle"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VObjectJointGeneric:
-    def __init__(self, show = True, axesRadius = 0.1, axesLength = 0.4, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.axesRadius = axesRadius
-        self.axesLength = axesLength
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'axesRadius', self.axesRadius
-        yield 'axesLength', self.axesLength
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointGeneric:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], constrainedAxes = [1,1,1,1,1,1], rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), activeConnector = True, offsetUserFunctionParameters = [0.,0.,0.,0.,0.,0.], offsetUserFunction = 0, offsetUserFunction_t = 0, alternativeConstraints = False, visualization = {'show': True, 'axesRadius': 0.1, 'axesLength': 0.4, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.constrainedAxes = copy.copy(constrainedAxes)
-        self.rotationMarker0 = np.array(rotationMarker0)
-        self.rotationMarker1 = np.array(rotationMarker1)
-        self.activeConnector = activeConnector
-        self.offsetUserFunctionParameters = np.array(offsetUserFunctionParameters)
-        self.offsetUserFunction = offsetUserFunction
-        self.offsetUserFunction_t = offsetUserFunction_t
-        self.alternativeConstraints = alternativeConstraints
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointGeneric'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'constrainedAxes', self.constrainedAxes
-        yield 'rotationMarker0', self.rotationMarker0
-        yield 'rotationMarker1', self.rotationMarker1
-        yield 'activeConnector', self.activeConnector
-        yield 'offsetUserFunctionParameters', self.offsetUserFunctionParameters
-        yield 'offsetUserFunction', self.offsetUserFunction
-        yield 'offsetUserFunction_t', self.offsetUserFunction_t
-        yield 'alternativeConstraints', self.alternativeConstraints
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VaxesRadius', dict(self.visualization)["axesRadius"]
-        yield 'VaxesLength', dict(self.visualization)["axesLength"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-GenericJoint = ObjectJointGeneric
-VGenericJoint = VObjectJointGeneric
-
-class VObjectJointRevoluteZ:
-    def __init__(self, show = True, axisRadius = 0.1, axisLength = 0.4, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.axisRadius = axisRadius
-        self.axisLength = axisLength
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'axisRadius', self.axisRadius
-        yield 'axisLength', self.axisLength
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointRevoluteZ:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), activeConnector = True, visualization = {'show': True, 'axisRadius': 0.1, 'axisLength': 0.4, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.rotationMarker0 = np.array(rotationMarker0)
-        self.rotationMarker1 = np.array(rotationMarker1)
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointRevoluteZ'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'rotationMarker0', self.rotationMarker0
-        yield 'rotationMarker1', self.rotationMarker1
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VaxisRadius', dict(self.visualization)["axisRadius"]
-        yield 'VaxisLength', dict(self.visualization)["axisLength"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RevoluteJointZ = ObjectJointRevoluteZ
-VRevoluteJointZ = VObjectJointRevoluteZ
-
-class VObjectJointPrismaticX:
-    def __init__(self, show = True, axisRadius = 0.1, axisLength = 0.4, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.axisRadius = axisRadius
-        self.axisLength = axisLength
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'axisRadius', self.axisRadius
-        yield 'axisLength', self.axisLength
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointPrismaticX:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), activeConnector = True, visualization = {'show': True, 'axisRadius': 0.1, 'axisLength': 0.4, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.rotationMarker0 = np.array(rotationMarker0)
-        self.rotationMarker1 = np.array(rotationMarker1)
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointPrismaticX'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'rotationMarker0', self.rotationMarker0
-        yield 'rotationMarker1', self.rotationMarker1
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VaxisRadius', dict(self.visualization)["axisRadius"]
-        yield 'VaxisLength', dict(self.visualization)["axisLength"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-PrismaticJointX = ObjectJointPrismaticX
-VPrismaticJointX = VObjectJointPrismaticX
-
-class VObjectJointSpherical:
-    def __init__(self, show = True, jointRadius = 0.1, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.jointRadius = jointRadius
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'jointRadius', self.jointRadius
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointSpherical:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], constrainedAxes = [1,1,1], activeConnector = True, visualization = {'show': True, 'jointRadius': 0.1, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.constrainedAxes = copy.copy(constrainedAxes)
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointSpherical'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'constrainedAxes', self.constrainedAxes
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VjointRadius', dict(self.visualization)["jointRadius"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-SphericalJoint = ObjectJointSpherical
-VSphericalJoint = VObjectJointSpherical
-
-class VObjectJointRollingDisc:
-    def __init__(self, show = True, discWidth = 0.1, color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.discWidth = discWidth
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'discWidth', self.discWidth
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointRollingDisc:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], constrainedAxes = [1,1,1], activeConnector = True, discRadius = 0, discAxis = [1,0,0], planeNormal = [0,0,1], visualization = {'show': True, 'discWidth': 0.1, 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.constrainedAxes = copy.copy(constrainedAxes)
-        self.activeConnector = activeConnector
-        self.discRadius = CheckForValidPReal(discRadius,"discRadius","ObjectJointRollingDisc")
-        self.discAxis = np.array(discAxis)
-        self.planeNormal = np.array(planeNormal)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointRollingDisc'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'constrainedAxes', self.constrainedAxes
-        yield 'activeConnector', self.activeConnector
-        yield 'discRadius', self.discRadius
-        yield 'discAxis', self.discAxis
-        yield 'planeNormal', self.planeNormal
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdiscWidth', dict(self.visualization)["discWidth"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RollingDiscJoint = ObjectJointRollingDisc
-VRollingDiscJoint = VObjectJointRollingDisc
-
-class VObjectJointRevolute2D:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointRevolute2D:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointRevolute2D'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-RevoluteJoint2D = ObjectJointRevolute2D
-VRevoluteJoint2D = VObjectJointRevolute2D
-
-class VObjectJointPrismatic2D:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointPrismatic2D:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], axisMarker0 = [1.,0.,0.], normalMarker1 = [0.,1.,0.], constrainRotation = True, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.axisMarker0 = np.array(axisMarker0)
-        self.normalMarker1 = np.array(normalMarker1)
-        self.constrainRotation = constrainRotation
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointPrismatic2D'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'axisMarker0', self.axisMarker0
-        yield 'normalMarker1', self.normalMarker1
-        yield 'constrainRotation', self.constrainRotation
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-PrismaticJoint2D = ObjectJointPrismatic2D
-VPrismaticJoint2D = VObjectJointPrismatic2D
-
-class VObjectJointSliding2D:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointSliding2D:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], slidingMarkerNumbers = [], slidingMarkerOffsets = [], nodeNumber = exudyn.InvalidIndex(), classicalFormulation = True, constrainRotation = False, axialForce = 0, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.slidingMarkerNumbers = copy.copy(slidingMarkerNumbers)
-        self.slidingMarkerOffsets = np.array(slidingMarkerOffsets)
-        self.nodeNumber = nodeNumber
-        self.classicalFormulation = classicalFormulation
-        self.constrainRotation = constrainRotation
-        self.axialForce = axialForce
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointSliding2D'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'slidingMarkerNumbers', self.slidingMarkerNumbers
-        yield 'slidingMarkerOffsets', self.slidingMarkerOffsets
-        yield 'nodeNumber', self.nodeNumber
-        yield 'classicalFormulation', self.classicalFormulation
-        yield 'constrainRotation', self.constrainRotation
-        yield 'axialForce', self.axialForce
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-SlidingJoint2D = ObjectJointSliding2D
-VSlidingJoint2D = VObjectJointSliding2D
-
-class VObjectJointALEMoving2D:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectJointALEMoving2D:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], slidingMarkerNumbers = [], slidingMarkerOffsets = [], slidingOffset = 0., nodeNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], usePenaltyFormulation = False, penaltyStiffness = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.slidingMarkerNumbers = copy.copy(slidingMarkerNumbers)
-        self.slidingMarkerOffsets = np.array(slidingMarkerOffsets)
-        self.slidingOffset = slidingOffset
-        self.nodeNumbers = copy.copy(nodeNumbers)
-        self.usePenaltyFormulation = usePenaltyFormulation
-        self.penaltyStiffness = penaltyStiffness
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'JointALEMoving2D'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'slidingMarkerNumbers', self.slidingMarkerNumbers
-        yield 'slidingMarkerOffsets', self.slidingMarkerOffsets
-        yield 'slidingOffset', self.slidingOffset
-        yield 'nodeNumbers', self.nodeNumbers
-        yield 'usePenaltyFormulation', self.usePenaltyFormulation
-        yield 'penaltyStiffness', self.penaltyStiffness
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-ALEMovingJoint2D = ObjectJointALEMoving2D
-VALEMovingJoint2D = VObjectJointALEMoving2D
-
-class VObjectContactFrictionCircleCable2DOld:
-    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
-        self.show = show
-        self.drawSize = drawSize
-        self.color = np.array(color)
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'drawSize', self.drawSize
-        yield 'color', self.color
-
-    def __repr__(self):
-        return str(dict(self))
-class ObjectContactFrictionCircleCable2DOld:
-    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), numberOfContactSegments = 3, contactStiffness = 0., contactDamping = 0., frictionVelocityPenalty = 0., frictionStiffness = 0., frictionCoefficient = 0., circleRadius = 0., offset = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
-        self.name = name
-        self.markerNumbers = copy.copy(markerNumbers)
-        self.nodeNumber = nodeNumber
-        self.numberOfContactSegments = CheckForValidPInt(numberOfContactSegments,"numberOfContactSegments","ObjectContactFrictionCircleCable2DOld")
-        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactFrictionCircleCable2DOld")
-        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactFrictionCircleCable2DOld")
-        self.frictionVelocityPenalty = CheckForValidUReal(frictionVelocityPenalty,"frictionVelocityPenalty","ObjectContactFrictionCircleCable2DOld")
-        self.frictionStiffness = CheckForValidUReal(frictionStiffness,"frictionStiffness","ObjectContactFrictionCircleCable2DOld")
-        self.frictionCoefficient = CheckForValidUReal(frictionCoefficient,"frictionCoefficient","ObjectContactFrictionCircleCable2DOld")
-        self.circleRadius = CheckForValidUReal(circleRadius,"circleRadius","ObjectContactFrictionCircleCable2DOld")
-        self.offset = offset
-        self.activeConnector = activeConnector
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'objectType', 'ContactFrictionCircleCable2DOld'
-        yield 'name', self.name
-        yield 'markerNumbers', self.markerNumbers
-        yield 'nodeNumber', self.nodeNumber
-        yield 'numberOfContactSegments', self.numberOfContactSegments
-        yield 'contactStiffness', self.contactStiffness
-        yield 'contactDamping', self.contactDamping
-        yield 'frictionVelocityPenalty', self.frictionVelocityPenalty
-        yield 'frictionStiffness', self.frictionStiffness
-        yield 'frictionCoefficient', self.frictionCoefficient
-        yield 'circleRadius', self.circleRadius
-        yield 'offset', self.offset
-        yield 'activeConnector', self.activeConnector
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VdrawSize', dict(self.visualization)["drawSize"]
-        yield 'Vcolor', dict(self.visualization)["color"]
-
-    def __repr__(self):
-        return str(dict(self))
-#+++++++++++++++++++++++++++++++
-#MARKER
-class VMarkerBodyMass:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerBodyMass:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'BodyMass'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerBodyPosition:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerBodyPosition:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.localPosition = np.array(localPosition)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'BodyPosition'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'localPosition', self.localPosition
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerBodyRigid:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerBodyRigid:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.localPosition = np.array(localPosition)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'BodyRigid'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'localPosition', self.localPosition
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerNodePosition:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerNodePosition:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'NodePosition'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerNodeRigid:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerNodeRigid:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'NodeRigid'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerNodeCoordinate:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerNodeCoordinate:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), coordinate = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.coordinate = CheckForValidUInt(coordinate,"coordinate","MarkerNodeCoordinate")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'NodeCoordinate'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'coordinate', self.coordinate
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerNodeCoordinates:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerNodeCoordinates:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'NodeCoordinates'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerNodeODE1Coordinate:
-    def __init__(self, show = False):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerNodeODE1Coordinate:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), coordinate = exudyn.InvalidIndex(), visualization = {'show': False}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.coordinate = CheckForValidUInt(coordinate,"coordinate","MarkerNodeODE1Coordinate")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'NodeODE1Coordinate'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'coordinate', self.coordinate
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerNodeRotationCoordinate:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerNodeRotationCoordinate:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), rotationCoordinate = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.rotationCoordinate = CheckForValidUInt(rotationCoordinate,"rotationCoordinate","MarkerNodeRotationCoordinate")
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'NodeRotationCoordinate'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'rotationCoordinate', self.rotationCoordinate
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerSuperElementPosition:
-    def __init__(self, show = True, showMarkerNodes = True):
-        self.show = show
-        self.showMarkerNodes = showMarkerNodes
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'showMarkerNodes', self.showMarkerNodes
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerSuperElementPosition:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), meshNodeNumbers = [], weightingFactors = [], visualization = {'show': True, 'showMarkerNodes': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.meshNodeNumbers = copy.copy(meshNodeNumbers)
-        self.weightingFactors = np.array(weightingFactors)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'SuperElementPosition'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'meshNodeNumbers', self.meshNodeNumbers
-        yield 'weightingFactors', self.weightingFactors
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VshowMarkerNodes', dict(self.visualization)["showMarkerNodes"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerSuperElementRigid:
-    def __init__(self, show = True, showMarkerNodes = True):
-        self.show = show
-        self.showMarkerNodes = showMarkerNodes
-
-    def __iter__(self):
-        yield 'show', self.show
-        yield 'showMarkerNodes', self.showMarkerNodes
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerSuperElementRigid:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), offset = [0.,0.,0.], meshNodeNumbers = [], weightingFactors = [], useAlternativeApproach = True, rotationsExponentialMap = 2, visualization = {'show': True, 'showMarkerNodes': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.offset = np.array(offset)
-        self.meshNodeNumbers = copy.copy(meshNodeNumbers)
-        self.weightingFactors = np.array(weightingFactors)
-        self.useAlternativeApproach = useAlternativeApproach
-        self.rotationsExponentialMap = rotationsExponentialMap
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'SuperElementRigid'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'offset', self.offset
-        yield 'meshNodeNumbers', self.meshNodeNumbers
-        yield 'weightingFactors', self.weightingFactors
-        yield 'useAlternativeApproach', self.useAlternativeApproach
-        yield 'rotationsExponentialMap', self.rotationsExponentialMap
-        yield 'Vshow', dict(self.visualization)["show"]
-        yield 'VshowMarkerNodes', dict(self.visualization)["showMarkerNodes"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerKinematicTreeRigid:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerKinematicTreeRigid:
-    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), linkNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], visualization = {'show': True}):
-        self.name = name
-        self.objectNumber = objectNumber
-        self.linkNumber = CheckForValidUInt(linkNumber,"linkNumber","MarkerKinematicTreeRigid")
-        self.localPosition = np.array(localPosition)
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'KinematicTreeRigid'
-        yield 'name', self.name
-        yield 'objectNumber', self.objectNumber
-        yield 'linkNumber', self.linkNumber
-        yield 'localPosition', self.localPosition
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerObjectODE2Coordinates:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerObjectODE2Coordinates:
-    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.objectNumber = objectNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'ObjectODE2Coordinates'
-        yield 'name', self.name
-        yield 'objectNumber', self.objectNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerBodyCable2DShape:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerBodyCable2DShape:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), numberOfSegments = 3, verticalOffset = 0., visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.numberOfSegments = CheckForValidPInt(numberOfSegments,"numberOfSegments","MarkerBodyCable2DShape")
-        self.verticalOffset = verticalOffset
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'BodyCable2DShape'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'numberOfSegments', self.numberOfSegments
-        yield 'verticalOffset', self.verticalOffset
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VMarkerBodyCable2DCoordinates:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class MarkerBodyCable2DCoordinates:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'markerType', 'BodyCable2DCoordinates'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-#+++++++++++++++++++++++++++++++
-#LOAD
-class VLoadForceVector:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class LoadForceVector:
-    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), loadVector = [0.,0.,0.], bodyFixed = False, loadVectorUserFunction = 0, visualization = {'show': True}):
-        self.name = name
-        self.markerNumber = markerNumber
-        self.loadVector = np.array(loadVector)
-        self.bodyFixed = bodyFixed
-        self.loadVectorUserFunction = loadVectorUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'loadType', 'ForceVector'
-        yield 'name', self.name
-        yield 'markerNumber', self.markerNumber
-        yield 'loadVector', self.loadVector
-        yield 'bodyFixed', self.bodyFixed
-        yield 'loadVectorUserFunction', self.loadVectorUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Force = LoadForceVector
-VForce = VLoadForceVector
-
-class VLoadTorqueVector:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class LoadTorqueVector:
-    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), loadVector = [0.,0.,0.], bodyFixed = False, loadVectorUserFunction = 0, visualization = {'show': True}):
-        self.name = name
-        self.markerNumber = markerNumber
-        self.loadVector = np.array(loadVector)
-        self.bodyFixed = bodyFixed
-        self.loadVectorUserFunction = loadVectorUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'loadType', 'TorqueVector'
-        yield 'name', self.name
-        yield 'markerNumber', self.markerNumber
-        yield 'loadVector', self.loadVector
-        yield 'bodyFixed', self.bodyFixed
-        yield 'loadVectorUserFunction', self.loadVectorUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Torque = LoadTorqueVector
-VTorque = VLoadTorqueVector
-
-class VLoadMassProportional:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class LoadMassProportional:
-    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), loadVector = [0.,0.,0.], loadVectorUserFunction = 0, visualization = {'show': True}):
-        self.name = name
-        self.markerNumber = markerNumber
-        self.loadVector = np.array(loadVector)
-        self.loadVectorUserFunction = loadVectorUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'loadType', 'MassProportional'
-        yield 'name', self.name
-        yield 'markerNumber', self.markerNumber
-        yield 'loadVector', self.loadVector
-        yield 'loadVectorUserFunction', self.loadVectorUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-#add typedef for short usage:
-Gravity = LoadMassProportional
-VGravity = VLoadMassProportional
-
-class VLoadCoordinate:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class LoadCoordinate:
-    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), load = 0., loadUserFunction = 0, visualization = {'show': True}):
-        self.name = name
-        self.markerNumber = markerNumber
-        self.load = load
-        self.loadUserFunction = loadUserFunction
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'loadType', 'Coordinate'
-        yield 'name', self.name
-        yield 'markerNumber', self.markerNumber
-        yield 'load', self.load
-        yield 'loadUserFunction', self.loadUserFunction
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-#+++++++++++++++++++++++++++++++
-#SENSOR
-class VSensorNode:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorNode:
-    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.nodeNumber = nodeNumber
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.outputVariableType = outputVariableType
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'Node'
-        yield 'name', self.name
-        yield 'nodeNumber', self.nodeNumber
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'outputVariableType', self.outputVariableType
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorObject:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorObject:
-    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.objectNumber = objectNumber
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.outputVariableType = outputVariableType
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'Object'
-        yield 'name', self.name
-        yield 'objectNumber', self.objectNumber
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'outputVariableType', self.outputVariableType
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorBody:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorBody:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.localPosition = np.array(localPosition)
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.outputVariableType = outputVariableType
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'Body'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'localPosition', self.localPosition
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'outputVariableType', self.outputVariableType
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorSuperElement:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorSuperElement:
-    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), meshNodeNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.bodyNumber = bodyNumber
-        self.meshNodeNumber = CheckForValidUInt(meshNodeNumber,"meshNodeNumber","SensorSuperElement")
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.outputVariableType = outputVariableType
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'SuperElement'
-        yield 'name', self.name
-        yield 'bodyNumber', self.bodyNumber
-        yield 'meshNodeNumber', self.meshNodeNumber
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'outputVariableType', self.outputVariableType
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorKinematicTree:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorKinematicTree:
-    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), linkNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.objectNumber = objectNumber
-        self.linkNumber = CheckForValidUInt(linkNumber,"linkNumber","SensorKinematicTree")
-        self.localPosition = np.array(localPosition)
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.outputVariableType = outputVariableType
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'KinematicTree'
-        yield 'name', self.name
-        yield 'objectNumber', self.objectNumber
-        yield 'linkNumber', self.linkNumber
-        yield 'localPosition', self.localPosition
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'outputVariableType', self.outputVariableType
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorMarker:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorMarker:
-    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.markerNumber = markerNumber
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.outputVariableType = outputVariableType
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'Marker'
-        yield 'name', self.name
-        yield 'markerNumber', self.markerNumber
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'outputVariableType', self.outputVariableType
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorLoad:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorLoad:
-    def __init__(self, name = '', loadNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.loadNumber = loadNumber
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'Load'
-        yield 'name', self.name
-        yield 'loadNumber', self.loadNumber
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
-class VSensorUserFunction:
-    def __init__(self, show = True):
-        self.show = show
-
-    def __iter__(self):
-        yield 'show', self.show
-
-    def __repr__(self):
-        return str(dict(self))
-class SensorUserFunction:
-    def __init__(self, name = '', sensorNumbers = [], factors = [], writeToFile = True, fileName = '', sensorUserFunction = 0, storeInternal = False, visualization = {'show': True}):
-        self.name = name
-        self.sensorNumbers = copy.copy(sensorNumbers)
-        self.factors = np.array(factors)
-        self.writeToFile = writeToFile
-        self.fileName = fileName
-        self.sensorUserFunction = sensorUserFunction
-        self.storeInternal = storeInternal
-        self.visualization = CopyDictLevel1(visualization)
-
-    def __iter__(self):
-        yield 'sensorType', 'UserFunction'
-        yield 'name', self.name
-        yield 'sensorNumbers', self.sensorNumbers
-        yield 'factors', self.factors
-        yield 'writeToFile', self.writeToFile
-        yield 'fileName', self.fileName
-        yield 'sensorUserFunction', self.sensorUserFunction
-        yield 'storeInternal', self.storeInternal
-        yield 'Vshow', dict(self.visualization)["show"]
-
-    def __repr__(self):
-        return str(dict(self))
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN example 
+# 
+# Details:  automatically generated file for conversion of item (node, object, marker, ...) data to dictionaries
+# 
+# Author:   Johannes Gerstmayr
+# Date:     2019-07-01
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#item interface diagonal matrix creator
+
+import exudyn #for exudyn.InvalidIndex() and other exudyn native structures needed in RigidBodySpringDamper
+import numpy as np
+import copy 
+
+#helper function for level-1 copy of dicts (for visualization default args!)
+#visualization dictionaries (which may be huge, are only flat copied, which is sufficient)
+def CopyDictLevel1(originalDict):
+    if isinstance(originalDict,dict): #copy only required if default dict is used
+        copyDict = {}
+        for key, value in originalDict.items():
+            copyDict[key] = copy.copy(value)
+        return copyDict
+    else:
+        return originalDict #fast track for everything else
+    
+#helper function diagonal matrices, not needing numpy
+def IIDiagMatrix(rowsColumns, value):
+    m = []
+    for i in range(rowsColumns):
+        m += [rowsColumns*[0]]
+        m[i][i] = value
+    return m
+
+#helper function to check valid range
+def CheckForValidUInt(value, parameterName, objectName):
+    if value < 0:
+        raise ValueError("Error in "+objectName+": (int) parameter "+parameterName + " may not be negative, but received "+str(value))
+        return 0
+    return value
+#helper function to check valid range
+def CheckForValidPInt(value, parameterName, objectName):
+    if value <= 0:
+        raise ValueError("Error in "+objectName+": (int) parameter "+parameterName + " must be positive (> 0), but received "+str(value))
+        return 1 #this position is usually not reached
+    return value
+#helper function to check valid range
+def CheckForValidUReal(value, parameterName, objectName):
+    if value < 0:
+        raise ValueError("Error in "+objectName+": (float) parameter "+parameterName + " may not be negative, but received "+str(value))
+        return 0.
+    return value
+#helper function to check valid range
+def CheckForValidPReal(value, parameterName, objectName):
+    if value <= 0:
+        raise ValueError("Error in "+objectName+": (float) parameter "+parameterName + " must be positive (> 0), but received "+str(value))
+        return 1. #this position is usually not reached
+    return value
+
+userFunctionArgsDict = {'MainSystem,preStepUserFunction': [['MainSystem', 'Real'], ['mbs', 'arg0'], ['bool']],
+        'MainSystem,postStepUserFunction': [['MainSystem', 'Real'], ['mbs', 'arg0'], ['bool']],
+        'MainSystem,postNewtonFunction': [['MainSystem', 'Real'], ['mbs', 'arg0'], ['StdVector2D']],
+        'ObjectGround,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
+        'ObjectRigidBody,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
+        'ObjectRigidBody2D,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
+        'ObjectGenericODE2,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
+        'ObjectGenericODE2,massMatrixUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['py::object']],
+        'ObjectGenericODE2,jacobianUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5'], ['py::object']],
+        'ObjectGenericODE2,graphicsDataUserFunction': [['MainSystem', 'Index'], ['mbs', 'arg0'], ['py::object']],
+        'ObjectGenericODE1,rhsUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2'], ['StdVector']],
+        'ObjectKinematicTree,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
+        'ObjectFFRF,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
+        'ObjectFFRF,massMatrixUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['NumpyMatrix']],
+        'ObjectFFRFreducedOrder,forceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']],
+        'ObjectFFRFreducedOrder,massMatrixUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['NumpyMatrix']],
+        'ObjectANCFCable2D,axialForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10'], ['Real']],
+        'ObjectANCFCable2D,bendingMomentUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10'], ['Real']],
+        'ObjectConnectorSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
+        'ObjectConnectorCartesianSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['StdVector3D']],
+        'ObjectConnectorRigidBodySpringDamper,springForceTorqueUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdMatrix6D', 'StdMatrix6D', 'StdMatrix3D', 'StdMatrix3D', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10'], ['StdVector6D']],
+        'ObjectConnectorRigidBodySpringDamper,postNewtonStepUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdVector3D', 'StdMatrix6D', 'StdMatrix6D', 'StdMatrix3D', 'StdMatrix3D', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10', 'arg11'], ['StdVector']],
+        'ObjectConnectorLinearSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
+        'ObjectConnectorTorsionalSpringDamper,springTorqueUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
+        'ObjectConnectorCoordinateSpringDamper,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6'], ['Real']],
+        'ObjectConnectorCoordinateSpringDamperExt,springForceUserFunction': [['MainSystem', 'Real', 'Index', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8', 'arg9', 'arg10', 'arg11', 'arg12'], ['Real']],
+        'ObjectConnectorCoordinate,offsetUserFunction': [['MainSystem', 'Real', 'Index', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2'], ['Real']],
+        'ObjectConnectorCoordinate,offsetUserFunction_t': [['MainSystem', 'Real', 'Index', 'Real'], ['mbs', 'arg0', 'arg1', 'arg2'], ['Real']],
+        'ObjectConnectorCoordinateVector,constraintUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector', 'bool'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4'], ['StdVector']],
+        'ObjectConnectorCoordinateVector,jacobianUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector', 'StdVector', 'bool'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4'], ['py::object']],
+        'ObjectJointGeneric,offsetUserFunction': [['MainSystem', 'Real', 'Index', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2'], ['StdVector6D']],
+        'ObjectJointGeneric,offsetUserFunction_t': [['MainSystem', 'Real', 'Index', 'StdVector6D'], ['mbs', 'arg0', 'arg1', 'arg2'], ['StdVector6D']],
+        'LoadForceVector,loadVectorUserFunction': [['MainSystem', 'Real', 'StdVector3D'], ['mbs', 'arg0', 'arg1'], ['StdVector3D']],
+        'LoadTorqueVector,loadVectorUserFunction': [['MainSystem', 'Real', 'StdVector3D'], ['mbs', 'arg0', 'arg1'], ['StdVector3D']],
+        'LoadMassProportional,loadVectorUserFunction': [['MainSystem', 'Real', 'StdVector3D'], ['mbs', 'arg0', 'arg1'], ['StdVector3D']],
+        'LoadCoordinate,loadUserFunction': [['MainSystem', 'Real', 'Real'], ['mbs', 'arg0', 'arg1'], ['Real']],
+        'SensorUserFunction,sensorUserFunction': [['MainSystem', 'Real', 'StdArrayIndex', 'StdVector', 'ConfigurationType'], ['mbs', 'arg0', 'arg1', 'arg2', 'arg3'], ['StdVector']]}
+
+
+#+++++++++++++++++++++++++++++++
+#NODE
+class VNodePoint:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePoint:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.], initialCoordinates = [0.,0.,0.], initialVelocities = [0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'Point'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Point = NodePoint
+VPoint = VNodePoint
+
+class VNodePoint2D:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePoint2D:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.], initialCoordinates = [0.,0.], initialVelocities = [0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'Point2D'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Point2D = NodePoint2D
+VPoint2D = VNodePoint2D
+
+class VNodeRigidBodyEP:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeRigidBodyEP:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0., 0.,0.,0.,0.], initialCoordinates = [0.,0.,0., 0.,0.,0.,0.], initialVelocities = [0.,0.,0., 0.,0.,0.,0.], addConstraintEquation = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.addConstraintEquation = addConstraintEquation
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'RigidBodyEP'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'addConstraintEquation', self.addConstraintEquation
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RigidEP = NodeRigidBodyEP
+VRigidEP = VNodeRigidBodyEP
+
+class VNodeRigidBodyRxyz:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeRigidBodyRxyz:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0., 0.,0.,0.], initialCoordinates = [0.,0.,0., 0.,0.,0.], initialVelocities = [0.,0.,0., 0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'RigidBodyRxyz'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RigidRxyz = NodeRigidBodyRxyz
+VRigidRxyz = VNodeRigidBodyRxyz
+
+class VNodeRigidBodyRotVecLG:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeRigidBodyRotVecLG:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0., 0.,0.,0.], initialCoordinates = [0.,0.,0., 0.,0.,0.], initialVelocities = [0.,0.,0., 0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'RigidBodyRotVecLG'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RigidRotVecLG = NodeRigidBodyRotVecLG
+VRigidRotVecLG = VNodeRigidBodyRotVecLG
+
+class VNodeRigidBody2D:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeRigidBody2D:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.], initialCoordinates = [0.,0.,0.], initialVelocities = [0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'RigidBody2D'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Rigid2D = NodeRigidBody2D
+VRigid2D = VNodeRigidBody2D
+
+class VNode1D:
+    def __init__(self, show = False):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class Node1D:
+    def __init__(self, name = '', referenceCoordinates = [0.], initialCoordinates = [0.], initialVelocities = [0.], visualization = {'show': False}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', '1D'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodePoint2DSlope1:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePoint2DSlope1:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,1.,0.], initialCoordinates = [0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'Point2DSlope1'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Point2DS1 = NodePoint2DSlope1
+VPoint2DS1 = VNodePoint2DSlope1
+
+class VNodePointSlope1:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePointSlope1:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.,1.,0.,0.], initialCoordinates = [0.,0.,0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'PointSlope1'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodePointSlope12:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePointSlope12:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.,1.,0.,0.,1.,0.,0.], initialCoordinates = [0.,0.,0.,0.,0.,0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.,0.,0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'PointSlope12'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodePointSlope23:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePointSlope23:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.,1.,0.,0.,1.,0.,0.], initialCoordinates = [0.,0.,0.,0.,0.,0.,0.,0.,0.], initialVelocities = [0.,0.,0.,0.,0.,0.,0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialVelocities = np.array(initialVelocities)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'PointSlope23'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialVelocities', self.initialVelocities
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodeGenericODE2:
+    def __init__(self, show = False):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeGenericODE2:
+    def __init__(self, name = '', referenceCoordinates = [], initialCoordinates = [], initialCoordinates_t = [], numberOfODE2Coordinates = 0, visualization = {'show': False}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.initialCoordinates_t = np.array(initialCoordinates_t)
+        self.numberOfODE2Coordinates = CheckForValidPInt(numberOfODE2Coordinates,"numberOfODE2Coordinates","NodeGenericODE2")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'GenericODE2'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'initialCoordinates_t', self.initialCoordinates_t
+        yield 'numberOfODE2Coordinates', self.numberOfODE2Coordinates
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodeGenericODE1:
+    def __init__(self, show = False):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeGenericODE1:
+    def __init__(self, name = '', referenceCoordinates = [], initialCoordinates = [], numberOfODE1Coordinates = 0, visualization = {'show': False}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.numberOfODE1Coordinates = CheckForValidPInt(numberOfODE1Coordinates,"numberOfODE1Coordinates","NodeGenericODE1")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'GenericODE1'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'numberOfODE1Coordinates', self.numberOfODE1Coordinates
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodeGenericAE:
+    def __init__(self, show = False):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeGenericAE:
+    def __init__(self, name = '', referenceCoordinates = [], initialCoordinates = [], numberOfAECoordinates = 0, visualization = {'show': False}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.numberOfAECoordinates = CheckForValidPInt(numberOfAECoordinates,"numberOfAECoordinates","NodeGenericAE")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'GenericAE'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'numberOfAECoordinates', self.numberOfAECoordinates
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodeGenericData:
+    def __init__(self, show = False):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class NodeGenericData:
+    def __init__(self, name = '', initialCoordinates = [], numberOfDataCoordinates = 0, visualization = {'show': False}):
+        self.name = name
+        self.initialCoordinates = np.array(initialCoordinates)
+        self.numberOfDataCoordinates = CheckForValidUInt(numberOfDataCoordinates,"numberOfDataCoordinates","NodeGenericData")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'GenericData'
+        yield 'name', self.name
+        yield 'initialCoordinates', self.initialCoordinates
+        yield 'numberOfDataCoordinates', self.numberOfDataCoordinates
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VNodePointGround:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class NodePointGround:
+    def __init__(self, name = '', referenceCoordinates = [0.,0.,0.], visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.referenceCoordinates = np.array(referenceCoordinates)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'nodeType', 'PointGround'
+        yield 'name', self.name
+        yield 'referenceCoordinates', self.referenceCoordinates
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+PointGround = NodePointGround
+VPointGround = VNodePointGround
+
+#+++++++++++++++++++++++++++++++
+#OBJECT
+class VObjectGround:
+    def __init__(self, show = True, graphicsDataUserFunction = 0, graphicsData = []):
+        self.show = show
+        self.graphicsDataUserFunction = graphicsDataUserFunction
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectGround:
+    def __init__(self, name = '', referencePosition = [0.,0.,0.], referenceRotation = IIDiagMatrix(rowsColumns=3,value=1), visualization = {'show': True, 'graphicsDataUserFunction': 0, 'graphicsData': []}):
+        self.name = name
+        self.referencePosition = np.array(referencePosition)
+        self.referenceRotation = np.array(referenceRotation)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'Ground'
+        yield 'name', self.name
+        yield 'referencePosition', self.referencePosition
+        yield 'referenceRotation', self.referenceRotation
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectMassPoint:
+    def __init__(self, show = True, graphicsData = []):
+        self.show = show
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectMassPoint:
+    def __init__(self, name = '', physicsMass = 0., nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsData': []}):
+        self.name = name
+        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectMassPoint")
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'MassPoint'
+        yield 'name', self.name
+        yield 'physicsMass', self.physicsMass
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+MassPoint = ObjectMassPoint
+VMassPoint = VObjectMassPoint
+
+class VObjectMassPoint2D:
+    def __init__(self, show = True, graphicsData = []):
+        self.show = show
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectMassPoint2D:
+    def __init__(self, name = '', physicsMass = 0., nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsData': []}):
+        self.name = name
+        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectMassPoint2D")
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'MassPoint2D'
+        yield 'name', self.name
+        yield 'physicsMass', self.physicsMass
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+MassPoint2D = ObjectMassPoint2D
+VMassPoint2D = VObjectMassPoint2D
+
+class VObjectMass1D:
+    def __init__(self, show = True, graphicsData = []):
+        self.show = show
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectMass1D:
+    def __init__(self, name = '', physicsMass = 0., nodeNumber = exudyn.InvalidIndex(), referencePosition = [0.,0.,0.], referenceRotation = IIDiagMatrix(rowsColumns=3,value=1), visualization = {'show': True, 'graphicsData': []}):
+        self.name = name
+        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectMass1D")
+        self.nodeNumber = nodeNumber
+        self.referencePosition = np.array(referencePosition)
+        self.referenceRotation = np.array(referenceRotation)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'Mass1D'
+        yield 'name', self.name
+        yield 'physicsMass', self.physicsMass
+        yield 'nodeNumber', self.nodeNumber
+        yield 'referencePosition', self.referencePosition
+        yield 'referenceRotation', self.referenceRotation
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Mass1D = ObjectMass1D
+VMass1D = VObjectMass1D
+
+class VObjectRotationalMass1D:
+    def __init__(self, show = True, graphicsData = []):
+        self.show = show
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectRotationalMass1D:
+    def __init__(self, name = '', physicsInertia = 0., nodeNumber = exudyn.InvalidIndex(), referencePosition = [0.,0.,0.], referenceRotation = IIDiagMatrix(rowsColumns=3,value=1), visualization = {'show': True, 'graphicsData': []}):
+        self.name = name
+        self.physicsInertia = CheckForValidUReal(physicsInertia,"physicsInertia","ObjectRotationalMass1D")
+        self.nodeNumber = nodeNumber
+        self.referencePosition = np.array(referencePosition)
+        self.referenceRotation = np.array(referenceRotation)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'RotationalMass1D'
+        yield 'name', self.name
+        yield 'physicsInertia', self.physicsInertia
+        yield 'nodeNumber', self.nodeNumber
+        yield 'referencePosition', self.referencePosition
+        yield 'referenceRotation', self.referenceRotation
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Rotor1D = ObjectRotationalMass1D
+VRotor1D = VObjectRotationalMass1D
+
+class VObjectRigidBody:
+    def __init__(self, show = True, graphicsDataUserFunction = 0, graphicsData = []):
+        self.show = show
+        self.graphicsDataUserFunction = graphicsDataUserFunction
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectRigidBody:
+    def __init__(self, name = '', physicsMass = 0., physicsInertia = [0.,0.,0., 0.,0.,0.], physicsCenterOfMass = [0.,0.,0.], nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsDataUserFunction': 0, 'graphicsData': []}):
+        self.name = name
+        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectRigidBody")
+        self.physicsInertia = np.array(physicsInertia)
+        self.physicsCenterOfMass = np.array(physicsCenterOfMass)
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'RigidBody'
+        yield 'name', self.name
+        yield 'physicsMass', self.physicsMass
+        yield 'physicsInertia', self.physicsInertia
+        yield 'physicsCenterOfMass', self.physicsCenterOfMass
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RigidBody = ObjectRigidBody
+VRigidBody = VObjectRigidBody
+
+class VObjectRigidBody2D:
+    def __init__(self, show = True, graphicsDataUserFunction = 0, graphicsData = []):
+        self.show = show
+        self.graphicsDataUserFunction = graphicsDataUserFunction
+        self.graphicsData = copy.copy(graphicsData)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
+        yield 'graphicsData', self.graphicsData
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectRigidBody2D:
+    def __init__(self, name = '', physicsMass = 0., physicsInertia = 0., nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True, 'graphicsDataUserFunction': 0, 'graphicsData': []}):
+        self.name = name
+        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectRigidBody2D")
+        self.physicsInertia = CheckForValidUReal(physicsInertia,"physicsInertia","ObjectRigidBody2D")
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'RigidBody2D'
+        yield 'name', self.name
+        yield 'physicsMass', self.physicsMass
+        yield 'physicsInertia', self.physicsInertia
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
+        yield 'VgraphicsData', dict(self.visualization)["graphicsData"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RigidBody2D = ObjectRigidBody2D
+VRigidBody2D = VObjectRigidBody2D
+
+class VObjectGenericODE2:
+    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.], triangleMesh = [], showNodes = False, graphicsDataUserFunction = 0):
+        self.show = show
+        self.color = np.array(color)
+        self.triangleMesh = np.array(triangleMesh)
+        self.showNodes = showNodes
+        self.graphicsDataUserFunction = graphicsDataUserFunction
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'color', self.color
+        yield 'triangleMesh', self.triangleMesh
+        yield 'showNodes', self.showNodes
+        yield 'graphicsDataUserFunction', self.graphicsDataUserFunction
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectGenericODE2:
+    def __init__(self, name = '', nodeNumbers = [], massMatrix = None, stiffnessMatrix = None, dampingMatrix = None, forceVector = [], forceUserFunction = 0, massMatrixUserFunction = 0, jacobianUserFunction = 0, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.], 'triangleMesh': [], 'showNodes': False, 'graphicsDataUserFunction': 0}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.massMatrix = massMatrix
+        self.stiffnessMatrix = stiffnessMatrix
+        self.dampingMatrix = dampingMatrix
+        self.forceVector = np.array(forceVector)
+        self.forceUserFunction = forceUserFunction
+        self.massMatrixUserFunction = massMatrixUserFunction
+        self.jacobianUserFunction = jacobianUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'GenericODE2'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'massMatrix', self.massMatrix
+        yield 'stiffnessMatrix', self.stiffnessMatrix
+        yield 'dampingMatrix', self.dampingMatrix
+        yield 'forceVector', self.forceVector
+        yield 'forceUserFunction', self.forceUserFunction
+        yield 'massMatrixUserFunction', self.massMatrixUserFunction
+        yield 'jacobianUserFunction', self.jacobianUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+        yield 'VtriangleMesh', dict(self.visualization)["triangleMesh"]
+        yield 'VshowNodes', dict(self.visualization)["showNodes"]
+        yield 'VgraphicsDataUserFunction', dict(self.visualization)["graphicsDataUserFunction"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectGenericODE1:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectGenericODE1:
+    def __init__(self, name = '', nodeNumbers = [], systemMatrix = [], rhsVector = [], rhsUserFunction = 0, visualization = {'show': True}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.systemMatrix = np.array(systemMatrix)
+        self.rhsVector = np.array(rhsVector)
+        self.rhsUserFunction = rhsUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'GenericODE1'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'systemMatrix', self.systemMatrix
+        yield 'rhsVector', self.rhsVector
+        yield 'rhsUserFunction', self.rhsUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectKinematicTree:
+    def __init__(self, show = True, showLinks = True, showJoints = True, color = [-1.,-1.,-1.,-1.], graphicsDataList = []):
+        self.show = show
+        self.showLinks = showLinks
+        self.showJoints = showJoints
+        self.color = np.array(color)
+        self.graphicsDataList = copy.copy(graphicsDataList)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'showLinks', self.showLinks
+        yield 'showJoints', self.showJoints
+        yield 'color', self.color
+        yield 'graphicsDataList', self.graphicsDataList
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectKinematicTree:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), gravity = [0.,0.,0.], baseOffset = [0.,0.,0.], jointTypes = [], linkParents = [], jointTransformations = None, jointOffsets = None, linkInertiasCOM = None, linkCOMs = None, linkMasses = [], linkForces = None, linkTorques = None, jointForceVector = [], jointPositionOffsetVector = [], jointVelocityOffsetVector = [], jointPControlVector = [], jointDControlVector = [], forceUserFunction = 0, visualization = {'show': True, 'showLinks': True, 'showJoints': True, 'color': [-1.,-1.,-1.,-1.], 'graphicsDataList': []}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.gravity = np.array(gravity)
+        self.baseOffset = np.array(baseOffset)
+        self.jointTypes = copy.copy(jointTypes)
+        self.linkParents = copy.copy(linkParents)
+        self.jointTransformations = jointTransformations
+        self.jointOffsets = jointOffsets
+        self.linkInertiasCOM = linkInertiasCOM
+        self.linkCOMs = linkCOMs
+        self.linkMasses = np.array(linkMasses)
+        self.linkForces = linkForces
+        self.linkTorques = linkTorques
+        self.jointForceVector = np.array(jointForceVector)
+        self.jointPositionOffsetVector = np.array(jointPositionOffsetVector)
+        self.jointVelocityOffsetVector = np.array(jointVelocityOffsetVector)
+        self.jointPControlVector = np.array(jointPControlVector)
+        self.jointDControlVector = np.array(jointDControlVector)
+        self.forceUserFunction = forceUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'KinematicTree'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'gravity', self.gravity
+        yield 'baseOffset', self.baseOffset
+        yield 'jointTypes', self.jointTypes
+        yield 'linkParents', self.linkParents
+        yield 'jointTransformations', self.jointTransformations
+        yield 'jointOffsets', self.jointOffsets
+        yield 'linkInertiasCOM', self.linkInertiasCOM
+        yield 'linkCOMs', self.linkCOMs
+        yield 'linkMasses', self.linkMasses
+        yield 'linkForces', self.linkForces
+        yield 'linkTorques', self.linkTorques
+        yield 'jointForceVector', self.jointForceVector
+        yield 'jointPositionOffsetVector', self.jointPositionOffsetVector
+        yield 'jointVelocityOffsetVector', self.jointVelocityOffsetVector
+        yield 'jointPControlVector', self.jointPControlVector
+        yield 'jointDControlVector', self.jointDControlVector
+        yield 'forceUserFunction', self.forceUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VshowLinks', dict(self.visualization)["showLinks"]
+        yield 'VshowJoints', dict(self.visualization)["showJoints"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+        yield 'VgraphicsDataList', dict(self.visualization)["graphicsDataList"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+KinematicTree = ObjectKinematicTree
+VKinematicTree = VObjectKinematicTree
+
+class VObjectFFRF:
+    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.], triangleMesh = [], showNodes = False):
+        self.show = show
+        self.color = np.array(color)
+        self.triangleMesh = np.array(triangleMesh)
+        self.showNodes = showNodes
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'color', self.color
+        yield 'triangleMesh', self.triangleMesh
+        yield 'showNodes', self.showNodes
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectFFRF:
+    def __init__(self, name = '', nodeNumbers = [], massMatrixFF = None, stiffnessMatrixFF = None, dampingMatrixFF = None, forceVector = [], forceUserFunction = 0, massMatrixUserFunction = 0, computeFFRFterms = True, objectIsInitialized = False, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.], 'triangleMesh': [], 'showNodes': False}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.massMatrixFF = massMatrixFF
+        self.stiffnessMatrixFF = stiffnessMatrixFF
+        self.dampingMatrixFF = dampingMatrixFF
+        self.forceVector = np.array(forceVector)
+        self.forceUserFunction = forceUserFunction
+        self.massMatrixUserFunction = massMatrixUserFunction
+        self.computeFFRFterms = computeFFRFterms
+        self.objectIsInitialized = objectIsInitialized
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'FFRF'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'massMatrixFF', self.massMatrixFF
+        yield 'stiffnessMatrixFF', self.stiffnessMatrixFF
+        yield 'dampingMatrixFF', self.dampingMatrixFF
+        yield 'forceVector', self.forceVector
+        yield 'forceUserFunction', self.forceUserFunction
+        yield 'massMatrixUserFunction', self.massMatrixUserFunction
+        yield 'computeFFRFterms', self.computeFFRFterms
+        yield 'objectIsInitialized', self.objectIsInitialized
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+        yield 'VtriangleMesh', dict(self.visualization)["triangleMesh"]
+        yield 'VshowNodes', dict(self.visualization)["showNodes"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectFFRFreducedOrder:
+    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.], triangleMesh = [], showNodes = False):
+        self.show = show
+        self.color = np.array(color)
+        self.triangleMesh = np.array(triangleMesh)
+        self.showNodes = showNodes
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'color', self.color
+        yield 'triangleMesh', self.triangleMesh
+        yield 'showNodes', self.showNodes
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectFFRFreducedOrder:
+    def __init__(self, name = '', nodeNumbers = [], massMatrixReduced = None, stiffnessMatrixReduced = None, dampingMatrixReduced = None, forceUserFunction = 0, massMatrixUserFunction = 0, computeFFRFterms = True, modeBasis = [], outputVariableModeBasis = [], outputVariableTypeModeBasis = 0, referencePositions = [], objectIsInitialized = False, physicsMass = 0., physicsInertia = IIDiagMatrix(rowsColumns=3,value=1), physicsCenterOfMass = [0.,0.,0.], mPsiTildePsi = [], mPsiTildePsiTilde = [], mPhitTPsi = [], mPhitTPsiTilde = [], mXRefTildePsi = [], mXRefTildePsiTilde = [], physicsCenterOfMassTilde = IIDiagMatrix(rowsColumns=3,value=0), visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.], 'triangleMesh': [], 'showNodes': False}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.massMatrixReduced = massMatrixReduced
+        self.stiffnessMatrixReduced = stiffnessMatrixReduced
+        self.dampingMatrixReduced = dampingMatrixReduced
+        self.forceUserFunction = forceUserFunction
+        self.massMatrixUserFunction = massMatrixUserFunction
+        self.computeFFRFterms = computeFFRFterms
+        self.modeBasis = np.array(modeBasis)
+        self.outputVariableModeBasis = np.array(outputVariableModeBasis)
+        self.outputVariableTypeModeBasis = outputVariableTypeModeBasis
+        self.referencePositions = np.array(referencePositions)
+        self.objectIsInitialized = objectIsInitialized
+        self.physicsMass = CheckForValidUReal(physicsMass,"physicsMass","ObjectFFRFreducedOrder")
+        self.physicsInertia = np.array(physicsInertia)
+        self.physicsCenterOfMass = np.array(physicsCenterOfMass)
+        self.mPsiTildePsi = np.array(mPsiTildePsi)
+        self.mPsiTildePsiTilde = np.array(mPsiTildePsiTilde)
+        self.mPhitTPsi = np.array(mPhitTPsi)
+        self.mPhitTPsiTilde = np.array(mPhitTPsiTilde)
+        self.mXRefTildePsi = np.array(mXRefTildePsi)
+        self.mXRefTildePsiTilde = np.array(mXRefTildePsiTilde)
+        self.physicsCenterOfMassTilde = np.array(physicsCenterOfMassTilde)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'FFRFreducedOrder'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'massMatrixReduced', self.massMatrixReduced
+        yield 'stiffnessMatrixReduced', self.stiffnessMatrixReduced
+        yield 'dampingMatrixReduced', self.dampingMatrixReduced
+        yield 'forceUserFunction', self.forceUserFunction
+        yield 'massMatrixUserFunction', self.massMatrixUserFunction
+        yield 'computeFFRFterms', self.computeFFRFterms
+        yield 'modeBasis', self.modeBasis
+        yield 'outputVariableModeBasis', self.outputVariableModeBasis
+        yield 'outputVariableTypeModeBasis', self.outputVariableTypeModeBasis
+        yield 'referencePositions', self.referencePositions
+        yield 'objectIsInitialized', self.objectIsInitialized
+        yield 'physicsMass', self.physicsMass
+        yield 'physicsInertia', self.physicsInertia
+        yield 'physicsCenterOfMass', self.physicsCenterOfMass
+        yield 'mPsiTildePsi', self.mPsiTildePsi
+        yield 'mPsiTildePsiTilde', self.mPsiTildePsiTilde
+        yield 'mPhitTPsi', self.mPhitTPsi
+        yield 'mPhitTPsiTilde', self.mPhitTPsiTilde
+        yield 'mXRefTildePsi', self.mXRefTildePsi
+        yield 'mXRefTildePsiTilde', self.mXRefTildePsiTilde
+        yield 'physicsCenterOfMassTilde', self.physicsCenterOfMassTilde
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+        yield 'VtriangleMesh', dict(self.visualization)["triangleMesh"]
+        yield 'VshowNodes', dict(self.visualization)["showNodes"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+CMSobject = ObjectFFRFreducedOrder
+VCMSobject = VObjectFFRFreducedOrder
+
+class VObjectANCFCable:
+    def __init__(self, show = True, radius = 0., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.radius = radius
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'radius', self.radius
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectANCFCable:
+    def __init__(self, name = '', physicsLength = 0., physicsMassPerLength = 0., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsReferenceAxialStrain = 0., strainIsRelativeToReference = 0., nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, visualization = {'show': True, 'radius': 0., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectANCFCable")
+        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectANCFCable")
+        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectANCFCable")
+        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectANCFCable")
+        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectANCFCable")
+        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectANCFCable")
+        self.physicsReferenceAxialStrain = physicsReferenceAxialStrain
+        self.strainIsRelativeToReference = strainIsRelativeToReference
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.useReducedOrderIntegration = useReducedOrderIntegration
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ANCFCable'
+        yield 'name', self.name
+        yield 'physicsLength', self.physicsLength
+        yield 'physicsMassPerLength', self.physicsMassPerLength
+        yield 'physicsBendingStiffness', self.physicsBendingStiffness
+        yield 'physicsAxialStiffness', self.physicsAxialStiffness
+        yield 'physicsBendingDamping', self.physicsBendingDamping
+        yield 'physicsAxialDamping', self.physicsAxialDamping
+        yield 'physicsReferenceAxialStrain', self.physicsReferenceAxialStrain
+        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vradius', dict(self.visualization)["radius"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Cable = ObjectANCFCable
+VCable = VObjectANCFCable
+
+class VObjectANCFCable2D:
+    def __init__(self, show = True, drawHeight = 0., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawHeight = drawHeight
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawHeight', self.drawHeight
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectANCFCable2D:
+    def __init__(self, name = '', physicsLength = 0., physicsMassPerLength = 0., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsReferenceAxialStrain = 0., physicsReferenceCurvature = 0., strainIsRelativeToReference = 0., nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, axialForceUserFunction = 0, bendingMomentUserFunction = 0, visualization = {'show': True, 'drawHeight': 0., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectANCFCable2D")
+        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectANCFCable2D")
+        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectANCFCable2D")
+        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectANCFCable2D")
+        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectANCFCable2D")
+        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectANCFCable2D")
+        self.physicsReferenceAxialStrain = physicsReferenceAxialStrain
+        self.physicsReferenceCurvature = physicsReferenceCurvature
+        self.strainIsRelativeToReference = strainIsRelativeToReference
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.useReducedOrderIntegration = useReducedOrderIntegration
+        self.axialForceUserFunction = axialForceUserFunction
+        self.bendingMomentUserFunction = bendingMomentUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ANCFCable2D'
+        yield 'name', self.name
+        yield 'physicsLength', self.physicsLength
+        yield 'physicsMassPerLength', self.physicsMassPerLength
+        yield 'physicsBendingStiffness', self.physicsBendingStiffness
+        yield 'physicsAxialStiffness', self.physicsAxialStiffness
+        yield 'physicsBendingDamping', self.physicsBendingDamping
+        yield 'physicsAxialDamping', self.physicsAxialDamping
+        yield 'physicsReferenceAxialStrain', self.physicsReferenceAxialStrain
+        yield 'physicsReferenceCurvature', self.physicsReferenceCurvature
+        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
+        yield 'axialForceUserFunction', self.axialForceUserFunction
+        yield 'bendingMomentUserFunction', self.bendingMomentUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawHeight', dict(self.visualization)["drawHeight"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Cable2D = ObjectANCFCable2D
+VCable2D = VObjectANCFCable2D
+
+class VObjectALEANCFCable2D:
+    def __init__(self, show = True, drawHeight = 0., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawHeight = drawHeight
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawHeight', self.drawHeight
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectALEANCFCable2D:
+    def __init__(self, name = '', physicsLength = 0., physicsMassPerLength = 0., physicsMovingMassFactor = 1., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsReferenceAxialStrain = 0., physicsReferenceCurvature = 0., physicsUseCouplingTerms = True, physicsAddALEvariation = True, nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, strainIsRelativeToReference = 0., visualization = {'show': True, 'drawHeight': 0., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectALEANCFCable2D")
+        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectALEANCFCable2D")
+        self.physicsMovingMassFactor = CheckForValidUReal(physicsMovingMassFactor,"physicsMovingMassFactor","ObjectALEANCFCable2D")
+        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectALEANCFCable2D")
+        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectALEANCFCable2D")
+        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectALEANCFCable2D")
+        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectALEANCFCable2D")
+        self.physicsReferenceAxialStrain = physicsReferenceAxialStrain
+        self.physicsReferenceCurvature = physicsReferenceCurvature
+        self.physicsUseCouplingTerms = physicsUseCouplingTerms
+        self.physicsAddALEvariation = physicsAddALEvariation
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.useReducedOrderIntegration = useReducedOrderIntegration
+        self.strainIsRelativeToReference = strainIsRelativeToReference
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ALEANCFCable2D'
+        yield 'name', self.name
+        yield 'physicsLength', self.physicsLength
+        yield 'physicsMassPerLength', self.physicsMassPerLength
+        yield 'physicsMovingMassFactor', self.physicsMovingMassFactor
+        yield 'physicsBendingStiffness', self.physicsBendingStiffness
+        yield 'physicsAxialStiffness', self.physicsAxialStiffness
+        yield 'physicsBendingDamping', self.physicsBendingDamping
+        yield 'physicsAxialDamping', self.physicsAxialDamping
+        yield 'physicsReferenceAxialStrain', self.physicsReferenceAxialStrain
+        yield 'physicsReferenceCurvature', self.physicsReferenceCurvature
+        yield 'physicsUseCouplingTerms', self.physicsUseCouplingTerms
+        yield 'physicsAddALEvariation', self.physicsAddALEvariation
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
+        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawHeight', dict(self.visualization)["drawHeight"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+ALECable2D = ObjectALEANCFCable2D
+VALECable2D = VObjectALEANCFCable2D
+
+class VObjectANCFBeam:
+    def __init__(self, show = True, sectionGeometry = exudyn.BeamSectionGeometry(), color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.sectionGeometry = sectionGeometry
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'sectionGeometry', self.sectionGeometry
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectANCFBeam:
+    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., sectionData = exudyn.BeamSection(), crossSectionPenaltyFactor = [1.,1.,1.], visualization = {'show': True, 'sectionGeometry': exudyn.BeamSectionGeometry(), 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.physicsLength = CheckForValidPReal(physicsLength,"physicsLength","ObjectANCFBeam")
+        self.sectionData = sectionData
+        self.crossSectionPenaltyFactor = np.array(crossSectionPenaltyFactor)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ANCFBeam'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'physicsLength', self.physicsLength
+        yield 'sectionData', self.sectionData
+        yield 'crossSectionPenaltyFactor', self.crossSectionPenaltyFactor
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VsectionGeometry', dict(self.visualization)["sectionGeometry"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+ANCFBeam = ObjectANCFBeam
+VANCFBeam = VObjectANCFBeam
+
+class VObjectBeamGeometricallyExact2D:
+    def __init__(self, show = True, drawHeight = 0., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawHeight = drawHeight
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawHeight', self.drawHeight
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectBeamGeometricallyExact2D:
+    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., physicsMassPerLength = 0., physicsCrossSectionInertia = 0., physicsBendingStiffness = 0., physicsAxialStiffness = 0., physicsShearStiffness = 0., physicsBendingDamping = 0., physicsAxialDamping = 0., physicsShearDamping = 0., physicsReferenceCurvature = 0., includeReferenceRotations = False, visualization = {'show': True, 'drawHeight': 0., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.physicsLength = CheckForValidUReal(physicsLength,"physicsLength","ObjectBeamGeometricallyExact2D")
+        self.physicsMassPerLength = CheckForValidUReal(physicsMassPerLength,"physicsMassPerLength","ObjectBeamGeometricallyExact2D")
+        self.physicsCrossSectionInertia = CheckForValidUReal(physicsCrossSectionInertia,"physicsCrossSectionInertia","ObjectBeamGeometricallyExact2D")
+        self.physicsBendingStiffness = CheckForValidUReal(physicsBendingStiffness,"physicsBendingStiffness","ObjectBeamGeometricallyExact2D")
+        self.physicsAxialStiffness = CheckForValidUReal(physicsAxialStiffness,"physicsAxialStiffness","ObjectBeamGeometricallyExact2D")
+        self.physicsShearStiffness = CheckForValidUReal(physicsShearStiffness,"physicsShearStiffness","ObjectBeamGeometricallyExact2D")
+        self.physicsBendingDamping = CheckForValidUReal(physicsBendingDamping,"physicsBendingDamping","ObjectBeamGeometricallyExact2D")
+        self.physicsAxialDamping = CheckForValidUReal(physicsAxialDamping,"physicsAxialDamping","ObjectBeamGeometricallyExact2D")
+        self.physicsShearDamping = CheckForValidUReal(physicsShearDamping,"physicsShearDamping","ObjectBeamGeometricallyExact2D")
+        self.physicsReferenceCurvature = physicsReferenceCurvature
+        self.includeReferenceRotations = includeReferenceRotations
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'BeamGeometricallyExact2D'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'physicsLength', self.physicsLength
+        yield 'physicsMassPerLength', self.physicsMassPerLength
+        yield 'physicsCrossSectionInertia', self.physicsCrossSectionInertia
+        yield 'physicsBendingStiffness', self.physicsBendingStiffness
+        yield 'physicsAxialStiffness', self.physicsAxialStiffness
+        yield 'physicsShearStiffness', self.physicsShearStiffness
+        yield 'physicsBendingDamping', self.physicsBendingDamping
+        yield 'physicsAxialDamping', self.physicsAxialDamping
+        yield 'physicsShearDamping', self.physicsShearDamping
+        yield 'physicsReferenceCurvature', self.physicsReferenceCurvature
+        yield 'includeReferenceRotations', self.includeReferenceRotations
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawHeight', dict(self.visualization)["drawHeight"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Beam2D = ObjectBeamGeometricallyExact2D
+VBeam2D = VObjectBeamGeometricallyExact2D
+
+class VObjectBeamGeometricallyExact:
+    def __init__(self, show = True, sectionGeometry = exudyn.BeamSectionGeometry(), color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.sectionGeometry = sectionGeometry
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'sectionGeometry', self.sectionGeometry
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectBeamGeometricallyExact:
+    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., sectionData = exudyn.BeamSection(), visualization = {'show': True, 'sectionGeometry': exudyn.BeamSectionGeometry(), 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.physicsLength = CheckForValidPReal(physicsLength,"physicsLength","ObjectBeamGeometricallyExact")
+        self.sectionData = sectionData
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'BeamGeometricallyExact'
+        yield 'name', self.name
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'physicsLength', self.physicsLength
+        yield 'sectionData', self.sectionData
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VsectionGeometry', dict(self.visualization)["sectionGeometry"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Beam3D = ObjectBeamGeometricallyExact
+VBeam3D = VObjectBeamGeometricallyExact
+
+class VObjectANCFThinPlate:
+    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectANCFThinPlate:
+    def __init__(self, name = '', physicsThickness = 0., physicsDensity = 0., physicsStrainCoefficients = IIDiagMatrix(rowsColumns=3,value=1), physicsCurvatureCoefficients = IIDiagMatrix(rowsColumns=3,value=1), strainIsRelativeToReference = 1., nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex(), exudyn.InvalidIndex(), exudyn.InvalidIndex()], useReducedOrderIntegration = 0, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.physicsThickness = CheckForValidUReal(physicsThickness,"physicsThickness","ObjectANCFThinPlate")
+        self.physicsDensity = CheckForValidUReal(physicsDensity,"physicsDensity","ObjectANCFThinPlate")
+        self.physicsStrainCoefficients = np.array(physicsStrainCoefficients)
+        self.physicsCurvatureCoefficients = np.array(physicsCurvatureCoefficients)
+        self.strainIsRelativeToReference = strainIsRelativeToReference
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.useReducedOrderIntegration = useReducedOrderIntegration
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ANCFThinPlate'
+        yield 'name', self.name
+        yield 'physicsThickness', self.physicsThickness
+        yield 'physicsDensity', self.physicsDensity
+        yield 'physicsStrainCoefficients', self.physicsStrainCoefficients
+        yield 'physicsCurvatureCoefficients', self.physicsCurvatureCoefficients
+        yield 'strainIsRelativeToReference', self.strainIsRelativeToReference
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'useReducedOrderIntegration', self.useReducedOrderIntegration
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectConnectorSpringDamper:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorSpringDamper:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], referenceLength = 0., stiffness = 0., damping = 0., force = 0., velocityOffset = 0., activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.referenceLength = CheckForValidUReal(referenceLength,"referenceLength","ObjectConnectorSpringDamper")
+        self.stiffness = CheckForValidUReal(stiffness,"stiffness","ObjectConnectorSpringDamper")
+        self.damping = CheckForValidUReal(damping,"damping","ObjectConnectorSpringDamper")
+        self.force = force
+        self.velocityOffset = velocityOffset
+        self.activeConnector = activeConnector
+        self.springForceUserFunction = springForceUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorSpringDamper'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'referenceLength', self.referenceLength
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'force', self.force
+        yield 'velocityOffset', self.velocityOffset
+        yield 'activeConnector', self.activeConnector
+        yield 'springForceUserFunction', self.springForceUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+SpringDamper = ObjectConnectorSpringDamper
+VSpringDamper = VObjectConnectorSpringDamper
+
+class VObjectConnectorCartesianSpringDamper:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorCartesianSpringDamper:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], stiffness = [0.,0.,0.], damping = [0.,0.,0.], offset = [0.,0.,0.], springForceUserFunction = 0, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.stiffness = np.array(stiffness)
+        self.damping = np.array(damping)
+        self.offset = np.array(offset)
+        self.springForceUserFunction = springForceUserFunction
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorCartesianSpringDamper'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'offset', self.offset
+        yield 'springForceUserFunction', self.springForceUserFunction
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+CartesianSpringDamper = ObjectConnectorCartesianSpringDamper
+VCartesianSpringDamper = VObjectConnectorCartesianSpringDamper
+
+class VObjectConnectorRigidBodySpringDamper:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorRigidBodySpringDamper:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), stiffness = IIDiagMatrix(rowsColumns=6,value=0.), damping = IIDiagMatrix(rowsColumns=6,value=0.), rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), offset = [0.,0.,0.,0.,0.,0.], intrinsicFormulation = False, activeConnector = True, springForceTorqueUserFunction = 0, postNewtonStepUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.stiffness = np.array(stiffness)
+        self.damping = np.array(damping)
+        self.rotationMarker0 = np.array(rotationMarker0)
+        self.rotationMarker1 = np.array(rotationMarker1)
+        self.offset = np.array(offset)
+        self.intrinsicFormulation = intrinsicFormulation
+        self.activeConnector = activeConnector
+        self.springForceTorqueUserFunction = springForceTorqueUserFunction
+        self.postNewtonStepUserFunction = postNewtonStepUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorRigidBodySpringDamper'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'rotationMarker0', self.rotationMarker0
+        yield 'rotationMarker1', self.rotationMarker1
+        yield 'offset', self.offset
+        yield 'intrinsicFormulation', self.intrinsicFormulation
+        yield 'activeConnector', self.activeConnector
+        yield 'springForceTorqueUserFunction', self.springForceTorqueUserFunction
+        yield 'postNewtonStepUserFunction', self.postNewtonStepUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RigidBodySpringDamper = ObjectConnectorRigidBodySpringDamper
+VRigidBodySpringDamper = VObjectConnectorRigidBodySpringDamper
+
+class VObjectConnectorLinearSpringDamper:
+    def __init__(self, show = True, drawSize = -1., drawAsCylinder = False, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.drawAsCylinder = drawAsCylinder
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'drawAsCylinder', self.drawAsCylinder
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorLinearSpringDamper:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], stiffness = 0., damping = 0., axisMarker0 = [1,0,0], offset = 0., velocityOffset = 0., force = 0., activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'drawAsCylinder': False, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.stiffness = stiffness
+        self.damping = damping
+        self.axisMarker0 = np.array(axisMarker0)
+        self.offset = offset
+        self.velocityOffset = velocityOffset
+        self.force = force
+        self.activeConnector = activeConnector
+        self.springForceUserFunction = springForceUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorLinearSpringDamper'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'axisMarker0', self.axisMarker0
+        yield 'offset', self.offset
+        yield 'velocityOffset', self.velocityOffset
+        yield 'force', self.force
+        yield 'activeConnector', self.activeConnector
+        yield 'springForceUserFunction', self.springForceUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'VdrawAsCylinder', dict(self.visualization)["drawAsCylinder"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+LinearSpringDamper = ObjectConnectorLinearSpringDamper
+VLinearSpringDamper = VObjectConnectorLinearSpringDamper
+
+class VObjectConnectorTorsionalSpringDamper:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorTorsionalSpringDamper:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), stiffness = 0., damping = 0., rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), offset = 0., velocityOffset = 0., torque = 0., activeConnector = True, springTorqueUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.stiffness = stiffness
+        self.damping = damping
+        self.rotationMarker0 = np.array(rotationMarker0)
+        self.rotationMarker1 = np.array(rotationMarker1)
+        self.offset = offset
+        self.velocityOffset = velocityOffset
+        self.torque = torque
+        self.activeConnector = activeConnector
+        self.springTorqueUserFunction = springTorqueUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorTorsionalSpringDamper'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'rotationMarker0', self.rotationMarker0
+        yield 'rotationMarker1', self.rotationMarker1
+        yield 'offset', self.offset
+        yield 'velocityOffset', self.velocityOffset
+        yield 'torque', self.torque
+        yield 'activeConnector', self.activeConnector
+        yield 'springTorqueUserFunction', self.springTorqueUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+TorsionalSpringDamper = ObjectConnectorTorsionalSpringDamper
+VTorsionalSpringDamper = VObjectConnectorTorsionalSpringDamper
+
+class VObjectConnectorCoordinateSpringDamper:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorCoordinateSpringDamper:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], stiffness = 0., damping = 0., offset = 0., activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.stiffness = stiffness
+        self.damping = damping
+        self.offset = offset
+        self.activeConnector = activeConnector
+        self.springForceUserFunction = springForceUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorCoordinateSpringDamper'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'offset', self.offset
+        yield 'activeConnector', self.activeConnector
+        yield 'springForceUserFunction', self.springForceUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+CoordinateSpringDamper = ObjectConnectorCoordinateSpringDamper
+VCoordinateSpringDamper = VObjectConnectorCoordinateSpringDamper
+
+class VObjectConnectorCoordinateSpringDamperExt:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorCoordinateSpringDamperExt:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), stiffness = 0., damping = 0., offset = 0., velocityOffset = 0., factor0 = 1., factor1 = 1., fDynamicFriction = 0., fStaticFrictionOffset = 0., stickingStiffness = 0., stickingDamping = 0., exponentialDecayStatic = 1.e-3, fViscousFriction = 0., frictionProportionalZone = 0., limitStopsUpper = 0., limitStopsLower = 0., limitStopsStiffness = 0., limitStopsDamping = 0., useLimitStops = False, activeConnector = True, springForceUserFunction = 0, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.stiffness = stiffness
+        self.damping = damping
+        self.offset = offset
+        self.velocityOffset = velocityOffset
+        self.factor0 = factor0
+        self.factor1 = factor1
+        self.fDynamicFriction = CheckForValidUReal(fDynamicFriction,"fDynamicFriction","ObjectConnectorCoordinateSpringDamperExt")
+        self.fStaticFrictionOffset = CheckForValidUReal(fStaticFrictionOffset,"fStaticFrictionOffset","ObjectConnectorCoordinateSpringDamperExt")
+        self.stickingStiffness = CheckForValidUReal(stickingStiffness,"stickingStiffness","ObjectConnectorCoordinateSpringDamperExt")
+        self.stickingDamping = CheckForValidUReal(stickingDamping,"stickingDamping","ObjectConnectorCoordinateSpringDamperExt")
+        self.exponentialDecayStatic = CheckForValidPReal(exponentialDecayStatic,"exponentialDecayStatic","ObjectConnectorCoordinateSpringDamperExt")
+        self.fViscousFriction = fViscousFriction
+        self.frictionProportionalZone = CheckForValidUReal(frictionProportionalZone,"frictionProportionalZone","ObjectConnectorCoordinateSpringDamperExt")
+        self.limitStopsUpper = limitStopsUpper
+        self.limitStopsLower = limitStopsLower
+        self.limitStopsStiffness = CheckForValidUReal(limitStopsStiffness,"limitStopsStiffness","ObjectConnectorCoordinateSpringDamperExt")
+        self.limitStopsDamping = CheckForValidUReal(limitStopsDamping,"limitStopsDamping","ObjectConnectorCoordinateSpringDamperExt")
+        self.useLimitStops = useLimitStops
+        self.activeConnector = activeConnector
+        self.springForceUserFunction = springForceUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorCoordinateSpringDamperExt'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'stiffness', self.stiffness
+        yield 'damping', self.damping
+        yield 'offset', self.offset
+        yield 'velocityOffset', self.velocityOffset
+        yield 'factor0', self.factor0
+        yield 'factor1', self.factor1
+        yield 'fDynamicFriction', self.fDynamicFriction
+        yield 'fStaticFrictionOffset', self.fStaticFrictionOffset
+        yield 'stickingStiffness', self.stickingStiffness
+        yield 'stickingDamping', self.stickingDamping
+        yield 'exponentialDecayStatic', self.exponentialDecayStatic
+        yield 'fViscousFriction', self.fViscousFriction
+        yield 'frictionProportionalZone', self.frictionProportionalZone
+        yield 'limitStopsUpper', self.limitStopsUpper
+        yield 'limitStopsLower', self.limitStopsLower
+        yield 'limitStopsStiffness', self.limitStopsStiffness
+        yield 'limitStopsDamping', self.limitStopsDamping
+        yield 'useLimitStops', self.useLimitStops
+        yield 'activeConnector', self.activeConnector
+        yield 'springForceUserFunction', self.springForceUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+CoordinateSpringDamperExt = ObjectConnectorCoordinateSpringDamperExt
+VCoordinateSpringDamperExt = VObjectConnectorCoordinateSpringDamperExt
+
+class VObjectConnectorGravity:
+    def __init__(self, show = False, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorGravity:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], gravitationalConstant = 6.67430e-11, mass0 = 0., mass1 = 0., minDistanceRegularization = 0., activeConnector = True, visualization = {'show': False, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.gravitationalConstant = gravitationalConstant
+        self.mass0 = CheckForValidUReal(mass0,"mass0","ObjectConnectorGravity")
+        self.mass1 = CheckForValidUReal(mass1,"mass1","ObjectConnectorGravity")
+        self.minDistanceRegularization = CheckForValidUReal(minDistanceRegularization,"minDistanceRegularization","ObjectConnectorGravity")
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorGravity'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'gravitationalConstant', self.gravitationalConstant
+        yield 'mass0', self.mass0
+        yield 'mass1', self.mass1
+        yield 'minDistanceRegularization', self.minDistanceRegularization
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+ConnectorGravity = ObjectConnectorGravity
+VConnectorGravity = VObjectConnectorGravity
+
+class VObjectConnectorHydraulicActuatorSimple:
+    def __init__(self, show = True, cylinderRadius = 0.05, rodRadius = 0.03, pistonRadius = 0.04, pistonLength = 0.001, rodMountRadius = 0.0, baseMountRadius = 0.0, baseMountLength = 0.0, colorCylinder = [-1.,-1.,-1.,-1.], colorPiston = [0.8,0.8,0.8,1.]):
+        self.show = show
+        self.cylinderRadius = cylinderRadius
+        self.rodRadius = rodRadius
+        self.pistonRadius = pistonRadius
+        self.pistonLength = pistonLength
+        self.rodMountRadius = rodMountRadius
+        self.baseMountRadius = baseMountRadius
+        self.baseMountLength = baseMountLength
+        self.colorCylinder = np.array(colorCylinder)
+        self.colorPiston = np.array(colorPiston)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'cylinderRadius', self.cylinderRadius
+        yield 'rodRadius', self.rodRadius
+        yield 'pistonRadius', self.pistonRadius
+        yield 'pistonLength', self.pistonLength
+        yield 'rodMountRadius', self.rodMountRadius
+        yield 'baseMountRadius', self.baseMountRadius
+        yield 'baseMountLength', self.baseMountLength
+        yield 'colorCylinder', self.colorCylinder
+        yield 'colorPiston', self.colorPiston
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorHydraulicActuatorSimple:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumbers = [], offsetLength = 0., strokeLength = 0., chamberCrossSection0 = 0., chamberCrossSection1 = 0., hoseVolume0 = 0., hoseVolume1 = 0., valveOpening0 = 0., valveOpening1 = 0., actuatorDamping = 0., oilBulkModulus = 0., cylinderBulkModulus = 0., hoseBulkModulus = 0., nominalFlow = 0., systemPressure = 0., tankPressure = 0., useChamberVolumeChange = False, activeConnector = True, visualization = {'show': True, 'cylinderRadius': 0.05, 'rodRadius': 0.03, 'pistonRadius': 0.04, 'pistonLength': 0.001, 'rodMountRadius': 0.0, 'baseMountRadius': 0.0, 'baseMountLength': 0.0, 'colorCylinder': [-1.,-1.,-1.,-1.], 'colorPiston': [0.8,0.8,0.8,1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.offsetLength = CheckForValidUReal(offsetLength,"offsetLength","ObjectConnectorHydraulicActuatorSimple")
+        self.strokeLength = CheckForValidPReal(strokeLength,"strokeLength","ObjectConnectorHydraulicActuatorSimple")
+        self.chamberCrossSection0 = CheckForValidPReal(chamberCrossSection0,"chamberCrossSection0","ObjectConnectorHydraulicActuatorSimple")
+        self.chamberCrossSection1 = CheckForValidPReal(chamberCrossSection1,"chamberCrossSection1","ObjectConnectorHydraulicActuatorSimple")
+        self.hoseVolume0 = CheckForValidPReal(hoseVolume0,"hoseVolume0","ObjectConnectorHydraulicActuatorSimple")
+        self.hoseVolume1 = CheckForValidPReal(hoseVolume1,"hoseVolume1","ObjectConnectorHydraulicActuatorSimple")
+        self.valveOpening0 = valveOpening0
+        self.valveOpening1 = valveOpening1
+        self.actuatorDamping = CheckForValidUReal(actuatorDamping,"actuatorDamping","ObjectConnectorHydraulicActuatorSimple")
+        self.oilBulkModulus = CheckForValidPReal(oilBulkModulus,"oilBulkModulus","ObjectConnectorHydraulicActuatorSimple")
+        self.cylinderBulkModulus = CheckForValidUReal(cylinderBulkModulus,"cylinderBulkModulus","ObjectConnectorHydraulicActuatorSimple")
+        self.hoseBulkModulus = CheckForValidUReal(hoseBulkModulus,"hoseBulkModulus","ObjectConnectorHydraulicActuatorSimple")
+        self.nominalFlow = CheckForValidPReal(nominalFlow,"nominalFlow","ObjectConnectorHydraulicActuatorSimple")
+        self.systemPressure = systemPressure
+        self.tankPressure = tankPressure
+        self.useChamberVolumeChange = useChamberVolumeChange
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorHydraulicActuatorSimple'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'offsetLength', self.offsetLength
+        yield 'strokeLength', self.strokeLength
+        yield 'chamberCrossSection0', self.chamberCrossSection0
+        yield 'chamberCrossSection1', self.chamberCrossSection1
+        yield 'hoseVolume0', self.hoseVolume0
+        yield 'hoseVolume1', self.hoseVolume1
+        yield 'valveOpening0', self.valveOpening0
+        yield 'valveOpening1', self.valveOpening1
+        yield 'actuatorDamping', self.actuatorDamping
+        yield 'oilBulkModulus', self.oilBulkModulus
+        yield 'cylinderBulkModulus', self.cylinderBulkModulus
+        yield 'hoseBulkModulus', self.hoseBulkModulus
+        yield 'nominalFlow', self.nominalFlow
+        yield 'systemPressure', self.systemPressure
+        yield 'tankPressure', self.tankPressure
+        yield 'useChamberVolumeChange', self.useChamberVolumeChange
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VcylinderRadius', dict(self.visualization)["cylinderRadius"]
+        yield 'VrodRadius', dict(self.visualization)["rodRadius"]
+        yield 'VpistonRadius', dict(self.visualization)["pistonRadius"]
+        yield 'VpistonLength', dict(self.visualization)["pistonLength"]
+        yield 'VrodMountRadius', dict(self.visualization)["rodMountRadius"]
+        yield 'VbaseMountRadius', dict(self.visualization)["baseMountRadius"]
+        yield 'VbaseMountLength', dict(self.visualization)["baseMountLength"]
+        yield 'VcolorCylinder', dict(self.visualization)["colorCylinder"]
+        yield 'VcolorPiston', dict(self.visualization)["colorPiston"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+HydraulicActuatorSimple = ObjectConnectorHydraulicActuatorSimple
+VHydraulicActuatorSimple = VObjectConnectorHydraulicActuatorSimple
+
+class VObjectConnectorReevingSystemSprings:
+    def __init__(self, show = True, ropeRadius = 0.001, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.ropeRadius = ropeRadius
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'ropeRadius', self.ropeRadius
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorReevingSystemSprings:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], hasCoordinateMarkers = False, coordinateFactors = [1,1], stiffnessPerLength = 0., dampingPerLength = 0., dampingTorsional = 0., dampingShear = 0., regularizationForce = 0.1, referenceLength = 0., sheavesAxes = None, sheavesRadii = [], activeConnector = True, visualization = {'show': True, 'ropeRadius': 0.001, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.hasCoordinateMarkers = hasCoordinateMarkers
+        self.coordinateFactors = np.array(coordinateFactors)
+        self.stiffnessPerLength = CheckForValidUReal(stiffnessPerLength,"stiffnessPerLength","ObjectConnectorReevingSystemSprings")
+        self.dampingPerLength = CheckForValidUReal(dampingPerLength,"dampingPerLength","ObjectConnectorReevingSystemSprings")
+        self.dampingTorsional = CheckForValidUReal(dampingTorsional,"dampingTorsional","ObjectConnectorReevingSystemSprings")
+        self.dampingShear = CheckForValidUReal(dampingShear,"dampingShear","ObjectConnectorReevingSystemSprings")
+        self.regularizationForce = regularizationForce
+        self.referenceLength = referenceLength
+        self.sheavesAxes = sheavesAxes
+        self.sheavesRadii = np.array(sheavesRadii)
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorReevingSystemSprings'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'hasCoordinateMarkers', self.hasCoordinateMarkers
+        yield 'coordinateFactors', self.coordinateFactors
+        yield 'stiffnessPerLength', self.stiffnessPerLength
+        yield 'dampingPerLength', self.dampingPerLength
+        yield 'dampingTorsional', self.dampingTorsional
+        yield 'dampingShear', self.dampingShear
+        yield 'regularizationForce', self.regularizationForce
+        yield 'referenceLength', self.referenceLength
+        yield 'sheavesAxes', self.sheavesAxes
+        yield 'sheavesRadii', self.sheavesRadii
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VropeRadius', dict(self.visualization)["ropeRadius"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+ReevingSystemSprings = ObjectConnectorReevingSystemSprings
+VReevingSystemSprings = VObjectConnectorReevingSystemSprings
+
+class VObjectConnectorDistance:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorDistance:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], distance = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.distance = CheckForValidPReal(distance,"distance","ObjectConnectorDistance")
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorDistance'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'distance', self.distance
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+DistanceConstraint = ObjectConnectorDistance
+VDistanceConstraint = VObjectConnectorDistance
+
+class VObjectConnectorCoordinate:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorCoordinate:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], offset = 0., factorValue1 = 1., velocityLevel = False, offsetUserFunction = 0, offsetUserFunction_t = 0, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.offset = offset
+        self.factorValue1 = factorValue1
+        self.velocityLevel = velocityLevel
+        self.offsetUserFunction = offsetUserFunction
+        self.offsetUserFunction_t = offsetUserFunction_t
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorCoordinate'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'offset', self.offset
+        yield 'factorValue1', self.factorValue1
+        yield 'velocityLevel', self.velocityLevel
+        yield 'offsetUserFunction', self.offsetUserFunction
+        yield 'offsetUserFunction_t', self.offsetUserFunction_t
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+CoordinateConstraint = ObjectConnectorCoordinate
+VCoordinateConstraint = VObjectConnectorCoordinate
+
+class VObjectConnectorCoordinateVector:
+    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorCoordinateVector:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], scalingMarker0 = [], scalingMarker1 = [], quadraticTermMarker0 = [], quadraticTermMarker1 = [], offset = [], velocityLevel = False, constraintUserFunction = 0, jacobianUserFunction = 0, activeConnector = True, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.scalingMarker0 = np.array(scalingMarker0)
+        self.scalingMarker1 = np.array(scalingMarker1)
+        self.quadraticTermMarker0 = np.array(quadraticTermMarker0)
+        self.quadraticTermMarker1 = np.array(quadraticTermMarker1)
+        self.offset = np.array(offset)
+        self.velocityLevel = velocityLevel
+        self.constraintUserFunction = constraintUserFunction
+        self.jacobianUserFunction = jacobianUserFunction
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorCoordinateVector'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'scalingMarker0', self.scalingMarker0
+        yield 'scalingMarker1', self.scalingMarker1
+        yield 'quadraticTermMarker0', self.quadraticTermMarker0
+        yield 'quadraticTermMarker1', self.quadraticTermMarker1
+        yield 'offset', self.offset
+        yield 'velocityLevel', self.velocityLevel
+        yield 'constraintUserFunction', self.constraintUserFunction
+        yield 'jacobianUserFunction', self.jacobianUserFunction
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+CoordinateVectorConstraint = ObjectConnectorCoordinateVector
+VCoordinateVectorConstraint = VObjectConnectorCoordinateVector
+
+class VObjectConnectorRollingDiscPenalty:
+    def __init__(self, show = True, discWidth = 0.1, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.discWidth = discWidth
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'discWidth', self.discWidth
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectConnectorRollingDiscPenalty:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), discRadius = 0., discAxis = [1,0,0], planeNormal = [0,0,1], dryFrictionAngle = 0., contactStiffness = 0., contactDamping = 0., dryFriction = [0,0], dryFrictionProportionalZone = 0., viscousFriction = [0,0], rollingFrictionViscous = 0., useLinearProportionalZone = False, activeConnector = True, visualization = {'show': True, 'discWidth': 0.1, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.discRadius = CheckForValidPReal(discRadius,"discRadius","ObjectConnectorRollingDiscPenalty")
+        self.discAxis = np.array(discAxis)
+        self.planeNormal = np.array(planeNormal)
+        self.dryFrictionAngle = dryFrictionAngle
+        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectConnectorRollingDiscPenalty")
+        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectConnectorRollingDiscPenalty")
+        self.dryFriction = np.array(dryFriction)
+        self.dryFrictionProportionalZone = dryFrictionProportionalZone
+        self.viscousFriction = np.array(viscousFriction)
+        self.rollingFrictionViscous = rollingFrictionViscous
+        self.useLinearProportionalZone = useLinearProportionalZone
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ConnectorRollingDiscPenalty'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'discRadius', self.discRadius
+        yield 'discAxis', self.discAxis
+        yield 'planeNormal', self.planeNormal
+        yield 'dryFrictionAngle', self.dryFrictionAngle
+        yield 'contactStiffness', self.contactStiffness
+        yield 'contactDamping', self.contactDamping
+        yield 'dryFriction', self.dryFriction
+        yield 'dryFrictionProportionalZone', self.dryFrictionProportionalZone
+        yield 'viscousFriction', self.viscousFriction
+        yield 'rollingFrictionViscous', self.rollingFrictionViscous
+        yield 'useLinearProportionalZone', self.useLinearProportionalZone
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdiscWidth', dict(self.visualization)["discWidth"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RollingDiscPenalty = ObjectConnectorRollingDiscPenalty
+VRollingDiscPenalty = VObjectConnectorRollingDiscPenalty
+
+class VObjectContactConvexRoll:
+    def __init__(self, show = True, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectContactConvexRoll:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), contactStiffness = 0., contactDamping = 0., dynamicFriction = 0., staticFrictionOffset = 0., viscousFriction = 0., exponentialDecayStatic = 1e-3, frictionProportionalZone = 1e-3, rollLength = 0., coefficientsHull =  [], rBoundingSphere = 0, activeConnector = True, visualization = {'show': True, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.contactStiffness = contactStiffness
+        self.contactDamping = contactDamping
+        self.dynamicFriction = CheckForValidUReal(dynamicFriction,"dynamicFriction","ObjectContactConvexRoll")
+        self.staticFrictionOffset = CheckForValidUReal(staticFrictionOffset,"staticFrictionOffset","ObjectContactConvexRoll")
+        self.viscousFriction = CheckForValidUReal(viscousFriction,"viscousFriction","ObjectContactConvexRoll")
+        self.exponentialDecayStatic = CheckForValidPReal(exponentialDecayStatic,"exponentialDecayStatic","ObjectContactConvexRoll")
+        self.frictionProportionalZone = CheckForValidUReal(frictionProportionalZone,"frictionProportionalZone","ObjectContactConvexRoll")
+        self.rollLength = CheckForValidUReal(rollLength,"rollLength","ObjectContactConvexRoll")
+        self.coefficientsHull = np.array(coefficientsHull)
+        self.rBoundingSphere = CheckForValidUReal(rBoundingSphere,"rBoundingSphere","ObjectContactConvexRoll")
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ContactConvexRoll'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'contactStiffness', self.contactStiffness
+        yield 'contactDamping', self.contactDamping
+        yield 'dynamicFriction', self.dynamicFriction
+        yield 'staticFrictionOffset', self.staticFrictionOffset
+        yield 'viscousFriction', self.viscousFriction
+        yield 'exponentialDecayStatic', self.exponentialDecayStatic
+        yield 'frictionProportionalZone', self.frictionProportionalZone
+        yield 'rollLength', self.rollLength
+        yield 'coefficientsHull', self.coefficientsHull
+        yield 'rBoundingSphere', self.rBoundingSphere
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectContactCoordinate:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectContactCoordinate:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), contactStiffness = 0., contactDamping = 0., offset = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactCoordinate")
+        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactCoordinate")
+        self.offset = offset
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ContactCoordinate'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'contactStiffness', self.contactStiffness
+        yield 'contactDamping', self.contactDamping
+        yield 'offset', self.offset
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectContactCircleCable2D:
+    def __init__(self, show = True, showContactCircle = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.showContactCircle = showContactCircle
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'showContactCircle', self.showContactCircle
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectContactCircleCable2D:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), numberOfContactSegments = 3, contactStiffness = 0., contactDamping = 0., circleRadius = 0., offset = 0., activeConnector = True, visualization = {'show': True, 'showContactCircle': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.numberOfContactSegments = numberOfContactSegments
+        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactCircleCable2D")
+        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactCircleCable2D")
+        self.circleRadius = CheckForValidUReal(circleRadius,"circleRadius","ObjectContactCircleCable2D")
+        self.offset = offset
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ContactCircleCable2D'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'numberOfContactSegments', self.numberOfContactSegments
+        yield 'contactStiffness', self.contactStiffness
+        yield 'contactDamping', self.contactDamping
+        yield 'circleRadius', self.circleRadius
+        yield 'offset', self.offset
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VshowContactCircle', dict(self.visualization)["showContactCircle"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectContactFrictionCircleCable2D:
+    def __init__(self, show = True, showContactCircle = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.showContactCircle = showContactCircle
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'showContactCircle', self.showContactCircle
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectContactFrictionCircleCable2D:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), numberOfContactSegments = 3, contactStiffness = 0., contactDamping = 0., frictionVelocityPenalty = 0., frictionStiffness = 0., frictionCoefficient = 0., circleRadius = 0., useSegmentNormals = True, activeConnector = True, visualization = {'show': True, 'showContactCircle': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.numberOfContactSegments = CheckForValidPInt(numberOfContactSegments,"numberOfContactSegments","ObjectContactFrictionCircleCable2D")
+        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactFrictionCircleCable2D")
+        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactFrictionCircleCable2D")
+        self.frictionVelocityPenalty = CheckForValidUReal(frictionVelocityPenalty,"frictionVelocityPenalty","ObjectContactFrictionCircleCable2D")
+        self.frictionStiffness = CheckForValidUReal(frictionStiffness,"frictionStiffness","ObjectContactFrictionCircleCable2D")
+        self.frictionCoefficient = CheckForValidUReal(frictionCoefficient,"frictionCoefficient","ObjectContactFrictionCircleCable2D")
+        self.circleRadius = CheckForValidUReal(circleRadius,"circleRadius","ObjectContactFrictionCircleCable2D")
+        self.useSegmentNormals = useSegmentNormals
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ContactFrictionCircleCable2D'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'numberOfContactSegments', self.numberOfContactSegments
+        yield 'contactStiffness', self.contactStiffness
+        yield 'contactDamping', self.contactDamping
+        yield 'frictionVelocityPenalty', self.frictionVelocityPenalty
+        yield 'frictionStiffness', self.frictionStiffness
+        yield 'frictionCoefficient', self.frictionCoefficient
+        yield 'circleRadius', self.circleRadius
+        yield 'useSegmentNormals', self.useSegmentNormals
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VshowContactCircle', dict(self.visualization)["showContactCircle"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VObjectJointGeneric:
+    def __init__(self, show = True, axesRadius = 0.1, axesLength = 0.4, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.axesRadius = axesRadius
+        self.axesLength = axesLength
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'axesRadius', self.axesRadius
+        yield 'axesLength', self.axesLength
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointGeneric:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], constrainedAxes = [1,1,1,1,1,1], rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), activeConnector = True, offsetUserFunctionParameters = [0.,0.,0.,0.,0.,0.], offsetUserFunction = 0, offsetUserFunction_t = 0, alternativeConstraints = False, visualization = {'show': True, 'axesRadius': 0.1, 'axesLength': 0.4, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.constrainedAxes = copy.copy(constrainedAxes)
+        self.rotationMarker0 = np.array(rotationMarker0)
+        self.rotationMarker1 = np.array(rotationMarker1)
+        self.activeConnector = activeConnector
+        self.offsetUserFunctionParameters = np.array(offsetUserFunctionParameters)
+        self.offsetUserFunction = offsetUserFunction
+        self.offsetUserFunction_t = offsetUserFunction_t
+        self.alternativeConstraints = alternativeConstraints
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointGeneric'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'constrainedAxes', self.constrainedAxes
+        yield 'rotationMarker0', self.rotationMarker0
+        yield 'rotationMarker1', self.rotationMarker1
+        yield 'activeConnector', self.activeConnector
+        yield 'offsetUserFunctionParameters', self.offsetUserFunctionParameters
+        yield 'offsetUserFunction', self.offsetUserFunction
+        yield 'offsetUserFunction_t', self.offsetUserFunction_t
+        yield 'alternativeConstraints', self.alternativeConstraints
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VaxesRadius', dict(self.visualization)["axesRadius"]
+        yield 'VaxesLength', dict(self.visualization)["axesLength"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+GenericJoint = ObjectJointGeneric
+VGenericJoint = VObjectJointGeneric
+
+class VObjectJointRevoluteZ:
+    def __init__(self, show = True, axisRadius = 0.1, axisLength = 0.4, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.axisRadius = axisRadius
+        self.axisLength = axisLength
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'axisRadius', self.axisRadius
+        yield 'axisLength', self.axisLength
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointRevoluteZ:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), activeConnector = True, visualization = {'show': True, 'axisRadius': 0.1, 'axisLength': 0.4, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.rotationMarker0 = np.array(rotationMarker0)
+        self.rotationMarker1 = np.array(rotationMarker1)
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointRevoluteZ'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'rotationMarker0', self.rotationMarker0
+        yield 'rotationMarker1', self.rotationMarker1
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VaxisRadius', dict(self.visualization)["axisRadius"]
+        yield 'VaxisLength', dict(self.visualization)["axisLength"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RevoluteJointZ = ObjectJointRevoluteZ
+VRevoluteJointZ = VObjectJointRevoluteZ
+
+class VObjectJointPrismaticX:
+    def __init__(self, show = True, axisRadius = 0.1, axisLength = 0.4, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.axisRadius = axisRadius
+        self.axisLength = axisLength
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'axisRadius', self.axisRadius
+        yield 'axisLength', self.axisLength
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointPrismaticX:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], rotationMarker0 = IIDiagMatrix(rowsColumns=3,value=1), rotationMarker1 = IIDiagMatrix(rowsColumns=3,value=1), activeConnector = True, visualization = {'show': True, 'axisRadius': 0.1, 'axisLength': 0.4, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.rotationMarker0 = np.array(rotationMarker0)
+        self.rotationMarker1 = np.array(rotationMarker1)
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointPrismaticX'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'rotationMarker0', self.rotationMarker0
+        yield 'rotationMarker1', self.rotationMarker1
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VaxisRadius', dict(self.visualization)["axisRadius"]
+        yield 'VaxisLength', dict(self.visualization)["axisLength"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+PrismaticJointX = ObjectJointPrismaticX
+VPrismaticJointX = VObjectJointPrismaticX
+
+class VObjectJointSpherical:
+    def __init__(self, show = True, jointRadius = 0.1, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.jointRadius = jointRadius
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'jointRadius', self.jointRadius
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointSpherical:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], constrainedAxes = [1,1,1], activeConnector = True, visualization = {'show': True, 'jointRadius': 0.1, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.constrainedAxes = copy.copy(constrainedAxes)
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointSpherical'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'constrainedAxes', self.constrainedAxes
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VjointRadius', dict(self.visualization)["jointRadius"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+SphericalJoint = ObjectJointSpherical
+VSphericalJoint = VObjectJointSpherical
+
+class VObjectJointRollingDisc:
+    def __init__(self, show = True, discWidth = 0.1, color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.discWidth = discWidth
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'discWidth', self.discWidth
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointRollingDisc:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], constrainedAxes = [1,1,1], activeConnector = True, discRadius = 0, discAxis = [1,0,0], planeNormal = [0,0,1], visualization = {'show': True, 'discWidth': 0.1, 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.constrainedAxes = copy.copy(constrainedAxes)
+        self.activeConnector = activeConnector
+        self.discRadius = CheckForValidPReal(discRadius,"discRadius","ObjectJointRollingDisc")
+        self.discAxis = np.array(discAxis)
+        self.planeNormal = np.array(planeNormal)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointRollingDisc'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'constrainedAxes', self.constrainedAxes
+        yield 'activeConnector', self.activeConnector
+        yield 'discRadius', self.discRadius
+        yield 'discAxis', self.discAxis
+        yield 'planeNormal', self.planeNormal
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdiscWidth', dict(self.visualization)["discWidth"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RollingDiscJoint = ObjectJointRollingDisc
+VRollingDiscJoint = VObjectJointRollingDisc
+
+class VObjectJointRevolute2D:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointRevolute2D:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointRevolute2D'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+RevoluteJoint2D = ObjectJointRevolute2D
+VRevoluteJoint2D = VObjectJointRevolute2D
+
+class VObjectJointPrismatic2D:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointPrismatic2D:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], axisMarker0 = [1.,0.,0.], normalMarker1 = [0.,1.,0.], constrainRotation = True, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.axisMarker0 = np.array(axisMarker0)
+        self.normalMarker1 = np.array(normalMarker1)
+        self.constrainRotation = constrainRotation
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointPrismatic2D'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'axisMarker0', self.axisMarker0
+        yield 'normalMarker1', self.normalMarker1
+        yield 'constrainRotation', self.constrainRotation
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+PrismaticJoint2D = ObjectJointPrismatic2D
+VPrismaticJoint2D = VObjectJointPrismatic2D
+
+class VObjectJointSliding2D:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointSliding2D:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], slidingMarkerNumbers = [], slidingMarkerOffsets = [], nodeNumber = exudyn.InvalidIndex(), classicalFormulation = True, constrainRotation = False, axialForce = 0, activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.slidingMarkerNumbers = copy.copy(slidingMarkerNumbers)
+        self.slidingMarkerOffsets = np.array(slidingMarkerOffsets)
+        self.nodeNumber = nodeNumber
+        self.classicalFormulation = classicalFormulation
+        self.constrainRotation = constrainRotation
+        self.axialForce = axialForce
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointSliding2D'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'slidingMarkerNumbers', self.slidingMarkerNumbers
+        yield 'slidingMarkerOffsets', self.slidingMarkerOffsets
+        yield 'nodeNumber', self.nodeNumber
+        yield 'classicalFormulation', self.classicalFormulation
+        yield 'constrainRotation', self.constrainRotation
+        yield 'axialForce', self.axialForce
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+SlidingJoint2D = ObjectJointSliding2D
+VSlidingJoint2D = VObjectJointSliding2D
+
+class VObjectJointALEMoving2D:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectJointALEMoving2D:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], slidingMarkerNumbers = [], slidingMarkerOffsets = [], slidingOffset = 0., nodeNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], usePenaltyFormulation = False, penaltyStiffness = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.slidingMarkerNumbers = copy.copy(slidingMarkerNumbers)
+        self.slidingMarkerOffsets = np.array(slidingMarkerOffsets)
+        self.slidingOffset = slidingOffset
+        self.nodeNumbers = copy.copy(nodeNumbers)
+        self.usePenaltyFormulation = usePenaltyFormulation
+        self.penaltyStiffness = penaltyStiffness
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'JointALEMoving2D'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'slidingMarkerNumbers', self.slidingMarkerNumbers
+        yield 'slidingMarkerOffsets', self.slidingMarkerOffsets
+        yield 'slidingOffset', self.slidingOffset
+        yield 'nodeNumbers', self.nodeNumbers
+        yield 'usePenaltyFormulation', self.usePenaltyFormulation
+        yield 'penaltyStiffness', self.penaltyStiffness
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+ALEMovingJoint2D = ObjectJointALEMoving2D
+VALEMovingJoint2D = VObjectJointALEMoving2D
+
+class VObjectContactFrictionCircleCable2DOld:
+    def __init__(self, show = True, drawSize = -1., color = [-1.,-1.,-1.,-1.]):
+        self.show = show
+        self.drawSize = drawSize
+        self.color = np.array(color)
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'drawSize', self.drawSize
+        yield 'color', self.color
+
+    def __repr__(self):
+        return str(dict(self))
+class ObjectContactFrictionCircleCable2DOld:
+    def __init__(self, name = '', markerNumbers = [ exudyn.InvalidIndex(), exudyn.InvalidIndex() ], nodeNumber = exudyn.InvalidIndex(), numberOfContactSegments = 3, contactStiffness = 0., contactDamping = 0., frictionVelocityPenalty = 0., frictionStiffness = 0., frictionCoefficient = 0., circleRadius = 0., offset = 0., activeConnector = True, visualization = {'show': True, 'drawSize': -1., 'color': [-1.,-1.,-1.,-1.]}):
+        self.name = name
+        self.markerNumbers = copy.copy(markerNumbers)
+        self.nodeNumber = nodeNumber
+        self.numberOfContactSegments = CheckForValidPInt(numberOfContactSegments,"numberOfContactSegments","ObjectContactFrictionCircleCable2DOld")
+        self.contactStiffness = CheckForValidUReal(contactStiffness,"contactStiffness","ObjectContactFrictionCircleCable2DOld")
+        self.contactDamping = CheckForValidUReal(contactDamping,"contactDamping","ObjectContactFrictionCircleCable2DOld")
+        self.frictionVelocityPenalty = CheckForValidUReal(frictionVelocityPenalty,"frictionVelocityPenalty","ObjectContactFrictionCircleCable2DOld")
+        self.frictionStiffness = CheckForValidUReal(frictionStiffness,"frictionStiffness","ObjectContactFrictionCircleCable2DOld")
+        self.frictionCoefficient = CheckForValidUReal(frictionCoefficient,"frictionCoefficient","ObjectContactFrictionCircleCable2DOld")
+        self.circleRadius = CheckForValidUReal(circleRadius,"circleRadius","ObjectContactFrictionCircleCable2DOld")
+        self.offset = offset
+        self.activeConnector = activeConnector
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'objectType', 'ContactFrictionCircleCable2DOld'
+        yield 'name', self.name
+        yield 'markerNumbers', self.markerNumbers
+        yield 'nodeNumber', self.nodeNumber
+        yield 'numberOfContactSegments', self.numberOfContactSegments
+        yield 'contactStiffness', self.contactStiffness
+        yield 'contactDamping', self.contactDamping
+        yield 'frictionVelocityPenalty', self.frictionVelocityPenalty
+        yield 'frictionStiffness', self.frictionStiffness
+        yield 'frictionCoefficient', self.frictionCoefficient
+        yield 'circleRadius', self.circleRadius
+        yield 'offset', self.offset
+        yield 'activeConnector', self.activeConnector
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VdrawSize', dict(self.visualization)["drawSize"]
+        yield 'Vcolor', dict(self.visualization)["color"]
+
+    def __repr__(self):
+        return str(dict(self))
+#+++++++++++++++++++++++++++++++
+#MARKER
+class VMarkerBodyMass:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerBodyMass:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'BodyMass'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerBodyPosition:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerBodyPosition:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.localPosition = np.array(localPosition)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'BodyPosition'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'localPosition', self.localPosition
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerBodyRigid:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerBodyRigid:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.localPosition = np.array(localPosition)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'BodyRigid'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'localPosition', self.localPosition
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerNodePosition:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerNodePosition:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'NodePosition'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerNodeRigid:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerNodeRigid:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'NodeRigid'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerNodeCoordinate:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerNodeCoordinate:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), coordinate = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.coordinate = CheckForValidUInt(coordinate,"coordinate","MarkerNodeCoordinate")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'NodeCoordinate'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'coordinate', self.coordinate
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerNodeCoordinates:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerNodeCoordinates:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'NodeCoordinates'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerNodeODE1Coordinate:
+    def __init__(self, show = False):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerNodeODE1Coordinate:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), coordinate = exudyn.InvalidIndex(), visualization = {'show': False}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.coordinate = CheckForValidUInt(coordinate,"coordinate","MarkerNodeODE1Coordinate")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'NodeODE1Coordinate'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'coordinate', self.coordinate
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerNodeRotationCoordinate:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerNodeRotationCoordinate:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), rotationCoordinate = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.rotationCoordinate = CheckForValidUInt(rotationCoordinate,"rotationCoordinate","MarkerNodeRotationCoordinate")
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'NodeRotationCoordinate'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'rotationCoordinate', self.rotationCoordinate
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerSuperElementPosition:
+    def __init__(self, show = True, showMarkerNodes = True):
+        self.show = show
+        self.showMarkerNodes = showMarkerNodes
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'showMarkerNodes', self.showMarkerNodes
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerSuperElementPosition:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), meshNodeNumbers = [], weightingFactors = [], visualization = {'show': True, 'showMarkerNodes': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.meshNodeNumbers = copy.copy(meshNodeNumbers)
+        self.weightingFactors = np.array(weightingFactors)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'SuperElementPosition'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'meshNodeNumbers', self.meshNodeNumbers
+        yield 'weightingFactors', self.weightingFactors
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VshowMarkerNodes', dict(self.visualization)["showMarkerNodes"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerSuperElementRigid:
+    def __init__(self, show = True, showMarkerNodes = True):
+        self.show = show
+        self.showMarkerNodes = showMarkerNodes
+
+    def __iter__(self):
+        yield 'show', self.show
+        yield 'showMarkerNodes', self.showMarkerNodes
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerSuperElementRigid:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), offset = [0.,0.,0.], meshNodeNumbers = [], weightingFactors = [], useAlternativeApproach = True, rotationsExponentialMap = 2, visualization = {'show': True, 'showMarkerNodes': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.offset = np.array(offset)
+        self.meshNodeNumbers = copy.copy(meshNodeNumbers)
+        self.weightingFactors = np.array(weightingFactors)
+        self.useAlternativeApproach = useAlternativeApproach
+        self.rotationsExponentialMap = rotationsExponentialMap
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'SuperElementRigid'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'offset', self.offset
+        yield 'meshNodeNumbers', self.meshNodeNumbers
+        yield 'weightingFactors', self.weightingFactors
+        yield 'useAlternativeApproach', self.useAlternativeApproach
+        yield 'rotationsExponentialMap', self.rotationsExponentialMap
+        yield 'Vshow', dict(self.visualization)["show"]
+        yield 'VshowMarkerNodes', dict(self.visualization)["showMarkerNodes"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerKinematicTreeRigid:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerKinematicTreeRigid:
+    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), linkNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], visualization = {'show': True}):
+        self.name = name
+        self.objectNumber = objectNumber
+        self.linkNumber = CheckForValidUInt(linkNumber,"linkNumber","MarkerKinematicTreeRigid")
+        self.localPosition = np.array(localPosition)
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'KinematicTreeRigid'
+        yield 'name', self.name
+        yield 'objectNumber', self.objectNumber
+        yield 'linkNumber', self.linkNumber
+        yield 'localPosition', self.localPosition
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerObjectODE2Coordinates:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerObjectODE2Coordinates:
+    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.objectNumber = objectNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'ObjectODE2Coordinates'
+        yield 'name', self.name
+        yield 'objectNumber', self.objectNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerBodyCable2DShape:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerBodyCable2DShape:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), numberOfSegments = 3, verticalOffset = 0., visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.numberOfSegments = CheckForValidPInt(numberOfSegments,"numberOfSegments","MarkerBodyCable2DShape")
+        self.verticalOffset = verticalOffset
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'BodyCable2DShape'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'numberOfSegments', self.numberOfSegments
+        yield 'verticalOffset', self.verticalOffset
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VMarkerBodyCable2DCoordinates:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class MarkerBodyCable2DCoordinates:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'markerType', 'BodyCable2DCoordinates'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+#+++++++++++++++++++++++++++++++
+#LOAD
+class VLoadForceVector:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class LoadForceVector:
+    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), loadVector = [0.,0.,0.], bodyFixed = False, loadVectorUserFunction = 0, visualization = {'show': True}):
+        self.name = name
+        self.markerNumber = markerNumber
+        self.loadVector = np.array(loadVector)
+        self.bodyFixed = bodyFixed
+        self.loadVectorUserFunction = loadVectorUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'loadType', 'ForceVector'
+        yield 'name', self.name
+        yield 'markerNumber', self.markerNumber
+        yield 'loadVector', self.loadVector
+        yield 'bodyFixed', self.bodyFixed
+        yield 'loadVectorUserFunction', self.loadVectorUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Force = LoadForceVector
+VForce = VLoadForceVector
+
+class VLoadTorqueVector:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class LoadTorqueVector:
+    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), loadVector = [0.,0.,0.], bodyFixed = False, loadVectorUserFunction = 0, visualization = {'show': True}):
+        self.name = name
+        self.markerNumber = markerNumber
+        self.loadVector = np.array(loadVector)
+        self.bodyFixed = bodyFixed
+        self.loadVectorUserFunction = loadVectorUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'loadType', 'TorqueVector'
+        yield 'name', self.name
+        yield 'markerNumber', self.markerNumber
+        yield 'loadVector', self.loadVector
+        yield 'bodyFixed', self.bodyFixed
+        yield 'loadVectorUserFunction', self.loadVectorUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Torque = LoadTorqueVector
+VTorque = VLoadTorqueVector
+
+class VLoadMassProportional:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class LoadMassProportional:
+    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), loadVector = [0.,0.,0.], loadVectorUserFunction = 0, visualization = {'show': True}):
+        self.name = name
+        self.markerNumber = markerNumber
+        self.loadVector = np.array(loadVector)
+        self.loadVectorUserFunction = loadVectorUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'loadType', 'MassProportional'
+        yield 'name', self.name
+        yield 'markerNumber', self.markerNumber
+        yield 'loadVector', self.loadVector
+        yield 'loadVectorUserFunction', self.loadVectorUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+#add typedef for short usage:
+Gravity = LoadMassProportional
+VGravity = VLoadMassProportional
+
+class VLoadCoordinate:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class LoadCoordinate:
+    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), load = 0., loadUserFunction = 0, visualization = {'show': True}):
+        self.name = name
+        self.markerNumber = markerNumber
+        self.load = load
+        self.loadUserFunction = loadUserFunction
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'loadType', 'Coordinate'
+        yield 'name', self.name
+        yield 'markerNumber', self.markerNumber
+        yield 'load', self.load
+        yield 'loadUserFunction', self.loadUserFunction
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+#+++++++++++++++++++++++++++++++
+#SENSOR
+class VSensorNode:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorNode:
+    def __init__(self, name = '', nodeNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.nodeNumber = nodeNumber
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.outputVariableType = outputVariableType
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'Node'
+        yield 'name', self.name
+        yield 'nodeNumber', self.nodeNumber
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'outputVariableType', self.outputVariableType
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorObject:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorObject:
+    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.objectNumber = objectNumber
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.outputVariableType = outputVariableType
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'Object'
+        yield 'name', self.name
+        yield 'objectNumber', self.objectNumber
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'outputVariableType', self.outputVariableType
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorBody:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorBody:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.localPosition = np.array(localPosition)
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.outputVariableType = outputVariableType
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'Body'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'localPosition', self.localPosition
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'outputVariableType', self.outputVariableType
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorSuperElement:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorSuperElement:
+    def __init__(self, name = '', bodyNumber = exudyn.InvalidIndex(), meshNodeNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.bodyNumber = bodyNumber
+        self.meshNodeNumber = CheckForValidUInt(meshNodeNumber,"meshNodeNumber","SensorSuperElement")
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.outputVariableType = outputVariableType
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'SuperElement'
+        yield 'name', self.name
+        yield 'bodyNumber', self.bodyNumber
+        yield 'meshNodeNumber', self.meshNodeNumber
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'outputVariableType', self.outputVariableType
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorKinematicTree:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorKinematicTree:
+    def __init__(self, name = '', objectNumber = exudyn.InvalidIndex(), linkNumber = exudyn.InvalidIndex(), localPosition = [0.,0.,0.], writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.objectNumber = objectNumber
+        self.linkNumber = CheckForValidUInt(linkNumber,"linkNumber","SensorKinematicTree")
+        self.localPosition = np.array(localPosition)
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.outputVariableType = outputVariableType
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'KinematicTree'
+        yield 'name', self.name
+        yield 'objectNumber', self.objectNumber
+        yield 'linkNumber', self.linkNumber
+        yield 'localPosition', self.localPosition
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'outputVariableType', self.outputVariableType
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorMarker:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorMarker:
+    def __init__(self, name = '', markerNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', outputVariableType = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.markerNumber = markerNumber
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.outputVariableType = outputVariableType
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'Marker'
+        yield 'name', self.name
+        yield 'markerNumber', self.markerNumber
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'outputVariableType', self.outputVariableType
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorLoad:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorLoad:
+    def __init__(self, name = '', loadNumber = exudyn.InvalidIndex(), writeToFile = True, fileName = '', storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.loadNumber = loadNumber
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'Load'
+        yield 'name', self.name
+        yield 'loadNumber', self.loadNumber
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
+class VSensorUserFunction:
+    def __init__(self, show = True):
+        self.show = show
+
+    def __iter__(self):
+        yield 'show', self.show
+
+    def __repr__(self):
+        return str(dict(self))
+class SensorUserFunction:
+    def __init__(self, name = '', sensorNumbers = [], factors = [], writeToFile = True, fileName = '', sensorUserFunction = 0, storeInternal = False, visualization = {'show': True}):
+        self.name = name
+        self.sensorNumbers = copy.copy(sensorNumbers)
+        self.factors = np.array(factors)
+        self.writeToFile = writeToFile
+        self.fileName = fileName
+        self.sensorUserFunction = sensorUserFunction
+        self.storeInternal = storeInternal
+        self.visualization = CopyDictLevel1(visualization)
+
+    def __iter__(self):
+        yield 'sensorType', 'UserFunction'
+        yield 'name', self.name
+        yield 'sensorNumbers', self.sensorNumbers
+        yield 'factors', self.factors
+        yield 'writeToFile', self.writeToFile
+        yield 'fileName', self.fileName
+        yield 'sensorUserFunction', self.sensorUserFunction
+        yield 'storeInternal', self.storeInternal
+        yield 'Vshow', dict(self.visualization)["show"]
+
+    def __repr__(self):
+        return str(dict(self))
```

## exudyn/kinematicTree.py

 * *Ordering differences only*

```diff
@@ -1,599 +1,599 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  A library for preparation of minimal coordinates (kinematic tree) formulation.
-#           This library follows mostly the algorithms of Roy Featherstone, see http://royfeatherstone.org/
-#           His code is availble in MATLAB as well as described in the Springer Handbook of Robotics \cite{Siciliano2016}.
-#           The main formalisms are based on 6x6 matrices, so-called Pl\"ucker transformations, denoted as \ac{T66}, as defined by Featherstone.
-#
-# Author:   Johannes Gerstmayr
-# Date:     2021-06-22
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#constants and fixed structures:
-import numpy as np
-#from math import pi, sin, cos#, sqrt
-from copy import deepcopy
-
-#import exudyn as exu
-import exudyn.rigidBodyUtilities as erb
-#from exudyn.robotics import *
-
-#check with Corke Toolbox:
-# https://github.com/petercorke/spatialmath-python
-# https://github.com/petercorke/robotics-toolbox-python
-
-
-#the following functions are defined here to fit into the original Featherstone algorithm
-#rotations are transposed / inverse
-def RotationX2T66Inverse(angle):
-    return erb.RotationX2T66(angle).T
-
-#the following functions are defined here to fit into the original Featherstone algorithm
-#rotations are transposed / inverse
-def RotationY2T66Inverse(angle):
-    return erb.RotationY2T66(angle).T
-
-#the following functions are defined here to fit into the original Featherstone algorithm
-#rotations are transposed / inverse
-def RotationZ2T66Inverse(angle):
-    return erb.RotationZ2T66(angle).T
-
-#compute inverse 6x6 transformation matrix for translation along X axis; output: first 3 components for rotation, second 3 components for translation!
-def TranslationX2T66Inverse(translation):
-    return erb.Translation2T66([-translation,0,0])
-
-#compute inverse 6x6 transformation matrix for translation along Y axis; output: first 3 components for rotation, second 3 components for translation!
-def TranslationY2T66Inverse(translation):
-    return erb.Translation2T66([0,-translation,0])
-
-#compute inverse 6x6 transformation matrix for translation along Z axis; output: first 3 components for rotation, second 3 components for translation!
-def TranslationZ2T66Inverse(translation):
-    return erb.Translation2T66([0,0,-translation])
-
-
-
-#**function: convert mass, COM and inertia into 6x6 inertia matrix
-#**input:
-#  mass: scalar mass
-#  centerOfMass: 3D vector (list/array)
-#  inertia: 3x3 matrix (list of lists / 2D array) w.r.t. center of mass
-#**output: 6x6 numpy array for further use in minimal coordinates formulation
-def MassCOMinertia2T66(mass, centerOfMass, inertia):
-    C = erb.Skew(centerOfMass)
-    return np.block([
-        [inertia + mass*(C @ C.T), mass*C],
-        [mass*C.T, mass*np.eye(3) ]])
-
-#**function: convert inertia as produced with RigidBodyInertia class into 6x6 inertia matrix (as used in KinematicTree66, Featherstone / Handbook of robotics \cite{Siciliano2016})
-#**notes: within the 6x6 matrix, the inertia tensor is defined w.r.t.\ the center of mass, while RigidBodyInertia defines the inertia tensor w.r.t.\ the reference point; however, this function correctly transforms all quantities of inertia.
-#**output: 6x6 numpy array for further use in minimal coordinates formulation
-def Inertia2T66(inertia):
-    C = erb.Skew(inertia.com)
-    mass = inertia.mass
-    #inertiaCOM = inertia.Translated(-inertia.com).inertiaTensor
-    inertiaCOM = inertia.InertiaCOM()
-    #alternatively, we could just use inertia.Inertia() in first block!
-    return np.block([
-        [inertiaCOM + mass*(C @ C.T), mass*C],
-        [mass*C.T, mass*np.eye(3) ]])
-
-#**function: convert 6x6 inertia matrix into mass, COM and inertia 
-#**input: 6x6 numpy array containing rigid body inertia according to Featherstone / Handbook of robotics \cite{Siciliano2016}
-#**output: [mass, centerOfMass, inertia]
-#  mass: scalar mass
-#  centerOfMass: 3D vector (list/array)
-#  inertia: 3x3 matrix (list of lists / 2D array) w.r.t. center of mass
-def Inertia66toMassCOMinertia(inertia66):
-    mass = inertia66[5,5]
-    massCOM = inertia66[0:3,3:6]
-    centerOfMass = erb.Skew2Vec(massCOM)/mass
-    inertia = inertia66[0:3,0:3] - massCOM @ massCOM.T/mass;
-
-    return [mass, centerOfMass, inertia]
-
-
-#define dictionary for joint transformations, as there is no switch case statement in Python
-dictOfJointTransformMotionSubspace66 = {
-    'Rx':[RotationX2T66Inverse,   np.array([1,0,0,0,0,0])], #revolute joint for local X axis
-    'Ry':[RotationY2T66Inverse,   np.array([0,1,0,0,0,0])], #revolute joint for local Y axis
-    'Rz':[RotationZ2T66Inverse,   np.array([0,0,1,0,0,0])], #revolute joint for local Z axis
-    'Px':[TranslationX2T66Inverse, np.array([0,0,0,1,0,0])], #prismatic joint for local X axis
-    'Py':[TranslationY2T66Inverse, np.array([0,0,0,0,1,0])], #prismatic joint for local Y axis
-    'Pz':[TranslationZ2T66Inverse, np.array([0,0,0,0,0,1])], #prismatic joint for local Z axis
-    #helical and planar joints available in Featherstone's implementation
-    }
-
-#**function: return 6x6 Pl\"ucker joint transformation matrix evaluated for scalar joint coordinate q and motion subspace ('free modes' in Table 2.6 in Handbook of robotics \cite{Siciliano2016})
-def JointTransformMotionSubspace66(jointType, q):
-    [T,MS] = dictOfJointTransformMotionSubspace66[jointType]
-    return [T(q), MS]
-        
-
-#unit matrix needed for dictOfJointRotationMatrixAxis
-# def UnitMatrix3D():
-#     return np.eye(3)
-
-#define dictionary for joint transformations, as there is no switch case statement in Python
-#using rotation matrix, translation (for prismatic joints), joint axes (rot, trans)
-dictOfJointRotationMatrixAxis = {
-    'Rx':[erb.RotationMatrixX, np.array([0,0,0]), np.array([1,0,0]), np.array([0,0,0])], #revolute joint for local X axis
-    'Ry':[erb.RotationMatrixY, np.array([0,0,0]), np.array([0,1,0]), np.array([0,0,0])], #revolute joint for local Y axis
-    'Rz':[erb.RotationMatrixZ, np.array([0,0,0]), np.array([0,0,1]), np.array([0,0,0])], #revolute joint for local Z axis
-    'Px':[0,               np.array([1,0,0]), np.array([0,0,0]), np.array([1,0,0])], #prismatic joint for local X axis
-    'Py':[0,               np.array([0,1,0]), np.array([0,0,0]), np.array([0,1,0])], #prismatic joint for local Y axis
-    'Pz':[0,               np.array([0,0,1]), np.array([0,0,0]), np.array([0,0,1])], #prismatic joint for local Z axis
-    }
-
-#**function: return list containing rotation matrix, translation vector, rotation axis and translation axis for joint transformation
-def JointTransformMotionSubspace(jointType, q):
-    [A, v, rotAxis, transAxis] = dictOfJointRotationMatrixAxis[jointType]
-    if jointType[0] == 'R':
-        return [A(q).T, v, rotAxis, transAxis] #transposed needed as compared to RotationMatrixX, as the algorithm requires coordinate transforms instead of active rotation matrices
-    else: #prismatic
-        return [np.eye(3), v*q, rotAxis, transAxis]
-        
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#definition of a kinematic tree
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: class to define a kinematic tree in Python, which can be used for building serial or tree-structured multibody systems 
-#         (or robots) with a minimal coordinates formulation, using rotation matrices and 3D offsets; for efficient computation, use the C++ ObjectKinematicTree
-#**notes:
-#   The formulation and structures widely follows the more efficient formulas (but still implemented in Python!) with 3D vectors and rotation matrices as proposed in Handbook of robotics \cite{Siciliano2016}, Chapter 3, but with the rotation matrices (\texttt{listOfRotations}) being transposed in the Python implementation as compared to the description in the book, being thus compliant with other Exudyn functions; the 3D vector/matrix Python implementation does not offer advantages as compared to the formulation with Pl\"ucker coordinates, BUT it reflects the formulas of the C++ implementation and is used for testing
-class KinematicTree33:
-    #**classFunction: initialize kinematic tree
-    #**input:
-    #  listOfJointTypes: mandatory list of joint types 'Rx', 'Ry', 'Rz' denoting revolute joints; 'Px', 'Py', 'Pz', denoting prismatic joints
-    #  listOfRotations: per link rotation matrix, transforming coordinates of the joint coordinate system w.r.t. the previous coordinate system (this is the inverse of Pl\"ucker coordinate transforms (6x6))
-    #  listOfOffsets: per link offset vector from pervious coordinate system to the joint coordinate system
-    #  listOfInertia3D: per link 3D inertia matrix, w.r.t.\ reference point (not COM!)
-    #  listOfCOM: per link vector from reference point to center of mass (COM), in link coordinates
-    #  listOfMass: mass per link
-    #  listOfParents: list of parent object indices (int), according to the index in jointTypes and transformations; use empty list for kinematic chain and use -1 if no parent exists (parent=base or world frame)
-    #  gravity: a 3D list/array containing the gravity applied to the kinematic tree (in world frame)
-    def __init__(self, 
-                 listOfJointTypes,
-                 listOfRotations,
-                 listOfOffsets,
-                 listOfInertia3D,
-                 listOfCOM, 
-                 listOfMass,
-                 listOfParents=[],
-                 gravity=[0,0,-9.81],
-                 ):
-        self.listOfJointTypes = listOfJointTypes
-        self.listOfRotations = listOfRotations
-        self.listOfOffsets = listOfOffsets
-        self.listOfInertia3D = listOfInertia3D
-        self.listOfCOM = listOfCOM
-        self.listOfMass = listOfMass
-        self.listOfParents = list(listOfParents)
-        self.gravity = np.array(gravity)
-
-        if len(self.listOfParents) == 0: #for kinematic chain, all joints are in a row
-            self.listOfParents = np.arange(-1,len(self.listOfJointTypes)-1)
-        else:
-            self.listOfParents = np.array(self.listOfParents)
-
-        if len(self.listOfJointTypes) != len(self.listOfRotations):
-            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfRotations')
-        if len(self.listOfJointTypes) != len(self.listOfOffsets):
-            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfOffsets')
-        if len(self.listOfJointTypes) != len(self.listOfParents):
-            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of parents (or parents may be empty)')
-        if len(self.listOfJointTypes) != len(self.listOfInertia3D):
-            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfInertia3D')
-        if len(self.listOfJointTypes) != len(self.listOfMass):
-            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfMass')
-        if len(self.listOfJointTypes) != len(self.listOfCOM):
-            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfCOM')
-
-        for i in range(len(listOfParents)):
-            if listOfParents[i] >= i:
-                raise ValueError('KinematicTree33: link / parent indices must be sorted such that parent indices always refer to a link with an index smaller than the current link (parent[i] < i)')
-    #**classFunction: return number of joints, defined by size of jointTypes
-    def Size(self):
-        return len(self.listOfJointTypes)
-    
-    #position of joint i is based on position of joint j, using offset %\pv_i%, $\LU{i}{\rv_i}=\LU{i}{\rv_j}+\LU{i}{\pv_i}$
-    #rotation of joint i relative to joint j is $\LU{ij}{\Am}$, rotation axis $\jv_j$ transformed by $\LU{i}{\jv_j} = \LU{ij}{\Am} \LU{j}{\jv_j}$
-    #**classFunction: return [A, p] containing rotation matrix and offset for joint j
-    def XL(self,i):
-        return [self.listOfRotations[i], self.listOfOffsets[i]]
-
-
-    #**classFunction: compute forward dynamics using composite rigid body algorithm
-    #**input:
-    #  q: joint space coordinates for the model at which the forward dynamics is evaluated
-    #  q_t: joint space velocity coordinates for the model at which the forward dynamics is evaluated
-    #  torques: a vector of torques applied at joint coordinates or list/array with zero length
-    #  forces: forces acting on the bodies using special format
-    #**output: returns acceleration vector q\_tt of joint coordinates
-    def ForwardDynamicsCRB(self, q=[], q_t=[], torques=[], forces=[]):
-        if forces != []:
-            raise ValueError('ForwardDynamicsCRB: forces not implemented')
-        
-        if len(torques) == 0:
-            torques = np.zeros(len(q))
-            
-        [M, fGeneralized] = self.ComputeMassMatrixAndForceTerms(q, q_t)
-        
-        return np.linalg.solve(M, torques - fGeneralized)
-    
-    
-    #**classFunction: compute generalized mass matrix M and generalized force terms for 
-    #            kinematic tree, using current state (joint) variables q and 
-    #            joint velocities q\_t. The generalized force terms f = fGeneralized
-    #            contain Coriolis and gravity if given in the kinematicTree.
-    #**input:
-    #  q: current joint coordinates
-    #  q_t: current joint velocities
-    #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
-    #**output: mass matrix $\Mm$ and RHS vector $\fv_{RHS}$ for equations of motion $M(q) \cdot q_{tt} + f(q,q_t,externalForces) = \tau$; RHS is $\fv_{RHS}=\tau - f(q,q_t,externalForces)$; $\tau$ can be added outside of \texttt{ComputeMassMatrixAndForceTerms}
-    def ComputeMassMatrixAndForceTerms(self, q, q_t, externalForces=[]):
-        #gravity6D = np.hstack((np.zeros(3),self.gravity))
-        n = self.Size()
-        
-        #initialize termporary matrices
-        #Rot = [np.zeros((3,3))]*n       #store rotation matrices
-        #Trans = [np.zeros(3)]*n     #store translation vectors
-        MSrot = [np.zeros(3)]*n     #motion subspace for rotation
-        MStrans = [np.zeros(3)]*n   #motion subspace for translation
-        XupRot = [np.zeros((3,3))]*n    #store link-joint rotation matrices
-        XupTrans = [np.zeros(3)]*n  #store link-joint translation vectors
-        vRot = [np.zeros(3)]*n     #store 3D joint angular velocity vectors
-        vTrans = [np.zeros(3)]*n     #store 3D joint velocity vectors
-        avpRot = [np.zeros(3)]*n   #store 3D joint angular acceleration vectors (rotation)
-        avpTrans = [np.zeros(3)]*n   #store 3D joint acceleration vectors (translation)
-        fvpRot = [np.zeros(3)]*n   #store 3D joint torque vectors for every body
-        fvpTrans = [np.zeros(3)]*n   #store 3D joint force vectors for every body
-        
-        #'recursively' compute transformations, accelerations and forces on parent joints
-        for i in range(n):
-            #[XJ, MS[i]] = JointTransformMotionSubspace(self.listOfJointTypes[i], q[i])
-            [XJrot, XJtrans, MSrot[i], MStrans[i]] = JointTransformMotionSubspace(self.listOfJointTypes[i], q[i])
-
-            #vJ = MS[i] * q_t[i]
-            vJrot = MSrot[i] * q_t[i]
-            vJtrans = MStrans[i] * q_t[i]
-
-            #Xup[i] = XJ @ self.XL(i)
-            [AL, tL] = self.XL(i)
-            AL = AL.T #AL transposed!
-            XupRot[i] = XJrot @ AL #X1*X2 = (R1*R2; p2+R2.T*p1)
-            XupTrans[i] = tL + AL.T @ XJtrans 
-            
-            if self.listOfParents[i] == -1:
-                #v[i] = vJ
-                vRot[i] = vJrot
-                vTrans[i] = vJtrans
-                #avp[i] = Xup[i] @ (-gravity6D)
-                avpRot[i] = np.zeros(3) #XupRot[i] @ omega = 0
-                avpTrans[i] = XupRot[i] @ (-self.gravity)
-            else:
-                #v[i] = Xup[i] @ v[self.listOfParents[i]] + vJ
-                vRot[i] = XupRot[i] @ vRot[self.listOfParents[i]] + vJrot
-                vTrans[i] = XupRot[i] @ (vTrans[self.listOfParents[i]] - np.cross(XupTrans[i],vRot[self.listOfParents[i]]) ) + vJtrans
-                #avp[i] = Xup[i] @ avp[self.listOfParents[i]] + CRM(v[i]) @ vJ
-                avpRot[i] = XupRot[i] @ avpRot[self.listOfParents[i]] + np.cross(vRot[i], vJrot)
-                avpTrans[i] = XupRot[i] @ (avpTrans[self.listOfParents[i]] - np.cross(XupTrans[i],avpRot[self.listOfParents[i]]) ) 
-                avpTrans[i] += np.cross(vTrans[i], vJrot) + np.cross(vRot[i], vJtrans)
-    
-            # print('vRot['+str(i)+']=',  vRot[i].round(4))
-            # print('vTra['+str(i)+']=',  vTrans[i].round(4))
-            # print('avpRot['+str(i)+']=',avpRot[i].round(4))
-            # print('avpTra['+str(i)+']=',avpTrans[i].round(4))
-            #continue with adaptation herehere!
-            #fvp[i] = self.inertias[i] @ avp[i] + CRF(v[i]) @ self.inertias[i] @ v[i] 
-            J = self.listOfInertia3D[i]
-            m = self.listOfMass[i]
-            h = m * self.listOfCOM[i]
-            JvRot = J @ vRot[i] + np.cross(h, vTrans[i])
-            JvTrans = m * vTrans[i] - np.cross(h, vRot[i])
-            
-            fvpRot[i] = J @ avpRot[i] + np.cross(h, avpTrans[i])
-            fvpRot[i] += np.cross(vRot[i], JvRot) + np.cross(vTrans[i], JvTrans)#CRF(v[i]) @ self.inertias[i] @ v[i] 
-            fvpTrans[i] = m * avpTrans[i] - np.cross(h, avpRot[i])
-            fvpTrans[i] += np.cross(vRot[i], JvTrans)  #CRF(v[i]) @ self.inertias[i] @ v[i] 
-    
-        # print('fvpRot =', fvpRot)
-        # print('fvpTrans =', fvpTrans)
-        #add external foces
-        #to be implemented
-        #fvp = self.AddExternalForces(Xup, fvp, externalForces)
-    
-        f = np.zeros(n)             #store joint forces
-        M = np.zeros((n,n))         #store mass matrix
-        #compute joint forces; REVERSED loop!
-        for i in reversed(range(n)):
-            f[i] = MSrot[i].T @ fvpRot[i] + MStrans[i].T @ fvpTrans[i]
-            if self.listOfParents[i] != -1:
-                #fvp[self.listOfParents[i]] += Xup[i].T @ fvp[i]
-                R = XupRot[i]
-                p = XupTrans[i]
-                fvpRot[self.listOfParents[i]] += R.T @ fvpRot[i] + np.cross(p, R.T@fvpTrans[i])
-                fvpTrans[self.listOfParents[i]] += R.T @ fvpTrans[i]
-
-        #compute composite inertia
-        #IC = deepcopy(self.inertias) #problems if identical np.array() used for several inertias!!!
-        ICinertia = [np.zeros((3,3))]*n
-        ICh = [np.zeros(3)]*n    
-        ICm = [0]*n    
-
-        for i in range(n):
-            ICinertia[i] = deepcopy(self.listOfInertia3D[i]) #deepcopy very slow!
-            ICm[i] = deepcopy(self.listOfMass[i])
-            ICh[i] = ICm[i] * deepcopy(self.listOfCOM[i])
-
-        # for i in range(n):
-        #     ICh[i] = ICm[i] * ICh[i]  #compute h=m*com
-        
-        for i in reversed(range(n)):
-            if self.listOfParents[i] != -1:
-                #IC[self.listOfParents[i]] += Xup[i].T @ IC[i] @ Xup[i]
-                R = XupRot[i]
-                p = XupTrans[i]
-                ICm[self.listOfParents[i]] += ICm[i]
-                ICh[self.listOfParents[i]] += R.T @ ICh[i] + ICm[i]*p
-                ICinertia[self.listOfParents[i]] += R.T @ ICinertia[i] @ R - erb.Skew(p)@erb.Skew(R.T @ ICh[i]) - erb.Skew(R.T@ICh[i] + ICm[i]*p) @ erb.Skew(p)
-
-        # for i in range(n):
-        #     print('IC'+str(i)+'m=',ICm[i])
-        #     print('ICh'+str(i)+'=',ICh[i])
-        #     print('ICinertia'+str(i)+'=',ICinertia[i])
-    
-        #compute generalized mass matrix and projected inertia
-        for i in range(n):
-            #fh = IC[i] @ MS[i]
-            fhRot = ICinertia[i] @ MSrot[i] + np.cross(ICh[i], MStrans[i])
-            fhTrans = m*MStrans[i] - np.cross(ICh[i], MSrot[i])
-            #M[i,i] = MS[i].T @ fh
-            M[i,i] = MSrot[i].T @ fhRot + MStrans[i].T @ fhTrans
-            j = i
-            while self.listOfParents[j] > -1:
-                #fh = Xup[j].T @ fh
-                R = XupRot[j]
-                p = XupTrans[j]
-                fhRot = R.T @ fhRot + np.cross(p, R.T@fhTrans)
-                fhTrans = R.T @ fhTrans
-                j = self.listOfParents[j]
-                #M[i,j] = MS[j].T @ fh
-                M[i,j] = MSrot[j].T @ fhRot + MStrans[j].T @ fhTrans
-                M[j,i] = M[i,j]
-    
-        return [M, f]
-    
-    
-    # #**classFunction: add action of external forces to forces fvp and return new composed vector of forces fvp
-    # #**input:
-    # #  Xup: 6x6 transformation matrices per joint; as computed in ComputeMassMatrixAndForceTerms
-    # #  fvp: force (torque) per joint, as computed in ComputeMassMatrixAndForceTerms
-    # #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
-    # def AddExternalForces(self, Xup, fvp, externalForces=[]):
-    #     fvpOut = fvp #np.zeros(n)
-    #     if len(externalForces): #only consider forces, if not empty list
-    #         n = len(self.listOfParents)
-    #         Xa = [np.zeros((6,6))]*n
-    #         for i in range(n):
-    #             if self.listOfParents[i] == -1:
-    #                 Xa[i] = Xup[i]
-    #             else:
-    #                 Xa[i] = Xup[i] * Xa[self.listOfParents[i]];
-    #             if len(externalForces[i].shape) == 1:
-    #                 fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i])
-    #             else:
-    #                 raise ValueError('KinematicTree33.AddExternalForces: unchecked code for multiple forces')
-    #                 for j in range(len(externalForces[i].shape[1])): #loop over several vectors
-    #                     fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i][:,j])
-    
-    #     return fvpOut
-        
-    
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: computes cross product operator for motion from 6D vector v; CRM(v) @ m computes the cross product of v and motion m
-def CRM(v):
-      return np.array([[0   , -v[2] , v[1]  , 0    , 0    , 0    ],
-                       [ v[2],  0    ,-v[0]  , 0    , 0    , 0    ],
-                       [-v[1],  v[0] , 0     , 0    , 0    , 0    ],
-                       [ 0   , -v[5] , v[4]  , 0    ,-v[2] , v[1] ],
-                       [ v[5],  0    ,-v[3]  , v[2] , 0    ,-v[0] ],
-                       [-v[4],  v[3] , 0     ,-v[1] , v[0] , 0    ] ])
-
-#**function: computes cross product operator for force from 6D vector v; CRF(v) @ f computes the cross product of v and force f
-def CRF(v):
-    return -CRM(v).T
-
-
-
-#definition of a kinematic tree
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: class to define a kinematic tree, which can be used for building serial or tree-structured multibody systems 
-#         (or robots) with a minimal coordinates formulation, using Pl\"ucker coordinate transforms (6x6); for efficient computation, use the C++ ObjectKinematicTree
-#**notes:
-#   The formulation and structures widely follow Roy Featherstone (http://royfeatherstone.org/) / Handbook of robotics \cite{Siciliano2016} 
-class KinematicTree66:
-    #**classFunction: initialize kinematic tree
-    #**input:
-    #  listOfJointTypes: mandatory list of joint types 'Rx', 'Ry', 'Rz' denoting revolute joints; 'Px', 'Py', 'Pz', denoting prismatic joints
-    #  listOfTransformations: provide a list of Pl\"ucker coordinate transforms (6x6 numpy matrices), describing the (constant) link transformation from the link coordinate system (previous/parent joint) to this joint coordinate system
-    #  listOfInertias: provide a list of inertias as (6x6 numpy matrices), as produced by the function MassCOMinertia2T66
-    #  listOfParents: list of parent object indices (int), according to the index in jointTypes and transformations; use empty list for kinematic chain and use -1 if no parent exists (parent=base or world frame)
-    #  gravity: a 3D list/array containing the gravity applied to the kinematic tree (in world frame)
-    def __init__(self, 
-                 listOfJointTypes,
-                 listOfTransformations, 
-                 listOfInertias, 
-                 listOfParents=[],
-                 gravity=[0,0,-9.81],
-                 ):
-        self.jointTypes = listOfJointTypes
-        self.transformations = listOfTransformations
-        self.inertias = listOfInertias
-        self.parents = listOfParents
-        self.gravity = np.array(gravity)
-
-        if len(self.parents) == 0: #for kinematic chain, all joints are in a row
-            self.parents = np.arange(-1,len(self.jointTypes)-1)
-        else:
-            self.parents = np.array(self.parents)
-
-        if len(self.jointTypes) != len(self.transformations):
-            raise ValueError('KinematicTree66: length of jointTypes must agree with length of transformations')
-        if len(self.jointTypes) != len(self.parents):
-            raise ValueError('KinematicTree66: length of jointTypes must agree with length of parents (or parents may be empty)')
-        if len(self.jointTypes) != len(self.inertias):
-            raise ValueError('KinematicTree66: length of jointTypes must agree with length of inertias')
-
-        for i in range(len(listOfParents)):
-            if listOfParents[i] >= i:
-                raise ValueError('KinematicTree66: link / parent indices must be sorted such that parent indices always refer to a link with an index smaller than the current link (parent[i] < i)')
-    #**classFunction: return number of joints, defined by size of jointTypes
-    def Size(self):
-        return len(self.jointTypes)
-    
-    #**classFunction: return 6D transformation of joint i, given by transformation
-    def XL(self,i):
-        return self.transformations[i]
-
-
-    #**classFunction: compute forward dynamics using composite rigid body algorithm
-    #**input:
-    #  q: joint space coordinates for the model at which the forward dynamics is evaluated
-    #  q_t: joint space velocity coordinates for the model at which the forward dynamics is evaluated
-    #  torques: a vector of torques applied at joint coordinates or list/array with zero length
-    #  forces: forces acting on the bodies using special format
-    #**output: returns acceleration vector q\_tt of joint coordinates
-    def ForwardDynamicsCRB(self, q=[], q_t=[], torques=[], forces=[]):
-        if forces != []:
-            raise ValueError('ForwardDynamicsCRB: forces not implemented')
-        
-        if len(torques) == 0:
-            torques = np.zeros(len(q))
-            
-        [M, fGeneralized] = self.ComputeMassMatrixAndForceTerms(q, q_t)
-        
-        return np.linalg.solve(M, torques - fGeneralized)
-    
-    
-    #**classFunction: compute generalized mass matrix M and generalized force terms for 
-    #            kinematic tree, using current state (joint) variables q and 
-    #            joint velocities q\_t. The generalized force terms f = fGeneralized
-    #            contain Coriolis and gravity if given in the kinematicTree.
-    #**input:
-    #  q: current joint coordinates
-    #  q_t: current joint velocities
-    #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
-    #**output: mass matrix $\Mm$ and RHS vector $\fv_{RHS}$ for equations of motion $M(q) \cdot q_{tt} + f(q,q_t,externalForces) = \tau$; RHS is $\fv_{RHS}=\tau - f(q,q_t,externalForces)$; $\tau$ can be added outside of \texttt{ComputeMassMatrixAndForceTerms}
-    def ComputeMassMatrixAndForceTerms(self, q, q_t, externalForces=[]):
-        gravity6D = np.hstack((np.zeros(3),self.gravity))
-        n = self.Size()
-        
-        #initialize termporary matrices
-        MS = [np.zeros((6))]*n      #store motion supspaces
-        Xup = [np.zeros((6,6))]*n   #store link-joint transformation matrices
-        v = [np.zeros(6)]*n     #store 6D joint velocity vectors
-        fvp = [np.zeros(6)]*n   #store 6D joint force vectors for every body
-        avp = [np.zeros(6)]*n   #store 6D joint acceleration vectors
-        
-        #'recursively' compute transformations, accelerations and forces on parent joints
-        for i in range(n):
-            [XJ, MS[i]] = JointTransformMotionSubspace66(self.jointTypes[i], q[i])
-            vJ = MS[i] * q_t[i]
-            Xup[i] = XJ @ self.XL(i)
-            if self.parents[i] == -1:
-                v[i] = vJ
-                avp[i] = Xup[i] @ (-gravity6D)
-            else:
-                v[i] = Xup[i] @ v[self.parents[i]] + vJ
-                avp[i] = Xup[i] @ avp[self.parents[i]] + CRM(v[i]) @ vJ
-    
-            fvp[i] = self.inertias[i] @ avp[i] + CRF(v[i]) @ self.inertias[i] @ v[i] 
-
-            # print("Xup"+str(i)+"=",Xup[i])
-            # print("MS"+str(i)+"=",MS[i])
-            # print("IC"+str(i)+"=",self.inertias[i])
-            # print("CRF"+str(i)+"=",CRF(v[i]))
-            # print("v"+str(i)+"=",v[i])
-            # print("avp"+str(i)+"=",avp[i])
-            # print('fvp['+str(i)+']=',fvp[i].round(8))
-    
-        #add external foces
-        fvp = self.AddExternalForces(Xup, fvp, externalForces)
-    
-        f = np.zeros(n)             #store joint forces
-        M = np.zeros((n,n))         #store mass matrix
-        #compute joint forces; REVERSED loop!
-        for i in reversed(range(n)):
-            f[i] = MS[i].T @ fvp[i]
-            if self.parents[i] != -1:
-                fvp[self.parents[i]] += Xup[i].T @ fvp[i]
-    
-        #compute composite inertia
-        #IC = deepcopy(self.inertias) #may cause problems if referenced np.arrays used!
-        IC = [np.zeros((6,6))]*n
-
-        for i in range(n):
-            IC[i] = deepcopy(self.inertias[i])
-        
-        for i in reversed(range(n)):
-            if self.parents[i] != -1:
-                IC[self.parents[i]] += Xup[i].T @ IC[i] @ Xup[i]
-
-        #compute generalized mass matrix and projected inertia
-        for i in range(n):
-            fh = IC[i] @ MS[i]
-            M[i,i] = MS[i].T @ fh
-            j = i
-            while self.parents[j] > -1:
-                fh = Xup[j].T @ fh
-                j = self.parents[j]
-                M[i,j] = MS[j].T @ fh
-                M[j,i] = M[i,j]
-    
-        return [M, f]
-    
-    
-    #**classFunction: add action of external forces to forces fvp and return new composed vector of forces fvp
-    #**input:
-    #  Xup: 6x6 transformation matrices per joint; as computed in ComputeMassMatrixAndForceTerms
-    #  fvp: force (torque) per joint, as computed in ComputeMassMatrixAndForceTerms
-    #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
-    def AddExternalForces(self, Xup, fvp, externalForces=[]):
-        fvpOut = fvp #np.zeros(n)
-        if len(externalForces): #only consider forces, if not empty list
-            n = len(self.parents)
-            Xa = [np.zeros((6,6))]*n
-            for i in range(n):
-                if self.parents[i] == -1:
-                    Xa[i] = Xup[i]
-                else:
-                    Xa[i] = Xup[i] * Xa[self.parents[i]];
-                if len(externalForces[i].shape) == 1:
-                    fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i])
-                else:
-                    raise ValueError('KinematicTree66.AddExternalForces: unchecked code for multiple forces')
-                    for j in range(len(externalForces[i].shape[1])): #loop over several vectors
-                        fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i][:,j])
-    
-        return fvpOut
-        
-    
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  A library for preparation of minimal coordinates (kinematic tree) formulation.
+#           This library follows mostly the algorithms of Roy Featherstone, see http://royfeatherstone.org/
+#           His code is availble in MATLAB as well as described in the Springer Handbook of Robotics \cite{Siciliano2016}.
+#           The main formalisms are based on 6x6 matrices, so-called Pl\"ucker transformations, denoted as \ac{T66}, as defined by Featherstone.
+#
+# Author:   Johannes Gerstmayr
+# Date:     2021-06-22
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#constants and fixed structures:
+import numpy as np
+#from math import pi, sin, cos#, sqrt
+from copy import deepcopy
+
+#import exudyn as exu
+import exudyn.rigidBodyUtilities as erb
+#from exudyn.robotics import *
+
+#check with Corke Toolbox:
+# https://github.com/petercorke/spatialmath-python
+# https://github.com/petercorke/robotics-toolbox-python
+
+
+#the following functions are defined here to fit into the original Featherstone algorithm
+#rotations are transposed / inverse
+def RotationX2T66Inverse(angle):
+    return erb.RotationX2T66(angle).T
+
+#the following functions are defined here to fit into the original Featherstone algorithm
+#rotations are transposed / inverse
+def RotationY2T66Inverse(angle):
+    return erb.RotationY2T66(angle).T
+
+#the following functions are defined here to fit into the original Featherstone algorithm
+#rotations are transposed / inverse
+def RotationZ2T66Inverse(angle):
+    return erb.RotationZ2T66(angle).T
+
+#compute inverse 6x6 transformation matrix for translation along X axis; output: first 3 components for rotation, second 3 components for translation!
+def TranslationX2T66Inverse(translation):
+    return erb.Translation2T66([-translation,0,0])
+
+#compute inverse 6x6 transformation matrix for translation along Y axis; output: first 3 components for rotation, second 3 components for translation!
+def TranslationY2T66Inverse(translation):
+    return erb.Translation2T66([0,-translation,0])
+
+#compute inverse 6x6 transformation matrix for translation along Z axis; output: first 3 components for rotation, second 3 components for translation!
+def TranslationZ2T66Inverse(translation):
+    return erb.Translation2T66([0,0,-translation])
+
+
+
+#**function: convert mass, COM and inertia into 6x6 inertia matrix
+#**input:
+#  mass: scalar mass
+#  centerOfMass: 3D vector (list/array)
+#  inertia: 3x3 matrix (list of lists / 2D array) w.r.t. center of mass
+#**output: 6x6 numpy array for further use in minimal coordinates formulation
+def MassCOMinertia2T66(mass, centerOfMass, inertia):
+    C = erb.Skew(centerOfMass)
+    return np.block([
+        [inertia + mass*(C @ C.T), mass*C],
+        [mass*C.T, mass*np.eye(3) ]])
+
+#**function: convert inertia as produced with RigidBodyInertia class into 6x6 inertia matrix (as used in KinematicTree66, Featherstone / Handbook of robotics \cite{Siciliano2016})
+#**notes: within the 6x6 matrix, the inertia tensor is defined w.r.t.\ the center of mass, while RigidBodyInertia defines the inertia tensor w.r.t.\ the reference point; however, this function correctly transforms all quantities of inertia.
+#**output: 6x6 numpy array for further use in minimal coordinates formulation
+def Inertia2T66(inertia):
+    C = erb.Skew(inertia.com)
+    mass = inertia.mass
+    #inertiaCOM = inertia.Translated(-inertia.com).inertiaTensor
+    inertiaCOM = inertia.InertiaCOM()
+    #alternatively, we could just use inertia.Inertia() in first block!
+    return np.block([
+        [inertiaCOM + mass*(C @ C.T), mass*C],
+        [mass*C.T, mass*np.eye(3) ]])
+
+#**function: convert 6x6 inertia matrix into mass, COM and inertia 
+#**input: 6x6 numpy array containing rigid body inertia according to Featherstone / Handbook of robotics \cite{Siciliano2016}
+#**output: [mass, centerOfMass, inertia]
+#  mass: scalar mass
+#  centerOfMass: 3D vector (list/array)
+#  inertia: 3x3 matrix (list of lists / 2D array) w.r.t. center of mass
+def Inertia66toMassCOMinertia(inertia66):
+    mass = inertia66[5,5]
+    massCOM = inertia66[0:3,3:6]
+    centerOfMass = erb.Skew2Vec(massCOM)/mass
+    inertia = inertia66[0:3,0:3] - massCOM @ massCOM.T/mass;
+
+    return [mass, centerOfMass, inertia]
+
+
+#define dictionary for joint transformations, as there is no switch case statement in Python
+dictOfJointTransformMotionSubspace66 = {
+    'Rx':[RotationX2T66Inverse,   np.array([1,0,0,0,0,0])], #revolute joint for local X axis
+    'Ry':[RotationY2T66Inverse,   np.array([0,1,0,0,0,0])], #revolute joint for local Y axis
+    'Rz':[RotationZ2T66Inverse,   np.array([0,0,1,0,0,0])], #revolute joint for local Z axis
+    'Px':[TranslationX2T66Inverse, np.array([0,0,0,1,0,0])], #prismatic joint for local X axis
+    'Py':[TranslationY2T66Inverse, np.array([0,0,0,0,1,0])], #prismatic joint for local Y axis
+    'Pz':[TranslationZ2T66Inverse, np.array([0,0,0,0,0,1])], #prismatic joint for local Z axis
+    #helical and planar joints available in Featherstone's implementation
+    }
+
+#**function: return 6x6 Pl\"ucker joint transformation matrix evaluated for scalar joint coordinate q and motion subspace ('free modes' in Table 2.6 in Handbook of robotics \cite{Siciliano2016})
+def JointTransformMotionSubspace66(jointType, q):
+    [T,MS] = dictOfJointTransformMotionSubspace66[jointType]
+    return [T(q), MS]
+        
+
+#unit matrix needed for dictOfJointRotationMatrixAxis
+# def UnitMatrix3D():
+#     return np.eye(3)
+
+#define dictionary for joint transformations, as there is no switch case statement in Python
+#using rotation matrix, translation (for prismatic joints), joint axes (rot, trans)
+dictOfJointRotationMatrixAxis = {
+    'Rx':[erb.RotationMatrixX, np.array([0,0,0]), np.array([1,0,0]), np.array([0,0,0])], #revolute joint for local X axis
+    'Ry':[erb.RotationMatrixY, np.array([0,0,0]), np.array([0,1,0]), np.array([0,0,0])], #revolute joint for local Y axis
+    'Rz':[erb.RotationMatrixZ, np.array([0,0,0]), np.array([0,0,1]), np.array([0,0,0])], #revolute joint for local Z axis
+    'Px':[0,               np.array([1,0,0]), np.array([0,0,0]), np.array([1,0,0])], #prismatic joint for local X axis
+    'Py':[0,               np.array([0,1,0]), np.array([0,0,0]), np.array([0,1,0])], #prismatic joint for local Y axis
+    'Pz':[0,               np.array([0,0,1]), np.array([0,0,0]), np.array([0,0,1])], #prismatic joint for local Z axis
+    }
+
+#**function: return list containing rotation matrix, translation vector, rotation axis and translation axis for joint transformation
+def JointTransformMotionSubspace(jointType, q):
+    [A, v, rotAxis, transAxis] = dictOfJointRotationMatrixAxis[jointType]
+    if jointType[0] == 'R':
+        return [A(q).T, v, rotAxis, transAxis] #transposed needed as compared to RotationMatrixX, as the algorithm requires coordinate transforms instead of active rotation matrices
+    else: #prismatic
+        return [np.eye(3), v*q, rotAxis, transAxis]
+        
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#definition of a kinematic tree
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: class to define a kinematic tree in Python, which can be used for building serial or tree-structured multibody systems 
+#         (or robots) with a minimal coordinates formulation, using rotation matrices and 3D offsets; for efficient computation, use the C++ ObjectKinematicTree
+#**notes:
+#   The formulation and structures widely follows the more efficient formulas (but still implemented in Python!) with 3D vectors and rotation matrices as proposed in Handbook of robotics \cite{Siciliano2016}, Chapter 3, but with the rotation matrices (\texttt{listOfRotations}) being transposed in the Python implementation as compared to the description in the book, being thus compliant with other Exudyn functions; the 3D vector/matrix Python implementation does not offer advantages as compared to the formulation with Pl\"ucker coordinates, BUT it reflects the formulas of the C++ implementation and is used for testing
+class KinematicTree33:
+    #**classFunction: initialize kinematic tree
+    #**input:
+    #  listOfJointTypes: mandatory list of joint types 'Rx', 'Ry', 'Rz' denoting revolute joints; 'Px', 'Py', 'Pz', denoting prismatic joints
+    #  listOfRotations: per link rotation matrix, transforming coordinates of the joint coordinate system w.r.t. the previous coordinate system (this is the inverse of Pl\"ucker coordinate transforms (6x6))
+    #  listOfOffsets: per link offset vector from pervious coordinate system to the joint coordinate system
+    #  listOfInertia3D: per link 3D inertia matrix, w.r.t.\ reference point (not COM!)
+    #  listOfCOM: per link vector from reference point to center of mass (COM), in link coordinates
+    #  listOfMass: mass per link
+    #  listOfParents: list of parent object indices (int), according to the index in jointTypes and transformations; use empty list for kinematic chain and use -1 if no parent exists (parent=base or world frame)
+    #  gravity: a 3D list/array containing the gravity applied to the kinematic tree (in world frame)
+    def __init__(self, 
+                 listOfJointTypes,
+                 listOfRotations,
+                 listOfOffsets,
+                 listOfInertia3D,
+                 listOfCOM, 
+                 listOfMass,
+                 listOfParents=[],
+                 gravity=[0,0,-9.81],
+                 ):
+        self.listOfJointTypes = listOfJointTypes
+        self.listOfRotations = listOfRotations
+        self.listOfOffsets = listOfOffsets
+        self.listOfInertia3D = listOfInertia3D
+        self.listOfCOM = listOfCOM
+        self.listOfMass = listOfMass
+        self.listOfParents = list(listOfParents)
+        self.gravity = np.array(gravity)
+
+        if len(self.listOfParents) == 0: #for kinematic chain, all joints are in a row
+            self.listOfParents = np.arange(-1,len(self.listOfJointTypes)-1)
+        else:
+            self.listOfParents = np.array(self.listOfParents)
+
+        if len(self.listOfJointTypes) != len(self.listOfRotations):
+            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfRotations')
+        if len(self.listOfJointTypes) != len(self.listOfOffsets):
+            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfOffsets')
+        if len(self.listOfJointTypes) != len(self.listOfParents):
+            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of parents (or parents may be empty)')
+        if len(self.listOfJointTypes) != len(self.listOfInertia3D):
+            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfInertia3D')
+        if len(self.listOfJointTypes) != len(self.listOfMass):
+            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfMass')
+        if len(self.listOfJointTypes) != len(self.listOfCOM):
+            raise ValueError('KinematicTree33: length of listOfJointTypes must agree with length of listOfCOM')
+
+        for i in range(len(listOfParents)):
+            if listOfParents[i] >= i:
+                raise ValueError('KinematicTree33: link / parent indices must be sorted such that parent indices always refer to a link with an index smaller than the current link (parent[i] < i)')
+    #**classFunction: return number of joints, defined by size of jointTypes
+    def Size(self):
+        return len(self.listOfJointTypes)
+    
+    #position of joint i is based on position of joint j, using offset %\pv_i%, $\LU{i}{\rv_i}=\LU{i}{\rv_j}+\LU{i}{\pv_i}$
+    #rotation of joint i relative to joint j is $\LU{ij}{\Am}$, rotation axis $\jv_j$ transformed by $\LU{i}{\jv_j} = \LU{ij}{\Am} \LU{j}{\jv_j}$
+    #**classFunction: return [A, p] containing rotation matrix and offset for joint j
+    def XL(self,i):
+        return [self.listOfRotations[i], self.listOfOffsets[i]]
+
+
+    #**classFunction: compute forward dynamics using composite rigid body algorithm
+    #**input:
+    #  q: joint space coordinates for the model at which the forward dynamics is evaluated
+    #  q_t: joint space velocity coordinates for the model at which the forward dynamics is evaluated
+    #  torques: a vector of torques applied at joint coordinates or list/array with zero length
+    #  forces: forces acting on the bodies using special format
+    #**output: returns acceleration vector q\_tt of joint coordinates
+    def ForwardDynamicsCRB(self, q=[], q_t=[], torques=[], forces=[]):
+        if forces != []:
+            raise ValueError('ForwardDynamicsCRB: forces not implemented')
+        
+        if len(torques) == 0:
+            torques = np.zeros(len(q))
+            
+        [M, fGeneralized] = self.ComputeMassMatrixAndForceTerms(q, q_t)
+        
+        return np.linalg.solve(M, torques - fGeneralized)
+    
+    
+    #**classFunction: compute generalized mass matrix M and generalized force terms for 
+    #            kinematic tree, using current state (joint) variables q and 
+    #            joint velocities q\_t. The generalized force terms f = fGeneralized
+    #            contain Coriolis and gravity if given in the kinematicTree.
+    #**input:
+    #  q: current joint coordinates
+    #  q_t: current joint velocities
+    #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
+    #**output: mass matrix $\Mm$ and RHS vector $\fv_{RHS}$ for equations of motion $M(q) \cdot q_{tt} + f(q,q_t,externalForces) = \tau$; RHS is $\fv_{RHS}=\tau - f(q,q_t,externalForces)$; $\tau$ can be added outside of \texttt{ComputeMassMatrixAndForceTerms}
+    def ComputeMassMatrixAndForceTerms(self, q, q_t, externalForces=[]):
+        #gravity6D = np.hstack((np.zeros(3),self.gravity))
+        n = self.Size()
+        
+        #initialize termporary matrices
+        #Rot = [np.zeros((3,3))]*n       #store rotation matrices
+        #Trans = [np.zeros(3)]*n     #store translation vectors
+        MSrot = [np.zeros(3)]*n     #motion subspace for rotation
+        MStrans = [np.zeros(3)]*n   #motion subspace for translation
+        XupRot = [np.zeros((3,3))]*n    #store link-joint rotation matrices
+        XupTrans = [np.zeros(3)]*n  #store link-joint translation vectors
+        vRot = [np.zeros(3)]*n     #store 3D joint angular velocity vectors
+        vTrans = [np.zeros(3)]*n     #store 3D joint velocity vectors
+        avpRot = [np.zeros(3)]*n   #store 3D joint angular acceleration vectors (rotation)
+        avpTrans = [np.zeros(3)]*n   #store 3D joint acceleration vectors (translation)
+        fvpRot = [np.zeros(3)]*n   #store 3D joint torque vectors for every body
+        fvpTrans = [np.zeros(3)]*n   #store 3D joint force vectors for every body
+        
+        #'recursively' compute transformations, accelerations and forces on parent joints
+        for i in range(n):
+            #[XJ, MS[i]] = JointTransformMotionSubspace(self.listOfJointTypes[i], q[i])
+            [XJrot, XJtrans, MSrot[i], MStrans[i]] = JointTransformMotionSubspace(self.listOfJointTypes[i], q[i])
+
+            #vJ = MS[i] * q_t[i]
+            vJrot = MSrot[i] * q_t[i]
+            vJtrans = MStrans[i] * q_t[i]
+
+            #Xup[i] = XJ @ self.XL(i)
+            [AL, tL] = self.XL(i)
+            AL = AL.T #AL transposed!
+            XupRot[i] = XJrot @ AL #X1*X2 = (R1*R2; p2+R2.T*p1)
+            XupTrans[i] = tL + AL.T @ XJtrans 
+            
+            if self.listOfParents[i] == -1:
+                #v[i] = vJ
+                vRot[i] = vJrot
+                vTrans[i] = vJtrans
+                #avp[i] = Xup[i] @ (-gravity6D)
+                avpRot[i] = np.zeros(3) #XupRot[i] @ omega = 0
+                avpTrans[i] = XupRot[i] @ (-self.gravity)
+            else:
+                #v[i] = Xup[i] @ v[self.listOfParents[i]] + vJ
+                vRot[i] = XupRot[i] @ vRot[self.listOfParents[i]] + vJrot
+                vTrans[i] = XupRot[i] @ (vTrans[self.listOfParents[i]] - np.cross(XupTrans[i],vRot[self.listOfParents[i]]) ) + vJtrans
+                #avp[i] = Xup[i] @ avp[self.listOfParents[i]] + CRM(v[i]) @ vJ
+                avpRot[i] = XupRot[i] @ avpRot[self.listOfParents[i]] + np.cross(vRot[i], vJrot)
+                avpTrans[i] = XupRot[i] @ (avpTrans[self.listOfParents[i]] - np.cross(XupTrans[i],avpRot[self.listOfParents[i]]) ) 
+                avpTrans[i] += np.cross(vTrans[i], vJrot) + np.cross(vRot[i], vJtrans)
+    
+            # print('vRot['+str(i)+']=',  vRot[i].round(4))
+            # print('vTra['+str(i)+']=',  vTrans[i].round(4))
+            # print('avpRot['+str(i)+']=',avpRot[i].round(4))
+            # print('avpTra['+str(i)+']=',avpTrans[i].round(4))
+            #continue with adaptation herehere!
+            #fvp[i] = self.inertias[i] @ avp[i] + CRF(v[i]) @ self.inertias[i] @ v[i] 
+            J = self.listOfInertia3D[i]
+            m = self.listOfMass[i]
+            h = m * self.listOfCOM[i]
+            JvRot = J @ vRot[i] + np.cross(h, vTrans[i])
+            JvTrans = m * vTrans[i] - np.cross(h, vRot[i])
+            
+            fvpRot[i] = J @ avpRot[i] + np.cross(h, avpTrans[i])
+            fvpRot[i] += np.cross(vRot[i], JvRot) + np.cross(vTrans[i], JvTrans)#CRF(v[i]) @ self.inertias[i] @ v[i] 
+            fvpTrans[i] = m * avpTrans[i] - np.cross(h, avpRot[i])
+            fvpTrans[i] += np.cross(vRot[i], JvTrans)  #CRF(v[i]) @ self.inertias[i] @ v[i] 
+    
+        # print('fvpRot =', fvpRot)
+        # print('fvpTrans =', fvpTrans)
+        #add external foces
+        #to be implemented
+        #fvp = self.AddExternalForces(Xup, fvp, externalForces)
+    
+        f = np.zeros(n)             #store joint forces
+        M = np.zeros((n,n))         #store mass matrix
+        #compute joint forces; REVERSED loop!
+        for i in reversed(range(n)):
+            f[i] = MSrot[i].T @ fvpRot[i] + MStrans[i].T @ fvpTrans[i]
+            if self.listOfParents[i] != -1:
+                #fvp[self.listOfParents[i]] += Xup[i].T @ fvp[i]
+                R = XupRot[i]
+                p = XupTrans[i]
+                fvpRot[self.listOfParents[i]] += R.T @ fvpRot[i] + np.cross(p, R.T@fvpTrans[i])
+                fvpTrans[self.listOfParents[i]] += R.T @ fvpTrans[i]
+
+        #compute composite inertia
+        #IC = deepcopy(self.inertias) #problems if identical np.array() used for several inertias!!!
+        ICinertia = [np.zeros((3,3))]*n
+        ICh = [np.zeros(3)]*n    
+        ICm = [0]*n    
+
+        for i in range(n):
+            ICinertia[i] = deepcopy(self.listOfInertia3D[i]) #deepcopy very slow!
+            ICm[i] = deepcopy(self.listOfMass[i])
+            ICh[i] = ICm[i] * deepcopy(self.listOfCOM[i])
+
+        # for i in range(n):
+        #     ICh[i] = ICm[i] * ICh[i]  #compute h=m*com
+        
+        for i in reversed(range(n)):
+            if self.listOfParents[i] != -1:
+                #IC[self.listOfParents[i]] += Xup[i].T @ IC[i] @ Xup[i]
+                R = XupRot[i]
+                p = XupTrans[i]
+                ICm[self.listOfParents[i]] += ICm[i]
+                ICh[self.listOfParents[i]] += R.T @ ICh[i] + ICm[i]*p
+                ICinertia[self.listOfParents[i]] += R.T @ ICinertia[i] @ R - erb.Skew(p)@erb.Skew(R.T @ ICh[i]) - erb.Skew(R.T@ICh[i] + ICm[i]*p) @ erb.Skew(p)
+
+        # for i in range(n):
+        #     print('IC'+str(i)+'m=',ICm[i])
+        #     print('ICh'+str(i)+'=',ICh[i])
+        #     print('ICinertia'+str(i)+'=',ICinertia[i])
+    
+        #compute generalized mass matrix and projected inertia
+        for i in range(n):
+            #fh = IC[i] @ MS[i]
+            fhRot = ICinertia[i] @ MSrot[i] + np.cross(ICh[i], MStrans[i])
+            fhTrans = m*MStrans[i] - np.cross(ICh[i], MSrot[i])
+            #M[i,i] = MS[i].T @ fh
+            M[i,i] = MSrot[i].T @ fhRot + MStrans[i].T @ fhTrans
+            j = i
+            while self.listOfParents[j] > -1:
+                #fh = Xup[j].T @ fh
+                R = XupRot[j]
+                p = XupTrans[j]
+                fhRot = R.T @ fhRot + np.cross(p, R.T@fhTrans)
+                fhTrans = R.T @ fhTrans
+                j = self.listOfParents[j]
+                #M[i,j] = MS[j].T @ fh
+                M[i,j] = MSrot[j].T @ fhRot + MStrans[j].T @ fhTrans
+                M[j,i] = M[i,j]
+    
+        return [M, f]
+    
+    
+    # #**classFunction: add action of external forces to forces fvp and return new composed vector of forces fvp
+    # #**input:
+    # #  Xup: 6x6 transformation matrices per joint; as computed in ComputeMassMatrixAndForceTerms
+    # #  fvp: force (torque) per joint, as computed in ComputeMassMatrixAndForceTerms
+    # #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
+    # def AddExternalForces(self, Xup, fvp, externalForces=[]):
+    #     fvpOut = fvp #np.zeros(n)
+    #     if len(externalForces): #only consider forces, if not empty list
+    #         n = len(self.listOfParents)
+    #         Xa = [np.zeros((6,6))]*n
+    #         for i in range(n):
+    #             if self.listOfParents[i] == -1:
+    #                 Xa[i] = Xup[i]
+    #             else:
+    #                 Xa[i] = Xup[i] * Xa[self.listOfParents[i]];
+    #             if len(externalForces[i].shape) == 1:
+    #                 fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i])
+    #             else:
+    #                 raise ValueError('KinematicTree33.AddExternalForces: unchecked code for multiple forces')
+    #                 for j in range(len(externalForces[i].shape[1])): #loop over several vectors
+    #                     fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i][:,j])
+    
+    #     return fvpOut
+        
+    
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: computes cross product operator for motion from 6D vector v; CRM(v) @ m computes the cross product of v and motion m
+def CRM(v):
+      return np.array([[0   , -v[2] , v[1]  , 0    , 0    , 0    ],
+                       [ v[2],  0    ,-v[0]  , 0    , 0    , 0    ],
+                       [-v[1],  v[0] , 0     , 0    , 0    , 0    ],
+                       [ 0   , -v[5] , v[4]  , 0    ,-v[2] , v[1] ],
+                       [ v[5],  0    ,-v[3]  , v[2] , 0    ,-v[0] ],
+                       [-v[4],  v[3] , 0     ,-v[1] , v[0] , 0    ] ])
+
+#**function: computes cross product operator for force from 6D vector v; CRF(v) @ f computes the cross product of v and force f
+def CRF(v):
+    return -CRM(v).T
+
+
+
+#definition of a kinematic tree
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: class to define a kinematic tree, which can be used for building serial or tree-structured multibody systems 
+#         (or robots) with a minimal coordinates formulation, using Pl\"ucker coordinate transforms (6x6); for efficient computation, use the C++ ObjectKinematicTree
+#**notes:
+#   The formulation and structures widely follow Roy Featherstone (http://royfeatherstone.org/) / Handbook of robotics \cite{Siciliano2016} 
+class KinematicTree66:
+    #**classFunction: initialize kinematic tree
+    #**input:
+    #  listOfJointTypes: mandatory list of joint types 'Rx', 'Ry', 'Rz' denoting revolute joints; 'Px', 'Py', 'Pz', denoting prismatic joints
+    #  listOfTransformations: provide a list of Pl\"ucker coordinate transforms (6x6 numpy matrices), describing the (constant) link transformation from the link coordinate system (previous/parent joint) to this joint coordinate system
+    #  listOfInertias: provide a list of inertias as (6x6 numpy matrices), as produced by the function MassCOMinertia2T66
+    #  listOfParents: list of parent object indices (int), according to the index in jointTypes and transformations; use empty list for kinematic chain and use -1 if no parent exists (parent=base or world frame)
+    #  gravity: a 3D list/array containing the gravity applied to the kinematic tree (in world frame)
+    def __init__(self, 
+                 listOfJointTypes,
+                 listOfTransformations, 
+                 listOfInertias, 
+                 listOfParents=[],
+                 gravity=[0,0,-9.81],
+                 ):
+        self.jointTypes = listOfJointTypes
+        self.transformations = listOfTransformations
+        self.inertias = listOfInertias
+        self.parents = listOfParents
+        self.gravity = np.array(gravity)
+
+        if len(self.parents) == 0: #for kinematic chain, all joints are in a row
+            self.parents = np.arange(-1,len(self.jointTypes)-1)
+        else:
+            self.parents = np.array(self.parents)
+
+        if len(self.jointTypes) != len(self.transformations):
+            raise ValueError('KinematicTree66: length of jointTypes must agree with length of transformations')
+        if len(self.jointTypes) != len(self.parents):
+            raise ValueError('KinematicTree66: length of jointTypes must agree with length of parents (or parents may be empty)')
+        if len(self.jointTypes) != len(self.inertias):
+            raise ValueError('KinematicTree66: length of jointTypes must agree with length of inertias')
+
+        for i in range(len(listOfParents)):
+            if listOfParents[i] >= i:
+                raise ValueError('KinematicTree66: link / parent indices must be sorted such that parent indices always refer to a link with an index smaller than the current link (parent[i] < i)')
+    #**classFunction: return number of joints, defined by size of jointTypes
+    def Size(self):
+        return len(self.jointTypes)
+    
+    #**classFunction: return 6D transformation of joint i, given by transformation
+    def XL(self,i):
+        return self.transformations[i]
+
+
+    #**classFunction: compute forward dynamics using composite rigid body algorithm
+    #**input:
+    #  q: joint space coordinates for the model at which the forward dynamics is evaluated
+    #  q_t: joint space velocity coordinates for the model at which the forward dynamics is evaluated
+    #  torques: a vector of torques applied at joint coordinates or list/array with zero length
+    #  forces: forces acting on the bodies using special format
+    #**output: returns acceleration vector q\_tt of joint coordinates
+    def ForwardDynamicsCRB(self, q=[], q_t=[], torques=[], forces=[]):
+        if forces != []:
+            raise ValueError('ForwardDynamicsCRB: forces not implemented')
+        
+        if len(torques) == 0:
+            torques = np.zeros(len(q))
+            
+        [M, fGeneralized] = self.ComputeMassMatrixAndForceTerms(q, q_t)
+        
+        return np.linalg.solve(M, torques - fGeneralized)
+    
+    
+    #**classFunction: compute generalized mass matrix M and generalized force terms for 
+    #            kinematic tree, using current state (joint) variables q and 
+    #            joint velocities q\_t. The generalized force terms f = fGeneralized
+    #            contain Coriolis and gravity if given in the kinematicTree.
+    #**input:
+    #  q: current joint coordinates
+    #  q_t: current joint velocities
+    #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
+    #**output: mass matrix $\Mm$ and RHS vector $\fv_{RHS}$ for equations of motion $M(q) \cdot q_{tt} + f(q,q_t,externalForces) = \tau$; RHS is $\fv_{RHS}=\tau - f(q,q_t,externalForces)$; $\tau$ can be added outside of \texttt{ComputeMassMatrixAndForceTerms}
+    def ComputeMassMatrixAndForceTerms(self, q, q_t, externalForces=[]):
+        gravity6D = np.hstack((np.zeros(3),self.gravity))
+        n = self.Size()
+        
+        #initialize termporary matrices
+        MS = [np.zeros((6))]*n      #store motion supspaces
+        Xup = [np.zeros((6,6))]*n   #store link-joint transformation matrices
+        v = [np.zeros(6)]*n     #store 6D joint velocity vectors
+        fvp = [np.zeros(6)]*n   #store 6D joint force vectors for every body
+        avp = [np.zeros(6)]*n   #store 6D joint acceleration vectors
+        
+        #'recursively' compute transformations, accelerations and forces on parent joints
+        for i in range(n):
+            [XJ, MS[i]] = JointTransformMotionSubspace66(self.jointTypes[i], q[i])
+            vJ = MS[i] * q_t[i]
+            Xup[i] = XJ @ self.XL(i)
+            if self.parents[i] == -1:
+                v[i] = vJ
+                avp[i] = Xup[i] @ (-gravity6D)
+            else:
+                v[i] = Xup[i] @ v[self.parents[i]] + vJ
+                avp[i] = Xup[i] @ avp[self.parents[i]] + CRM(v[i]) @ vJ
+    
+            fvp[i] = self.inertias[i] @ avp[i] + CRF(v[i]) @ self.inertias[i] @ v[i] 
+
+            # print("Xup"+str(i)+"=",Xup[i])
+            # print("MS"+str(i)+"=",MS[i])
+            # print("IC"+str(i)+"=",self.inertias[i])
+            # print("CRF"+str(i)+"=",CRF(v[i]))
+            # print("v"+str(i)+"=",v[i])
+            # print("avp"+str(i)+"=",avp[i])
+            # print('fvp['+str(i)+']=',fvp[i].round(8))
+    
+        #add external foces
+        fvp = self.AddExternalForces(Xup, fvp, externalForces)
+    
+        f = np.zeros(n)             #store joint forces
+        M = np.zeros((n,n))         #store mass matrix
+        #compute joint forces; REVERSED loop!
+        for i in reversed(range(n)):
+            f[i] = MS[i].T @ fvp[i]
+            if self.parents[i] != -1:
+                fvp[self.parents[i]] += Xup[i].T @ fvp[i]
+    
+        #compute composite inertia
+        #IC = deepcopy(self.inertias) #may cause problems if referenced np.arrays used!
+        IC = [np.zeros((6,6))]*n
+
+        for i in range(n):
+            IC[i] = deepcopy(self.inertias[i])
+        
+        for i in reversed(range(n)):
+            if self.parents[i] != -1:
+                IC[self.parents[i]] += Xup[i].T @ IC[i] @ Xup[i]
+
+        #compute generalized mass matrix and projected inertia
+        for i in range(n):
+            fh = IC[i] @ MS[i]
+            M[i,i] = MS[i].T @ fh
+            j = i
+            while self.parents[j] > -1:
+                fh = Xup[j].T @ fh
+                j = self.parents[j]
+                M[i,j] = MS[j].T @ fh
+                M[j,i] = M[i,j]
+    
+        return [M, f]
+    
+    
+    #**classFunction: add action of external forces to forces fvp and return new composed vector of forces fvp
+    #**input:
+    #  Xup: 6x6 transformation matrices per joint; as computed in ComputeMassMatrixAndForceTerms
+    #  fvp: force (torque) per joint, as computed in ComputeMassMatrixAndForceTerms
+    #  externalForces: list of torque/forces in global (world) frame per joint; may be empty list, containing 6D vectors or matrices with 6D vectors in columns that are summed up for each link
+    def AddExternalForces(self, Xup, fvp, externalForces=[]):
+        fvpOut = fvp #np.zeros(n)
+        if len(externalForces): #only consider forces, if not empty list
+            n = len(self.parents)
+            Xa = [np.zeros((6,6))]*n
+            for i in range(n):
+                if self.parents[i] == -1:
+                    Xa[i] = Xup[i]
+                else:
+                    Xa[i] = Xup[i] * Xa[self.parents[i]];
+                if len(externalForces[i].shape) == 1:
+                    fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i])
+                else:
+                    raise ValueError('KinematicTree66.AddExternalForces: unchecked code for multiple forces')
+                    for j in range(len(externalForces[i].shape[1])): #loop over several vectors
+                        fvpOut[i] += np.linalg.solve(Xa[i].T, externalForces[i][:,j])
+    
+        return fvpOut
+        
+    
+
```

## exudyn/lieGroupBasics.py

 * *Ordering differences only*

```diff
@@ -1,606 +1,606 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Lie group methods and formulas for Lie group integration.
-# References:   \\
-#               For details on Lie group methods used here, see the references \cite{Henderson1977, Simo1988, Bruels2011, Sonneville2014, Sonneville2017, Terze2016, Mueller2017}.
-#               Lie group methods for rotation vector are described in Holzinger and Gerstmayr \cite{HolzingerGerstmayr2020, Holzinger2021}.
-#               
-# Author:   Stefan Holzinger, Johannes Gerstmayr
-# Date:     2020-09-11
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-
-import numpy as np
-from numpy.linalg import norm
-from math import sin, cos, tan, atan2, acos, sqrt
-
-#import exudyn as exu
-from exudyn.rigidBodyUtilities import EulerParameters2RotationMatrix, RotXYZ2RotationMatrix, HT2rotationMatrix, HT2translation, \
-            HomogeneousTransformation, Skew, Skew2Vec, ComputeRotationAxisFromRotationVector, RotationMatrix2EulerParameters
-
-
-# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#       HELPER METHODS FOR BASIC LIE GROUP METHODS
-# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    
-#**function: compute the cardinal sine function in radians
-#**input: scalar float or int value
-#**output: float value in radians
-#**author: Stefan Holzinger
-def Sinc(x):
-    if x == 0.:
-        s = 1.0
-    else:
-        s = sin(x)/x
-#    s = np.sinc(x/np.pi) # is not more accurate than our implementation!
-    return s
-
-
-#**function: compute the cotangent function cot(x)=1/tan(x) in radians
-#**input: scalar float or int value
-#**output: float value in radians
-#**author: Stefan Holzinger
-def Cot(x):
-    return 1/tan(x)
-
-
-#**function: computes 3x3 rotation matrix from 7x7 R3xSO(3) matrix, see \cite{Bruels2011}
-#**input: 
-#   G: 7x7 matrix as np.array
-#**output: 3x3 rotation matrix as np.array
-#**author: Stefan Holzinger
-def R3xSO3Matrix2RotationMatrix(G): 
-    return G[0:3,0:3]
-
-
-#**function: computes translation part of R3xSO(3) matrix, see \cite{Bruels2011}
-#**input: 
-#   G: 7x7 matrix as np.array
-#**output: 3D vector as np.array containg translational part of R3xSO(3)
-#**author: Stefan Holzinger
-def R3xSO3Matrix2Translation(G):
-    return G[3:6,6]
-
-
-#**function: builds 7x7 matrix as element of the Lie group R3xSO(3), see \cite{Bruels2011}
-#**input: 
-#   x: 3D vector as np.array representing the translation part corresponding to R3 
-#   R: 3x3 rotation matrix as np.array
-#**output: 7x7 matrix as np.array
-#**author: Stefan Holzinger
-def R3xSO3Matrix(x,R):
-    G = np.eye(7)
-    G[0:3,0:3] = R
-    G[3:6,6] = x
-    return G
-
-
-
-
-
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#       EXPONENTIAL MAPS AND TANGENT OPERATORS
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-#**function: compute the matrix exponential map on the Lie group SO(3), see \cite{Mueller2017}
-#**input: 3D rotation vector as np.array
-#**output: 3x3 matrix as np.array
-#**author: Stefan Holzinger
-def ExpSO3(Omega):
-    phi = norm(Omega)
-    I = np.eye(3)
-    OmegaSkew = Skew(Omega)
-    R = I + Sinc(phi)*OmegaSkew + 0.5*(Sinc(0.5*phi)**2)*np.matmul(OmegaSkew, OmegaSkew)
-    return R  
-
-
-#**function: compute the quaternion exponential map on the Lie group S(3), see \cite{Terze2016, Mueller2017}
-#**input: 3D rotation vector as np.array
-#**output: 4D vector as np.array containing four Euler parameters 
-#          entry zero of output represent the scalar part of Euler parameters
-#**author: Stefan Holzinger
-def ExpS3(Omega):
-    phi = norm(Omega)
-    q0 = cos(0.5*phi)
-    qV = 0.5*Sinc(0.5*phi)*Omega
-    return np.array([q0, qV[0], qV[1], qV[2]])     
-
-
-#**function: compute the matrix logarithmic map on the Lie group SO(3)
-#**input: 3x3 rotation matrix as np.array
-#**output: 3x3 skew symmetric matrix as np.array
-#**author: Johannes Gerstmayr
-#**notes: improved accuracy for very small angles as well as angles phi close to pi AS WELL AS at phi=pi
-def LogSO3(R):
-    ep = RotationMatrix2EulerParameters(R)
-    
-    n = ep[1:]
-    norm = np.linalg.norm(n)
-    
-    #phi = 2.*acos(ep[0])
-    phi = 2.*np.arctan2(norm, ep[0])
-    
-    if norm != 0.:
-        n = (1./norm)*n
-
-    return Skew(phi*n)
-    
-
-
-# #**function: compute the matrix logarithmic map on the Lie group SO(3), see \cite{Sonneville2014, Sonneville2017}
-# #**input: 3x3 rotation matrix as np.array
-# #**output: 3x3 skew symmetric matrix as np.array
-# #**author: Stefan Holzinger
-# def LogSO3(R):
-#     val = 0.5*(np.trace(R)-1) #if slightly larger than 1, due to numerical differentiation
-#     if abs(val)>1:
-#         val = val/abs(val)
-#     phi = acos(val)
-#     if phi == 0.:
-#         X = np.zeros((3,3))
-#     else:
-#         X = (phi/(2*sin(phi)))*(R - np.transpose(R))
-#     return X
-
-
-#**function: compute the tangent operator corresponding to ExpSO3, see \cite{Bruels2011}
-#**input: 3D rotation vector as np.array
-#**output: 3x3 matrix as np.array       
-#**author: Stefan Holzinger
-def TExpSO3(Omega):
-    #not all of these terms are needed (as implemented in C++ code):
-
-    phi = norm(Omega)
-    I = np.eye(3)
-    if phi == 0.:
-        T = I
-    else:
-        OmegaSkew = Skew(Omega)
-        t1 = -0.5*Sinc(phi/2)**2 #(np.cos(phi)-1)/(phi**2)
-        if phi < 0.01:
-            t2 = 1 / 6 - (1 / 120)*phi**2 + (1 / 5040)*phi**4
-            #termExpanded = lambda x: 1/6 - (1/120)*x**2 + (1/5040)*x**4 - (1/362880)*x**6 + (1/39916800)*x**8 - (1/6227020800)*x**10 + (1/1307674368000)*x**12 
-        else:
-            t2 = (1/(phi**2))*(1-(sin(phi)/phi))
-        T = I + t1*OmegaSkew + t2*np.dot(OmegaSkew, OmegaSkew)
-    return T
-
-
-#**function: compute the inverse of the tangent operator TExpSO3, see \cite{Sonneville2014}
-#            this function was improved, see coordinateMaps.pdf by Stefan Holzinger
-#**input: 3D rotation vector as np.array
-#**output: 3x3 matrix as np.array 
-#**author: Stefan Holzinger
-def TExpSO3Inv(Omega):
-    phi = norm(Omega)
-    if phi == 0.0: 
-        Tinv = np.eye(3)
-    elif phi <= 0.02: 
-        c = (1/12) + (1/720)*phi**2 + (1/30240)*phi**4 # + (1/1209600)*phi**6 # + (1/47900160)*phi**8
-        b = 1 - c*phi**2
-        A = np.diag([b, b, b])
-        OmegaSkew = Skew(0.5*Omega)
-        Tinv = A + OmegaSkew + c*np.outer(Omega,Omega)
-    else:
-        OmegaSkew = Skew(0.5*Omega)
-        epsilon = 0.5*phi
-        beta = epsilon*Cot( epsilon )
-        gamma = (1 - beta)/(phi**2)
-        Tinv = np.diag([beta, beta, beta]) + OmegaSkew + gamma*np.outer(Omega,Omega)
-    return Tinv 
-
-
-#**function: compute the matrix exponential map on the Lie group SE(3), see \cite{Bruels2011}
-#**input: 6D incremental motion vector as np.array
-#**output: 4x4 homogeneous transformation matrix as np.array
-#**author: Stefan Holzinger
-def ExpSE3(x):
-    U     = x[0:3]
-    Omega = x[3:6]
-    R = ExpSO3(Omega)
-    x = np.dot(np.transpose(TExpSO3(Omega)), U)
-    return HomogeneousTransformation(R, x)
-
-
-#**function: compute the matrix logarithm on the Lie group SE(3), see \cite{Sonneville2014}
-#**input: 4x4 homogeneous transformation matrix as np.array
-#**output: 4x4 skew symmetric matrix as np.array
-#**author: Stefan Holzinger
-def LogSE3(H):
-    R = HT2rotationMatrix(H)
-    aSkew = LogSO3(R)
-    a = Skew2Vec(aSkew)   
-    A = np.transpose(TExpSO3Inv(a))
-    x = np.dot(A,HT2translation(H))
-    log = np.zeros((4,4))
-    log[0:3,0:3] = aSkew
-    log[0:3,3] = x
-    return log
-    
-
-#**function: compute the tangent operator corresponding to ExpSE3, see \cite{Bruels2011}
-#**input: 6D incremental motion vector as np.array
-#**output: 6x6 matrix as np.array
-#**author: Stefan Holzinger
-#**notes: improved accuracy for very small angles as well as angles phi 
-def TExpSE3(x):
-    U     = x[0:3]
-    Omega = x[3:6]
-    USkew     = Skew(U)
-    OmegaSkew = Skew(Omega)
-    phi = norm(Omega)
-   # phiOverTwo = 0.5*phi
-    
-    # coefficient f2, see Phd thesis Stefan Hante, Table. 1, page 121
-    if phi >= 1e-2:
-        f2 = (np.cos(phi) - 1) / phi**2
-    else:
-        f2 = -0.5 + (1/24)*phi**2 - (1/720)*phi**4
-
-    # coefficient f3, see Phd thesis Stefan Hante, Table. 1, page 121
-    if phi >= 1e-4:
-        f3 = (phi - np.sin(phi)) / phi**3
-    else:
-        f3 = 1/6 - (1/24)*phi**2 - (1/720)*phi**4     
-
-    # coefficient f4, see Phd thesis Stefan Hante, Table. 1, page 121
-    if phi >= 1e-1:
-        f4 = (2 - 2*np.cos(phi) - phi*np.sin(phi)) / phi**4
-    else:
-        f4 = 1/12 - (1/180)*phi**2 + (1/6720)*phi**4 - (1/453600)*phi**6
-        
-    # coefficient f5, see Phd thesis Stefan Hante, Table. 1, page 121
-    if phi >= 1e-1:
-        f5 = ( phi*(2 + np.cos(phi)) - 3*np.sin(phi)) / phi**5
-    else:
-        f5 = 1/60 - (1/1260)*phi**2 + (1/60480)*phi**4 - (1/4989600)*phi**6     
-    
-    TUOmegaPlus = f2*USkew + f3*( USkew @ OmegaSkew + OmegaSkew @ USkew ) + f4*np.dot(Omega,U)*OmegaSkew - f5*np.dot(Omega,U)*OmegaSkew**2
-    
-    TexpSO3 = TExpSO3(Omega)
-    T = np.block([[TexpSO3,         TUOmegaPlus],
-                  [np.zeros((3,3)), TexpSO3]])
-    return T
-
-
-
-#**function: compute the inverse of tangent operator TExpSE3, see \cite{Sonneville2014}
-#**input: 6D incremental motion vector as np.array
-#**output: 6x6 matrix as np.array
-#**author: Stefan Holzinger
-#**notes: improved accuracy for very small angles as well as angles phi 
-def TExpSE3Inv(x):
-    U     = x[0:3]
-    Omega = x[3:6]
-    USkew     = Skew(U)
-    OmegaSkew = Skew(Omega)
-    phi = norm(Omega)
-    phiOverTwo = 0.5*phi
-    
-    # coefficient f6, see Phd thesis Stefan Hante, Table. 1, page 121
-    if phi >= 1e-2:
-        f6 = (2 - Cot(phiOverTwo)) / (2*phi**2)
-    else:
-        f6 = 1/12 + (1/720)*phi**2 + (1/30240)*phi**4
-    
-    # coefficient f8, see Phd thesis Stefan Hante, Table. 1, page 121
-    if phi >= 2e-1:
-        f8 = (phi*np.sin(phi) + 4*np.cos(phi) + phi**2 - 4) / (4*np.sin(phiOverTwo)**2 * phi**4)
-    else:
-        f8 = 1/360 + (1/7560)*phi**2 + (1/201600)*phi**4 + (1/5987520)*phi**6 + (691/130767436800)*phi**8
-    
-    # Matrix C2, see Phd thesis Stefan Hante, Sect.A.3, page 117
-    Tuwm = 0.5*USkew + f6*( USkew @ OmegaSkew + OmegaSkew @ USkew ) + f8*np.dot(Omega,U)*OmegaSkew**2
-    TexpSO3Inv = TExpSO3Inv(Omega) #NOTE: overrides the function TexpSO3Inv
-    Tinv = np.block([[TexpSO3Inv,      Tuwm],
-                     [np.zeros((3,3)), TexpSO3Inv]])
-    return Tinv
-    
-
-#**function: compute the matrix exponential map on the Lie group R3xSO(3), see \cite{Bruels2011}
-#**input: 6D incremental motion vector as np.array
-#**output: 7x7 matrix as np.array
-#**author: Stefan Holzinger
-def ExpR3xSO3(x):
-    G = np.eye(7)
-    G[0:3,0:3] = ExpSO3(x[3:6])
-    G[3:6,6] = x[0:3]
-    return G
-
-
-#**function: compute the tangent operator corresponding to ExpR3xSO3, see \cite{Bruels2011}
-#**input: 6D incremental motion vector as np.array
-#**output: 6x6 matrix as np.array
-#**author: Stefan Holzinger
-def TExpR3xSO3(x):
-    T = np.eye(6)
-    T[3:6,3:6] = TExpSO3(x[3:6])
-    return T
-
-
-#**function: compute the inverse of tangent operator TExpR3xSO3
-#**input: 6D incremental motion vector as np.array
-#**output: 6x6 matrix as np.array
-#**author: Stefan Holzinger
-def TExpR3xSO3Inv(x):
-    T = np.eye(6)
-    T[3:6,3:6] = TExpSO3Inv(x[3:6])
-    return T
-
-
-
-
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#       COMPOSITION OPERATIONS FOR LIE GROUP TIME INTEGRATION METHODS 
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-
-#**function: compute composition operation for pairs in the Lie group R3xS3
-#**input: 
-#  q0: 7D vector as np.array containing position coordinates and Euler parameters
-#  incrementalMotionVector: 6D incremental motion vector as np.array
-#**output: 7D vector as np.array containing composed position coordinates and composed Euler parameters
-#**author: Stefan Holzinger
-def CompositionRuleDirectProductR3AndS3(q0, incrementalMotionVector):
-    
-    # pair (x0, theta0)
-    x0     = q0[0:3]  # global COM position at time step t0
-    theta0 = q0[3:7]  # Euler parameters at time step t0
-    
-    # pair (delta x, incremental rotation vector)
-    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
-    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
-    
-    # compososition rule
-    x   = x0 + delta_x
-    theta = CompositionRuleForEulerParameters(theta0, ExpS3(incRotVec))
-    
-    return np.block([x, theta])
-
-
-#**function: compute composition operation for pairs in the Lie group R3 semiTimes S3 (corresponds to SE(3))
-#**input: 
-#  q0: 7D vector as np.array containing position coordinates and Euler parameters
-#  incrementalMotionVector: 6D incremental motion vector as np.array
-#**output: 7D vector as np.array containing composed position coordinates and composed Euler parameters
-#**author: Stefan Holzinger
-def CompositionRuleSemiDirectProductR3AndS3(q0, incrementalMotionVector):
-    
-    # pair (x0, theta0)
-    x0     = q0[0:3]  # global COM position at time step t0
-    theta0 = q0[3:7]  # Euler parameters at time step t0
-    
-    # pair (delta x, incremental rotation vector)
-    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
-    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
-    
-    # compososition rule
-    R0  = EulerParameters2RotationMatrix(theta0)
-    x   = x0 + np.dot(R0, np.dot(np.transpose(TExpSO3(incRotVec)), delta_x))
-    theta = CompositionRuleForEulerParameters(theta0, ExpS3(incRotVec))
-    
-    return np.block([x, theta])
-
-
-#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3, see \cite{HolzingerGerstmayr2020}
-#            the rotation vector is used as rotation parametrizations
-#            this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
-#**input: 
-#  q0: 6D vector as np.array containing position coordinates and rotation vector
-#  incrementalMotionVector: 6D incremental motion vector as np.array
-#**output: 7D vector as np.array containing composed position coordinates and composed rotation vector
-#**author: Stefan Holzinger
-def CompositionRuleDirectProductR3AndR3RotVec(q0, incrementalMotionVector):
-    
-    # pair (x0, psi0)
-    x0   = q0[0:3]  # global COM position at time step t0
-    psi0 = q0[3:6]  # rotation vector at time step t0
-    
-    # pair (delta x, delta theta)
-    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
-    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
-    
-    # compososition rule
-    x   = x0 + delta_x
-    psi = CompositionRuleForRotationVectors(psi0, incRotVec)
-    
-    return np.block([x, psi])
-
-
-#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
-#            the rotation vector is used as rotation parametrizations
-#            this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
-#**input: 
-#  q0: 6D vector as np.array containing position coordinates and rotation vector
-#  incrementalMotionVector: 6D incremental motion vector as np.array
-#**output: 6D vector as np.array containing composed position coordinates and composed rotation vector
-#**author: Stefan Holzinger
-def CompositionRuleSemiDirectProductR3AndR3RotVec(q0, incrementalMotionVector):
-    
-    # pair (x0, psi0)
-    x0   = q0[0:3]  # global COM position at time step t0
-    psi0 = q0[3:6]  # rotation vector at time step t0
-    
-    # pair (delta x, delta theta)
-    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
-    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
-    
-    # compososition rule
-    R0  = ExpSO3(psi0)
-    x   = x0 + np.dot(R0, np.dot(np.transpose(TExpSO3(incRotVec)), delta_x))
-    psi = CompositionRuleForRotationVectors(psi0, incRotVec)
-    
-    return np.block([x, psi])
-
-
-#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
-#            Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
-#            this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
-#**input: 
-#  q0: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
-#  incrementalMotionVector: 6D incremental motion vector as np.array
-#**output: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles
-#**author: Stefan Holzinger
-def CompositionRuleDirectProductR3AndR3RotXYZAngles(q0, incrementalMotionVector):
-    
-    # pair (x0, psi0)
-    x0     = q0[0:3]  # global COM position at time step t0
-    alpha0 = q0[3:6]  # Cardan-Tait/Bryan angles at time step t0
-    
-    # pair (delta x, delta theta)
-    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
-    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
-    
-    # compososition rule
-    x   = x0 + delta_x
-    alpha = CompositionRuleRotXYZAnglesRotationVector(alpha0, incRotVec)
-    
-    return np.block([x, alpha])
-
-
-#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
-#            Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
-#            this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
-#**input: 
-#  q0: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
-#  incrementalMotionVector: 6D incremental motion vector as np.array
-#**output: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles
-#**author: Stefan Holzinger
-def CompositionRuleSemiDirectProductR3AndR3RotXYZAngles(q0, incrementalMotionVector):
-    
-    # pair (x0, psi0)
-    x0     = q0[0:3]  # global COM position at time step t0
-    alpha0 = q0[3:6]  # Cardan-Tait/Bryan angles at time step t0
-    
-    # pair (delta x, delta theta)
-    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
-    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
-    
-    # compososition rule
-    R0    = RotXYZ2RotationMatrix(alpha0)
-    x     = x0 + np.dot(R0, np.dot(np.transpose(TExpSO3(incRotVec)), delta_x))
-    alpha = CompositionRuleRotXYZAnglesRotationVector(alpha0, incRotVec)
-    
-    return np.block([x, alpha])
- 
-
-#**function: compute composition operation for Euler parameters (unit quaternions)
-#            this composition operation is quaternion multiplication, see \cite{Terze2016}
-#**input: 
-#  q: 4D vector as np.array containing Euler parameters
-#  p: 4D vector as np.array containing Euler parameters
-#**output: 4D vector as np.array containing composed (multiplied) Euler parameters
-#**author: Stefan Holzinger
-def CompositionRuleForEulerParameters(q, p):
-    p0 = p[0]
-    pV = p[1:4]
-    q0 = q[0]
-    qV = q[1:4]
-    x0 = q0*p0 - np.dot(qV,pV)
-    xV = q0*pV + p0*qV + np.cross(qV,pV)
-    return np.array([x0, xV[0], xV[1], xV[2]])
-
-
-#**function: compute composition operation for rotation vectors v0 and Omega, see \cite{Holzinger2021}
-#**input: 
-#  v0: 3D rotation vector as np.array
-#  Omega: 3D (incremental) rotation vector as np.array
-#**output: 3D vector as np.array containing composed rotation vector v
-#**author: Stefan Holzinger
-def CompositionRuleForRotationVectors(v0, Omega):
-    w1Half = 0.5*norm(v0)
-    w2Half = 0.5*norm(Omega)
-    c0 = cos(w1Half)
-    c1 = cos(w2Half)
-    s0 = Sinc(w1Half)
-    s1 = Sinc(w2Half)
-    x = c0*c1 - 0.25*s0*s1*np.dot(v0,Omega)
-    xPower = x**2
-    xTemp = sqrt(1 - xPower)
-    w = np.pi - 2*atan2(x,xTemp)        
-    rho = s0*c1*v0 + c0*s1*Omega + 0.5*s0*s1*np.cross(v0, Omega)
-    n = ComputeRotationAxisFromRotationVector(rho)
-    v = w*n
-    return v
-
-
-#**function: compute composition operation for RotXYZ angles, see \cite{Holzinger2021}
-#**input: 
-#  alpha0: 3D vector as np.array containing RotXYZ angles
-#  Omega:  3D vector as np.array containing the (incremental) rotation vector
-#**output: 3D vector as np.array containing composed RotXYZ angles
-#**author: Stefan Holzinger
-def CompositionRuleRotXYZAnglesRotationVector(alpha0, Omega):
-  
-    # Cardan-Tait/Bryan angles
-    psi0   = alpha0[0]
-    theta0 = alpha0[1]
-    phi0   = alpha0[2]
-    
-    # define unit vectors
-    e1 = np.array([1, 0, 0])
-    e2 = np.array([0, 1, 0])
-    e3 = np.array([0, 0, 1])
-    
-    # compute vectors u and v
-    R0 = RotXYZ2RotationMatrix(alpha0)
-    exp = ExpSO3(Omega)
-    u1 = np.dot(e1, R0) 
-    u2 = np.dot(e2, R0)
-    u3 = np.dot(e3, R0)
-    v1 = np.dot(exp, e1)
-    v2 = np.dot(exp, e2)
-    v3 = np.dot(exp, e3)
-    u1v3 = np.dot(u1,v3)
-    cosTheta = sqrt(1 - u1v3**2)
-    
-    # compute mu
-    if cosTheta == 0.0:
-        mu = 0
-    else:
-        mu = 1 / cosTheta
-    
-    # compute sine and cosine terms of incremental angle changes
-    sinPsi0 = sin(psi0)
-    cosPsi0 = cos(psi0)
-    sinTheta0 = sin(theta0)
-    cosTheta0 = cos(theta0)
-    sinPhi0 = sin(phi0)
-    cosPhi0 = cos(phi0)    
-    u2v3 = np.dot(u2,v3)
-    u3v3 = np.dot(u3,v3)
-    u1v2 = np.dot(u1,v2)
-    u1v1 = np.dot(u1,v1)    
-    y1 = -u2v3*cosPsi0 - u3v3*sinPsi0
-    x1 =  u3v3*cosPsi0 - u2v3*sinPsi0
-    y2 = u1v3*cosTheta0 - cosTheta*sinTheta0
-    x2 = cosTheta*cosTheta0 + u1v3*sinTheta0
-    y3 = -u1v2*cosPhi0 - u1v1*sinPhi0
-    x3 = u1v1*cosPhi0 - u1v2*sinPhi0
-    
-    # compute incremental angles changes
-    deltaPsi   = atan2(mu*y1, mu*x1)
-    deltaTheta = atan2(y2, x2)
-    deltaPhi   = atan2(mu*y3, mu*x3)
-    deltaAlpha = np.array([deltaPsi, deltaTheta, deltaPhi])
-    
-    return alpha0 + deltaAlpha
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Lie group methods and formulas for Lie group integration.
+# References:   \\
+#               For details on Lie group methods used here, see the references \cite{Henderson1977, Simo1988, Bruels2011, Sonneville2014, Sonneville2017, Terze2016, Mueller2017}.
+#               Lie group methods for rotation vector are described in Holzinger and Gerstmayr \cite{HolzingerGerstmayr2020, Holzinger2021}.
+#               
+# Author:   Stefan Holzinger, Johannes Gerstmayr
+# Date:     2020-09-11
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+
+import numpy as np
+from numpy.linalg import norm
+from math import sin, cos, tan, atan2, acos, sqrt
+
+#import exudyn as exu
+from exudyn.rigidBodyUtilities import EulerParameters2RotationMatrix, RotXYZ2RotationMatrix, HT2rotationMatrix, HT2translation, \
+            HomogeneousTransformation, Skew, Skew2Vec, ComputeRotationAxisFromRotationVector, RotationMatrix2EulerParameters
+
+
+# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#       HELPER METHODS FOR BASIC LIE GROUP METHODS
+# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    
+#**function: compute the cardinal sine function in radians
+#**input: scalar float or int value
+#**output: float value in radians
+#**author: Stefan Holzinger
+def Sinc(x):
+    if x == 0.:
+        s = 1.0
+    else:
+        s = sin(x)/x
+#    s = np.sinc(x/np.pi) # is not more accurate than our implementation!
+    return s
+
+
+#**function: compute the cotangent function cot(x)=1/tan(x) in radians
+#**input: scalar float or int value
+#**output: float value in radians
+#**author: Stefan Holzinger
+def Cot(x):
+    return 1/tan(x)
+
+
+#**function: computes 3x3 rotation matrix from 7x7 R3xSO(3) matrix, see \cite{Bruels2011}
+#**input: 
+#   G: 7x7 matrix as np.array
+#**output: 3x3 rotation matrix as np.array
+#**author: Stefan Holzinger
+def R3xSO3Matrix2RotationMatrix(G): 
+    return G[0:3,0:3]
+
+
+#**function: computes translation part of R3xSO(3) matrix, see \cite{Bruels2011}
+#**input: 
+#   G: 7x7 matrix as np.array
+#**output: 3D vector as np.array containg translational part of R3xSO(3)
+#**author: Stefan Holzinger
+def R3xSO3Matrix2Translation(G):
+    return G[3:6,6]
+
+
+#**function: builds 7x7 matrix as element of the Lie group R3xSO(3), see \cite{Bruels2011}
+#**input: 
+#   x: 3D vector as np.array representing the translation part corresponding to R3 
+#   R: 3x3 rotation matrix as np.array
+#**output: 7x7 matrix as np.array
+#**author: Stefan Holzinger
+def R3xSO3Matrix(x,R):
+    G = np.eye(7)
+    G[0:3,0:3] = R
+    G[3:6,6] = x
+    return G
+
+
+
+
+
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#       EXPONENTIAL MAPS AND TANGENT OPERATORS
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+#**function: compute the matrix exponential map on the Lie group SO(3), see \cite{Mueller2017}
+#**input: 3D rotation vector as np.array
+#**output: 3x3 matrix as np.array
+#**author: Stefan Holzinger
+def ExpSO3(Omega):
+    phi = norm(Omega)
+    I = np.eye(3)
+    OmegaSkew = Skew(Omega)
+    R = I + Sinc(phi)*OmegaSkew + 0.5*(Sinc(0.5*phi)**2)*np.matmul(OmegaSkew, OmegaSkew)
+    return R  
+
+
+#**function: compute the quaternion exponential map on the Lie group S(3), see \cite{Terze2016, Mueller2017}
+#**input: 3D rotation vector as np.array
+#**output: 4D vector as np.array containing four Euler parameters 
+#          entry zero of output represent the scalar part of Euler parameters
+#**author: Stefan Holzinger
+def ExpS3(Omega):
+    phi = norm(Omega)
+    q0 = cos(0.5*phi)
+    qV = 0.5*Sinc(0.5*phi)*Omega
+    return np.array([q0, qV[0], qV[1], qV[2]])     
+
+
+#**function: compute the matrix logarithmic map on the Lie group SO(3)
+#**input: 3x3 rotation matrix as np.array
+#**output: 3x3 skew symmetric matrix as np.array
+#**author: Johannes Gerstmayr
+#**notes: improved accuracy for very small angles as well as angles phi close to pi AS WELL AS at phi=pi
+def LogSO3(R):
+    ep = RotationMatrix2EulerParameters(R)
+    
+    n = ep[1:]
+    norm = np.linalg.norm(n)
+    
+    #phi = 2.*acos(ep[0])
+    phi = 2.*np.arctan2(norm, ep[0])
+    
+    if norm != 0.:
+        n = (1./norm)*n
+
+    return Skew(phi*n)
+    
+
+
+# #**function: compute the matrix logarithmic map on the Lie group SO(3), see \cite{Sonneville2014, Sonneville2017}
+# #**input: 3x3 rotation matrix as np.array
+# #**output: 3x3 skew symmetric matrix as np.array
+# #**author: Stefan Holzinger
+# def LogSO3(R):
+#     val = 0.5*(np.trace(R)-1) #if slightly larger than 1, due to numerical differentiation
+#     if abs(val)>1:
+#         val = val/abs(val)
+#     phi = acos(val)
+#     if phi == 0.:
+#         X = np.zeros((3,3))
+#     else:
+#         X = (phi/(2*sin(phi)))*(R - np.transpose(R))
+#     return X
+
+
+#**function: compute the tangent operator corresponding to ExpSO3, see \cite{Bruels2011}
+#**input: 3D rotation vector as np.array
+#**output: 3x3 matrix as np.array       
+#**author: Stefan Holzinger
+def TExpSO3(Omega):
+    #not all of these terms are needed (as implemented in C++ code):
+
+    phi = norm(Omega)
+    I = np.eye(3)
+    if phi == 0.:
+        T = I
+    else:
+        OmegaSkew = Skew(Omega)
+        t1 = -0.5*Sinc(phi/2)**2 #(np.cos(phi)-1)/(phi**2)
+        if phi < 0.01:
+            t2 = 1 / 6 - (1 / 120)*phi**2 + (1 / 5040)*phi**4
+            #termExpanded = lambda x: 1/6 - (1/120)*x**2 + (1/5040)*x**4 - (1/362880)*x**6 + (1/39916800)*x**8 - (1/6227020800)*x**10 + (1/1307674368000)*x**12 
+        else:
+            t2 = (1/(phi**2))*(1-(sin(phi)/phi))
+        T = I + t1*OmegaSkew + t2*np.dot(OmegaSkew, OmegaSkew)
+    return T
+
+
+#**function: compute the inverse of the tangent operator TExpSO3, see \cite{Sonneville2014}
+#            this function was improved, see coordinateMaps.pdf by Stefan Holzinger
+#**input: 3D rotation vector as np.array
+#**output: 3x3 matrix as np.array 
+#**author: Stefan Holzinger
+def TExpSO3Inv(Omega):
+    phi = norm(Omega)
+    if phi == 0.0: 
+        Tinv = np.eye(3)
+    elif phi <= 0.02: 
+        c = (1/12) + (1/720)*phi**2 + (1/30240)*phi**4 # + (1/1209600)*phi**6 # + (1/47900160)*phi**8
+        b = 1 - c*phi**2
+        A = np.diag([b, b, b])
+        OmegaSkew = Skew(0.5*Omega)
+        Tinv = A + OmegaSkew + c*np.outer(Omega,Omega)
+    else:
+        OmegaSkew = Skew(0.5*Omega)
+        epsilon = 0.5*phi
+        beta = epsilon*Cot( epsilon )
+        gamma = (1 - beta)/(phi**2)
+        Tinv = np.diag([beta, beta, beta]) + OmegaSkew + gamma*np.outer(Omega,Omega)
+    return Tinv 
+
+
+#**function: compute the matrix exponential map on the Lie group SE(3), see \cite{Bruels2011}
+#**input: 6D incremental motion vector as np.array
+#**output: 4x4 homogeneous transformation matrix as np.array
+#**author: Stefan Holzinger
+def ExpSE3(x):
+    U     = x[0:3]
+    Omega = x[3:6]
+    R = ExpSO3(Omega)
+    x = np.dot(np.transpose(TExpSO3(Omega)), U)
+    return HomogeneousTransformation(R, x)
+
+
+#**function: compute the matrix logarithm on the Lie group SE(3), see \cite{Sonneville2014}
+#**input: 4x4 homogeneous transformation matrix as np.array
+#**output: 4x4 skew symmetric matrix as np.array
+#**author: Stefan Holzinger
+def LogSE3(H):
+    R = HT2rotationMatrix(H)
+    aSkew = LogSO3(R)
+    a = Skew2Vec(aSkew)   
+    A = np.transpose(TExpSO3Inv(a))
+    x = np.dot(A,HT2translation(H))
+    log = np.zeros((4,4))
+    log[0:3,0:3] = aSkew
+    log[0:3,3] = x
+    return log
+    
+
+#**function: compute the tangent operator corresponding to ExpSE3, see \cite{Bruels2011}
+#**input: 6D incremental motion vector as np.array
+#**output: 6x6 matrix as np.array
+#**author: Stefan Holzinger
+#**notes: improved accuracy for very small angles as well as angles phi 
+def TExpSE3(x):
+    U     = x[0:3]
+    Omega = x[3:6]
+    USkew     = Skew(U)
+    OmegaSkew = Skew(Omega)
+    phi = norm(Omega)
+   # phiOverTwo = 0.5*phi
+    
+    # coefficient f2, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-2:
+        f2 = (np.cos(phi) - 1) / phi**2
+    else:
+        f2 = -0.5 + (1/24)*phi**2 - (1/720)*phi**4
+
+    # coefficient f3, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-4:
+        f3 = (phi - np.sin(phi)) / phi**3
+    else:
+        f3 = 1/6 - (1/24)*phi**2 - (1/720)*phi**4     
+
+    # coefficient f4, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-1:
+        f4 = (2 - 2*np.cos(phi) - phi*np.sin(phi)) / phi**4
+    else:
+        f4 = 1/12 - (1/180)*phi**2 + (1/6720)*phi**4 - (1/453600)*phi**6
+        
+    # coefficient f5, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-1:
+        f5 = ( phi*(2 + np.cos(phi)) - 3*np.sin(phi)) / phi**5
+    else:
+        f5 = 1/60 - (1/1260)*phi**2 + (1/60480)*phi**4 - (1/4989600)*phi**6     
+    
+    TUOmegaPlus = f2*USkew + f3*( USkew @ OmegaSkew + OmegaSkew @ USkew ) + f4*np.dot(Omega,U)*OmegaSkew - f5*np.dot(Omega,U)*OmegaSkew**2
+    
+    TexpSO3 = TExpSO3(Omega)
+    T = np.block([[TexpSO3,         TUOmegaPlus],
+                  [np.zeros((3,3)), TexpSO3]])
+    return T
+
+
+
+#**function: compute the inverse of tangent operator TExpSE3, see \cite{Sonneville2014}
+#**input: 6D incremental motion vector as np.array
+#**output: 6x6 matrix as np.array
+#**author: Stefan Holzinger
+#**notes: improved accuracy for very small angles as well as angles phi 
+def TExpSE3Inv(x):
+    U     = x[0:3]
+    Omega = x[3:6]
+    USkew     = Skew(U)
+    OmegaSkew = Skew(Omega)
+    phi = norm(Omega)
+    phiOverTwo = 0.5*phi
+    
+    # coefficient f6, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-2:
+        f6 = (2 - Cot(phiOverTwo)) / (2*phi**2)
+    else:
+        f6 = 1/12 + (1/720)*phi**2 + (1/30240)*phi**4
+    
+    # coefficient f8, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 2e-1:
+        f8 = (phi*np.sin(phi) + 4*np.cos(phi) + phi**2 - 4) / (4*np.sin(phiOverTwo)**2 * phi**4)
+    else:
+        f8 = 1/360 + (1/7560)*phi**2 + (1/201600)*phi**4 + (1/5987520)*phi**6 + (691/130767436800)*phi**8
+    
+    # Matrix C2, see Phd thesis Stefan Hante, Sect.A.3, page 117
+    Tuwm = 0.5*USkew + f6*( USkew @ OmegaSkew + OmegaSkew @ USkew ) + f8*np.dot(Omega,U)*OmegaSkew**2
+    TexpSO3Inv = TExpSO3Inv(Omega) #NOTE: overrides the function TexpSO3Inv
+    Tinv = np.block([[TexpSO3Inv,      Tuwm],
+                     [np.zeros((3,3)), TexpSO3Inv]])
+    return Tinv
+    
+
+#**function: compute the matrix exponential map on the Lie group R3xSO(3), see \cite{Bruels2011}
+#**input: 6D incremental motion vector as np.array
+#**output: 7x7 matrix as np.array
+#**author: Stefan Holzinger
+def ExpR3xSO3(x):
+    G = np.eye(7)
+    G[0:3,0:3] = ExpSO3(x[3:6])
+    G[3:6,6] = x[0:3]
+    return G
+
+
+#**function: compute the tangent operator corresponding to ExpR3xSO3, see \cite{Bruels2011}
+#**input: 6D incremental motion vector as np.array
+#**output: 6x6 matrix as np.array
+#**author: Stefan Holzinger
+def TExpR3xSO3(x):
+    T = np.eye(6)
+    T[3:6,3:6] = TExpSO3(x[3:6])
+    return T
+
+
+#**function: compute the inverse of tangent operator TExpR3xSO3
+#**input: 6D incremental motion vector as np.array
+#**output: 6x6 matrix as np.array
+#**author: Stefan Holzinger
+def TExpR3xSO3Inv(x):
+    T = np.eye(6)
+    T[3:6,3:6] = TExpSO3Inv(x[3:6])
+    return T
+
+
+
+
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#       COMPOSITION OPERATIONS FOR LIE GROUP TIME INTEGRATION METHODS 
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+
+#**function: compute composition operation for pairs in the Lie group R3xS3
+#**input: 
+#  q0: 7D vector as np.array containing position coordinates and Euler parameters
+#  incrementalMotionVector: 6D incremental motion vector as np.array
+#**output: 7D vector as np.array containing composed position coordinates and composed Euler parameters
+#**author: Stefan Holzinger
+def CompositionRuleDirectProductR3AndS3(q0, incrementalMotionVector):
+    
+    # pair (x0, theta0)
+    x0     = q0[0:3]  # global COM position at time step t0
+    theta0 = q0[3:7]  # Euler parameters at time step t0
+    
+    # pair (delta x, incremental rotation vector)
+    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
+    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
+    
+    # compososition rule
+    x   = x0 + delta_x
+    theta = CompositionRuleForEulerParameters(theta0, ExpS3(incRotVec))
+    
+    return np.block([x, theta])
+
+
+#**function: compute composition operation for pairs in the Lie group R3 semiTimes S3 (corresponds to SE(3))
+#**input: 
+#  q0: 7D vector as np.array containing position coordinates and Euler parameters
+#  incrementalMotionVector: 6D incremental motion vector as np.array
+#**output: 7D vector as np.array containing composed position coordinates and composed Euler parameters
+#**author: Stefan Holzinger
+def CompositionRuleSemiDirectProductR3AndS3(q0, incrementalMotionVector):
+    
+    # pair (x0, theta0)
+    x0     = q0[0:3]  # global COM position at time step t0
+    theta0 = q0[3:7]  # Euler parameters at time step t0
+    
+    # pair (delta x, incremental rotation vector)
+    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
+    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
+    
+    # compososition rule
+    R0  = EulerParameters2RotationMatrix(theta0)
+    x   = x0 + np.dot(R0, np.dot(np.transpose(TExpSO3(incRotVec)), delta_x))
+    theta = CompositionRuleForEulerParameters(theta0, ExpS3(incRotVec))
+    
+    return np.block([x, theta])
+
+
+#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3, see \cite{HolzingerGerstmayr2020}
+#            the rotation vector is used as rotation parametrizations
+#            this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
+#**input: 
+#  q0: 6D vector as np.array containing position coordinates and rotation vector
+#  incrementalMotionVector: 6D incremental motion vector as np.array
+#**output: 7D vector as np.array containing composed position coordinates and composed rotation vector
+#**author: Stefan Holzinger
+def CompositionRuleDirectProductR3AndR3RotVec(q0, incrementalMotionVector):
+    
+    # pair (x0, psi0)
+    x0   = q0[0:3]  # global COM position at time step t0
+    psi0 = q0[3:6]  # rotation vector at time step t0
+    
+    # pair (delta x, delta theta)
+    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
+    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
+    
+    # compososition rule
+    x   = x0 + delta_x
+    psi = CompositionRuleForRotationVectors(psi0, incRotVec)
+    
+    return np.block([x, psi])
+
+
+#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
+#            the rotation vector is used as rotation parametrizations
+#            this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
+#**input: 
+#  q0: 6D vector as np.array containing position coordinates and rotation vector
+#  incrementalMotionVector: 6D incremental motion vector as np.array
+#**output: 6D vector as np.array containing composed position coordinates and composed rotation vector
+#**author: Stefan Holzinger
+def CompositionRuleSemiDirectProductR3AndR3RotVec(q0, incrementalMotionVector):
+    
+    # pair (x0, psi0)
+    x0   = q0[0:3]  # global COM position at time step t0
+    psi0 = q0[3:6]  # rotation vector at time step t0
+    
+    # pair (delta x, delta theta)
+    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
+    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
+    
+    # compososition rule
+    R0  = ExpSO3(psi0)
+    x   = x0 + np.dot(R0, np.dot(np.transpose(TExpSO3(incRotVec)), delta_x))
+    psi = CompositionRuleForRotationVectors(psi0, incRotVec)
+    
+    return np.block([x, psi])
+
+
+#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
+#            Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
+#            this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
+#**input: 
+#  q0: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
+#  incrementalMotionVector: 6D incremental motion vector as np.array
+#**output: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles
+#**author: Stefan Holzinger
+def CompositionRuleDirectProductR3AndR3RotXYZAngles(q0, incrementalMotionVector):
+    
+    # pair (x0, psi0)
+    x0     = q0[0:3]  # global COM position at time step t0
+    alpha0 = q0[3:6]  # Cardan-Tait/Bryan angles at time step t0
+    
+    # pair (delta x, delta theta)
+    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
+    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
+    
+    # compososition rule
+    x   = x0 + delta_x
+    alpha = CompositionRuleRotXYZAnglesRotationVector(alpha0, incRotVec)
+    
+    return np.block([x, alpha])
+
+
+#**function: compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
+#            Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
+#            this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
+#**input: 
+#  q0: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
+#  incrementalMotionVector: 6D incremental motion vector as np.array
+#**output: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles
+#**author: Stefan Holzinger
+def CompositionRuleSemiDirectProductR3AndR3RotXYZAngles(q0, incrementalMotionVector):
+    
+    # pair (x0, psi0)
+    x0     = q0[0:3]  # global COM position at time step t0
+    alpha0 = q0[3:6]  # Cardan-Tait/Bryan angles at time step t0
+    
+    # pair (delta x, delta theta)
+    delta_x   = incrementalMotionVector[0:3] # global position increment of COM at time step t
+    incRotVec = incrementalMotionVector[3:6] # incremental rotation vector at time step t
+    
+    # compososition rule
+    R0    = RotXYZ2RotationMatrix(alpha0)
+    x     = x0 + np.dot(R0, np.dot(np.transpose(TExpSO3(incRotVec)), delta_x))
+    alpha = CompositionRuleRotXYZAnglesRotationVector(alpha0, incRotVec)
+    
+    return np.block([x, alpha])
+ 
+
+#**function: compute composition operation for Euler parameters (unit quaternions)
+#            this composition operation is quaternion multiplication, see \cite{Terze2016}
+#**input: 
+#  q: 4D vector as np.array containing Euler parameters
+#  p: 4D vector as np.array containing Euler parameters
+#**output: 4D vector as np.array containing composed (multiplied) Euler parameters
+#**author: Stefan Holzinger
+def CompositionRuleForEulerParameters(q, p):
+    p0 = p[0]
+    pV = p[1:4]
+    q0 = q[0]
+    qV = q[1:4]
+    x0 = q0*p0 - np.dot(qV,pV)
+    xV = q0*pV + p0*qV + np.cross(qV,pV)
+    return np.array([x0, xV[0], xV[1], xV[2]])
+
+
+#**function: compute composition operation for rotation vectors v0 and Omega, see \cite{Holzinger2021}
+#**input: 
+#  v0: 3D rotation vector as np.array
+#  Omega: 3D (incremental) rotation vector as np.array
+#**output: 3D vector as np.array containing composed rotation vector v
+#**author: Stefan Holzinger
+def CompositionRuleForRotationVectors(v0, Omega):
+    w1Half = 0.5*norm(v0)
+    w2Half = 0.5*norm(Omega)
+    c0 = cos(w1Half)
+    c1 = cos(w2Half)
+    s0 = Sinc(w1Half)
+    s1 = Sinc(w2Half)
+    x = c0*c1 - 0.25*s0*s1*np.dot(v0,Omega)
+    xPower = x**2
+    xTemp = sqrt(1 - xPower)
+    w = np.pi - 2*atan2(x,xTemp)        
+    rho = s0*c1*v0 + c0*s1*Omega + 0.5*s0*s1*np.cross(v0, Omega)
+    n = ComputeRotationAxisFromRotationVector(rho)
+    v = w*n
+    return v
+
+
+#**function: compute composition operation for RotXYZ angles, see \cite{Holzinger2021}
+#**input: 
+#  alpha0: 3D vector as np.array containing RotXYZ angles
+#  Omega:  3D vector as np.array containing the (incremental) rotation vector
+#**output: 3D vector as np.array containing composed RotXYZ angles
+#**author: Stefan Holzinger
+def CompositionRuleRotXYZAnglesRotationVector(alpha0, Omega):
+  
+    # Cardan-Tait/Bryan angles
+    psi0   = alpha0[0]
+    theta0 = alpha0[1]
+    phi0   = alpha0[2]
+    
+    # define unit vectors
+    e1 = np.array([1, 0, 0])
+    e2 = np.array([0, 1, 0])
+    e3 = np.array([0, 0, 1])
+    
+    # compute vectors u and v
+    R0 = RotXYZ2RotationMatrix(alpha0)
+    exp = ExpSO3(Omega)
+    u1 = np.dot(e1, R0) 
+    u2 = np.dot(e2, R0)
+    u3 = np.dot(e3, R0)
+    v1 = np.dot(exp, e1)
+    v2 = np.dot(exp, e2)
+    v3 = np.dot(exp, e3)
+    u1v3 = np.dot(u1,v3)
+    cosTheta = sqrt(1 - u1v3**2)
+    
+    # compute mu
+    if cosTheta == 0.0:
+        mu = 0
+    else:
+        mu = 1 / cosTheta
+    
+    # compute sine and cosine terms of incremental angle changes
+    sinPsi0 = sin(psi0)
+    cosPsi0 = cos(psi0)
+    sinTheta0 = sin(theta0)
+    cosTheta0 = cos(theta0)
+    sinPhi0 = sin(phi0)
+    cosPhi0 = cos(phi0)    
+    u2v3 = np.dot(u2,v3)
+    u3v3 = np.dot(u3,v3)
+    u1v2 = np.dot(u1,v2)
+    u1v1 = np.dot(u1,v1)    
+    y1 = -u2v3*cosPsi0 - u3v3*sinPsi0
+    x1 =  u3v3*cosPsi0 - u2v3*sinPsi0
+    y2 = u1v3*cosTheta0 - cosTheta*sinTheta0
+    x2 = cosTheta*cosTheta0 + u1v3*sinTheta0
+    y3 = -u1v2*cosPhi0 - u1v1*sinPhi0
+    x3 = u1v1*cosPhi0 - u1v2*sinPhi0
+    
+    # compute incremental angles changes
+    deltaPsi   = atan2(mu*y1, mu*x1)
+    deltaTheta = atan2(y2, x2)
+    deltaPhi   = atan2(mu*y3, mu*x3)
+    deltaAlpha = np.array([deltaPsi, deltaTheta, deltaPhi])
+    
+    return alpha0 + deltaAlpha
+
+
+
+
```

## exudyn/lieGroupIntegration.py

 * *Ordering differences only*

```diff
@@ -1,318 +1,318 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Lie group integration methods in Python; this is available for tests and research; 
-#           these methods are integrated into the C++ kernel as a larger set of explicit Lie group methods 
-#           and automatically used, if Lie group Nodes are used
-#               
-# Author:   Stefan Holzinger, Johannes Gerstmayr
-# Date:     2020-09-11
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-import exudyn as exu
-import exudyn.lieGroupBasics as elg
-import numpy as np
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#       LIE GROUP TIME INTEGRATION METHODS 
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-###############################################################################    
-def ComputeStepWithRK1(ODE2RHS, v0, w0, h):
-    w     = w0 + h*ODE2RHS(v0, w0)
-    Omega = h*w
-    v     = elg.CompositionRuleForRotationVectors(v0, Omega)
-    return [v, w]
-
-def ComputeStepWithRK1FromAcceleration(v0_t, v0, w0, h):
-    w     = w0 + h*v0_t
-    Omega = h*w
-    v     = elg.CompositionRuleForRotationVectors(v0, Omega)
-    return [v, w]
-
-def ComputeStepWithRK4(ODE2RHS, v0, w0, h):
-    
-    # compute slope estimations
-    k1 = h*ODE2RHS( v0, w0 )
-    K1 = h*np.dot( elg.TExpSO3Inv(np.zeros(3)), w0 )
-    
-    k2 = h*ODE2RHS( elg.CompositionRuleForRotationVectors(v0, 0.5*K1), w0+0.5*k1 )
-    K2 = h*np.dot( elg.TExpSO3Inv(0.5*K1), w0+0.5*k1 )
-    
-    k3 = h*ODE2RHS( elg.CompositionRuleForRotationVectors(v0, 0.5*K2), w0+0.5*k2 )
-    K3 = h*np.dot( elg.TExpSO3Inv(0.5*K2), w0+0.5*k2 )
-    
-    #k4 = h*ODE2RHS( v0, w0+k3 )
-    k4 = h*ODE2RHS( elg.CompositionRuleForRotationVectors(v0, K3), w0+k3 )
-    K4 = h*np.dot( elg.TExpSO3Inv(K3), w0+k3 )
-    
-    # compute update
-    w     = w0 + 1/6 * (k1 + 2*k2 + 2*k3 + k4)
-    Omega = 1/6 * (K1 + 2*K2 + 2*K3 + K4)
-    v     = elg.CompositionRuleForRotationVectors(v0, Omega)
-    
-    # return step solution
-    return [v, w]
-
-      
-def RK_SolveEulersEOMWithProposedApproach(ODE2RHS, v0, w0, tEnd, numberOfSteps, solver):
-    
-    # choose solver
-    if solver == "RK1":
-        def ComputeStep(ODE2RHS, v0, w0, h):
-            return ComputeStepWithRK1(ODE2RHS, v0, w0, h)
-    elif solver == "RK4":
-        def ComputeStep(ODE2RHS, v0, w0, h):
-            return ComputeStepWithRK4(ODE2RHS, v0, w0, h)    
-    else:
-        print('wished solver is not available!!')
-        
-    # compute time step size
-    h = tEnd/numberOfSteps
-    
-    # allocate memory
-    t = np.zeros(numberOfSteps+1)
-    v = np.zeros((numberOfSteps+1,3),dtype=float)
-    w = np.zeros((numberOfSteps+1,3),dtype=float)
-  
-    # set initial conditions
-    v[0] = v0
-    w[0] = w0
-    
-    # time integration loop
-    for i in range(numberOfSteps):
-        
-        # compute step i+1
-        stepSolution = ComputeStep(ODE2RHS, v[i], w[i], h)
-        
-        # update solution data
-        v[i+1] = stepSolution[0] # rotation vector update
-        w[i+1] = stepSolution[1] # angular velocity update
-        t[i+1] = (i+1)*h
-        
-    # solution data
-    solutionData = {"time": t,
-                    "rotationVector": v,
-                    "angularVelocity": w                    
-                    }
-    
-    # return solution data
-    return solutionData 
-
-
-
-
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#Explicit Lie group integrator using solver user function
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-#compute coordinates and LieGroup nodes lists for Explicit LieGroup RK
-def LieGroupExplicitRKInitialize(mainSys):
-    nObjects = mainSys.systemData.NumberOfObjects()
-    nNodes = mainSys.systemData.NumberOfNodes()
-#    lieGroupNodesList = []   #UNUSED #list of lie group nodes which need special treatment
-
-    lieGroupODE2indices = []
-    lieGroupReferenceRotations = [] #store reference values of nodes; need to be added to current values when computing rotation vectors
-    constrainedToGroundCoordinatesList = [] #list of constrained (fixed) ODE2 coordinates
-    constrainedCoordinatesList =[]  #list of pairs of constrained ODE2 coordinates
-    
-
-    for i in range(nNodes):
-        d = mainSys.GetNode(i)
-        if d['nodeType'] == 'RigidBodyRotVecLG':
-#            lieGroupNodesList += [i]
-            lieGroupODE2indices += [mainSys.GetNodeODE2Index(i)]
-            lieGroupReferenceRotations += [d['referenceCoordinates'][3:6] ]
-    
-    for i in range(nObjects):
-        d = mainSys.GetObject(i)
-        if d['objectType'] == 'ConnectorCoordinate':
-            if d['factorValue1'] != 1.: 
-                print('ConnectorCoordinate.factorValue1 must be 1., otherwise connector constraint cannot be resolved!')
-            elif d['offset'] != 0.: 
-                print('ConnectorCoordinate.offset must be 0., otherwise connector constraint cannot be resolved!')
-            elif d['activeConnector'] == True: #constrain only if connector is active!
-                markers = d['markerNumbers']
-                coords=[]
-                for j in markers:
-                    dm=mainSys.GetMarker(j)
-                    if dm['markerType'] == 'NodeCoordinate': #only works for NodeCoordinate for now
-                        nNode = dm['nodeNumber']
-                        nCoordinate = dm['coordinate']
-                        dn = mainSys.GetNode(nNode)
-                        if dn['nodeType'] != 'PointGround':
-                            coords+=[mainSys.GetNodeODE2Index(nNode)+nCoordinate]
-                if len(coords) == 2:
-                    constrainedCoordinatesList += [coords] #these global coordinates need to be fixed to each other
-                else:
-                    constrainedToGroundCoordinatesList += [coords[0]] #this global coordinate needs to be fixed
-#    print("constrained coordinates =",constrainedToGroundCoordinatesList)
-    mainSys.sys['lieGroupODE2indices'] = lieGroupODE2indices
-    mainSys.sys['lieGroupReferenceRotations'] = lieGroupReferenceRotations
-    
-    mainSys.sys['constrainedToGroundCoordinatesList'] = constrainedToGroundCoordinatesList
-    mainSys.sys['constrainedCoordinatesList'] = constrainedCoordinatesList
-    
-#compute accelerations for current state; used for explicit RK integrator
-def ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2):
-    mainSolver.ComputeODE2RHS(mainSys)
-    res = mainSolver.GetSystemResidual()
-    Fode2 = res[0:nODE2]
-    mainSolver.ComputeMassMatrix(mainSys)
-    M = mainSolver.GetSystemMassMatrix()
-#    print("Fode2=",Fode2)
-#    print("M=",np.diag(M))
-    
-    #adjust mass and force for constrained coordinates:
-    #cCoords[0] is the relevant coordinate
-    for cCoords in mainSys.sys['constrainedCoordinatesList']: #list of pairs of constrained ODE2 coordinates
-        M[cCoords[0]][cCoords[0]] += M[cCoords[0]][cCoords[1]]
-        M[cCoords[0]][cCoords[0]] += M[cCoords[1]][cCoords[0]]
-        M[cCoords[0]][cCoords[0]] += M[cCoords[1]][cCoords[1]]
-
-        Fode2[cCoords[0]] += Fode2[cCoords[1]]
-    
-    a0= np.linalg.solve(M,Fode2)[0:nODE2] #acceleration
-    return a0
-
-#computes global K for rotation vector update; used for explicit LieGroup RK integrator
-#v0 is startOfStep global velocity vector
-#Kprev is K of previous stage
-def LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, Kprev, kprev, factK):
-
-    #K = np.zeros(nODE2)
-    K = h*(v0[0:nODE2] + factK*kprev) #this is the correct displacement stage for non-LieGroup coordinates; LieGroup coordinates will be overwritten!
-    for i in mainSys.sys['lieGroupODE2indices']:
-        i1 = i+3 #start index of rotation
-        i2 = i+6 #end index of rotation
-        omega0 = v0[i1:i2]
-        K0 = Kprev[i1:i2]
-        k0 = kprev[i1:i2]
-        K[i1:i2] = h*np.dot(elg.TExpSO3Inv(factK*K0), omega0 + factK*k0)
-        
-    return K
-
-#apply coordinate constraints to updated system coordinates; used for explicit RK integrator
-def ExplicitRKApplyCoordinateConstraints(mainSys):
-    u = mainSys.systemData.GetODE2Coordinates()
-    v = mainSys.systemData.GetODE2Coordinates_t()
-    for i in mainSys.sys['constrainedToGroundCoordinatesList']: #list of constrained (fixed) ODE2 coordinates
-        u[i] = 0 #offset could be considered here very easy
-        v[i] = 0
-
-    for cCoords in mainSys.sys['constrainedCoordinatesList']: #list of pairs of constrained ODE2 coordinates
-        u[cCoords[1]] = u[cCoords[0]] #cCoords[0] coordinate has been considered in ODE2RHS computation and contains correct motion
-        v[cCoords[1]] = v[cCoords[0]] 
-
-    mainSys.systemData.SetODE2Coordinates(u)
-    mainSys.systemData.SetODE2Coordinates_t(v)    
-
-
-#update rotation vector and angular velocities for every Lie group node; used for explicit LieGroup RK integrator
-def LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, Kprev, kprev, factK):
-#    u = mainSys.systemData.GetODE2Coordinates()
-#    v = mainSys.systemData.GetODE2Coordinates_t()
-
-    #RK stage update for non-LieGroup coordinates
-    u = u0[0:nODE2] + factK * Kprev
-    v = v0[0:nODE2] + factK * kprev
-
-    #update rotation vector and angular velocities for every Lie group node: 
-    cnt = 0
-    for i in mainSys.sys['lieGroupODE2indices']:
-        i1 = i+3 #start index of rotation
-        i2 = i+6 #end index of rotation
-        vecRef = mainSys.sys['lieGroupReferenceRotations'][cnt]
-        vec0 = vecRef + u0[i1:i2]
-        omega0 = v0[i1:i2]
-        K = Kprev[i1:i2]
-        k = kprev[i1:i2]
-        u[i1:i2] = elg.CompositionRuleForRotationVectors(vec0, factK*K) - vecRef
-        #print("k=",k, ",factK=", factK, ",omega0=", omega0)
-        v[i1:i2] = omega0+factK*k #could be omitted
-        cnt += 1
-
-    mainSys.systemData.SetODE2Coordinates(u)
-    mainSys.systemData.SetODE2Coordinates_t(v)    
-    ExplicitRKApplyCoordinateConstraints(mainSys)
-
-#user function for Newton to realize explicit RK4 solver with LieGroup integration
-#USAGE:
-#dynamicSolver = exu.MainSolverImplicitSecondOrder()
-#dynamicSolver.SetUserFunctionNewton(mbs, UserFunctionNewtonLieGroupRK4)
-#dynamicSolver.SolveSystem(mbs, simulationSettings)
-def UserFunctionNewtonLieGroupRK4(mainSolver, mainSys, sims):
-
-    h = mainSolver.it.currentStepSize
-    tend = mainSys.systemData.GetTime() #end of step time
-    t0 = mainSys.systemData.GetTime(exu.ConfigurationType.StartOfStep) #start of step time
-    #print("tstart0=", t0)
-
-    nODE2 = mainSolver.GetODE2size()
-    #nAE = mainSolver.GetAEsize()
-    #nSys = nODE2+nAE
-
-    #+++++++++++++++++++++++++++++++++++++     
-    u0 = mainSys.systemData.GetODE2Coordinates()
-    #uRef=mainSys.systemData.GetODE2Coordinates(configuration = exu.ConfigurationType.Reference)
-    v0 = mainSys.systemData.GetODE2Coordinates_t()
-     
-    #K0 = np.zeros(nODE2)
-    mainSys.systemData.SetTime(t0)
-    k1 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)#velocities
-    #K1 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K0, K0, 0.)      #displacements; K0==k0; 
-    K1 = h*v0[0:nODE2]
-
-    mainSys.systemData.SetTime(t0 + 0.5*h)
-    LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K1, k1, 0.5)
-    k2 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
-    K2 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K1, k1, 0.5)
-    
-    mainSys.systemData.SetTime(t0 + 0.5*h)
-    LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K2, k2, 0.5)
-    k3 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
-    K3 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K2, k2, 0.5)
-    
-    mainSys.systemData.SetTime(t0 + h) #this is also the step end time
-    LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K3, k3, 1.)
-    k4 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
-    K4 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K3, k3, 1.)
-    
-    #++++++++++++++++++
-    mainSys.systemData.SetTime(tend)
-    # compute update for end of step
-    #global update for velocities (same for all velocities!)
-    vStep      = v0 + 1./6. * (k1 + 2*k2 + 2*k3 + k4)
-    #incremental rotation vector, can be computed globally:
-    deltaU     = 1./6. * (K1 + 2*K2 + 2*K3 + K4) #contains displacement updates and incremental velocity vectors
-    
-    uStep = u0 + deltaU #standard update for non-LieGroup nodes
-    
-    #compute final rotation vector updates based on deltaU:
-    cnt = 0
-    for i in mainSys.sys['lieGroupODE2indices']:
-        i1 = i+3 #start index of rotation
-        i2 = i+6 #end index of rotation
-        vecRef = mainSys.sys['lieGroupReferenceRotations'][cnt]
-        vec0 = vecRef + u0[i1:i2]
-        #vec0 = u0[i1:i2]
-        incrRotVec = deltaU[i1:i2]
-        uStep[i1:i2] = elg.CompositionRuleForRotationVectors(vec0, incrRotVec) - vecRef
-        cnt += 1
-        
-    mainSys.systemData.SetODE2Coordinates(uStep)
-    mainSys.systemData.SetODE2Coordinates_t(vStep)
-
-    ExplicitRKApplyCoordinateConstraints(mainSys)
-
-    return True
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Lie group integration methods in Python; this is available for tests and research; 
+#           these methods are integrated into the C++ kernel as a larger set of explicit Lie group methods 
+#           and automatically used, if Lie group Nodes are used
+#               
+# Author:   Stefan Holzinger, Johannes Gerstmayr
+# Date:     2020-09-11
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+import exudyn as exu
+import exudyn.lieGroupBasics as elg
+import numpy as np
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#       LIE GROUP TIME INTEGRATION METHODS 
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+###############################################################################    
+def ComputeStepWithRK1(ODE2RHS, v0, w0, h):
+    w     = w0 + h*ODE2RHS(v0, w0)
+    Omega = h*w
+    v     = elg.CompositionRuleForRotationVectors(v0, Omega)
+    return [v, w]
+
+def ComputeStepWithRK1FromAcceleration(v0_t, v0, w0, h):
+    w     = w0 + h*v0_t
+    Omega = h*w
+    v     = elg.CompositionRuleForRotationVectors(v0, Omega)
+    return [v, w]
+
+def ComputeStepWithRK4(ODE2RHS, v0, w0, h):
+    
+    # compute slope estimations
+    k1 = h*ODE2RHS( v0, w0 )
+    K1 = h*np.dot( elg.TExpSO3Inv(np.zeros(3)), w0 )
+    
+    k2 = h*ODE2RHS( elg.CompositionRuleForRotationVectors(v0, 0.5*K1), w0+0.5*k1 )
+    K2 = h*np.dot( elg.TExpSO3Inv(0.5*K1), w0+0.5*k1 )
+    
+    k3 = h*ODE2RHS( elg.CompositionRuleForRotationVectors(v0, 0.5*K2), w0+0.5*k2 )
+    K3 = h*np.dot( elg.TExpSO3Inv(0.5*K2), w0+0.5*k2 )
+    
+    #k4 = h*ODE2RHS( v0, w0+k3 )
+    k4 = h*ODE2RHS( elg.CompositionRuleForRotationVectors(v0, K3), w0+k3 )
+    K4 = h*np.dot( elg.TExpSO3Inv(K3), w0+k3 )
+    
+    # compute update
+    w     = w0 + 1/6 * (k1 + 2*k2 + 2*k3 + k4)
+    Omega = 1/6 * (K1 + 2*K2 + 2*K3 + K4)
+    v     = elg.CompositionRuleForRotationVectors(v0, Omega)
+    
+    # return step solution
+    return [v, w]
+
+      
+def RK_SolveEulersEOMWithProposedApproach(ODE2RHS, v0, w0, tEnd, numberOfSteps, solver):
+    
+    # choose solver
+    if solver == "RK1":
+        def ComputeStep(ODE2RHS, v0, w0, h):
+            return ComputeStepWithRK1(ODE2RHS, v0, w0, h)
+    elif solver == "RK4":
+        def ComputeStep(ODE2RHS, v0, w0, h):
+            return ComputeStepWithRK4(ODE2RHS, v0, w0, h)    
+    else:
+        print('wished solver is not available!!')
+        
+    # compute time step size
+    h = tEnd/numberOfSteps
+    
+    # allocate memory
+    t = np.zeros(numberOfSteps+1)
+    v = np.zeros((numberOfSteps+1,3),dtype=float)
+    w = np.zeros((numberOfSteps+1,3),dtype=float)
+  
+    # set initial conditions
+    v[0] = v0
+    w[0] = w0
+    
+    # time integration loop
+    for i in range(numberOfSteps):
+        
+        # compute step i+1
+        stepSolution = ComputeStep(ODE2RHS, v[i], w[i], h)
+        
+        # update solution data
+        v[i+1] = stepSolution[0] # rotation vector update
+        w[i+1] = stepSolution[1] # angular velocity update
+        t[i+1] = (i+1)*h
+        
+    # solution data
+    solutionData = {"time": t,
+                    "rotationVector": v,
+                    "angularVelocity": w                    
+                    }
+    
+    # return solution data
+    return solutionData 
+
+
+
+
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#Explicit Lie group integrator using solver user function
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+#compute coordinates and LieGroup nodes lists for Explicit LieGroup RK
+def LieGroupExplicitRKInitialize(mainSys):
+    nObjects = mainSys.systemData.NumberOfObjects()
+    nNodes = mainSys.systemData.NumberOfNodes()
+#    lieGroupNodesList = []   #UNUSED #list of lie group nodes which need special treatment
+
+    lieGroupODE2indices = []
+    lieGroupReferenceRotations = [] #store reference values of nodes; need to be added to current values when computing rotation vectors
+    constrainedToGroundCoordinatesList = [] #list of constrained (fixed) ODE2 coordinates
+    constrainedCoordinatesList =[]  #list of pairs of constrained ODE2 coordinates
+    
+
+    for i in range(nNodes):
+        d = mainSys.GetNode(i)
+        if d['nodeType'] == 'RigidBodyRotVecLG':
+#            lieGroupNodesList += [i]
+            lieGroupODE2indices += [mainSys.GetNodeODE2Index(i)]
+            lieGroupReferenceRotations += [d['referenceCoordinates'][3:6] ]
+    
+    for i in range(nObjects):
+        d = mainSys.GetObject(i)
+        if d['objectType'] == 'ConnectorCoordinate':
+            if d['factorValue1'] != 1.: 
+                print('ConnectorCoordinate.factorValue1 must be 1., otherwise connector constraint cannot be resolved!')
+            elif d['offset'] != 0.: 
+                print('ConnectorCoordinate.offset must be 0., otherwise connector constraint cannot be resolved!')
+            elif d['activeConnector'] == True: #constrain only if connector is active!
+                markers = d['markerNumbers']
+                coords=[]
+                for j in markers:
+                    dm=mainSys.GetMarker(j)
+                    if dm['markerType'] == 'NodeCoordinate': #only works for NodeCoordinate for now
+                        nNode = dm['nodeNumber']
+                        nCoordinate = dm['coordinate']
+                        dn = mainSys.GetNode(nNode)
+                        if dn['nodeType'] != 'PointGround':
+                            coords+=[mainSys.GetNodeODE2Index(nNode)+nCoordinate]
+                if len(coords) == 2:
+                    constrainedCoordinatesList += [coords] #these global coordinates need to be fixed to each other
+                else:
+                    constrainedToGroundCoordinatesList += [coords[0]] #this global coordinate needs to be fixed
+#    print("constrained coordinates =",constrainedToGroundCoordinatesList)
+    mainSys.sys['lieGroupODE2indices'] = lieGroupODE2indices
+    mainSys.sys['lieGroupReferenceRotations'] = lieGroupReferenceRotations
+    
+    mainSys.sys['constrainedToGroundCoordinatesList'] = constrainedToGroundCoordinatesList
+    mainSys.sys['constrainedCoordinatesList'] = constrainedCoordinatesList
+    
+#compute accelerations for current state; used for explicit RK integrator
+def ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2):
+    mainSolver.ComputeODE2RHS(mainSys)
+    res = mainSolver.GetSystemResidual()
+    Fode2 = res[0:nODE2]
+    mainSolver.ComputeMassMatrix(mainSys)
+    M = mainSolver.GetSystemMassMatrix()
+#    print("Fode2=",Fode2)
+#    print("M=",np.diag(M))
+    
+    #adjust mass and force for constrained coordinates:
+    #cCoords[0] is the relevant coordinate
+    for cCoords in mainSys.sys['constrainedCoordinatesList']: #list of pairs of constrained ODE2 coordinates
+        M[cCoords[0]][cCoords[0]] += M[cCoords[0]][cCoords[1]]
+        M[cCoords[0]][cCoords[0]] += M[cCoords[1]][cCoords[0]]
+        M[cCoords[0]][cCoords[0]] += M[cCoords[1]][cCoords[1]]
+
+        Fode2[cCoords[0]] += Fode2[cCoords[1]]
+    
+    a0= np.linalg.solve(M,Fode2)[0:nODE2] #acceleration
+    return a0
+
+#computes global K for rotation vector update; used for explicit LieGroup RK integrator
+#v0 is startOfStep global velocity vector
+#Kprev is K of previous stage
+def LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, Kprev, kprev, factK):
+
+    #K = np.zeros(nODE2)
+    K = h*(v0[0:nODE2] + factK*kprev) #this is the correct displacement stage for non-LieGroup coordinates; LieGroup coordinates will be overwritten!
+    for i in mainSys.sys['lieGroupODE2indices']:
+        i1 = i+3 #start index of rotation
+        i2 = i+6 #end index of rotation
+        omega0 = v0[i1:i2]
+        K0 = Kprev[i1:i2]
+        k0 = kprev[i1:i2]
+        K[i1:i2] = h*np.dot(elg.TExpSO3Inv(factK*K0), omega0 + factK*k0)
+        
+    return K
+
+#apply coordinate constraints to updated system coordinates; used for explicit RK integrator
+def ExplicitRKApplyCoordinateConstraints(mainSys):
+    u = mainSys.systemData.GetODE2Coordinates()
+    v = mainSys.systemData.GetODE2Coordinates_t()
+    for i in mainSys.sys['constrainedToGroundCoordinatesList']: #list of constrained (fixed) ODE2 coordinates
+        u[i] = 0 #offset could be considered here very easy
+        v[i] = 0
+
+    for cCoords in mainSys.sys['constrainedCoordinatesList']: #list of pairs of constrained ODE2 coordinates
+        u[cCoords[1]] = u[cCoords[0]] #cCoords[0] coordinate has been considered in ODE2RHS computation and contains correct motion
+        v[cCoords[1]] = v[cCoords[0]] 
+
+    mainSys.systemData.SetODE2Coordinates(u)
+    mainSys.systemData.SetODE2Coordinates_t(v)    
+
+
+#update rotation vector and angular velocities for every Lie group node; used for explicit LieGroup RK integrator
+def LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, Kprev, kprev, factK):
+#    u = mainSys.systemData.GetODE2Coordinates()
+#    v = mainSys.systemData.GetODE2Coordinates_t()
+
+    #RK stage update for non-LieGroup coordinates
+    u = u0[0:nODE2] + factK * Kprev
+    v = v0[0:nODE2] + factK * kprev
+
+    #update rotation vector and angular velocities for every Lie group node: 
+    cnt = 0
+    for i in mainSys.sys['lieGroupODE2indices']:
+        i1 = i+3 #start index of rotation
+        i2 = i+6 #end index of rotation
+        vecRef = mainSys.sys['lieGroupReferenceRotations'][cnt]
+        vec0 = vecRef + u0[i1:i2]
+        omega0 = v0[i1:i2]
+        K = Kprev[i1:i2]
+        k = kprev[i1:i2]
+        u[i1:i2] = elg.CompositionRuleForRotationVectors(vec0, factK*K) - vecRef
+        #print("k=",k, ",factK=", factK, ",omega0=", omega0)
+        v[i1:i2] = omega0+factK*k #could be omitted
+        cnt += 1
+
+    mainSys.systemData.SetODE2Coordinates(u)
+    mainSys.systemData.SetODE2Coordinates_t(v)    
+    ExplicitRKApplyCoordinateConstraints(mainSys)
+
+#user function for Newton to realize explicit RK4 solver with LieGroup integration
+#USAGE:
+#dynamicSolver = exu.MainSolverImplicitSecondOrder()
+#dynamicSolver.SetUserFunctionNewton(mbs, UserFunctionNewtonLieGroupRK4)
+#dynamicSolver.SolveSystem(mbs, simulationSettings)
+def UserFunctionNewtonLieGroupRK4(mainSolver, mainSys, sims):
+
+    h = mainSolver.it.currentStepSize
+    tend = mainSys.systemData.GetTime() #end of step time
+    t0 = mainSys.systemData.GetTime(exu.ConfigurationType.StartOfStep) #start of step time
+    #print("tstart0=", t0)
+
+    nODE2 = mainSolver.GetODE2size()
+    #nAE = mainSolver.GetAEsize()
+    #nSys = nODE2+nAE
+
+    #+++++++++++++++++++++++++++++++++++++     
+    u0 = mainSys.systemData.GetODE2Coordinates()
+    #uRef=mainSys.systemData.GetODE2Coordinates(configuration = exu.ConfigurationType.Reference)
+    v0 = mainSys.systemData.GetODE2Coordinates_t()
+     
+    #K0 = np.zeros(nODE2)
+    mainSys.systemData.SetTime(t0)
+    k1 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)#velocities
+    #K1 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K0, K0, 0.)      #displacements; K0==k0; 
+    K1 = h*v0[0:nODE2]
+
+    mainSys.systemData.SetTime(t0 + 0.5*h)
+    LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K1, k1, 0.5)
+    k2 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
+    K2 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K1, k1, 0.5)
+    
+    mainSys.systemData.SetTime(t0 + 0.5*h)
+    LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K2, k2, 0.5)
+    k3 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
+    K3 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K2, k2, 0.5)
+    
+    mainSys.systemData.SetTime(t0 + h) #this is also the step end time
+    LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K3, k3, 1.)
+    k4 = h*ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
+    K4 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K3, k3, 1.)
+    
+    #++++++++++++++++++
+    mainSys.systemData.SetTime(tend)
+    # compute update for end of step
+    #global update for velocities (same for all velocities!)
+    vStep      = v0 + 1./6. * (k1 + 2*k2 + 2*k3 + k4)
+    #incremental rotation vector, can be computed globally:
+    deltaU     = 1./6. * (K1 + 2*K2 + 2*K3 + K4) #contains displacement updates and incremental velocity vectors
+    
+    uStep = u0 + deltaU #standard update for non-LieGroup nodes
+    
+    #compute final rotation vector updates based on deltaU:
+    cnt = 0
+    for i in mainSys.sys['lieGroupODE2indices']:
+        i1 = i+3 #start index of rotation
+        i2 = i+6 #end index of rotation
+        vecRef = mainSys.sys['lieGroupReferenceRotations'][cnt]
+        vec0 = vecRef + u0[i1:i2]
+        #vec0 = u0[i1:i2]
+        incrRotVec = deltaU[i1:i2]
+        uStep[i1:i2] = elg.CompositionRuleForRotationVectors(vec0, incrRotVec) - vecRef
+        cnt += 1
+        
+    mainSys.systemData.SetODE2Coordinates(uStep)
+    mainSys.systemData.SetODE2Coordinates_t(vStep)
+
+    ExplicitRKApplyCoordinateConstraints(mainSys)
+
+    return True
+
+
```

## exudyn/machines.py

 * *Ordering differences only*

```diff
@@ -1,79 +1,79 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  The machines library includes helper functions and classes for
-#           mechanical engineering and machine elements, in particular bearings, gears, mechanisms
-#
-# Authors:  Johannes Gerstmayr
-# Date:     2023-01-06
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-from math import tan, atan
-#from math import sin, cos, asin, acos, pi, exp, log, tan, atan
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute involute (x being in radians): $y=\\tan(x)-x$; 
-def Involute(x):
-    if abs(x) < 0.02:
-        return ApproxInvolute(x)
-    return tan(x)-x
-
-#**function: Approximate involute for $|x| < 0.02$, being more accurate than tan: $y=\\tan(x)-x \approx (1/3) x^3 + (2/15) x^5$; 
-def ApproxInvolute(x):
-    return (1./3.) * x**3 + (2./15.) * x**5 + (17./315.) * x**7
-
-#**function: compute inverse of involute, see Involute(x); computes $x$ for given $y$ in $y=\\tan(x)-x$ using Newton-Raphson method
-#**input: y provides given value; if warn==True, a warning is displayed if no convergence is achieved
-#**notes: uses Newton-Raphson method (iteratively); usually converges within 4-5 steps
-def InvInvolute(y, warn=True):
-    #compute starting value:
-    if abs(y) > 2:
-        x0 = atan(y)
-    else:
-        x0 = np.cbrt(3*y) - 2./5.*y  #numpy cubic root also includes negative case!
-    
-    converged = False
-    maxIt = 10
-    it = 0
-    while not converged and it < maxIt:
-        tanX0 = tan(x0)
-        if abs(x0) < 0.02:
-            d = (y - ApproxInvolute(x0))/tanX0**2
-        else:
-            d = (y-(tanX0-x0))/tanX0**2
-        if abs(d) < 1e-13: #last iteration should do the rest ...
-            converged = True
-        x0 += d
-        it += 1
-        #print(d)
-    print('it=',it)
-    if it == maxIt and warn:
-        raise ValueError('ERROR: InvInvolute(...) did not converge within 10 steps!')
-
-    return x0
-
-#%%++++++++++++++++++++++++
-#testing of involute and approximated involute
-if __name__ == '__main__':
-    if False:
-        for i in range(40):
-            x = 2**(-i/2)
-            print('x=', x,'Inv=', Involute(x), ', Approx Inv=', ApproxInvolute(x), ', diff=', ApproxInvolute(x)-Involute(x), 'err term=', (62/2835)*x**9)  
-            #==> error term < diff for x<0.02
-
-    #test InvInvolute:
-    #iteration number largest for x \approx 1
-    for i in range(80): #80 goes up to x=2e-46, invinv=9e-16
-        x = 100*2**(-2*i) 
-        print('x=', x,'InvInv=', InvInvolute(x), ', Involute(InvInv)-x=', Involute(InvInvolute(x))-x)  
-        
-    for i in range(80): #80 goes up to x=2e-46, invinv=9e-16
-        x = -100*2**(-2*i)
-        print('x=', x,'InvInv=', InvInvolute(x), ', Involute(InvInv)-x=', Involute(InvInvolute(x))-x)  
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  The machines library includes helper functions and classes for
+#           mechanical engineering and machine elements, in particular bearings, gears, mechanisms
+#
+# Authors:  Johannes Gerstmayr
+# Date:     2023-01-06
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+from math import tan, atan
+#from math import sin, cos, asin, acos, pi, exp, log, tan, atan
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute involute (x being in radians): $y=\\tan(x)-x$; 
+def Involute(x):
+    if abs(x) < 0.02:
+        return ApproxInvolute(x)
+    return tan(x)-x
+
+#**function: Approximate involute for $|x| < 0.02$, being more accurate than tan: $y=\\tan(x)-x \approx (1/3) x^3 + (2/15) x^5$; 
+def ApproxInvolute(x):
+    return (1./3.) * x**3 + (2./15.) * x**5 + (17./315.) * x**7
+
+#**function: compute inverse of involute, see Involute(x); computes $x$ for given $y$ in $y=\\tan(x)-x$ using Newton-Raphson method
+#**input: y provides given value; if warn==True, a warning is displayed if no convergence is achieved
+#**notes: uses Newton-Raphson method (iteratively); usually converges within 4-5 steps
+def InvInvolute(y, warn=True):
+    #compute starting value:
+    if abs(y) > 2:
+        x0 = atan(y)
+    else:
+        x0 = np.cbrt(3*y) - 2./5.*y  #numpy cubic root also includes negative case!
+    
+    converged = False
+    maxIt = 10
+    it = 0
+    while not converged and it < maxIt:
+        tanX0 = tan(x0)
+        if abs(x0) < 0.02:
+            d = (y - ApproxInvolute(x0))/tanX0**2
+        else:
+            d = (y-(tanX0-x0))/tanX0**2
+        if abs(d) < 1e-13: #last iteration should do the rest ...
+            converged = True
+        x0 += d
+        it += 1
+        #print(d)
+    print('it=',it)
+    if it == maxIt and warn:
+        raise ValueError('ERROR: InvInvolute(...) did not converge within 10 steps!')
+
+    return x0
+
+#%%++++++++++++++++++++++++
+#testing of involute and approximated involute
+if __name__ == '__main__':
+    if False:
+        for i in range(40):
+            x = 2**(-i/2)
+            print('x=', x,'Inv=', Involute(x), ', Approx Inv=', ApproxInvolute(x), ', diff=', ApproxInvolute(x)-Involute(x), 'err term=', (62/2835)*x**9)  
+            #==> error term < diff for x<0.02
+
+    #test InvInvolute:
+    #iteration number largest for x \approx 1
+    for i in range(80): #80 goes up to x=2e-46, invinv=9e-16
+        x = 100*2**(-2*i) 
+        print('x=', x,'InvInv=', InvInvolute(x), ', Involute(InvInv)-x=', Involute(InvInvolute(x))-x)  
+        
+    for i in range(80): #80 goes up to x=2e-46, invinv=9e-16
+        x = -100*2**(-2*i)
+        print('x=', x,'InvInv=', InvInvolute(x), ', Involute(InvInv)-x=', Involute(InvInvolute(x))-x)  
+
```

## exudyn/mainSystemExtensions.py

```diff
@@ -1,1691 +1,1689 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  This module provides an extension interface to the C++ class MainSystem;
-#           MainSystem is extended by Python interface functions to easily create
-#           bodies and point masses without the need to create an according node and
-#           connectors and joints without the need to create markers.
-#           For activation of Python extension in the mainSystem, 
-#           just write: \\ \texttt{import exudyn.mainSystemExtensions} or 
-#           import \texttt{exudyn.utilities}
-#
-# Author:   Johannes Gerstmayr
-# Date:     2023-05-07 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#import exudyn #does not work out of exudyn.__init__.py
-import exudyn as exu
-import exudyn.plot
-import exudyn.solver
-import exudyn.interactive
-#import exudyn.robotics
-import exudyn.utilities
-
-from exudyn.rigidBodyUtilities import GetRigidBodyNode, ComputeOrthonormalBasis, \
-    RotationMatrix2EulerParameters, AngularVelocity2EulerParameters_t, RotationMatrix2RotXYZ, AngularVelocity2RotXYZ_t, \
-    RotationMatrix2RotationVector
-
-import exudyn.itemInterface as eii 
-from exudyn.advancedUtilities import RaiseTypeError, IsVector, ExpectedType, IsValidObjectIndex, IsValidNodeIndex, \
-                                    IsValidRealInt, IsValidPRealInt, IsValidURealInt, IsIntVector, \
-                                    IsValidBool, IsSquareMatrix
-
-from exudyn.graphicsDataUtilities import color4default, color4red
-import numpy as np
-import copy
-
-#exudyn.Print('WARNING: mainSystemInterface is available only for testing; it may fail on certain architectures; use with care')
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#add helpful Python extensions for MainSystem, regarding creation of bodies, point masses, connectors and joints
-
-#internal function: do some pre-checks and calculations for joint
-def JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame):
-    #perform some checks:
-    if not exudyn.__useExudynFast:
-        if not isinstance(bodyNumbers, list) or len(bodyNumbers) != 2:
-            RaiseTypeError(where=where, argumentName='bodyNumbers', received = bodyNumbers, expectedType = 'list of 2 body numbers')
-        if not IsValidObjectIndex(bodyNumbers[0]):
-            RaiseTypeError(where=where, argumentName='bodyNumbers[0]', received = bodyNumbers[0], expectedType = ExpectedType.ObjectIndex)
-        if not IsValidObjectIndex(bodyNumbers[1]):
-            RaiseTypeError(where=where, argumentName='bodyNumbers[1]', received = bodyNumbers[1], expectedType = ExpectedType.ObjectIndex)
-    
-        if not IsVector(position, 3):
-            RaiseTypeError(where=where, argumentName='position', received = position, expectedType = ExpectedType.Vector, dim=3)
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidBool(useGlobalFrame):
-            RaiseTypeError(where=where, argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-    p0 = mbs.GetObjectOutputBody(bodyNumbers[0],exudyn.OutputVariableType.Position,
-                                 localPosition=[0,0,0],
-                                 configuration=exudyn.ConfigurationType.Reference)
-    A0 = mbs.GetObjectOutputBody(bodyNumbers[0],exudyn.OutputVariableType.RotationMatrix,
-                                 localPosition=[0,0,0],
-                                 configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
-    p1 = mbs.GetObjectOutputBody(bodyNumbers[1],exudyn.OutputVariableType.Position,
-                                 localPosition=[0,0,0],
-                                 configuration=exudyn.ConfigurationType.Reference)
-    A1 = mbs.GetObjectOutputBody(bodyNumbers[1],exudyn.OutputVariableType.RotationMatrix,
-                                 localPosition=[0,0,0],
-                                 configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
-
-    return [p0, A0, p1, A1] 
-
-#internal function, which checks bodyList and bodyOrNodeList and returns appropriate bodyOrNodeList
-def ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where):
-    if not exudyn.__useExudynFast:
-        if not isinstance(bodyList, list) or len(bodyList) != 2:
-            RaiseTypeError(where=where, argumentName='bodyList', received = bodyList, expectedType = 'list of 2 body or node numbers')
-
-    causingArgName = 'bodyOrNodeList'
-    if bodyList[0] != None or bodyList[1] != None:
-        bodyOrNodeList = [bodyList[0],bodyList[1]] #flat copy, but otherwise would lead to change of args (mutable args!)
-        causingArgName = 'bodyList'
-        # if bodyList[0] == None or bodyList[1] == None:
-        #     raise ValueError(where+': bodyList contained None in one of the list items')
-        
-    if not exudyn.__useExudynFast:
-        if not isinstance(bodyOrNodeList, list) or len(bodyOrNodeList) != 2:
-            RaiseTypeError(where=where, argumentName='bodyOrNodeList', received = bodyOrNodeList, expectedType = 'list of 2 body or node numbers')
-    
-        if not (isinstance(bodyOrNodeList[0], exudyn.ObjectIndex) or (isinstance(bodyOrNodeList[0], exudyn.NodeIndex) and localPosition0==[0.,0.,0.])):
-            RaiseTypeError(where=where, argumentName=''+causingArgName+'[0]', received = bodyOrNodeList[0], 
-                           expectedType = 'expected either ObjectIndex or NodeIndex and localPosition0=[0.,0.,0.]')
-            
-        if not (isinstance(bodyOrNodeList[1], exudyn.ObjectIndex) or (isinstance(bodyOrNodeList[1], exudyn.NodeIndex) and localPosition1==[0.,0.,0.])):
-            RaiseTypeError(where=where, argumentName=''+causingArgName+'[1]', received = bodyOrNodeList[1], 
-                           expectedType = 'expected either ObjectIndex or NodeIndex and localPosition1=[0.,0.,0.]')
-    
-    return bodyOrNodeList
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create a ground object, using arguments of ObjectGround; this function is mainly added for consistency with other mainSystemExtensions
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for object
-#  referencePosition: reference coordinates for point node (always a 3D vector, no matter if 2D or 3D mass)
-#  referenceRotationMatrix: reference rotation matrix for rigid body node (always 3D matrix, no matter if 2D or 3D body)
-#  graphicsDataList: list of GraphicsData for optional ground visualization
-#  graphicsDataUserFunction: a user function graphicsDataUserFunction(mbs, itemNumber)->BodyGraphicsData (list of GraphicsData), which can be used to draw user-defined graphics; this is much slower than regular GraphicsData
-#  color: color of node
-#  show: True: show ground object; 
-#**output: ObjectIndex; returns ground object index 
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# ground=mbs.CreateGround(referencePosition = [2,0,0],
-#                         graphicsDataList = [GraphicsDataCheckerBoard(point=[0,0,0], normal=[0,1,0],size=4)])
-# 
-def MainSystemCreateGround(mbs,
-                           name = '',   
-                           referencePosition = [0.,0.,0.],
-                           referenceRotationMatrix = np.eye(3),
-                           graphicsDataList = [],
-                           graphicsDataUserFunction = 0,
-                           show = True): 
-
-    #error checks:        
-    if not exudyn.__useExudynFast:
-        where='MainSystem.CreateGround(...)'
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-        if not IsVector(referencePosition, 3):
-            RaiseTypeError(where=where, argumentName='referencePosition', received = referencePosition, expectedType = ExpectedType.Vector, dim=3)
-
-        if not IsSquareMatrix(referenceRotationMatrix, 3):
-            RaiseTypeError(where=where, argumentName='referenceRotationMatrix', received = referenceRotationMatrix, expectedType = ExpectedType.Matrix, dim=3)
-    
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-    
-        if type(graphicsDataList) != list:
-            raise ValueError(where+': graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
-
-    groundNumber = mbs.AddObject(eii.ObjectGround(name = name,
-                                    referencePosition=referencePosition,
-                                    referenceRotation=referenceRotationMatrix,
-                                    visualization = eii.VObjectGround(show = show, 
-                                                        graphicsDataUserFunction=graphicsDataUserFunction,
-                                                        graphicsData = graphicsDataList) ))
-    return groundNumber
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create 2D or 3D mass point object and node, using arguments as in NodePoint and MassPoint
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for object, node is 'Node:'+name
-#  referencePosition: reference coordinates for point node (always a 3D vector, no matter if 2D or 3D mass)
-#  initialDisplacement: initial displacements for point node (always a 3D vector, no matter if 2D or 3D mass)
-#  initialVelocity: initial velocities for point node (always a 3D vector, no matter if 2D or 3D mass)
-#  physicsMass: mass of mass point
-#  gravity: gravity vevtor applied (always a 3D vector, no matter if 2D or 3D mass)
-#  graphicsDataList: list of GraphicsData for optional mass visualization
-#  drawSize: general drawing size of node
-#  color: color of node
-#  show: True: if graphicsData list is empty, node is shown, otherwise body is shown; otherwise, nothing is shown
-#  create2D: if True, create NodePoint2D and MassPoint2D
-#  returnDict: if False, returns object index; if True, returns dict of all information on created object and node
-#**output: Union[dict, ObjectIndex]; returns mass point object index or dict with all data on request (if returnDict=True)
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0=mbs.CreateMassPoint(referencePosition = [0,0,0],
-#                        initialVelocity = [2,5,0],
-#                        physicsMass = 1, gravity = [0,-9.81,0],
-#                        drawSize = 0.5, color=color4blue)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateMassPoint(mbs,
-                           name = '',
-                           referencePosition = [0.,0.,0.],
-                           initialDisplacement = [0.,0.,0.],
-                           initialVelocity = [0.,0.,0.],
-                           physicsMass=0,
-                           gravity = [0.,0.,0.],
-                           graphicsDataList = [],
-                           drawSize = -1,
-                           color =  [-1.,-1.,-1.,-1.],
-                           show = True, 
-                           create2D = False, 
-                           returnDict = False): 
-
-    #error checks:        
-    if not exudyn.__useExudynFast:
-        where='MainSystem.CreateMassPoint(...)'
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-        if not IsVector(referencePosition, 3):
-            RaiseTypeError(where=where, argumentName='referencePosition', received = referencePosition, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(initialDisplacement, 3):
-            RaiseTypeError(where=where, argumentName='initialDisplacement', received = initialDisplacement, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(initialVelocity, 3):
-            RaiseTypeError(where=where, argumentName='initialVelocity', received = initialVelocity, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(gravity, 3):
-            RaiseTypeError(where=where, argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidBool(create2D):
-            RaiseTypeError(where=where, argumentName='create2D', received = create2D, expectedType = ExpectedType.Bool)
-        if not IsValidBool(returnDict):
-            RaiseTypeError(where=where, argumentName='returnDict', received = returnDict, expectedType = ExpectedType.Bool)
-    
-        if type(graphicsDataList) != list:
-            raise ValueError(where+': graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
-
-    nodeName = ''
-    if name != '':
-        nodeName = 'Node:'+name
-
-    if not create2D:
-        nodeNumber = mbs.AddNode(eii.NodePoint(name = nodeName,
-                         referenceCoordinates = referencePosition,
-                         initialCoordinates=initialDisplacement,
-                         initialVelocities=initialVelocity,
-                         visualization = eii.VNodePoint(show = show and (graphicsDataList == []), drawSize = drawSize, color = color),
-                         ))
-        bodyNumber = mbs.AddObject(eii.MassPoint(name = name,
-                                                physicsMass=physicsMass,
-                                                nodeNumber = nodeNumber,
-                                                visualization = eii.VMassPoint(show = graphicsDataList != [], 
-                                                                           graphicsData = graphicsDataList) ))
-    else:
-        nodeNumber = mbs.AddNode(eii.NodePoint2D(name = nodeName,
-                         referenceCoordinates = referencePosition[0:2],
-                         initialCoordinates=initialDisplacement[0:2],
-                         initialVelocities=initialVelocity[0:2],
-                         visualization = eii.VNodePoint2D(show = show and (graphicsDataList == []), drawSize = drawSize, color = color),
-                         ))
-        bodyNumber = mbs.AddObject(eii.MassPoint2D(name = name, 
-                                                physicsMass=physicsMass,
-                                                nodeNumber = nodeNumber,
-                                                visualization = eii.VMassPoint(show = graphicsDataList != [], 
-                                                                           graphicsData = graphicsDataList) ))
-        
-    if returnDict:
-        rDict = {'nodeNumber':nodeNumber, 'bodyNumber': bodyNumber}
-    
-    if list(gravity) != [0.,0.,0.]: #        if NormL2(gravity) != 0.:
-        markerNumber = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=bodyNumber))
-        loadNumber = mbs.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
-        if returnDict:
-            rDict['markerBodyMass'] = markerNumber
-            rDict['loadNumber'] = loadNumber
-
-    if returnDict:
-        return rDict
-    else:
-        return bodyNumber
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create 3D (or 2D) rigid body object and node; all quantities are global (angular velocity, etc.)
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for object, node is 'Node:'+name
-#  referencePosition: reference position vector for rigid body node (always a 3D vector, no matter if 2D or 3D body)
-#  referenceRotationMatrix: reference rotation matrix for rigid body node (always 3D matrix, no matter if 2D or 3D body)
-#  initialVelocity: initial translational velocity vector for node (always a 3D vector, no matter if 2D or 3D body)
-#  initialAngularVelocity: initial angular velocity vector for node (always a 3D vector, no matter if 2D or 3D body)
-#  initialDisplacement: initial translational displacement vector for node (always a 3D vector, no matter if 2D or 3D body); these displacements are deviations from reference position, e.g. for a finite element node [None: unused]
-#  initialRotationMatrix: initial rotation provided as matrix (always a 3D matrix, no matter if 2D or 3D body); this rotation is superimposed to reference rotation [None: unused]
-#  inertia: an instance of class RigidBodyInertia, see rigidBodyUtilities; may also be from derived class (InertiaCuboid, InertiaMassPoint, InertiaCylinder, ...)
-#  gravity: gravity vevtor applied (always a 3D vector, no matter if 2D or 3D mass)
-#  graphicsDataList: list of GraphicsData for rigid body visualization; use graphicsDataUtilities function GraphicsData...(...)
-#  graphicsDataUserFunction: a user function graphicsDataUserFunction(mbs, itemNumber)->BodyGraphicsData (list of GraphicsData), which can be used to draw user-defined graphics; this is much slower than regular GraphicsData
-#  drawSize: general drawing size of node
-#  color: color of node
-#  show: True: if graphicsData list is empty, node is shown, otherwise body is shown; False: nothing is shown
-#  create2D: if True, create NodeRigidBody2D and ObjectRigidBody2D
-#  returnDict: if False, returns object index; if True, returns dict of all information on created object and node
-#**output: Union[dict, ObjectIndex]; returns rigid body object index (or dict with 'nodeNumber', 'objectNumber' and possibly 'loadNumber' and 'markerBodyMass' if returnDict=True)
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [1,0,0],
-#                          initialVelocity = [2,5,0],
-#                          initialAngularVelocity = [5,0.5,0.7],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4red)])
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateRigidBody(mbs,
-                           name = '',   
-                           referencePosition = [0.,0.,0.],
-                           referenceRotationMatrix = np.eye(3),
-                           initialVelocity = [0.,0.,0.],
-                           initialAngularVelocity = [0.,0.,0.],
-                           initialDisplacement = None,
-                           initialRotationMatrix = None,
-                           inertia=None,
-                           gravity = [0.,0.,0.],
-                           nodeType=exudyn.NodeType.RotationEulerParameters,
-                           graphicsDataList = [],
-                           graphicsDataUserFunction = 0,
-                           drawSize = -1,
-                           color =  [-1.,-1.,-1.,-1.],
-                           show = True, 
-                           create2D = False, 
-                           returnDict = False): 
-
-    #error checks:        
-    if not exudyn.__useExudynFast:
-        where='MainSystem.CreateRigidBody(...)'
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-        if not IsVector(referencePosition, 3):
-            RaiseTypeError(where=where, argumentName='referencePosition', received = referencePosition, expectedType = ExpectedType.Vector, dim=3)
-        if not IsSquareMatrix(referenceRotationMatrix, 3):
-            RaiseTypeError(where=where, argumentName='referenceRotationMatrix', received = referenceRotationMatrix, expectedType = ExpectedType.Matrix, dim=3)
-
-
-        if not IsVector(initialVelocity, 3):
-            RaiseTypeError(where=where, argumentName='initialVelocity', received = initialVelocity, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(initialAngularVelocity, 3):
-            RaiseTypeError(where=where, argumentName='initialAngularVelocity', received = initialAngularVelocity, expectedType = ExpectedType.Vector, dim=3)
-        if initialDisplacement != None and not IsVector(initialDisplacement, 3):
-            RaiseTypeError(where=where, argumentName='initialDisplacement', received = initialDisplacement, expectedType = ExpectedType.Vector, dim=3)
-        if initialRotationMatrix != None and not IsSquareMatrix(initialRotationMatrix, 3):
-            RaiseTypeError(where=where, argumentName='initialRotationMatrix', received = initialRotationMatrix, expectedType = ExpectedType.Matrix, dim=3)
-
-        if not IsVector(gravity, 3):
-            RaiseTypeError(where=where, argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-        if not IsValidBool(create2D):
-            RaiseTypeError(where=where, argumentName='create2D', received = create2D, expectedType = ExpectedType.Bool)
-        if not IsValidBool(returnDict):
-            RaiseTypeError(where=where, argumentName='returnDict', received = returnDict, expectedType = ExpectedType.Bool)
-    
-        if type(graphicsDataList) != list:
-            raise ValueError(where+': graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
-
-        # if create2D:
-        #     raise ValueError('MainSystem.CreateRigidBody(...): create2D=True currently not supported')
-
-    nodeName = ''
-    if name != '':
-        nodeName = 'Node:'+name
-
-    #++++++++++++++++        
-    if not create2D:
-        RotationMatrix2parameters = None
-        AngularVelocity2parameters_t = None
-        NodeClass = None
-        VNodeClass = None
-        if nodeType == exudyn.NodeType.RotationEulerParameters:
-            RotationMatrix2parameters = RotationMatrix2EulerParameters
-            AngularVelocity2parameters_t = AngularVelocity2EulerParameters_t
-            NodeClass = eii.NodeRigidBodyEP
-            VNodeClass = eii.VNodeRigidBodyEP
-        elif nodeType == exudyn.NodeType.RotationRxyz:
-            RotationMatrix2parameters = RotationMatrix2RotXYZ
-            AngularVelocity2parameters_t = AngularVelocity2RotXYZ_t
-            NodeClass = eii.NodeRigidBodyRxyz
-            VNodeClass = eii.VNodeRigidBodyRxyz
-        elif nodeType == exudyn.NodeType.RotationRotationVector:
-            def AngularVelocity2RotationVector_t(angularVelocity, rotMatrix):
-                return np.dot(rotMatrix.transpose(),angularVelocity)
-                
-            RotationMatrix2parameters = RotationMatrix2RotationVector
-            AngularVelocity2parameters_t = AngularVelocity2RotationVector_t
-            NodeClass = eii.NodeRigidBodyRotVecLG
-            VNodeClass = eii.VNodeRigidBodyRotVecLG
-        else:
-            raise ValueError('MainSystem.CreateRigidBody(...): invalid nodeType!')
-        #++++++++++++++++        
-        referenceRot = RotationMatrix2parameters(referenceRotationMatrix)
-        if nodeType != exudyn.NodeType.RotationRotationVector:
-            rot0_t = AngularVelocity2parameters_t(initialAngularVelocity, referenceRot)
-        else:
-            rot0_t = AngularVelocity2parameters_t(initialAngularVelocity, referenceRotationMatrix)
-    
-        initCoordinates = [0] * (3+len(referenceRot))
-        if initialDisplacement != None or initialRotationMatrix != None:
-            if initialDisplacement == None:
-                initialDisplacement = [0.,0.,0.]
-            if initialRotationMatrix == None:
-                initialRotationMatrix = np.eye(3)
-            
-            rotInit = RotationMatrix2parameters(referenceRotationMatrix*initialRotationMatrix) - referenceRot #relative to reference!
-            initCoordinates  = list(initialDisplacement)+list(rotInit)
-            
-    
-        nodeItem = NodeClass(name = nodeName,
-                             referenceCoordinates=list(referencePosition) + list(referenceRot), 
-                             initialVelocities=list(initialVelocity)+list(rot0_t),
-                             initialCoordinates=initCoordinates,
-                             visualization = VNodeClass(show = show and (graphicsDataList == []), drawSize = drawSize, color = color)
-                             )
-        nodeNumber = mbs.AddNode(nodeItem)
-        bodyNumber = mbs.AddObject(eii.ObjectRigidBody(name=name, physicsMass=inertia.mass, physicsInertia=inertia.GetInertia6D(), 
-                                                       physicsCenterOfMass=inertia.com,
-                                                       nodeNumber=nodeNumber, 
-                                                       visualization=eii.VObjectRigidBody(show = graphicsDataList != [], 
-                                                                                          graphicsDataUserFunction = graphicsDataUserFunction,
-                                                                                          graphicsData=graphicsDataList)))
-    else: #2D
-        A = np.array(referenceRotationMatrix)
-        if not exudyn.__useExudynFast:
-            if abs(referencePosition[2]) > 1e-14:
-                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, referencePosition may not have a Z-component')
-            if (abs(A[2,0]) + abs(A[2,1]) + abs(A[0,2]) + abs(A[1,2]) + abs(A[2,2]-1)) > 1e-13:
-                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, referenceRotationMatrix must only have a rotation around Z-axis')
-            if (abs(initialVelocity[2])) > 1e-14:
-                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialVelocity must not have a Z-component')
-            if (abs(initialAngularVelocity[0]) + abs(initialAngularVelocity[1])) > 1e-14:
-                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialAngularVelocity must only have a Z-component')
-            if np.linalg.norm(inertia.com) > 1e-14:
-                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, the center of mass in inertia must be [0,0,0] (will be fixed in future)')
-
-
-        referenceRot = np.arctan2(A[1,0],A[0,0])
-    
-        initCoordinates = [0.,0.,0.]
-        if initialDisplacement != None or initialRotationMatrix != None:
-            if initialDisplacement != None:
-                if abs(initialDisplacement[2]) > 1e-14:
-                    raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialDisplacement may not have a Z-component')
-                initCoordinates[0] = initialDisplacement[0]
-                initCoordinates[1] = initialDisplacement[1]
-            if initialRotationMatrix != None:
-                A0 = np.array(initialRotationMatrix)
-                if (abs(A0[2,0]) + abs(A0[2,1]) + abs(A0[0,2]) + abs(A0[1,2]) + abs(A0[2,2]-1)) > 1e-13:
-                    raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialRotationMatrix must only have a rotation around Z-axis')
-                phi0 = np.arctan2(A0[1,0],A0[0,0]) - referenceRot
-                initCoordinates[2] = phi0
-            
-        nodeItem = eii.NodeRigidBody2D(name = nodeName,
-                             referenceCoordinates=[referencePosition[0],referencePosition[1],referenceRot], 
-                             initialCoordinates=initCoordinates,
-                             initialVelocities=[initialVelocity[0],initialVelocity[1],initialAngularVelocity[2]],
-                             visualization = eii.VNodeRigidBody2D(show = show and (graphicsDataList == []), drawSize = drawSize, color = color)
-                             )
-        nodeNumber = mbs.AddNode(nodeItem)
-        bodyNumber = mbs.AddObject(eii.ObjectRigidBody2D(name=name, physicsMass=inertia.mass, physicsInertia=inertia.GetInertia6D()[2],
-                                                       #physicsCenterOfMass=inertia.com,
-                                                       nodeNumber=nodeNumber,
-                                                       visualization=eii.VObjectRigidBody(show = graphicsDataList != [],
-                                                                                          graphicsDataUserFunction=graphicsDataUserFunction,
-                                                                                          graphicsData=graphicsDataList)))
-        
-    if returnDict:
-        rDict = {'nodeNumber':nodeNumber, 'bodyNumber': bodyNumber}
-
-    if np.linalg.norm(gravity) != 0.:
-        markerNumber = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=bodyNumber))
-        loadNumber = mbs.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
-
-        if returnDict:
-            rDict['markerBodyMass'] = markerNumber
-            rDict['loadNumber'] = loadNumber
-
-    if returnDict:
-        return rDict
-    else:
-        return bodyNumber
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create SpringDamper connector, using arguments from ObjectConnectorSpringDamper; similar interface as CreateDistanceConstraint(...), see there for for further information
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for connector; markers get Marker0:name and Marker1:name
-#  bodyList: a list of two body numbers (ObjectIndex) to be connected
-#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
-#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
-#  referenceLength: if None, length is computed from reference position of bodies or nodes; if not None, this scalar reference length is used for spring
-#  stiffness: scalar stiffness coefficient
-#  damping: scalar damping coefficient
-#  force: scalar additional force applied
-#  velocityOffset: scalar offset: if referenceLength is changed over time, the velocityOffset may be changed accordingly to emulate a reference motion
-#  springForceUserFunction: a user function springForceUserFunction(mbs, t, itemNumber, deltaL, deltaL\_t, stiffness, damping, force)->float ; this function replaces the internal connector force compuation
-#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
-#  show: if True, connector visualization is drawn
-#  drawSize: general drawing size of connector
-#  color: color of connector
-#**output: ObjectIndex; returns index of newly created object
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateMassPoint(referencePosition = [2,0,0],
-#                          initialVelocity = [2,5,0],
-#                          physicsMass = 1, gravity = [0,-9.81,0],
-#                          drawSize = 0.5, color=color4blue)
-# 
-# oGround = mbs.AddObject(ObjectGround())
-# #add vertical spring
-# oSD = mbs.CreateSpringDamper(bodyList=[oGround, b0],
-#                              localPosition0=[2,1,0],
-#                              localPosition1=[0,0,0],
-#                              stiffness=1e4, damping=1e2,
-#                              drawSize=0.2)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# SC.visualizationSettings.nodes.drawNodesAsPoint=False
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateSpringDamper(mbs,
-                                 name='',
-                                 bodyList=[None, None], 
-                                 localPosition0 = [0.,0.,0.],
-                                 localPosition1 = [0.,0.,0.], 
-                                 referenceLength = None, 
-                                 stiffness = 0., damping = 0., force = 0.,
-                                 velocityOffset = 0., 
-                                 springForceUserFunction = 0,
-                                 bodyOrNodeList=[None, None], 
-                                 show=True, drawSize=-1, color=color4default):
-    #perform some checks:
-    where='MainSystem.CreateSpringDamper(...)'
-    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
-    
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-                
-        if not IsVector(localPosition0, 3):
-            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition1, 3):
-            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
-    
-        if referenceLength != None and not IsValidURealInt(referenceLength):
-            RaiseTypeError(where=where, argumentName='referenceLength', received = referenceLength, expectedType = ExpectedType.PReal)
-        if not IsValidRealInt(stiffness):
-            RaiseTypeError(where=where, argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(damping):
-            RaiseTypeError(where=where, argumentName='damping', received = damping, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(force):
-            RaiseTypeError(where=where, argumentName='force', received = force, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(velocityOffset):
-            RaiseTypeError(where=where, argumentName='velocityOffset', received = velocityOffset, expectedType = ExpectedType.Real)
-    
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-    
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-        
-    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-        mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
-    else:
-        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
-
-    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-        mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
-    else:
-        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
-        
-    if referenceLength == None: #automatically compute reference length
-        
-        if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-            p0 = mbs.GetObjectOutputBody(internBodyNodeList[0],exudyn.OutputVariableType.Position,
-                                         localPosition=localPosition0, configuration=exudyn.ConfigurationType.Reference)
-        else:
-            p0 = mbs.GetNodeOutput(internBodyNodeList[0],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
-            
-        if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-            p1 = mbs.GetObjectOutputBody(internBodyNodeList[1],exudyn.OutputVariableType.Position,
-                                         localPosition=localPosition1, configuration=exudyn.ConfigurationType.Reference)
-        else:
-            p1 = mbs.GetNodeOutput(internBodyNodeList[1],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
-        
-        referenceLength = np.linalg.norm(np.array(p1)-p0)
-    
-    oConnector = mbs.AddObject(eii.ObjectConnectorSpringDamper(name=name,markerNumbers = [mBody0,mBody1],
-                                                                      referenceLength = referenceLength,
-                                                                      stiffness = stiffness,
-                                                                      damping = damping,
-                                                                      force = force, 
-                                                                      velocityOffset = velocityOffset,
-                                                                      springForceUserFunction=springForceUserFunction,
-                                                                      visualization=eii.VSpringDamper(show=show, drawSize=drawSize,
-                                                                                                      color=color)
-                                                                      ))
-
-    return oConnector
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create CartesianSpringDamper connector, using arguments from ObjectConnectorCartesianSpringDamper
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for connector; markers get Marker0:name and Marker1:name
-#  bodyList: a list of two body numbers (ObjectIndex) to be connected
-#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
-#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
-#  stiffness: stiffness coefficients (as 3D list or numpy array)
-#  damping: damping coefficients (as 3D list or numpy array)
-#  offset: offset vector (as 3D list or numpy array)
-#  springForceUserFunction: a user function springForceUserFunction(mbs, t, itemNumber, displacement, velocity, stiffness, damping, offset)->[float,float,float] ; this function replaces the internal connector force compuation
-#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
-#  show: if True, connector visualization is drawn
-#  drawSize: general drawing size of connector
-#  color: color of connector
-#**output: ObjectIndex; returns index of newly created object
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateMassPoint(referencePosition = [7,0,0],
-#                           physicsMass = 1, gravity = [0,-9.81,0],
-#                           drawSize = 0.5, color=color4blue)
-# 
-# oGround = mbs.AddObject(ObjectGround())
-# 
-# oSD = mbs.CreateCartesianSpringDamper(bodyList=[oGround, b0],
-#                               localPosition0=[7.5,1,0],
-#                               localPosition1=[0,0,0],
-#                               stiffness=[200,2000,0], damping=[2,20,0],
-#                               drawSize=0.2)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# SC.visualizationSettings.nodes.drawNodesAsPoint=False
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateCartesianSpringDamper(mbs,
-                                 name='',
-                                 bodyList=[None, None], 
-                                 localPosition0 = [0.,0.,0.],
-                                 localPosition1 = [0.,0.,0.], 
-                                 stiffness = [0.,0.,0.], damping = [0.,0.,0.], 
-                                 offset = [0.,0.,0.],
-                                 springForceUserFunction = 0,
-                                 bodyOrNodeList=[None, None], 
-                                 show=True, drawSize=-1, color=color4default):
-
-    where='MainSystem.CreateCartesianSpringDamper(...)'
-    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
-
-    #perform some checks:
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-    
-        if not IsVector(localPosition0, 3):
-            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition1, 3):
-            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsVector(stiffness, 3):
-            RaiseTypeError(where=where, argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(damping, 3):
-            RaiseTypeError(where=where, argumentName='damping', received = damping, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(offset, 3):
-            RaiseTypeError(where=where, argumentName='offset', received = offset, expectedType = ExpectedType.Vector, dim=3)
-
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-    
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-        
-    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-        mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
-    else:
-        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
-
-    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-        mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
-    else:
-        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
-            
-    oConnector = mbs.AddObject(eii.ObjectConnectorCartesianSpringDamper(name=name,markerNumbers = [mBody0,mBody1],
-                                                                        stiffness = stiffness, damping = damping, offset = offset,
-                                                                        springForceUserFunction=springForceUserFunction,
-                                                                        visualization=eii.VCartesianSpringDamper(show=show, 
-                                                                                      drawSize=drawSize, color=color)
-                                                                      ))
-
-    return oConnector
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create RigidBodySpringDamper connector, using arguments from ObjectConnectorRigidBodySpringDamper, see there for the full documentation
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for connector; markers get Marker0:name and Marker1:name
-#  bodyList: a list of two body numbers (ObjectIndex) to be connected
-#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
-#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
-#  stiffness: stiffness coefficients (as 6D matrix or numpy array)
-#  damping: damping coefficients (as 6D matrix or numpy array)
-#  offset: offset vector (as 6D list or numpy array)
-#  rotationMatrixJoint: additional rotation matrix; in case  useGlobalFrame=False, it transforms body0/node0 local frame to joint frame; if useGlobalFrame=True, it transforms global frame to joint frame
-#  useGlobalFrame: if False, the rotationMatrixJoint is defined in the local coordinate system of body0
-#  intrinsicFormulation: if True, uses intrinsic formulation of Maserati and Morandini, which uses matrix logarithm and is independent of order of markers (preferred formulation); otherwise, Tait-Bryan angles are used for computation of torque, see documentation
-#  springForceTorqueUserFunction: a user function springForceTorqueUserFunction(mbs, t, itemNumber, displacement, rotation, velocity, angularVelocity, stiffness, damping, rotJ0, rotJ1, offset)->[float,float,float, float,float,float] ; this function replaces the internal connector force / torque compuation
-#  postNewtonStepUserFunction: a special user function postNewtonStepUserFunction(mbs, t, Index itemIndex, dataCoordinates, displacement, rotation, velocity, angularVelocity, stiffness, damping, rotJ0, rotJ1, offset)->[PNerror, recommendedStepSize, data[0], data[1], ...] ; for details, see RigidBodySpringDamper for full docu
-#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
-#  show: if True, connector visualization is drawn
-#  drawSize: general drawing size of connector
-#  color: color of connector
-#**output: ObjectIndex; returns index of newly created object
-#**belongsTo: MainSystem
-#**example:
-# #TODO
-def MainSystemCreateRigidBodySpringDamper(mbs,
-                                 name='',
-                                 bodyList=[None, None], 
-                                 localPosition0 = [0.,0.,0.],
-                                 localPosition1 = [0.,0.,0.], 
-                                 stiffness = np.zeros((6,6)), 
-                                 damping = np.zeros((6,6)), 
-                                 offset = [0.,0.,0.,0.,0.,0.],
-                                 rotationMatrixJoint=np.eye(3),
-                                 useGlobalFrame=True,
-                                 intrinsicFormulation=True,
-                                 springForceTorqueUserFunction=0,
-                                 postNewtonStepUserFunction=0,
-                                 bodyOrNodeList=[None, None],
-                                 show=True, drawSize=-1, color=color4default):
-
-    where='MainSystem.CreateRigidBodySpringDamper(...)'
-    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
-
-    #perform some checks:
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-                
-        if not IsVector(localPosition0, 3):
-            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition1, 3):
-            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsSquareMatrix(stiffness, 6):
-            RaiseTypeError(where=where, argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Matrix, dim=6)
-        if not IsSquareMatrix(damping, 6):
-            RaiseTypeError(where=where, argumentName='damping', received = damping, expectedType = ExpectedType.Matrix, dim=6)
-        if not IsVector(offset, 6):
-            RaiseTypeError(where=where, argumentName='offset', received = offset, expectedType = ExpectedType.Vector, dim=3)
-
-
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsValidBool(useGlobalFrame):
-            RaiseTypeError(where=where, argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
-
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-    
-    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-        mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
-        A0 = mbs.GetObjectOutputBody(objectNumber=internBodyNodeList[0],variableType=exudyn.OutputVariableType.RotationMatrix,
-                                     localPosition=localPosition0,
-                                     configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
-    else:
-        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
-        A0 = mbs.GetNodeOutput(nodeNumber=internBodyNodeList[0], variableType=exudyn.OutputVariableType.RotationMatrix,
-                               configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
-
-    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-        mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
-        A1 = mbs.GetObjectOutputBody(objectNumber=internBodyNodeList[1],variableType=exudyn.OutputVariableType.RotationMatrix,
-                                     localPosition=localPosition1,
-                                     configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
-    else:
-        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
-        A1 = mbs.GetNodeOutput(nodeNumber=internBodyNodeList[1], variableType=exudyn.OutputVariableType.RotationMatrix,
-                               configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
-
-    # print('A0=',A0)
-    # print('A1=',A1)
-    if useGlobalFrame:
-        #compute joint marker orientations, rotationMatrixAxes represents global frame:
-        MR0 = A0.T @ rotationMatrixJoint
-        MR1 = A1.T @ rotationMatrixJoint
-    else: #transform into global coordinates, then everything works same
-        #compute joint marker orientations, rotationMatrixAxes represents local frame:
-        MR0 = rotationMatrixJoint
-        MR1 = A1.T @ A0 @ rotationMatrixJoint
-
-            
-    oConnector = mbs.AddObject(eii.ObjectConnectorRigidBodySpringDamper(name=name,markerNumbers = [mBody0,mBody1],
-                                                                        stiffness = stiffness, damping = damping, 
-                                                                        offset = offset,
-                                                                        rotationMarker0=MR0, 
-                                                                        rotationMarker1=MR1,
-                                                                        intrinsicFormulation=intrinsicFormulation,
-                                                                        springForceTorqueUserFunction=springForceTorqueUserFunction, 
-                                                                        postNewtonStepUserFunction=postNewtonStepUserFunction,
-                                                                        visualization=eii.VRigidBodySpringDamper(show=show, 
-                                                                                      drawSize=drawSize, color=color)
-                                                                      ))
-
-    return oConnector
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Create revolute joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
-#**input:
-#  mbs: the MainSystem where joint and markers shall be created
-#  name: name string for joint; markers get Marker0:name and Marker1:name
-#  bodyNumbers: a list of object numbers for body0 and body1; must be rigid body or ground object
-#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
-#  axis: a 3D vector as list or np.array containing the joint axis either in local body0 coordinates (useGlobalFrame=False), or in global reference configuration (useGlobalFrame=True)
-#  useGlobalFrame: if False, the position and axis vectors are defined in the local coordinate system of body0, otherwise in global (reference) coordinates
-#  show: if True, connector visualization is drawn
-#  axisRadius: radius of axis for connector graphical representation
-#  axisLength: length of axis for connector graphical representation
-#  color: color of connector
-#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [3,0,0],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4steelblue)])
-# oGround = mbs.AddObject(ObjectGround())
-# mbs.CreateRevoluteJoint(bodyNumbers=[oGround, b0], position=[2.5,0,0], axis=[0,0,1],
-#                         useGlobalFrame=True, axisRadius=0.02, axisLength=0.14)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateRevoluteJoint(mbs, name='', bodyNumbers=[None, None], 
-                                  position=[], axis=[], useGlobalFrame=True, 
-                                  show=True, axisRadius=0.1, axisLength=0.4, color=color4default):
-    
-    where = 'MainSystem.CreateRevoluteJoint(...)'
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsVector(axis, 3):
-            RaiseTypeError(where=where, argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsValidRealInt(axisRadius):
-            RaiseTypeError(where=where, argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(axisLength):
-            RaiseTypeError(where=where, argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
-        
-    if useGlobalFrame:
-        pJoint = copy.copy(position)
-        vAxis = copy.copy(axis)
-    else: #transform into global coordinates, then everything works same
-        pJoint = A0 @ position + p0
-        vAxis = A0 @ axis
-
-    #compute joint frame (not unique, only rotation axis must coincide)
-    B = ComputeOrthonormalBasis(vAxis) #axis = x-axis
-    #interchange z and x axis (needs sign change, otherwise det(A)=-1)
-    AJ = np.eye(3)
-    AJ[:,0]=-B[:,2]
-    AJ[:,1]= B[:,1]
-    AJ[:,2]= B[:,0] #axis ==> rotation axis z for revolute joint ... 
-    #print(AJ)
-    
-    #compute joint position and axis in bodyNumber0 / 1 coordinates:
-    pJ0 = A0.T @ (np.array(pJoint) - p0)
-    pJ1 = A1.T @ (np.array(pJoint) - p1)
-
-    #compute joint marker orientations:
-    MR0 = A0.T @ AJ  
-    MR1 = A1.T @ AJ  
-    
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-
-    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
-    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
-    
-    oJoint = mbs.AddObject(eii.ObjectJointRevoluteZ(name=name,markerNumbers=[mBody0,mBody1],
-                                                rotationMarker0=MR0,
-                                                rotationMarker1=MR1,
-             visualization=eii.VRevoluteJointZ(show=show, axisRadius=axisRadius, axisLength=axisLength, color=color) ))
-
-    return [oJoint, mBody0, mBody1]
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Create prismatic joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
-#**input:
-#  mbs: the MainSystem where joint and markers shall be created
-#  name: name string for joint; markers get Marker0:name and Marker1:name
-#  bodyNumbers: a list of object numbers for body0 and body1; must be rigid body or ground object
-#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
-#  axis: a 3D vector as list or np.array containing the joint axis either in local body0 coordinates (useGlobalFrame=False), or in global reference configuration (useGlobalFrame=True)
-#  useGlobalFrame: if False, the position and axis vectors are defined in the local coordinate system of body0, otherwise in global (reference) coordinates
-#  show: if True, connector visualization is drawn
-#  axisRadius: radius of axis for connector graphical representation
-#  axisLength: length of axis for connector graphical representation
-#  color: color of connector
-#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [4,0,0],
-#                          initialVelocity = [0,4,0],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4steelblue)])
-# 
-# oGround = mbs.AddObject(ObjectGround())
-# mbs.CreatePrismaticJoint(bodyNumbers=[oGround, b0], position=[3.5,0,0], axis=[0,1,0], 
-#                          useGlobalFrame=True, axisRadius=0.02, axisLength=1)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreatePrismaticJoint(mbs, name='', bodyNumbers=[None, None], 
-                                  position=[], axis=[], useGlobalFrame=True, 
-                                  show=True, axisRadius=0.1, axisLength=0.4, color=color4default):
-        
-    where = 'MainSystem.CreatePrismaticJoint(...)'
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsVector(axis, 3):
-            RaiseTypeError(where=where, argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsValidRealInt(axisRadius):
-            RaiseTypeError(where=where, argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(axisLength):
-            RaiseTypeError(where=where, argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
-
-
-    if useGlobalFrame:
-        pJoint = copy.copy(position)
-        vAxis = copy.copy(axis)
-    else: #transform into global coordinates, then everything works same
-        pJoint = A0 @ position + p0
-        vAxis = A0 @ axis
-
-    #compute joint frame (not unique, only rotation axis must coincide)
-    AJ = ComputeOrthonormalBasis(vAxis) #axis = x-axis
-    
-    #compute joint position and axis in bodyNumber0 / 1 coordinates:
-    pJ0 = A0.T @ (np.array(pJoint) - p0)
-    pJ1 = A1.T @ (np.array(pJoint) - p1)
-
-    #compute joint marker orientations:
-    MR0 = A0.T @ AJ  
-    MR1 = A1.T @ AJ  
-    
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-
-    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
-    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
-    
-    oJoint = mbs.AddObject(eii.ObjectJointPrismaticX(name=name,markerNumbers=[mBody0,mBody1],
-                                                rotationMarker0=MR0,
-                                                rotationMarker1=MR1,
-             visualization=eii.VPrismaticJointX(show=show, axisRadius=axisRadius, axisLength=axisLength, color=color) ))
-
-    return [oJoint, mBody0, mBody1]
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Create spherical joint between two bodies; definition of joint position in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers are automatically computed
-#**input:
-#  mbs: the MainSystem where joint and markers shall be created
-#  name: name string for joint; markers get Marker0:name and Marker1:name
-#  bodyNumbers: a list of object numbers for body0 and body1; must be mass point, rigid body or ground object
-#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
-#  constrainedAxes: flags, which determines which (global) translation axes are constrained; each entry may only be 0 (=free) axis or 1 (=constrained axis)
-#  useGlobalFrame: if False, the point and axis vectors are defined in the local coordinate system of body0
-#  show: if True, connector visualization is drawn
-#  jointRadius: radius of sphere for connector graphical representation
-#  color: color of connector
-#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [5,0,0],
-#                          initialAngularVelocity = [5,0,0],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4orange)])
-# oGround = mbs.AddObject(ObjectGround())
-# mbs.CreateSphericalJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0], 
-#                          useGlobalFrame=True, jointRadius=0.06)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateSphericalJoint(mbs, name='', bodyNumbers=[None, None], 
-                                  position=[], constrainedAxes=[1,1,1], useGlobalFrame=True, 
-                                  show=True, jointRadius=0.1, color=color4default):
-        
-    where = 'MainSystem.CreateSphericalJoint(...)'
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsIntVector(constrainedAxes, 3):
-            RaiseTypeError(where=where, argumentName='constrainedAxes', received = constrainedAxes, expectedType = ExpectedType.IntVector, dim=3)
-        if not IsValidRealInt(jointRadius):
-            RaiseTypeError(where=where, argumentName='jointRadius', received = jointRadius, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
-
-    if useGlobalFrame:
-        pJoint = copy.copy(position)
-    else: #transform into global coordinates, then everything works same
-        pJoint = A0 @ position + p0
-
-    
-    #compute joint position and axis in bodyNumber0 / 1 coordinates:
-    pJ0 = A0.T @ (np.array(pJoint) - p0)
-    pJ1 = A1.T @ (np.array(pJoint) - p1)
-
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-
-    mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
-    mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
-    
-    oJoint = mbs.AddObject(eii.ObjectJointSpherical(name=name,markerNumbers=[mBody0,mBody1], 
-                                                    constrainedAxes=constrainedAxes,
-             visualization=eii.VObjectJointSpherical(show=show, jointRadius=jointRadius, color=color) ))
-
-    return [oJoint, mBody0, mBody1]
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Create generic joint between two bodies; definition of joint position (position) and axes (rotationMatrixAxes) in global coordinates (useGlobalFrame=True) or in local coordinates of body0 (useGlobalFrame=False), where rotationMatrixAxes is an additional rotation to body0; all markers, markerRotation and other quantities are automatically computed
-#**input:
-#  mbs: the MainSystem where joint and markers shall be created
-#  name: name string for joint; markers get Marker0:name and Marker1:name
-#  bodyNumber0: a object number for body0, must be rigid body or ground object
-#  bodyNumber1: a object number for body1, must be rigid body or ground object
-#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
-#  rotationMatrixAxes: rotation matrix which defines orientation of constrainedAxes; if useGlobalFrame, this rotation matrix is global, else the rotation matrix is post-multiplied with the rotation of body0, identical with rotationMarker0 in the joint
-#  constrainedAxes: flag, which determines which translation (0,1,2) and rotation (3,4,5) axes are constrained; each entry may only be 0 (=free) axis or 1 (=constrained axis); ALL constrained Axes are defined relative to reference rotation of body0 times rotation0
-#  useGlobalFrame: if False, the position is defined in the local coordinate system of body0, otherwise it is defined in global coordinates
-#  offsetUserFunction: a user function offsetUserFunction(mbs, t, itemNumber, offsetUserFunctionParameters)->float ; this function replaces the internal (constant) by a user-defined offset. This allows to realize rheonomic joints and allows kinematic simulation
-#  offsetUserFunction_t: a user function offsetUserFunction\_t(mbs, t, itemNumber, offsetUserFunctionParameters)->float ; this function replaces the internal (constant) by a user-defined offset velocity; this function is used instead of offsetUserFunction, if velocityLevel (index2) time integration
-#  show: if True, connector visualization is drawn
-#  axesRadius: radius of axes for connector graphical representation
-#  axesLength: length of axes for connector graphical representation
-#  color: color of connector
-#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [6,0,0],
-#                          initialAngularVelocity = [0,8,0],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4orange)])
-# oGround = mbs.AddObject(ObjectGround())
-# mbs.CreateGenericJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
-#                        constrainedAxes=[1,1,1, 1,0,0],
-#                        rotationMatrixAxes=RotationMatrixX(0.125*pi), #tilt axes
-#                        useGlobalFrame=True, axesRadius=0.02, axesLength=0.2)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateGenericJoint(mbs, name='', bodyNumbers=[None, None], 
-                                 position=[], 
-                                 rotationMatrixAxes=np.eye(3), 
-                                 constrainedAxes=[1,1,1, 1,1,1], 
-                                 useGlobalFrame=True,
-                                 offsetUserFunction=0, offsetUserFunction_t=0,
-                                 show=True, axesRadius=0.1, axesLength=0.4, color=color4default):
-        
-    where = 'MainSystem.CreateGenericJoint(...)'
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsIntVector(constrainedAxes, 6):
-            RaiseTypeError(where=where, argumentName='constrainedAxes', received = constrainedAxes, expectedType = ExpectedType.IntVector, dim=6)
-    
-        if not IsValidRealInt(axesRadius):
-            RaiseTypeError(where=where, argumentName='axesRadius', received = axesRadius, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(axesLength):
-            RaiseTypeError(where=where, argumentName='axesLength', received = axesLength, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
-
-
-    if useGlobalFrame:
-        pJoint = copy.copy(position)
-        #compute joint marker orientations, rotationMatrixAxes represents global frame:
-        MR0 = A0.T @ rotationMatrixAxes
-        MR1 = A1.T @ rotationMatrixAxes
-    else: #transform into global coordinates, then everything works same
-        pJoint = A0 @ position + p0
-        #compute joint marker orientations, rotationMatrixAxes represents local frame:
-        MR0 = copy.copy(rotationMatrixAxes)
-        MR1 = A1.T @ A0 @ rotationMatrixAxes
-
-    
-    #compute joint position and axis in bodyNumber0 / 1 coordinates:
-    pJ0 = A0.T @ (np.array(pJoint) - p0)
-    pJ1 = A1.T @ (np.array(pJoint) - p1)
-
-    
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-
-    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
-    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
-    
-    oJoint = mbs.AddObject(eii.ObjectJointGeneric(name=name,markerNumbers=[mBody0,mBody1],
-                                                  constrainedAxes = constrainedAxes,
-                                                  rotationMarker0=MR0,
-                                                  rotationMarker1=MR1, 
-                                                  offsetUserFunction=offsetUserFunction,
-                                                  offsetUserFunction_t=offsetUserFunction_t,
-             visualization=eii.VObjectJointGeneric(show=show, axesRadius=axesRadius, axesLength=axesLength, color=color) ))
-
-    return [oJoint, mBody0, mBody1]
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Create distance joint between two bodies; definition of joint positions in local coordinates of bodies or nodes; if distance=None, it is computed automatically from reference length; all markers are automatically computed
-#**input:
-#  mbs: the MainSystem where joint and markers shall be created
-#  name: name string for joint; markers get Marker0:name and Marker1:name
-#  bodyList: a list of two body numbers (ObjectIndex) to be constrained
-#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
-#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
-#  distance: if None, distance is computed from reference position of bodies or nodes; if not None, this distance is prescribed between the two positions; if distance = 0, it will create a SphericalJoint as this case is not possible with a DistanceConstraint
-#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
-#  show: if True, connector visualization is drawn
-#  drawSize: general drawing size of node
-#  color: color of connector
-#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                   sideLengths=[1,0.1,0.1]),
-#                           referencePosition = [6,0,0],
-#                           gravity = [0,-9.81,0],
-#                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4orange)])
-# m1 = mbs.CreateMassPoint(referencePosition=[5.5,-1,0],
-#                          physicsMass=1, drawSize = 0.2)
-# n1 = mbs.GetObject(m1)['nodeNumber']
-#     
-# oGround = mbs.AddObject(ObjectGround())
-# mbs.CreateDistanceConstraint(bodyList=[oGround, b0], 
-#                              localPosition0 = [6.5,1,0],
-#                              localPosition1 = [0.5,0,0],
-#                              distance=None, #automatically computed
-#                              drawSize=0.06)
-# 
-# mbs.CreateDistanceConstraint(bodyOrNodeList=[b0, n1], 
-#                              localPosition0 = [-0.5,0,0],
-#                              localPosition1 = [0.,0.,0.], #must be [0,0,0] for Node
-#                              distance=None, #automatically computed
-#                              drawSize=0.06)
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# 
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateDistanceConstraint(mbs, name='', 
-                                       bodyList=[None, None], 
-                                       localPosition0 = [0.,0.,0.],
-                                       localPosition1 = [0.,0.,0.], 
-                                       distance=None, 
-                                       bodyOrNodeList=[None, None],
-                                       show=True, drawSize=-1., color=color4default):
-    
-    where = 'MainSystem.CreateDistanceConstraint(...)'
-    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
-        
-    if not exudyn.__useExudynFast:
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-            
-        if not IsVector(localPosition0, 3):
-            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition1, 3):
-            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
-    
-        if distance != None and not IsValidURealInt(distance):
-            RaiseTypeError(where=where, argumentName='distance', received = distance, expectedType = ExpectedType.PReal)
-
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-        if not IsVector(color, 4):
-            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-
-
-    mName0 = ''
-    mName1 = ''
-    if name != '':
-        mName0 = 'Marker0:'+name
-        mName1 = 'Marker1:'+name
-        
-    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-        mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
-    else:
-        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
-
-    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-        mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
-    else:
-        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
-        
-    if distance == None: #automatically compute distance
-        
-        if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-            p0 = mbs.GetObjectOutputBody(internBodyNodeList[0],exudyn.OutputVariableType.Position,
-                                         localPosition=localPosition0, configuration=exudyn.ConfigurationType.Reference)
-        else:
-            p0 = mbs.GetNodeOutput(internBodyNodeList[0],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
-            
-        if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-            p1 = mbs.GetObjectOutputBody(internBodyNodeList[1],exudyn.OutputVariableType.Position,
-                                         localPosition=localPosition1, configuration=exudyn.ConfigurationType.Reference)
-        else:
-            p1 = mbs.GetNodeOutput(internBodyNodeList[1],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
-        
-        distance = np.linalg.norm(np.array(p1)-p0)
-    
-    if distance != 0:
-        oJoint = mbs.AddObject(eii.ObjectConnectorDistance(name=name,markerNumbers=[mBody0,mBody1], distance=distance,
-                 visualization=eii.VObjectConnectorDistance(show=show, drawSize=drawSize, color=color) ))
-    else:
-        #VERY SPECIAL case, which should help to resolve problems if distance=0 is used ... 
-        exu.Print('WARNING: CreateDistanceConstraint called with distance=0; creating SphericalJoint instead')
-        constrainedAxes = [1,1,1]
-        if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
-            if '2D' in mbs.GetObject(internBodyNodeList[0])['objectType']:
-                constrainedAxes[2] = 0
-        if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
-            if '2D' in mbs.GetObject(internBodyNodeList[1])['objectType']:
-                constrainedAxes[2] = 0
-        oJoint = mbs.AddObject(eii.SphericalJoint(name=name,markerNumbers=[mBody0,mBody1], 
-                                                  constrainedAxes=constrainedAxes,
-                                                  visualization=eii.VSphericalJoint(show=show, jointRadius=0.5*drawSize, color=color) ))
-        
-
-    return [oJoint, mBody0, mBody1]
-
-
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create force applied to given body
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for object
-#  bodyNumber: body number (ObjectIndex) at which the force is applied to
-#  loadVector: force vector (as 3D list or numpy array)
-#  localPosition: local position (as 3D list or numpy array) where force is applied
-#  bodyFixed: if True, the force is corotated with the body; else, the force is global
-#  loadVectorUserFunction: A Python function f(mbs, t, load)->loadVector which defines the time-dependent load and replaces loadVector in every time step; the arg load is the static loadVector
-#  show: if True, load is drawn
-#**output: LoadIndex; returns load index
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0=mbs.CreateMassPoint(referencePosition = [0,0,0],
-#                        initialVelocity = [2,5,0],
-#                        physicsMass = 1, gravity = [0,-9.81,0],
-#                        drawSize = 0.5, color=color4blue)
-#
-# f0=mbs.CreateForce(bodyNumber=b0, loadVector=[100,0,0],
-#                    localPosition=[0,0,0])
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateForce(mbs,
-                name = '',   
-                bodyNumber = None,
-                loadVector = [0.,0.,0.], 
-                localPosition = [0.,0.,0.], 
-                bodyFixed = False,
-                loadVectorUserFunction = 0,
-                show = True):
-
-    #error checks:        
-    if not exudyn.__useExudynFast:
-        where='MainSystem.CreateForce(...)'
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsValidObjectIndex(bodyNumber):
-            RaiseTypeError(where=where, argumentName='bodyNumber', received = bodyNumber, expectedType = ExpectedType.ObjectIndex)
-        if not IsVector(loadVector, 3):
-            RaiseTypeError(where=where, argumentName='loadVector', received = loadVector, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition, 3):
-            RaiseTypeError(where=where, argumentName='localPosition', received = localPosition, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsValidRealInt(bodyFixed):
-            RaiseTypeError(where=where, argumentName='bodyFixed', received = bodyFixed, expectedType = ExpectedType.Bool)
-        
-        # if not IsUserFunction(loadVectorUserFunction):
-        #     RaiseTypeError(where=where, argumentName='loadVectorUserFunction', received = loadVectorUserFunction, expectedType = ExpectedType.UserFunction)
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-    
-
-    if bodyFixed:
-        markerNumber = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=bodyNumber, localPosition=localPosition))
-    else:
-        markerNumber = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber=bodyNumber, localPosition=localPosition))
-        
-    loadNumber = mbs.AddLoad(eii.LoadForceVector(markerNumber=markerNumber, 
-                                                 loadVector=loadVector,
-                                                 bodyFixed=bodyFixed, 
-                                                 loadVectorUserFunction=loadVectorUserFunction))
-
-    return loadNumber
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function to create torque applied to given body
-#**input: 
-#  mbs: the MainSystem where items are created
-#  name: name string for object
-#  bodyNumber: body number (ObjectIndex) at which the torque is applied to
-#  loadVector: torque vector (as 3D list or numpy array)
-#  localPosition: local position (as 3D list or numpy array) where torque is applied
-#  bodyFixed: if True, the torque is corotated with the body; else, the torque is global
-#  loadVectorUserFunction: A Python function f(mbs, t, load)->loadVector which defines the time-dependent load and replaces loadVector in every time step; the arg load is the static loadVector
-#  show: if True, load is drawn
-#**output: LoadIndex; returns load index
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# 
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [1,3,0],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4red)])
-#
-# f0=mbs.CreateTorque(bodyNumber=b0, loadVector=[0,100,0])
-# 
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
-# simulationSettings.timeIntegration.numberOfSteps = 1000
-# simulationSettings.timeIntegration.endTime = 2
-# mbs.SolveDynamic(simulationSettings = simulationSettings)
-def MainSystemCreateTorque(mbs,
-                name = '',   
-                bodyNumber = None,
-                loadVector = [0.,0.,0.], 
-                localPosition = [0.,0.,0.], 
-                bodyFixed = False,
-                loadVectorUserFunction = 0,
-                show = True):
-
-    #error checks:        
-    if not exudyn.__useExudynFast:
-        where='MainSystem.CreateTorque(...)'
-        if not isinstance(name, str):
-            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
-
-        if not IsValidObjectIndex(bodyNumber):
-            RaiseTypeError(where=where, argumentName='bodyNumber', received = bodyNumber, expectedType = ExpectedType.ObjectIndex)
-        if not IsVector(loadVector, 3):
-            RaiseTypeError(where=where, argumentName='loadVector', received = loadVector, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition, 3):
-            RaiseTypeError(where=where, argumentName='localPosition', received = localPosition, expectedType = ExpectedType.Vector, dim=3)
-    
-        if not IsValidRealInt(bodyFixed):
-            RaiseTypeError(where=where, argumentName='bodyFixed', received = bodyFixed, expectedType = ExpectedType.Bool)
-        # if not IsUserFunction(loadVectorUserFunction):
-        #     RaiseTypeError(where=where, argumentName='loadVectorUserFunction', received = loadVectorUserFunction, expectedType = ExpectedType.UserFunction)
-        if not IsValidBool(show):
-            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
-    
-    
-    markerNumber = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=bodyNumber, localPosition=localPosition))
-    loadNumber = mbs.AddLoad(eii.LoadTorqueVector(markerNumber=markerNumber, 
-                                                  loadVector=loadVector,
-                                                  bodyFixed=bodyFixed,
-                                                  loadVectorUserFunction=loadVectorUserFunction))
-
-    return loadNumber
-
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-# exudyn.MainSystem.CreateMassPoint = MainSystemCreateMassPoint
-# exudyn.MainSystem.CreateSpringDamper = MainSystemCreateSpringDamper
-# exudyn.MainSystem.CreateRevoluteJoint = MainSystemCreateRevoluteJoint
-# exudyn.MainSystem.CreatePrismaticJoint = MainSystemCreatePrismaticJoint
-# exudyn.MainSystem.CreateGenericJoint = MainSystemCreateGenericJoint
-
-#missing:
-#RigidBodySpringDamper
-#LinearSpringDamper
-#TorsionalSpringDamper
-#2x rolling disc
-#CreateBeamsStraight[2D](...) #ANCF, GE with types?
-#CreateBeamsCurved[2D](...)   #ANCF, GE
-
-
-# #FUTURE:
-# #def InitializeFromRestartFile(mbs, simulationSettings, restartFileName, verbose=True):
-
-    
-# #needs some extensions; really needed?
-# # def AnimateModes(self, *args, **kwargs):
-# #     SC = self.GetSystemContainer()
-# #     return exudyn.interactive.AnimateModes(SC, self, *args, **kwargs)
-# #makes no sense, as it is a class:
-# # def InteractiveDialog(self, *args, **kwargs):
-# #     return exudyn.interactive.InteractiveDialog(self, *args, **kwargs)
- 
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO 
-#NOTE that the following text is autogenerated, do not modify!
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.SolutionViewer=exu.interactive.SolutionViewer
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateGround=MainSystemCreateGround
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateMassPoint=MainSystemCreateMassPoint
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateRigidBody=MainSystemCreateRigidBody
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateSpringDamper=MainSystemCreateSpringDamper
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateCartesianSpringDamper=MainSystemCreateCartesianSpringDamper
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateRigidBodySpringDamper=MainSystemCreateRigidBodySpringDamper
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateRevoluteJoint=MainSystemCreateRevoluteJoint
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreatePrismaticJoint=MainSystemCreatePrismaticJoint
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateSphericalJoint=MainSystemCreateSphericalJoint
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateGenericJoint=MainSystemCreateGenericJoint
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateDistanceConstraint=MainSystemCreateDistanceConstraint
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateForce=MainSystemCreateForce
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateTorque=MainSystemCreateTorque
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.PlotSensor=exu.plot.PlotSensor
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.SolveStatic=exu.solver.SolveStatic
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.SolveDynamic=exu.solver.SolveDynamic
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.ComputeLinearizedSystem=exu.solver.ComputeLinearizedSystem
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.ComputeODE2Eigenvalues=exu.solver.ComputeODE2Eigenvalues
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.ComputeSystemDegreeOfFreedom=exu.solver.ComputeSystemDegreeOfFreedom
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateDistanceSensorGeometry=exu.utilities.CreateDistanceSensorGeometry
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.CreateDistanceSensor=exu.utilities.CreateDistanceSensor
-
-
-#link MainSystem function to Python function:
-exu.MainSystem.DrawSystemGraph=exu.utilities.DrawSystemGraph
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  This module provides an extension interface to the C++ class MainSystem;
+#           MainSystem is extended by Python interface functions to easily create
+#           bodies and point masses without the need to create an according node and
+#           connectors and joints without the need to create markers.
+#           For activation of Python extension in the mainSystem, 
+#           just write: \\ \texttt{import exudyn.mainSystemExtensions} or 
+#           import \texttt{exudyn.utilities}
+#
+# Author:   Johannes Gerstmayr
+# Date:     2023-05-07 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#import exudyn #does not work out of exudyn.__init__.py
+import exudyn as exu
+import exudyn.plot
+import exudyn.solver
+import exudyn.interactive
+#import exudyn.robotics
+import exudyn.utilities
+
+from exudyn.rigidBodyUtilities import GetRigidBodyNode, ComputeOrthonormalBasis, \
+    RotationMatrix2EulerParameters, AngularVelocity2EulerParameters_t, RotationMatrix2RotXYZ, AngularVelocity2RotXYZ_t, \
+    RotationMatrix2RotationVector
+
+import exudyn.itemInterface as eii 
+from exudyn.advancedUtilities import RaiseTypeError, IsVector, ExpectedType, IsValidObjectIndex, IsValidNodeIndex, \
+                                    IsValidRealInt, IsValidPRealInt, IsValidURealInt, IsIntVector, \
+                                    IsValidBool, IsSquareMatrix, IsNone, IsNotNone
+
+from exudyn.graphicsDataUtilities import color4default, color4red
+import numpy as np
+import copy
+
+#exudyn.Print('WARNING: mainSystemInterface is available only for testing; it may fail on certain architectures; use with care')
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#add helpful Python extensions for MainSystem, regarding creation of bodies, point masses, connectors and joints
+
+#internal function: do some pre-checks and calculations for joint
+def JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame):
+    #perform some checks:
+    if not exudyn.__useExudynFast:
+        if not isinstance(bodyNumbers, list) or len(bodyNumbers) != 2:
+            RaiseTypeError(where=where, argumentName='bodyNumbers', received = bodyNumbers, expectedType = 'list of 2 body numbers')
+        if not IsValidObjectIndex(bodyNumbers[0]):
+            RaiseTypeError(where=where, argumentName='bodyNumbers[0]', received = bodyNumbers[0], expectedType = ExpectedType.ObjectIndex)
+        if not IsValidObjectIndex(bodyNumbers[1]):
+            RaiseTypeError(where=where, argumentName='bodyNumbers[1]', received = bodyNumbers[1], expectedType = ExpectedType.ObjectIndex)
+    
+        if not IsVector(position, 3):
+            RaiseTypeError(where=where, argumentName='position', received = position, expectedType = ExpectedType.Vector, dim=3)
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidBool(useGlobalFrame):
+            RaiseTypeError(where=where, argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+    p0 = mbs.GetObjectOutputBody(bodyNumbers[0],exudyn.OutputVariableType.Position,
+                                 localPosition=[0,0,0],
+                                 configuration=exudyn.ConfigurationType.Reference)
+    A0 = mbs.GetObjectOutputBody(bodyNumbers[0],exudyn.OutputVariableType.RotationMatrix,
+                                 localPosition=[0,0,0],
+                                 configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
+    p1 = mbs.GetObjectOutputBody(bodyNumbers[1],exudyn.OutputVariableType.Position,
+                                 localPosition=[0,0,0],
+                                 configuration=exudyn.ConfigurationType.Reference)
+    A1 = mbs.GetObjectOutputBody(bodyNumbers[1],exudyn.OutputVariableType.RotationMatrix,
+                                 localPosition=[0,0,0],
+                                 configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
+
+    return [p0, A0, p1, A1] 
+
+#internal function, which checks bodyList and bodyOrNodeList and returns appropriate bodyOrNodeList
+def ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where):
+    if not exudyn.__useExudynFast:
+        if not isinstance(bodyList, list) or len(bodyList) != 2:
+            RaiseTypeError(where=where, argumentName='bodyList', received = bodyList, expectedType = 'list of 2 body or node numbers')
+
+    causingArgName = 'bodyOrNodeList'
+    if IsNotNone(bodyList[0]) or IsNotNone(bodyList[1]):
+        bodyOrNodeList = [bodyList[0],bodyList[1]] #flat copy, but otherwise would lead to change of args (mutable args!)
+        causingArgName = 'bodyList'
+        
+    if not exudyn.__useExudynFast:
+        if not isinstance(bodyOrNodeList, list) or len(bodyOrNodeList) != 2:
+            RaiseTypeError(where=where, argumentName='bodyOrNodeList', received = bodyOrNodeList, expectedType = 'list of 2 body or node numbers')
+    
+        if not (isinstance(bodyOrNodeList[0], exudyn.ObjectIndex) or (isinstance(bodyOrNodeList[0], exudyn.NodeIndex) and localPosition0==[0.,0.,0.])):
+            RaiseTypeError(where=where, argumentName=''+causingArgName+'[0]', received = bodyOrNodeList[0], 
+                           expectedType = 'expected either ObjectIndex or NodeIndex and localPosition0=[0.,0.,0.]')
+            
+        if not (isinstance(bodyOrNodeList[1], exudyn.ObjectIndex) or (isinstance(bodyOrNodeList[1], exudyn.NodeIndex) and localPosition1==[0.,0.,0.])):
+            RaiseTypeError(where=where, argumentName=''+causingArgName+'[1]', received = bodyOrNodeList[1], 
+                           expectedType = 'expected either ObjectIndex or NodeIndex and localPosition1=[0.,0.,0.]')
+    
+    return bodyOrNodeList
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create a ground object, using arguments of ObjectGround; this function is mainly added for consistency with other mainSystemExtensions
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for object
+#  referencePosition: reference coordinates for point node (always a 3D vector, no matter if 2D or 3D mass)
+#  referenceRotationMatrix: reference rotation matrix for rigid body node (always 3D matrix, no matter if 2D or 3D body)
+#  graphicsDataList: list of GraphicsData for optional ground visualization
+#  graphicsDataUserFunction: a user function graphicsDataUserFunction(mbs, itemNumber)->BodyGraphicsData (list of GraphicsData), which can be used to draw user-defined graphics; this is much slower than regular GraphicsData
+#  color: color of node
+#  show: True: show ground object; 
+#**output: ObjectIndex; returns ground object index 
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# ground=mbs.CreateGround(referencePosition = [2,0,0],
+#                         graphicsDataList = [GraphicsDataCheckerBoard(point=[0,0,0], normal=[0,1,0],size=4)])
+# 
+def MainSystemCreateGround(mbs,
+                           name = '',   
+                           referencePosition = [0.,0.,0.],
+                           referenceRotationMatrix = np.eye(3),
+                           graphicsDataList = [],
+                           graphicsDataUserFunction = 0,
+                           show = True): 
+
+    #error checks:        
+    if not exudyn.__useExudynFast:
+        where='MainSystem.CreateGround(...)'
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+        if not IsVector(referencePosition, 3):
+            RaiseTypeError(where=where, argumentName='referencePosition', received = referencePosition, expectedType = ExpectedType.Vector, dim=3)
+
+        if not IsSquareMatrix(referenceRotationMatrix, 3):
+            RaiseTypeError(where=where, argumentName='referenceRotationMatrix', received = referenceRotationMatrix, expectedType = ExpectedType.Matrix, dim=3)
+    
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+    
+        if type(graphicsDataList) != list:
+            raise ValueError(where+': graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
+
+    groundNumber = mbs.AddObject(eii.ObjectGround(name = name,
+                                    referencePosition=referencePosition,
+                                    referenceRotation=referenceRotationMatrix,
+                                    visualization = eii.VObjectGround(show = show, 
+                                                        graphicsDataUserFunction=graphicsDataUserFunction,
+                                                        graphicsData = graphicsDataList) ))
+    return groundNumber
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create 2D or 3D mass point object and node, using arguments as in NodePoint and MassPoint
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for object, node is 'Node:'+name
+#  referencePosition: reference coordinates for point node (always a 3D vector, no matter if 2D or 3D mass)
+#  initialDisplacement: initial displacements for point node (always a 3D vector, no matter if 2D or 3D mass)
+#  initialVelocity: initial velocities for point node (always a 3D vector, no matter if 2D or 3D mass)
+#  physicsMass: mass of mass point
+#  gravity: gravity vevtor applied (always a 3D vector, no matter if 2D or 3D mass)
+#  graphicsDataList: list of GraphicsData for optional mass visualization
+#  drawSize: general drawing size of node
+#  color: color of node
+#  show: True: if graphicsData list is empty, node is shown, otherwise body is shown; otherwise, nothing is shown
+#  create2D: if True, create NodePoint2D and MassPoint2D
+#  returnDict: if False, returns object index; if True, returns dict of all information on created object and node
+#**output: Union[dict, ObjectIndex]; returns mass point object index or dict with all data on request (if returnDict=True)
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0=mbs.CreateMassPoint(referencePosition = [0,0,0],
+#                        initialVelocity = [2,5,0],
+#                        physicsMass = 1, gravity = [0,-9.81,0],
+#                        drawSize = 0.5, color=color4blue)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateMassPoint(mbs,
+                           name = '',
+                           referencePosition = [0.,0.,0.],
+                           initialDisplacement = [0.,0.,0.],
+                           initialVelocity = [0.,0.,0.],
+                           physicsMass=0,
+                           gravity = [0.,0.,0.],
+                           graphicsDataList = [],
+                           drawSize = -1,
+                           color =  [-1.,-1.,-1.,-1.],
+                           show = True, 
+                           create2D = False, 
+                           returnDict = False): 
+
+    #error checks:        
+    if not exudyn.__useExudynFast:
+        where='MainSystem.CreateMassPoint(...)'
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+        if not IsVector(referencePosition, 3):
+            RaiseTypeError(where=where, argumentName='referencePosition', received = referencePosition, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(initialDisplacement, 3):
+            RaiseTypeError(where=where, argumentName='initialDisplacement', received = initialDisplacement, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(initialVelocity, 3):
+            RaiseTypeError(where=where, argumentName='initialVelocity', received = initialVelocity, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(gravity, 3):
+            RaiseTypeError(where=where, argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidBool(create2D):
+            RaiseTypeError(where=where, argumentName='create2D', received = create2D, expectedType = ExpectedType.Bool)
+        if not IsValidBool(returnDict):
+            RaiseTypeError(where=where, argumentName='returnDict', received = returnDict, expectedType = ExpectedType.Bool)
+    
+        if type(graphicsDataList) != list:
+            raise ValueError(where+': graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
+
+    nodeName = ''
+    if name != '':
+        nodeName = 'Node:'+name
+
+    if not create2D:
+        nodeNumber = mbs.AddNode(eii.NodePoint(name = nodeName,
+                         referenceCoordinates = referencePosition,
+                         initialCoordinates=initialDisplacement,
+                         initialVelocities=initialVelocity,
+                         visualization = eii.VNodePoint(show = show and (graphicsDataList == []), drawSize = drawSize, color = color),
+                         ))
+        bodyNumber = mbs.AddObject(eii.MassPoint(name = name,
+                                                physicsMass=physicsMass,
+                                                nodeNumber = nodeNumber,
+                                                visualization = eii.VMassPoint(show = graphicsDataList != [], 
+                                                                           graphicsData = graphicsDataList) ))
+    else:
+        nodeNumber = mbs.AddNode(eii.NodePoint2D(name = nodeName,
+                         referenceCoordinates = referencePosition[0:2],
+                         initialCoordinates=initialDisplacement[0:2],
+                         initialVelocities=initialVelocity[0:2],
+                         visualization = eii.VNodePoint2D(show = show and (graphicsDataList == []), drawSize = drawSize, color = color),
+                         ))
+        bodyNumber = mbs.AddObject(eii.MassPoint2D(name = name, 
+                                                physicsMass=physicsMass,
+                                                nodeNumber = nodeNumber,
+                                                visualization = eii.VMassPoint(show = graphicsDataList != [], 
+                                                                           graphicsData = graphicsDataList) ))
+        
+    if returnDict:
+        rDict = {'nodeNumber':nodeNumber, 'bodyNumber': bodyNumber}
+    
+    if list(gravity) != [0.,0.,0.]: #        if NormL2(gravity) != 0.:
+        markerNumber = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=bodyNumber))
+        loadNumber = mbs.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
+        if returnDict:
+            rDict['markerBodyMass'] = markerNumber
+            rDict['loadNumber'] = loadNumber
+
+    if returnDict:
+        return rDict
+    else:
+        return bodyNumber
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create 3D (or 2D) rigid body object and node; all quantities are global (angular velocity, etc.)
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for object, node is 'Node:'+name
+#  referencePosition: reference position vector for rigid body node (always a 3D vector, no matter if 2D or 3D body)
+#  referenceRotationMatrix: reference rotation matrix for rigid body node (always 3D matrix, no matter if 2D or 3D body)
+#  initialVelocity: initial translational velocity vector for node (always a 3D vector, no matter if 2D or 3D body)
+#  initialAngularVelocity: initial angular velocity vector for node (always a 3D vector, no matter if 2D or 3D body)
+#  initialDisplacement: initial translational displacement vector for node (always a 3D vector, no matter if 2D or 3D body); these displacements are deviations from reference position, e.g. for a finite element node [None: unused]
+#  initialRotationMatrix: initial rotation provided as matrix (always a 3D matrix, no matter if 2D or 3D body); this rotation is superimposed to reference rotation [None: unused]
+#  inertia: an instance of class RigidBodyInertia, see rigidBodyUtilities; may also be from derived class (InertiaCuboid, InertiaMassPoint, InertiaCylinder, ...)
+#  gravity: gravity vevtor applied (always a 3D vector, no matter if 2D or 3D mass)
+#  graphicsDataList: list of GraphicsData for rigid body visualization; use graphicsDataUtilities function GraphicsData...(...)
+#  graphicsDataUserFunction: a user function graphicsDataUserFunction(mbs, itemNumber)->BodyGraphicsData (list of GraphicsData), which can be used to draw user-defined graphics; this is much slower than regular GraphicsData
+#  drawSize: general drawing size of node
+#  color: color of node
+#  show: True: if graphicsData list is empty, node is shown, otherwise body is shown; False: nothing is shown
+#  create2D: if True, create NodeRigidBody2D and ObjectRigidBody2D
+#  returnDict: if False, returns object index; if True, returns dict of all information on created object and node
+#**output: Union[dict, ObjectIndex]; returns rigid body object index (or dict with 'nodeNumber', 'objectNumber' and possibly 'loadNumber' and 'markerBodyMass' if returnDict=True)
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [1,0,0],
+#                          initialVelocity = [2,5,0],
+#                          initialAngularVelocity = [5,0.5,0.7],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4red)])
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateRigidBody(mbs,
+                           name = '',   
+                           referencePosition = [0.,0.,0.],
+                           referenceRotationMatrix = np.eye(3),
+                           initialVelocity = [0.,0.,0.],
+                           initialAngularVelocity = [0.,0.,0.],
+                           initialDisplacement = None,
+                           initialRotationMatrix = None,
+                           inertia=None,
+                           gravity = [0.,0.,0.],
+                           nodeType=exudyn.NodeType.RotationEulerParameters,
+                           graphicsDataList = [],
+                           graphicsDataUserFunction = 0,
+                           drawSize = -1,
+                           color =  [-1.,-1.,-1.,-1.],
+                           show = True, 
+                           create2D = False, 
+                           returnDict = False): 
+
+    #error checks:        
+    if not exudyn.__useExudynFast:
+        where='MainSystem.CreateRigidBody(...)'
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+        if not IsVector(referencePosition, 3):
+            RaiseTypeError(where=where, argumentName='referencePosition', received = referencePosition, expectedType = ExpectedType.Vector, dim=3)
+        if not IsSquareMatrix(referenceRotationMatrix, 3):
+            RaiseTypeError(where=where, argumentName='referenceRotationMatrix', received = referenceRotationMatrix, expectedType = ExpectedType.Matrix, dim=3)
+
+
+        if not IsVector(initialVelocity, 3):
+            RaiseTypeError(where=where, argumentName='initialVelocity', received = initialVelocity, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(initialAngularVelocity, 3):
+            RaiseTypeError(where=where, argumentName='initialAngularVelocity', received = initialAngularVelocity, expectedType = ExpectedType.Vector, dim=3)
+        if IsNotNone(initialDisplacement) and not IsVector(initialDisplacement, 3):
+            RaiseTypeError(where=where, argumentName='initialDisplacement', received = initialDisplacement, expectedType = ExpectedType.Vector, dim=3)
+        if IsNotNone(initialRotationMatrix) and not IsSquareMatrix(initialRotationMatrix, 3):
+            RaiseTypeError(where=where, argumentName='initialRotationMatrix', received = initialRotationMatrix, expectedType = ExpectedType.Matrix, dim=3)
+
+        if not IsVector(gravity, 3):
+            RaiseTypeError(where=where, argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+        if not IsValidBool(create2D):
+            RaiseTypeError(where=where, argumentName='create2D', received = create2D, expectedType = ExpectedType.Bool)
+        if not IsValidBool(returnDict):
+            RaiseTypeError(where=where, argumentName='returnDict', received = returnDict, expectedType = ExpectedType.Bool)
+    
+        if type(graphicsDataList) != list:
+            raise ValueError(where+': graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
+
+        # if create2D:
+        #     raise ValueError('MainSystem.CreateRigidBody(...): create2D=True currently not supported')
+
+    nodeName = ''
+    if name != '':
+        nodeName = 'Node:'+name
+
+    #++++++++++++++++        
+    if not create2D:
+        RotationMatrix2parameters = None
+        AngularVelocity2parameters_t = None
+        NodeClass = None
+        VNodeClass = None
+        if nodeType == exudyn.NodeType.RotationEulerParameters:
+            RotationMatrix2parameters = RotationMatrix2EulerParameters
+            AngularVelocity2parameters_t = AngularVelocity2EulerParameters_t
+            NodeClass = eii.NodeRigidBodyEP
+            VNodeClass = eii.VNodeRigidBodyEP
+        elif nodeType == exudyn.NodeType.RotationRxyz:
+            RotationMatrix2parameters = RotationMatrix2RotXYZ
+            AngularVelocity2parameters_t = AngularVelocity2RotXYZ_t
+            NodeClass = eii.NodeRigidBodyRxyz
+            VNodeClass = eii.VNodeRigidBodyRxyz
+        elif nodeType == exudyn.NodeType.RotationRotationVector:
+            def AngularVelocity2RotationVector_t(angularVelocity, rotMatrix):
+                return np.dot(rotMatrix.transpose(),angularVelocity)
+                
+            RotationMatrix2parameters = RotationMatrix2RotationVector
+            AngularVelocity2parameters_t = AngularVelocity2RotationVector_t
+            NodeClass = eii.NodeRigidBodyRotVecLG
+            VNodeClass = eii.VNodeRigidBodyRotVecLG
+        else:
+            raise ValueError('MainSystem.CreateRigidBody(...): invalid nodeType!')
+        #++++++++++++++++        
+        referenceRot = RotationMatrix2parameters(referenceRotationMatrix)
+        if nodeType != exudyn.NodeType.RotationRotationVector:
+            rot0_t = AngularVelocity2parameters_t(initialAngularVelocity, referenceRot)
+        else:
+            rot0_t = AngularVelocity2parameters_t(initialAngularVelocity, referenceRotationMatrix)
+    
+        initCoordinates = [0] * (3+len(referenceRot))
+        if IsNotNone(initialDisplacement) or IsNotNone(initialRotationMatrix):
+            if IsNone(initialDisplacement):
+                initialDisplacement = [0.,0.,0.]
+            if IsNone(initialRotationMatrix):
+                initialRotationMatrix = np.eye(3)
+            
+            rotInit = RotationMatrix2parameters(referenceRotationMatrix @ initialRotationMatrix) - referenceRot #relative to reference!
+            initCoordinates  = list(initialDisplacement)+list(rotInit)
+            
+    
+        nodeItem = NodeClass(name = nodeName,
+                             referenceCoordinates=list(referencePosition) + list(referenceRot), 
+                             initialVelocities=list(initialVelocity)+list(rot0_t),
+                             initialCoordinates=initCoordinates,
+                             visualization = VNodeClass(show = show and (graphicsDataList == []), drawSize = drawSize, color = color)
+                             )
+        nodeNumber = mbs.AddNode(nodeItem)
+        bodyNumber = mbs.AddObject(eii.ObjectRigidBody(name=name, physicsMass=inertia.mass, physicsInertia=inertia.GetInertia6D(), 
+                                                       physicsCenterOfMass=inertia.com,
+                                                       nodeNumber=nodeNumber, 
+                                                       visualization=eii.VObjectRigidBody(show = graphicsDataList != [], 
+                                                                                          graphicsDataUserFunction = graphicsDataUserFunction,
+                                                                                          graphicsData=graphicsDataList)))
+    else: #2D
+        A = np.array(referenceRotationMatrix)
+        if not exudyn.__useExudynFast:
+            if abs(referencePosition[2]) > 1e-14:
+                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, referencePosition may not have a Z-component')
+            if (abs(A[2,0]) + abs(A[2,1]) + abs(A[0,2]) + abs(A[1,2]) + abs(A[2,2]-1)) > 1e-13:
+                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, referenceRotationMatrix must only have a rotation around Z-axis')
+            if (abs(initialVelocity[2])) > 1e-14:
+                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialVelocity must not have a Z-component')
+            if (abs(initialAngularVelocity[0]) + abs(initialAngularVelocity[1])) > 1e-14:
+                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialAngularVelocity must only have a Z-component')
+            if np.linalg.norm(inertia.com) > 1e-14:
+                raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, the center of mass in inertia must be [0,0,0] (will be fixed in future)')
+
+
+        referenceRot = np.arctan2(A[1,0],A[0,0])
+    
+        initCoordinates = [0.,0.,0.]
+        if IsNotNone(initialDisplacement) or IsNotNone(initialRotationMatrix):
+            if IsNotNone(initialDisplacement):
+                if abs(initialDisplacement[2]) > 1e-14:
+                    raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialDisplacement may not have a Z-component')
+                initCoordinates[0] = initialDisplacement[0]
+                initCoordinates[1] = initialDisplacement[1]
+            if IsNotNone(initialRotationMatrix):
+                A0 = np.array(initialRotationMatrix)
+                if (abs(A0[2,0]) + abs(A0[2,1]) + abs(A0[0,2]) + abs(A0[1,2]) + abs(A0[2,2]-1)) > 1e-13:
+                    raise ValueError('MainSystem.CreateRigidBody(...): in case of 2D rigid body, initialRotationMatrix must only have a rotation around Z-axis')
+                phi0 = np.arctan2(A0[1,0],A0[0,0]) - referenceRot
+                initCoordinates[2] = phi0
+            
+        nodeItem = eii.NodeRigidBody2D(name = nodeName,
+                             referenceCoordinates=[referencePosition[0],referencePosition[1],referenceRot], 
+                             initialCoordinates=initCoordinates,
+                             initialVelocities=[initialVelocity[0],initialVelocity[1],initialAngularVelocity[2]],
+                             visualization = eii.VNodeRigidBody2D(show = show and (graphicsDataList == []), drawSize = drawSize, color = color)
+                             )
+        nodeNumber = mbs.AddNode(nodeItem)
+        bodyNumber = mbs.AddObject(eii.ObjectRigidBody2D(name=name, physicsMass=inertia.mass, physicsInertia=inertia.GetInertia6D()[2],
+                                                       #physicsCenterOfMass=inertia.com,
+                                                       nodeNumber=nodeNumber,
+                                                       visualization=eii.VObjectRigidBody(show = graphicsDataList != [],
+                                                                                          graphicsDataUserFunction=graphicsDataUserFunction,
+                                                                                          graphicsData=graphicsDataList)))
+        
+    if returnDict:
+        rDict = {'nodeNumber':nodeNumber, 'bodyNumber': bodyNumber}
+
+    if np.linalg.norm(gravity) != 0.:
+        markerNumber = mbs.AddMarker(eii.MarkerBodyMass(bodyNumber=bodyNumber))
+        loadNumber = mbs.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
+
+        if returnDict:
+            rDict['markerBodyMass'] = markerNumber
+            rDict['loadNumber'] = loadNumber
+
+    if returnDict:
+        return rDict
+    else:
+        return bodyNumber
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create SpringDamper connector, using arguments from ObjectConnectorSpringDamper; similar interface as CreateDistanceConstraint(...), see there for for further information
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for connector; markers get Marker0:name and Marker1:name
+#  bodyList: a list of two body numbers (ObjectIndex) to be connected
+#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
+#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
+#  referenceLength: if None, length is computed from reference position of bodies or nodes; if not None, this scalar reference length is used for spring
+#  stiffness: scalar stiffness coefficient
+#  damping: scalar damping coefficient
+#  force: scalar additional force applied
+#  velocityOffset: scalar offset: if referenceLength is changed over time, the velocityOffset may be changed accordingly to emulate a reference motion
+#  springForceUserFunction: a user function springForceUserFunction(mbs, t, itemNumber, deltaL, deltaL\_t, stiffness, damping, force)->float ; this function replaces the internal connector force compuation
+#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
+#  show: if True, connector visualization is drawn
+#  drawSize: general drawing size of connector
+#  color: color of connector
+#**output: ObjectIndex; returns index of newly created object
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateMassPoint(referencePosition = [2,0,0],
+#                          initialVelocity = [2,5,0],
+#                          physicsMass = 1, gravity = [0,-9.81,0],
+#                          drawSize = 0.5, color=color4blue)
+# 
+# oGround = mbs.AddObject(ObjectGround())
+# #add vertical spring
+# oSD = mbs.CreateSpringDamper(bodyList=[oGround, b0],
+#                              localPosition0=[2,1,0],
+#                              localPosition1=[0,0,0],
+#                              stiffness=1e4, damping=1e2,
+#                              drawSize=0.2)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# SC.visualizationSettings.nodes.drawNodesAsPoint=False
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateSpringDamper(mbs,
+                                 name='',
+                                 bodyList=[None, None], 
+                                 localPosition0 = [0.,0.,0.],
+                                 localPosition1 = [0.,0.,0.], 
+                                 referenceLength = None, 
+                                 stiffness = 0., damping = 0., force = 0.,
+                                 velocityOffset = 0., 
+                                 springForceUserFunction = 0,
+                                 bodyOrNodeList=[None, None], 
+                                 show=True, drawSize=-1, color=color4default):
+    #perform some checks:
+    where='MainSystem.CreateSpringDamper(...)'
+    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
+    
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+                
+        if not IsVector(localPosition0, 3):
+            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition1, 3):
+            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
+    
+        if IsNotNone(referenceLength) and not IsValidURealInt(referenceLength):
+            RaiseTypeError(where=where, argumentName='referenceLength', received = referenceLength, expectedType = ExpectedType.PReal)
+        if not IsValidRealInt(stiffness):
+            RaiseTypeError(where=where, argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(damping):
+            RaiseTypeError(where=where, argumentName='damping', received = damping, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(force):
+            RaiseTypeError(where=where, argumentName='force', received = force, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(velocityOffset):
+            RaiseTypeError(where=where, argumentName='velocityOffset', received = velocityOffset, expectedType = ExpectedType.Real)
+    
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+    
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+        
+    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+        mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
+    else:
+        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
+
+    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+        mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
+    else:
+        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
+        
+    if IsNone(referenceLength): #automatically compute reference length
+        
+        if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+            p0 = mbs.GetObjectOutputBody(internBodyNodeList[0],exudyn.OutputVariableType.Position,
+                                         localPosition=localPosition0, configuration=exudyn.ConfigurationType.Reference)
+        else:
+            p0 = mbs.GetNodeOutput(internBodyNodeList[0],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
+            
+        if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+            p1 = mbs.GetObjectOutputBody(internBodyNodeList[1],exudyn.OutputVariableType.Position,
+                                         localPosition=localPosition1, configuration=exudyn.ConfigurationType.Reference)
+        else:
+            p1 = mbs.GetNodeOutput(internBodyNodeList[1],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
+        
+        referenceLength = np.linalg.norm(np.array(p1)-p0)
+    
+    oConnector = mbs.AddObject(eii.ObjectConnectorSpringDamper(name=name,markerNumbers = [mBody0,mBody1],
+                                                                      referenceLength = referenceLength,
+                                                                      stiffness = stiffness,
+                                                                      damping = damping,
+                                                                      force = force, 
+                                                                      velocityOffset = velocityOffset,
+                                                                      springForceUserFunction=springForceUserFunction,
+                                                                      visualization=eii.VSpringDamper(show=show, drawSize=drawSize,
+                                                                                                      color=color)
+                                                                      ))
+
+    return oConnector
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create CartesianSpringDamper connector, using arguments from ObjectConnectorCartesianSpringDamper
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for connector; markers get Marker0:name and Marker1:name
+#  bodyList: a list of two body numbers (ObjectIndex) to be connected
+#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
+#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
+#  stiffness: stiffness coefficients (as 3D list or numpy array)
+#  damping: damping coefficients (as 3D list or numpy array)
+#  offset: offset vector (as 3D list or numpy array)
+#  springForceUserFunction: a user function springForceUserFunction(mbs, t, itemNumber, displacement, velocity, stiffness, damping, offset)->[float,float,float] ; this function replaces the internal connector force compuation
+#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
+#  show: if True, connector visualization is drawn
+#  drawSize: general drawing size of connector
+#  color: color of connector
+#**output: ObjectIndex; returns index of newly created object
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateMassPoint(referencePosition = [7,0,0],
+#                           physicsMass = 1, gravity = [0,-9.81,0],
+#                           drawSize = 0.5, color=color4blue)
+# 
+# oGround = mbs.AddObject(ObjectGround())
+# 
+# oSD = mbs.CreateCartesianSpringDamper(bodyList=[oGround, b0],
+#                               localPosition0=[7.5,1,0],
+#                               localPosition1=[0,0,0],
+#                               stiffness=[200,2000,0], damping=[2,20,0],
+#                               drawSize=0.2)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# SC.visualizationSettings.nodes.drawNodesAsPoint=False
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateCartesianSpringDamper(mbs,
+                                 name='',
+                                 bodyList=[None, None], 
+                                 localPosition0 = [0.,0.,0.],
+                                 localPosition1 = [0.,0.,0.], 
+                                 stiffness = [0.,0.,0.], damping = [0.,0.,0.], 
+                                 offset = [0.,0.,0.],
+                                 springForceUserFunction = 0,
+                                 bodyOrNodeList=[None, None], 
+                                 show=True, drawSize=-1, color=color4default):
+
+    where='MainSystem.CreateCartesianSpringDamper(...)'
+    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
+
+    #perform some checks:
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+    
+        if not IsVector(localPosition0, 3):
+            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition1, 3):
+            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsVector(stiffness, 3):
+            RaiseTypeError(where=where, argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(damping, 3):
+            RaiseTypeError(where=where, argumentName='damping', received = damping, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(offset, 3):
+            RaiseTypeError(where=where, argumentName='offset', received = offset, expectedType = ExpectedType.Vector, dim=3)
+
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+    
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+        
+    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+        mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
+    else:
+        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
+
+    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+        mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
+    else:
+        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
+            
+    oConnector = mbs.AddObject(eii.ObjectConnectorCartesianSpringDamper(name=name,markerNumbers = [mBody0,mBody1],
+                                                                        stiffness = stiffness, damping = damping, offset = offset,
+                                                                        springForceUserFunction=springForceUserFunction,
+                                                                        visualization=eii.VCartesianSpringDamper(show=show, 
+                                                                                      drawSize=drawSize, color=color)
+                                                                      ))
+
+    return oConnector
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create RigidBodySpringDamper connector, using arguments from ObjectConnectorRigidBodySpringDamper, see there for the full documentation
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for connector; markers get Marker0:name and Marker1:name
+#  bodyList: a list of two body numbers (ObjectIndex) to be connected
+#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
+#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
+#  stiffness: stiffness coefficients (as 6D matrix or numpy array)
+#  damping: damping coefficients (as 6D matrix or numpy array)
+#  offset: offset vector (as 6D list or numpy array)
+#  rotationMatrixJoint: additional rotation matrix; in case  useGlobalFrame=False, it transforms body0/node0 local frame to joint frame; if useGlobalFrame=True, it transforms global frame to joint frame
+#  useGlobalFrame: if False, the rotationMatrixJoint is defined in the local coordinate system of body0
+#  intrinsicFormulation: if True, uses intrinsic formulation of Maserati and Morandini, which uses matrix logarithm and is independent of order of markers (preferred formulation); otherwise, Tait-Bryan angles are used for computation of torque, see documentation
+#  springForceTorqueUserFunction: a user function springForceTorqueUserFunction(mbs, t, itemNumber, displacement, rotation, velocity, angularVelocity, stiffness, damping, rotJ0, rotJ1, offset)->[float,float,float, float,float,float] ; this function replaces the internal connector force / torque compuation
+#  postNewtonStepUserFunction: a special user function postNewtonStepUserFunction(mbs, t, Index itemIndex, dataCoordinates, displacement, rotation, velocity, angularVelocity, stiffness, damping, rotJ0, rotJ1, offset)->[PNerror, recommendedStepSize, data[0], data[1], ...] ; for details, see RigidBodySpringDamper for full docu
+#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
+#  show: if True, connector visualization is drawn
+#  drawSize: general drawing size of connector
+#  color: color of connector
+#**output: ObjectIndex; returns index of newly created object
+#**belongsTo: MainSystem
+#**example:
+# #TODO
+def MainSystemCreateRigidBodySpringDamper(mbs,
+                                 name='',
+                                 bodyList=[None, None], 
+                                 localPosition0 = [0.,0.,0.],
+                                 localPosition1 = [0.,0.,0.], 
+                                 stiffness = np.zeros((6,6)), 
+                                 damping = np.zeros((6,6)), 
+                                 offset = [0.,0.,0.,0.,0.,0.],
+                                 rotationMatrixJoint=np.eye(3),
+                                 useGlobalFrame=True,
+                                 intrinsicFormulation=True,
+                                 springForceTorqueUserFunction=0,
+                                 postNewtonStepUserFunction=0,
+                                 bodyOrNodeList=[None, None],
+                                 show=True, drawSize=-1, color=color4default):
+
+    where='MainSystem.CreateRigidBodySpringDamper(...)'
+    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
+
+    #perform some checks:
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+                
+        if not IsVector(localPosition0, 3):
+            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition1, 3):
+            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsSquareMatrix(stiffness, 6):
+            RaiseTypeError(where=where, argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Matrix, dim=6)
+        if not IsSquareMatrix(damping, 6):
+            RaiseTypeError(where=where, argumentName='damping', received = damping, expectedType = ExpectedType.Matrix, dim=6)
+        if not IsVector(offset, 6):
+            RaiseTypeError(where=where, argumentName='offset', received = offset, expectedType = ExpectedType.Vector, dim=3)
+
+
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsValidBool(useGlobalFrame):
+            RaiseTypeError(where=where, argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
+
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+    
+    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+        mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
+        A0 = mbs.GetObjectOutputBody(objectNumber=internBodyNodeList[0],variableType=exudyn.OutputVariableType.RotationMatrix,
+                                     localPosition=localPosition0,
+                                     configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
+    else:
+        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
+        A0 = mbs.GetNodeOutput(nodeNumber=internBodyNodeList[0], variableType=exudyn.OutputVariableType.RotationMatrix,
+                               configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
+
+    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+        mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
+        A1 = mbs.GetObjectOutputBody(objectNumber=internBodyNodeList[1],variableType=exudyn.OutputVariableType.RotationMatrix,
+                                     localPosition=localPosition1,
+                                     configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
+    else:
+        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
+        A1 = mbs.GetNodeOutput(nodeNumber=internBodyNodeList[1], variableType=exudyn.OutputVariableType.RotationMatrix,
+                               configuration=exudyn.ConfigurationType.Reference).reshape((3,3))
+
+    # print('A0=',A0)
+    # print('A1=',A1)
+    if useGlobalFrame:
+        #compute joint marker orientations, rotationMatrixAxes represents global frame:
+        MR0 = A0.T @ rotationMatrixJoint
+        MR1 = A1.T @ rotationMatrixJoint
+    else: #transform into global coordinates, then everything works same
+        #compute joint marker orientations, rotationMatrixAxes represents local frame:
+        MR0 = rotationMatrixJoint
+        MR1 = A1.T @ A0 @ rotationMatrixJoint
+
+            
+    oConnector = mbs.AddObject(eii.ObjectConnectorRigidBodySpringDamper(name=name,markerNumbers = [mBody0,mBody1],
+                                                                        stiffness = stiffness, damping = damping, 
+                                                                        offset = offset,
+                                                                        rotationMarker0=MR0, 
+                                                                        rotationMarker1=MR1,
+                                                                        intrinsicFormulation=intrinsicFormulation,
+                                                                        springForceTorqueUserFunction=springForceTorqueUserFunction, 
+                                                                        postNewtonStepUserFunction=postNewtonStepUserFunction,
+                                                                        visualization=eii.VRigidBodySpringDamper(show=show, 
+                                                                                      drawSize=drawSize, color=color)
+                                                                      ))
+
+    return oConnector
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Create revolute joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
+#**input:
+#  mbs: the MainSystem where joint and markers shall be created
+#  name: name string for joint; markers get Marker0:name and Marker1:name
+#  bodyNumbers: a list of object numbers for body0 and body1; must be rigid body or ground object
+#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
+#  axis: a 3D vector as list or np.array containing the joint axis either in local body0 coordinates (useGlobalFrame=False), or in global reference configuration (useGlobalFrame=True)
+#  useGlobalFrame: if False, the position and axis vectors are defined in the local coordinate system of body0, otherwise in global (reference) coordinates
+#  show: if True, connector visualization is drawn
+#  axisRadius: radius of axis for connector graphical representation
+#  axisLength: length of axis for connector graphical representation
+#  color: color of connector
+#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [3,0,0],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4steelblue)])
+# oGround = mbs.AddObject(ObjectGround())
+# mbs.CreateRevoluteJoint(bodyNumbers=[oGround, b0], position=[2.5,0,0], axis=[0,0,1],
+#                         useGlobalFrame=True, axisRadius=0.02, axisLength=0.14)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateRevoluteJoint(mbs, name='', bodyNumbers=[None, None], 
+                                  position=[], axis=[], useGlobalFrame=True, 
+                                  show=True, axisRadius=0.1, axisLength=0.4, color=color4default):
+    
+    where = 'MainSystem.CreateRevoluteJoint(...)'
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsVector(axis, 3):
+            RaiseTypeError(where=where, argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsValidRealInt(axisRadius):
+            RaiseTypeError(where=where, argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(axisLength):
+            RaiseTypeError(where=where, argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
+        
+    if useGlobalFrame:
+        pJoint = copy.copy(position)
+        vAxis = copy.copy(axis)
+    else: #transform into global coordinates, then everything works same
+        pJoint = A0 @ position + p0
+        vAxis = A0 @ axis
+
+    #compute joint frame (not unique, only rotation axis must coincide)
+    B = ComputeOrthonormalBasis(vAxis) #axis = x-axis
+    #interchange z and x axis (needs sign change, otherwise det(A)=-1)
+    AJ = np.eye(3)
+    AJ[:,0]=-B[:,2]
+    AJ[:,1]= B[:,1]
+    AJ[:,2]= B[:,0] #axis ==> rotation axis z for revolute joint ... 
+    #print(AJ)
+    
+    #compute joint position and axis in bodyNumber0 / 1 coordinates:
+    pJ0 = A0.T @ (np.array(pJoint) - p0)
+    pJ1 = A1.T @ (np.array(pJoint) - p1)
+
+    #compute joint marker orientations:
+    MR0 = A0.T @ AJ  
+    MR1 = A1.T @ AJ  
+    
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+
+    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
+    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
+    
+    oJoint = mbs.AddObject(eii.ObjectJointRevoluteZ(name=name,markerNumbers=[mBody0,mBody1],
+                                                rotationMarker0=MR0,
+                                                rotationMarker1=MR1,
+             visualization=eii.VRevoluteJointZ(show=show, axisRadius=axisRadius, axisLength=axisLength, color=color) ))
+
+    return [oJoint, mBody0, mBody1]
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Create prismatic joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
+#**input:
+#  mbs: the MainSystem where joint and markers shall be created
+#  name: name string for joint; markers get Marker0:name and Marker1:name
+#  bodyNumbers: a list of object numbers for body0 and body1; must be rigid body or ground object
+#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
+#  axis: a 3D vector as list or np.array containing the joint axis either in local body0 coordinates (useGlobalFrame=False), or in global reference configuration (useGlobalFrame=True)
+#  useGlobalFrame: if False, the position and axis vectors are defined in the local coordinate system of body0, otherwise in global (reference) coordinates
+#  show: if True, connector visualization is drawn
+#  axisRadius: radius of axis for connector graphical representation
+#  axisLength: length of axis for connector graphical representation
+#  color: color of connector
+#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [4,0,0],
+#                          initialVelocity = [0,4,0],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4steelblue)])
+# 
+# oGround = mbs.AddObject(ObjectGround())
+# mbs.CreatePrismaticJoint(bodyNumbers=[oGround, b0], position=[3.5,0,0], axis=[0,1,0], 
+#                          useGlobalFrame=True, axisRadius=0.02, axisLength=1)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreatePrismaticJoint(mbs, name='', bodyNumbers=[None, None], 
+                                  position=[], axis=[], useGlobalFrame=True, 
+                                  show=True, axisRadius=0.1, axisLength=0.4, color=color4default):
+        
+    where = 'MainSystem.CreatePrismaticJoint(...)'
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsVector(axis, 3):
+            RaiseTypeError(where=where, argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsValidRealInt(axisRadius):
+            RaiseTypeError(where=where, argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(axisLength):
+            RaiseTypeError(where=where, argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
+
+
+    if useGlobalFrame:
+        pJoint = copy.copy(position)
+        vAxis = copy.copy(axis)
+    else: #transform into global coordinates, then everything works same
+        pJoint = A0 @ position + p0
+        vAxis = A0 @ axis
+
+    #compute joint frame (not unique, only rotation axis must coincide)
+    AJ = ComputeOrthonormalBasis(vAxis) #axis = x-axis
+    
+    #compute joint position and axis in bodyNumber0 / 1 coordinates:
+    pJ0 = A0.T @ (np.array(pJoint) - p0)
+    pJ1 = A1.T @ (np.array(pJoint) - p1)
+
+    #compute joint marker orientations:
+    MR0 = A0.T @ AJ  
+    MR1 = A1.T @ AJ  
+    
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+
+    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
+    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
+    
+    oJoint = mbs.AddObject(eii.ObjectJointPrismaticX(name=name,markerNumbers=[mBody0,mBody1],
+                                                rotationMarker0=MR0,
+                                                rotationMarker1=MR1,
+             visualization=eii.VPrismaticJointX(show=show, axisRadius=axisRadius, axisLength=axisLength, color=color) ))
+
+    return [oJoint, mBody0, mBody1]
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Create spherical joint between two bodies; definition of joint position in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers are automatically computed
+#**input:
+#  mbs: the MainSystem where joint and markers shall be created
+#  name: name string for joint; markers get Marker0:name and Marker1:name
+#  bodyNumbers: a list of object numbers for body0 and body1; must be mass point, rigid body or ground object
+#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
+#  constrainedAxes: flags, which determines which (global) translation axes are constrained; each entry may only be 0 (=free) axis or 1 (=constrained axis)
+#  useGlobalFrame: if False, the point and axis vectors are defined in the local coordinate system of body0
+#  show: if True, connector visualization is drawn
+#  jointRadius: radius of sphere for connector graphical representation
+#  color: color of connector
+#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [5,0,0],
+#                          initialAngularVelocity = [5,0,0],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4orange)])
+# oGround = mbs.AddObject(ObjectGround())
+# mbs.CreateSphericalJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0], 
+#                          useGlobalFrame=True, jointRadius=0.06)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateSphericalJoint(mbs, name='', bodyNumbers=[None, None], 
+                                  position=[], constrainedAxes=[1,1,1], useGlobalFrame=True, 
+                                  show=True, jointRadius=0.1, color=color4default):
+        
+    where = 'MainSystem.CreateSphericalJoint(...)'
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsIntVector(constrainedAxes, 3):
+            RaiseTypeError(where=where, argumentName='constrainedAxes', received = constrainedAxes, expectedType = ExpectedType.IntVector, dim=3)
+        if not IsValidRealInt(jointRadius):
+            RaiseTypeError(where=where, argumentName='jointRadius', received = jointRadius, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
+
+    if useGlobalFrame:
+        pJoint = copy.copy(position)
+    else: #transform into global coordinates, then everything works same
+        pJoint = A0 @ position + p0
+
+    
+    #compute joint position and axis in bodyNumber0 / 1 coordinates:
+    pJ0 = A0.T @ (np.array(pJoint) - p0)
+    pJ1 = A1.T @ (np.array(pJoint) - p1)
+
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+
+    mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
+    mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
+    
+    oJoint = mbs.AddObject(eii.ObjectJointSpherical(name=name,markerNumbers=[mBody0,mBody1], 
+                                                    constrainedAxes=constrainedAxes,
+             visualization=eii.VObjectJointSpherical(show=show, jointRadius=jointRadius, color=color) ))
+
+    return [oJoint, mBody0, mBody1]
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Create generic joint between two bodies; definition of joint position (position) and axes (rotationMatrixAxes) in global coordinates (useGlobalFrame=True) or in local coordinates of body0 (useGlobalFrame=False), where rotationMatrixAxes is an additional rotation to body0; all markers, markerRotation and other quantities are automatically computed
+#**input:
+#  mbs: the MainSystem where joint and markers shall be created
+#  name: name string for joint; markers get Marker0:name and Marker1:name
+#  bodyNumber0: a object number for body0, must be rigid body or ground object
+#  bodyNumber1: a object number for body1, must be rigid body or ground object
+#  position: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
+#  rotationMatrixAxes: rotation matrix which defines orientation of constrainedAxes; if useGlobalFrame, this rotation matrix is global, else the rotation matrix is post-multiplied with the rotation of body0, identical with rotationMarker0 in the joint
+#  constrainedAxes: flag, which determines which translation (0,1,2) and rotation (3,4,5) axes are constrained; each entry may only be 0 (=free) axis or 1 (=constrained axis); ALL constrained Axes are defined relative to reference rotation of body0 times rotation0
+#  useGlobalFrame: if False, the position is defined in the local coordinate system of body0, otherwise it is defined in global coordinates
+#  offsetUserFunction: a user function offsetUserFunction(mbs, t, itemNumber, offsetUserFunctionParameters)->float ; this function replaces the internal (constant) by a user-defined offset. This allows to realize rheonomic joints and allows kinematic simulation
+#  offsetUserFunction_t: a user function offsetUserFunction\_t(mbs, t, itemNumber, offsetUserFunctionParameters)->float ; this function replaces the internal (constant) by a user-defined offset velocity; this function is used instead of offsetUserFunction, if velocityLevel (index2) time integration
+#  show: if True, connector visualization is drawn
+#  axesRadius: radius of axes for connector graphical representation
+#  axesLength: length of axes for connector graphical representation
+#  color: color of connector
+#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [6,0,0],
+#                          initialAngularVelocity = [0,8,0],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4orange)])
+# oGround = mbs.AddObject(ObjectGround())
+# mbs.CreateGenericJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
+#                        constrainedAxes=[1,1,1, 1,0,0],
+#                        rotationMatrixAxes=RotationMatrixX(0.125*pi), #tilt axes
+#                        useGlobalFrame=True, axesRadius=0.02, axesLength=0.2)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateGenericJoint(mbs, name='', bodyNumbers=[None, None], 
+                                 position=[], 
+                                 rotationMatrixAxes=np.eye(3), 
+                                 constrainedAxes=[1,1,1, 1,1,1], 
+                                 useGlobalFrame=True,
+                                 offsetUserFunction=0, offsetUserFunction_t=0,
+                                 show=True, axesRadius=0.1, axesLength=0.4, color=color4default):
+        
+    where = 'MainSystem.CreateGenericJoint(...)'
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsIntVector(constrainedAxes, 6):
+            RaiseTypeError(where=where, argumentName='constrainedAxes', received = constrainedAxes, expectedType = ExpectedType.IntVector, dim=6)
+    
+        if not IsValidRealInt(axesRadius):
+            RaiseTypeError(where=where, argumentName='axesRadius', received = axesRadius, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(axesLength):
+            RaiseTypeError(where=where, argumentName='axesLength', received = axesLength, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+    [p0, A0, p1, A1] = JointPreCheckCalc(where, mbs, name, bodyNumbers, position, show, useGlobalFrame)
+
+
+    if useGlobalFrame:
+        pJoint = copy.copy(position)
+        #compute joint marker orientations, rotationMatrixAxes represents global frame:
+        MR0 = A0.T @ rotationMatrixAxes
+        MR1 = A1.T @ rotationMatrixAxes
+    else: #transform into global coordinates, then everything works same
+        pJoint = A0 @ position + p0
+        #compute joint marker orientations, rotationMatrixAxes represents local frame:
+        MR0 = copy.copy(rotationMatrixAxes)
+        MR1 = A1.T @ A0 @ rotationMatrixAxes
+
+    
+    #compute joint position and axis in bodyNumber0 / 1 coordinates:
+    pJ0 = A0.T @ (np.array(pJoint) - p0)
+    pJ1 = A1.T @ (np.array(pJoint) - p1)
+
+    
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+
+    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName0,bodyNumber=bodyNumbers[0], localPosition=pJ0))
+    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(name=mName1,bodyNumber=bodyNumbers[1], localPosition=pJ1))
+    
+    oJoint = mbs.AddObject(eii.ObjectJointGeneric(name=name,markerNumbers=[mBody0,mBody1],
+                                                  constrainedAxes = constrainedAxes,
+                                                  rotationMarker0=MR0,
+                                                  rotationMarker1=MR1, 
+                                                  offsetUserFunction=offsetUserFunction,
+                                                  offsetUserFunction_t=offsetUserFunction_t,
+             visualization=eii.VObjectJointGeneric(show=show, axesRadius=axesRadius, axesLength=axesLength, color=color) ))
+
+    return [oJoint, mBody0, mBody1]
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Create distance joint between two bodies; definition of joint positions in local coordinates of bodies or nodes; if distance=None, it is computed automatically from reference length; all markers are automatically computed
+#**input:
+#  mbs: the MainSystem where joint and markers shall be created
+#  name: name string for joint; markers get Marker0:name and Marker1:name
+#  bodyList: a list of two body numbers (ObjectIndex) to be constrained
+#  localPosition0: local position (as 3D list or numpy array) on body0, if not a node number
+#  localPosition1: local position (as 3D list or numpy array) on body1, if not a node number
+#  distance: if None, distance is computed from reference position of bodies or nodes; if not None, this distance is prescribed between the two positions; if distance = 0, it will create a SphericalJoint as this case is not possible with a DistanceConstraint
+#  bodyOrNodeList: alternative to bodyList; a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types; to use this case, set bodyList = [None,None]
+#  show: if True, connector visualization is drawn
+#  drawSize: general drawing size of node
+#  color: color of connector
+#**output: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                   sideLengths=[1,0.1,0.1]),
+#                           referencePosition = [6,0,0],
+#                           gravity = [0,-9.81,0],
+#                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4orange)])
+# m1 = mbs.CreateMassPoint(referencePosition=[5.5,-1,0],
+#                          physicsMass=1, drawSize = 0.2)
+# n1 = mbs.GetObject(m1)['nodeNumber']
+#     
+# oGround = mbs.AddObject(ObjectGround())
+# mbs.CreateDistanceConstraint(bodyList=[oGround, b0], 
+#                              localPosition0 = [6.5,1,0],
+#                              localPosition1 = [0.5,0,0],
+#                              distance=None, #automatically computed
+#                              drawSize=0.06)
+# 
+# mbs.CreateDistanceConstraint(bodyOrNodeList=[b0, n1], 
+#                              localPosition0 = [-0.5,0,0],
+#                              localPosition1 = [0.,0.,0.], #must be [0,0,0] for Node
+#                              distance=None, #automatically computed
+#                              drawSize=0.06)
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# 
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateDistanceConstraint(mbs, name='', 
+                                       bodyList=[None, None], 
+                                       localPosition0 = [0.,0.,0.],
+                                       localPosition1 = [0.,0.,0.], 
+                                       distance=None, 
+                                       bodyOrNodeList=[None, None],
+                                       show=True, drawSize=-1., color=color4default):
+    
+    where = 'MainSystem.CreateDistanceConstraint(...)'
+    internBodyNodeList = ProcessBodyNodeLists(bodyList, bodyOrNodeList, localPosition0, localPosition1, where)
+        
+    if not exudyn.__useExudynFast:
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+            
+        if not IsVector(localPosition0, 3):
+            RaiseTypeError(where=where, argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition1, 3):
+            RaiseTypeError(where=where, argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
+    
+        if IsNotNone(distance) and not IsValidURealInt(distance):
+            RaiseTypeError(where=where, argumentName='distance', received = distance, expectedType = ExpectedType.PReal)
+
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where=where, argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+        if not IsVector(color, 4):
+            RaiseTypeError(where=where, argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+
+
+    mName0 = ''
+    mName1 = ''
+    if name != '':
+        mName0 = 'Marker0:'+name
+        mName1 = 'Marker1:'+name
+        
+    if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+        mBody0 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName0,bodyNumber=internBodyNodeList[0], localPosition=localPosition0))
+    else:
+        mBody0 = mbs.AddMarker(eii.MarkerNodePosition(name=mName0,nodeNumber=internBodyNodeList[0]))
+
+    if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+        mBody1 = mbs.AddMarker(eii.MarkerBodyPosition(name=mName1,bodyNumber=internBodyNodeList[1], localPosition=localPosition1))
+    else:
+        mBody1 = mbs.AddMarker(eii.MarkerNodePosition(name=mName1,nodeNumber=internBodyNodeList[1]))
+        
+    if IsNone(distance): #automatically compute distance
+        
+        if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+            p0 = mbs.GetObjectOutputBody(internBodyNodeList[0],exudyn.OutputVariableType.Position,
+                                         localPosition=localPosition0, configuration=exudyn.ConfigurationType.Reference)
+        else:
+            p0 = mbs.GetNodeOutput(internBodyNodeList[0],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
+            
+        if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+            p1 = mbs.GetObjectOutputBody(internBodyNodeList[1],exudyn.OutputVariableType.Position,
+                                         localPosition=localPosition1, configuration=exudyn.ConfigurationType.Reference)
+        else:
+            p1 = mbs.GetNodeOutput(internBodyNodeList[1],exudyn.OutputVariableType.Position, configuration=exudyn.ConfigurationType.Reference)
+        
+        distance = np.linalg.norm(np.array(p1)-p0)
+    
+    if distance != 0:
+        oJoint = mbs.AddObject(eii.ObjectConnectorDistance(name=name,markerNumbers=[mBody0,mBody1], distance=distance,
+                 visualization=eii.VObjectConnectorDistance(show=show, drawSize=drawSize, color=color) ))
+    else:
+        #VERY SPECIAL case, which should help to resolve problems if distance=0 is used ... 
+        exu.Print('WARNING: CreateDistanceConstraint called with distance=0; creating SphericalJoint instead')
+        constrainedAxes = [1,1,1]
+        if isinstance(internBodyNodeList[0], exudyn.ObjectIndex):
+            if '2D' in mbs.GetObject(internBodyNodeList[0])['objectType']:
+                constrainedAxes[2] = 0
+        if isinstance(internBodyNodeList[1], exudyn.ObjectIndex):
+            if '2D' in mbs.GetObject(internBodyNodeList[1])['objectType']:
+                constrainedAxes[2] = 0
+        oJoint = mbs.AddObject(eii.SphericalJoint(name=name,markerNumbers=[mBody0,mBody1], 
+                                                  constrainedAxes=constrainedAxes,
+                                                  visualization=eii.VSphericalJoint(show=show, jointRadius=0.5*drawSize, color=color) ))
+        
+
+    return [oJoint, mBody0, mBody1]
+
+
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create force applied to given body
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for object
+#  bodyNumber: body number (ObjectIndex) at which the force is applied to
+#  loadVector: force vector (as 3D list or numpy array)
+#  localPosition: local position (as 3D list or numpy array) where force is applied
+#  bodyFixed: if True, the force is corotated with the body; else, the force is global
+#  loadVectorUserFunction: A Python function f(mbs, t, load)->loadVector which defines the time-dependent load and replaces loadVector in every time step; the arg load is the static loadVector
+#  show: if True, load is drawn
+#**output: LoadIndex; returns load index
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0=mbs.CreateMassPoint(referencePosition = [0,0,0],
+#                        initialVelocity = [2,5,0],
+#                        physicsMass = 1, gravity = [0,-9.81,0],
+#                        drawSize = 0.5, color=color4blue)
+#
+# f0=mbs.CreateForce(bodyNumber=b0, loadVector=[100,0,0],
+#                    localPosition=[0,0,0])
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateForce(mbs,
+                name = '',   
+                bodyNumber = None,
+                loadVector = [0.,0.,0.], 
+                localPosition = [0.,0.,0.], 
+                bodyFixed = False,
+                loadVectorUserFunction = 0,
+                show = True):
+
+    #error checks:        
+    if not exudyn.__useExudynFast:
+        where='MainSystem.CreateForce(...)'
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsValidObjectIndex(bodyNumber):
+            RaiseTypeError(where=where, argumentName='bodyNumber', received = bodyNumber, expectedType = ExpectedType.ObjectIndex)
+        if not IsVector(loadVector, 3):
+            RaiseTypeError(where=where, argumentName='loadVector', received = loadVector, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition, 3):
+            RaiseTypeError(where=where, argumentName='localPosition', received = localPosition, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsValidRealInt(bodyFixed):
+            RaiseTypeError(where=where, argumentName='bodyFixed', received = bodyFixed, expectedType = ExpectedType.Bool)
+        
+        # if not IsUserFunction(loadVectorUserFunction):
+        #     RaiseTypeError(where=where, argumentName='loadVectorUserFunction', received = loadVectorUserFunction, expectedType = ExpectedType.UserFunction)
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+    
+
+    if bodyFixed:
+        markerNumber = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=bodyNumber, localPosition=localPosition))
+    else:
+        markerNumber = mbs.AddMarker(eii.MarkerBodyPosition(bodyNumber=bodyNumber, localPosition=localPosition))
+        
+    loadNumber = mbs.AddLoad(eii.LoadForceVector(markerNumber=markerNumber, 
+                                                 loadVector=loadVector,
+                                                 bodyFixed=bodyFixed, 
+                                                 loadVectorUserFunction=loadVectorUserFunction))
+
+    return loadNumber
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function to create torque applied to given body
+#**input: 
+#  mbs: the MainSystem where items are created
+#  name: name string for object
+#  bodyNumber: body number (ObjectIndex) at which the torque is applied to
+#  loadVector: torque vector (as 3D list or numpy array)
+#  localPosition: local position (as 3D list or numpy array) where torque is applied
+#  bodyFixed: if True, the torque is corotated with the body; else, the torque is global
+#  loadVectorUserFunction: A Python function f(mbs, t, load)->loadVector which defines the time-dependent load and replaces loadVector in every time step; the arg load is the static loadVector
+#  show: if True, load is drawn
+#**output: LoadIndex; returns load index
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# 
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [1,3,0],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4red)])
+#
+# f0=mbs.CreateTorque(bodyNumber=b0, loadVector=[0,100,0])
+# 
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings() #takes currently set values or default values
+# simulationSettings.timeIntegration.numberOfSteps = 1000
+# simulationSettings.timeIntegration.endTime = 2
+# mbs.SolveDynamic(simulationSettings = simulationSettings)
+def MainSystemCreateTorque(mbs,
+                name = '',   
+                bodyNumber = None,
+                loadVector = [0.,0.,0.], 
+                localPosition = [0.,0.,0.], 
+                bodyFixed = False,
+                loadVectorUserFunction = 0,
+                show = True):
+
+    #error checks:        
+    if not exudyn.__useExudynFast:
+        where='MainSystem.CreateTorque(...)'
+        if not isinstance(name, str):
+            RaiseTypeError(where=where, argumentName='name', received = name, expectedType = ExpectedType.String)
+
+        if not IsValidObjectIndex(bodyNumber):
+            RaiseTypeError(where=where, argumentName='bodyNumber', received = bodyNumber, expectedType = ExpectedType.ObjectIndex)
+        if not IsVector(loadVector, 3):
+            RaiseTypeError(where=where, argumentName='loadVector', received = loadVector, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition, 3):
+            RaiseTypeError(where=where, argumentName='localPosition', received = localPosition, expectedType = ExpectedType.Vector, dim=3)
+    
+        if not IsValidRealInt(bodyFixed):
+            RaiseTypeError(where=where, argumentName='bodyFixed', received = bodyFixed, expectedType = ExpectedType.Bool)
+        # if not IsUserFunction(loadVectorUserFunction):
+        #     RaiseTypeError(where=where, argumentName='loadVectorUserFunction', received = loadVectorUserFunction, expectedType = ExpectedType.UserFunction)
+        if not IsValidBool(show):
+            RaiseTypeError(where=where, argumentName='show', received = show, expectedType = ExpectedType.Bool)
+    
+    
+    markerNumber = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=bodyNumber, localPosition=localPosition))
+    loadNumber = mbs.AddLoad(eii.LoadTorqueVector(markerNumber=markerNumber, 
+                                                  loadVector=loadVector,
+                                                  bodyFixed=bodyFixed,
+                                                  loadVectorUserFunction=loadVectorUserFunction))
+
+    return loadNumber
+
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+# exudyn.MainSystem.CreateMassPoint = MainSystemCreateMassPoint
+# exudyn.MainSystem.CreateSpringDamper = MainSystemCreateSpringDamper
+# exudyn.MainSystem.CreateRevoluteJoint = MainSystemCreateRevoluteJoint
+# exudyn.MainSystem.CreatePrismaticJoint = MainSystemCreatePrismaticJoint
+# exudyn.MainSystem.CreateGenericJoint = MainSystemCreateGenericJoint
+
+#missing:
+#RigidBodySpringDamper
+#LinearSpringDamper
+#TorsionalSpringDamper
+#2x rolling disc
+#CreateBeamsStraight[2D](...) #ANCF, GE with types?
+#CreateBeamsCurved[2D](...)   #ANCF, GE
+
+
+# #FUTURE:
+# #def InitializeFromRestartFile(mbs, simulationSettings, restartFileName, verbose=True):
+
+    
+# #needs some extensions; really needed?
+# # def AnimateModes(self, *args, **kwargs):
+# #     SC = self.GetSystemContainer()
+# #     return exudyn.interactive.AnimateModes(SC, self, *args, **kwargs)
+# #makes no sense, as it is a class:
+# # def InteractiveDialog(self, *args, **kwargs):
+# #     return exudyn.interactive.InteractiveDialog(self, *args, **kwargs)
+ 
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO AUTO 
+#NOTE that the following text is autogenerated, do not modify!
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.SolutionViewer=exu.interactive.SolutionViewer
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateGround=MainSystemCreateGround
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateMassPoint=MainSystemCreateMassPoint
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateRigidBody=MainSystemCreateRigidBody
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateSpringDamper=MainSystemCreateSpringDamper
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateCartesianSpringDamper=MainSystemCreateCartesianSpringDamper
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateRigidBodySpringDamper=MainSystemCreateRigidBodySpringDamper
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateRevoluteJoint=MainSystemCreateRevoluteJoint
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreatePrismaticJoint=MainSystemCreatePrismaticJoint
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateSphericalJoint=MainSystemCreateSphericalJoint
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateGenericJoint=MainSystemCreateGenericJoint
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateDistanceConstraint=MainSystemCreateDistanceConstraint
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateForce=MainSystemCreateForce
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateTorque=MainSystemCreateTorque
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.PlotSensor=exu.plot.PlotSensor
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.SolveStatic=exu.solver.SolveStatic
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.SolveDynamic=exu.solver.SolveDynamic
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.ComputeLinearizedSystem=exu.solver.ComputeLinearizedSystem
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.ComputeODE2Eigenvalues=exu.solver.ComputeODE2Eigenvalues
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.ComputeSystemDegreeOfFreedom=exu.solver.ComputeSystemDegreeOfFreedom
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateDistanceSensorGeometry=exu.utilities.CreateDistanceSensorGeometry
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.CreateDistanceSensor=exu.utilities.CreateDistanceSensor
+
+
+#link MainSystem function to Python function:
+exu.MainSystem.DrawSystemGraph=exu.utilities.DrawSystemGraph
+
```

## exudyn/mainSystemInterface.py

 * *Ordering differences only*

```diff
@@ -1,165 +1,165 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details: 	This module provides an extension interface to the C++ class MainSystem;
-#			MainSystem is extended by Python interface functions to easily create
-#           bodies and point masses without the need to create an according node and
-#           connectors and joints without the need to create markers.
-#
-# Author:   Johannes Gerstmayr
-# Date:     2023-05-07 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import exudyn as exu
-from exudyn.rigidBodyUtilities import GetRigidBodyNode
-import exudyn.itemInterface as eii 
-from exudyn.advancedUtilities import RaiseTypeError, IsVector, ExpectedType, IsValidObjectIndex, IsValidRealInt, IsValidPRealInt, IsValidURealInt,\
-                                    IsValidBool
-from exudyn.graphicsDataUtilities import color4default
-import numpy as np
-
-if not 'mainSystemInterface' in exu.sys:
-    raise ValueError('mainSystemInterface is only for testing; it requires to resolve the problem of type completion prior to full implementation')
-
-#steps to do:
-#naming: mbs.CreateMassPoint(...), mbs.CreateRevoluteJoint(...)
-#create autoGenerateMBScreators.py
-#==>dicts to define arguments, type, defaults, description
-#   automatically create checks
-#   add code section or autocode
-#   bodyNumber0=>index0
-
-#**function: add helpful Python extensions for MainSystem, regarding creation of bodies, point masses, connectors and joints
-def MainSystemAddPythonFunctions():
-    
-    #**function: helper function to create 2D or 3D mass point object and node
-    def MainSystemAddMassPoint(self,#node quantities
-                               referenceCoordinates = [0.,0.,0.],
-                               initialCoordinates = [0.,0.,0.],
-                               initialVelocities = [0.,0.,0.],
-                               #object quantities:
-                               physicsMass=0,
-                               gravity = [0.,0.,0.],
-                               graphicsDataList = [],
-                               #graphics, mixed
-                               drawSize = -1,
-                               color =  [-1.,-1.,-1.,-1.],
-                               show = True, #if graphicsDataList is empty, node is shown, otherwise body is shown
-                               name = '',   #both for node and object
-                               create2D = False, #NodePoint2D, MassPoint2D
-                               returnDict = False, #if True, returns dictionary of all data
-                               ):
-
-        mainSystem = self
-        #error checks:        
-        if not IsVector(referenceCoordinates, 3):
-            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='referenceCoordinates', received = referenceCoordinates, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(initialCoordinates, 3):
-            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='initialCoordinates', received = initialCoordinates, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(initialVelocities, 3):
-            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='initialVelocities', received = initialVelocities, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(gravity, 3):
-            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
-    
-        if type(graphicsDataList) != list:
-            raise ValueError('MainSystem.AddMassPoint(...): graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
-    
-        nodeNumber = mainSystem.AddNode(eii.NodePoint(name = name,
-                         referenceCoordinates = referenceCoordinates,
-                         initialCoordinates=initialCoordinates,
-                         initialVelocities=initialVelocities,
-                         visualization = eii.VNodePoint (show = show and (graphicsDataList == []), drawSize = drawSize, color = color),
-                         ))
-        objectNumber = mainSystem.AddObject(eii.MassPoint(name = name, 
-                                                physicsMass=physicsMass,
-                                                nodeNumber = nodeNumber,
-                                                visualization = eii.VMassPoint(show = graphicsDataList != [], 
-                                                                           graphicsData = graphicsDataList)
-                                                ))
-        if returnDict:
-            rDict = {'nodeNumber':nodeNumber, 'objectNumber': objectNumber}
-        
-        if list(gravity) != [0.,0.,0.]: #        if NormL2(gravity) != 0.:
-            markerNumber = mainSystem.AddMarker(eii.MarkerBodyMass(bodyNumber=objectNumber))
-            loadNumber = mainSystem.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
-            if returnDict:
-                rDict['markerBodyMass'] = markerNumber
-                rDict['loadNumber'] = loadNumber
-
-        if returnDict:
-            return rDict
-        else:
-            return objectNumber
-
-    def MainSystemAddSpringDamper(self,
-                                  bodyNumber0, bodyNumber1, 
-                                  localPosition0 = [0.,0.,0.],
-                                  localPosition1 = [0.,0.,0.],
-                                  referenceLength = None, 
-                                  stiffness = 0., damping = 0., force = 0.,
-                                  velocityOffset = 0., 
-                                  show=True, drawSize=-1, color=color4default,
-                                  ):
-        mainSystem = self
-        #perform some checks:
-        if not IsValidObjectIndex(bodyNumber0):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='bodyNumber0', received = bodyNumber0, expectedType = ExpectedType.ObjectIndex)
-        if not IsValidObjectIndex(bodyNumber1):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='bodyNumber1', received = bodyNumber1, expectedType = ExpectedType.ObjectIndex)
-
-        if not IsVector(localPosition0, 3):
-            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
-        if not IsVector(localPosition1, 3):
-            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
-
-        if referenceLength != None and not IsValidPRealInt(referenceLength):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='referenceLength', received = referenceLength, expectedType = ExpectedType.PReal)
-        if not IsValidRealInt(stiffness):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(damping):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='damping', received = damping, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(force):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='force', received = force, expectedType = ExpectedType.Real)
-        if not IsValidRealInt(velocityOffset):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='velocityOffset', received = velocityOffset, expectedType = ExpectedType.Real)
-
-        if not IsValidBool(show):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='show', received = show, expectedType = ExpectedType.Bool)
-        if not IsValidRealInt(drawSize):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
-
-        if not IsVector(color, 4):
-            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
-            
-        mBody0 = mainSystem.AddMarker(eii.MarkerBodyPosition(bodyNumber=bodyNumber0, localPosition=localPosition0))
-        mBody1 = mainSystem.AddMarker(eii.MarkerBodyPosition(bodyNumber=bodyNumber1, localPosition=localPosition1))
-
-        if referenceLength == None: #automatically compute reference length
-            p0 = mainSystem.GetObjectOutputBody(bodyNumber0,exu.OutputVariableType.Position,
-                                         localPosition=localPosition0, configuration=exu.ConfigurationType.Reference)
-            p1 = mainSystem.GetObjectOutputBody(bodyNumber1,exu.OutputVariableType.Position,
-                                         localPosition=localPosition1, configuration=exu.ConfigurationType.Reference)
-            referenceLength = np.linalg.norm(np.array(p1)-p0)
-        
-        oConnector = mainSystem.AddObject(eii.ObjectConnectorSpringDamper(markerNumbers = [mBody0,mBody1],
-                                                                          referenceLength = referenceLength,
-                                                                          stiffness = stiffness,
-                                                                          damping = damping,
-                                                                          force = force,
-                                                                          velocityOffset = velocityOffset,
-                                                                          visualization=eii.VSpringDamper(show=show, drawSize=drawSize,
-                                                                                                          color=color)
-                                                                          ))
-
-        return oConnector
-
-
-    exu.MainSystem.AddMassPoint = MainSystemAddMassPoint
-    exu.MainSystem.AddSpringDamper = MainSystemAddSpringDamper
-
-
-MainSystemAddPythonFunctions()
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details: 	This module provides an extension interface to the C++ class MainSystem;
+#			MainSystem is extended by Python interface functions to easily create
+#           bodies and point masses without the need to create an according node and
+#           connectors and joints without the need to create markers.
+#
+# Author:   Johannes Gerstmayr
+# Date:     2023-05-07 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import exudyn as exu
+from exudyn.rigidBodyUtilities import GetRigidBodyNode
+import exudyn.itemInterface as eii 
+from exudyn.advancedUtilities import RaiseTypeError, IsVector, ExpectedType, IsValidObjectIndex, IsValidRealInt, IsValidPRealInt, IsValidURealInt,\
+                                    IsValidBool
+from exudyn.graphicsDataUtilities import color4default
+import numpy as np
+
+if not 'mainSystemInterface' in exu.sys:
+    raise ValueError('mainSystemInterface is only for testing; it requires to resolve the problem of type completion prior to full implementation')
+
+#steps to do:
+#naming: mbs.CreateMassPoint(...), mbs.CreateRevoluteJoint(...)
+#create autoGenerateMBScreators.py
+#==>dicts to define arguments, type, defaults, description
+#   automatically create checks
+#   add code section or autocode
+#   bodyNumber0=>index0
+
+#**function: add helpful Python extensions for MainSystem, regarding creation of bodies, point masses, connectors and joints
+def MainSystemAddPythonFunctions():
+    
+    #**function: helper function to create 2D or 3D mass point object and node
+    def MainSystemAddMassPoint(self,#node quantities
+                               referenceCoordinates = [0.,0.,0.],
+                               initialCoordinates = [0.,0.,0.],
+                               initialVelocities = [0.,0.,0.],
+                               #object quantities:
+                               physicsMass=0,
+                               gravity = [0.,0.,0.],
+                               graphicsDataList = [],
+                               #graphics, mixed
+                               drawSize = -1,
+                               color =  [-1.,-1.,-1.,-1.],
+                               show = True, #if graphicsDataList is empty, node is shown, otherwise body is shown
+                               name = '',   #both for node and object
+                               create2D = False, #NodePoint2D, MassPoint2D
+                               returnDict = False, #if True, returns dictionary of all data
+                               ):
+
+        mainSystem = self
+        #error checks:        
+        if not IsVector(referenceCoordinates, 3):
+            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='referenceCoordinates', received = referenceCoordinates, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(initialCoordinates, 3):
+            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='initialCoordinates', received = initialCoordinates, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(initialVelocities, 3):
+            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='initialVelocities', received = initialVelocities, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(gravity, 3):
+            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
+    
+        if type(graphicsDataList) != list:
+            raise ValueError('MainSystem.AddMassPoint(...): graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
+    
+        nodeNumber = mainSystem.AddNode(eii.NodePoint(name = name,
+                         referenceCoordinates = referenceCoordinates,
+                         initialCoordinates=initialCoordinates,
+                         initialVelocities=initialVelocities,
+                         visualization = eii.VNodePoint (show = show and (graphicsDataList == []), drawSize = drawSize, color = color),
+                         ))
+        objectNumber = mainSystem.AddObject(eii.MassPoint(name = name, 
+                                                physicsMass=physicsMass,
+                                                nodeNumber = nodeNumber,
+                                                visualization = eii.VMassPoint(show = graphicsDataList != [], 
+                                                                           graphicsData = graphicsDataList)
+                                                ))
+        if returnDict:
+            rDict = {'nodeNumber':nodeNumber, 'objectNumber': objectNumber}
+        
+        if list(gravity) != [0.,0.,0.]: #        if NormL2(gravity) != 0.:
+            markerNumber = mainSystem.AddMarker(eii.MarkerBodyMass(bodyNumber=objectNumber))
+            loadNumber = mainSystem.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
+            if returnDict:
+                rDict['markerBodyMass'] = markerNumber
+                rDict['loadNumber'] = loadNumber
+
+        if returnDict:
+            return rDict
+        else:
+            return objectNumber
+
+    def MainSystemAddSpringDamper(self,
+                                  bodyNumber0, bodyNumber1, 
+                                  localPosition0 = [0.,0.,0.],
+                                  localPosition1 = [0.,0.,0.],
+                                  referenceLength = None, 
+                                  stiffness = 0., damping = 0., force = 0.,
+                                  velocityOffset = 0., 
+                                  show=True, drawSize=-1, color=color4default,
+                                  ):
+        mainSystem = self
+        #perform some checks:
+        if not IsValidObjectIndex(bodyNumber0):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='bodyNumber0', received = bodyNumber0, expectedType = ExpectedType.ObjectIndex)
+        if not IsValidObjectIndex(bodyNumber1):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='bodyNumber1', received = bodyNumber1, expectedType = ExpectedType.ObjectIndex)
+
+        if not IsVector(localPosition0, 3):
+            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='localPosition0', received = localPosition0, expectedType = ExpectedType.Vector, dim=3)
+        if not IsVector(localPosition1, 3):
+            RaiseTypeError(where='MainSystem.AddMassPoint(...)', argumentName='localPosition1', received = localPosition1, expectedType = ExpectedType.Vector, dim=3)
+
+        if referenceLength != None and not IsValidPRealInt(referenceLength):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='referenceLength', received = referenceLength, expectedType = ExpectedType.PReal)
+        if not IsValidRealInt(stiffness):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='stiffness', received = stiffness, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(damping):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='damping', received = damping, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(force):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='force', received = force, expectedType = ExpectedType.Real)
+        if not IsValidRealInt(velocityOffset):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='velocityOffset', received = velocityOffset, expectedType = ExpectedType.Real)
+
+        if not IsValidBool(show):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='show', received = show, expectedType = ExpectedType.Bool)
+        if not IsValidRealInt(drawSize):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='drawSize', received = drawSize, expectedType = ExpectedType.Real)
+
+        if not IsVector(color, 4):
+            RaiseTypeError(where='MainSystem.AddSpringDamper(...)', argumentName='color', received = color, expectedType = ExpectedType.Vector, dim=4)
+            
+        mBody0 = mainSystem.AddMarker(eii.MarkerBodyPosition(bodyNumber=bodyNumber0, localPosition=localPosition0))
+        mBody1 = mainSystem.AddMarker(eii.MarkerBodyPosition(bodyNumber=bodyNumber1, localPosition=localPosition1))
+
+        if referenceLength == None: #automatically compute reference length
+            p0 = mainSystem.GetObjectOutputBody(bodyNumber0,exu.OutputVariableType.Position,
+                                         localPosition=localPosition0, configuration=exu.ConfigurationType.Reference)
+            p1 = mainSystem.GetObjectOutputBody(bodyNumber1,exu.OutputVariableType.Position,
+                                         localPosition=localPosition1, configuration=exu.ConfigurationType.Reference)
+            referenceLength = np.linalg.norm(np.array(p1)-p0)
+        
+        oConnector = mainSystem.AddObject(eii.ObjectConnectorSpringDamper(markerNumbers = [mBody0,mBody1],
+                                                                          referenceLength = referenceLength,
+                                                                          stiffness = stiffness,
+                                                                          damping = damping,
+                                                                          force = force,
+                                                                          velocityOffset = velocityOffset,
+                                                                          visualization=eii.VSpringDamper(show=show, drawSize=drawSize,
+                                                                                                          color=color)
+                                                                          ))
+
+        return oConnector
+
+
+    exu.MainSystem.AddMassPoint = MainSystemAddMassPoint
+    exu.MainSystem.AddSpringDamper = MainSystemAddSpringDamper
+
+
+MainSystemAddPythonFunctions()
+
```

## exudyn/physics.py

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  The physics library includes helper functions and data related to physics 
-#           models and parameters; for rigid body inertia, see rigidBodyUtilities
-#
-# Authors:  Johannes Gerstmayr
-# Date:     2021-01-20
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#import numpy as np
-import numpy as np
-from math import exp
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: describes regularized Stribeck function with optial viscous part for given velocity,
-#  $f(v) = \begin{cases} (\mu_d + \mu_{s_{off}}) v, \quad \mathrm{if} \quad |v| <= v_{reg}\\ \mathrm{Sign}(v)\left( \mu_d + \mu_{s_{off}} \mathrm{e}^{-(|v|-v_{reg})/v_{exp}} + \mu_v (|v|-v_{reg}) \right), \quad \mathrm{else}\end{cases}$
-#**input:
-#  vel: input velocity $v$
-#  muDynamic: dynamic friction coefficient $\mu_d$
-#  muStaticOffset: $\mu_{s_{off}}$, offset to dynamic friction, which gives muStaticFriction = muDynamic + muStaticOffset
-#  muViscous: $\mu_v$, viscous part, acting proportional to velocity except for regVel
-#  regVel: $v_{reg}$,  small regularization velocity in which the friction is linear around zero velocity (e.g., to get Newton converged)
-#  expVel: $v_{exp}$,  velocity (relative to regVel, at which the muStaticOffset decreases exponentially, at vel=expVel, the factor to muStaticOffset is exp(-1) = 36.8\%)
-#**output: returns velocity dependent friction coefficient (if muDynamic and muStaticOffset are friction coefficients) or friction force (if muDynamic and muStaticOffset are on force level)
-#**notes: see Isermann (2008) and Armstrong-Helouvry (1991)
-def StribeckFunction(vel, muDynamic, muStaticOffset, muViscous=0, expVel=1e-3, regVel=1e-3):
-    if abs(vel) <= regVel and regVel != 0:
-        return (muDynamic + muStaticOffset)*vel/regVel
-    else:
-        s = np.sign(vel)
-        v = abs(vel)-regVel
-        return s*(muDynamic + muStaticOffset*exp(-v/expVel) + muViscous*v)
-
-#**function: helper function for RegularizedFriction(...)
-def RegularizedFrictionStep(x,x0,h0,x1,h1):
-    if x <= x0:
-        return h0
-    elif x < x1:
-        delta = (x-x0)/(x1-x0)
-        return h0 + (h1-h0)*delta**2*(3-2*delta)
-    else:
-        return h1
-
-#regularized friction model:
-#**function: describes regularized friction function, with increased static friction, dynamic friction and optional viscous part
-#**input:
-#  vel: input velocity
-#  muDynamic: dynamic friction coefficient
-#  muStaticOffset: offset to dynamic friction, which gives muStaticFriction = muDynamic + muStaticOffset
-#  muViscous: viscous part, acting proportional to velocity for velocities larger than velDynamic; extension to mentioned references
-#  velStatic: small regularization velocity at which exactly the staticFriction is reached; for smaller velocities, the friction is smooth and zero-crossing (unphysical!) (e.g., to get Newton converged)
-#  velDynamic: velocity at which muDynamic is reached for first time
-#**output: returns velocity dependent friction coefficient (if muDynamic and muStaticOffset are friction coefficients) or friction force (if muDynamic and muStaticOffset are on force level)
-#**notes:
-#  see references: Flores et al. \cite{Flores2008}, Qian et al. \cite{Qian2018}
-def RegularizedFriction(vel, muDynamic, muStaticOffset, velStatic, velDynamic, muViscous=0):
-    vs = velStatic
-    vd = velDynamic
-    mud = muDynamic
-    mus = muDynamic + muStaticOffset
-    if abs(vel) > vd:
-        return np.sign(vel)*(muDynamic + (abs(vel)-velDynamic)*muViscous)
-    elif vs <= abs(vel) and abs(vel) <= vd:
-        return np.sign(vel)*RegularizedFrictionStep(abs(vel), vs, mus, vd, mud) #error in paper of Qian, Zhang and Jin: vs, mus sitched with vd, mud
-    else:
-        return RegularizedFrictionStep(vel, -vs, -mus, vs, mus)
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute equivalent von-Mises stress given 6 stress components or list of stress6D (or stress6D in rows of np.array)
-#**input:
-#  stress6D: 6 stress components as list or np.array, using ordering $[\sigma_{xx}$, $\sigma_{yy}$, $\sigma_{zz}$, $\sigma_{yz}$, $\sigma_{xz}$, $\sigma_{xy}]$
-#**output: returns scalar equivalent von-Mises stress or np.array of von-Mises stresses for all stress6D
-def VonMisesStress(stress6D):
-    s = np.array(stress6D)
-    if s.ndim == 1:
-        return np.sqrt(0.5*((s[0]-s[1])**2 + 
-                         (s[1]-s[2])**2 + 
-                         (s[2]-s[0])**2 + 
-                         6*(s[3]**2+s[4]**2+s[5]**2 )))
-    else: #numpy sqrt does the job:
-        return np.sqrt(0.5*((s[:,0]-s[:,1])**2 + 
-                         (s[:,1]-s[:,2])**2 + 
-                         (s[:,2]-s[:,0])**2 + 
-                         6*(s[:,3]**2+s[:,4]**2+s[:,5]**2 )))
-        
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Sensor user function to compute equivalent von-Mises stress from sensor with Stress or StressLocal OutputVariableType; if more than 1 sensor is given in sensorNumbers, then the maximum stress is computed
-#**input: arguments according to \texttt{SensorUserFunction}; factors are ignored
-#**output: returns scalar (maximum) equivalent von-Mises stress
-#**example:
-##assuming s0, s1, s2 being sensor numbers with StressLocal components
-#sUser = mbs.AddSensor(SensorUserFunction(sensorNumbers=[s0,s1,s2], 
-#                                         fileName='solution/sensorMisesStress.txt',
-#                                         sensorUserFunction=UFvonMisesStress))
-def UFvonMisesStress(mbs, t, sensorNumbers, factors, configuration):
-    maxStress = 0
-    for sensor in sensorNumbers:
-        maxStress = max(maxStress,
-                        mbs.GetSensorValues(sensor, configuration))
-    return [maxStress]
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  The physics library includes helper functions and data related to physics 
+#           models and parameters; for rigid body inertia, see rigidBodyUtilities
+#
+# Authors:  Johannes Gerstmayr
+# Date:     2021-01-20
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#import numpy as np
+import numpy as np
+from math import exp
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: describes regularized Stribeck function with optial viscous part for given velocity,
+#  $f(v) = \begin{cases} (\mu_d + \mu_{s_{off}}) v, \quad \mathrm{if} \quad |v| <= v_{reg}\\ \mathrm{Sign}(v)\left( \mu_d + \mu_{s_{off}} \mathrm{e}^{-(|v|-v_{reg})/v_{exp}} + \mu_v (|v|-v_{reg}) \right), \quad \mathrm{else}\end{cases}$
+#**input:
+#  vel: input velocity $v$
+#  muDynamic: dynamic friction coefficient $\mu_d$
+#  muStaticOffset: $\mu_{s_{off}}$, offset to dynamic friction, which gives muStaticFriction = muDynamic + muStaticOffset
+#  muViscous: $\mu_v$, viscous part, acting proportional to velocity except for regVel
+#  regVel: $v_{reg}$,  small regularization velocity in which the friction is linear around zero velocity (e.g., to get Newton converged)
+#  expVel: $v_{exp}$,  velocity (relative to regVel, at which the muStaticOffset decreases exponentially, at vel=expVel, the factor to muStaticOffset is exp(-1) = 36.8\%)
+#**output: returns velocity dependent friction coefficient (if muDynamic and muStaticOffset are friction coefficients) or friction force (if muDynamic and muStaticOffset are on force level)
+#**notes: see Isermann (2008) and Armstrong-Helouvry (1991)
+def StribeckFunction(vel, muDynamic, muStaticOffset, muViscous=0, expVel=1e-3, regVel=1e-3):
+    if abs(vel) <= regVel and regVel != 0:
+        return (muDynamic + muStaticOffset)*vel/regVel
+    else:
+        s = np.sign(vel)
+        v = abs(vel)-regVel
+        return s*(muDynamic + muStaticOffset*exp(-v/expVel) + muViscous*v)
+
+#**function: helper function for RegularizedFriction(...)
+def RegularizedFrictionStep(x,x0,h0,x1,h1):
+    if x <= x0:
+        return h0
+    elif x < x1:
+        delta = (x-x0)/(x1-x0)
+        return h0 + (h1-h0)*delta**2*(3-2*delta)
+    else:
+        return h1
+
+#regularized friction model:
+#**function: describes regularized friction function, with increased static friction, dynamic friction and optional viscous part
+#**input:
+#  vel: input velocity
+#  muDynamic: dynamic friction coefficient
+#  muStaticOffset: offset to dynamic friction, which gives muStaticFriction = muDynamic + muStaticOffset
+#  muViscous: viscous part, acting proportional to velocity for velocities larger than velDynamic; extension to mentioned references
+#  velStatic: small regularization velocity at which exactly the staticFriction is reached; for smaller velocities, the friction is smooth and zero-crossing (unphysical!) (e.g., to get Newton converged)
+#  velDynamic: velocity at which muDynamic is reached for first time
+#**output: returns velocity dependent friction coefficient (if muDynamic and muStaticOffset are friction coefficients) or friction force (if muDynamic and muStaticOffset are on force level)
+#**notes:
+#  see references: Flores et al. \cite{Flores2008}, Qian et al. \cite{Qian2018}
+def RegularizedFriction(vel, muDynamic, muStaticOffset, velStatic, velDynamic, muViscous=0):
+    vs = velStatic
+    vd = velDynamic
+    mud = muDynamic
+    mus = muDynamic + muStaticOffset
+    if abs(vel) > vd:
+        return np.sign(vel)*(muDynamic + (abs(vel)-velDynamic)*muViscous)
+    elif vs <= abs(vel) and abs(vel) <= vd:
+        return np.sign(vel)*RegularizedFrictionStep(abs(vel), vs, mus, vd, mud) #error in paper of Qian, Zhang and Jin: vs, mus sitched with vd, mud
+    else:
+        return RegularizedFrictionStep(vel, -vs, -mus, vs, mus)
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute equivalent von-Mises stress given 6 stress components or list of stress6D (or stress6D in rows of np.array)
+#**input:
+#  stress6D: 6 stress components as list or np.array, using ordering $[\sigma_{xx}$, $\sigma_{yy}$, $\sigma_{zz}$, $\sigma_{yz}$, $\sigma_{xz}$, $\sigma_{xy}]$
+#**output: returns scalar equivalent von-Mises stress or np.array of von-Mises stresses for all stress6D
+def VonMisesStress(stress6D):
+    s = np.array(stress6D)
+    if s.ndim == 1:
+        return np.sqrt(0.5*((s[0]-s[1])**2 + 
+                         (s[1]-s[2])**2 + 
+                         (s[2]-s[0])**2 + 
+                         6*(s[3]**2+s[4]**2+s[5]**2 )))
+    else: #numpy sqrt does the job:
+        return np.sqrt(0.5*((s[:,0]-s[:,1])**2 + 
+                         (s[:,1]-s[:,2])**2 + 
+                         (s[:,2]-s[:,0])**2 + 
+                         6*(s[:,3]**2+s[:,4]**2+s[:,5]**2 )))
+        
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Sensor user function to compute equivalent von-Mises stress from sensor with Stress or StressLocal OutputVariableType; if more than 1 sensor is given in sensorNumbers, then the maximum stress is computed
+#**input: arguments according to \texttt{SensorUserFunction}; factors are ignored
+#**output: returns scalar (maximum) equivalent von-Mises stress
+#**example:
+##assuming s0, s1, s2 being sensor numbers with StressLocal components
+#sUser = mbs.AddSensor(SensorUserFunction(sensorNumbers=[s0,s1,s2], 
+#                                         fileName='solution/sensorMisesStress.txt',
+#                                         sensorUserFunction=UFvonMisesStress))
+def UFvonMisesStress(mbs, t, sensorNumbers, factors, configuration):
+    maxStress = 0
+    for sensor in sensorNumbers:
+        maxStress = max(maxStress,
+                        mbs.GetSensorValues(sensor, configuration))
+    return [maxStress]
+
+
+
```

## exudyn/plot.py

 * *Ordering differences only*

```diff
@@ -1,1014 +1,1014 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Plot utility functions based on matplotlib, including plotting of sensors and FFT.
-#
-# Author:   Johannes Gerstmayr
-# Date:     2020-09-16 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-# Notes:    For a list of plot colors useful for matplotlib, see also advancedUtilities.PlotLineCode(...)
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-import numpy as np #for loading
-import exudyn #for sensor index
-from exudyn.advancedUtilities import PlotLineCode, IsListOrArray
-import copy
-import os
-
-#++++++++++++++++++++++++++++++++
-#this structure helps to define default values, that are then always used!
-class __PlotSensorDefaults:
-    def __init__(self):
-        pass
-    def __repr__(self):
-        return str(self.__dict__) #not very nice, but helps to easily see contents
-    
-__plotSensorDefaults = __PlotSensorDefaults() #initialize structure
-
-#here we define the modifyable default values (only change with PlotSensorDefaults() function!)
-__plotSensorDefaults.xLabel='time (s)'
-__plotSensorDefaults.yLabel=None
-__plotSensorDefaults.fontSize = 16
-
-__plotSensorDefaults.colors=[]
-__plotSensorDefaults.lineStyles=[]
-__plotSensorDefaults.lineWidths=[]
-__plotSensorDefaults.markerStyles=[]
-__plotSensorDefaults.markerSizes=[]
-__plotSensorDefaults.markerDensity=0.08
-
-__plotSensorDefaults.majorTicksX = 10
-__plotSensorDefaults.majorTicksY = 10
-__plotSensorDefaults.sizeInches=[6.4,4.8]
-
-#practical list of marker styles to be used as list:
-listMarkerStyles = ['x ', '+ ', '* ', '. ', 'd ', 'D ', 's ', 'X ', 'P ', 'v ', '^ ', '< ', '> ', 'o ', 'p ', 'h ', 'H ']
-listMarkerStylesFilled = ['x','+','*','.','d','D','s','X','P','v','^','<','>','o','p','h','H']
-
-#this is the value for a component which indicates to show the norm (e.g. of a vector) instead of the component
-componentNorm = -2 #
-
-#**function: parse header of output file (solution file, sensor file, genetic optimization output, ...) given in file.readlines() format
-#**output: return dictionary with 'type'=['sensor','solution','geneticOptimization','parameterVariation'], 'variableType' containing variable types, 'variableRanges' containing ranges for parameter variation 
-def ParseOutputFileHeader(lines):
-    nLines = len(lines)
-    parseLines = min(10, nLines) #max 10 lines to parse
-    output = {}
-    output['type'] = 'unknown'
-    #columns = []
-    if len(lines) < 1:
-        return {} #empty dictionary
-    variableTypes = []
-    variableRanges = [] #only for parameter variation
-    if lines[0].find('EXUDYN genetic optimization results file') != -1:
-        output['type'] = 'geneticOptimization'
-        for i in range(parseLines): #header is max. 10 lines
-            if i+1 < len(lines) and lines[i][0:9] == '#columns:':
-                cols = lines[i+1].strip('#').split(',')
-                for j in range(len(cols)):
-                    variableTypes += [cols[j].strip()]
-                break
-    if lines[0].find('EXUDYN parameter variation results file') != -1:
-        output['type'] = 'parameterVariation'
-        for i in range(parseLines): #header is max. 10 lines
-            if i+1 < len(lines) and lines[i][0:9] == '#columns:':
-                cols = lines[i+1].strip('#').split(',')
-                for j in range(len(cols)):
-                    variableTypes += [cols[j].strip()]
-                break
-        for i in range(parseLines): #header is max. 10 lines
-            if i+1 < len(lines) and lines[i][0:17] == '#parameter ranges':
-                ranges = lines[i+1].strip('#').strip('\n').split(';') #this gives e.g. ['(0.1, 5, 4)', '(2,4.5,2)']
-                # print('ranges=', ranges)
-                for j in range(len(ranges)):
-                    oneRange = ranges[j].strip('(').strip(')').split(',')
-                    # print('one range=', oneRange)
-                    variableRanges += [[float(oneRange[0]),float(oneRange[1]),int(oneRange[2])]]
-                break
-    elif lines[0].find('sensor output file') != -1:
-        #print("SENSOR")
-        output['type'] = 'sensor'
-        outputVariableType = ''
-        for i in range(parseLines): #header is max. 10 lines
-            if lines[i].find('Object number') != -1:
-                output['objectNumber'] = int(lines[i].split('=')[1])
-            elif lines[i].find('OutputVariableType') != -1:
-                outputVariableType = lines[i].split('=')[1].strip() #without spaces
-                output['outputVariableType'] = outputVariableType #for PlotSensor
-            elif lines[i].find('number of sensor values') != -1:
-                output['numberOfSensors'] = int(lines[i].split('=')[1]) 
-
-            if lines[i].find('#measure') != -1:
-                if ' ' in lines[i]:
-                    output['sensorType'] = lines[i].split(' ')[1] #for PlotSensor
-                else:
-                    output['sensorType'] = '' #no specific sensor type
-                if '=' in lines[i]:
-                    output['itemNumber'] = int(lines[i].split('=')[1]) #unused
-                else:
-                    output['itemNumber'] = -1 #invalid
-                
-            if lines[i][0] != '#': #break after comment
-                break
-        variableTypes = ['time']
-        for i in range(output['numberOfSensors']):
-            variableTypes += [outputVariableType+str(i)] #e.g., Position0, Position1, ...
-    elif lines[0].find('solution file') != -1: #coordinates solution file
-        output['type'] = 'solution'
-        writtenCoordinateTypes = []
-        writtenCoordinates = []
-        for i in range(parseLines): #header is max. 10 lines
-            if lines[i].find('number of written coordinates') != -1:
-                line = lines[i]
-                writtenCoordinateTypes = line.split('=')[0].split('[')[1].split(']')[0].replace(' ','').split(',')
-                writtenCoordinates = line.split('=')[1].split('[')[1].split(']')[0].replace(' ','').split(',')
-                variableTypes = ['time']
-                #print('writtenCoordinates=',writtenCoordinates)
-                for j in range(len(writtenCoordinateTypes)):
-                    for k in range(int(writtenCoordinates[j])):
-                       variableTypes += [writtenCoordinateTypes[j].strip('n')+'-'+str(k)]
-                #variableTypes += [writtenCoordinateTypes[j]]*int(writtenCoordinates[j])
-            elif lines[i].find('number of time steps') != -1:
-                output['numberOfSteps'] = int(lines[i].split('=')[1])
-
-            if lines[i][0] != '#': #break after comment
-                break
-
-    output['columns'] = variableTypes
-    output['variableRanges'] = variableRanges
-    
-    return output
-
-#**function: returns structure with default values for PlotSensor which can be modified once to be set for all later calls of PlotSensor
-#**example: 
-##change one parameter:
-#plot.PlotSensorDefaults().fontSize = 12
-##==>now PlotSensor(...) will use fontSize=12
-##==>now PlotSensor(..., fontSize=10) will use fontSize=10
-##==>BUT PlotSensor(..., fontSize=16) will use fontSize=12, BECAUSE 16 is the original default value!!!
-##see which parameters are available:
-#print(PlotSensorDefaults())
-def PlotSensorDefaults():
-    return __plotSensorDefaults #for definition see at top of this file
-   
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Helper function for direct and easy visualization of sensor outputs, without need for loading text files, etc.; PlotSensor can be used to simply plot, e.g., the measured x-Position over time in a figure. PlotSensor provides an interface to matplotlib (which needs to be installed). Default values of many function arguments can be changed using the exudyn.plot function PlotSensorDefaults(), see there for usage.
-#**input: 
-#  mbs: must be a valid MainSystem (mbs)
-#  sensorNumbers: consists of one or a list of sensor numbers (type SensorIndex or int) as returned by the mbs function AddSensor(...); sensors need to set writeToFile=True and/or storeInternal=True for PlotSensor to work; alternatively, it may contain FILENAMES (incl. path) to stored sensor or solution files OR a numpy array instead of sensor numbers; the format of data (file or numpy array) must contain per row the time and according solution values in columns; if components is a list and sensorNumbers is a scalar, sensorNumbers is adjusted automatically to the components
-#  components: consists of one or a list of components according to the component of the sensor to be plotted at y-axis; if components is a list and sensorNumbers is a scalar, sensorNumbers is adjusted automatically to the components; as always, components are zero-based, meaning 0=X, 1=Y, etc.; for regular sensor files, time will be component=-1; to show the norm (e.g., of a force vector), use component=[plot.componentNorm] for according sensors; norm will consider all values of sensor except time (for 3D force, it will be $\sqrt{f_0^2+f_1^2+f_2^2}$); offsets and factors are mapped on norm (plot value=factor*(norm(values) + offset) ), not on component values
-#  componentsX: default componentsX=[] uses time in files; otherwise provide componentsX as list of components (or scalar) representing x components of sensors in plotted curves; DON'T forget to change xLabel accordingly! 
-#    Using componentsX=[...] with a list of column indices specifies the respective columns used for the x-coordinates in all sensors; by default, values are plotted against the first column in the files, which is time; according to counting in PlotSensor, this represents componentX=-1; 
-#    plotting y over x in a position sensor thus reads: components=[1], componentsX=[0]; 
-#    plotting time over x reads: components=[-1], componentsX=[0]; 
-#    the default value reads componentsX=[-1,-1,...]
-#  xLabel: string for text at x-axis
-#  yLabel: string for text at y-axis (default: None==> label is automatically computed from sensor value types)
-#  labels: string (for one sensor) or list of strings (according to number of sensors resp. components) representing the labels used in legend; if labels=[], automatically generated legend is used
-#  rangeX: default rangeX=[]: computes range automatically; otherwise use rangeX to set range (limits) for x-axis provided as sorted list of two floats, e.g., rangeX=[0,4]
-#  rangeY: default rangeY=[]: computes range automatically; otherwise use rangeY to set range (limits) for y-axis provided as sorted list of two floats, e.g., rangeY=[-1,1]
-#  figureName: optional name for figure, if newFigure=True
-#  fontSize: change general fontsize of axis, labels, etc. (matplotlib default is 12, default in PlotSensor: 16)
-#  title: optional string representing plot title 
-#  offsets: provide as scalar, list of scalars (per sensor) or list of 2D numpy.arrays (per sensor, having same rows/columns as sensor data; in this case it will also influence x-axis if componentsX is different from -1) to add offset to each sensor output; for an original value fOrig, the new value reads fNew = factor*(fOrig+offset); for offset provided as numpy array (with same time values), the 'time' column is ignored in the offset computation; can be used to compute difference of sensors; if offsets=[], no offset is used
-#  factors: provide as scalar or list (per sensor) to add factor to each sensor output; for an original value fOrig, the new value reads fNew = factor*(fOrig+offset); if factor=[], no factor is used
-#  majorTicksX: number of major ticks on x-axis; default: 10
-#  majorTicksY: number of major ticks on y-axis; default: 10
-#  colorCodeOffset: int offset for color code, color codes going from 0 to 27 (see PlotLineCode(...)); automatic line/color codes are used if no colors and lineStyles are used
-#  colors: color is automatically selected from colorCodeOffset if colors=[]; otherwise chose from 'b', 'g', 'r', 'c', 'm', 'y', 'k' and many other colors see https://matplotlib.org/stable/gallery/color/named\_colors.html
-#  lineStyles: line style is automatically selected from colorCodeOffset if lineStyles=[]; otherwise define for all lines with string or with list of strings, chosing from '-', '--', '-.', ':', or '' 
-#  lineWidths: float to define line width by float (default=1); either use single float for all sensors or list of floats with length >= number of sensors
-#  markerStyles: if different from [], marker styles are defined as list of marker style strings or single string for one sensor; chose from '.', 'o', 'x', '+' ... check listMarkerStylesFilled and listMarkerStyles in exudyn.plot and see https://matplotlib.org/stable/api/markers\_api.html ; ADD a space to markers to make them empty (transparent), e.g. 'o ' will create an empty circle 
-#  markerSizes: float to define marker size by float (default=6); either use single float for all sensors or list of floats with length >= number of sensors 
-#  markerDensity: if int, it defines approx. the total number of markers used along each graph; if float, this defines the distance of markers relative to the diagonal of the plot (default=0.08); if None, it adds a marker to every data point if marker style is specified for sensor
-#  newFigure: if True, a new matplotlib.pyplot figure is created; otherwise, existing figures are overwritten
-#  subPlot: given as list [nx, ny, position] with nx, ny being the number of subplots in x and y direction (nx=cols, ny=rows), and position in [1,..., nx*ny] gives the position in the subplots; use the same structure for first PlotSensor (with newFigure=True) and all subsequent PlotSensor calls with newFigure=False, which creates the according subplots; default=[](no subplots) 
-#  sizeInches: given as list [sizeX, sizeY] with the sizes per (sub)plot given in inches; default: [6.4, 4.8]; in case of sub plots, the total size of the figure is computed from nx*sizeInches[0] and ny*sizeInches[1]
-#  fileName: if this string is non-empty, figure will be saved to given path and filename (use figName.pdf to safe as PDF or figName.png to save as PNG image); use matplotlib.use('Agg') in order not to open figures if you just want to save them
-#  useXYZcomponents: of True, it will use X, Y and Z for sensor components, e.g., measuring Position, Velocity, etc. wherever possible
-#  closeAll: if True, close all figures before opening new one (do this only in first PlotSensor command!)
-#  [*kwargs]:
-#        minorTicksXon: if True, turn minor ticks for x-axis on
-#        minorTicksYon: if True, turn minor ticks for y-axis on
-#        logScaleX: use log scale for x-axis
-#        logScaleY: use log scale for y-axis
-#        fileCommentChar: if exists, defines the comment character in files (\#, %, ...)
-#        fileDelimiterChar: if exists, defines the character indicating the columns for data (',', ' ', ';', ...)
-#**output: [Any, Any, Any, Any]; plots the sensor data; returns [plt, fig, ax, line] in which plt is matplotlib.pyplot, fig is the figure (or None), ax is the axis (or None) and line is the return value of plt.plot (or None) which could be changed hereafter
-#**notes: adjust default values by modifying the variables exudyn.plot.plotSensorDefault..., e.g., exudyn.plot.plotSensorDefaultFontSize
-#**belongsTo: MainSystem
-#**example: 
-##assume to have some position-based nodes 0 and 1:
-#s0=mbs.AddSensor(SensorNode(nodeNumber=0, fileName='s0.txt',
-#                            outputVariableType=exu.OutputVariableType.Position))
-#s1=mbs.AddSensor(SensorNode(nodeNumber=1, fileName='s1.txt',
-#                            outputVariableType=exu.OutputVariableType.Position))
-#mbs.PlotSensor(s0, 0) #plot x-coordinate
-##plot x for s0 and z for s1:
-#mbs.PlotSensor(sensorNumbers=[s0,s1], components=[0,2], yLabel='this is the position in meter')
-#mbs.PlotSensor(sensorNumbers=s0, components=plot.componentNorm) #norm of position
-#mbs.PlotSensor(sensorNumbers=s0, components=[0,1,2], factors=1000., title='Answers to the big questions')
-#mbs.PlotSensor(sensorNumbers=s0, components=[0,1,2,3], 
-#           yLabel='Coordantes with offset 1\nand scaled with $\\frac{1}{1000}$', 
-#           factors=1e-3, offsets=1,fontSize=12, closeAll=True)
-#
-##assume to have body sensor sBody, marker sensor sMarker:
-#mbs.PlotSensor(sensorNumbers=[sBody]*3+[sMarker]*3, components=[0,1,2,0,1,2], 
-#           colorCodeOffset=3, newFigure=False, fontSize=10, 
-#           yLabel='Rotation $\\alpha, \\beta, \\gamma$ and\n Position $x,y,z$',
-#           title='compare marker and body sensor')
-##assume having file plotSensorNode.txt:
-#mbs.PlotSensor(sensorNumbers=[s0]*3+ [filedir+'plotSensorNode.txt']*3, 
-#           components=[0,1,2]*2)
-##plot y over x:
-#mbs.PlotSensor(sensorNumbers=s0, componentsX=[0], components=[1], xLabel='x-Position', yLabel='y-Position')
-##for further examples, see also Examples/plotSensorExamples.py
-def PlotSensor(mbs, sensorNumbers=[], components=0, xLabel='time (s)', yLabel=None, labels=[], 
-               colorCodeOffset=0, newFigure=True, closeAll=False, 
-               componentsX=[], title='', figureName='', fontSize=16, 
-               colors=[], lineStyles=[], lineWidths=[], markerStyles=[], markerSizes=[], markerDensity=0.08,
-               rangeX=[], rangeY=[], majorTicksX=10, majorTicksY=10,
-               offsets=[], factors=[], subPlot=[], sizeInches=[6.4,4.8],
-               fileName='', useXYZcomponents=True, **kwargs):
-    #could also be imported from exudyn.utilities import PlotLineCode
-    #CC = ['k-','g-','b-','r-','c-','m-','y-','k:','g:','b:','r:','c:','m:','y:','k--','g--','b--','r--','c--','m--','y--','k-.','g-.','b-.','r-.','c-.','m-.','y-.']
-    try:
-        import matplotlib
-        import matplotlib.pyplot as plt
-        import matplotlib.ticker as ticker
-    except:
-        raise ValueError('ERROR: PlotSensor: matplotlib is not installed; PlotSensor is therefore not available')
-
-    
-    for key in kwargs:
-        if (key!='minorTicksXon' and key!='minorTicksYon'
-            and key!='fileCommentChar' and key!='fileDelimiterChar'
-            and key!='logScaleX'  and key!='logScaleY'):
-            raise ValueError('PlotSensor: invalid argument: '+key)
-
-    if xLabel == 'time (s)':
-        xLabel = __plotSensorDefaults.xLabel
-    if yLabel == None:
-        yLabel = __plotSensorDefaults.yLabel
-
-    if fontSize == 16:
-        fontSize = __plotSensorDefaults.fontSize
-
-    #the following code is not totally safe regarding mutable args, but works with this kind of default args
-    if colors == []:
-        colors = __plotSensorDefaults.colors
-    if lineStyles == []:
-        lineStyles = __plotSensorDefaults.lineStyles
-    if lineWidths == []:
-        lineWidths = __plotSensorDefaults.lineWidths
-    if markerStyles == []:
-        markerStyles = __plotSensorDefaults.markerStyles
-    if markerSizes == []:
-        markerSizes = __plotSensorDefaults.markerSizes
-    if markerDensity == 0.08:
-        markerDensity = __plotSensorDefaults.markerDensity
-
-    if majorTicksX == 10:
-        majorTicksX = __plotSensorDefaults.majorTicksX
-    if majorTicksY == 10:
-        majorTicksY = __plotSensorDefaults.majorTicksY
-    if sizeInches == [6.4,4.8]:
-        sizeInches = __plotSensorDefaults.sizeInches
-
-
-            
-    if isinstance(sensorNumbers,list):
-        sensorList = list(sensorNumbers)
-    else:
-        sensorList = [sensorNumbers]
-
-    if isinstance(components,list):
-        componentList = components
-    else:
-        componentList = [components]
-
-    if len(componentList) == 1 and len(sensorList) != 1:
-        componentList = componentList*len(sensorList)
-        
-    if len(componentList) != 1 and len(sensorList) == 1:
-        sensorList = sensorList*len(componentList)
-        
-    if len(componentList) !=  len(sensorList):
-        raise ValueError('PlotSensor: size of sensorNumbers and size of components must be same or either components or sensorNumbers is scalar, sensorNumbers='+str(sensorNumbers)+', components='+str(components))
-
-    nSensors = len(sensorList)
-
-    componentsXnew = copy.copy(componentsX)
-    if componentsXnew != []:
-        if not isinstance(components,list):
-            componentsXnew = [componentsXnew]*nSensors
-        elif len(componentsXnew) != nSensors:
-            raise ValueError('PlotSensor: size of componentsX and size of sensors or components must be agree; componentsX='+str(componentsXnew))
-    else:
-        componentsXnew = [-1]*nSensors
-
-    
-    if closeAll:
-        plt.close('all')
-
-    logScaleX = False
-    if 'logScaleX' in kwargs:
-        logScaleX = kwargs['logScaleX']
-    logScaleY = False
-    if 'logScaleY' in kwargs:
-        logScaleY = kwargs['logScaleY']
-        
-    #increase font size as default is rather small
-    plt.rcParams.update({'font.size': fontSize})
-
-    factorOffsetUsed = False
-    if IsListOrArray(factors, checkIfNoneEmpty=True):#factors!=[]:
-        if type(factors) != list:
-            factors = [factors]*nSensors
-        if len(factors) != nSensors:
-            raise ValueError('PlotSensor: factors must be scalar or have same dimension as sensors')
-        factorOffsetUsed = True
-    else:
-        factors = [1.]*nSensors
-
-    if IsListOrArray(offsets, checkIfNoneEmpty=True):#offsets!=[]:
-        if type(offsets) != list:
-            offsets = [offsets]*nSensors
-        if len(offsets) != nSensors:
-            raise ValueError('PlotSensor: offsets must be scalar or have same dimension as sensors')
-        factorOffsetUsed = True
-    else:
-        offsets = [0.]*nSensors
-
-
-    fig=None
-    ax=None
-    line=None
-    if nSensors:
-        if figureName!='':
-            if newFigure and plt.fignum_exists(figureName):
-                plt.close(figureName)
-            fig = plt.figure(figureName)
-        elif newFigure:
-            fig = plt.figure()
-        else:
-            if plt.get_fignums() == []:
-                print('WARNING: PlotSensor(...,newFigure=False):  no existing figure was found, creating new figure')
-                fig = plt.figure()
-            else:
-                fig = plt.figure(plt.get_fignums()[-1]) #get last (current figure)
-    
-    # subNx=1
-    # subNy=1
-    if fig!=None:
-        if subPlot!=[]:
-            if type(subPlot)!=list or len(subPlot)!=3:
-                raise ValueError('PlotSensor: subPlot must have 3 integers [nx, ny, position]')
-            [subNx, subNy, subPos] = subPlot
-            fig.add_subplot(subNy, subNx, subPos)
-            fig.set_size_inches(subNx*sizeInches[0],subNy*sizeInches[1], forward=True)
-        else:
-            fig.set_size_inches(sizeInches[0],sizeInches[1], forward=True)
-
-    sensorFileNames = [] #for loading of files
-    sensorLabels = []    #plot label (legend)
-    sensorTypes = []     #for comparison, if all are of the same type
-    sensorDicts = []     #to check if stored internally
-    
-    for i in range(nSensors):
-        component = componentList[i]
-        sensorNumber = sensorList[i]
-        if not (isinstance(sensorNumber, exudyn.SensorIndex) or 
-                type(sensorNumber) == int or
-                type(sensorNumber) == str or 
-                type(sensorNumber) == np.ndarray):
-            raise ValueError('PlotSensor: *args must contain valid sensor numbers (SensorIndex or integers) or represent a filename string')
-
-        #retrieve sensor information:
-        if type(sensorNumber) == str: #direct path to file name
-            sensorDict={}
-            sensorDict['fileName'] = sensorNumber #sensorNumber must contain a file name, otherwise will fail
-            sensorDict['outputVariableType']=''
-            sensorDict['name'] = sensorNumber.split('/')[-1].split('\\')[-1].split('.')[0] #use filename without path and ending
-            
-            with open(sensorDict['fileName']) as file:
-                sensorDict.update(ParseOutputFileHeader(file.readlines()) )
-            
-            if sensorDict['type'] == 'solution':
-                sensorDict['outputVariableType'] = 'Coordinates'
-                
-        elif type(sensorNumber) == np.ndarray: #data provided as numpy array
-            sensorDict={}
-            sensorDict['fileName'] = sensorNumber #sensorNumber must contain the data as numpy array
-            sensorDict['outputVariableType']=''
-            sensorDict['name'] = ''
-            sensorDict['numpyArray'] = True #signal that it contains a numpy array
-            sensorDict['outputVariableType'] = ''
-        else:
-            sensorDict = mbs.GetSensor(sensorNumber)
-            if not (sensorDict['storeInternal'] or (sensorDict['writeToFile']
-                    and len(sensorDict['fileName'])!=0)):
-                raise ValueError('PlotSensor: sensor '+str(sensorNumber) +' has neither writeToFile=True nor storeInternal=True or filenName is empty, thus sensor cannot be plotted!')
-
-        sensorDicts += [sensorDict]
-        
-        #print('sensorDict=',sensorDict)
-        sensorName = sensorDict['name']
-
-        variableStr = '' #in case of markers, etc.
-        if 'outputVariableType' in sensorDict:
-            variable = sensorDict['outputVariableType']
-            variableStr = str(variable).replace('OutputVariableType.','')
-        elif 'sensorType' in sensorDict:
-            if sensorDict['sensorType'] == 'Load':
-                loadNumber = sensorDict['loadNumber']
-                loadDict = mbs.GetLoad(loadNumber)
-                loadType = loadDict['loadType']
-                if (loadType == 'ForceVector' or
-                    loadType == 'TorqueVector'):
-                    variableStr = loadType.replace('Vector','')
-                else:
-                    variableStr = 'Load'
-            else:
-                variableStr = sensorDict['sensorType']
-
-        #+++++++++++++++++++++++++++++++++++        
-        #create name for component
-        sComponent=''
-        #if len(componentList) != 1: #changed 2022-01-25: should show up anyway
-        varStrNoLocal = variableStr.replace('Local','')
-        compXYZ = ['X','Y','Z']
-        compXYZ2 = ['XX','YY','ZZ','YZ','XZ','XY'] #for stress, strain,...
-        
-        if (useXYZcomponents and component < 3 and component >= 0 and 
-            (varStrNoLocal == 'Force' or varStrNoLocal == 'Torque' or 
-             varStrNoLocal == 'Position' or varStrNoLocal == 'Displacement' or 
-             varStrNoLocal == 'Velocity' or varStrNoLocal == 'Acceleration' or
-             varStrNoLocal == 'Rotation' or varStrNoLocal == 'AngularVelocity' or
-             varStrNoLocal == 'AngularAcceleration' or 
-             varStrNoLocal == 'Force' or varStrNoLocal == 'Torque' or 
-             varStrNoLocal == 'AngularVelocity' or varStrNoLocal == 'AngularAcceleration')):
-            sComponent = compXYZ[component]
-        elif (useXYZcomponents and component < 6 and component >= 0 and 
-            (varStrNoLocal == 'Strain' or varStrNoLocal == 'Stress')):
-            sComponent = compXYZ2[component]
-        else:
-            sComponent = str(component)
-
-        sensorFileNames += [sensorDict['fileName']]
-        sensorLabels += [sensorName+', '+variableStr+sComponent]
-        sensorTypes += [variableStr]
-    
-    if labels != []:
-        if nSensors == 1 and type(labels)==str:
-            sensorLabels = [labels]
-        elif type(labels)==list and len(labels) == nSensors:
-            sensorLabels = labels
-        else:
-            raise ValueError('PlotSensor: labels must be either string for one sensor or list of strings according to number of sensors / components')
-            
-    
-    #+++++++++++++++++++++++++++++++++++++++++++
-    #check if all sensor outputvariables are the same => generate ylabel automatically!
-    checkStr = ''
-    allVariablesSame = True
-    for i in range(nSensors):
-
-        if i == 0:
-            checkStr = sensorTypes[i]
-        elif checkStr != sensorTypes[i]:
-            allVariablesSame = False
-
-    if yLabel == None:
-        yLabel = ''
-        if allVariablesSame:
-            yLabel = checkStr
-        else:
-            for (i, tt) in enumerate(sensorTypes):
-                yLabel += tt
-                if i < len(sensorTypes)-1:
-                    yLabel += ', '
-    
-    #+++++++++++++++++++++++++++++++++++++++++++
-    #finally plot:
-    for i in range(nSensors):
-        if componentList[i] != componentNorm:
-            componentY = componentList[i] + 1
-        else:
-            componentY = componentNorm
-        componentX = componentsXnew[i] + 1
-        
-        #now load sensor file:
-        if ('storeInternal' in sensorDicts[i] and
-            sensorDicts[i]['storeInternal']): #preferred way (higher accuracy, faster)
-            sensorNumber = sensorList[i]
-            data = mbs.GetSensorStoredData(sensorNumber)
-        elif 'numpyArray' in sensorDicts[i]:
-            sensorNumber = 'data'+str(i) #this string appears in errors and possibly in legend
-            data = sensorList[i]
-        else:
-            fileCommentChar = '#'
-            fileDelimiterChar = ','
-            if 'fileCommentChar' in kwargs:
-                fileCommentChar = kwargs['fileCommentChar']
-            if 'fileDelimiterChar' in kwargs:
-                fileDelimiterChar = kwargs['fileDelimiterChar']
-            
-            data = np.loadtxt(sensorFileNames[i], comments=fileCommentChar, delimiter=fileDelimiterChar)
-
-        #select color and style for sensor
-        CC = PlotLineCode(i+colorCodeOffset)
-        
-        color = CC[0]
-        lineStyle = CC[1:]
-        markerStyle = ''
-        markerSize = 6 #default matplotlib for scatter
-        lineWidth = 1
-
-        if lineStyles != []:
-            if type(lineStyles)==str:
-                lineStyle = lineStyles
-            elif type(lineStyles)==list and len(lineStyles) >= nSensors:
-                lineStyle = lineStyles[i]
-            else:
-                raise ValueError('PlotSensor: lineStyles must be either string for one sensor or list of matplotlib line style codes with length >= number of sensors / components')
-        
-        if lineWidths != []:
-            if type(lineWidths)==float or type(lineWidths)==int:
-                lineWidth = lineWidths
-            elif type(lineWidths)==list and len(lineWidths) >= nSensors:
-                lineWidth = lineWidths[i]
-            else:
-                raise ValueError('PlotSensor: lineWidths must be either a single float for all sensors or list of floats with length >= number of sensors / components (default line width=1)')
-        
-        if colors != []:
-            if nSensors == 1 and type(colors)==str:
-                color = colors
-            elif type(colors)==list and len(colors) >= nSensors:
-                color = colors[i]
-            else:
-                raise ValueError('PlotSensor: colors must be either string for one sensor or list of matplotlib color codes with length >= to number of sensors / components')
-        
-        markEvery = None
-        markerFillStyle = 'full'
-        if markerStyles != []:
-            if nSensors == 1 and type(markerStyles)==str:
-                markerStyle = markerStyles
-            elif type(markerStyles)==list and len(markerStyles) >= nSensors:
-                markerStyle = markerStyles[i]
-                if ' ' in markerStyle:
-                    markerFillStyle = 'none'
-                    markerStyle = markerStyle.replace(' ','')
-            else:
-                raise ValueError('PlotSensor: markerStyles must be either string for one sensor or list of matplotlib marker style codes with length >= number of sensors / components')
-            if type(markerDensity) == int:
-                nd = len(data) #len(data[:,componentY])
-                if markerDensity != 0:
-                    markEvery = int(1+nd/markerDensity)
-                    #print('markEvery=',markEvery, ', nd=',nd)
-            else:
-                markEvery = markerDensity
-        else:
-            markEvery = None
-        
-        if markerSizes != []:
-            if type(markerSizes)==float or type(markerSizes)==int:
-                markerSize = markerSizes
-            elif type(markerSizes)==list and len(markerSizes) == nSensors:
-                markerSize = markerSizes[i]
-            else:
-                raise ValueError('PlotSensor: markerSizes must be either a single float for all sensor or list of marker sizes with length >= number of sensors / components')
-                
-        #+++++++++++++++++++++++++++++++++++        
-        xData = data[:,componentX]
-        if componentY != componentNorm:
-            yData = data[:,componentY]
-        else:
-            #compute norm, not including time
-            nValues = len(data)
-            yData = np.zeros(nValues)
-            for rowNorm in range(nValues):
-                yData[rowNorm] = np.linalg.norm(data[rowNorm,1:])
-
-        #+++++++++++++++++++++++++++++++++++        
-        #add factor and offset if defined:
-        if factorOffsetUsed:
-            if type(offsets[i]) == float or type(offsets[i]) == int:
-                yData = factors[i]*(yData + offsets[i])
-            else: #must be numpy array
-                if componentY == componentNorm:
-                    raise ValueError('PlotSensor: sensor '+str(sensorNumber) +': component plot.componentNorm is only possible with scalar offsets')
-                if not isinstance(offsets[i], np.ndarray):
-                    raise ValueError('PlotSensor: sensor '+str(sensorNumber) +' offset must be either scalar (float) or numpy array, but received: '+str(type(offsets[i])))
-                if offsets[i].shape != data.shape:
-                    raise ValueError('PlotSensor: sensor '+str(sensorNumber) +' offset must have same dimensions as sensor data ('+str(data.shape)+') but received: '+str(offsets[i].shape))
-                yData = factors[i]*(yData + offsets[i][:,componentY])
-                if componentX != 0: #ignored for time
-                    xData = xData + offsets[i][:,componentX]
-
-        #+++++++++++++++++++++++++++++++++++        
-        #finally plot curve:
- 
-        plt.plot(xData, yData, color=color, linestyle=lineStyle, linewidth=lineWidth,
-                 marker=markerStyle, fillstyle=markerFillStyle, markersize=markerSize, markevery=markEvery, label=sensorLabels[i]) #numerical solution
-       
-        #plt.plot(data[:,componentX], yData, CC, label=sensorLabels[i]) #numerical solution
-        plt.xlabel(xLabel)
-        plt.ylabel(yLabel)
-        ax=plt.gca() # get current axes
-        ax.grid(True, 'major', 'both')
-        
-        ax.xaxis.set_major_locator(ticker.MaxNLocator(majorTicksX)) 
-        ax.yaxis.set_major_locator(ticker.MaxNLocator(majorTicksY)) 
-
-        if logScaleX:
-            plt.xscale('log')
-        if logScaleY:
-            plt.yscale('log')
-
-        if 'minorTicksOn' in kwargs:
-            if kwargs['minorTicksOn']:
-                ax.minorticks_on()
-            else:
-                ax.minorticks_off()
-
-        
-        if title!='':
-            plt.title(title)
-
-        if rangeX!=[]:
-            if type(rangeX)!=list or len(rangeX)!=2:
-                raise ValueError('PlotSensor: rangeX must be list of length 2 with minimum and maximum x-values')
-            plt.xlim(rangeX)
-            
-        if rangeY!=[]:
-            if type(rangeY)!=list or len(rangeY)!=2:
-                raise ValueError('PlotSensor: rangeY must be list of length 2 with minimum and maximum y-values')
-            plt.ylim(rangeY)
-
-
-    #do this finally!!!
-    if nSensors > 0:
-        handle = plt
-        if fig!=None:
-            handle = fig #better to use fig; plt.tight_layout() gives warning
-
-        
-        handle.legend() #show labels as legend
-        handle.tight_layout()
-        if matplotlib.get_backend() != 'agg': #this is used to avoid showing the figures, if they are just saved
-            handle.show() 
-        
-        if fileName != '':
-            try:
-                os.makedirs(os.path.dirname(fileName), exist_ok=True)
-            except:
-                pass #makedirs may fail on some systems, but we keep going
-
-            handle.savefig(fileName)
-    
-    return [plt, fig, ax, line]
-    
-#**function: plot fft spectrum of signal
-#**input: 
-#   frequency:  frequency vector (Hz, if time is in SECONDS)   
-#   data:       magnitude or phase as returned by ComputeFFT() in exudyn.signalProcessing
-#   xLabel:     label for x-axis, default=frequency
-#   yLabel:     label for y-axis, default=magnitude
-#   label:      either empty string ('') or name used in legend
-#   freqStart:  starting range for frequency
-#   freqEnd:    end of range for frequency; if freqEnd==-1 (default), the total range is plotted
-#   logScaleX:  use log scale for x-axis
-#   logScaleY:  use log scale for y-axis
-#   majorGrid:  if True, plot major grid with solid line 
-#   minorGrid:  if True, plot minor grid with dotted line 
-#**output: creates plot and returns plot (plt) handle
-def PlotFFT(frequency, data, 
-               xLabel='frequency', yLabel='magnitude', 
-               label = '',
-               freqStart = 0, freqEnd = -1, 
-               logScaleX = True, logScaleY = True,
-               majorGrid = True, minorGrid = True):
-    import matplotlib.pyplot as plt
-    import matplotlib.ticker as ticker
-
-    indStart = 0
-    indEnd = len(data)
-    for i in range(len(frequency)):
-        if frequency[i] <= freqStart:
-            indStart = i
-        if frequency[i] <= freqEnd:
-            indEnd = i
-
-    #print("fft ind=", indStart, indEnd)
-    if len(label) != 0:
-        plt.plot(frequency[indStart:indEnd], data[indStart:indEnd], label=label)
-        plt.legend() #show labels as legend
-    else:
-        plt.plot(frequency[indStart:indEnd], data[indStart:indEnd])
-    plt.xlabel(xLabel)
-    plt.ylabel(yLabel)
-    ax=plt.gca() # get current axes
-    ax.xaxis.set_major_locator(ticker.MaxNLocator(10)) 
-    ax.yaxis.set_major_locator(ticker.MaxNLocator(10)) 
-    # xScale = 'linear'
-    # yScale = 'linear'
-    if logScaleX:
-        plt.xscale('log')
-    if logScaleY:
-        plt.yscale('log')
-    ax.grid(visible=True, which='major', color='k', linestyle='-')
-    ax.grid(visible=True, which='minor', color='k', linestyle=':')
-    ax.minorticks_on()
-
-    plt.tight_layout()
-    plt.show() 
-
-    return plt
-
-#**function: strip spaces at beginning / end of lines; this may be sometimes necessary when reading solutions from files that are space-separated
-#**input:
-#  filename: name of file to process
-#  outputFilename: name of file to which text without leading/trailing spaces is written
-#  fileCommentChar: if not equal '', lines starting with this character will not be processed
-#  removeDoubleChars: if not equal '', this double characters (especial multiple spaces) will be removed; '1.0   3.0' will be converted into '1.0 3.0'
-#**output: new file written
-def FileStripSpaces(filename, outputFilename, fileCommentChar='', removeDoubleChars=''):
-    if filename==outputFilename:
-        raise ValueError('StripSpaces: filename and outputFilename must be different')
-    with open(filename, 'r') as file:
-        lines = file.readlines()
-        with open(outputFilename, 'w') as outfile:
-
-            for line in lines:
-                if fileCommentChar=='' or not (len(line)>=len(fileCommentChar)
-                    and line[0:len(fileCommentChar)] == fileCommentChar):
-
-                    line = line.strip('\n').strip(' ')+'\n'
-                    found = (removeDoubleChars != '')
-                    while found:
-                        if (removeDoubleChars+removeDoubleChars) in line:
-                            line = line.replace(removeDoubleChars+removeDoubleChars,removeDoubleChars)
-                        else: found=False
-                outfile.write(line)
-
-
-#**function: helper function to create data array from outputs defined by sensorNumbers list [+optional positionList which must have, e.g., local arc-length of beam according to sensor numbers]; if time=='', current sensor values will be used; if time!=[], evaluation will be based on loading values from file or sensor internal data and evaluate at that time 
-#**input: 
-#  mbs: a MainSystem where the sensors are given
-#  sensorNumbers: a list of sensor numbers, which shall be evaluated
-#  positionList: an optional list of positions per sensor (e.g., axial positions at beam) 
-#  time: optional time at which the sensor values are evaluated (currently not implemented)
-#**output: returns data as numpy array, containg per row the number or position (positionList) in the first column and all sensor values in the remaining columns
-def DataArrayFromSensorList(mbs, sensorNumbers, positionList=[], time=''):
-    if time != '':
-        raise ValueError("DataArrayFromSensors: time != '' is currently not implemented!")
-    n = len(sensorNumbers)
-    if positionList != [] and (n != len(positionList)):
-        raise ValueError("DataArrayFromSensors: sensorNumbers and positionList must have same dimensions, or positionList must be empty list")
-    
-    data = []
-    
-    for i, sensor in enumerate(sensorNumbers):
-        values = mbs.GetSensorValues(sensor)
-        if type(values) != np.ndarray:
-            values = np.array([values])
-            
-        if i == 0:
-            data = np.zeros((n, 1+len(values)))
-        if positionList != []:
-            data[i,0] = positionList[i]
-        else:
-            data[i,0] = i
-        data[i,1:] = values
-    return data
-
-
-#**function: import image text file as exported from RedrawAndSaveImage() with exportImages.saveImageFormat='TXT'; triangles are converted to lines
-#**input: fileName includes directory
-#**output: returns dictionary with according structures
-def LoadImage(fileName, trianglesAsLines = True, verbose=False):
-        
-    with open(fileName) as file:
-        lines = file.readlines()
-
-    if len(lines) == 0:
-        raise ValueError('LoadImage: empty file')
-
-    if lines[0][:-1] != '#Exudyn text image export file':
-        print('WARNING: LoadImage found inconsistent file header:',lines[0])
-    
-    if lines[-1][:-1] != '#END':
-        print('WARNING: LoadImage found inconsistent file ending; expected "END"')
-    
-    i = 1
-    listLines = []
-    listLineColors = [] #line colors as tuples
-    listTriangles = []
-    nSegments = 0
-    nTriangles = 0
-    actColor = (0,0,0,1)
-    while i < len(lines)-1: #there will be always 1 extra line (or file end)!
-        lineType = lines[i][:-1]
-        data = lines[i+1]
-        if lineType == '#COLOR':
-            actColor = tuple(np.array(data.split(','), dtype=float))
-            # print('color', actColor)
-        elif lineType == '#LINE':
-            splitLine = np.array(data.split(','), dtype=float)
-            listLines += [list(splitLine)]
-            listLineColors += [actColor] #per line
-            nSegments +=int(len(splitLine)/3)-1
-            # print('line', listLines)
-        elif lineType == '#TRIANGLE':
-            nTriangles += 1
-            splitLine = np.array(data.split(','), dtype=float)
-            linePoints = list(np.array(data.split(','), dtype=float))
-            if trianglesAsLines:
-                linePoints += linePoints[0:3] #add first point as last point
-                listLines += [linePoints]
-                listLineColors += [actColor] #per line
-            else:
-               listTriangles += [(list(splitLine), actColor)]
-        else:
-            i -= 1 #this may be a comment line; just increment by 1
-        
-        i += 2 #always increment by 2
-
-    if verbose:
-        print('number of lines:', len(listLines))
-        print('number of line segments:', nSegments)
-        print('number of triangles:', nTriangles)
-        
-    return {'linePoints':listLines, 'lineColors':listLineColors, 'triangles':listTriangles}
-
-#**function: plot 2D or 3D vector image data as provided by LoadImage(...) using matplotlib
-#**input:
-#  imageData: dictionary as provided by LoadImage(...) 
-#  HT: homogeneous transformation, used to transform coordinates; lines are drawn in (x,y) plane
-#  axesEqual: for 2D mode, axis are set equal, otherwise model is distorted
-#  plot3D: in this mode, a 3D visualization is used; triangles are only be displayed in this mode!
-#  lineWidths: width of lines
-#  lineStyles: matplotlib codes for lines
-#  triangleEdgeColors: color for triangle edges as tuple of rgb colors or matplotlib color code strings 'black', 'r', ...
-#  triangleEdgeWidths: width of triangle edges; set to 0 if edges shall not be shown
-#  removeAxes: if True, all axes and background are removed for simpler export
-#  orthogonalProjection: if True, projection is orthogonal with no perspective view
-#  title: optional string representing plot title 
-#  figureName: optional name for figure, if newFigure=True
-#  fileName: if this string is non-empty, figure will be saved to given path and filename (use figName.pdf to safe as PDF or figName.png to save as PNG image); use matplotlib.use('Agg') in order not to open figures if you just want to save them
-#  fontSize: change general fontsize of axis, labels, etc. (matplotlib default is 12, default in PlotSensor: 16)
-#  closeAll: if True, close all figures before opening new one (do this only in first PlotSensor command!)
-#  azim, elev: for 3D plots: the initial angles for the 3D view in degrees
-def PlotImage(imageData, HT = np.eye(4), axesEqual=True, plot3D=False, lineWidths=1, lineStyles='-', 
-              triangleEdgeColors='black', triangleEdgeWidths=0.5, removeAxes = True, orthogonalProjection=True,
-              title = '', figureName='', fileName = '', fontSize = 16, closeAll = False,
-              azim=0., elev=0.):
-
-    from matplotlib import collections  as mc #plot does not accept colors
-    import matplotlib.pyplot as plt
-    import matplotlib
-
-    from exudyn.rigidBodyUtilities import HT2rotationMatrix, HT2translation
-
-    linePoints = imageData['linePoints']
-    lineColors = imageData['lineColors']
-    triangles = imageData['triangles']
-
-    if closeAll:
-        plt.close('all')
-
-    plt.rcParams.update({'font.size': fontSize})
-    fig = plt.figure()
-
-    if figureName!='':
-        if plt.fignum_exists(figureName):
-            plt.close(figureName)
-        fig = plt.figure(figureName)
-    
-    #optional transformation
-    A = HT2rotationMatrix(HT)
-    p0 = HT2translation(HT)
-
-    if not plot3D: #plot in 2D
-        ax = fig.gca()
-        plotData = []
-        colors = []
-        
-        for i, line3D in enumerate(linePoints):
-            # print('line3D:', line3D)
-            nPoints = int(len(line3D)/3)
-    
-            line = (A @ np.array(line3D).reshape((nPoints,3)).T).T.flatten()
-            color = lineColors[i]
-            x = np.zeros(nPoints)
-            y = np.zeros(nPoints)
-            z = np.zeros(nPoints)
-            for j in range(nPoints):
-                x[j] = float(line[j*3+0]+p0[0])
-                y[j] = float(line[j*3+1]+p0[0])
-                z[j] = float(line[j*3+2]+p0[0])
-                
-            for j in range(nPoints-1):
-                plotData += [[(x[j], y[j]), (x[j+1], y[j+1])]] #for plot
-                colors += [color]
-    
-        if plotData != []:
-            collLines = mc.LineCollection(plotData, colors=colors, 
-                                   linewidths=lineWidths, linestyles=lineStyles)
-            ax.add_collection(collLines)
-            if axesEqual:
-                ax.set_aspect('equal', 'box') #for 2D only
-
-        if len(triangles) != 0:
-            print('WARNING: PlotImage: triangles are ignored; they can only be plotted if plot3D=True')
-            
-    else: #plot in 3D
-        ax = fig.gca(projection='3d')
-        plotData = []
-        colors = []
-        from mpl_toolkits.mplot3d.art3d import Line3DCollection
-
-        for i, line3D in enumerate(linePoints):
-            # print('line3D:', line3D)
-            nPoints = int(len(line3D)/3)
-
-            line = (A @ np.array(line3D).reshape((nPoints,3)).T).T.flatten()
-            color = lineColors[i]
-            x = np.zeros(nPoints)
-            y = np.zeros(nPoints)
-            z = np.zeros(nPoints)
-            for j in range(nPoints):
-                x[j] = float(line[j*3+0]+p0[0])
-                y[j] = float(line[j*3+1]+p0[1])
-                z[j] = float(line[j*3+2]+p0[2])
-                
-            for j in range(nPoints-1):
-                plotData += [[(x[j], y[j], z[j]), (x[j+1], y[j+1], z[j])]] #for plot
-                colors += [color]
-
-        if plotData != []:
-            collLines = Line3DCollection(plotData, colors=colors, 
-                                   linewidths=lineWidths, linestyles=lineStyles)
-            ax.add_collection3d(collLines)
-
-        ##Poly3DCollection seems not to work!
-        if len(triangles) != 0:
-            triangle_vertices = []
-            colors = []
-            #from mpl_toolkits.mplot3d import Axes3D
-            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
-            pOff = np.array([list(p0),list(p0),list(p0)]).T
-            for i, trig in enumerate(triangles):
-                trigPoints = (A @ np.array(trig[0]).reshape(3,3).T+pOff).T
-                #trigPoints = np.array(trig[0]).reshape(3,3)
-                triangle_vertices += [trigPoints]
-                colors += [np.array(trig[1][0:3])]
-    
-            # fig = plt.figure()
-            # ax = fig.gca(projection='3d')
-            edgeColors = triangleEdgeColors
-            if lineWidths == 0:
-                edgeColors = 'none'
-            collTrigs = Poly3DCollection(triangle_vertices, facecolors=colors, 
-                                         edgecolors=edgeColors, linewidths=triangleEdgeWidths)
-            collTrigs._facecolors2d = ax._facecolor
-            ax.add_collection(collTrigs)
-
-        ax.view_init(elev=0., azim=0.)
-        if removeAxes:
-            ax.set_axis_off()
-        if orthogonalProjection:
-            ax.set_proj_type('ortho') #this is better for e.g. xy view
-
-        if axesEqual:
-            ax.set_aspect('auto') 
-            ax.set_box_aspect([1,1,1])
-
-        ax.autoscale()
-    #end 3D plotting
-
-    if title!='':
-        plt.title(title)
-
-    plt.autoscale()
-    # plt.margins(0.1)
-
-    plt.tight_layout() #not needed
-    if matplotlib.get_backend() != 'agg': #this is used to avoid showing the figures, if they are just saved
-        plt.show() 
-    
-    if fileName != '':
-        try:
-            os.makedirs(os.path.dirname(fileName), exist_ok=True)
-        except:
-            pass #makedirs may fail on some systems, but we keep going
-        plt.savefig(fileName)
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Plot utility functions based on matplotlib, including plotting of sensors and FFT.
+#
+# Author:   Johannes Gerstmayr
+# Date:     2020-09-16 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+# Notes:    For a list of plot colors useful for matplotlib, see also advancedUtilities.PlotLineCode(...)
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+import numpy as np #for loading
+import exudyn #for sensor index
+from exudyn.advancedUtilities import PlotLineCode, IsListOrArray
+import copy
+import os
+
+#++++++++++++++++++++++++++++++++
+#this structure helps to define default values, that are then always used!
+class __PlotSensorDefaults:
+    def __init__(self):
+        pass
+    def __repr__(self):
+        return str(self.__dict__) #not very nice, but helps to easily see contents
+    
+__plotSensorDefaults = __PlotSensorDefaults() #initialize structure
+
+#here we define the modifyable default values (only change with PlotSensorDefaults() function!)
+__plotSensorDefaults.xLabel='time (s)'
+__plotSensorDefaults.yLabel=None
+__plotSensorDefaults.fontSize = 16
+
+__plotSensorDefaults.colors=[]
+__plotSensorDefaults.lineStyles=[]
+__plotSensorDefaults.lineWidths=[]
+__plotSensorDefaults.markerStyles=[]
+__plotSensorDefaults.markerSizes=[]
+__plotSensorDefaults.markerDensity=0.08
+
+__plotSensorDefaults.majorTicksX = 10
+__plotSensorDefaults.majorTicksY = 10
+__plotSensorDefaults.sizeInches=[6.4,4.8]
+
+#practical list of marker styles to be used as list:
+listMarkerStyles = ['x ', '+ ', '* ', '. ', 'd ', 'D ', 's ', 'X ', 'P ', 'v ', '^ ', '< ', '> ', 'o ', 'p ', 'h ', 'H ']
+listMarkerStylesFilled = ['x','+','*','.','d','D','s','X','P','v','^','<','>','o','p','h','H']
+
+#this is the value for a component which indicates to show the norm (e.g. of a vector) instead of the component
+componentNorm = -2 #
+
+#**function: parse header of output file (solution file, sensor file, genetic optimization output, ...) given in file.readlines() format
+#**output: return dictionary with 'type'=['sensor','solution','geneticOptimization','parameterVariation'], 'variableType' containing variable types, 'variableRanges' containing ranges for parameter variation 
+def ParseOutputFileHeader(lines):
+    nLines = len(lines)
+    parseLines = min(10, nLines) #max 10 lines to parse
+    output = {}
+    output['type'] = 'unknown'
+    #columns = []
+    if len(lines) < 1:
+        return {} #empty dictionary
+    variableTypes = []
+    variableRanges = [] #only for parameter variation
+    if lines[0].find('EXUDYN genetic optimization results file') != -1:
+        output['type'] = 'geneticOptimization'
+        for i in range(parseLines): #header is max. 10 lines
+            if i+1 < len(lines) and lines[i][0:9] == '#columns:':
+                cols = lines[i+1].strip('#').split(',')
+                for j in range(len(cols)):
+                    variableTypes += [cols[j].strip()]
+                break
+    if lines[0].find('EXUDYN parameter variation results file') != -1:
+        output['type'] = 'parameterVariation'
+        for i in range(parseLines): #header is max. 10 lines
+            if i+1 < len(lines) and lines[i][0:9] == '#columns:':
+                cols = lines[i+1].strip('#').split(',')
+                for j in range(len(cols)):
+                    variableTypes += [cols[j].strip()]
+                break
+        for i in range(parseLines): #header is max. 10 lines
+            if i+1 < len(lines) and lines[i][0:17] == '#parameter ranges':
+                ranges = lines[i+1].strip('#').strip('\n').split(';') #this gives e.g. ['(0.1, 5, 4)', '(2,4.5,2)']
+                # print('ranges=', ranges)
+                for j in range(len(ranges)):
+                    oneRange = ranges[j].strip('(').strip(')').split(',')
+                    # print('one range=', oneRange)
+                    variableRanges += [[float(oneRange[0]),float(oneRange[1]),int(oneRange[2])]]
+                break
+    elif lines[0].find('sensor output file') != -1:
+        #print("SENSOR")
+        output['type'] = 'sensor'
+        outputVariableType = ''
+        for i in range(parseLines): #header is max. 10 lines
+            if lines[i].find('Object number') != -1:
+                output['objectNumber'] = int(lines[i].split('=')[1])
+            elif lines[i].find('OutputVariableType') != -1:
+                outputVariableType = lines[i].split('=')[1].strip() #without spaces
+                output['outputVariableType'] = outputVariableType #for PlotSensor
+            elif lines[i].find('number of sensor values') != -1:
+                output['numberOfSensors'] = int(lines[i].split('=')[1]) 
+
+            if lines[i].find('#measure') != -1:
+                if ' ' in lines[i]:
+                    output['sensorType'] = lines[i].split(' ')[1] #for PlotSensor
+                else:
+                    output['sensorType'] = '' #no specific sensor type
+                if '=' in lines[i]:
+                    output['itemNumber'] = int(lines[i].split('=')[1]) #unused
+                else:
+                    output['itemNumber'] = -1 #invalid
+                
+            if lines[i][0] != '#': #break after comment
+                break
+        variableTypes = ['time']
+        for i in range(output['numberOfSensors']):
+            variableTypes += [outputVariableType+str(i)] #e.g., Position0, Position1, ...
+    elif lines[0].find('solution file') != -1: #coordinates solution file
+        output['type'] = 'solution'
+        writtenCoordinateTypes = []
+        writtenCoordinates = []
+        for i in range(parseLines): #header is max. 10 lines
+            if lines[i].find('number of written coordinates') != -1:
+                line = lines[i]
+                writtenCoordinateTypes = line.split('=')[0].split('[')[1].split(']')[0].replace(' ','').split(',')
+                writtenCoordinates = line.split('=')[1].split('[')[1].split(']')[0].replace(' ','').split(',')
+                variableTypes = ['time']
+                #print('writtenCoordinates=',writtenCoordinates)
+                for j in range(len(writtenCoordinateTypes)):
+                    for k in range(int(writtenCoordinates[j])):
+                       variableTypes += [writtenCoordinateTypes[j].strip('n')+'-'+str(k)]
+                #variableTypes += [writtenCoordinateTypes[j]]*int(writtenCoordinates[j])
+            elif lines[i].find('number of time steps') != -1:
+                output['numberOfSteps'] = int(lines[i].split('=')[1])
+
+            if lines[i][0] != '#': #break after comment
+                break
+
+    output['columns'] = variableTypes
+    output['variableRanges'] = variableRanges
+    
+    return output
+
+#**function: returns structure with default values for PlotSensor which can be modified once to be set for all later calls of PlotSensor
+#**example: 
+##change one parameter:
+#plot.PlotSensorDefaults().fontSize = 12
+##==>now PlotSensor(...) will use fontSize=12
+##==>now PlotSensor(..., fontSize=10) will use fontSize=10
+##==>BUT PlotSensor(..., fontSize=16) will use fontSize=12, BECAUSE 16 is the original default value!!!
+##see which parameters are available:
+#print(PlotSensorDefaults())
+def PlotSensorDefaults():
+    return __plotSensorDefaults #for definition see at top of this file
+   
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Helper function for direct and easy visualization of sensor outputs, without need for loading text files, etc.; PlotSensor can be used to simply plot, e.g., the measured x-Position over time in a figure. PlotSensor provides an interface to matplotlib (which needs to be installed). Default values of many function arguments can be changed using the exudyn.plot function PlotSensorDefaults(), see there for usage.
+#**input: 
+#  mbs: must be a valid MainSystem (mbs)
+#  sensorNumbers: consists of one or a list of sensor numbers (type SensorIndex or int) as returned by the mbs function AddSensor(...); sensors need to set writeToFile=True and/or storeInternal=True for PlotSensor to work; alternatively, it may contain FILENAMES (incl. path) to stored sensor or solution files OR a numpy array instead of sensor numbers; the format of data (file or numpy array) must contain per row the time and according solution values in columns; if components is a list and sensorNumbers is a scalar, sensorNumbers is adjusted automatically to the components
+#  components: consists of one or a list of components according to the component of the sensor to be plotted at y-axis; if components is a list and sensorNumbers is a scalar, sensorNumbers is adjusted automatically to the components; as always, components are zero-based, meaning 0=X, 1=Y, etc.; for regular sensor files, time will be component=-1; to show the norm (e.g., of a force vector), use component=[plot.componentNorm] for according sensors; norm will consider all values of sensor except time (for 3D force, it will be $\sqrt{f_0^2+f_1^2+f_2^2}$); offsets and factors are mapped on norm (plot value=factor*(norm(values) + offset) ), not on component values
+#  componentsX: default componentsX=[] uses time in files; otherwise provide componentsX as list of components (or scalar) representing x components of sensors in plotted curves; DON'T forget to change xLabel accordingly! 
+#    Using componentsX=[...] with a list of column indices specifies the respective columns used for the x-coordinates in all sensors; by default, values are plotted against the first column in the files, which is time; according to counting in PlotSensor, this represents componentX=-1; 
+#    plotting y over x in a position sensor thus reads: components=[1], componentsX=[0]; 
+#    plotting time over x reads: components=[-1], componentsX=[0]; 
+#    the default value reads componentsX=[-1,-1,...]
+#  xLabel: string for text at x-axis
+#  yLabel: string for text at y-axis (default: None==> label is automatically computed from sensor value types)
+#  labels: string (for one sensor) or list of strings (according to number of sensors resp. components) representing the labels used in legend; if labels=[], automatically generated legend is used
+#  rangeX: default rangeX=[]: computes range automatically; otherwise use rangeX to set range (limits) for x-axis provided as sorted list of two floats, e.g., rangeX=[0,4]
+#  rangeY: default rangeY=[]: computes range automatically; otherwise use rangeY to set range (limits) for y-axis provided as sorted list of two floats, e.g., rangeY=[-1,1]
+#  figureName: optional name for figure, if newFigure=True
+#  fontSize: change general fontsize of axis, labels, etc. (matplotlib default is 12, default in PlotSensor: 16)
+#  title: optional string representing plot title 
+#  offsets: provide as scalar, list of scalars (per sensor) or list of 2D numpy.arrays (per sensor, having same rows/columns as sensor data; in this case it will also influence x-axis if componentsX is different from -1) to add offset to each sensor output; for an original value fOrig, the new value reads fNew = factor*(fOrig+offset); for offset provided as numpy array (with same time values), the 'time' column is ignored in the offset computation; can be used to compute difference of sensors; if offsets=[], no offset is used
+#  factors: provide as scalar or list (per sensor) to add factor to each sensor output; for an original value fOrig, the new value reads fNew = factor*(fOrig+offset); if factor=[], no factor is used
+#  majorTicksX: number of major ticks on x-axis; default: 10
+#  majorTicksY: number of major ticks on y-axis; default: 10
+#  colorCodeOffset: int offset for color code, color codes going from 0 to 27 (see PlotLineCode(...)); automatic line/color codes are used if no colors and lineStyles are used
+#  colors: color is automatically selected from colorCodeOffset if colors=[]; otherwise chose from 'b', 'g', 'r', 'c', 'm', 'y', 'k' and many other colors see https://matplotlib.org/stable/gallery/color/named\_colors.html
+#  lineStyles: line style is automatically selected from colorCodeOffset if lineStyles=[]; otherwise define for all lines with string or with list of strings, chosing from '-', '--', '-.', ':', or '' 
+#  lineWidths: float to define line width by float (default=1); either use single float for all sensors or list of floats with length >= number of sensors
+#  markerStyles: if different from [], marker styles are defined as list of marker style strings or single string for one sensor; chose from '.', 'o', 'x', '+' ... check listMarkerStylesFilled and listMarkerStyles in exudyn.plot and see https://matplotlib.org/stable/api/markers\_api.html ; ADD a space to markers to make them empty (transparent), e.g. 'o ' will create an empty circle 
+#  markerSizes: float to define marker size by float (default=6); either use single float for all sensors or list of floats with length >= number of sensors 
+#  markerDensity: if int, it defines approx. the total number of markers used along each graph; if float, this defines the distance of markers relative to the diagonal of the plot (default=0.08); if None, it adds a marker to every data point if marker style is specified for sensor
+#  newFigure: if True, a new matplotlib.pyplot figure is created; otherwise, existing figures are overwritten
+#  subPlot: given as list [nx, ny, position] with nx, ny being the number of subplots in x and y direction (nx=cols, ny=rows), and position in [1,..., nx*ny] gives the position in the subplots; use the same structure for first PlotSensor (with newFigure=True) and all subsequent PlotSensor calls with newFigure=False, which creates the according subplots; default=[](no subplots) 
+#  sizeInches: given as list [sizeX, sizeY] with the sizes per (sub)plot given in inches; default: [6.4, 4.8]; in case of sub plots, the total size of the figure is computed from nx*sizeInches[0] and ny*sizeInches[1]
+#  fileName: if this string is non-empty, figure will be saved to given path and filename (use figName.pdf to safe as PDF or figName.png to save as PNG image); use matplotlib.use('Agg') in order not to open figures if you just want to save them
+#  useXYZcomponents: of True, it will use X, Y and Z for sensor components, e.g., measuring Position, Velocity, etc. wherever possible
+#  closeAll: if True, close all figures before opening new one (do this only in first PlotSensor command!)
+#  [*kwargs]:
+#        minorTicksXon: if True, turn minor ticks for x-axis on
+#        minorTicksYon: if True, turn minor ticks for y-axis on
+#        logScaleX: use log scale for x-axis
+#        logScaleY: use log scale for y-axis
+#        fileCommentChar: if exists, defines the comment character in files (\#, %, ...)
+#        fileDelimiterChar: if exists, defines the character indicating the columns for data (',', ' ', ';', ...)
+#**output: [Any, Any, Any, Any]; plots the sensor data; returns [plt, fig, ax, line] in which plt is matplotlib.pyplot, fig is the figure (or None), ax is the axis (or None) and line is the return value of plt.plot (or None) which could be changed hereafter
+#**notes: adjust default values by modifying the variables exudyn.plot.plotSensorDefault..., e.g., exudyn.plot.plotSensorDefaultFontSize
+#**belongsTo: MainSystem
+#**example: 
+##assume to have some position-based nodes 0 and 1:
+#s0=mbs.AddSensor(SensorNode(nodeNumber=0, fileName='s0.txt',
+#                            outputVariableType=exu.OutputVariableType.Position))
+#s1=mbs.AddSensor(SensorNode(nodeNumber=1, fileName='s1.txt',
+#                            outputVariableType=exu.OutputVariableType.Position))
+#mbs.PlotSensor(s0, 0) #plot x-coordinate
+##plot x for s0 and z for s1:
+#mbs.PlotSensor(sensorNumbers=[s0,s1], components=[0,2], yLabel='this is the position in meter')
+#mbs.PlotSensor(sensorNumbers=s0, components=plot.componentNorm) #norm of position
+#mbs.PlotSensor(sensorNumbers=s0, components=[0,1,2], factors=1000., title='Answers to the big questions')
+#mbs.PlotSensor(sensorNumbers=s0, components=[0,1,2,3], 
+#           yLabel='Coordantes with offset 1\nand scaled with $\\frac{1}{1000}$', 
+#           factors=1e-3, offsets=1,fontSize=12, closeAll=True)
+#
+##assume to have body sensor sBody, marker sensor sMarker:
+#mbs.PlotSensor(sensorNumbers=[sBody]*3+[sMarker]*3, components=[0,1,2,0,1,2], 
+#           colorCodeOffset=3, newFigure=False, fontSize=10, 
+#           yLabel='Rotation $\\alpha, \\beta, \\gamma$ and\n Position $x,y,z$',
+#           title='compare marker and body sensor')
+##assume having file plotSensorNode.txt:
+#mbs.PlotSensor(sensorNumbers=[s0]*3+ [filedir+'plotSensorNode.txt']*3, 
+#           components=[0,1,2]*2)
+##plot y over x:
+#mbs.PlotSensor(sensorNumbers=s0, componentsX=[0], components=[1], xLabel='x-Position', yLabel='y-Position')
+##for further examples, see also Examples/plotSensorExamples.py
+def PlotSensor(mbs, sensorNumbers=[], components=0, xLabel='time (s)', yLabel=None, labels=[], 
+               colorCodeOffset=0, newFigure=True, closeAll=False, 
+               componentsX=[], title='', figureName='', fontSize=16, 
+               colors=[], lineStyles=[], lineWidths=[], markerStyles=[], markerSizes=[], markerDensity=0.08,
+               rangeX=[], rangeY=[], majorTicksX=10, majorTicksY=10,
+               offsets=[], factors=[], subPlot=[], sizeInches=[6.4,4.8],
+               fileName='', useXYZcomponents=True, **kwargs):
+    #could also be imported from exudyn.utilities import PlotLineCode
+    #CC = ['k-','g-','b-','r-','c-','m-','y-','k:','g:','b:','r:','c:','m:','y:','k--','g--','b--','r--','c--','m--','y--','k-.','g-.','b-.','r-.','c-.','m-.','y-.']
+    try:
+        import matplotlib
+        import matplotlib.pyplot as plt
+        import matplotlib.ticker as ticker
+    except:
+        raise ValueError('ERROR: PlotSensor: matplotlib is not installed; PlotSensor is therefore not available')
+
+    
+    for key in kwargs:
+        if (key!='minorTicksXon' and key!='minorTicksYon'
+            and key!='fileCommentChar' and key!='fileDelimiterChar'
+            and key!='logScaleX'  and key!='logScaleY'):
+            raise ValueError('PlotSensor: invalid argument: '+key)
+
+    if xLabel == 'time (s)':
+        xLabel = __plotSensorDefaults.xLabel
+    if yLabel == None:
+        yLabel = __plotSensorDefaults.yLabel
+
+    if fontSize == 16:
+        fontSize = __plotSensorDefaults.fontSize
+
+    #the following code is not totally safe regarding mutable args, but works with this kind of default args
+    if colors == []:
+        colors = __plotSensorDefaults.colors
+    if lineStyles == []:
+        lineStyles = __plotSensorDefaults.lineStyles
+    if lineWidths == []:
+        lineWidths = __plotSensorDefaults.lineWidths
+    if markerStyles == []:
+        markerStyles = __plotSensorDefaults.markerStyles
+    if markerSizes == []:
+        markerSizes = __plotSensorDefaults.markerSizes
+    if markerDensity == 0.08:
+        markerDensity = __plotSensorDefaults.markerDensity
+
+    if majorTicksX == 10:
+        majorTicksX = __plotSensorDefaults.majorTicksX
+    if majorTicksY == 10:
+        majorTicksY = __plotSensorDefaults.majorTicksY
+    if sizeInches == [6.4,4.8]:
+        sizeInches = __plotSensorDefaults.sizeInches
+
+
+            
+    if isinstance(sensorNumbers,list):
+        sensorList = list(sensorNumbers)
+    else:
+        sensorList = [sensorNumbers]
+
+    if isinstance(components,list):
+        componentList = components
+    else:
+        componentList = [components]
+
+    if len(componentList) == 1 and len(sensorList) != 1:
+        componentList = componentList*len(sensorList)
+        
+    if len(componentList) != 1 and len(sensorList) == 1:
+        sensorList = sensorList*len(componentList)
+        
+    if len(componentList) !=  len(sensorList):
+        raise ValueError('PlotSensor: size of sensorNumbers and size of components must be same or either components or sensorNumbers is scalar, sensorNumbers='+str(sensorNumbers)+', components='+str(components))
+
+    nSensors = len(sensorList)
+
+    componentsXnew = copy.copy(componentsX)
+    if componentsXnew != []:
+        if not isinstance(components,list):
+            componentsXnew = [componentsXnew]*nSensors
+        elif len(componentsXnew) != nSensors:
+            raise ValueError('PlotSensor: size of componentsX and size of sensors or components must be agree; componentsX='+str(componentsXnew))
+    else:
+        componentsXnew = [-1]*nSensors
+
+    
+    if closeAll:
+        plt.close('all')
+
+    logScaleX = False
+    if 'logScaleX' in kwargs:
+        logScaleX = kwargs['logScaleX']
+    logScaleY = False
+    if 'logScaleY' in kwargs:
+        logScaleY = kwargs['logScaleY']
+        
+    #increase font size as default is rather small
+    plt.rcParams.update({'font.size': fontSize})
+
+    factorOffsetUsed = False
+    if IsListOrArray(factors, checkIfNoneEmpty=True):#factors!=[]:
+        if type(factors) != list:
+            factors = [factors]*nSensors
+        if len(factors) != nSensors:
+            raise ValueError('PlotSensor: factors must be scalar or have same dimension as sensors')
+        factorOffsetUsed = True
+    else:
+        factors = [1.]*nSensors
+
+    if IsListOrArray(offsets, checkIfNoneEmpty=True):#offsets!=[]:
+        if type(offsets) != list:
+            offsets = [offsets]*nSensors
+        if len(offsets) != nSensors:
+            raise ValueError('PlotSensor: offsets must be scalar or have same dimension as sensors')
+        factorOffsetUsed = True
+    else:
+        offsets = [0.]*nSensors
+
+
+    fig=None
+    ax=None
+    line=None
+    if nSensors:
+        if figureName!='':
+            if newFigure and plt.fignum_exists(figureName):
+                plt.close(figureName)
+            fig = plt.figure(figureName)
+        elif newFigure:
+            fig = plt.figure()
+        else:
+            if plt.get_fignums() == []:
+                print('WARNING: PlotSensor(...,newFigure=False):  no existing figure was found, creating new figure')
+                fig = plt.figure()
+            else:
+                fig = plt.figure(plt.get_fignums()[-1]) #get last (current figure)
+    
+    # subNx=1
+    # subNy=1
+    if fig!=None:
+        if subPlot!=[]:
+            if type(subPlot)!=list or len(subPlot)!=3:
+                raise ValueError('PlotSensor: subPlot must have 3 integers [nx, ny, position]')
+            [subNx, subNy, subPos] = subPlot
+            fig.add_subplot(subNy, subNx, subPos)
+            fig.set_size_inches(subNx*sizeInches[0],subNy*sizeInches[1], forward=True)
+        else:
+            fig.set_size_inches(sizeInches[0],sizeInches[1], forward=True)
+
+    sensorFileNames = [] #for loading of files
+    sensorLabels = []    #plot label (legend)
+    sensorTypes = []     #for comparison, if all are of the same type
+    sensorDicts = []     #to check if stored internally
+    
+    for i in range(nSensors):
+        component = componentList[i]
+        sensorNumber = sensorList[i]
+        if not (isinstance(sensorNumber, exudyn.SensorIndex) or 
+                type(sensorNumber) == int or
+                type(sensorNumber) == str or 
+                type(sensorNumber) == np.ndarray):
+            raise ValueError('PlotSensor: *args must contain valid sensor numbers (SensorIndex or integers) or represent a filename string')
+
+        #retrieve sensor information:
+        if type(sensorNumber) == str: #direct path to file name
+            sensorDict={}
+            sensorDict['fileName'] = sensorNumber #sensorNumber must contain a file name, otherwise will fail
+            sensorDict['outputVariableType']=''
+            sensorDict['name'] = sensorNumber.split('/')[-1].split('\\')[-1].split('.')[0] #use filename without path and ending
+            
+            with open(sensorDict['fileName']) as file:
+                sensorDict.update(ParseOutputFileHeader(file.readlines()) )
+            
+            if sensorDict['type'] == 'solution':
+                sensorDict['outputVariableType'] = 'Coordinates'
+                
+        elif type(sensorNumber) == np.ndarray: #data provided as numpy array
+            sensorDict={}
+            sensorDict['fileName'] = sensorNumber #sensorNumber must contain the data as numpy array
+            sensorDict['outputVariableType']=''
+            sensorDict['name'] = ''
+            sensorDict['numpyArray'] = True #signal that it contains a numpy array
+            sensorDict['outputVariableType'] = ''
+        else:
+            sensorDict = mbs.GetSensor(sensorNumber)
+            if not (sensorDict['storeInternal'] or (sensorDict['writeToFile']
+                    and len(sensorDict['fileName'])!=0)):
+                raise ValueError('PlotSensor: sensor '+str(sensorNumber) +' has neither writeToFile=True nor storeInternal=True or filenName is empty, thus sensor cannot be plotted!')
+
+        sensorDicts += [sensorDict]
+        
+        #print('sensorDict=',sensorDict)
+        sensorName = sensorDict['name']
+
+        variableStr = '' #in case of markers, etc.
+        if 'outputVariableType' in sensorDict:
+            variable = sensorDict['outputVariableType']
+            variableStr = str(variable).replace('OutputVariableType.','')
+        elif 'sensorType' in sensorDict:
+            if sensorDict['sensorType'] == 'Load':
+                loadNumber = sensorDict['loadNumber']
+                loadDict = mbs.GetLoad(loadNumber)
+                loadType = loadDict['loadType']
+                if (loadType == 'ForceVector' or
+                    loadType == 'TorqueVector'):
+                    variableStr = loadType.replace('Vector','')
+                else:
+                    variableStr = 'Load'
+            else:
+                variableStr = sensorDict['sensorType']
+
+        #+++++++++++++++++++++++++++++++++++        
+        #create name for component
+        sComponent=''
+        #if len(componentList) != 1: #changed 2022-01-25: should show up anyway
+        varStrNoLocal = variableStr.replace('Local','')
+        compXYZ = ['X','Y','Z']
+        compXYZ2 = ['XX','YY','ZZ','YZ','XZ','XY'] #for stress, strain,...
+        
+        if (useXYZcomponents and component < 3 and component >= 0 and 
+            (varStrNoLocal == 'Force' or varStrNoLocal == 'Torque' or 
+             varStrNoLocal == 'Position' or varStrNoLocal == 'Displacement' or 
+             varStrNoLocal == 'Velocity' or varStrNoLocal == 'Acceleration' or
+             varStrNoLocal == 'Rotation' or varStrNoLocal == 'AngularVelocity' or
+             varStrNoLocal == 'AngularAcceleration' or 
+             varStrNoLocal == 'Force' or varStrNoLocal == 'Torque' or 
+             varStrNoLocal == 'AngularVelocity' or varStrNoLocal == 'AngularAcceleration')):
+            sComponent = compXYZ[component]
+        elif (useXYZcomponents and component < 6 and component >= 0 and 
+            (varStrNoLocal == 'Strain' or varStrNoLocal == 'Stress')):
+            sComponent = compXYZ2[component]
+        else:
+            sComponent = str(component)
+
+        sensorFileNames += [sensorDict['fileName']]
+        sensorLabels += [sensorName+', '+variableStr+sComponent]
+        sensorTypes += [variableStr]
+    
+    if labels != []:
+        if nSensors == 1 and type(labels)==str:
+            sensorLabels = [labels]
+        elif type(labels)==list and len(labels) == nSensors:
+            sensorLabels = labels
+        else:
+            raise ValueError('PlotSensor: labels must be either string for one sensor or list of strings according to number of sensors / components')
+            
+    
+    #+++++++++++++++++++++++++++++++++++++++++++
+    #check if all sensor outputvariables are the same => generate ylabel automatically!
+    checkStr = ''
+    allVariablesSame = True
+    for i in range(nSensors):
+
+        if i == 0:
+            checkStr = sensorTypes[i]
+        elif checkStr != sensorTypes[i]:
+            allVariablesSame = False
+
+    if yLabel == None:
+        yLabel = ''
+        if allVariablesSame:
+            yLabel = checkStr
+        else:
+            for (i, tt) in enumerate(sensorTypes):
+                yLabel += tt
+                if i < len(sensorTypes)-1:
+                    yLabel += ', '
+    
+    #+++++++++++++++++++++++++++++++++++++++++++
+    #finally plot:
+    for i in range(nSensors):
+        if componentList[i] != componentNorm:
+            componentY = componentList[i] + 1
+        else:
+            componentY = componentNorm
+        componentX = componentsXnew[i] + 1
+        
+        #now load sensor file:
+        if ('storeInternal' in sensorDicts[i] and
+            sensorDicts[i]['storeInternal']): #preferred way (higher accuracy, faster)
+            sensorNumber = sensorList[i]
+            data = mbs.GetSensorStoredData(sensorNumber)
+        elif 'numpyArray' in sensorDicts[i]:
+            sensorNumber = 'data'+str(i) #this string appears in errors and possibly in legend
+            data = sensorList[i]
+        else:
+            fileCommentChar = '#'
+            fileDelimiterChar = ','
+            if 'fileCommentChar' in kwargs:
+                fileCommentChar = kwargs['fileCommentChar']
+            if 'fileDelimiterChar' in kwargs:
+                fileDelimiterChar = kwargs['fileDelimiterChar']
+            
+            data = np.loadtxt(sensorFileNames[i], comments=fileCommentChar, delimiter=fileDelimiterChar)
+
+        #select color and style for sensor
+        CC = PlotLineCode(i+colorCodeOffset)
+        
+        color = CC[0]
+        lineStyle = CC[1:]
+        markerStyle = ''
+        markerSize = 6 #default matplotlib for scatter
+        lineWidth = 1
+
+        if lineStyles != []:
+            if type(lineStyles)==str:
+                lineStyle = lineStyles
+            elif type(lineStyles)==list and len(lineStyles) >= nSensors:
+                lineStyle = lineStyles[i]
+            else:
+                raise ValueError('PlotSensor: lineStyles must be either string for one sensor or list of matplotlib line style codes with length >= number of sensors / components')
+        
+        if lineWidths != []:
+            if type(lineWidths)==float or type(lineWidths)==int:
+                lineWidth = lineWidths
+            elif type(lineWidths)==list and len(lineWidths) >= nSensors:
+                lineWidth = lineWidths[i]
+            else:
+                raise ValueError('PlotSensor: lineWidths must be either a single float for all sensors or list of floats with length >= number of sensors / components (default line width=1)')
+        
+        if colors != []:
+            if nSensors == 1 and type(colors)==str:
+                color = colors
+            elif type(colors)==list and len(colors) >= nSensors:
+                color = colors[i]
+            else:
+                raise ValueError('PlotSensor: colors must be either string for one sensor or list of matplotlib color codes with length >= to number of sensors / components')
+        
+        markEvery = None
+        markerFillStyle = 'full'
+        if markerStyles != []:
+            if nSensors == 1 and type(markerStyles)==str:
+                markerStyle = markerStyles
+            elif type(markerStyles)==list and len(markerStyles) >= nSensors:
+                markerStyle = markerStyles[i]
+                if ' ' in markerStyle:
+                    markerFillStyle = 'none'
+                    markerStyle = markerStyle.replace(' ','')
+            else:
+                raise ValueError('PlotSensor: markerStyles must be either string for one sensor or list of matplotlib marker style codes with length >= number of sensors / components')
+            if type(markerDensity) == int:
+                nd = len(data) #len(data[:,componentY])
+                if markerDensity != 0:
+                    markEvery = int(1+nd/markerDensity)
+                    #print('markEvery=',markEvery, ', nd=',nd)
+            else:
+                markEvery = markerDensity
+        else:
+            markEvery = None
+        
+        if markerSizes != []:
+            if type(markerSizes)==float or type(markerSizes)==int:
+                markerSize = markerSizes
+            elif type(markerSizes)==list and len(markerSizes) == nSensors:
+                markerSize = markerSizes[i]
+            else:
+                raise ValueError('PlotSensor: markerSizes must be either a single float for all sensor or list of marker sizes with length >= number of sensors / components')
+                
+        #+++++++++++++++++++++++++++++++++++        
+        xData = data[:,componentX]
+        if componentY != componentNorm:
+            yData = data[:,componentY]
+        else:
+            #compute norm, not including time
+            nValues = len(data)
+            yData = np.zeros(nValues)
+            for rowNorm in range(nValues):
+                yData[rowNorm] = np.linalg.norm(data[rowNorm,1:])
+
+        #+++++++++++++++++++++++++++++++++++        
+        #add factor and offset if defined:
+        if factorOffsetUsed:
+            if type(offsets[i]) == float or type(offsets[i]) == int:
+                yData = factors[i]*(yData + offsets[i])
+            else: #must be numpy array
+                if componentY == componentNorm:
+                    raise ValueError('PlotSensor: sensor '+str(sensorNumber) +': component plot.componentNorm is only possible with scalar offsets')
+                if not isinstance(offsets[i], np.ndarray):
+                    raise ValueError('PlotSensor: sensor '+str(sensorNumber) +' offset must be either scalar (float) or numpy array, but received: '+str(type(offsets[i])))
+                if offsets[i].shape != data.shape:
+                    raise ValueError('PlotSensor: sensor '+str(sensorNumber) +' offset must have same dimensions as sensor data ('+str(data.shape)+') but received: '+str(offsets[i].shape))
+                yData = factors[i]*(yData + offsets[i][:,componentY])
+                if componentX != 0: #ignored for time
+                    xData = xData + offsets[i][:,componentX]
+
+        #+++++++++++++++++++++++++++++++++++        
+        #finally plot curve:
+ 
+        plt.plot(xData, yData, color=color, linestyle=lineStyle, linewidth=lineWidth,
+                 marker=markerStyle, fillstyle=markerFillStyle, markersize=markerSize, markevery=markEvery, label=sensorLabels[i]) #numerical solution
+       
+        #plt.plot(data[:,componentX], yData, CC, label=sensorLabels[i]) #numerical solution
+        plt.xlabel(xLabel)
+        plt.ylabel(yLabel)
+        ax=plt.gca() # get current axes
+        ax.grid(True, 'major', 'both')
+        
+        ax.xaxis.set_major_locator(ticker.MaxNLocator(majorTicksX)) 
+        ax.yaxis.set_major_locator(ticker.MaxNLocator(majorTicksY)) 
+
+        if logScaleX:
+            plt.xscale('log')
+        if logScaleY:
+            plt.yscale('log')
+
+        if 'minorTicksOn' in kwargs:
+            if kwargs['minorTicksOn']:
+                ax.minorticks_on()
+            else:
+                ax.minorticks_off()
+
+        
+        if title!='':
+            plt.title(title)
+
+        if rangeX!=[]:
+            if type(rangeX)!=list or len(rangeX)!=2:
+                raise ValueError('PlotSensor: rangeX must be list of length 2 with minimum and maximum x-values')
+            plt.xlim(rangeX)
+            
+        if rangeY!=[]:
+            if type(rangeY)!=list or len(rangeY)!=2:
+                raise ValueError('PlotSensor: rangeY must be list of length 2 with minimum and maximum y-values')
+            plt.ylim(rangeY)
+
+
+    #do this finally!!!
+    if nSensors > 0:
+        handle = plt
+        if fig!=None:
+            handle = fig #better to use fig; plt.tight_layout() gives warning
+
+        
+        handle.legend() #show labels as legend
+        handle.tight_layout()
+        if matplotlib.get_backend() != 'agg': #this is used to avoid showing the figures, if they are just saved
+            handle.show() 
+        
+        if fileName != '':
+            try:
+                os.makedirs(os.path.dirname(fileName), exist_ok=True)
+            except:
+                pass #makedirs may fail on some systems, but we keep going
+
+            handle.savefig(fileName)
+    
+    return [plt, fig, ax, line]
+    
+#**function: plot fft spectrum of signal
+#**input: 
+#   frequency:  frequency vector (Hz, if time is in SECONDS)   
+#   data:       magnitude or phase as returned by ComputeFFT() in exudyn.signalProcessing
+#   xLabel:     label for x-axis, default=frequency
+#   yLabel:     label for y-axis, default=magnitude
+#   label:      either empty string ('') or name used in legend
+#   freqStart:  starting range for frequency
+#   freqEnd:    end of range for frequency; if freqEnd==-1 (default), the total range is plotted
+#   logScaleX:  use log scale for x-axis
+#   logScaleY:  use log scale for y-axis
+#   majorGrid:  if True, plot major grid with solid line 
+#   minorGrid:  if True, plot minor grid with dotted line 
+#**output: creates plot and returns plot (plt) handle
+def PlotFFT(frequency, data, 
+               xLabel='frequency', yLabel='magnitude', 
+               label = '',
+               freqStart = 0, freqEnd = -1, 
+               logScaleX = True, logScaleY = True,
+               majorGrid = True, minorGrid = True):
+    import matplotlib.pyplot as plt
+    import matplotlib.ticker as ticker
+
+    indStart = 0
+    indEnd = len(data)
+    for i in range(len(frequency)):
+        if frequency[i] <= freqStart:
+            indStart = i
+        if frequency[i] <= freqEnd:
+            indEnd = i
+
+    #print("fft ind=", indStart, indEnd)
+    if len(label) != 0:
+        plt.plot(frequency[indStart:indEnd], data[indStart:indEnd], label=label)
+        plt.legend() #show labels as legend
+    else:
+        plt.plot(frequency[indStart:indEnd], data[indStart:indEnd])
+    plt.xlabel(xLabel)
+    plt.ylabel(yLabel)
+    ax=plt.gca() # get current axes
+    ax.xaxis.set_major_locator(ticker.MaxNLocator(10)) 
+    ax.yaxis.set_major_locator(ticker.MaxNLocator(10)) 
+    # xScale = 'linear'
+    # yScale = 'linear'
+    if logScaleX:
+        plt.xscale('log')
+    if logScaleY:
+        plt.yscale('log')
+    ax.grid(visible=True, which='major', color='k', linestyle='-')
+    ax.grid(visible=True, which='minor', color='k', linestyle=':')
+    ax.minorticks_on()
+
+    plt.tight_layout()
+    plt.show() 
+
+    return plt
+
+#**function: strip spaces at beginning / end of lines; this may be sometimes necessary when reading solutions from files that are space-separated
+#**input:
+#  filename: name of file to process
+#  outputFilename: name of file to which text without leading/trailing spaces is written
+#  fileCommentChar: if not equal '', lines starting with this character will not be processed
+#  removeDoubleChars: if not equal '', this double characters (especial multiple spaces) will be removed; '1.0   3.0' will be converted into '1.0 3.0'
+#**output: new file written
+def FileStripSpaces(filename, outputFilename, fileCommentChar='', removeDoubleChars=''):
+    if filename==outputFilename:
+        raise ValueError('StripSpaces: filename and outputFilename must be different')
+    with open(filename, 'r') as file:
+        lines = file.readlines()
+        with open(outputFilename, 'w') as outfile:
+
+            for line in lines:
+                if fileCommentChar=='' or not (len(line)>=len(fileCommentChar)
+                    and line[0:len(fileCommentChar)] == fileCommentChar):
+
+                    line = line.strip('\n').strip(' ')+'\n'
+                    found = (removeDoubleChars != '')
+                    while found:
+                        if (removeDoubleChars+removeDoubleChars) in line:
+                            line = line.replace(removeDoubleChars+removeDoubleChars,removeDoubleChars)
+                        else: found=False
+                outfile.write(line)
+
+
+#**function: helper function to create data array from outputs defined by sensorNumbers list [+optional positionList which must have, e.g., local arc-length of beam according to sensor numbers]; if time=='', current sensor values will be used; if time!=[], evaluation will be based on loading values from file or sensor internal data and evaluate at that time 
+#**input: 
+#  mbs: a MainSystem where the sensors are given
+#  sensorNumbers: a list of sensor numbers, which shall be evaluated
+#  positionList: an optional list of positions per sensor (e.g., axial positions at beam) 
+#  time: optional time at which the sensor values are evaluated (currently not implemented)
+#**output: returns data as numpy array, containg per row the number or position (positionList) in the first column and all sensor values in the remaining columns
+def DataArrayFromSensorList(mbs, sensorNumbers, positionList=[], time=''):
+    if time != '':
+        raise ValueError("DataArrayFromSensors: time != '' is currently not implemented!")
+    n = len(sensorNumbers)
+    if positionList != [] and (n != len(positionList)):
+        raise ValueError("DataArrayFromSensors: sensorNumbers and positionList must have same dimensions, or positionList must be empty list")
+    
+    data = []
+    
+    for i, sensor in enumerate(sensorNumbers):
+        values = mbs.GetSensorValues(sensor)
+        if type(values) != np.ndarray:
+            values = np.array([values])
+            
+        if i == 0:
+            data = np.zeros((n, 1+len(values)))
+        if positionList != []:
+            data[i,0] = positionList[i]
+        else:
+            data[i,0] = i
+        data[i,1:] = values
+    return data
+
+
+#**function: import image text file as exported from RedrawAndSaveImage() with exportImages.saveImageFormat='TXT'; triangles are converted to lines
+#**input: fileName includes directory
+#**output: returns dictionary with according structures
+def LoadImage(fileName, trianglesAsLines = True, verbose=False):
+        
+    with open(fileName) as file:
+        lines = file.readlines()
+
+    if len(lines) == 0:
+        raise ValueError('LoadImage: empty file')
+
+    if lines[0][:-1] != '#Exudyn text image export file':
+        print('WARNING: LoadImage found inconsistent file header:',lines[0])
+    
+    if lines[-1][:-1] != '#END':
+        print('WARNING: LoadImage found inconsistent file ending; expected "END"')
+    
+    i = 1
+    listLines = []
+    listLineColors = [] #line colors as tuples
+    listTriangles = []
+    nSegments = 0
+    nTriangles = 0
+    actColor = (0,0,0,1)
+    while i < len(lines)-1: #there will be always 1 extra line (or file end)!
+        lineType = lines[i][:-1]
+        data = lines[i+1]
+        if lineType == '#COLOR':
+            actColor = tuple(np.array(data.split(','), dtype=float))
+            # print('color', actColor)
+        elif lineType == '#LINE':
+            splitLine = np.array(data.split(','), dtype=float)
+            listLines += [list(splitLine)]
+            listLineColors += [actColor] #per line
+            nSegments +=int(len(splitLine)/3)-1
+            # print('line', listLines)
+        elif lineType == '#TRIANGLE':
+            nTriangles += 1
+            splitLine = np.array(data.split(','), dtype=float)
+            linePoints = list(np.array(data.split(','), dtype=float))
+            if trianglesAsLines:
+                linePoints += linePoints[0:3] #add first point as last point
+                listLines += [linePoints]
+                listLineColors += [actColor] #per line
+            else:
+               listTriangles += [(list(splitLine), actColor)]
+        else:
+            i -= 1 #this may be a comment line; just increment by 1
+        
+        i += 2 #always increment by 2
+
+    if verbose:
+        print('number of lines:', len(listLines))
+        print('number of line segments:', nSegments)
+        print('number of triangles:', nTriangles)
+        
+    return {'linePoints':listLines, 'lineColors':listLineColors, 'triangles':listTriangles}
+
+#**function: plot 2D or 3D vector image data as provided by LoadImage(...) using matplotlib
+#**input:
+#  imageData: dictionary as provided by LoadImage(...) 
+#  HT: homogeneous transformation, used to transform coordinates; lines are drawn in (x,y) plane
+#  axesEqual: for 2D mode, axis are set equal, otherwise model is distorted
+#  plot3D: in this mode, a 3D visualization is used; triangles are only be displayed in this mode!
+#  lineWidths: width of lines
+#  lineStyles: matplotlib codes for lines
+#  triangleEdgeColors: color for triangle edges as tuple of rgb colors or matplotlib color code strings 'black', 'r', ...
+#  triangleEdgeWidths: width of triangle edges; set to 0 if edges shall not be shown
+#  removeAxes: if True, all axes and background are removed for simpler export
+#  orthogonalProjection: if True, projection is orthogonal with no perspective view
+#  title: optional string representing plot title 
+#  figureName: optional name for figure, if newFigure=True
+#  fileName: if this string is non-empty, figure will be saved to given path and filename (use figName.pdf to safe as PDF or figName.png to save as PNG image); use matplotlib.use('Agg') in order not to open figures if you just want to save them
+#  fontSize: change general fontsize of axis, labels, etc. (matplotlib default is 12, default in PlotSensor: 16)
+#  closeAll: if True, close all figures before opening new one (do this only in first PlotSensor command!)
+#  azim, elev: for 3D plots: the initial angles for the 3D view in degrees
+def PlotImage(imageData, HT = np.eye(4), axesEqual=True, plot3D=False, lineWidths=1, lineStyles='-', 
+              triangleEdgeColors='black', triangleEdgeWidths=0.5, removeAxes = True, orthogonalProjection=True,
+              title = '', figureName='', fileName = '', fontSize = 16, closeAll = False,
+              azim=0., elev=0.):
+
+    from matplotlib import collections  as mc #plot does not accept colors
+    import matplotlib.pyplot as plt
+    import matplotlib
+
+    from exudyn.rigidBodyUtilities import HT2rotationMatrix, HT2translation
+
+    linePoints = imageData['linePoints']
+    lineColors = imageData['lineColors']
+    triangles = imageData['triangles']
+
+    if closeAll:
+        plt.close('all')
+
+    plt.rcParams.update({'font.size': fontSize})
+    fig = plt.figure()
+
+    if figureName!='':
+        if plt.fignum_exists(figureName):
+            plt.close(figureName)
+        fig = plt.figure(figureName)
+    
+    #optional transformation
+    A = HT2rotationMatrix(HT)
+    p0 = HT2translation(HT)
+
+    if not plot3D: #plot in 2D
+        ax = fig.gca()
+        plotData = []
+        colors = []
+        
+        for i, line3D in enumerate(linePoints):
+            # print('line3D:', line3D)
+            nPoints = int(len(line3D)/3)
+    
+            line = (A @ np.array(line3D).reshape((nPoints,3)).T).T.flatten()
+            color = lineColors[i]
+            x = np.zeros(nPoints)
+            y = np.zeros(nPoints)
+            z = np.zeros(nPoints)
+            for j in range(nPoints):
+                x[j] = float(line[j*3+0]+p0[0])
+                y[j] = float(line[j*3+1]+p0[0])
+                z[j] = float(line[j*3+2]+p0[0])
+                
+            for j in range(nPoints-1):
+                plotData += [[(x[j], y[j]), (x[j+1], y[j+1])]] #for plot
+                colors += [color]
+    
+        if plotData != []:
+            collLines = mc.LineCollection(plotData, colors=colors, 
+                                   linewidths=lineWidths, linestyles=lineStyles)
+            ax.add_collection(collLines)
+            if axesEqual:
+                ax.set_aspect('equal', 'box') #for 2D only
+
+        if len(triangles) != 0:
+            print('WARNING: PlotImage: triangles are ignored; they can only be plotted if plot3D=True')
+            
+    else: #plot in 3D
+        ax = fig.gca(projection='3d')
+        plotData = []
+        colors = []
+        from mpl_toolkits.mplot3d.art3d import Line3DCollection
+
+        for i, line3D in enumerate(linePoints):
+            # print('line3D:', line3D)
+            nPoints = int(len(line3D)/3)
+
+            line = (A @ np.array(line3D).reshape((nPoints,3)).T).T.flatten()
+            color = lineColors[i]
+            x = np.zeros(nPoints)
+            y = np.zeros(nPoints)
+            z = np.zeros(nPoints)
+            for j in range(nPoints):
+                x[j] = float(line[j*3+0]+p0[0])
+                y[j] = float(line[j*3+1]+p0[1])
+                z[j] = float(line[j*3+2]+p0[2])
+                
+            for j in range(nPoints-1):
+                plotData += [[(x[j], y[j], z[j]), (x[j+1], y[j+1], z[j])]] #for plot
+                colors += [color]
+
+        if plotData != []:
+            collLines = Line3DCollection(plotData, colors=colors, 
+                                   linewidths=lineWidths, linestyles=lineStyles)
+            ax.add_collection3d(collLines)
+
+        ##Poly3DCollection seems not to work!
+        if len(triangles) != 0:
+            triangle_vertices = []
+            colors = []
+            #from mpl_toolkits.mplot3d import Axes3D
+            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
+            pOff = np.array([list(p0),list(p0),list(p0)]).T
+            for i, trig in enumerate(triangles):
+                trigPoints = (A @ np.array(trig[0]).reshape(3,3).T+pOff).T
+                #trigPoints = np.array(trig[0]).reshape(3,3)
+                triangle_vertices += [trigPoints]
+                colors += [np.array(trig[1][0:3])]
+    
+            # fig = plt.figure()
+            # ax = fig.gca(projection='3d')
+            edgeColors = triangleEdgeColors
+            if lineWidths == 0:
+                edgeColors = 'none'
+            collTrigs = Poly3DCollection(triangle_vertices, facecolors=colors, 
+                                         edgecolors=edgeColors, linewidths=triangleEdgeWidths)
+            collTrigs._facecolors2d = ax._facecolor
+            ax.add_collection(collTrigs)
+
+        ax.view_init(elev=0., azim=0.)
+        if removeAxes:
+            ax.set_axis_off()
+        if orthogonalProjection:
+            ax.set_proj_type('ortho') #this is better for e.g. xy view
+
+        if axesEqual:
+            ax.set_aspect('auto') 
+            ax.set_box_aspect([1,1,1])
+
+        ax.autoscale()
+    #end 3D plotting
+
+    if title!='':
+        plt.title(title)
+
+    plt.autoscale()
+    # plt.margins(0.1)
+
+    plt.tight_layout() #not needed
+    if matplotlib.get_backend() != 'agg': #this is used to avoid showing the figures, if they are just saved
+        plt.show() 
+    
+    if fileName != '':
+        try:
+            os.makedirs(os.path.dirname(fileName), exist_ok=True)
+        except:
+            pass #makedirs may fail on some systems, but we keep going
+        plt.savefig(fileName)
+
+
+
+
```

## exudyn/processing.py

```diff
@@ -1,1310 +1,1316 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  The processing module supports multiple execution of EXUDYN models.
-#           It includes parameter variation and (genetic) optimization functionality.
-#
-# Author:   Johannes Gerstmayr, Stefan Holzinger
-# Date:     2020-11-17 (2022-02-04 modified by Stefan Holzinger)
-# Notes:    Parallel processing, which requires multiprocessing library, can lead to considerable speedup (measured speedup factor > 50 on 80 core machine). The progess bar during multiprocessing requires the library tqdm.
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-import numpy as np
-import sys
-import time
-from copy import deepcopy #, copy 
-import os
-from exudyn.advancedUtilities import IsInteger
-
-#%%+++++++++++++++++++++++++++++++++++++++++++
-#**function: internal function to return Exudyn version string, which allows to identify how results have been obtained
-#            writes something like 'Exudyn version = 1.2.33.dev1; Python3.9.11; Windows AVX2 FLOAT64; Windows10 V10.0.19044; AMD64; Intel64 Family 6 Model 142 Stepping 10, GenuineIntel'
-#**notes: If exudyn C++ module is not available, it outputs the Python version
-def GetVersionPlatformString():
-    sReturn = ''
-    try:
-        import exudyn
-        sReturn += 'Exudyn version = '
-        sReturn += exudyn.GetVersionString(True)
-    except:
-        import sys
-        #the micro version may be different!
-        sReturn += '(no exudyn) Python'+str(sys.version_info.major)+'.'+str(sys.version_info.minor)+'.'+str(sys.version_info.micro)
-        
-    try: #put into try except block to avoid problems with new machines ...
-        import platform
-        sReturn += '; ' + platform.uname().system + platform.uname().release
-        if platform.uname().version != '':
-            sReturn += ' V' + platform.uname().version
-        sReturn += '; ' + platform.uname().machine + '; ' + platform.uname().processor
-    except:
-        pass
-
-    return sReturn
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#*function: internal function; convert single index i into subindices based on given list of ranges in subIndexRanges; return list of subindices for sub ranges; ordering is according to way computed in ParameterVariation
-# try following to see effects: for i in range(100): print(SingleIndex2SubIndices(i,[10,2,3,2]))
-def SingleIndex2SubIndices(i, subIndexRanges):
-    nr = len(subIndexRanges)
-    iRanges=[]
-    for k in range(nr):
-        rem = 1
-        for j in range(k+1,nr):
-            rem *= subIndexRanges[j]
-        # print('k=',k,'rem=',rem)
-        kk = int(i/rem)%subIndexRanges[k]
-        iRanges += [kk]
-    # print('iRanges=',iRanges)
-    return iRanges
-    
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#*function: internal function; add computation Index and parameterFunctionData to dictionry entry
-# 
-def AddComputationIndexAndFunctionData(ind, cnt, addComputationIndex, parameterFunctionData): 
-    if addComputationIndex:
-        ind['computationIndex'] = cnt
-    if bool(parameterFunctionData): # if dict is not empty
-        ind['functionData'] = parameterFunctionData
-    return
-
-
-#%%+++++++++++++++++++++++++++++++++++++++++++
-#function: internal output function for ParameterVariation and GeneticOptimization
-# write header or values to output file and increase counter
-def WriteToFile(resultsFile, parameters, currentGeneration, values, globalCnt, writeHeader = False, fileType='genetic optimization', multiProcessingMode=''):
-    if resultsFile != '':
-        #print('write to file')
-        if writeHeader:
-            try:
-                #check only added in case of writeHeader to reduce overheads; may fail, if no header is written (but why...?)
-                os.makedirs(os.path.dirname(resultsFile), exist_ok=True)
-            except:
-                pass #makedirs may fail on some systems, but we keep going
-
-            file = open(resultsFile, 'w')
-            file.write('#EXUDYN '+fileType+' results file:'+resultsFile+'\n')
-            file.write('#results stored columnwise for every parameter and individual\n')
-            sVersion = GetVersionPlatformString()
-            if multiProcessingMode != '':
-                sVersion += '(processing='+multiProcessingMode+')'
-            file.write('#'+sVersion+'\n')
-            if 'functionData' in parameters:
-                file.write('functionData:'+str(parameters['functionData'])+'\n')
-            else:
-                file.write('#\n')
-            file.write('#columns:\n') #'globalIndex, parameters, computationIndex:\n')
-            s = '#globalIndex,value'
-            for (key,value) in parameters.items():
-                if key != 'functionData':
-                    s += ',' + key
-            s += ',computationIndex'
-            file.write(s+'\n')
-            file.write('#parameter ranges [format: (begin, end, numberOfVariations) or list, parameters separated with ";"]:\n')
-            sep = ''
-            s = '#'
-            for (key,value) in parameters.items():
-                if key != 'functionData':
-                    s += sep + str(value)
-                    sep = ';'
-            file.write(s+'\n')
-            file.close()
-        
-        file = open(resultsFile, 'a')
-        for i in range(len(values)):
-            s = ''
-            s += str(globalCnt) + ', '
-            s += str(values[i])
-            for (key,value) in currentGeneration[i].items():
-                #print(currentGeneration[i])
-                if key != 'functionData':
-                    s += ', ' + str(value)
-            file.write(s+'\n')
-            globalCnt += 1 #for every line of values
-            
-        file.close()
-        #print('... done')
-    return globalCnt
-    
-
-
-#**function: processes parameterFunction for given parameters in parameterList, see ParameterVariation
-#**input:
-#    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
-#    parameterList: list of parameter sets (as dictionaries) which are fed into the parameter variation, see example 
-#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
-#    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
-#    resultsFile: if provided, output is immediately written to resultsFile during processing
-#    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
-#    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
-#    useMPI: if given in **kwargs and set True, and if Python package mpi4py is installed, mpi parallelization is used; for hints see parameterVariationExample.py
-#**output: returns values containing the results according to parameterList
-#**notes: options are passed from Parametervariation
-#**example:
-#def PF(parameterSet):
-#    #in reality, value will be result of a complex exudyn simulation:
-#    value = sin(parameterSet['mass']) * parameterSet['stiffness']
-#    return value
-#
-#values=ProcessParameterList(parameterFunction=PF, 
-#                            parameterList=[{'m':1, 's':100},
-#                                          {'m':2, 's':100},
-#                                          {'m':3, 's':100},
-#                                          {'m':1, 's':200},
-#                                          {'m':2, 's':250},
-#                                          {'m':3, 's':300},
-#                                          ], useMultiProcessing=False )
-def ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, clusterHostNames=[], **kwargs):
-    values = [] #create empty list
-    nVariations = len(parameterList)
-    #print("pl=",parameterList)
-    showProgress = False
-    if 'showProgress' in kwargs: 
-        showProgress = kwargs['showProgress']
-
-    resultsFile = ''
-    if 'resultsFile' in kwargs: 
-        resultsFile = kwargs['resultsFile']
-
-    parameters = {}
-    if 'parameters' in kwargs: 
-        parameters = kwargs['parameters']
-
-    useCluster = (clusterHostNames != []) and useMultiProcessing
-    if useCluster:
-        try:
-            import dispy
-        except:
-            print('WARNING: ProcessParameterList: dispy is not installed (try: pip install dispy); switching to multiprocessing mode instead')
-            useCluster = False
-
-    useMPI = False
-    if 'useMPI' in kwargs and useMultiProcessing:
-        useMPI = kwargs['useMPI']
-        if useMPI:
-            try:
-                from mpi4py.futures import MPIPoolExecutor
-            except:
-                print('WARNING: ProcessParameterList: mpi4py is not installed or mpi4py.futures not available (try: conda install mpi4py); switching to multiprocessing mode instead')
-                useMPI = False
-
-    useTQDM = False
-    if showProgress and useMultiProcessing and not useCluster:
-        try:
-            import tqdm #progress bar
-            try: #_instances only available after first run!
-                tqdm.tqdm._instances.clear() #if open instances of tqdm, which leads to nasty newline
-            except:
-                pass
-            useTQDM = True
-        except:
-            pass
-            #print("module 'tqdm' not available (use pip to install); progress bar not shown")
-
-    resultsFileCnt = 0 #counter for results file; used in several if branches
-
-    if not useCluster and not useMPI:
-        if not useMultiProcessing:
-            for i in range(nVariations):
-                currentParameters = parameterList[i]
-                v = parameterFunction(currentParameters)
-                values += [v]
-                if showProgress:
-                    printStr = ''
-                    if (type(v) == float) or (type(v) == int):
-                        printStr = ', value = '+str(v)
-                    if 'functionData' in currentParameters: #functionData may be large, DO not print!
-                        copyParameters = {}
-                        for key, value in currentParameters.items():
-                            if key != 'functionData':
-                                copyParameters[key] = value
-                        printStr += ": parameters=" + str(copyParameters)
-                    else:
-                        printStr += ": parameters=" + str(currentParameters)
-                    
-                    print("\rrun ", i+1, "/", nVariations, printStr, '                ', end='', flush=True)
-                if resultsFile != '':
-                    resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
-                                              [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
-                                              fileType='parameter variation',
-                                              multiProcessingMode='serial')
-            if showProgress:
-                print("", flush=True) #newline after tqdm progress bar output....
-        else:
-            from multiprocessing import Pool, cpu_count #parallelization of computation
-           
-            numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
-            if 'numberOfThreads' in kwargs: 
-                numberOfThreads = kwargs['numberOfThreads']
-            
-            vInput = np.array(parameterList)
-                
-            if useTQDM:
-                with Pool(processes=numberOfThreads) as p:
-                    #values = list(tqdm.tqdm(p.imap(parameterFunction, vInput), total=nVariations))
-                    for v in (tqdm.tqdm(p.imap(parameterFunction, vInput), total=nVariations)):
-                        values+=[v]
-                        if resultsFile != '':
-                            resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
-                                                      [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
-                                                      fileType='parameter variation',
-                                                      multiProcessingMode='multiprocessing.Pool, numberOfThreads='+str(numberOfThreads))
-                print("", flush=True) #newline after tqdm progress bar output....
-            else:
-                #simpler approach without tqdm:
-                # with Pool(processes=numberOfThreads) as p:
-                #     values = p.map(parameterFunction, vInput)
-                with Pool(processes=numberOfThreads) as p:
-                    for v in p.imap(parameterFunction, vInput):
-                        values+=[v]
-                        if resultsFile != '':
-                            resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
-                                                      [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
-                                                      fileType='parameter variation',
-                                                      multiProcessingMode='multiprocessing.Pool, numberOfThreads='+str(numberOfThreads))
-                            #print("value=",i)
-    elif useCluster: 
-        
-        # form cluster and submit jobs
-        cluster = dispy.JobCluster(parameterFunction, nodes=clusterHostNames, host=clusterHostNames, cleanup=True, dispy_port=9700) 
-        
-        # import dispy's httpd module, create http server for this cluster
-        # monitor allows to monitor and manage clusters with a web browser; it works with common web browsers, including in iOS and Android devices.
-        http_server = None
-        if 'useDispyWebMonitor' in kwargs: #showProgress: #True:
-            if showProgress:
-                print('open http monitor')
-            import dispy.httpd
-            import socket
-            clientHostname = socket.gethostname()
-            http_server = dispy.httpd.DispyHTTPServer(cluster, host=clientHostname, port=8181, poll_sec=5) 
-            import webbrowser
-            clientIPv4Address = socket.gethostbyname(clientHostname)
-            webbrowser.open("http://"+clientIPv4Address+":8181/monitor.html")
-        
-        # perform computations
-        nVariations = len(parameterList)
-        jobs = [None]*nVariations
-        for i in range(nVariations):
-            
-            # submit job to cluster
-            job = cluster.submit(parameterList[i]) #, refSol=referenceSolution) 
-            jobs[i] = job
-            job.id = i+1
-
-        #cluster.wait() # waits until all jobs finish
-        
-        # collect return value of each job      
-        values = [None]*len(jobs)  
-        
-        jobCtr = 0        
-        for job in jobs:     
-            #host, val = job()
-            val = job()
-            values[jobCtr] = val
-            jobCtr += 1
-            if showProgress:
-                #show return values only in case that they are of float type
-                if (type(job.result) == float) or (type(job.result) == int):
-                    print('executed job '+str(job.id) + ' / ' + str(nVariations) +
-                          ' with return value ' + str(job.result))
-                else:
-                    print('executed job ' + str(job.id) + ' / ' + str(nVariations))
-        
-        # close cluster
-        cluster.wait()
-        if showProgress:
-            cluster.print_status()
-        
-        if http_server != None:
-            http_server.shutdown() # this waits until browser gets all updates
-        cluster.close()
-    elif useMPI:
-        #numberOfThreads not used in this case; given by mpiexec call
-
-        vInput = np.array(parameterList)
-
-        from mpi4py import MPI
-        
-        comm = MPI.COMM_WORLD
-        nprocs = comm.Get_size()
-        # rank   = comm.Get_rank() 
-        
-        if useTQDM:
-
-            with MPIPoolExecutor() as p:
-            # with Pool(processes=numberOfThreads) as p:
-                for v in (tqdm.tqdm(p.map(parameterFunction, vInput), total=nVariations)):
-                    values+=[v]
-                    if resultsFile != '':
-                        resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
-                                                  [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
-                                                  fileType='parameter variation',
-                                                  multiProcessingMode='mpi4py, numberOfWorkers='+str(nprocs))
-            print("", flush=True) #newline after tqdm progress bar output....
-        else:
-            #simpler approach without tqdm:
-            # with Pool(processes=numberOfThreads) as p:
-            #     values = p.map(parameterFunction, vInput)
-            with MPIPoolExecutor() as p:
-                for v in p.map(parameterFunction, vInput):
-                    values+=[v]
-                    if resultsFile != '':
-                        resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
-                                                  [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
-                                                  fileType='parameter variation',
-                                                  multiProcessingMode='mpi4py, numberOfWorkers='+str(nprocs))
-
-            
-    return values
-
-
-
-#**function: calls successively the function parameterFunction(parameterDict) with variation of parameters in given range; parameterDict is a dictionary, containing the current values of parameters,
-#  e.g., parameterDict=['mass':13, 'stiffness':12000] to be computed and returns a value or a list of values which is then stored for each parameter
-#**input:
-#    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
-#    parameters: given as a dictionary, consist of name and tuple of (begin, end, numberOfValues) same as in np.linspace(...), e.g. 'mass':(10,50,10), for a mass varied from 10 to 50, using 10 steps OR a list of values [v0, v1, v2, ...], e.g. 'mass':[10,15,25,50]
-#    useLogSpace: (optional) if True, the parameters are varied at a logarithmic scale, e.g., [1, 10, 100] instead linear [1, 50.5, 100]
-#    debugMode: if True, additional print out is done
-#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
-#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
-#    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
-#    resultsFile: if provided, output is immediately written to resultsFile during processing
-#    numberOfThreads: default(None): same as number of cpus (threads); used for multiprocessing lib;
-#    parameterFunctionData: dictionary containing additional data passed to the parameterFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
-#    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
-#    useDispyWebMonitor: if given in **kwargs, a web browser is started in case of cluster computation to manage the cluster during computation
-#    useMPI: if given in **kwargs and set True, and if Python package mpi4py is installed, mpi parallelization is used; for hints see parameterVariationExample.py
-#**output:
-#    returns [parameterList, values], containing, e.g., parameterList=\{'mass':[1,1,1,2,2,2,3,3,3], 'stiffness':[4,5,6, 4,5,6, 4,5,6]\} and the result values of the parameter variation accoring to the parameterList, 
-#           values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
-#**example:
-#if __name__ == '__main__':
-#    ParameterVariation(parameterFunction=Test, 
-#                       parameters={'mass':(1,10,10), 'stiffness':(1000,10000,10)}, 
-#                       useMultiProcessing=True)
-def ParameterVariation(parameterFunction, parameters, 
-                       useLogSpace=False, debugMode=False, addComputationIndex=False,
-                       useMultiProcessing=False, showProgress = True, parameterFunctionData={}, clusterHostNames=[],
-                       numberOfThreads=None, resultsFile='', **kwargs):
-    
-    if 'multiprocessing' in sys.modules:
-        from multiprocessing import cpu_count
-        if numberOfThreads == None:
-            numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
-        if debugMode:
-            if clusterHostNames == []:
-                print("using", numberOfThreads, "cpus")
-            else:
-                print("using cluster")
-    if numberOfThreads == None:
-        numberOfThreads = 8 #just some default, if no other value available
-
-    #generate list of parameters to iterate
-    dim = len(parameters)       #dimensionality (dimension) of problem
-    nParams = np.zeros(dim, dtype=int)     #number of variations in each dimension
-    cnt = 0
-    for (key,value) in parameters.items(): 
-        if isinstance(value, tuple): #then it is a range (start, end, numberOfValues)
-            nParams[cnt] = value[2] #last value is the number of variations
-        elif isinstance(value, list): #then it contains list of values, e.g., [1,2,4,8]
-            nParams[cnt] = len(value) #last value is the number of variations
-        else:
-            raise ValueError('ParameterVariation: parameters must contain tuple with range (begin, end, numberOfValues) or list of values [v0, v1, v2, ...]')
-        cnt+=1 #counts the dimensionality
-        
-        
-    nVariations = np.array(nParams).prod() #product of all ranges gives total count
-    if nVariations == 0:
-        print("WARNING: number of variations =", nVariations)
-        return []
-
-    if debugMode:
-        print("number of variations =", nVariations)
-
-    cnt = 0
-    isIntType = [False] * dim # true if corresponding parameter ranges/list is all int type
-    parameterDict = {} #dictionary of parameter lists
-    for (key,value) in parameters.items():
-        if isinstance(value, tuple): #then it is a range (start, end, numberOfValues)
-            pStart = value[0]
-            pEnd = value[1]
-            numberOfValues = value[2]
-
-            if numberOfValues == 0:
-                raise ValueError('ParameterVariation: in tuples (begin, end, numberOfValues), numberOfValues may not be zero')
-            if int(numberOfValues) != numberOfValues:
-                raise ValueError('ParameterVariation: in tuples (begin, end, numberOfValues), numberOfValues must be integer')
-            if pStart > pEnd:
-                raise ValueError('ParameterVariation: in tuples (begin, end, numberOfValues), there must be begin <= end')
-        
-            step = (pEnd-pStart+1)/numberOfValues # is for check if numberOfValues is even
-            if IsInteger(pStart) and IsInteger(pEnd) and step == int(step): # is true, if ranges/list are all int and step is integer
-                isIntType[cnt] = True 
-
-            #now create list of parameters, using duplicates according to dimensionality
-            if useLogSpace:
-                space = np.logspace(np.log10(pStart),np.log10(pEnd),numberOfValues)
-            else:
-                space = np.linspace(pStart,pEnd,numberOfValues)
-        else: #already checked above: if isinstance(value, list): #then it contains list of values, e.g., [1,2,4,8]
-            space = value
-            isIntType[cnt] = True
-            for val in value:
-                if not IsInteger(val):
-                    isIntType[cnt] = False
-            
-        range1 = nParams[0:cnt].prod()
-        range2 = nParams[cnt+1:dim+1].prod()
-        if range1 == 0:
-            range1 = 1 #otherwise kronecker product won't work
-        if range2 == 0:
-            range2 = 1 #otherwise kronecker product won't work
-            
-        #print("space=",space)
-        
-        parameterDict[key] = np.kron(np.kron([1]*range1, space), [1]*range2)
-        cnt+=1 #counts the dimensionality
-
-    if debugMode:
-        print("parameterDict =", parameterDict)
-
-    if addComputationIndex:
-        parameterDict['computationIndex'] = np.linspace(0,nVariations-1,nVariations,dtype=int)
-        
-    #finally convert parameter dictinary to list of dictionaries:
-    parameterList = [] #list of parameter dictionaries
-    for i in range(nVariations):
-        parameterSet = {}
-        cnt = 0
-        for (key,value) in parameterDict.items(): 
-            if key == 'computationIndex':
-                v = int(value[i]) #make integers, which follow type(v)==int
-            elif isIntType[cnt]: # check if this variable is an integer type
-                v = int(value[i]) #make integers, which follow type(v)==int
-            else:
-                v = float(value[i]) #make floats, which follow type(v)==float
-            parameterSet[key] = v
-            cnt += 1
-        if parameterFunctionData != {}:
-            parameterSet['functionData'] = parameterFunctionData
-            #not needed: parameterSet['functionData'] = copy.deepcopy(parameterFunctionData)
-            
-        parameterList += [parameterSet]
-
-    values = ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, 
-                                  showProgress = showProgress, numberOfThreads=numberOfThreads,
-                                  resultsFile = resultsFile, parameters=parameters, 
-                                  clusterHostNames=clusterHostNames, **kwargs)
-    
-    return [parameterDict, values]
-    
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute minimum of given objectiveFunction
-#**input:
-#    objectiveFunction: function, which takes the form parameterFunction(parameterDict) and which returns a value or list (or numpy array) which reflects the size of the objective to be minimized
-#    parameters: given as a dictionary, consist of name and tuple containing the search range for this parameter (begin, end), e.g. 'mass':(10,50)
-#
-#    populationSize: individuals in every generation
-#    initialPopulationSize: number of random initial individuals; default: population size
-#    numberOfGenerations: number of generations; NOTE: it is required that elitistRatio*populationSize >= 1
-#    elitistRatio: the number of surviving individuals in every generation is equal to the previous population times the elitistRatio
-#    crossoverProbability: if > 0: children are generated from two (randomly selected) parents by gene-crossover; if 0, no crossover is used
-#    crossoverAmount: if crossoverProbability > 0, then this amount is the probability of genes to cross; 0.1: small amount of genes cross, 0.5: 50\% of genes cross
-#    rangeReductionFactor: reduction of mutation range (boundary) relative to range of last generation; helps algorithm to converge to more accurate values
-#    distanceFactor: children only survive at a certain relative distance of the current range; must be small enough (< 0.5) to allow individuals to survive; ignored if distanceFactor=0; as a rule of thumb, the distanceFactor should be zero in case that there is only one significant minimum, but if there are many local minima, the distanceFactor should be used to search at several different local minima
-#    childDistribution: string with name of distribution for producing childs: "normal" (Gaussian, with sigma defining range), "uniform" (exactly in range of childs)
-#    distanceFactorGenerations: number of generations (populations) at which the distance factor is active; the distance factor is used to find several local minima; finally, convergence is speed up without the distance factor
-#    parameterFunctionData: dictionary containing additional data passed to the objectiveFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
-#    randomizerInitialization: initialize randomizer at beginning of optimization in order to get reproducible results, provide any integer in the range between 0 and 2**32 - 1 (default: no initialization)
-#
-#    debugMode: if True, additional print out is done
-#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
-#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
-#    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
-#    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
-#    resultsFile: if provided, the results are stored columnwise into the given file and written after every generation; use resultsMonitor.py to track results in realtime
-#    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
-#    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
-#**output:
-#    returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
-#           values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
-#**notes: This function is still under development and shows an experimental state! 
-#**example:
-#GeneticOptimization(objectiveFunction = fOpt, parameters={'mass':(1,10), 'stiffness':(1000,10000)})
-def GeneticOptimization(objectiveFunction, parameters, 
-                        populationSize=100,
-                        numberOfGenerations=10,
-                        elitistRatio = 0.1,
-                        crossoverProbability=0.25,
-                        crossoverAmount=0.5,
-                        rangeReductionFactor=0.7,
-                        distanceFactor=0.1,
-                        childDistribution="uniform",  
-                        distanceFactorGenerations=-1,
-                        debugMode=False, 
-                        addComputationIndex=False,
-                        useMultiProcessing=False, 
-                        showProgress = True,
-                        clusterHostNames = [],
-                        parameterFunctionData = {}, 
-                        **kwargs):
-
-    def RandomNumber(distribution, rangeBegin, rangeEnd, vMin, vMax):
-        a = rangeBegin
-        b = rangeEnd
-        value = vMax + 1
-        while (value < vMin or value > vMax):
-            if distribution == 'uniform':
-                value = np.random.uniform(a, b)
-            elif distribution == 'normal':
-                value = np.random.normal(loc = 0.5*(a+b), scale = 0.5*(b-a))
-            else:
-                raise ValueError('GeneticOptimization: invalid childDistribution "'+childDistribution+'"')
-        
-        return value
-        
-    
-    #get number of threads:
-    if 'multiprocessing' in sys.modules:
-        from multiprocessing import cpu_count
-        numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
-    else:
-        numberOfThreads = 8
-    if 'numberOfThreads' in kwargs: 
-        numberOfThreads = kwargs['numberOfThreads']
-
-    if useMultiProcessing:
-        if clusterHostNames==[]:
-            print("number of threads used =", numberOfThreads,flush=True) #very useful information
-        else:
-            print("using cluster",flush=True) 
-            
-
-    useDispyWebMonitor = False
-    if 'useDispyWebMonitor' in kwargs: 
-        useDispyWebMonitor = kwargs['useDispyWebMonitor']
-
-    initialPopulationSize = populationSize
-    if 'initialPopulationSize' in kwargs: 
-        initialPopulationSize = kwargs['initialPopulationSize']
-
-    resultsFile = ''
-    if 'resultsFile' in kwargs: 
-        resultsFile = kwargs['resultsFile']
-
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-    #delete this in future:
-    if 'numberOfChildren' in kwargs: 
-        print("GeneticOptimization: deprecated and unused parameter; use population size a and elitistRatio instead\n")
-    
-    #old value: survivingIndividuals=8
-    survivingIndividuals = int(elitistRatio*populationSize)
-    if 'survivingIndividuals' in kwargs: 
-        survivingIndividuals = kwargs['survivingIndividuals']
-        print("GeneticOptimization: survivingIndividuals: deprecated parameter; use population size a and elitistRatio instead\n")
-
-
-    if 'randomizerInitialization' in kwargs: 
-        randomizerInitialization = kwargs['randomizerInitialization']
-        if not isinstance(randomizerInitialization,int):
-            raise ValueError("GeneticOptimization: ERROR: randomizerInitialization must be positive 32 bit integer")
-        np.random.seed(randomizerInitialization)
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-    #check that there are surviving individuals at all (otherwise hangs...)
-    if survivingIndividuals < 1:
-        elitistRatio = 1/populationSize
-        survivingIndividuals = 1
-        print("WARNING: elitistRatio*populationSize < 1. Setting elitistRatio=", elitistRatio,'\n')
-
-    if distanceFactor >= 1:
-        distanceFactor = 0.5
-        print("WARNING: distanceFactor >= 1, setting distanceFactor = 0.5\n")
-
-    if distanceFactorGenerations < 0:
-        distanceFactorGenerations = numberOfGenerations+1 #will be never active
-
-    dim = 0
-    ranges = []                 #list containing the ranges of each dimension
-    rangesDict = {} #dict containing only the ranges
-    for (key,value) in parameters.items():
-        dim += 1 #count dimensions of parameters
-        r = value[1]-value[0]
-        if r <= 0:
-            raise ValueError("GeneticOptimization: ERROR: range of component "+str(dim-1)+" has negative or zero range")
-        ranges += [r]
-        rangesDict[key] = r
-    
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-    #generate first generation:
-    currentGeneration = []
-    for i in range(initialPopulationSize):
-        ind = {} #dictionary for individual
-        for (key,value) in parameters.items():
-            pBegin = value[0]
-            pEnd = value[1]
-            value = np.random.uniform(pBegin, pEnd)
-            ind[key] = value
-        AddComputationIndexAndFunctionData(ind, i, addComputationIndex, parameterFunctionData)
-        currentGeneration += [ind]
-    #+++++++++++++++++++++++++++++++++++++++++++++++
-
-    if debugMode:
-        if initialPopulationSize <= 50:
-            print("initial population =", currentGeneration)
-        print("rangesDict =", rangesDict)
-
-    parametersAll = []
-    valueList = []
-    newGeneration = []      #surviving individuals, not re-computed!
-    newGenerationValues = []#surviving individuals' values, not re-computed!
-    
-    totalEvaluations = 0
-    resultsFileCnt = 0 #counter for output file
-
-    for popCnt in range(numberOfGenerations):
-        if debugMode:
-            print("===============\nevaluate population", popCnt, ":")
-
-        totalEvaluations += len(currentGeneration)
-        values = ProcessParameterList(objectiveFunction, currentGeneration, useMultiProcessing, showProgress = showProgress, numberOfThreads=numberOfThreads,
-                                      clusterHostNames=clusterHostNames, useDispyWebMonitor=useDispyWebMonitor)
-
-        if (showProgress and useMultiProcessing and popCnt < numberOfGenerations-1): print("            #"+str(popCnt+1), end='')
-        #print("values=",values)
-        multiProcessingMode = ''
-        if useMultiProcessing:
-            multiProcessingMode = 'multiprocessing.Pool, numberOfThreads='+str(numberOfThreads)
-        resultsFileCnt = WriteToFile(resultsFile, parameters, currentGeneration, values, resultsFileCnt, 
-                                     writeHeader = (popCnt == 0),
-                                     multiProcessingMode=multiProcessingMode)
-
-        #remove computationIndex and parameterfunctiondata from new generation
-        for item in currentGeneration:
-            if 'computationIndex' in item:
-                del item['computationIndex']
-            if 'functionData' in item: 
-                del item['functionData']
-
-        #store all values
-        parametersAll += currentGeneration.copy()
-        valueList += values.copy()
-
-        #add best individuals from previous parents:
-        currentGeneration += newGeneration.copy()
-        values += newGenerationValues.copy()
-        
-        #compute norm and minimum values:
-        scalarValues = [(0,0)]*len(values)
-        for i in range(len(values)):
-            item = values[i]
-            if isinstance(item, float):
-                scalarValues[i] = (item,i)
-            else: #must be list of values ==> compute norm!
-                scalarValues[i] = (np.sqrt(np.dot(item,item)),i)
-
-        valuesDtype = [('value', float), ('index', int)]
-        scalarValues = np.array(scalarValues, dtype = valuesDtype)
-
-        sortedValues = np.sort(scalarValues, order='value') #sort for item values
-        #print("scalarValues=",scalarValues)
-        #print("sortedValues=",sortedValues)
-
-        if popCnt < numberOfGenerations-1: #go on for next population
-            relativeRange = rangeReductionFactor**(popCnt+1) #this is the relative range for the next population
-
-            if debugMode:
-                print("Child ranges in population",popCnt)
-                for (key,value) in parameters.items():
-                    r = value[1]-value[0]
-                    r *= relativeRange #reduce range
-                    print('  '+key+':', r)
-            
-            #selection: chose best surviving individuals
-            newGeneration = []
-            newGenerationValues = []
-            cnt = 0
-
-            if distanceFactor == 0 or popCnt >= distanceFactorGenerations: #distance not important
-                for i in range(min(survivingIndividuals,len(sortedValues))):
-                    ind = currentGeneration[int(sortedValues[i][1])] #dictionary for individual
-                    if addComputationIndex:
-                        ind['computationIndex'] = cnt #unique index for one set of computations
-                    newGeneration += [ind]
-                    newGenerationValues += [values[int(sortedValues[i][1])]]
-                    cnt += 1
-            else:
-                nSurviving = min(survivingIndividuals,len(sortedValues))
-                nGen = len(currentGeneration)
-                j = 0 #index counter
-                i = 0 #counter for surviving individuals to be found
-                distanceList = [1]*nGen #initialize with one, saying that all distances large enough #relativeRange*np.reshape(ranges*dim,(nGen, dim)) #these are the maximum distances
-                
-                #print("nSurviving=",nSurviving)
-                #print("len(sortedValues)=",len(sortedValues))
-                #find indices which have sallest objective function value, but obey distanceFactor
-                while i < nSurviving and j < len(sortedValues):
-                    iInd = int(sortedValues[j][1]) #index for individual in currentGeneration
-                    ind = currentGeneration[iInd] #dictionary for individual
-                    j += 1
-                    if distanceList[iInd] > distanceFactor:
-                        if addComputationIndex:
-                            ind['computationIndex'] = cnt #unique index for one set of computations
-                        newGeneration += [ind]
-                        newGenerationValues += [values[iInd]]
-                        cnt += 1 #computation index counter
-                        i += 1   #counts the surviving individuals
-                        #print("\nadd individual", ind)
-                        #print("currentGeneration", currentGeneration)
-                        
-                        #update distances for added individual:
-                        for k in range(nGen):
-                            d = 0
-                            for (key,value) in ind.items():
-                                if key != 'computationIndex' and key in parameters.keys(): # only manipulate values from given parameters
-                                    d += (ind[key] - currentGeneration[k][key])**2/(rangesDict[key])**2
-                            d = np.sqrt(d/dim) #number of parameters shall not influence distanceFactor
-                            #print("d=",d,":",ind,"-",currentGeneration[k])
-                            if d < distanceList[k]:
-                                distanceList[k] = d
-                    # else:
-                    #     print("\nindiv.",ind," ignored due to small distance:", distanceList[iInd])
-                        
-                    #print("distanceList=",distanceList)
-            
-            #print("survivingIndividuals=",newGeneration)
-            if debugMode:
-                print("\nbest values=",sortedValues[0:min(survivingIndividuals,4)])
-            
-            #prolongate best individuals:
-            currentGeneration = []
-            # for item in newGeneration: #removed, in order to save number of evaluations
-            #     currentGeneration += [item]
-    
-            #modification of parents
-            genSize = len(newGeneration)
-            if genSize == 0:
-                print("WARNING: size of generation = 0, terminating (check your optimization parameters...)\n")
-                
-            p = 0 #current population size
-            while p < populationSize and genSize != 0:
-                for item in newGeneration:
-                    indList = [{}]      #dictionary for individual
-                    parents = [item]    #list of parents
-
-                    #do gene crossing fro parents:
-                    if crossoverProbability > 0:
-                        r = np.random.random()
-                        if r < crossoverProbability: #do cross-over only for a smaller portion of parents!
-                            indList += [{}] #use two new individuals with gene-crossover
-                            rand0 = np.random.randint(genSize)
-                            rand1 = np.random.randint(genSize) #may be same as rand1
-                            p0 = newGeneration[rand0].copy() #parent1 for crossover
-                            p1 = newGeneration[rand1].copy() #parent2 for crossover
-                            parents = [p0, p1]
-                            for (key,value) in parameters.items():
-                                r = np.random.random()
-                                if r < crossoverAmount: #usually 50% gene cross over
-                                    indList[0][key] = p1[key] #uniform gene crossing
-                                    indList[1][key] = p0[key]
-                            # print('indList=',indList)
-
-                    #one or two individuals
-                    for pi in range(len(parents)):
-                        item = parents[pi]
-                        for (key,value) in parameters.items():
-                            r = value[1]-value[0]
-                            r *= relativeRange #reduce range
-                            #print("range=",r)
-                            pBegin = item[key]-0.5*r #minimum value
-                            pEnd = item[key]+0.5*r 
-                            #obej ranges: ==> this may give more values at boundary
-                            if pBegin < value[0]: pBegin = value[0]
-                            if pEnd > value[1]: pEnd = value[1]
-    
-                            #print("new range=",pBegin,pEnd)
-                            #value = np.random.uniform(pBegin, pEnd)
-                            newValue = RandomNumber(childDistribution, 
-                                                 pBegin, pEnd, 
-                                                 value[0], value[1])
-                            indList[pi][key] = newValue
-    
-                        if p < populationSize:
-                            newGen = {}
-                            for (key,value) in parameters.items(): #sort according to parameters, for output file!
-                                newGen[key] = indList[pi][key]
-                            if addComputationIndex:
-                                newGen['computationIndex'] = cnt #unique index for one set of computations
-                            currentGeneration += [newGen]
-                            #currentGeneration += [indList[pi]] #gives wrong sorting in dict ..., destroys output file order
-                            p += 1
-                        indList[-1]['functionData'] = parameterFunctionData # add function data
-                        cnt += 1 #computation count ... for every parameter variation within one generation
-            # print("pop", popCnt, ": currentGeneration=\n",currentGeneration)
-        else:
-            #select final best individual
-            optimumParameter = currentGeneration[int(sortedValues[0][1])]
-            optimumValue = sortedValues[0][0]
-            if debugMode:
-                print("opt par=", optimumParameter, ", opt val=", optimumValue)
-
-    if debugMode:
-        print("===============\ntotal evaluations=", totalEvaluations)
-
-    #now make dict of parameter lists instead list of dicts
-    parameterList = {}
-    n = len(parametersAll)
-    if n != 0:
-        for key in parametersAll[0]:
-            if key != 'computationIndex' and key in parameters.keys(): # do not output function data
-                parameterData = np.zeros(n)
-                #extract parameter list from list of dictionaries:
-                for i in range(n):
-                    parameterData[i] = parametersAll[i][key]
-    
-                #add parameter list to final dictionary
-                parameterList[key] = parameterData
-
-
-    return [optimumParameter, optimumValue, parameterList, valueList]
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: Compute minimum of given objectiveFunction. This function is based on scipy.optimize.minimize() and it provides the same interface as GeneticOptimization(). Note that in special cases, you should copy this function and adapt to your needs.
-#**input:
-#    objectiveFunction: function, which takes the form parameterFunction(parameterDict) and which returns a value or list (or numpy array) which reflects the size of the objective to be minimized
-#    parameters: given as a dictionary, consist of name and tuple containing the search range for this parameter (begin, end), e.g. 'mass':(10,50)
-#    storeFunctionValues: if True, objectiveFunction values are computed (additional costs!) and stored in every iteration into valueList
-#    initialGuess: initial guess. Array of real elements of size (n,), where 'n' is the number of independent variables. If not provided by the user, initialGuess is computed from bounds provided in parameterDict.
-#    method: solver that should be used, e.g. 'Nelder-Mead', 'Powell', 'CG' etc. A list of available solvers can be found in the documentation of scipy.optimize.minimize().
-#    tol: tolerance for termination. When tol is specified, the selected minimization algorithm sets some relevant solver-specific tolerance(s) equal to tol (but this is usually not the tolerance for loss or parameters1). For detailed control, use solver-specific options using the 'options' variable.
-#    options: dictionary of solver options. Can be used to set absolute and relative error tolerances. Detailed information can be found in the documentation of scipy.optimize.minimize().
-#    enforceBounds: if True, ensures that only parameters within the bounds specified in ParameterDict are used for minimization; this may help to avoid, e.g., negative values, but may lead to non-convergence 
-#    verbose: prints solver information into console, e.g. number of iterations 'nit', number of funcion evaluations 'nfev', status etc.
-#    showProgress: if True, shows for every iteration objective function value, current iteration number, time needed for current iteration, maximum number of iterations and loss (current value of objective function)
-#    addComputationIndex: if True, key 'computationIndex' is added for consistency reasons with GeneticOptimizaiton to every parameterDict in the call to parameterFunction(); however, the value is always 0, because no multi threading is used in Minimize(...)
-#    resultsFile: if provided, the results are stored columnwise into the given file and written after every generation; use resultsMonitor.py to track results in realtime
-#    useScipyBounds: if True, use scipy.optimize.minimize() option 'bounds' to apply bounds on variable specified in ParameterDict. Note, this option is only used by some specific methods of scipy.optimize.minimize()! method='Nelder-Mead' ignores this option for example! if False, option 'enforceBounds' will be set to False!
-#    args: extra arguments passed to the objective function and its derivatives (fun, jac and hess functions). 
-#**author: Stefan Holzinger, Johannes Gerstmayr
-#**output: returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
-#**notes: This function is still under development and shows an experimental state! There are currently unused arguments of scipy.optimize.minimize(): Detailed information can be found in the documentation of scipy.optimize.minimize().
-def Minimize(objectiveFunction, parameters, initialGuess=[], method='Nelder-Mead', tol=1e-4, options={}, 
-             enforceBounds=True, debugMode=False, showProgress=True, addComputationIndex=False,
-             storeFunctionValues=True, **kwargs):
-    from scipy import optimize #for minimize
-    # from functools import partial #add extra args to function
-    
-    # get parameter names
-    parKeyLst = list(parameters.keys())
-    initialGuessCopy = list(initialGuess)
-    
-    # number of parameters
-    nParameters = len(parKeyLst)
-    
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    resultsFile = '' # if resultsFile name is provided, write solution to resultsFile
-    if 'resultsFile' in kwargs: 
-        resultsFile = kwargs['resultsFile']
-    
-    maxiter = 200*nParameters # maximum iterations used by th solver (default value of method='Nelder-Mead')
-    if 'maxiter' in options:
-        maxiter = options['maxiter']
-    
-    
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # get boundaries ((min, max), ... ,(min, max))
-    bounds = [None]*nParameters 
-    for i in range(nParameters):
-        bounds[i] = parameters[parKeyLst[i]]    
-    bounds = tuple(bounds) # type cast: list --> tuple
-    
-    useScipyBounds = False
-    scipyMinimizeBounds = None # 'bounds' option of scipy.optimize.minimize() will not be used!
-    if 'useScipyBounds' in kwargs: 
-        if kwargs['useScipyBounds']:
-            useScipyBounds = True
-            scipyMinimizeBounds = bounds # use option 'bounds'
-        
-    
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # process initial guess
-    if initialGuessCopy == []: # initial guess has been provided by the user
-        initialGuessCopy = [None]*nParameters
-        for i in range(nParameters):
-            initialGuessCopy[i] = np.mean(bounds[i])
-
-
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #create lists for output
-    parameterValueLst = [None]*nParameters # type=list(list()); contains parameter values for each iteration
-    for i in range(nParameters):
-        parameterValueLst[i] = []
-    valueList = [] # objective function value for initial guess parameters
-
-
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # map initialGuess list --> dict 
-    def ParameterListToParameterDict(initialGuess, *args):
-        paraDict = {}
-        for i in range(nParameters):
-            paraDict[parKeyLst[i]] = initialGuess[i]
-
-        if addComputationIndex: # add computation index
-            paraDict['computationIndex'] = 0 #itCtr[0]
-        
-        return paraDict
-         
-    
-    # count number of iterations
-    itCtr = [0]
-    resultsFileCnt = [0] # counter for output file
-
-    # this function is a inerface to exudyn.processing.WriteToFile()
-    def WriteToFileMinimize(resFileName, parDictInit, pDict, objFunVal, resFileCnt):       
-        resultsFileCntTemp = WriteToFile(resFileName, 
-                                         parDictInit, # parameter dict with value range supplied by user
-                                         [pDict], # parameter values 
-                                         [objFunVal], # objective function values
-                                         resFileCnt, # line counter --> write data to file at this line
-                                         writeHeader = (resFileCnt == 0), 
-                                         fileType='optimization using scipy.optimize.minimize(method='+method+')',
-                                         )
-        return resultsFileCntTemp
-
-    startTime = time.time()  #for calculating time to go
-    timePrintLast = [startTime-10]
-
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # callback: needed to get parameters after each iteration for file writing and post processing
-    def StoreParameterFunctionValues(parametersAtIteration, convergence=0, lastTime=False):
-        #global timePrintLast
-        # print(parametersAtIteration2)
-        for i in range(nParameters):
-            parameterValueLst[i].append(parametersAtIteration[i])
-        
-        # map initial guess (type list) to dict
-        pDict = ParameterListToParameterDict(parametersAtIteration)
-
-        if storeFunctionValues or resultsFile != '':
-            # compute objective function value        
-            valuesAtIteration = objectiveFunction(pDict)  #additional costs!
-            valueList.append(valuesAtIteration) # add value to value list
-            # write parameters and objective function at current iteration to file
-            if resultsFile != '':
-                resultsFileCnt[0] = WriteToFileMinimize(resultsFile, parameters, pDict, valuesAtIteration, resultsFileCnt[0])
-        
-        # increase iteration counter 
-        itCtr[0] += 1 
-        
-        # time needed for iteration     
-        iterationsToGo = (maxiter-itCtr[0]) 
-        timeToGo = 0
-        currentTime = time.time()
-        timeSpent = currentTime - startTime
-        if itCtr[0] != 0:
-            timeToGo = timeSpent/itCtr[0] * iterationsToGo
-
-        # print progess to console 
-        if showProgress: 
-            if currentTime - timePrintLast[0] > 1 or lastTime:
-                timePrintLast[0] = currentTime
-                print('iteration ' + str(itCtr[0]) + ' / ' + str(maxiter), end='')
-                print(', time = '+str(round(timeSpent,2)), 's / ',end='')
-                print(str(round(timeToGo,2)) + 's',end='')
-                print(', loss:', ("{:.0"+str(3)+"g}").format(valuesAtIteration))
-            
-
-
-
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # local parameterFunction used for minimization
-    def ParameterFunctionMinimize(parametersAtIteration):
-    
-        if not useScipyBounds: # if useScipyBounds=True, use scipy option 'bounds', else apply manual enforcement of bounds. 
-            if enforceBounds: # enforce bounds by mapping initial guess to allowed parameter range
-                for i in range(nParameters):
-                    pVal = parametersAtIteration[i]
-                    lowerBound = min(bounds[i])
-                    upperBound = max(bounds[i])
-                    if pVal < lowerBound:
-                        parametersAtIteration[i] = lowerBound
-                    if pVal > upperBound:
-                        parametersAtIteration[i] = upperBound
-
-        return objectiveFunction(ParameterListToParameterDict(parametersAtIteration))
-    
-    
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # perform optimizaion
-    optimizeResult = optimize.minimize(ParameterFunctionMinimize, 
-                                       initialGuessCopy, 
-                                        method=method, 
-                                        bounds=scipyMinimizeBounds, 
-                                        # callback=partial(StoreParameterFunctionValues, convergence=0, callbackArgs=callbackArgs), 
-                                        callback=StoreParameterFunctionValues, 
-                                        tol=tol,
-                                        options=options,
-                                        )
-    
-    # if showProgress: # print progress data for final iteration to console
-    StoreParameterFunctionValues(optimizeResult['x'], lastTime=True)
-    
-    if debugMode: # show solver informations (e.g. number of function evaluations etc.)
-        print('---------------------------------------\n')
-        print('solver output:\n')
-        print(optimizeResult, '\n')
-        print('---------------------------------------\n')
-
-    # iteration ctr of optimize.minimize is one-based! --> add first (0th) iteration to itCtr
-    itCtr = itCtr[0] + 1  
-
-    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    # optimization results; generate same data for return as in GeneticOptimization()
-    optimizedParameter = optimizeResult['x']
-    optimumValue = optimizeResult['fun']
-    parameterList = {}
-    optimumParameter = {}
-    for i in range(nParameters):
-        parameterList[parKeyLst[i]] = parameterValueLst[i]
-        optimumParameter[parKeyLst[i]] = optimizedParameter[i]
-        
-    return [optimumParameter, optimumValue, parameterList, valueList]
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
-#**function: Perform a sensitivity analysis by successively calling the function parameterFunction(parameterList[i]) with a one at a time variation of parameters in the defined increments. 
-#  e.g., parameterList[0] =['mass':13, 'stiffness':12000] to be computed and returns a value or a list of values which is then stored for each parameter
-#**input:
-#    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns one or more output values for which the sensitivity is calculated
-#    parameters: given as a dictionary, consist of name and tuple of (begin, Variation steps, numberOfValues) e.g. 'mass':(10,0.01,5), for a reference mass of 10, incremented by 0.01*10 and using 5 steps in negative and positive, doing 10 steps in total
-#    scaledByReference: if true multiplies the sensitivities with the corresponding reference parameters, so that the sensitivity resembles a change relative to the reference value
-#    debugMode: if True, additional information is shown
-#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter etc. 
-#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
-#    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
-#    resultsFile: if provided, output is immediately written to resultsFile during processing
-#    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
-#    parameterFunctionData: dictionary containing additional data passed to the parameterFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
-#**output:
-#    returns [parameterList, valRef, valuesSorted, sensitivity], parameterList containing the list of dictionaries processed. valRef is the Solution for the reference values paramList[0], valuesSorted contains the results sorted by the dictionary key that was varied in the simulation. The sensitivity contains the calculated sensitivity, where the rows are the corresponding outputparameters, while the columns are the input parameters, thereby the index sensitivity[1,0] is the sensitivity of output parameter 1 with respect to the input parameter 0. 
-#**author: Peter Manzl
-#**example:
-#   ComputeSensitivities(parameterFunction=ParameterFunction, parameters = {'mass': (mRef, 0.01, 3), 'spring': (1000,0.01, 10),}, multiprocessing=True)
-def ComputeSensitivities(parameterFunction, parameters, scaledByReference=False, 
-                       debugMode=False, addComputationIndex=False, useMultiProcessing=False, 
-                       showProgress = True, parameterFunctionData=dict(),**kwargs):
-    
-    
-    if 'multiprocessing' in sys.modules:
-        from multiprocessing import cpu_count
-        numberOfThreads = cpu_count() #cpu_count gives number of threads
-        if debugMode:
-            print("using", numberOfThreads, "cpus")
-    else:
-        numberOfThreads = 8
-    if 'numberOfThreads' in kwargs: 
-        numberOfThreads = kwargs['numberOfThreads']
-
-    resultsFile = ''
-    if 'resultsFile' in kwargs: 
-        resultsFile = kwargs['resultsFile']
-        
-    paramKeys = list(parameters.keys())
-    for i in range(len(parameters)): 
-        iKey = paramKeys[i]
-        if not(hasattr(parameters[iKey], '__iter__')): # 
-            parameters[iKey] = (parameters[iKey], 1e-3) # only a scalar value for reference value is given
-        if len(parameters[iKey]) == 2: 
-            parameters[iKey] = tuple(list(parameters[iKey]) + [0])
-    # create Reference parameters [0]
-    parameterList = [] #list of parameter dictionaries
-    
-    parameterList += [{paramKeys[0]: parameters[paramKeys[0]][0]}]
-    nVar = [parameters[paramKeys[0]][2]]
-    for i in range(1, len(paramKeys)): 
-        parameterList[0][paramKeys[i]] = parameters[paramKeys[i]][0]
-        nVar += [parameters[paramKeys[i]][2]]
-    
-    
-    
-    for i in range(len(nVar)):
-        iKey =paramKeys[i] 
-
-        fVal = parameters[iKey][1]
-        # except 
-        if debugMode: 
-            print('Variate {} by {} each in {} steps'.format(iKey, fVal, nVar[i]))
-        
-        if nVar[i] == 0: # use forward difference
-            parameterList += [deepcopy(parameterList[0])]
-            parameterList[-1][iKey] = parameterList[-1][iKey] * (1+fVal)
-        else:         
-            for j in range(nVar[i]*2): 
-                if j < nVar[i]: 
-                    jVar = j -  nVar[i]
-                else: 
-                    jVar = j  - nVar[i] +1
-                parameterList += [deepcopy(parameterList[0])]
-                valVar = max(jVar*fVal, 1e-6) # if fVal == 0! 
-                parameterList[-1][iKey] = parameterList[-1][iKey] *(1+jVar*fVal)
-                if parameterList[-1][iKey] == 0: 
-                    parameterList[-1][iKey] += max(fVal, 1e-6)
-    
-    if addComputationIndex: 
-        for cnt in range(1, len(parameterList)): 
-            parameterList[cnt]['computationIndex'] = cnt
-        
-    if parameterFunctionData != {}:
-        for cnt in range(0, len(parameterList)): 
-            parameterList[cnt]['functionData'] = parameterFunctionData
-
-    values = ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, 
-                                  showProgress = showProgress, numberOfThreads=numberOfThreads,
-                                  resultsFile = resultsFile, parameters=parameters)
-
-
-    # calculate sensitivity of the parameter by forward/central difference
-    sensitivity = np.zeros([len(nVar), len(values[0])])
-    valuesSorted = {paramKeys[0]: []}
-    iForward = nVar[0] + 1
-    iBackward = nVar[0]
-    for i in range(sensitivity.shape[0]): # iterate over keys from input
-        iKey = paramKeys[i]
-        for j in range(sensitivity.shape[1]): # iterate over outputvalues 
-            if nVar[i] == 0: # use forward difference
-                sensitivity[i][j] = (values[iForward][j] - values[0][j])/(parameterList[iForward][iKey] - parameterList[0][iKey])
-            else:
-                sensitivity[i][j] = (values[iForward][j] - values[iBackward][j])/(parameterList[iForward][iKey] - parameterList[iBackward][iKey])
-            
-            if scaledByReference: # multiply with the reference value so the sensitivity shows the influence by change of percent of the input
-                sensitivity[i][j] = sensitivity[i][j] * parameterList[0][iKey]
-        if nVar[i] == 0: 
-            valuesSorted[iKey] = np.array([values[iForward]])
-            iForward +=1
-            iBackward = iForward - 1
-        else: 
-            valuesSorted[iKey] = np.array(values[iBackward-nVar[i]+1:iForward+nVar[i]])
-            try: 
-                iForward += nVar[i] + nVar[i+1]
-            except: 
-                continue
-            iBackward = iForward -1
-    valRef = values[0]
-    return [parameterList, valRef, valuesSorted, sensitivity]
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: visualize results of optimization for every parameter (2D plots)
-#**input: 
-#   parameterList: taken from output parameterList of \texttt{GeneticOptimization}, containing a dictinary with lists of parameters
-#   valueList: taken from output valueList of \texttt{GeneticOptimization}; containing a list of floats that result from the objective function
-#   xLogScale: use log scale for x-axis
-#   yLogScale: use log scale for y-axis
-#**output: return [figList, axList] containing the corresponding handles; creates a figure for every parameter in parameterList
-def PlotOptimizationResults2D(parameterList, valueList, xLogScale=False, yLogScale=False):
-    import matplotlib.pyplot as plt
-    import matplotlib.ticker as ticker
-    plt.close("all")
-
-    n = len(valueList) #length of data
-    if  n == 0:
-        print('WARNING: PlotOptimizationResults: parameterList has zero length and therefore terminates!')
-    
-    figList = []
-    axList = []
-    for key in parameterList:
-        fig = plt.figure()
-        figList += [fig]
-        ax=fig.gca() # get current axes
-        axList+=[ax]
-
-        parameterData = parameterList[key]
-        if n != len(parameterData):
-            raise ValueError('PlotOptimizationResults: length of parameterList is different from length of valueList')
-        
-        ax.plot(parameterData, valueList, 'b.', label=key) 
-        ax.set_ylabel('value (objective function)')
-        ax.set_xlabel(key)
-
-
-        ax.grid(True, 'major', 'both')
-        ax.xaxis.set_major_locator(ticker.MaxNLocator(10)) 
-        ax.yaxis.set_major_locator(ticker.MaxNLocator(10)) 
-
-        if xLogScale:
-            ax.set_xscale('log')
-        if yLogScale:
-            ax.set_yscale('log')
-            
-
-        plt.tight_layout()
-        plt.legend()
-
-    plt.show() 
-    return [figList, axList]
-
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: visualize results of Sensitivityanalyis for every parameter (2D plots)
-#**input: 
-#   valRef: The output values of the reference solution
-#   valuesSorted: The output values of the analysed function sorted by the parameter which was varied
-#   sensitivity: The sensitivity Matrix calculated by the function \texttt{ComputeSensitivities()}
-#   fVar: The list of variation stepsizes. It is assumed to be 1e-3 if not defined.
-#   strYAxis: A list of strings to label the plots yAxis
-#   
-#**output: return [fig, axs] containing the corresponding handles; creates a subplot for every row in the sensitivity matrix
-#**author: Peter Manzl
-def PlotSensitivityResults(valRef, valuesSorted, sensitivity, fVar=None, strYAxis = None):
-    import matplotlib.pyplot as plt
-    if strYAxis == None: 
-        strYAxis = ['']*sensitivity.shape[1]
-    if fVar ==None: 
-        fVar = [1e-3] * sensitivity.shape[1]
-    if type(fVar) != list: # if one scalar varaible is passed it is assumed it is the same for each parameter
-        fVar = [fVar]*sensitivity.shape[1]
-    # the rows of the sensitivity are the different outputparameters, while the columns are the input parameters
-    n = []
-    fig, axs = plt.subplots(sensitivity.shape[1]) 
-    for i in range(sensitivity.shape[1]): # each type of values gets a subplot 
-        for j in range(len(list(valuesSorted.keys()))): # iterate over the variated parameters/keys
-            iKey = list(valuesSorted.keys())[j]
-            n += [int(len(valuesSorted[iKey])/2)] # there are +- n variations = 2*2 in the list
-            iVar = np.linspace(-n[j]*fVar[j]*100, n[j]*fVar[j]*100, 2*n[j]+1) # variations 
-            if len(iVar) != 1: 
-                iPlt = iVar # 2*n+1, contains the reference value
-                
-                pltValues = np.r_[valuesSorted[iKey][:int(len(iVar)/2),i], valRef[i], valuesSorted[iKey][int(len(iVar)/2):,i]] 
-            else: 
-                pltValues = [valRef[i], valuesSorted[iKey][0,i]]
-                iVar = np.r_[iVar, fVar[i]*100]
-                iPlt = iVar
-            iVar = np.delete(iVar, n[j]) # without the reference value
-            axs[i].plot(iPlt, pltValues, '--', color=np.ones(3)*0.8) # connect all values including reference values
-            if sensitivity[j,i] != 0: 
-                sDigits = int(-np.log10(abs(sensitivity[j,i])) + 4)
-            else: 
-                sDigits = 1
-            axs[i].plot(iVar, valuesSorted[iKey][:,i], 'o', label='{}, s={}'.format(iKey, np.round(sensitivity[j,i], sDigits))) # plot variation as points
-        axs[i].plot(0, valRef[i], 'd', label='Ref') # reference value in the center of plot
-        axs[i].set(ylabel=strYAxis[i])
-        axs[i].legend()
-        axs[i].grid()
-    axs[-1].set( xlabel='Variation in $\\%$') # in % because spacing is fVar*100 on x-Axis
-    plt.tight_layout()
-    return [fig, axs]
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  The processing module supports multiple execution of EXUDYN models.
+#           It includes parameter variation and (genetic) optimization functionality.
+#
+# Author:   Johannes Gerstmayr, Stefan Holzinger
+# Date:     2020-11-17 (2022-02-04 modified by Stefan Holzinger)
+# Notes:    Parallel processing, which requires multiprocessing library, can lead to considerable speedup (measured speedup factor > 50 on 80 core machine). The progess bar during multiprocessing requires the library tqdm.
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+import numpy as np
+import sys
+import time
+from copy import deepcopy #, copy 
+import os
+from exudyn.advancedUtilities import IsInteger
+
+#%%+++++++++++++++++++++++++++++++++++++++++++
+#**function: internal function to return Exudyn version string, which allows to identify how results have been obtained
+#            writes something like 'Exudyn version = 1.2.33.dev1; Python3.9.11; Windows AVX2 FLOAT64; Windows10 V10.0.19044; AMD64; Intel64 Family 6 Model 142 Stepping 10, GenuineIntel'
+#**notes: If exudyn C++ module is not available, it outputs the Python version
+def GetVersionPlatformString():
+    sReturn = ''
+    try:
+        import exudyn
+        sReturn += 'Exudyn version = '
+        sReturn += exudyn.GetVersionString(True)
+    except:
+        import sys
+        #the micro version may be different!
+        sReturn += '(no exudyn) Python'+str(sys.version_info.major)+'.'+str(sys.version_info.minor)+'.'+str(sys.version_info.micro)
+        
+    try: #put into try except block to avoid problems with new machines ...
+        import platform
+        sReturn += '; ' + platform.uname().system + platform.uname().release
+        if platform.uname().version != '':
+            sReturn += ' V' + platform.uname().version
+        sReturn += '; ' + platform.uname().machine + '; ' + platform.uname().processor
+    except:
+        pass
+
+    return sReturn
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#*function: internal function; convert single index i into subindices based on given list of ranges in subIndexRanges; return list of subindices for sub ranges; ordering is according to way computed in ParameterVariation
+# try following to see effects: for i in range(100): print(SingleIndex2SubIndices(i,[10,2,3,2]))
+def SingleIndex2SubIndices(i, subIndexRanges):
+    nr = len(subIndexRanges)
+    iRanges=[]
+    for k in range(nr):
+        rem = 1
+        for j in range(k+1,nr):
+            rem *= subIndexRanges[j]
+        # print('k=',k,'rem=',rem)
+        kk = int(i/rem)%subIndexRanges[k]
+        iRanges += [kk]
+    # print('iRanges=',iRanges)
+    return iRanges
+    
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#*function: internal function; add computation Index and parameterFunctionData to dictionry entry
+# 
+def AddComputationIndexAndFunctionData(ind, cnt, addComputationIndex, parameterFunctionData): 
+    if addComputationIndex:
+        ind['computationIndex'] = cnt
+    if bool(parameterFunctionData): # if dict is not empty
+        ind['functionData'] = parameterFunctionData
+    return
+
+
+#%%+++++++++++++++++++++++++++++++++++++++++++
+#function: internal output function for ParameterVariation and GeneticOptimization
+# write header or values to output file and increase counter
+def WriteToFile(resultsFile, parameters, currentGeneration, values, globalCnt, writeHeader = False, fileType='genetic optimization', multiProcessingMode=''):
+    if resultsFile != '':
+        #print('write to file')
+        if writeHeader:
+            try:
+                #check only added in case of writeHeader to reduce overheads; may fail, if no header is written (but why...?)
+                os.makedirs(os.path.dirname(resultsFile), exist_ok=True)
+            except:
+                pass #makedirs may fail on some systems, but we keep going
+
+            file = open(resultsFile, 'w')
+            file.write('#EXUDYN '+fileType+' results file:'+resultsFile+'\n')
+            file.write('#results stored columnwise for every parameter and individual\n')
+            sVersion = GetVersionPlatformString()
+            if multiProcessingMode != '':
+                sVersion += '(processing='+multiProcessingMode+')'
+            file.write('#'+sVersion+'\n')
+            if 'functionData' in parameters:
+                file.write('functionData:'+str(parameters['functionData'])+'\n')
+            else:
+                file.write('#\n')
+            file.write('#columns:\n') #'globalIndex, parameters, computationIndex:\n')
+            s = '#globalIndex,value'
+            for (key,value) in parameters.items():
+                if key != 'functionData':
+                    s += ',' + key
+            s += ',computationIndex'
+            file.write(s+'\n')
+            file.write('#parameter ranges [format: (begin, end, numberOfVariations) or list, parameters separated with ";"]:\n')
+            sep = ''
+            s = '#'
+            for (key,value) in parameters.items():
+                if key != 'functionData':
+                    s += sep + str(value)
+                    sep = ';'
+            file.write(s+'\n')
+            file.close()
+        
+        file = open(resultsFile, 'a')
+        for i in range(len(values)):
+            s = ''
+            s += str(globalCnt) + ', '
+            s += str(values[i])
+            for (key,value) in currentGeneration[i].items():
+                #print(currentGeneration[i])
+                if key != 'functionData':
+                    s += ', ' + str(value)
+            file.write(s+'\n')
+            globalCnt += 1 #for every line of values
+            
+        file.close()
+        #print('... done')
+    return globalCnt
+    
+
+
+#**function: processes parameterFunction for given parameters in parameterList, see ParameterVariation
+#**input:
+#    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
+#    parameterList: list of parameter sets (as dictionaries) which are fed into the parameter variation, see example 
+#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
+#    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
+#    resultsFile: if provided, output is immediately written to resultsFile during processing
+#    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
+#    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
+#    useMPI: if given in **kwargs and set True, and if Python package mpi4py is installed, mpi parallelization is used; for hints see parameterVariationExample.py
+#**output: returns values containing the results according to parameterList
+#**notes: options are passed from Parametervariation
+#**example:
+#def PF(parameterSet):
+#    #in reality, value will be result of a complex exudyn simulation:
+#    value = sin(parameterSet['mass']) * parameterSet['stiffness']
+#    return value
+#
+#values=ProcessParameterList(parameterFunction=PF, 
+#                            parameterList=[{'m':1, 's':100},
+#                                          {'m':2, 's':100},
+#                                          {'m':3, 's':100},
+#                                          {'m':1, 's':200},
+#                                          {'m':2, 's':250},
+#                                          {'m':3, 's':300},
+#                                          ], useMultiProcessing=False )
+def ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, clusterHostNames=[], **kwargs):
+    values = [] #create empty list
+    nVariations = len(parameterList)
+    #print("pl=",parameterList)
+    showProgress = False
+    if 'showProgress' in kwargs: 
+        showProgress = kwargs['showProgress']
+
+    resultsFile = ''
+    if 'resultsFile' in kwargs: 
+        resultsFile = kwargs['resultsFile']
+
+    parameters = {}
+    if 'parameters' in kwargs: 
+        parameters = kwargs['parameters']
+
+    useCluster = (clusterHostNames != []) and useMultiProcessing
+    if useCluster:
+        try:
+            import dispy
+        except:
+            print('WARNING: ProcessParameterList: dispy is not installed (try: pip install dispy); switching to multiprocessing mode instead')
+            useCluster = False
+
+    useMPI = False
+    if 'useMPI' in kwargs and useMultiProcessing:
+        useMPI = kwargs['useMPI']
+        if useMPI:
+            try:
+                from mpi4py.futures import MPIPoolExecutor
+            except:
+                print('WARNING: ProcessParameterList: mpi4py is not installed or mpi4py.futures not available (try: conda install mpi4py); switching to multiprocessing mode instead')
+                useMPI = False
+
+    useTQDM = False
+    if showProgress and useMultiProcessing and not useCluster:
+        try:
+            import tqdm #progress bar
+            try: #_instances only available after first run!
+                tqdm.tqdm._instances.clear() #if open instances of tqdm, which leads to nasty newline
+            except:
+                pass
+            useTQDM = True
+        except:
+            pass
+            #print("module 'tqdm' not available (use pip to install); progress bar not shown")
+
+    resultsFileCnt = 0 #counter for results file; used in several if branches
+
+    if not useCluster and not useMPI:
+        if not useMultiProcessing:
+            for i in range(nVariations):
+                currentParameters = parameterList[i]
+                v = parameterFunction(currentParameters)
+                values += [v]
+                if showProgress:
+                    printStr = ''
+                    if (type(v) == float) or (type(v) == int):
+                        printStr = ', value = '+str(v)
+                    if 'functionData' in currentParameters: #functionData may be large, DO not print!
+                        copyParameters = {}
+                        for key, value in currentParameters.items():
+                            if key != 'functionData':
+                                copyParameters[key] = value
+                        printStr += ": parameters=" + str(copyParameters)
+                    else:
+                        printStr += ": parameters=" + str(currentParameters)
+                    
+                    print("\rrun ", i+1, "/", nVariations, printStr, '                ', end='', flush=True)
+                if resultsFile != '':
+                    resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
+                                              [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
+                                              fileType='parameter variation',
+                                              multiProcessingMode='serial')
+            if showProgress:
+                print("", flush=True) #newline after tqdm progress bar output....
+        else:
+            from multiprocessing import Pool, cpu_count #parallelization of computation
+           
+            numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
+            if 'numberOfThreads' in kwargs: 
+                numberOfThreads = kwargs['numberOfThreads']
+            
+            vInput = np.array(parameterList)
+                
+            if useTQDM:
+                with Pool(processes=numberOfThreads) as p:
+                    #values = list(tqdm.tqdm(p.imap(parameterFunction, vInput), total=nVariations))
+                    for v in (tqdm.tqdm(p.imap(parameterFunction, vInput), total=nVariations)):
+                        values+=[v]
+                        if resultsFile != '':
+                            resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
+                                                      [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
+                                                      fileType='parameter variation',
+                                                      multiProcessingMode='multiprocessing.Pool, numberOfThreads='+str(numberOfThreads))
+                print("", flush=True) #newline after tqdm progress bar output....
+            else:
+                #simpler approach without tqdm:
+                # with Pool(processes=numberOfThreads) as p:
+                #     values = p.map(parameterFunction, vInput)
+                with Pool(processes=numberOfThreads) as p:
+                    for v in p.imap(parameterFunction, vInput):
+                        values+=[v]
+                        if resultsFile != '':
+                            resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
+                                                      [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
+                                                      fileType='parameter variation',
+                                                      multiProcessingMode='multiprocessing.Pool, numberOfThreads='+str(numberOfThreads))
+                            #print("value=",i)
+    elif useCluster: 
+        
+        # form cluster and submit jobs
+        cluster = dispy.JobCluster(parameterFunction, nodes=clusterHostNames, host=clusterHostNames, cleanup=True, dispy_port=9700) 
+        
+        # import dispy's httpd module, create http server for this cluster
+        # monitor allows to monitor and manage clusters with a web browser; it works with common web browsers, including in iOS and Android devices.
+        http_server = None
+        if 'useDispyWebMonitor' in kwargs: #showProgress: #True:
+            if showProgress:
+                print('open http monitor')
+            import dispy.httpd
+            import socket
+            clientHostname = socket.gethostname()
+            http_server = dispy.httpd.DispyHTTPServer(cluster, host=clientHostname, port=8181, poll_sec=5) 
+            import webbrowser
+            clientIPv4Address = socket.gethostbyname(clientHostname)
+            webbrowser.open("http://"+clientIPv4Address+":8181/monitor.html")
+        
+        # perform computations
+        nVariations = len(parameterList)
+        jobs = [None]*nVariations
+        for i in range(nVariations):
+            
+            # submit job to cluster
+            job = cluster.submit(parameterList[i]) #, refSol=referenceSolution) 
+            jobs[i] = job
+            job.id = i+1
+
+        #cluster.wait() # waits until all jobs finish
+        
+        # collect return value of each job      
+        values = [None]*len(jobs)  
+        
+        jobCtr = 0        
+        for job in jobs:     
+            #host, val = job()
+            val = job()
+            values[jobCtr] = val
+            jobCtr += 1
+            if showProgress:
+                #show return values only in case that they are of float type
+                if (type(job.result) == float) or (type(job.result) == int):
+                    print('executed job '+str(job.id) + ' / ' + str(nVariations) +
+                          ' with return value ' + str(job.result))
+                else:
+                    print('executed job ' + str(job.id) + ' / ' + str(nVariations))
+        
+        # close cluster
+        cluster.wait()
+        if showProgress:
+            cluster.print_status()
+        
+        if http_server != None:
+            http_server.shutdown() # this waits until browser gets all updates
+        cluster.close()
+    elif useMPI:
+        #numberOfThreads not used in this case; given by mpiexec call
+
+        vInput = np.array(parameterList)
+
+        from mpi4py import MPI
+        
+        comm = MPI.COMM_WORLD
+        nprocs = comm.Get_size()
+        # rank   = comm.Get_rank() 
+        
+        if useTQDM:
+
+            with MPIPoolExecutor() as p:
+            # with Pool(processes=numberOfThreads) as p:
+                for v in (tqdm.tqdm(p.map(parameterFunction, vInput), total=nVariations)):
+                    values+=[v]
+                    if resultsFile != '':
+                        resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
+                                                  [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
+                                                  fileType='parameter variation',
+                                                  multiProcessingMode='mpi4py, numberOfWorkers='+str(nprocs))
+            print("", flush=True) #newline after tqdm progress bar output....
+        else:
+            #simpler approach without tqdm:
+            # with Pool(processes=numberOfThreads) as p:
+            #     values = p.map(parameterFunction, vInput)
+            with MPIPoolExecutor() as p:
+                for v in p.map(parameterFunction, vInput):
+                    values+=[v]
+                    if resultsFile != '':
+                        resultsFileCnt = WriteToFile(resultsFile, parameters, [parameterList[resultsFileCnt]], 
+                                                  [v], resultsFileCnt, writeHeader = (resultsFileCnt == 0), 
+                                                  fileType='parameter variation',
+                                                  multiProcessingMode='mpi4py, numberOfWorkers='+str(nprocs))
+
+            
+    return values
+
+
+
+#**function: calls successively the function parameterFunction(parameterDict) with variation of parameters in given range; parameterDict is a dictionary, containing the current values of parameters,
+#  e.g., parameterDict=['mass':13, 'stiffness':12000] to be computed and returns a value or a list of values which is then stored for each parameter
+#**input:
+#    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
+#    parameters: given as a dictionary, consist of name and tuple of (begin, end, numberOfValues) same as in np.linspace(...), e.g. 'mass':(10,50,10), for a mass varied from 10 to 50, using 10 steps OR a list of values [v0, v1, v2, ...], e.g. 'mass':[10,15,25,50]
+#    useLogSpace: (optional) if True, the parameters are varied at a logarithmic scale, e.g., [1, 10, 100] instead linear [1, 50.5, 100]
+#    debugMode: if True, additional print out is done
+#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
+#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
+#    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
+#    resultsFile: if provided, output is immediately written to resultsFile during processing
+#    numberOfThreads: default(None): same as number of cpus (threads); used for multiprocessing lib;
+#    parameterFunctionData: dictionary containing additional data passed to the parameterFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
+#    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
+#    useDispyWebMonitor: if given in **kwargs, a web browser is started in case of cluster computation to manage the cluster during computation
+#    useMPI: if given in **kwargs and set True, and if Python package mpi4py is installed, mpi parallelization is used; for hints see parameterVariationExample.py
+#**output:
+#    returns [parameterList, values], containing, e.g., parameterList=\{'mass':[1,1,1,2,2,2,3,3,3], 'stiffness':[4,5,6, 4,5,6, 4,5,6]\} and the result values of the parameter variation accoring to the parameterList, 
+#           values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
+#**example:
+#if __name__ == '__main__':
+#    ParameterVariation(parameterFunction=Test, 
+#                       parameters={'mass':(1,10,10), 'stiffness':(1000,10000,10)}, 
+#                       useMultiProcessing=True)
+def ParameterVariation(parameterFunction, parameters, 
+                       useLogSpace=False, debugMode=False, addComputationIndex=False,
+                       useMultiProcessing=False, showProgress = True, parameterFunctionData={}, clusterHostNames=[],
+                       numberOfThreads=None, resultsFile='', **kwargs):
+    
+    if 'multiprocessing' in sys.modules:
+        from multiprocessing import cpu_count
+        if numberOfThreads == None:
+            numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
+        if debugMode:
+            if clusterHostNames == []:
+                print("using", numberOfThreads, "cpus")
+            else:
+                print("using cluster")
+    if numberOfThreads == None:
+        numberOfThreads = 8 #just some default, if no other value available
+
+    #generate list of parameters to iterate
+    dim = len(parameters)       #dimensionality (dimension) of problem
+    nParams = np.zeros(dim, dtype=int)     #number of variations in each dimension
+    cnt = 0
+    for (key,value) in parameters.items(): 
+        if isinstance(value, tuple): #then it is a range (start, end, numberOfValues)
+            nParams[cnt] = value[2] #last value is the number of variations
+        elif isinstance(value, list): #then it contains list of values, e.g., [1,2,4,8]
+            nParams[cnt] = len(value) #last value is the number of variations
+        else:
+            raise ValueError('ParameterVariation: parameters must contain tuple with range (begin, end, numberOfValues) or list of values [v0, v1, v2, ...]')
+        cnt+=1 #counts the dimensionality
+        
+        
+    nVariations = np.array(nParams).prod() #product of all ranges gives total count
+    if nVariations == 0:
+        print("WARNING: number of variations =", nVariations)
+        return []
+
+    if debugMode:
+        print("number of variations =", nVariations)
+
+    cnt = 0
+    isIntType = [False] * dim # true if corresponding parameter ranges/list is all int type
+    parameterDict = {} #dictionary of parameter lists
+    for (key,value) in parameters.items():
+        if isinstance(value, tuple): #then it is a range (start, end, numberOfValues)
+            pStart = value[0]
+            pEnd = value[1]
+            numberOfValues = value[2]
+
+            if numberOfValues == 0:
+                raise ValueError('ParameterVariation: in tuples (begin, end, numberOfValues), numberOfValues may not be zero')
+            if int(numberOfValues) != numberOfValues:
+                raise ValueError('ParameterVariation: in tuples (begin, end, numberOfValues), numberOfValues must be integer')
+            if pStart > pEnd:
+                raise ValueError('ParameterVariation: in tuples (begin, end, numberOfValues), there must be begin <= end')
+        
+            step = (pEnd-pStart+1)/numberOfValues # is for check if numberOfValues is even
+            if IsInteger(pStart) and IsInteger(pEnd) and step == int(step): # is true, if ranges/list are all int and step is integer
+                isIntType[cnt] = True 
+
+            #now create list of parameters, using duplicates according to dimensionality
+            if useLogSpace:
+                space = np.logspace(np.log10(pStart),np.log10(pEnd),numberOfValues)
+            else:
+                space = np.linspace(pStart,pEnd,numberOfValues)
+        else: #already checked above: if isinstance(value, list): #then it contains list of values, e.g., [1,2,4,8]
+            space = value
+            isIntType[cnt] = True
+            for val in value:
+                if not IsInteger(val):
+                    isIntType[cnt] = False
+            
+        range1 = nParams[0:cnt].prod()
+        range2 = nParams[cnt+1:dim+1].prod()
+        if range1 == 0:
+            range1 = 1 #otherwise kronecker product won't work
+        if range2 == 0:
+            range2 = 1 #otherwise kronecker product won't work
+            
+        #print("space=",space)
+        
+        parameterDict[key] = np.kron(np.kron([1]*range1, space), [1]*range2)
+        cnt+=1 #counts the dimensionality
+
+    if debugMode:
+        print("parameterDict =", parameterDict)
+
+    if addComputationIndex:
+        parameterDict['computationIndex'] = np.linspace(0,nVariations-1,nVariations,dtype=int)
+        
+    #finally convert parameter dictinary to list of dictionaries:
+    parameterList = [] #list of parameter dictionaries
+    for i in range(nVariations):
+        parameterSet = {}
+        cnt = 0
+        for (key,value) in parameterDict.items(): 
+            if key == 'computationIndex':
+                v = int(value[i]) #make integers, which follow type(v)==int
+            elif isIntType[cnt]: # check if this variable is an integer type
+                v = int(value[i]) #make integers, which follow type(v)==int
+            else:
+                v = float(value[i]) #make floats, which follow type(v)==float
+            parameterSet[key] = v
+            cnt += 1
+        if parameterFunctionData != {}:
+            parameterSet['functionData'] = parameterFunctionData
+            #not needed: parameterSet['functionData'] = copy.deepcopy(parameterFunctionData)
+            
+        parameterList += [parameterSet]
+
+    values = ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, 
+                                  showProgress = showProgress, numberOfThreads=numberOfThreads,
+                                  resultsFile = resultsFile, parameters=parameters, 
+                                  clusterHostNames=clusterHostNames, **kwargs)
+    
+    return [parameterDict, values]
+    
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute minimum of given objectiveFunction
+#**input:
+#    objectiveFunction: function, which takes the form parameterFunction(parameterDict) and which returns a value or list (or numpy array) which reflects the size of the objective to be minimized
+#    parameters: given as a dictionary, consist of name and tuple containing the search range for this parameter (begin, end), e.g. 'mass':(10,50)
+#
+#    populationSize: individuals in every generation
+#    initialPopulationSize: number of random initial individuals; default: population size
+#    numberOfGenerations: number of generations; NOTE: it is required that elitistRatio*populationSize >= 1
+#    elitistRatio: the number of surviving individuals in every generation is equal to the previous population times the elitistRatio
+#    crossoverProbability: if > 0: children are generated from two (randomly selected) parents by gene-crossover; if 0, no crossover is used
+#    crossoverAmount: if crossoverProbability > 0, then this amount is the probability of genes to cross; 0.1: small amount of genes cross, 0.5: 50\% of genes cross
+#    rangeReductionFactor: reduction of mutation range (boundary) relative to range of last generation; helps algorithm to converge to more accurate values
+#    distanceFactor: children only survive at a certain relative distance of the current range; must be small enough (< 0.5) to allow individuals to survive; ignored if distanceFactor=0; as a rule of thumb, the distanceFactor should be zero in case that there is only one significant minimum, but if there are many local minima, the distanceFactor should be used to search at several different local minima
+#    childDistribution: string with name of distribution for producing childs: "normal" (Gaussian, with sigma defining range), "uniform" (exactly in range of childs)
+#    distanceFactorGenerations: number of generations (populations) at which the distance factor is active; the distance factor is used to find several local minima; finally, convergence is speed up without the distance factor
+#    parameterFunctionData: dictionary containing additional data passed to the objectiveFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
+#    randomizerInitialization: initialize randomizer at beginning of optimization in order to get reproducible results, provide any integer in the range between 0 and 2**32 - 1 (default: no initialization)
+#
+#    debugMode: if True, additional print out is done
+#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
+#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
+#    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
+#    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
+#    resultsFile: if provided, the results are stored columnwise into the given file and written after every generation; use resultsMonitor.py to track results in realtime
+#    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
+#    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
+#**output:
+#    returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
+#           values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
+#**notes: This function is still under development and shows an experimental state! 
+#**example:
+#GeneticOptimization(objectiveFunction = fOpt, parameters={'mass':(1,10), 'stiffness':(1000,10000)})
+def GeneticOptimization(objectiveFunction, parameters, 
+                        populationSize=100,
+                        numberOfGenerations=10,
+                        elitistRatio = 0.1,
+                        crossoverProbability=0.25,
+                        crossoverAmount=0.5,
+                        rangeReductionFactor=0.7,
+                        distanceFactor=0.1,
+                        childDistribution="uniform",  
+                        distanceFactorGenerations=-1,
+                        debugMode=False, 
+                        addComputationIndex=False,
+                        useMultiProcessing=False, 
+                        showProgress = True,
+                        clusterHostNames = [],
+                        parameterFunctionData = {}, 
+                        **kwargs):
+
+    def RandomNumber(distribution, rangeBegin, rangeEnd, vMin, vMax):
+        a = rangeBegin
+        b = rangeEnd
+        value = vMax + 1
+        while (value < vMin or value > vMax):
+            if distribution == 'uniform':
+                value = np.random.uniform(a, b)
+            elif distribution == 'normal':
+                value = np.random.normal(loc = 0.5*(a+b), scale = 0.5*(b-a))
+            else:
+                raise ValueError('GeneticOptimization: invalid childDistribution "'+childDistribution+'"')
+        
+        return value
+        
+    
+    #get number of threads:
+    if 'multiprocessing' in sys.modules:
+        from multiprocessing import cpu_count
+        numberOfThreads = cpu_count() #cpu_count in fact gives number of threads ...
+    else:
+        numberOfThreads = 8
+    if 'numberOfThreads' in kwargs: 
+        numberOfThreads = kwargs['numberOfThreads']
+
+    if useMultiProcessing:
+        if clusterHostNames==[]:
+            print("number of threads used =", numberOfThreads,flush=True) #very useful information
+        else:
+            print("using cluster",flush=True) 
+            
+
+    useDispyWebMonitor = False
+    if 'useDispyWebMonitor' in kwargs: 
+        useDispyWebMonitor = kwargs['useDispyWebMonitor']
+
+    initialPopulationSize = populationSize
+    if 'initialPopulationSize' in kwargs: 
+        initialPopulationSize = kwargs['initialPopulationSize']
+
+    resultsFile = ''
+    if 'resultsFile' in kwargs: 
+        resultsFile = kwargs['resultsFile']
+
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+    #delete this in future:
+    if 'numberOfChildren' in kwargs: 
+        print("GeneticOptimization: deprecated and unused parameter; use population size a and elitistRatio instead\n")
+    
+    #old value: survivingIndividuals=8
+    survivingIndividuals = int(elitistRatio*populationSize)
+    if 'survivingIndividuals' in kwargs: 
+        survivingIndividuals = kwargs['survivingIndividuals']
+        print("GeneticOptimization: survivingIndividuals: deprecated parameter; use population size a and elitistRatio instead\n")
+
+
+    if 'randomizerInitialization' in kwargs: 
+        randomizerInitialization = kwargs['randomizerInitialization']
+        if not isinstance(randomizerInitialization,int):
+            raise ValueError("GeneticOptimization: ERROR: randomizerInitialization must be positive 32 bit integer")
+        np.random.seed(randomizerInitialization)
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+    #check that there are surviving individuals at all (otherwise hangs...)
+    if survivingIndividuals < 1:
+        elitistRatio = 1/populationSize
+        survivingIndividuals = 1
+        print("WARNING: elitistRatio*populationSize < 1. Setting elitistRatio=", elitistRatio,'\n')
+
+    if distanceFactor >= 1:
+        distanceFactor = 0.5
+        print("WARNING: distanceFactor >= 1, setting distanceFactor = 0.5\n")
+
+    if distanceFactorGenerations < 0:
+        distanceFactorGenerations = numberOfGenerations+1 #will be never active
+
+    dim = 0
+    ranges = []                 #list containing the ranges of each dimension
+    rangesDict = {} #dict containing only the ranges
+    for (key,value) in parameters.items():
+        dim += 1 #count dimensions of parameters
+        r = value[1]-value[0]
+        if r <= 0:
+            raise ValueError("GeneticOptimization: ERROR: range of component "+str(dim-1)+" has negative or zero range")
+        ranges += [r]
+        rangesDict[key] = r
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+    #generate first generation:
+    currentGeneration = []
+    for i in range(initialPopulationSize):
+        ind = {} #dictionary for individual
+        for (key,value) in parameters.items():
+            pBegin = value[0]
+            pEnd = value[1]
+            value = np.random.uniform(pBegin, pEnd)
+            ind[key] = value
+        AddComputationIndexAndFunctionData(ind, i, addComputationIndex, parameterFunctionData)
+        currentGeneration += [ind]
+    #+++++++++++++++++++++++++++++++++++++++++++++++
+
+    if debugMode:
+        if initialPopulationSize <= 50:
+            print("initial population =", currentGeneration)
+        print("rangesDict =", rangesDict)
+
+    parametersAll = []
+    valueList = []
+    newGeneration = []      #surviving individuals, not re-computed!
+    newGenerationValues = []#surviving individuals' values, not re-computed!
+    
+    totalEvaluations = 0
+    resultsFileCnt = 0 #counter for output file
+
+    for popCnt in range(numberOfGenerations):
+        if debugMode:
+            print("===============\nevaluate population", popCnt, ":")
+
+        totalEvaluations += len(currentGeneration)
+        values = ProcessParameterList(objectiveFunction, currentGeneration, useMultiProcessing, showProgress = showProgress, numberOfThreads=numberOfThreads,
+                                      clusterHostNames=clusterHostNames, useDispyWebMonitor=useDispyWebMonitor)
+
+        if (showProgress and useMultiProcessing and popCnt < numberOfGenerations-1): print("            #"+str(popCnt+1), end='')
+        #print("values=",values)
+        multiProcessingMode = ''
+        if useMultiProcessing:
+            multiProcessingMode = 'multiprocessing.Pool, numberOfThreads='+str(numberOfThreads)
+        resultsFileCnt = WriteToFile(resultsFile, parameters, currentGeneration, values, resultsFileCnt, 
+                                     writeHeader = (popCnt == 0),
+                                     multiProcessingMode=multiProcessingMode)
+
+        #remove computationIndex and parameterfunctiondata from new generation
+        for item in currentGeneration:
+            if 'computationIndex' in item:
+                del item['computationIndex']
+            if 'functionData' in item: 
+                del item['functionData']
+
+        #store all values
+        parametersAll += currentGeneration.copy()
+        valueList += values.copy()
+
+        #add best individuals from previous parents:
+        currentGeneration += newGeneration.copy()
+        values += newGenerationValues.copy()
+        
+        #compute norm and minimum values:
+        scalarValues = [(0,0)]*len(values)
+        for i in range(len(values)):
+            item = values[i]
+            if isinstance(item, float):
+                scalarValues[i] = (item,i)
+            else: #must be list of values ==> compute norm!
+                scalarValues[i] = (np.sqrt(np.dot(item,item)),i)
+
+        valuesDtype = [('value', float), ('index', int)]
+        scalarValues = np.array(scalarValues, dtype = valuesDtype)
+
+        sortedValues = np.sort(scalarValues, order='value') #sort for item values
+        #print("scalarValues=",scalarValues)
+        #print("sortedValues=",sortedValues)
+
+        if popCnt < numberOfGenerations-1: #go on for next population
+            relativeRange = rangeReductionFactor**(popCnt+1) #this is the relative range for the next population
+
+            if debugMode:
+                print("Child ranges in population",popCnt)
+                for (key,value) in parameters.items():
+                    r = value[1]-value[0]
+                    r *= relativeRange #reduce range
+                    print('  '+key+':', r)
+            
+            #selection: chose best surviving individuals
+            newGeneration = []
+            newGenerationValues = []
+            cnt = 0
+
+            if distanceFactor == 0 or popCnt >= distanceFactorGenerations: #distance not important
+                for i in range(min(survivingIndividuals,len(sortedValues))):
+                    ind = currentGeneration[int(sortedValues[i][1])] #dictionary for individual
+                    if addComputationIndex:
+                        ind['computationIndex'] = cnt #unique index for one set of computations
+                    newGeneration += [ind]
+                    newGenerationValues += [values[int(sortedValues[i][1])]]
+                    cnt += 1
+            else:
+                nSurviving = min(survivingIndividuals,len(sortedValues))
+                nGen = len(currentGeneration)
+                j = 0 #index counter
+                i = 0 #counter for surviving individuals to be found
+                distanceList = [1]*nGen #initialize with one, saying that all distances large enough #relativeRange*np.reshape(ranges*dim,(nGen, dim)) #these are the maximum distances
+                
+                #print("nSurviving=",nSurviving)
+                #print("len(sortedValues)=",len(sortedValues))
+                #find indices which have sallest objective function value, but obey distanceFactor
+                while i < nSurviving and j < len(sortedValues):
+                    iInd = int(sortedValues[j][1]) #index for individual in currentGeneration
+                    ind = currentGeneration[iInd] #dictionary for individual
+                    j += 1
+                    if distanceList[iInd] > distanceFactor:
+                        if addComputationIndex:
+                            ind['computationIndex'] = cnt #unique index for one set of computations
+                        newGeneration += [ind]
+                        newGenerationValues += [values[iInd]]
+                        cnt += 1 #computation index counter
+                        i += 1   #counts the surviving individuals
+                        #print("\nadd individual", ind)
+                        #print("currentGeneration", currentGeneration)
+                        
+                        #update distances for added individual:
+                        for k in range(nGen):
+                            d = 0
+                            for (key,value) in ind.items():
+                                if key != 'computationIndex' and key in parameters.keys(): # only manipulate values from given parameters
+                                    d += (ind[key] - currentGeneration[k][key])**2/(rangesDict[key])**2
+                            d = np.sqrt(d/dim) #number of parameters shall not influence distanceFactor
+                            #print("d=",d,":",ind,"-",currentGeneration[k])
+                            if d < distanceList[k]:
+                                distanceList[k] = d
+                    # else:
+                    #     print("\nindiv.",ind," ignored due to small distance:", distanceList[iInd])
+                        
+                    #print("distanceList=",distanceList)
+            
+            #print("survivingIndividuals=",newGeneration)
+            if debugMode:
+                print("\nbest values=",sortedValues[0:min(survivingIndividuals,4)])
+            
+            #prolongate best individuals:
+            currentGeneration = []
+            # for item in newGeneration: #removed, in order to save number of evaluations
+            #     currentGeneration += [item]
+    
+            #modification of parents
+            genSize = len(newGeneration)
+            if genSize == 0:
+                print("WARNING: size of generation = 0, terminating (check your optimization parameters...)\n")
+                
+            p = 0 #current population size
+            while p < populationSize and genSize != 0:
+                for item in newGeneration:
+                    indList = [{}]      #dictionary for individual
+                    parents = [item]    #list of parents
+
+                    #do gene crossing fro parents:
+                    if crossoverProbability > 0:
+                        r = np.random.random()
+                        if r < crossoverProbability: #do cross-over only for a smaller portion of parents!
+                            indList += [{}] #use two new individuals with gene-crossover
+                            rand0 = np.random.randint(genSize)
+                            rand1 = np.random.randint(genSize) #may be same as rand1
+                            p0 = newGeneration[rand0].copy() #parent1 for crossover
+                            p1 = newGeneration[rand1].copy() #parent2 for crossover
+                            parents = [p0, p1]
+                            for (key,value) in parameters.items():
+                                r = np.random.random()
+                                if r < crossoverAmount: #usually 50% gene cross over
+                                    indList[0][key] = p1[key] #uniform gene crossing
+                                    indList[1][key] = p0[key]
+                            # print('indList=',indList)
+
+                    #one or two individuals
+                    for pi in range(len(parents)):
+                        item = parents[pi]
+                        for (key,value) in parameters.items():
+                            r = value[1]-value[0]
+                            r *= relativeRange #reduce range
+                            #print("range=",r)
+                            pBegin = item[key]-0.5*r #minimum value
+                            pEnd = item[key]+0.5*r 
+                            #obej ranges: ==> this may give more values at boundary
+                            if pBegin < value[0]: pBegin = value[0]
+                            if pEnd > value[1]: pEnd = value[1]
+    
+                            #print("new range=",pBegin,pEnd)
+                            #value = np.random.uniform(pBegin, pEnd)
+                            newValue = RandomNumber(childDistribution, 
+                                                 pBegin, pEnd, 
+                                                 value[0], value[1])
+                            indList[pi][key] = newValue
+    
+                        if p < populationSize:
+                            newGen = {}
+                            for (key,value) in parameters.items(): #sort according to parameters, for output file!
+                                newGen[key] = indList[pi][key]
+                            if addComputationIndex:
+                                newGen['computationIndex'] = cnt #unique index for one set of computations
+                            currentGeneration += [newGen]
+                            #currentGeneration += [indList[pi]] #gives wrong sorting in dict ..., destroys output file order
+                            p += 1
+                        indList[-1]['functionData'] = parameterFunctionData # add function data
+                        cnt += 1 #computation count ... for every parameter variation within one generation
+            # print("pop", popCnt, ": currentGeneration=\n",currentGeneration)
+        else:
+            #select final best individual
+            optimumParameter = currentGeneration[int(sortedValues[0][1])]
+            optimumValue = sortedValues[0][0]
+            if debugMode:
+                print("opt par=", optimumParameter, ", opt val=", optimumValue)
+
+    if debugMode:
+        print("===============\ntotal evaluations=", totalEvaluations)
+
+    #now make dict of parameter lists instead list of dicts
+    parameterList = {}
+    n = len(parametersAll)
+    if n != 0:
+        for key in parametersAll[0]:
+            if key != 'computationIndex' and key in parameters.keys(): # do not output function data
+                parameterData = np.zeros(n)
+                #extract parameter list from list of dictionaries:
+                for i in range(n):
+                    parameterData[i] = parametersAll[i][key]
+    
+                #add parameter list to final dictionary
+                parameterList[key] = parameterData
+
+
+    return [optimumParameter, optimumValue, parameterList, valueList]
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: Compute minimum of given objectiveFunction. This function is based on scipy.optimize.minimize() and it provides the same interface as GeneticOptimization(). Note that in special cases, you should copy this function and adapt to your needs.
+#**input:
+#    objectiveFunction: function, which takes the form parameterFunction(parameterDict) and which returns a value or list (or numpy array) which reflects the size of the objective to be minimized
+#    parameters: given as a dictionary, consist of name and tuple containing the search range for this parameter (begin, end), e.g. 'mass':(10,50)
+#    storeFunctionValues: if True, objectiveFunction values are computed (additional costs!) and stored in every iteration into valueList
+#    initialGuess: initial guess. Array of real elements of size (n,), where 'n' is the number of independent variables. If not provided by the user, initialGuess is computed from bounds provided in parameterDict.
+#    method: solver that should be used, e.g. 'Nelder-Mead', 'Powell', 'CG' etc. A list of available solvers can be found in the documentation of scipy.optimize.minimize().
+#    tol: tolerance for termination. When tol is specified, the selected minimization algorithm sets some relevant solver-specific tolerance(s) equal to tol (but this is usually not the tolerance for loss or parameters1). For detailed control, use solver-specific options using the 'options' variable.
+#    options: dictionary of solver options. Can be used to set absolute and relative error tolerances. Detailed information can be found in the documentation of scipy.optimize.minimize().
+#    enforceBounds: if True, ensures that only parameters within the bounds specified in ParameterDict are used for minimization; this may help to avoid, e.g., negative values, but may lead to non-convergence 
+#    verbose: prints solver information into console, e.g. number of iterations 'nit', number of funcion evaluations 'nfev', status etc.
+#    showProgress: if True, shows for every iteration objective function value, current iteration number, time needed for current iteration, maximum number of iterations and loss (current value of objective function)
+#    addComputationIndex: if True, key 'computationIndex' is added for consistency reasons with GeneticOptimizaiton to every parameterDict in the call to parameterFunction(); however, the value is always 0, because no multi threading is used in Minimize(...)
+#    resultsFile: if provided, the results are stored columnwise into the given file and written after every generation; use resultsMonitor.py to track results in realtime
+#    useScipyBounds: if True, use scipy.optimize.minimize() option 'bounds' to apply bounds on variable specified in ParameterDict. Note, this option is only used by some specific methods of scipy.optimize.minimize()! method='Nelder-Mead' ignores this option for example! if False, option 'enforceBounds' will be set to False!
+#    args: extra arguments passed to the objective function and its derivatives (fun, jac and hess functions). 
+#**author: Stefan Holzinger, Johannes Gerstmayr
+#**output: returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
+#**notes: This function is still under development and shows an experimental state! There are currently unused arguments of scipy.optimize.minimize(): Detailed information can be found in the documentation of scipy.optimize.minimize().
+def Minimize(objectiveFunction, parameters, initialGuess=[], method='Nelder-Mead', tol=1e-4, options={}, 
+             enforceBounds=True, debugMode=False, showProgress=True, addComputationIndex=False,
+             storeFunctionValues=True, **kwargs):
+    from scipy import optimize #for minimize
+    # from functools import partial #add extra args to function
+    
+    # get parameter names
+    parKeyLst = list(parameters.keys())
+    initialGuessCopy = list(initialGuess)
+    
+    # number of parameters
+    nParameters = len(parKeyLst)
+    
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    resultsFile = '' # if resultsFile name is provided, write solution to resultsFile
+    if 'resultsFile' in kwargs: 
+        resultsFile = kwargs['resultsFile']
+    
+    maxiter = 200*nParameters # maximum iterations used by th solver (default value of method='Nelder-Mead')
+    if 'maxiter' in options:
+        maxiter = options['maxiter']
+    
+    
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # get boundaries ((min, max), ... ,(min, max))
+    bounds = [None]*nParameters 
+    for i in range(nParameters):
+        bounds[i] = parameters[parKeyLst[i]]    
+    bounds = tuple(bounds) # type cast: list --> tuple
+    
+    useScipyBounds = False
+    scipyMinimizeBounds = None # 'bounds' option of scipy.optimize.minimize() will not be used!
+    if 'useScipyBounds' in kwargs: 
+        if kwargs['useScipyBounds']:
+            useScipyBounds = True
+            scipyMinimizeBounds = bounds # use option 'bounds'
+        
+    
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # process initial guess
+    if initialGuessCopy == []: # initial guess has been provided by the user
+        initialGuessCopy = [None]*nParameters
+        for i in range(nParameters):
+            initialGuessCopy[i] = np.mean(bounds[i])
+
+
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #create lists for output
+    parameterValueLst = [None]*nParameters # type=list(list()); contains parameter values for each iteration
+    for i in range(nParameters):
+        parameterValueLst[i] = []
+    valueList = [] # objective function value for initial guess parameters
+
+
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # map initialGuess list --> dict 
+    def ParameterListToParameterDict(initialGuess, *args):
+        paraDict = {}
+        for i in range(nParameters):
+            paraDict[parKeyLst[i]] = initialGuess[i]
+
+        if addComputationIndex: # add computation index
+            paraDict['computationIndex'] = 0 #itCtr[0]
+        
+        return paraDict
+         
+    
+    # count number of iterations
+    itCtr = [0]
+    resultsFileCnt = [0] # counter for output file
+
+    # this function is a inerface to exudyn.processing.WriteToFile()
+    def WriteToFileMinimize(resFileName, parDictInit, pDict, objFunVal, resFileCnt):       
+        resultsFileCntTemp = WriteToFile(resFileName, 
+                                         parDictInit, # parameter dict with value range supplied by user
+                                         [pDict], # parameter values 
+                                         [objFunVal], # objective function values
+                                         resFileCnt, # line counter --> write data to file at this line
+                                         writeHeader = (resFileCnt == 0), 
+                                         fileType='optimization using scipy.optimize.minimize(method='+method+')',
+                                         )
+        return resultsFileCntTemp
+
+    startTime = time.time()  #for calculating time to go
+    timePrintLast = [startTime-10]
+
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # callback: needed to get parameters after each iteration for file writing and post processing
+    def StoreParameterFunctionValues(parametersAtIteration, convergence=0, lastTime=False):
+        #global timePrintLast
+        # print(parametersAtIteration2)
+        for i in range(nParameters):
+            parameterValueLst[i].append(parametersAtIteration[i])
+        
+        # map initial guess (type list) to dict
+        pDict = ParameterListToParameterDict(parametersAtIteration)
+
+        if storeFunctionValues or resultsFile != '':
+            # compute objective function value        
+            valuesAtIteration = objectiveFunction(pDict)  #additional costs!
+            valueList.append(valuesAtIteration) # add value to value list
+            # write parameters and objective function at current iteration to file
+            if resultsFile != '':
+                resultsFileCnt[0] = WriteToFileMinimize(resultsFile, parameters, pDict, valuesAtIteration, resultsFileCnt[0])
+        
+        # increase iteration counter 
+        itCtr[0] += 1 
+        
+        # time needed for iteration     
+        iterationsToGo = (maxiter-itCtr[0]) 
+        timeToGo = 0
+        currentTime = time.time()
+        timeSpent = currentTime - startTime
+        if itCtr[0] != 0:
+            timeToGo = timeSpent/itCtr[0] * iterationsToGo
+
+        # print progess to console 
+        if showProgress: 
+            if currentTime - timePrintLast[0] > 1 or lastTime:
+                timePrintLast[0] = currentTime
+                print('iteration ' + str(itCtr[0]) + ' / ' + str(maxiter), end='')
+                print(', time = '+str(round(timeSpent,2)), 's / ',end='')
+                print(str(round(timeToGo,2)) + 's',end='')
+                print(', loss:', ("{:.0"+str(3)+"g}").format(valuesAtIteration))
+            
+
+
+
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # local parameterFunction used for minimization
+    def ParameterFunctionMinimize(parametersAtIteration):
+    
+        if not useScipyBounds: # if useScipyBounds=True, use scipy option 'bounds', else apply manual enforcement of bounds. 
+            if enforceBounds: # enforce bounds by mapping initial guess to allowed parameter range
+                for i in range(nParameters):
+                    pVal = parametersAtIteration[i]
+                    lowerBound = min(bounds[i])
+                    upperBound = max(bounds[i])
+                    if pVal < lowerBound:
+                        parametersAtIteration[i] = lowerBound
+                    if pVal > upperBound:
+                        parametersAtIteration[i] = upperBound
+
+        return objectiveFunction(ParameterListToParameterDict(parametersAtIteration))
+    
+    
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # perform optimizaion
+    optimizeResult = optimize.minimize(ParameterFunctionMinimize, 
+                                       initialGuessCopy, 
+                                        method=method, 
+                                        bounds=scipyMinimizeBounds, 
+                                        # callback=partial(StoreParameterFunctionValues, convergence=0, callbackArgs=callbackArgs), 
+                                        callback=StoreParameterFunctionValues, 
+                                        tol=tol,
+                                        options=options,
+                                        )
+    
+    # if showProgress: # print progress data for final iteration to console
+    StoreParameterFunctionValues(optimizeResult['x'], lastTime=True)
+    
+    if debugMode: # show solver informations (e.g. number of function evaluations etc.)
+        print('---------------------------------------\n')
+        print('solver output:\n')
+        print(optimizeResult, '\n')
+        print('---------------------------------------\n')
+
+    # iteration ctr of optimize.minimize is one-based! --> add first (0th) iteration to itCtr
+    itCtr = itCtr[0] + 1  
+
+    # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    # optimization results; generate same data for return as in GeneticOptimization()
+    optimizedParameter = optimizeResult['x']
+    optimumValue = optimizeResult['fun']
+    parameterList = {}
+    optimumParameter = {}
+    for i in range(nParameters):
+        parameterList[parKeyLst[i]] = parameterValueLst[i]
+        optimumParameter[parKeyLst[i]] = optimizedParameter[i]
+        
+    return [optimumParameter, optimumValue, parameterList, valueList]
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
+#**function: Perform a sensitivity analysis by successively calling the function parameterFunction(parameterList[i]) with a one at a time variation of parameters in the defined increments. 
+#  e.g., parameterList[0] =['mass':13, 'stiffness':12000] to be computed and returns a value or a list of values which is then stored for each parameter
+#**input:
+#    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns one or more output values for which the sensitivity is calculated
+#    parameters: given as a dictionary, consist of name and tuple of (begin, Variation steps, numberOfValues) e.g. 'mass':(10,0.01,5), for a reference mass of 10, incremented by 0.01*10 and using 5 steps in negative and positive, doing 10 steps in total
+#    scaledByReference: if true multiplies the sensitivities with the corresponding reference parameters, so that the sensitivity resembles a change relative to the reference value
+#    debugMode: if True, additional information is shown
+#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter etc. 
+#    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
+#    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
+#    resultsFile: if provided, output is immediately written to resultsFile during processing
+#    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
+#    parameterFunctionData: dictionary containing additional data passed to the parameterFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
+#**output:
+#    returns [parameterList, valRef, valuesSorted, sensitivity], parameterList containing the list of dictionaries processed. valRef is the Solution for the reference values paramList[0], valuesSorted contains the results sorted by the dictionary key that was varied in the simulation. The sensitivity contains the calculated sensitivity, where the rows are the corresponding outputparameters, while the columns are the input parameters, thereby the index sensitivity[1,0] is the sensitivity of output parameter 1 with respect to the input parameter 0. 
+#**author: Peter Manzl
+#**example:
+#   ComputeSensitivities(parameterFunction=ParameterFunction, parameters = {'mass': (mRef, 0.01, 3), 'spring': (1000,0.01, 10),}, multiprocessing=True)
+def ComputeSensitivities(parameterFunction, parameters, scaledByReference=False, 
+                       debugMode=False, addComputationIndex=False, useMultiProcessing=False, 
+                       showProgress = True, parameterFunctionData=dict(),**kwargs):
+    
+    
+    if 'multiprocessing' in sys.modules:
+        from multiprocessing import cpu_count
+        numberOfThreads = cpu_count() #cpu_count gives number of threads
+        if debugMode:
+            print("using", numberOfThreads, "cpus")
+    else:
+        numberOfThreads = 8
+    if 'numberOfThreads' in kwargs: 
+        numberOfThreads = kwargs['numberOfThreads']
+
+    resultsFile = ''
+    if 'resultsFile' in kwargs: 
+        resultsFile = kwargs['resultsFile']
+        
+    paramKeys = list(parameters.keys())
+    for i in range(len(parameters)): 
+        iKey = paramKeys[i]
+        if not(hasattr(parameters[iKey], '__iter__')): # 
+            parameters[iKey] = (parameters[iKey], 1e-3) # only a scalar value for reference value is given
+        if len(parameters[iKey]) == 2: 
+            parameters[iKey] = tuple(list(parameters[iKey]) + [0])
+    # create Reference parameters [0]
+    parameterList = [] #list of parameter dictionaries
+    
+    parameterList += [{paramKeys[0]: parameters[paramKeys[0]][0]}]
+    nVar = [parameters[paramKeys[0]][2]]
+    for i in range(1, len(paramKeys)): 
+        parameterList[0][paramKeys[i]] = parameters[paramKeys[i]][0]
+        nVar += [parameters[paramKeys[i]][2]]
+    
+    
+    
+    for i in range(len(nVar)):
+        iKey =paramKeys[i] 
+
+        fVal = parameters[iKey][1]
+        # except 
+        if debugMode: 
+            print('Variate {} by {} each in {} steps'.format(iKey, fVal, nVar[i]))
+        
+        if nVar[i] == 0: # use forward difference
+            parameterList += [deepcopy(parameterList[0])]
+            parameterList[-1][iKey] = parameterList[-1][iKey] * (1+fVal)
+        else:         
+            for j in range(nVar[i]*2): 
+                if j < nVar[i]: 
+                    jVar = j -  nVar[i]
+                else: 
+                    jVar = j  - nVar[i] +1
+                parameterList += [deepcopy(parameterList[0])]
+                valVar = max(jVar*fVal, 1e-6) # if fVal == 0! 
+                parameterList[-1][iKey] = parameterList[-1][iKey] *(1+jVar*fVal)
+                if parameterList[-1][iKey] == 0: 
+                    parameterList[-1][iKey] += max(fVal, 1e-6)
+    
+    if addComputationIndex: 
+        for cnt in range(1, len(parameterList)): 
+            parameterList[cnt]['computationIndex'] = cnt
+        
+    if parameterFunctionData != {}:
+        for cnt in range(0, len(parameterList)): 
+            parameterList[cnt]['functionData'] = parameterFunctionData
+
+    values = ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, 
+                                  showProgress = showProgress, numberOfThreads=numberOfThreads,
+                                  resultsFile = resultsFile, parameters=parameters)
+   
+    if not(hasattr(values[0], '__iter__')): 
+        # if sensitivity is only calculated regarding to one output, reshape
+        # calculated values in 2D array to support same indexing
+        values = np.reshape(values, [-1,1])
+
+    # calculate sensitivity of the parameter by forward/central difference
+    sensitivity = np.zeros([len(nVar), len(values[0])])
+    valuesSorted = {paramKeys[0]: []}
+    iForward = nVar[0] + 1
+    iBackward = nVar[0]
+    for i in range(sensitivity.shape[0]): # iterate over keys from input
+        iKey = paramKeys[i]
+        for j in range(sensitivity.shape[1]): # iterate over outputvalues 
+            if nVar[i] == 0: # use forward difference
+                sensitivity[i][j] = (values[iForward][j] - values[0][j])/(parameterList[iForward][iKey] - parameterList[0][iKey])
+            else:
+                sensitivity[i][j] = (values[iForward][j] - values[iBackward][j])/(parameterList[iForward][iKey] - parameterList[iBackward][iKey])
+            
+            if scaledByReference: # multiply with the reference value so the sensitivity shows the influence by change of percent of the input
+                sensitivity[i][j] = sensitivity[i][j] * parameterList[0][iKey]
+        if nVar[i] == 0: 
+            valuesSorted[iKey] = np.array([values[iForward]])
+            iForward +=1
+            iBackward = iForward - 1
+        else: 
+            valuesSorted[iKey] = np.array(values[iBackward-nVar[i]+1:iForward+nVar[i]])
+            try: 
+                iForward += nVar[i] + nVar[i+1]
+            except: 
+                continue
+            iBackward = iForward -1
+    valRef = values[0]
+    return [parameterList, valRef, valuesSorted, sensitivity]
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: visualize results of optimization for every parameter (2D plots)
+#**input: 
+#   parameterList: taken from output parameterList of \texttt{GeneticOptimization}, containing a dictinary with lists of parameters
+#   valueList: taken from output valueList of \texttt{GeneticOptimization}; containing a list of floats that result from the objective function
+#   xLogScale: use log scale for x-axis
+#   yLogScale: use log scale for y-axis
+#**output: return [figList, axList] containing the corresponding handles; creates a figure for every parameter in parameterList
+def PlotOptimizationResults2D(parameterList, valueList, xLogScale=False, yLogScale=False):
+    import matplotlib.pyplot as plt
+    import matplotlib.ticker as ticker
+    plt.close("all")
+
+    n = len(valueList) #length of data
+    if  n == 0:
+        print('WARNING: PlotOptimizationResults: parameterList has zero length and therefore terminates!')
+    
+    figList = []
+    axList = []
+    for key in parameterList:
+        fig = plt.figure()
+        figList += [fig]
+        ax=fig.gca() # get current axes
+        axList+=[ax]
+
+        parameterData = parameterList[key]
+        if n != len(parameterData):
+            raise ValueError('PlotOptimizationResults: length of parameterList is different from length of valueList')
+        
+        ax.plot(parameterData, valueList, 'b.', label=key) 
+        ax.set_ylabel('value (objective function)')
+        ax.set_xlabel(key)
+
+
+        ax.grid(True, 'major', 'both')
+        ax.xaxis.set_major_locator(ticker.MaxNLocator(10)) 
+        ax.yaxis.set_major_locator(ticker.MaxNLocator(10)) 
+
+        if xLogScale:
+            ax.set_xscale('log')
+        if yLogScale:
+            ax.set_yscale('log')
+            
+
+        plt.tight_layout()
+        plt.legend()
+
+    plt.show() 
+    return [figList, axList]
+
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: visualize results of Sensitivityanalyis for every parameter (2D plots)
+#**input: 
+#   valRef: The output values of the reference solution
+#   valuesSorted: The output values of the analysed function sorted by the parameter which was varied
+#   sensitivity: The sensitivity Matrix calculated by the function \texttt{ComputeSensitivities()}
+#   fVar: The list of variation stepsizes. It is assumed to be 1e-3 if not defined.
+#   strYAxis: A list of strings to label the plots yAxis
+#   
+#**output: return [fig, axs] containing the corresponding handles; creates a subplot for every row in the sensitivity matrix
+#**author: Peter Manzl
+def PlotSensitivityResults(valRef, valuesSorted, sensitivity, fVar=None, strYAxis = None):
+    import matplotlib.pyplot as plt
+    if strYAxis == None: 
+        strYAxis = ['']*sensitivity.shape[1]
+    if fVar == None: 
+        fVar = [1e-3] * sensitivity.shape[1]
+    if type(fVar) != list: # if one scalar varaible is passed it is assumed it is the same for each parameter
+        fVar = [fVar]*sensitivity.shape[1]
+    # the rows of the sensitivity are the different outputparameters, while the columns are the input parameters
+    n = []
+    fig, axs = plt.subplots(sensitivity.shape[1]) 
+    if sensitivity.shape[1] == 1: 
+        axs = [axs] # enable indexing for loop also for a single value
+    for i in range(sensitivity.shape[1]): # each type of values gets a subplot 
+        for j in range(len(list(valuesSorted.keys()))): # iterate over the variated parameters/keys
+            iKey = list(valuesSorted.keys())[j]
+            n += [int(len(valuesSorted[iKey])/2)] # there are +- n variations = 2*2 in the list
+            iVar = np.linspace(-n[j]*fVar[i]*100, n[j]*fVar[i]*100, 2*n[j]+1) # variations 
+            if len(iVar) != 1: 
+                iPlt = iVar # 2*n+1, contains the reference value
+                
+                pltValues = np.r_[valuesSorted[iKey][:int(len(iVar)/2),i], valRef[i], valuesSorted[iKey][int(len(iVar)/2):,i]] 
+            else: 
+                pltValues = [valRef[i], valuesSorted[iKey][0,i]]
+                iVar = np.r_[iVar, fVar[i]*100]
+                iPlt = iVar
+            iVar = np.delete(iVar, n[j]) # without the reference value
+            axs[i].plot(iPlt, pltValues, '--', color=np.ones(3)*0.8) # connect all values including reference values
+            if sensitivity[j,i] != 0: 
+                sDigits = int(-np.log10(abs(sensitivity[j,i])) + 4)
+            else: 
+                sDigits = 1
+            axs[i].plot(iVar, valuesSorted[iKey][:,i], 'o', label='{}, s={}'.format(iKey, np.round(sensitivity[j,i], sDigits))) # plot variation as points
+        axs[i].plot(0, valRef[i], 'd', label='Ref') # reference value in the center of plot
+        axs[i].set(ylabel=strYAxis[i])
+        axs[i].legend()
+        axs[i].grid()
+    axs[-1].set( xlabel='Variation in $\\%$') # in % because spacing is fVar*100 on x-Axis
+    plt.tight_layout()
+    return [fig, axs]
+
```

## exudyn/resultsMonitor.py

 * *Ordering differences only*

```diff
@@ -1,366 +1,366 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN helper file
-#
-# Details:  Use this script to continuously visualize results;
-#           command line Usage (cmd): python resultsMonitor.py results.txt -updateTime=0.2 -plotMode=lines -logx -logy
-#
-# Author:   Johannes Gerstmayr 
-# Date:     2021-01-14
-# Notes:    Parallel processing, which requires multiprocessing library, can lead to considerable speedup (measured speedup factor > 50 on 80 core machine). The progess bar during multiprocessing requires the library tqdm.
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import sys
-
-doDebug = False
-
-if doDebug:
-    print("number of args=",len(sys.argv))
-    print("args=",sys.argv)
-argList = sys.argv
-# for i in sys.argv:
-#     print("arg=",i)
-
-import matplotlib.pyplot as plt
-import numpy as np
-from exudyn.plot import ParseOutputFileHeader
-from exudyn.advancedUtilities import PlotLineCode
-from exudyn.processing import SingleIndex2SubIndices
-
-listMarkerStyles = ['. ', '+', 'x ', 'v ', '^ ', '< ', '> ', '* ', 'd ', 'D', 's', 'X ', 'P', 'o', 'p ', 'h ', 'H ']
-
-def GetMarkerColorCode(i):
-    j = int(i/7)
-    if j >= len(listMarkerStyles):
-        j = 0
-    c = PlotLineCode(i%7)[0]+listMarkerStyles[j]
-
-x = np.linspace(0, 6*np.pi, 100)
-y = np.sin(x)
-
-plt.ion() #interactive mode on
-
-
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#default values
-updatePeriod = 1. #one second update rate
-lineColor = 'b'
-lineStyle = '-'
-logX = False
-logY = False
-colorVariations = False
-sizeXinInches = 5
-sizeYinInches = 5
-xColumns = [] #which columns to read data for x-axis
-yColumns = [] #which columns to read data for y-axis
-xLabels = [] #labels per plot
-yLabels = [] #labels per plot
-addMarker = False #add marker to last point in curve
-fileName = '' #must be set
-variations = []
-
-#parse command line arguments:
-runLoader = True
-nArgs = len(argList) #first argument = python file
-if nArgs < 2:
-    print("ERROR in resultsMonitor: filename missing\nuse option -h for help")
-    runLoader = False
-else:
-    if argList[1] == '-h':
-        print('usage for resultsMonitor:')
-        print('  python resultsMonitor.py file.txt')
-        print('options:')
-        print('  -xcols i,j,..: comma-separated columns (NO SPACES!) to be plotted on x-axis')
-        print('  -ycols i,j,..: comma-separated columns (NO SPACES!) to be plotted on y-axis')
-        print('  -logx: use log scale for x-axis')
-        print('  -logy: use log scale for y-axis')
-        print('  -colorVariations: for parameter variation file just plot first axis, add different colors for variations of other axes (limited to 28 colors)')
-        print('  -variations start,end: comma-separated values (NO SPACES!) for start and end index of colorVariations; -variations 0,2 plots variation 0 and 1')
-        print('  -addMarker: add marker (filled red circle) to last point in plot')
-        print('  -sizex float: float = x-size of one subplot in inches (default=5)')
-        print('  -sizey float: float = y-size of one subplot in inches (default=5)')
-        print('  -update float: float = update period in seconds (default: 1)')
-        print('  -color char: char = line color code according to pyplot, default=b (blue)')
-        print('  -style char: char = line symbol according to pyplot, default="-"')
-        print('example: (to be called from windows Anaconda prompt or in linux terminal in the directory where file.txt lies)')
-        print('  python resultsMonitor.py file.txt -logy -xcols 0,1 -ycols 2,3 -update 0.2')
-        
-        runLoader = False
-    else:
-        fileName = argList[1]
-        if doDebug:
-            print('fileName=',fileName)
-        i = 2
-        while i < nArgs:
-            if argList[i] == '-xcols':
-                strList = argList[i+1].split(',')
-                xColumns = []
-                for s in strList:
-                    xColumns += [int(s)]
-                i=i+1
-            elif argList[i] == '-ycols':
-                strList = argList[i+1].split(',')
-                yColumns = []
-                for s in strList:
-                    yColumns += [int(s)]
-                i=i+1
-            elif argList[i] == '-logx':
-                logX = True
-            elif argList[i] == '-logy':
-                logY = True
-            elif argList[i] == '-colorVariations':
-                colorVariations = True                
-            elif argList[i] == '-variations':
-                strList = argList[i+1].split(',')
-                for s in strList:
-                    variations += [int(s)]
-                i=i+1
-            elif argList[i] == '-addMarker':
-                addMarker = True
-            elif argList[i] == '-sizex':
-                sizeXinInches = float(argList[i+1]); i=i+1
-            elif argList[i] == '-sizey':
-                sizeYinInches = float(argList[i+1]); i=i+1
-            elif argList[i] == '-update':
-                updatePeriod = float(argList[i+1]); i=i+1
-            elif argList[i] == '-color':
-                lineColor = argList[i+1]; i=i+1
-            elif argList[i] == '-style':
-                lineStyle = argList[i+1]; i=i+1
-            else:
-                print("WARNING: unknown argument '"+argList[i]+"' ignored")
-                
-            i += 1
-            
-if runLoader:
-    #%%+++++++++++++++++++++++++++++
-    #check if file is ready
-    fileReady = False
-    lines = []
-    while not fileReady:
-        file = open(fileName, 'r')
-        lines = file.readlines()
-        file.close()
-        if len(lines) >= 1:
-            hasComment = False
-            hasData = False
-            for line in lines:
-                if line[0] == '#':
-                    hasComment = True
-                elif line[0] != '#':
-                    hasData = True
-            if hasComment and hasData:
-                fileReady = True
-    
-    #%%+++++++++++++++++++++++++++++
-    #now we can interpret data
-
-    header = ParseOutputFileHeader(lines)
-    #print('header=',header)
-    if header['type'] == 'geneticOptimization' or header['type'] == 'parameterVariation':
-        lineStyle = '.'
-        colValue = -1
-        nColumnsProcessed = len(header['columns'])
-        for i in range(nColumnsProcessed):
-            col = header['columns'][i]
-            if col != 'globalIndex' and col != 'computationIndex' and col != 'value':
-                xColumns += [i]
-                xLabels += [col]
-                if header['type'] == 'geneticOptimization':
-                    yLabels += ['fitness']
-                elif header['type'] == 'parameterVariation':
-                    yLabels += ['result']
-            elif col == 'value':
-                colValue = i #fitness value is always second column in genetic optimization and parameter variation
-        yColumns = [colValue]*len(xColumns)
-    elif header['type'] == 'sensor' or header['type'] == 'solution':
-        if len(xColumns) == 0: #automatically choose all columns
-            for i in range(len(header['columns'])-1): #exclude time
-                yColumns += [i+1] #exclude time
-                xColumns += [0] #automatically choose time
-        if len(xColumns) != len(yColumns):
-            print('ERROR in resultsLoader: size of xColumns not equal to yColumns! terminating...')
-            runLoader = False
-        else:
-            for i in range(len(xColumns)):
-                xLabels += [header['columns'][xColumns[i]]]
-                yLabels += [header['columns'][yColumns[i]]]
-    else:
-        print('ERROR in resultsLoader: unknown file header! terminating...')
-        runLoader = False
-    
-    if len(xColumns)*len(yColumns)*len(xLabels)*len(yLabels) == 0:
-        print('ERROR in resultsLoader: no valid columns given! terminating...')
-        runLoader = False
-
-    if doDebug:
-        print('xColumns=',xColumns)
-        print('yColumns=',yColumns)
-        print('xLabels=',xLabels)
-        print('yLabels=',yLabels)
-    
-if runLoader:    
-    #generate subplots:
-    nPlots = len(xColumns)
-    nVariations = 1 #regular case
-    variableRanges = header['variableRanges']
-
-    maxCols = int(np.sqrt(nPlots)+1)
-    if nPlots == 3:
-        maxCols = 3
-    if nPlots == 4:
-        maxCols = 2
-    nRows = int(np.ceil(nPlots/maxCols))
-    nCols = nPlots
-    if nCols > maxCols:
-        nCols = maxCols
-    # print("nRows=",nRows,", nCols=", nCols)
-    if colorVariations:
-        # print('variableRanges=',variableRanges)
-        for rangeI in variableRanges[1:]:
-            nVariations *= rangeI[2] #this is the number of variations
-        # print('plot',nVariations,'variations')
-        nPlots=nVariations
-        if variations == []:
-            variations = [0,nPlots]
-        else:
-            nPlots = variations[1]-variations[0]
-        nCols=1 #everything in one plot
-        nRows=1
-    
-    fig = plt.figure('Results monitor')
-    fig.dpi = 100 #in terminal, initially set to 200
-    fig.tight_layout()
-    fig.set_size_inches(nCols*sizeXinInches, nRows*sizeYinInches, forward=True)
-    
-    axList = []
-    lineList = []
-    markerList = []
-    for i in range(nPlots):
-        if not colorVariations or i==0:
-            ax = fig.add_subplot(nRows,nCols,i+1)
-            
-        ax.grid(True, 'major', 'both')
-        axList += [ax]
-        if logX:
-            ax.set_xscale('log')
-        if logY:
-            ax.set_yscale('log')
-        lineColorStyle=lineColor+lineStyle
-        if colorVariations:
-            lineColorStyle = PlotLineCode(i)
-            # print(listMarkerStyles[i%7][0])
-            lineColorStyle = lineColorStyle[0]+listMarkerStyles[int(i/7)][0]
-
-        line, = ax.plot(0.1,0.1, lineColorStyle)
-        lineList += [line] #empty plot
-        
-        if addMarker: #red circle at end of line
-            markerColorCode = 'ro'
-            line, = ax.plot(0.1,0.1, markerColorCode) #red circle
-            markerList += [line] #empty plot
-            
-    
-    finished = False #finish when plot window is closed ...
-    if len(xColumns) == 0:
-        finished = True
-    
-    #main updating loop, until user closes window:
-    firstRun = True
-    while not finished:
-        #data = np.loadtxt(fileName, delimiter=',') does not work with inconsistent data
-        data = np.genfromtxt(fileName,comments='#',delimiter=',',invalid_raise=False)
-        if data.ndim == 2: #if only one line, ndim=1 and data[:,xColumns[i]] crashes!
-            for i in range(nPlots):
-                ax = axList[i]
-                # ax.clear() #slow
-                # ax.plot(data[:,xColumns[i]], data[:,yColumns[i]], lineColor+lineStyle) 
-                if not colorVariations:
-                    dataX = data[:,xColumns[i]]
-                    dataY = data[:,yColumns[i]]
-                else:
-                    dataRows = data.shape[0]
-                    # print('rows= ',dataRows)
-                    ii = variations[0] + i
-                    nRanges=[]
-                    for kRange in variableRanges:
-                        nRanges += [kRange[2]]
-
-                    n0 = nRanges[0]
-                    nRest = np.array(nRanges[1:]).prod() #remaining range
-                    # print('n ranges=', nRanges)
-                    # print('variableRanges=',variableRanges)
-                    subIndices = SingleIndex2SubIndices(ii, nRanges[1:]) #i runs in subindices
-                    subValues = []
-                    for j in range(len(subIndices)):
-                        valueStart = variableRanges[j+1][0]
-                        valueEnd = variableRanges[j+1][1]
-                        value = valueStart
-                        if nRanges[j+1] > 1:
-                            value += (valueEnd-valueStart)*(subIndices[j]/(nRanges[j+1]-1))
-                        subValues += [value]
-                    # print('subIndices=', subIndices)
-                    jIndex0 = np.arange(n0)*nRest+ii
-                    # print(jIndex0)
-                    #check if data is available:
-                    if dataRows < max(jIndex0):
-                        jIndex = []
-                        for j in jIndex0:
-                            if j < dataRows:
-                                jIndex += [j]
-                        #print('new indices=',jIndex)
-                        jIndex = np.array(jIndex)
-                    else:
-                        jIndex = jIndex0
-                    
-                    if len(jIndex) == 0:
-                        continue
-                    
-                    dataX = data[jIndex,xColumns[0]]
-                    dataY = data[jIndex,yColumns[0]]
-                    
-                    # ax.set_label('asdf')
-                    # ax.legend()
-                    sLabel = 'var'+str(ii)+':'
-                    for kRange in range(len(nRanges)-1):
-                        #print('kRange=',kRange)
-                        colName = header['columns'][kRange+1+2] #offset 1 to take first sub index; offset 2 for globalindex and value
-                        sLabel += colName[0:5]+str(round(subValues[kRange],3))+' '
-                        #sLabel += colName[0:5]+str(subIndices[kRange])
-                        
-                    lineList[i].set_label(sLabel)
-                    ax.legend()
-
-
-                if logX:
-                    dataX = abs(dataX)
-                if logY:
-                    dataY = abs(dataY)
-                lineList[i].set_data(dataX, dataY) 
-
-                if addMarker:
-                    markerList[i].set_data(dataX[-1], dataY[-1])
-
-                if not colorVariations or i==0:
-                    ax.set_xlabel(xLabels[i])
-                    ax.set_ylabel(yLabels[i])
-                    
-                #next two commands to zoom all ...:
-                ax.relim()
-                ax.autoscale_view()
-                
-            fig.canvas.draw()
-            fig.canvas.flush_events()
-            #print("dpi=", fig.dpi)
-    
-        plt.pause(updatePeriod)
-        if not plt.fignum_exists(fig.number):
-            finished = True
-        #firstRun = False
-    
-    print("Plot window closed by user.")
-    
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN helper file
+#
+# Details:  Use this script to continuously visualize results;
+#           command line Usage (cmd): python resultsMonitor.py results.txt -updateTime=0.2 -plotMode=lines -logx -logy
+#
+# Author:   Johannes Gerstmayr 
+# Date:     2021-01-14
+# Notes:    Parallel processing, which requires multiprocessing library, can lead to considerable speedup (measured speedup factor > 50 on 80 core machine). The progess bar during multiprocessing requires the library tqdm.
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import sys
+
+doDebug = False
+
+if doDebug:
+    print("number of args=",len(sys.argv))
+    print("args=",sys.argv)
+argList = sys.argv
+# for i in sys.argv:
+#     print("arg=",i)
+
+import matplotlib.pyplot as plt
+import numpy as np
+from exudyn.plot import ParseOutputFileHeader
+from exudyn.advancedUtilities import PlotLineCode
+from exudyn.processing import SingleIndex2SubIndices
+
+listMarkerStyles = ['. ', '+', 'x ', 'v ', '^ ', '< ', '> ', '* ', 'd ', 'D', 's', 'X ', 'P', 'o', 'p ', 'h ', 'H ']
+
+def GetMarkerColorCode(i):
+    j = int(i/7)
+    if j >= len(listMarkerStyles):
+        j = 0
+    c = PlotLineCode(i%7)[0]+listMarkerStyles[j]
+
+x = np.linspace(0, 6*np.pi, 100)
+y = np.sin(x)
+
+plt.ion() #interactive mode on
+
+
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#default values
+updatePeriod = 1. #one second update rate
+lineColor = 'b'
+lineStyle = '-'
+logX = False
+logY = False
+colorVariations = False
+sizeXinInches = 5
+sizeYinInches = 5
+xColumns = [] #which columns to read data for x-axis
+yColumns = [] #which columns to read data for y-axis
+xLabels = [] #labels per plot
+yLabels = [] #labels per plot
+addMarker = False #add marker to last point in curve
+fileName = '' #must be set
+variations = []
+
+#parse command line arguments:
+runLoader = True
+nArgs = len(argList) #first argument = python file
+if nArgs < 2:
+    print("ERROR in resultsMonitor: filename missing\nuse option -h for help")
+    runLoader = False
+else:
+    if argList[1] == '-h':
+        print('usage for resultsMonitor:')
+        print('  python resultsMonitor.py file.txt')
+        print('options:')
+        print('  -xcols i,j,..: comma-separated columns (NO SPACES!) to be plotted on x-axis')
+        print('  -ycols i,j,..: comma-separated columns (NO SPACES!) to be plotted on y-axis')
+        print('  -logx: use log scale for x-axis')
+        print('  -logy: use log scale for y-axis')
+        print('  -colorVariations: for parameter variation file just plot first axis, add different colors for variations of other axes (limited to 28 colors)')
+        print('  -variations start,end: comma-separated values (NO SPACES!) for start and end index of colorVariations; -variations 0,2 plots variation 0 and 1')
+        print('  -addMarker: add marker (filled red circle) to last point in plot')
+        print('  -sizex float: float = x-size of one subplot in inches (default=5)')
+        print('  -sizey float: float = y-size of one subplot in inches (default=5)')
+        print('  -update float: float = update period in seconds (default: 1)')
+        print('  -color char: char = line color code according to pyplot, default=b (blue)')
+        print('  -style char: char = line symbol according to pyplot, default="-"')
+        print('example: (to be called from windows Anaconda prompt or in linux terminal in the directory where file.txt lies)')
+        print('  python resultsMonitor.py file.txt -logy -xcols 0,1 -ycols 2,3 -update 0.2')
+        
+        runLoader = False
+    else:
+        fileName = argList[1]
+        if doDebug:
+            print('fileName=',fileName)
+        i = 2
+        while i < nArgs:
+            if argList[i] == '-xcols':
+                strList = argList[i+1].split(',')
+                xColumns = []
+                for s in strList:
+                    xColumns += [int(s)]
+                i=i+1
+            elif argList[i] == '-ycols':
+                strList = argList[i+1].split(',')
+                yColumns = []
+                for s in strList:
+                    yColumns += [int(s)]
+                i=i+1
+            elif argList[i] == '-logx':
+                logX = True
+            elif argList[i] == '-logy':
+                logY = True
+            elif argList[i] == '-colorVariations':
+                colorVariations = True                
+            elif argList[i] == '-variations':
+                strList = argList[i+1].split(',')
+                for s in strList:
+                    variations += [int(s)]
+                i=i+1
+            elif argList[i] == '-addMarker':
+                addMarker = True
+            elif argList[i] == '-sizex':
+                sizeXinInches = float(argList[i+1]); i=i+1
+            elif argList[i] == '-sizey':
+                sizeYinInches = float(argList[i+1]); i=i+1
+            elif argList[i] == '-update':
+                updatePeriod = float(argList[i+1]); i=i+1
+            elif argList[i] == '-color':
+                lineColor = argList[i+1]; i=i+1
+            elif argList[i] == '-style':
+                lineStyle = argList[i+1]; i=i+1
+            else:
+                print("WARNING: unknown argument '"+argList[i]+"' ignored")
+                
+            i += 1
+            
+if runLoader:
+    #%%+++++++++++++++++++++++++++++
+    #check if file is ready
+    fileReady = False
+    lines = []
+    while not fileReady:
+        file = open(fileName, 'r')
+        lines = file.readlines()
+        file.close()
+        if len(lines) >= 1:
+            hasComment = False
+            hasData = False
+            for line in lines:
+                if line[0] == '#':
+                    hasComment = True
+                elif line[0] != '#':
+                    hasData = True
+            if hasComment and hasData:
+                fileReady = True
+    
+    #%%+++++++++++++++++++++++++++++
+    #now we can interpret data
+
+    header = ParseOutputFileHeader(lines)
+    #print('header=',header)
+    if header['type'] == 'geneticOptimization' or header['type'] == 'parameterVariation':
+        lineStyle = '.'
+        colValue = -1
+        nColumnsProcessed = len(header['columns'])
+        for i in range(nColumnsProcessed):
+            col = header['columns'][i]
+            if col != 'globalIndex' and col != 'computationIndex' and col != 'value':
+                xColumns += [i]
+                xLabels += [col]
+                if header['type'] == 'geneticOptimization':
+                    yLabels += ['fitness']
+                elif header['type'] == 'parameterVariation':
+                    yLabels += ['result']
+            elif col == 'value':
+                colValue = i #fitness value is always second column in genetic optimization and parameter variation
+        yColumns = [colValue]*len(xColumns)
+    elif header['type'] == 'sensor' or header['type'] == 'solution':
+        if len(xColumns) == 0: #automatically choose all columns
+            for i in range(len(header['columns'])-1): #exclude time
+                yColumns += [i+1] #exclude time
+                xColumns += [0] #automatically choose time
+        if len(xColumns) != len(yColumns):
+            print('ERROR in resultsLoader: size of xColumns not equal to yColumns! terminating...')
+            runLoader = False
+        else:
+            for i in range(len(xColumns)):
+                xLabels += [header['columns'][xColumns[i]]]
+                yLabels += [header['columns'][yColumns[i]]]
+    else:
+        print('ERROR in resultsLoader: unknown file header! terminating...')
+        runLoader = False
+    
+    if len(xColumns)*len(yColumns)*len(xLabels)*len(yLabels) == 0:
+        print('ERROR in resultsLoader: no valid columns given! terminating...')
+        runLoader = False
+
+    if doDebug:
+        print('xColumns=',xColumns)
+        print('yColumns=',yColumns)
+        print('xLabels=',xLabels)
+        print('yLabels=',yLabels)
+    
+if runLoader:    
+    #generate subplots:
+    nPlots = len(xColumns)
+    nVariations = 1 #regular case
+    variableRanges = header['variableRanges']
+
+    maxCols = int(np.sqrt(nPlots)+1)
+    if nPlots == 3:
+        maxCols = 3
+    if nPlots == 4:
+        maxCols = 2
+    nRows = int(np.ceil(nPlots/maxCols))
+    nCols = nPlots
+    if nCols > maxCols:
+        nCols = maxCols
+    # print("nRows=",nRows,", nCols=", nCols)
+    if colorVariations:
+        # print('variableRanges=',variableRanges)
+        for rangeI in variableRanges[1:]:
+            nVariations *= rangeI[2] #this is the number of variations
+        # print('plot',nVariations,'variations')
+        nPlots=nVariations
+        if variations == []:
+            variations = [0,nPlots]
+        else:
+            nPlots = variations[1]-variations[0]
+        nCols=1 #everything in one plot
+        nRows=1
+    
+    fig = plt.figure('Results monitor')
+    fig.dpi = 100 #in terminal, initially set to 200
+    fig.tight_layout()
+    fig.set_size_inches(nCols*sizeXinInches, nRows*sizeYinInches, forward=True)
+    
+    axList = []
+    lineList = []
+    markerList = []
+    for i in range(nPlots):
+        if not colorVariations or i==0:
+            ax = fig.add_subplot(nRows,nCols,i+1)
+            
+        ax.grid(True, 'major', 'both')
+        axList += [ax]
+        if logX:
+            ax.set_xscale('log')
+        if logY:
+            ax.set_yscale('log')
+        lineColorStyle=lineColor+lineStyle
+        if colorVariations:
+            lineColorStyle = PlotLineCode(i)
+            # print(listMarkerStyles[i%7][0])
+            lineColorStyle = lineColorStyle[0]+listMarkerStyles[int(i/7)][0]
+
+        line, = ax.plot(0.1,0.1, lineColorStyle)
+        lineList += [line] #empty plot
+        
+        if addMarker: #red circle at end of line
+            markerColorCode = 'ro'
+            line, = ax.plot(0.1,0.1, markerColorCode) #red circle
+            markerList += [line] #empty plot
+            
+    
+    finished = False #finish when plot window is closed ...
+    if len(xColumns) == 0:
+        finished = True
+    
+    #main updating loop, until user closes window:
+    firstRun = True
+    while not finished:
+        #data = np.loadtxt(fileName, delimiter=',') does not work with inconsistent data
+        data = np.genfromtxt(fileName,comments='#',delimiter=',',invalid_raise=False)
+        if data.ndim == 2: #if only one line, ndim=1 and data[:,xColumns[i]] crashes!
+            for i in range(nPlots):
+                ax = axList[i]
+                # ax.clear() #slow
+                # ax.plot(data[:,xColumns[i]], data[:,yColumns[i]], lineColor+lineStyle) 
+                if not colorVariations:
+                    dataX = data[:,xColumns[i]]
+                    dataY = data[:,yColumns[i]]
+                else:
+                    dataRows = data.shape[0]
+                    # print('rows= ',dataRows)
+                    ii = variations[0] + i
+                    nRanges=[]
+                    for kRange in variableRanges:
+                        nRanges += [kRange[2]]
+
+                    n0 = nRanges[0]
+                    nRest = np.array(nRanges[1:]).prod() #remaining range
+                    # print('n ranges=', nRanges)
+                    # print('variableRanges=',variableRanges)
+                    subIndices = SingleIndex2SubIndices(ii, nRanges[1:]) #i runs in subindices
+                    subValues = []
+                    for j in range(len(subIndices)):
+                        valueStart = variableRanges[j+1][0]
+                        valueEnd = variableRanges[j+1][1]
+                        value = valueStart
+                        if nRanges[j+1] > 1:
+                            value += (valueEnd-valueStart)*(subIndices[j]/(nRanges[j+1]-1))
+                        subValues += [value]
+                    # print('subIndices=', subIndices)
+                    jIndex0 = np.arange(n0)*nRest+ii
+                    # print(jIndex0)
+                    #check if data is available:
+                    if dataRows < max(jIndex0):
+                        jIndex = []
+                        for j in jIndex0:
+                            if j < dataRows:
+                                jIndex += [j]
+                        #print('new indices=',jIndex)
+                        jIndex = np.array(jIndex)
+                    else:
+                        jIndex = jIndex0
+                    
+                    if len(jIndex) == 0:
+                        continue
+                    
+                    dataX = data[jIndex,xColumns[0]]
+                    dataY = data[jIndex,yColumns[0]]
+                    
+                    # ax.set_label('asdf')
+                    # ax.legend()
+                    sLabel = 'var'+str(ii)+':'
+                    for kRange in range(len(nRanges)-1):
+                        #print('kRange=',kRange)
+                        colName = header['columns'][kRange+1+2] #offset 1 to take first sub index; offset 2 for globalindex and value
+                        sLabel += colName[0:5]+str(round(subValues[kRange],3))+' '
+                        #sLabel += colName[0:5]+str(subIndices[kRange])
+                        
+                    lineList[i].set_label(sLabel)
+                    ax.legend()
+
+
+                if logX:
+                    dataX = abs(dataX)
+                if logY:
+                    dataY = abs(dataY)
+                lineList[i].set_data(dataX, dataY) 
+
+                if addMarker:
+                    markerList[i].set_data(dataX[-1], dataY[-1])
+
+                if not colorVariations or i==0:
+                    ax.set_xlabel(xLabels[i])
+                    ax.set_ylabel(yLabels[i])
+                    
+                #next two commands to zoom all ...:
+                ax.relim()
+                ax.autoscale_view()
+                
+            fig.canvas.draw()
+            fig.canvas.flush_events()
+            #print("dpi=", fig.dpi)
+    
+        plt.pause(updatePeriod)
+        if not plt.fignum_exists(fig.number):
+            finished = True
+        #firstRun = False
+    
+    print("Plot window closed by user.")
+
```

## exudyn/rigidBodyUtilities.py

 * *Ordering differences only*

```diff
@@ -1,1356 +1,1356 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Advanced utility/mathematical functions for reference frames, rigid body kinematics
-#           and dynamics. Useful Euler parameter and Tait-Bryan angle conversion functions
-#           are included. A class for rigid body inertia creating and transformation is available.
-#
-# Author:   Johannes Gerstmayr, Stefan Holzinger (rotation vector and Tait-Bryan angles)
-# Date:     2020-03-10 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#constants and fixed structures:
-import numpy as np #LoadSolutionFile
-import exudyn.itemInterface as eii
-import exudyn as exu 
-from exudyn.basicUtilities import NormL2
-from exudyn.advancedUtilities import ExpectedType, RaiseTypeError, IsValidBool, IsValidRealInt, IsVector, IsSquareMatrix, IsValidObjectIndex
-from math import sin, cos #, sqrt, atan2
-
-import copy
-
-eulerParameters0 = [1.,0.,0.,0.] #Euler parameters for case where rotation angle is zero (rotation axis arbitrary)
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute orthogonal basis vectors (normal1, normal2) for given vector0 (non-unique solution!); the length of vector0 must not be 1; if vector0 == [0,0,0], then any normal basis is returned
-#**output: returns [vector0normalized, normal1, normal2], in which vector0normalized is the normalized vector0 (has unit length); all vectors in numpy array format
-def ComputeOrthonormalBasisVectors(vector0):
-    v = np.array([vector0[0],vector0[1],vector0[2]])
-
-    L0 = np.linalg.norm(v)
-    if L0 == 0:
-        n1 = np.array([1,0,0])
-        n2 = np.array([0,1,0])
-    else:
-        v = (1. / L0)*v;
-    
-        if (abs(v[0]) > 0.5) and (abs(v[1]) < 0.1) and (abs(v[2]) < 0.1):
-            n1 = np.array([0., 1., 0.])
-        else:
-            n1 = np.array([1., 0., 0.])
-    
-        h = np.dot(n1, v);
-        n1 -= h * v;
-        n1 = (1/np.linalg.norm(n1))*n1;
-        n2 = np.cross(v,n1)
-    #print("basis=", v,n1,n2)
-    return [v, n1, n2]
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute orthogonal basis, in which the normalized vector0 is the first column and the other columns are normals to vector0 (non-unique solution!); the length of vector0 must not be 1; if vector0 == [0,0,0], then any normal basis is returned
-#**output: returns A, a rotation matrix, in which the first column is parallel to vector0; A is a 2D numpy array
-def ComputeOrthonormalBasis(vector0):
-    return np.vstack(ComputeOrthonormalBasisVectors(vector0)).T
-    
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute Gram-Schmidt projection of given 3D vector 1 on vector 0 and return normalized triad (vector0, vector1, vector0 x vector1)
-def GramSchmidt(vector0, vector1):
-
-    v0 = np.array([vector0[0],vector0[1],vector0[2]])
-    L0 = np.linalg.norm(v0)
-    v0 = (1. / L0)*v0;
-    
-    v1 = np.array([vector1[0],vector1[1],vector1[2]])
-    L1 = np.linalg.norm(v1)
-    v1 = (1. / L1)*v1;
-    
-    h = np.dot(v1, v0);
-    v1 -= h * v0;
-    v1 = (1/np.linalg.norm(v1))*v1;
-    n2 = np.cross(v0,v1)
-    #print("basis=", v,n1,n2)
-    return [v0, v1, n2]
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute skew symmetric 3x3-matrix from 3x1- or 1x3-vector
-def Skew(vector):
-    skewsymmetricMatrix = np.array([[ 0.,       -vector[2], vector[1]], 
-                                    [ vector[2], 0.,       -vector[0]],
-                                    [-vector[1], vector[0], 0.]])
-    return skewsymmetricMatrix
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: convert skew symmetric matrix m to vector
-def Skew2Vec(skew):
-    shape = skew.shape
-    if shape == (3,3):
-        w1 = skew[2][1]
-        w2 = skew[0][2]
-        w3 = -skew[0][1]
-        vec = np.array([w1, w2, w3])
-    if shape == (4,4):
-        w1 = skew[2][1]
-        w2 = skew[0][2]
-        w3 = -skew[0][1]
-        u1 = skew[0][3]
-        u2 = skew[1][3]
-        u3 = skew[2][3]
-        vec = np.array([u1, u2, u3, w1, w2, w3])       
-    return vec
-
-
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute skew matrix from vector or matrix; used for ObjectFFRF and CMS implementation
-#**input: a vector v in np.array format, containing 3*n components or a matrix with m columns of same shape
-#**output: if v is a vector, output is (3*n x 3) skew matrix in np.array format; if v is a (n x m) matrix, the output is a (3*n x m) skew matrix in np.array format
-def ComputeSkewMatrix(v):
-    if type(v) == list or v.ndim == 1:
-        n = int(len(v)/3) #number of nodes
-        sm = np.zeros((3*n,3))
-
-        for i in range(n):
-            off = 3*i
-            x=v[off+0]
-            y=v[off+1]
-            z=v[off+2]
-            mLoc = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
-            sm[off:off+3,:] = mLoc[:,:]
-    
-        return sm
-    elif v.ndim==2: #dim=2
-        (nRows,nCols) = v.shape
-        n = int(nRows/3) #number of nodes
-        sm = np.zeros((3*n,3*nCols))
-
-        for j in range(nCols):
-            for i in range(n):
-                off = 3*i
-                x=v[off+0,j]
-                y=v[off+1,j]
-                z=v[off+2,j]
-                mLoc = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
-                sm[off:off+3,3*j:3*j+3] = mLoc[:,:]
-    else: 
-        print("ERROR: wrong dimension in ComputeSkewMatrix(...)")
-    return sm
-
-#tests for ComputeSkewMatrix
-#x = np.array([1,2,3,4,5,6])
-#print(ComputeSkewMatrix(x))
-#x = np.array([[1,2],[3,4],[5,6],[1,2],[3,4],[5,6]])
-#print(ComputeSkewMatrix(x))
-
-
-# OLD / duplicate with less functionality!
-# #**function: compute (3 x 3*n) skew matrix from (3*n) vector
-# def ComputeSkewMatrix(v):
-#     n = int(len(v)/3) #number of nodes
-#     sm = np.zeros((3*n,3))
-
-#     for i in range(n):
-#         off = 3*i
-#         x=v[off+0]
-#         y=v[off+1]
-#         z=v[off+2]
-#         sm[off:off+3,:] = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
-#         # mLoc = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
-#         # sm[off:off+3,:] = mLoc[:,:]
-    
-#     return sm
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#helper functions for RIGID BODY KINEMATICS:
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: convert Euler parameters (ep) to G-matrix (=$\partial \tomega  / \partial \pv_t$)
-#**input: vector of 4 eulerParameters as list or np.array
-#**output: 3x4 matrix G as np.array
-def EulerParameters2G(eulerParameters):
-    ep = eulerParameters
-    return np.array([[-2.*ep[1], 2.*ep[0],-2.*ep[3], 2.*ep[2]],
-                     [-2.*ep[2], 2.*ep[3], 2.*ep[0],-2.*ep[1]],
-                     [-2.*ep[3],-2.*ep[2], 2.*ep[1], 2.*ep[0]] ])
-
-#**function: convert Euler parameters (ep) to local G-matrix (=$\partial \LU{b}{\tomega} / \partial \pv_t$)
-#**input: vector of 4 eulerParameters as list or np.array
-#**output: 3x4 matrix G as np.array
-def EulerParameters2GLocal(eulerParameters):
-    ep = eulerParameters
-    return np.array([[-2.*ep[1], 2.*ep[0], 2.*ep[3],-2.*ep[2]],
-                     [-2.*ep[2],-2.*ep[3], 2.*ep[0], 2.*ep[1]],
-                     [-2.*ep[3], 2.*ep[2],-2.*ep[1], 2.*ep[0]] ])
-
-#**function: compute rotation matrix from eulerParameters    
-#**input: vector of 4 eulerParameters as list or np.array
-#**output: 3x3 rotation matrix as np.array
-def EulerParameters2RotationMatrix(eulerParameters):
-    ep = eulerParameters
-    return np.array([[-2.0*ep[3]*ep[3] - 2.0*ep[2]*ep[2] + 1.0, -2.0*ep[3]*ep[0] + 2.0*ep[2]*ep[1], 2.0*ep[3]*ep[1] + 2.0*ep[2]*ep[0]],
-                     [ 2.0*ep[3]*ep[0] + 2.0*ep[2]*ep[1], -2.0*ep[3]*ep[3] - 2.0*ep[1]*ep[1] + 1.0, 2.0*ep[3]*ep[2] - 2.0*ep[1]*ep[0]],
-                     [-2.0*ep[2]*ep[0] + 2.0*ep[3]*ep[1], 2.0*ep[3]*ep[2] + 2.0*ep[1]*ep[0], -2.0*ep[2]*ep[2] - 2.0*ep[1]*ep[1] + 1.0] ])
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute Euler parameters from given rotation matrix
-#**input: 3x3 rotation matrix as list of lists or as np.array
-#**output: vector of 4 eulerParameters as np.array
-def RotationMatrix2EulerParameters(rotationMatrix):
-    A=np.array(rotationMatrix)
-    trace = A[0,0] + A[1,1] + A[2,2] + 1.0
-    M_EPSILON = 1e-15 #small number to avoid division by zero
-
-    if (abs(trace) > M_EPSILON):
-        s = 0.5 / np.sqrt(abs(trace))
-        ep0 = 0.25 / s
-        ep1 = (A[2,1] - A[1,2]) * s
-        ep2 = (A[0,2] - A[2,0]) * s
-        ep3 = (A[1,0] - A[0,1]) * s
-    else:
-        if (A[0,0] > A[1,1]) and (A[0,0] > A[2,2]):
-            s = 2.0 * np.sqrt(abs(1.0 + A[0,0] - A[1,1] - A[2,2]))
-            ep1 = 0.25 * s
-            ep2 = (A[0,1] + A[1,0]) / s
-            ep3 = (A[0,2] + A[2,0]) / s
-            ep0 = (A[1,2] - A[2,1]) / s
-        elif A[1,1] > A[2,2]:
-            s = 2.0 * np.sqrt(abs(1.0 + A[1,1] - A[0,0] - A[2,2]))
-            ep1 = (A[0,1] + A[1,0]) / s
-            ep2 = 0.25 * s
-            ep3 = (A[1,2] + A[2,1]) / s
-            ep0 = (A[0,2] - A[2,0]) / s
-        else:
-            s = 2.0 * np.sqrt(abs(1.0 + A[2,2] - A[0,0] - A[1,1]));
-            ep1 = (A[0,2] + A[2,0]) / s
-            ep2 = (A[1,2] + A[2,1]) / s
-            ep3 = 0.25 * s
-            ep0 = (A[0,1] - A[1,0]) / s
-
-    ep=np.array([ep0,ep1,ep2,ep3])
-    #normalize Euler parameters, if rotation matrix is inaccurate; otherwise, may lead to errors in checkPreAssemble
-    epNorm = np.linalg.norm(ep)
-    if epNorm != 0.:
-        ep *= 1./epNorm
-    return ep
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute time derivative of Euler parameters from (global) angular velocity vector
-#note that for Euler parameters $\pv$, we have $\tomega=\Gm \dot \pv$ ==> $\Gm^T \tomega = \Gm^T\cdot \Gm\cdot \dot \pv$ ==> $\Gm^T \Gm=4(\Im_{4 \times 4} - \pv\cdot \pv^T)\dot\pv = 4 (\Im_{4x4}) \dot \pv$
-#**input: 
-#  angularVelocity: 3D vector of angular velocity in global frame, as lists or as np.array
-#  eulerParameters: vector of 4 eulerParameters as np.array or list
-#**output: vector of time derivatives of 4 eulerParameters as np.array
-def AngularVelocity2EulerParameters_t(angularVelocity, eulerParameters):
-    
-    GT = np.transpose(EulerParameters2G(eulerParameters))
-    return 0.25*(GT.dot(angularVelocity))
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#            ROTATION VECTOR
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: rotaton matrix from rotation vector, see appendix B in \cite{Simo1988}
-#**input: 3D rotation vector as list or np.array
-#**output: 3x3 rotation matrix as np.array
-#**notes: gets inaccurate for very large rotations, $\phi \\gg 2*\pi$
-def RotationVector2RotationMatrix(rotationVector):
-    phi = np.linalg.norm(rotationVector)
-    if phi == 0.:
-        R = np.eye(3)
-    else:
-        OmegaSkew = Skew(rotationVector)
-        alpha = np.sin(phi)/phi
-        beta = 2*(1-np.cos(phi))/phi**2 #the loss of digits in 1-np.cos(phi) is compensated by OmegaSkew@OmegaSkew
-        R = np.eye(3) + alpha*OmegaSkew + 0.5*beta*np.matmul(OmegaSkew, OmegaSkew)
-
-    
-    return R  
-
-
-#**function: compute rotation vector from rotation matrix
-#**input: 3x3 rotation matrix as list of lists or as np.array
-#**output: vector of 3 components of rotation vector as np.array
-def RotationMatrix2RotationVector(rotationMatrix):
-    ep = RotationMatrix2EulerParameters(rotationMatrix)
-    
-    n = ep[1:]
-    norm = np.linalg.norm(n)
-    
-    #phi = 2.*acos(ep[0])
-    phi = 2.*np.arctan2(norm, ep[0])
-    
-    if norm != 0.:
-        n = (1./norm)*n
-
-    return phi*n
-    
-    # # compute a  rotation vector from given rotation matrix according to 
-    # # 2015 - Sonneville - A geometrical local frame approach for flexible multibody systems, p45
-    # if np.linalg.norm(rotationMatrix - np.eye(3)) == 0.:
-    #     rotationVector = np.zeros(3)
-    # else:
-    #     theta = np.arccos(0.5*(np.trace(rotationMatrix)-1))
-    #     if abs(theta) < np.pi and abs(theta) > 0:
-    #         logR = (theta/(2*np.sin(theta)))*(rotationMatrix - np.transpose(rotationMatrix))
-    #         rotationVector = Skew2Vec(logR)
-    #     else:
-    #         rotationVector = np.zeros(3)
-
-    # return rotationVector
-
-
-#**function: compute rotation axis from given rotation vector
-#**input: 3D rotation vector as np.array
-#**output: 3D vector as np.array representing the rotation axis
-def ComputeRotationAxisFromRotationVector(rotationVector):
-    
-    # compute rotation angle
-    rotationAngle = np.linalg.norm(rotationVector)
-    
-    # compute rotation axis
-    if rotationAngle == 0.0:
-        rotationAxis = np.zeros(3)
-    else:
-        rotationAxis = rotationVector/rotationAngle
-    
-    # return rotation axis 
-    return rotationAxis
-
-
-#**function: convert rotation vector (parameters) (v) to G-matrix (=$\partial \tomega  / \partial \dot \vv$)
-#**input: vector of rotation vector (len=3) as list or np.array
-#**output: 3x3 matrix G as np.array
-def RotationVector2G(rotationVector):
-    return RotationVector2RotationMatrix(rotationVector)
-
-#**function: convert rotation vector (parameters) (v) to local G-matrix (=$\partial \LU{b}{\tomega}   / \partial \vv_t$)
-#**input: vector of rotation vector (len=3) as list or np.array
-#**output: 3x3 matrix G as np.array
-def RotationVector2GLocal(eulerParameters):
-    return np.eye(3)
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#            TAIT BRYAN ANGLES
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**function: compute rotation matrix from consecutive xyz \acp{Rot} (Tait-Bryan angles); A=Ax*Ay*Az; rot=[rotX, rotY, rotZ]
-#**input: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
-#**output: 3x3 rotation matrix as np.array
-def RotXYZ2RotationMatrix(rot):
-    c0 = np.cos(rot[0])
-    s0 = np.sin(rot[0])
-    c1 = np.cos(rot[1])
-    s1 = np.sin(rot[1])
-    c2 = np.cos(rot[2])
-    s2 = np.sin(rot[2])
-    
-    return np.array([[ c1*c2           ,-c1*s2           , s1    ],
-                     [ s0*s1*c2 + c0*s2,-s0*s1*s2 + c0*c2,-s0*c1 ],
-                     [-c0*s1*c2 + s0*s2, c0*s1*s2 + s0*c2, c0*c1 ]]);
-
-#**function: convert rotation matrix to xyz Euler angles (Tait-Bryan angles);  A=Ax*Ay*Az; 
-#**input:  3x3 rotation matrix as list of lists or np.array
-#**output: vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array
-#**notes: due to gimbal lock / singularity at rot[1] = pi/2, -pi/2, ... the reconstruction of 
-#  \texttt{RotationMatrix2RotXYZ( RotXYZ2RotationMatrix(rot) )} may fail, but 
-#  \texttt{RotXYZ2RotationMatrix( RotationMatrix2RotXYZ( RotXYZ2RotationMatrix(rot) ) )} works always
-def RotationMatrix2RotXYZ(rotationMatrix):
-    R=np.array(rotationMatrix)
-    #rot=np.array([0,0,0])
-    rot=np.zeros(3)
-    absC1 = np.sqrt((-R[1,2])**2+R[2,2]**2)
-    rot[1] = np.arctan2(R[0,2], absC1)
-    if absC1 > 1e-14:
-        rot[0] = np.arctan2(-R[1,2], R[2,2])
-        rot[2] = np.arctan2(-R[0,1], R[0,0])
-    else: #rot[0] and rot[2] represent same axes, set one of them zero!
-        rot[0] = 0.
-        #c1=0,s0=0,c0=1
-        #s0*s1*c2 + c0*s2,-s0*s1*s2 + c0*c2 => c0*s2, c0*c2
-        rot[2] = np.arctan2(R[1,0], R[1,1])
-        
-    return rot
-
-# #OLD, problems at rot[1]=pi/2: rotation represents different rotation matrix
-# def RotationMatrix2RotXYZ(rotationMatrix):
-#     R=np.array(rotationMatrix)
-#     #rot=np.array([0,0,0])
-#     rot=[0,0,0]
-#     rot[0] = np.arctan2(-R[1,2], R[2,2])
-#     rot[1] = np.arctan2(R[0,2], np.sqrt(abs(1. - R[0,2] * R[0,2]))) #fabs for safety, if small round up error in rotation matrix ...
-#     rot[2] = np.arctan2(-R[0,1], R[0,0])
-#     return np.array(rot);
-
-
-#**function: compute (global-frame) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{0}{\Gm} = \partial \LU{0}{\tomega}  / \partial \dot \ttheta$)
-#**input:  3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
-#**output: 3x3 matrix G as np.array
-def RotXYZ2G(rot):
-    c0 = cos(rot[0])
-    s0 = sin(rot[0])
-    c1 = cos(rot[1])
-    s1 = sin(rot[1])
-
-    return np.array([[1, 0, s1],
-                     [0, c0, -c1*s0],
-                     [0, s0,  c0*c1 ]])
-
-#**function: compute time derivative of (global-frame) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{0}{\Gm} = \partial \LU{0}{\tomega}  / \partial \dot \ttheta$)
-#**input:  
-#    rot: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
-#    rot_t: 3D vector of time derivative of Tait-Bryan rotation parameters [X,Y,Z] in radiant/s
-#**output: 3x3 matrix G\_t as np.array
-def RotXYZ2G_t(rot, rot_t):
-    c0 = cos(rot[0])
-    s0 = sin(rot[0])
-    c1 = cos(rot[1])
-    s1 = sin(rot[1])
-
-    return np.array([[0, 0, rot_t[1]*c1],
-                     [0, -rot_t[0]*s0, rot_t[1]*s0*s1 - rot_t[0]*c0*c1],
-                     [0, rot_t[0]*c0, -rot_t[0]*c1*s0 - rot_t[1]*c0*s1]])
-
-
-#**function: compute local (body-fixed) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{b}{\Gm} = \partial \LU{b}{\tomega}  / \partial \ttheta_t$)
-#**input:  3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
-#**output: 3x3 matrix GLocal as np.array
-def RotXYZ2GLocal(rot):
-    c1 = cos(rot[1])
-    s1 = sin(rot[1])
-    c2 = cos(rot[2])
-    s2 = sin(rot[2])
-
-    return np.array([[ c1*c2, s2, 0],
-                     [-c1*s2, c2, 0],
-                     [ s1,     0,  1]])
-
-#**function: compute time derivative of (body-fixed) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{b}{\Gm} = \partial \LU{b}{\tomega}  / \partial \ttheta_t$)
-#**input:  
-#    rot: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
-#    rot_t: 3D vector of time derivative of Tait-Bryan rotation parameters [X,Y,Z] in radiant/s
-#**output: 3x3 matrix GLocal\_t as np.array
-def RotXYZ2GLocal_t(rot, rot_t):
-    c1 = cos(rot[1])
-    s1 = sin(rot[1])
-    c2 = cos(rot[2])
-    s2 = sin(rot[2])
-
-    return np.array([[-rot_t[2]*c1*s2 - rot_t[1]*c2*s1, rot_t[2]*c2, 0],
-                     [ rot_t[1]*s2*s1 - rot_t[2]*c2*c1, -rot_t[2]*s2, 0],
-                     [ rot_t[1]*c1, 0, 0 ]])
-
-
-
-
-
-
-#**function: compute time derivatives of angles RotXYZ from (global) angular velocity vector and given rotation
-#**input:  
-#  angularVelocity: global angular velocity vector as list or np.array
-#  rotation: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
-#**output: time derivative of vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array
-def AngularVelocity2RotXYZ_t(angularVelocity, rotation):
-    psi = rotation[0]
-    theta = rotation[1]
-    #phi = rotation[2] #not needed
-    cTheta = np.cos(theta)
-    if cTheta == 0:
-        print('AngularVelocity2RotXYZ_t: not possible for rotation[1] == pi/2, 3*pi/2, ...')
-
-    GInv = (1/cTheta)*np.array([[np.cos(theta), np.sin(psi)*np.sin(theta),-np.cos(psi)*np.sin(theta)],
-                                [0            , np.cos(psi)*np.cos(theta)   , np.sin(psi)*np.cos(theta)],
-                                [0            ,-np.sin(psi)              , np.cos(psi)]])
-    return np.dot(GInv,angularVelocity)
-  
-    
-#**function: compute four Euler parameters from given RotXYZ angles, see \cite{Henderson1977}
-#**input: 
-#   alpha: 3D vector as np.array containing RotXYZ angles
-#**output: 4D vector as np.array containing four Euler parameters 
-#          entry zero of output represent the scalar part of Euler parameters
-def RotXYZ2EulerParameters(alpha):
-    psi   = alpha[0]
-    theta = alpha[1]
-    phi   = alpha[2]   
-    u = 0.5*psi
-    v = 0.5*theta
-    w = 0.5*phi    
-    cPsi   = np.cos(u)
-    cTheta = np.cos(v)
-    cPhi   = np.cos(w)    
-    sPsi   = np.sin(u)
-    sTheta = np.sin(v)
-    sPhi   = np.sin(w)    
-    q0 = -sPsi*sTheta*sPhi + cPsi*cTheta*cPhi
-    q1 =  sPsi*cTheta*cPhi + sTheta*sPhi*cPsi    
-    q2 = -sPsi*sPhi*cTheta + sTheta*cPsi*cPhi 
-    q3 =  sPsi*sTheta*cPhi + sPhi*cPsi*cTheta 
-    return np.array([q0, q1, q2, q3])
-
-
-#%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#            Euler ANGLES
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**function: convert rotation matrix to zyz Euler angles;  A=Az*Ay*Az;
-#**input:
-#  rotationMatrix: 3x3 rotation matrix as list of lists or np.array
-#  flip:           argument to choose first Euler angle to be in quadrant 2 or 3.
-#**output: vector of Euler rotation parameters [Z,Y,Z] (in radiant) as np.array
-#**notes: tested (compared with Robotics, Vision and Control book of P. Corke)
-#**author: Martin Sereinig
-def RotationMatrix2RotZYZ(rotationMatrix, flip):
-    R=np.array(rotationMatrix)
-    # Method as per Paul, p 69.
-    # euler = [phi theta psi]
-    eulangles = np.zeros([3])
-    eps = 10**(-14)
-
-    if abs(R[0, 2]) < eps and abs(R[1, 2]) < eps:
-        # singularity
-        eulangles[0] = 0
-        sp = 0
-        cp = 1
-        eulangles[1] = np.arctan2(
-            cp*R[0, 2] + sp*R[1, 2], R[2, 2])
-        eulangles[2] = np.arctan2(-sp * R[0, 0] + cp *
-                                  R[1, 0], -sp*R[0, 1] + cp*R[1, 1])
-    else:
-        # non singular
-        # Only positive phi is returned.
-        if flip:
-            eulangles[0] = np.arctan2(-R[1, 2], -R[0, 2])
-        else:
-            eulangles[0] = np.arctan2(R[1, 2], R[0, 2])
-
-        sp = np.sin(eulangles[0])
-        cp = np.cos(eulangles[0])
-        eulangles[1] = np.arctan2(
-            cp*R[0, 2] + sp*R[1, 2], R[2, 2])
-        eulangles[2] = np.arctan2(-sp * R[0, 0] + cp *
-                                  R[1, 0], -sp*R[0, 1] + cp*R[1, 1])
-    return eulangles
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute rotation matrix w.r.t. X-axis (first axis)
-#**input: angle around X-axis in radiant
-#**output: 3x3 rotation matrix as np.array
-def RotationMatrixX(angleRad):
-    return np.array([[1, 0, 0],
-                     [0, np.cos(angleRad),-np.sin(angleRad)],
-                     [0, np.sin(angleRad), np.cos(angleRad)] ])
-
-#**function: compute rotation matrix w.r.t. Y-axis (second axis)
-#**input: angle around Y-axis in radiant
-#**output: 3x3 rotation matrix as np.array
-def RotationMatrixY(angleRad):
-    return np.array([ [ np.cos(angleRad), 0, np.sin(angleRad)],
-                      [0,        1, 0],
-                      [-np.sin(angleRad),0, np.cos(angleRad)] ])
-
-#**function: compute rotation matrix w.r.t. Z-axis (third axis)
-#**input: angle around Z-axis in radiant
-#**output: 3x3 rotation matrix as np.array
-def RotationMatrixZ(angleRad):
-    return np.array([ [np.cos(angleRad),-np.sin(angleRad), 0],
-                      [np.sin(angleRad), np.cos(angleRad), 0],
-                      [0,        0,        1] ]);
-
-    
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#functions for homogeneous transformations (HT)
-#**function: compute \ac{HT} matrix from rotation matrix A and translation vector r
-def HomogeneousTransformation(A, r):
-    T = np.zeros((4,4))
-    T[0:3,0:3] = A
-    T[0:3,3] = r
-    T[3,3] = 1
-    return T
-
-HT = HomogeneousTransformation #shortcut
-
-#**function: \ac{HT} for translation with vector r
-def HTtranslate(r):
-    T = np.eye(4)
-    T[0:3,3] = r
-    return T
-
-#**function: \ac{HT} for translation along x axis with value x
-def HTtranslateX(x):
-    T = np.eye(4)
-    T[0,3] = x
-    return T
-
-#**function: \ac{HT} for translation along y axis with value y
-def HTtranslateY(y):
-    T = np.eye(4)
-    T[1,3] = y
-    return T
-
-#**function: \ac{HT} for translation along z axis with value z
-def HTtranslateZ(z):
-    T = np.eye(4)
-    T[2,3] = z
-    return T
-
-#**function: identity \ac{HT}:
-def HT0():
-    return np.eye(4)
-
-#**function: \ac{HT} for rotation around axis X (first axis)
-def HTrotateX(angle):
-    T = np.eye(4)
-    T[0:3,0:3] = RotationMatrixX(angle)
-    return T
-    
-#**function: \ac{HT} for rotation around axis X (first axis)
-def HTrotateY(angle):
-    T = np.eye(4)
-    T[0:3,0:3] = RotationMatrixY(angle)
-    return T
-    
-#**function: \ac{HT} for rotation around axis X (first axis)
-def HTrotateZ(angle):
-    T = np.eye(4)
-    T[0:3,0:3] = RotationMatrixZ(angle)
-    return T
-
-#**function: return translation part of \ac{HT}
-def HT2translation(T):
-    return T[0:3,3]
-
-#**function: return rotation matrix of \ac{HT}
-def HT2rotationMatrix(T):
-    return T[0:3,0:3]
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: return inverse \ac{HT} such that inv(T)*T = np.eye(4)
-def InverseHT(T):
-    Tinv = np.eye(4)
-    Ainv = T[0:3,0:3].T #inverse rotation part
-    Tinv[0:3,0:3] = Ainv
-    r = T[0:3,3]        #translation part
-    Tinv[0:3,3]  = -Ainv @ r       #inverse translation part
-    return Tinv
-
-################################################################################
-#Test (compared with Robotcs, Vision and Control book of P. Corke:
-#T=HTtranslate([1,0,0]) @ HTrotateX(np.pi/2) @ HTtranslate([0,1,0])
-#print("T=",T.round(8))
-#
-#R = RotationMatrixZ(0.1) @ RotationMatrixY(0.2) @ RotationMatrixZ(0.3) 
-#print("R=",R.round(4))
-
-################################################################################
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#functions for 6x6 coordinate transformation matrices (\ac{T66}), see Featherstone / Handbook of robotics \cite{Siciliano2016}
-#**function: compute 6x6 coordinate transformation matrix for rotation around X axis; output: first 3 components for rotation, second 3 components for translation! See Featherstone / Handbook of robotics \cite{Siciliano2016}
-def RotationX2T66(angle):
-    c = cos(angle);
-    s = sin(angle);
-    return np.array(
-        [[1,  0,  0,  0,  0,  0],
-         [0,  c, -s,  0,  0,  0],
-         [0,  s,  c,  0,  0,  0],
-         [0,  0,  0,  1,  0,  0],
-         [0,  0,  0,  0,  c, -s],
-         [0,  0,  0,  0,  s,  c]])
-
-#**function: compute 6x6 transformation matrix for rotation around Y axis; output: first 3 components for rotation, second 3 components for translation
-def RotationY2T66(angle):
-    c = cos(angle);
-    s = sin(angle);
-    return np.array(
-        [[c,  0,  s,  0,  0,  0],
-         [0,  1,  0,  0,  0,  0],
-         [-s, 0,  c,  0,  0,  0],
-         [0,  0,  0,  c,  0,  s],
-         [0,  0,  0,  0,  1,  0],
-         [0,  0,  0, -s,  0,  c]])
-
-#**function: compute 6x6 transformation matrix for rotation around Z axis; output: first 3 components for rotation, second 3 components for translation
-def RotationZ2T66(angle):
-    c = cos(angle);
-    s = sin(angle);
-    return np.array(
-        [[ c, -s,  0,  0,  0,  0],
-         [ s,  c,  0,  0,  0,  0],
-         [ 0,  0,  1,  0,  0,  0],
-         [ 0,  0,  0,  c, -s,  0],
-         [ 0,  0,  0,  s,  c,  0],
-         [ 0,  0,  0,  0,  0,  1]])
-
-#**function: compute 6x6 transformation matrix for translation according to 3D vector translation3D; output: first 3 components for rotation, second 3 components for translation!
-def Translation2T66(translation3D):
-    t = translation3D
-    return np.array(
-        [[    1,    0,    0,  0,  0,  0],
-         [    0,    1,    0,  0,  0,  0],
-         [    0,    0,    1,  0,  0,  0],
-         [    0, t[2],-t[1],  1,  0,  0],
-         [-t[2],    0, t[0],  0,  1,  0],
-         [ t[1],-t[0],    0,  0,  0,  1]])
-
-#**function: compute 6x6 transformation matrix for translation along X axis; output: first 3 components for rotation, second 3 components for translation!
-def TranslationX2T66(translation):
-    return Translation2T66([translation,0,0])
-
-#**function: compute 6x6 transformation matrix for translation along Y axis; output: first 3 components for rotation, second 3 components for translation!
-def TranslationY2T66(translation):
-    return Translation2T66([0,translation,0])
-
-#**function: compute 6x6 transformation matrix for translation along Z axis; output: first 3 components for rotation, second 3 components for translation!
-def TranslationZ2T66(translation):
-    return Translation2T66([0,0,translation])
-
-#**function convert 6x6 coordinate transformation (Pl\"ucker transform) into rotation and translation
-#**input: T66 given as  6x6 numpy array
-#**output: [A, v] with 3x3 rotation matrix A and 3D translation vector v
-def T66toRotationTranslation(T66):
-    A = T66[0:3,0:3]
-    v = Skew2Vec(T66[3:6,0:3]@A.T) #this leads to identical backtransformation
-    return [A, v] 
-
-#**function convert inverse 6x6 coordinate transformation (Pl\"ucker transform) into rotation and translation
-#**input: inverse T66 given as  6x6 numpy array
-#**output: [A, v] with 3x3 rotation matrix A and 3D translation vector v
-def InverseT66toRotationTranslation(T66):
-    A = (T66[0:3,0:3]).T
-    v = -Skew2Vec(A@T66[3:6,0:3])
-    return [A, v] 
-
-#**function convert rotation and translation into 6x6 coordinate transformation (Pl\"ucker transform)
-#**input:
-#  A: 3x3 rotation matrix A
-#  v: 3D translation vector v
-#**output: return 6x6 transformation matrix 'T66'
-def RotationTranslation2T66(A, v):
-    return np.block([
-        [A, np.zeros((3,3))], 
-        [Skew(v)@A, A]]) 
-
-#**function convert rotation and translation into INVERSE 6x6 coordinate transformation (Pl\"ucker transform)
-#**input:
-#  A: 3x3 rotation matrix A
-#  v: 3D translation vector v
-#**output: return 6x6 transformation matrix 'T66'
-def RotationTranslation2T66Inverse(A, v):
-    return np.block([
-        [A.T, np.zeros((3,3))], 
-        [-A.T@Skew(v), A.T]]) 
-
-#**compute inverse of 6x6 coordinate transformation (Pl\"ucker transform)
-#**input:
-#  T66: 6x6 coordinate transformation (Pl\"ucker transform)
-#**output: return inverse 6x6 transformation matrix 'T66'
-#**note: Skew(A@v) = A@Skew(v)@A.T; v=ApB: -BRA@Skew(ApB) = Skew(BpA)@BRA
-def T66Inverse(T66):
-    A = T66[0:3,0:3] #BRA in Handbook of robotics
-    v = Skew2Vec(T66[3:6,0:3]@A.T) #v=BpA in in Handbook of robotics ==> ApB=-BRA.T@BpA = -A.T@v
-        
-    return np.block([
-        [         A.T, np.zeros((3,3))], 
-        [-A.T@Skew(v), A.T            ]])
-# #identical (using an inverse representation of v):
-#     A = T66[0:3,0:3] #BRA in Handbook of robotics
-#     v = -Skew2Vec(A.T @ T66[3:6,0:3]) #v=ApB in in Handbook of robotics ==> BpA=-BRA@ApB = -A@v
-        
-#     return np.block([
-#         [A.T, np.zeros((3,3))], 
-#         [A.T@Skew(A@v), A.T]])
-
-#**function convert 6x6 coordinate transformation (Pl\"ucker transform) into 4x4 homogeneous transformation; NOTE that the homogeneous transformation is the inverse of what is computed in function pluho() of Featherstone
-#**input: T66 given as 6x6 numpy array
-#**output: homogeneous transformation (4x4 numpy array)
-def T66toHT(T66):
-    A = T66[0:3,0:3]
-    T = np.zeros((4,4))
-    T[0:3,0:3] = A
-    T[0:3,3] = Skew2Vec(T66[3:6,0:3] @ A.T)
-    T[3,3] = 1
-    return T
-
-#**function: convert 4x4 homogeneous transformation into 6x6 coordinate transformation (Pl\"ucker transform); NOTE that the homogeneous transformation is the inverse of what is computed in function pluho() of Featherstone
-#**output: 4x4 homogeneous transformation in numpy array format
-#**outputinput: T66 (6x6 numpy array)
-def HT2T66Inverse(T):
-    A = T[0:3,0:3].T 
-    v = T[0:3,3]
-    return np.block([
-        [A, np.zeros((3,3))],
-        [-A@Skew(v), A]])
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#inertia 6D functions
-
-#**function: convert a 3x3 matrix (list or numpy array) into a list with 6 inertia components, sorted as J00, J11, J22, J12, J02, J01
-def InertiaTensor2Inertia6D(inertiaTensor):
-    J = np.array(inertiaTensor)
-    return [J[0,0], J[1,1], J[2,2],  J[1,2], J[0,2], J[0,1]]
-
-#**function: convert a list or numpy array with 6 inertia components (sorted as [J00, J11, J22, J12, J02, J01]) (list or numpy array) into a 3x3 matrix (np.array)
-def Inertia6D2InertiaTensor(inertia6D):
-    J = inertia6D
-    return np.array([[J[0],J[5],J[4]],
-                     [J[5],J[1],J[3]],
-                     [J[4],J[3],J[2]]])
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: helper class for rigid body inertia (see also derived classes Inertia...).
-#Provides a structure to define mass, inertia and center of mass (COM) of a rigid body.
-#The inertia tensor and center of mass must correspond when initializing the body!
-#**notes:
-#   in the default mode, inertiaTensorAtCOM = False, the inertia tensor must be provided with respect to the reference point; otherwise, it is given at COM; internally, the inertia tensor is always with respect to the reference point, not w.r.t. to COM!
-#**example:
-#i0 = RigidBodyInertia(10,np.diag([1,2,3]))
-#i1 = i0.Rotated(RotationMatrixX(np.pi/2))
-#i2 = i1.Translated([1,0,0])
-class RigidBodyInertia:
-    #**classFunction: initialize RigidBodyInertia with scalar mass, 3x3 inertiaTensor (w.r.t. reference point!!!) and center of mass com
-    #**input:
-    #  mass: mass of rigid body (dimensions need to be consistent, should be in SI-units)
-    #  inertiaTensor: tensor given w.r.t.\ reference point, NOT w.r.t.\ center of mass!
-    #  com: center of mass relative to reference point, in same coordinate system as inertiaTensor
-    def __init__(self, mass=0, inertiaTensor=np.zeros([3,3]), com=np.zeros(3), inertiaTensorAtCOM = False):
-        
-        if np.array(inertiaTensor).shape != (3,3): #shape is a tuple
-            raise ValueError('RigidBodyInertia: inertiaTensor must have shape (3,3), but received '+str(inertiaTensor.shape))
-        if np.array(com).shape != (3,): #shape is a tuple
-            raise ValueError('RigidBodyInertia: com must have 3 components, but received '+str(np.array(inertiaTensor).shape))
-        self.mass = mass
-        self.inertiaTensor = np.array(inertiaTensor)
-        self.com = np.array(com)
-        if inertiaTensorAtCOM:
-            self.inertiaTensor = self.inertiaTensor + self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
-        
-    #**classFunction: add (+) operator allows adding another inertia information with SAME local coordinate system and reference point!
-    #only inertias with same center of rotation can be added!
-    #**example: 
-    #J = InertiaSphere(2,0.1) + InertiaRodX(1,2)
-    def __add__(self, otherBodyInertia):
-        sumMass = self.mass + otherBodyInertia.mass
-        return RigidBodyInertia(mass=sumMass,
-                                inertiaTensor = self.inertiaTensor + otherBodyInertia.inertiaTensor,
-                                com=1./sumMass*(self.mass*self.com + otherBodyInertia.mass*otherBodyInertia.com))
-
-    #**classFunction: += operator allows adding another inertia information with SAME local coordinate system and reference point!
-    #only inertias with same center of rotation can be added!
-    #**example: 
-    #J = InertiaSphere(2,0.1) 
-    #J += InertiaRodX(1,2)
-    def __iadd__(self, otherBodyInertia):
-        self = self + otherBodyInertia
-        return self
-        
-    #**classFunction: set RigidBodyInertia with scalar mass, 3x3 inertiaTensor (w.r.t.\ com) and center of mass com
-    #**input:
-    #  mass: mass of rigid body (dimensions need to be consistent, should be in SI-units)
-    #  inertiaTensorCOM: tensor given w.r.t.\ reference point, NOT w.r.t.\ center of mass!
-    #  com: center of mass relative to reference point, in same coordinate system as inertiaTensor
-    def SetWithCOMinertia(self, mass, inertiaTensorCOM, com):
-        if np.array(inertiaTensorCOM).shape != (3,3): #shape is a tuple
-            raise ValueError('RigidBodyInertia: inertiaTensorCOMmust have shape (3,3), but received '+str(np.array(inertiaTensorCOM).shape))
-        if np.array(com).shape != (3,): #shape is a tuple
-            raise ValueError('RigidBodyInertia: com must have 3 components, but received '+str(np.array(inertiaTensorCOM).shape))
-        self.mass = mass
-        self.com = np.array(com)
-        self.inertiaTensor = np.array(inertiaTensorCOM) + self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
-        
-        
-    #**classFunction: returns 3x3 inertia tensor with respect to chosen reference point (not necessarily COM)
-    def Inertia(self):
-        return self.inertiaTensor
-
-    #**classFunction: returns 3x3 inertia tensor with respect to COM
-    def InertiaCOM(self):
-        return self.inertiaTensor - self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
-
-    #**classFunction: returns center of mass (COM) w.r.t. chosen reference point
-    def COM(self):
-        return self.com
-
-    #**classFunction: returns mass
-    def Mass(self):
-        return self.mass
-
-    #**classFunction: returns a RigidBodyInertia with center of mass com shifted by vec; $\ra$ transforms the returned inertiaTensor to the new center of rotation
-    def Translated(self, vec):
-        #transform inertia to com=[0,0,0]
-        inertiaCOM = self.inertiaTensor - self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
-        try:
-            newCOM = self.com + vec
-        except:
-            raise ValueError("ERROR in RigidBodyInertia.Translated(vec): vec must be a vector with 3 components")
-        inertiaCOM += self.mass*np.dot(Skew(newCOM).transpose(),Skew(newCOM))
-        return RigidBodyInertia(mass=self.mass, 
-                                inertiaTensor=inertiaCOM,
-                                com=newCOM)
-
-    #**classFunction: returns a RigidBodyInertia rotated by 3x3 rotation matrix rot, such that for a given J, the new inertia tensor reads Jnew = rot*J*rot.T
-    #**notes: only allowed if COM=0 !
-    def Rotated(self, rot):
-        if NormL2(self.com) != 0:
-            print("ERROR: RigidBodyInertia.Rotated only allowed in case of com=0")
-            return 0
-        try:
-            inertia = np.dot(np.array(rot),np.dot(self.inertiaTensor,rot.transpose()))
-        except:
-            raise ValueError("ERROR in RigidBodyInertia.Rotated(rot): rot must be a 3x3 rotation matrix")
-        return RigidBodyInertia(mass=self.mass, 
-                                inertiaTensor=inertia,
-                                com=self.com)
-
-    #**classFunction: return rigid body inertia transformed by homogeneous transformation HT
-    def Transformed(self, HT):
-        A = HT2rotationMatrix(HT)
-        v = HT2translation(HT)
-        
-        inertiaCOM = self.inertiaTensor - self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
-        inertiaCOM = A @ inertiaCOM @ A.T #tested with general rigid body and shifted reference point
-
-        newCOM = A @ self.com + v
-
-        inertiaCOM += self.mass*np.dot(Skew(newCOM).transpose(),Skew(newCOM))
-        return RigidBodyInertia(mass=self.mass, 
-                                inertiaTensor=inertiaCOM,
-                                com=newCOM)
-
-    #**classFunction: get vector with 6 inertia components (Jxx, Jyy, Jzz, Jyz, Jxz, Jxy) as needed in ObjectRigidBody
-    def GetInertia6D(self):
-        return InertiaTensor2Inertia6D(self.inertiaTensor)
-        # J = self.inertiaTensor
-        # return [J[0][0], J[1][1], J[2][2],  J[1][2], J[0][2], J[0][1]]
-
-
-    def __str__(self):
-        s = 'mass = ' + str(self.mass)
-        s += '\nCOM = ' + str(self.com)
-        s += '\ninertiaTensorAtOrigin = \n' + str(self.inertiaTensor)
-        s += '\ninertiaTensorAtCOM = \n' + str(self.InertiaCOM())
-        return s
-    def __repr__(self):
-        return str(self)
-
-
-#**class: create RigidBodyInertia with moment of inertia and mass of a cuboid with density and side lengths sideLengths along local axes 1, 2, 3; inertia w.r.t. center of mass, com=[0,0,0]
-#**example: 
-# InertiaCuboid(density=1000,sideLengths=[1,0.1,0.1])
-class InertiaCuboid(RigidBodyInertia):
-    #**classFunction: initialize inertia
-    def __init__(self, density, sideLengths):
-        L1=sideLengths[0]
-        L2=sideLengths[1]
-        L3=sideLengths[2]
-        newMass=density*L1*L2*L3
-        RigidBodyInertia.__init__(self, mass=newMass,
-                                  inertiaTensor=newMass/12.*np.diag([(L2**2 + L3**2),(L1**2 + L3**2),(L1**2 + L2**2)]),
-                                  com=np.zeros(3))
-
-#**class: create RigidBodyInertia with moment of inertia and mass of a rod with mass m and length L in local 1-direction (x-direction); inertia w.r.t. center of mass, com=[0,0,0]
-class InertiaRodX(RigidBodyInertia):
-    #**classFunction: initialize inertia with mass and length of rod
-    def __init__(self, mass, length):
-        RigidBodyInertia.__init__(self, mass=mass,
-                                  inertiaTensor=mass/12.*np.diag([0.,length**2,length**2]),
-                                  com=np.zeros(3))
-        
-#**class: create RigidBodyInertia with moment of inertia and mass of mass point with 'mass'; inertia w.r.t. center of mass, com=[0,0,0]
-class InertiaMassPoint(RigidBodyInertia):
-    #**classFunction: initialize inertia with mass of point
-    def __init__(self, mass):
-        RigidBodyInertia.__init__(self, mass=mass,
-                                  inertiaTensor=np.zeros([3,3]),
-                                  com=np.zeros(3))
-
-#**class: create RigidBodyInertia with moment of inertia and mass of sphere with mass and radius; inertia w.r.t. center of mass, com=[0,0,0]
-class InertiaSphere(RigidBodyInertia):
-    #**classFunction: initialize inertia with mass and radius of sphere
-    def __init__(self, mass, radius):
-        J = 2.*mass/5.*radius**2
-        RigidBodyInertia.__init__(self, mass=mass,
-                                  inertiaTensor=np.diag([J,J,J]),
-                                  com=np.zeros(3))
-        
-#**class: create RigidBodyInertia with moment of inertia and mass of hollow sphere with mass (concentrated at circumference) and radius; inertia w.r.t. center of mass, com=0
-class InertiaHollowSphere(RigidBodyInertia):
-    #**classFunction: initialize inertia with mass and (inner==outer) radius of hollow sphere
-    def __init__(self, mass, radius):
-        J = 2.*mass/3.*radius**2
-        RigidBodyInertia.__init__(self, mass=mass,
-                                  inertiaTensor=np.diag([J,J,J]),
-                                  com=np.zeros(3))
-
-#**class: create RigidBodyInertia with moment of inertia and mass of cylinder with density, length and outerRadius; axis defines the orientation of the cylinder axis (0=x-axis, 1=y-axis, 2=z-axis); for hollow cylinder use innerRadius != 0; inertia w.r.t. center of mass, com=[0,0,0]
-class InertiaCylinder(RigidBodyInertia):
-    #**classFunction: initialize inertia with density, length, outer radius, axis (0=x-axis, 1=y-axis, 2=z-axis) and optional inner radius (for hollow cylinder)
-    def __init__(self, density, length, outerRadius, axis, innerRadius=0):
-        m = density*length*np.pi*(outerRadius**2-innerRadius**2)
-        Jaxis = 0.5*m*(outerRadius**2+innerRadius**2)
-        Jtt = 1./12.*m*(3*(outerRadius**2+innerRadius**2)+length**2)
-
-        if axis==0:
-            RigidBodyInertia.__init__(self, mass=m,
-                                      inertiaTensor=np.diag([Jaxis,Jtt,Jtt]),
-                                      com=np.zeros(3))
-        elif axis==1:
-            RigidBodyInertia.__init__(self, mass=m,
-                                      inertiaTensor=np.diag([Jtt,Jaxis,Jtt]),
-                                      com=np.zeros(3))
-        elif axis==2:
-            RigidBodyInertia.__init__(self, mass=m,
-                                      inertiaTensor=np.diag([Jtt,Jtt,Jaxis]),
-                                      com=np.zeros(3))
-        else:
-            raise ValueError("InertiaCylinder: axis must be 0, 1 or 2!")
-        
-
-#**function: convert string into exudyn.NodeType; call e.g. with 'NodeType.RotationEulerParameters' or 'RotationEulerParameters'
-#**notes: function is not very fast, so should be avoided in time-critical situations
-def StrNodeType2NodeType(sNodeType):
-    s = str(sNodeType) #if called with type
-    s = s.replace('NodeType.','')
-    nodeTypes = exu.NodeType.__members__
-    if s in nodeTypes:
-        return nodeTypes[s]
-    else:
-        raise ValueError('StrNodeType2NodeType: no valid NodeType: "'+s+'"')
-    # for key in nodeTypes:
-    #     if s == str(key) or s == str(nodeTypes[key]):
-    #         return int(nodeTypes[key])
-    
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: get node item interface according to nodeType, using initialization with position, velocity, angularVelocity and rotationMatrix
-#**input:
-#   nodeType: a node type according to exudyn.NodeType, or a string of it, e.g., 'NodeType.RotationEulerParameters' (fastest, but additional algebraic constraint equation), 'NodeType.RotationRxyz' (Tait-Bryan angles, singularity for second angle at +/- 90 degrees), 'NodeType.RotationRotationVector' (used for Lie group integration)
-#   position: reference position as list or numpy array with 3 components (in global/world frame)
-#   velocity: initial translational velocity as list or numpy array with 3 components (in global/world frame)
-#   rotationMatrix: 3x3 list or numpy matrix to define reference rotation; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
-#   rotationParameters: reference rotation parameters; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
-#   angularVelocity: initial angular velocity as list or numpy array with 3 components (in global/world frame)
-#**output: returns list containing node number and body number: [nodeNumber, bodyNumber]
-def GetRigidBodyNode(nodeType, 
-                 position=[0,0,0], 
-                 velocity=[0,0,0], 
-                 rotationMatrix= [],
-                 rotationParameters = [],
-                 angularVelocity=[0,0,0]):
-
-    rotationMatrixNew = copy.copy(rotationMatrix)
-    if len(rotationMatrixNew) != 0 and len(rotationParameters) != 0:
-        raise ValueError('GetRigidBodyNode: either rotationMatrixNew or rotationParameters must empty!')
-    if len(rotationMatrixNew) == 0 and len(rotationParameters) == 0:
-        rotationMatrixNew=np.eye(3)
-
-    strNodeType = str(nodeType) #works both for nodeType and for strings (if exudyn not available)
-
-    nodeItem = []
-    if strNodeType == 'NodeType.RotationEulerParameters':
-        if len(rotationParameters) == 0:
-            ep0 = RotationMatrix2EulerParameters(rotationMatrixNew)
-        else:
-            ep0 = rotationParameters
-           
-        ep_t0 = AngularVelocity2EulerParameters_t(angularVelocity, ep0)
-        nodeItem = eii.NodeRigidBodyEP(referenceCoordinates=list(position)+list(ep0),
-                                   initialVelocities=list(velocity)+list(ep_t0))       
-    elif strNodeType == 'NodeType.RotationRxyz':
-        if len(rotationParameters) == 0:
-            rot0 = RotationMatrix2RotXYZ(rotationMatrixNew)
-        else:
-            rot0 = rotationParameters
-
-        rot_t0 = AngularVelocity2RotXYZ_t(angularVelocity, rot0)
-        nodeItem = eii.NodeRigidBodyRxyz(referenceCoordinates=list(position)+list(rot0),
-                                     initialVelocities=list(velocity)+list(rot_t0))
-    elif strNodeType == 'NodeType.RotationRotationVector':
-        if len(rotationParameters) == 0:
-            #raise ValueError('NodeType.RotationRotationVector not implemented!')
-            rot0 = RotationMatrix2RotationVector(rotationMatrixNew)
-        else:
-            rot0 = rotationParameters
-        
-        rotMatrix = RotationVector2RotationMatrix(rot0) #rotationMatrixNew needed!
-        angularVelocityLocal = np.dot(rotMatrix.transpose(),angularVelocity)
-            
-        nodeItem = eii.NodeRigidBodyRotVecLG(referenceCoordinates=list(position) + list(rot0), 
-                                         initialVelocities=list(velocity)+list(angularVelocityLocal))
-        
-    elif strNodeType == 'NodeType.LieGroupWithDirectUpdate':
-        if len(rotationParameters) == 0:
-            #raise ValueError('NodeType.RotationRotationVector not implemented!')
-            rot0 = RotationMatrix2RotationVector(rotationMatrixNew)
-        else:
-            rot0 = rotationParameters
-        
-        rotMatrix = RotationVector2RotationMatrix(rot0) #rotationMatrixNew needed!
-        angularVelocityLocal = np.dot(rotMatrix.transpose(),angularVelocity)
-            
-        nodeItem = eii.NodeRigidBodyRotVecLG(referenceCoordinates=list(position) + list(rot0), 
-                                         initialVelocities=list(velocity)+list(angularVelocityLocal))  
-        
-    # elif strNodeType == 'NodeType.LieGroupWithDataCoordinates':
-    #     if len(rotationParameters) == 0:
-    #         #raise ValueError('NodeType.RotationRotationVector not implemented!')
-    #         rot0 = RotationMatrix2RotationVector(rotationMatrixNew)
-    #     else:
-    #         rot0 = rotationParameters
-        
-    #     rotMatrix = RotationVector2RotationMatrix(rot0) #rotationMatrixNew needed!
-    #     angularVelocityLocal = np.dot(rotMatrix.transpose(),angularVelocity)
-            
-    #     nodeItem = eii.NodeRigidBodyRotVecDataLG(referenceCoordinates=list(position) + list(rot0),
-    #                                                     initialCoordinates=list(position)+list(rot0), #initializes data coordinates
-    #                                                     initialVelocities=list(velocity)+list(angularVelocityLocal))  
-        
-    else:
-        raise ValueError("GetRigidBodyNode: invalid node type:"+strNodeType)
-
-    return nodeItem
-
-#soon: DEPRECATED (use MainSystem function instead): 
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: adds a node (with str(exu.NodeType. ...)) and body for a given rigid body; all quantities (esp. velocity and angular velocity) are given in global coordinates!
-#**input:
-#   inertia: an inertia object as created by class RigidBodyInertia; containing mass, COM and inertia
-#   nodeType: a node type according to exudyn.NodeType, or a string of it, e.g., 'NodeType.RotationEulerParameters' (fastest, but additional algebraic constraint equation), 'NodeType.RotationRxyz' (Tait-Bryan angles, singularity for second angle at +/- 90 degrees), 'NodeType.RotationRotationVector' (used for Lie group integration)
-#   position: reference position as list or numpy array with 3 components (in global/world frame)
-#   velocity: initial translational velocity as list or numpy array with 3 components (in global/world frame)
-#   rotationMatrix: 3x3 list or numpy matrix to define reference rotation; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
-#   rotationParameters: reference rotation parameters; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
-#   angularVelocity: initial angular velocity as list or numpy array with 3 components (in global/world frame)
-#   gravity: if provided as list or numpy array with 3 components, it adds gravity force to the body at the COM, i.e., fAdd = m*gravity
-#   graphicsDataList: list of graphicsData objects to define appearance of body
-#**output: returns list containing node number and body number: [nodeNumber, bodyNumber]
-def AddRigidBody(mainSys, inertia, 
-                 nodeType = exu.NodeType.RotationEulerParameters, 
-                 position=[0,0,0], velocity=[0,0,0], 
-                 rotationMatrix= [],
-                 rotationParameters = [],
-                 angularVelocity=[0,0,0],
-                 gravity=[0,0,0],
-                 graphicsDataList=[]):
-
-    rotationMatrixNew = copy.copy(rotationMatrix)
-
-    if not isinstance(inertia, RigidBodyInertia): #do not use 'exu.rigidBodyUtilities.' in front, even not outside of module!
-        RaiseTypeError(where='AddRigidBody', argumentName='inertia', received = inertia, expectedType = ExpectedType.RigidBodyInertia, dim=None)
-    #MISSING: check for nodeType
-    if not IsVector(position, 3):
-        RaiseTypeError(where='AddRigidBody', argumentName='position', received = position, expectedType = ExpectedType.Vector, dim=3)
-    if not IsVector(velocity, 3):
-        RaiseTypeError(where='AddRigidBody', argumentName='velocity', received = velocity, expectedType = ExpectedType.Vector, dim=3)
-    if not IsVector(angularVelocity, 3):
-        RaiseTypeError(where='AddRigidBody', argumentName='angularVelocity', received = angularVelocity, expectedType = ExpectedType.Vector, dim=3)
-    if not IsVector(gravity, 3):
-        RaiseTypeError(where='AddRigidBody', argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
-
-    if type(graphicsDataList) != list:
-        raise ValueError('AddRigidBody: graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
-
-
-    if not IsSquareMatrix(rotationMatrixNew):
-        raise ValueError('AddRigidBody: rotationMatrix must be a (possibly empty) list or numpy array!')
-    if not IsVector(rotationParameters):
-        raise ValueError('AddRigidBody: rotationParameters must be a (possibly empty) list or numpy array!')
-    
-    if len(rotationMatrixNew) != 0 and len(rotationParameters) != 0:
-        raise ValueError('AddRigidBody: either rotationMatrix or rotationParameters must be empty list or numpy array!')
-    if len(rotationMatrixNew) == 0 and len(rotationParameters) == 0:
-        rotationMatrixNew=np.eye(3)
-    else:
-        if len(rotationMatrixNew) == 0:
-            expectedSize = 3
-            if str(nodeType) == 'NodeType.RotationEulerParameters': 
-                expectedSize = 4
-            if not IsVector(rotationParameters, expectedSize):
-                RaiseTypeError(where='AddRigidBody', argumentName='rotationParameters', received = rotationParameters, expectedType = ExpectedType.Vector, dim=expectedSize)
-        else:
-            if not IsSquareMatrix(rotationMatrixNew, 3):
-                RaiseTypeError(where='AddRigidBody', argumentName='rotationMatrix', received = rotationMatrixNew, expectedType = ExpectedType.Matrix, dim=3)
-            
-            
-    nodeItem = GetRigidBodyNode(nodeType, position, velocity, rotationMatrixNew, rotationParameters, angularVelocity)
-    nodeNumber = mainSys.AddNode(nodeItem)
-    
-    bodyNumber = mainSys.AddObject(eii.ObjectRigidBody(physicsMass=inertia.mass, physicsInertia=inertia.GetInertia6D(), 
-                                                   physicsCenterOfMass=inertia.com,
-                                                   nodeNumber=nodeNumber, 
-                                                   visualization=eii.VObjectRigidBody(graphicsData=graphicsDataList)))
-    
-    if NormL2(gravity) != 0.:
-        markerNumber = mainSys.AddMarker(eii.MarkerBodyMass(bodyNumber=bodyNumber))
-        mainSys.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
-    
-    return [nodeNumber, bodyNumber]
-
-
-#**function: DEPRECATED (use MainSystem function instead): add revolute joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
-#**input:
-#  mbs: the MainSystem to which the joint and markers shall be added
-#  body0: a object number for body0, must be rigid body or ground object
-#  body1: a object number for body1, must be rigid body or ground object
-#  point: a 3D vector as list or np.array containing the global center point of the joint in reference configuration
-#  axis: a 3D vector as list or np.array containing the global rotation axis of the joint in reference configuration
-#  useGlobalFrame: if False, the point and axis vectors are defined in the local coordinate system of body0
-#**output: returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-def AddRevoluteJoint(mbs, body0, body1, point, axis, useGlobalFrame=True, 
-                     showJoint=True, axisRadius=0.1, axisLength=0.4):
-
-    #perform some checks:
-    if not IsValidObjectIndex(body0):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='body0', received = body0, expectedType = ExpectedType.ObjectIndex)
-    if not IsValidObjectIndex(body1):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='body1', received = body1, expectedType = ExpectedType.ObjectIndex)
-        
-    if not IsVector(point, 3):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='point', received = point, expectedType = ExpectedType.Vector, dim=3)
-    if not IsVector(axis, 3):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
-
-    if not IsValidBool(useGlobalFrame):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
-    if not IsValidBool(showJoint):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='showJoint', received = showJoint, expectedType = ExpectedType.Bool)
-
-    if not IsValidRealInt(axisRadius):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
-    if not IsValidRealInt(axisLength):
-        RaiseTypeError(where='AddRevoluteJoint', argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
-
-    p0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.Position,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference)
-    A0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.RotationMatrix,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
-    p1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.Position,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference)
-    A1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.RotationMatrix,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
-
-    if useGlobalFrame:
-        pJoint = point
-        vAxis = copy.copy(axis)
-    else: #transform into global coordinates, then everything works same
-        pJoint = A0 @ point + p0
-        vAxis = A0 @ axis
-
-    #compute joint frame (not unique, only rotation axis must coincide)
-    B = ComputeOrthonormalBasis(vAxis) #axis = x-axis
-    #interchange z and x axis (needs sign change, otherwise det(A)=-1)
-    AJ = np.eye(3)
-    AJ[:,0]=-B[:,2]
-    AJ[:,1]= B[:,1]
-    AJ[:,2]= B[:,0] #axis ==> rotation axis z for revolute joint ... 
-    #print(AJ)
-    
-    #compute joint position and axis in body0 / 1 coordinates:
-    pJ0 = A0.T @ (np.array(pJoint) - p0)
-    pJ1 = A1.T @ (np.array(pJoint) - p1)
-
-    #compute joint marker orientations:
-    MR0 = A0.T @ AJ  
-    MR1 = A1.T @ AJ  
-    
-    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body0, localPosition=pJ0))
-    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body1, localPosition=pJ1))
-    
-    oJoint = mbs.AddObject(eii.ObjectJointRevoluteZ(markerNumbers=[mBody0,mBody1],
-                                                rotationMarker0=MR0,
-                                                rotationMarker1=MR1,
-             visualization=eii.VRevoluteJointZ(show=showJoint, axisRadius=axisRadius, axisLength=axisLength) ))
-
-    return [oJoint, mBody0, mBody1]
-
-
-#**function: DEPRECATED (use MainSystem function instead): add prismatic joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
-#**input:
-#  mbs: the MainSystem to which the joint and markers shall be added
-#  body0: a object number for body0, must be rigid body or ground object
-#  body1: a object number for body1, must be rigid body or ground object
-#  point: a 3D vector as list or np.array containing the global center point of the joint in reference configuration
-#  axis: a 3D vector as list or np.array containing the global translation axis of the joint in reference configuration
-#  useGlobalFrame: if False, the point and axis vectors are defined in the local coordinate system of body0
-#**output: returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
-def AddPrismaticJoint(mbs, body0, body1, point, axis, useGlobalFrame=True, 
-                     showJoint=True, axisRadius=0.1, axisLength=0.4):
-        
-    if not IsValidObjectIndex(body0):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='body0', received = body0, expectedType = ExpectedType.ObjectIndex)
-    if not IsValidObjectIndex(body1):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='body1', received = body1, expectedType = ExpectedType.ObjectIndex)
-        
-    if not IsVector(point, 3):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='point', received = point, expectedType = ExpectedType.Vector, dim=3)
-    if not IsVector(axis, 3):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
-
-    if not IsValidBool(useGlobalFrame):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
-    if not IsValidBool(showJoint):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='showJoint', received = showJoint, expectedType = ExpectedType.Bool)
-
-    if not IsValidRealInt(axisRadius):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
-    if not IsValidRealInt(axisLength):
-        RaiseTypeError(where='AddPrismaticJoint', argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
-
-    p0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.Position,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference)
-    A0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.RotationMatrix,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
-    p1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.Position,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference)
-    A1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.RotationMatrix,
-                                 localPosition=[0,0,0],
-                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
-
-    if useGlobalFrame:
-        pJoint = point
-        vAxis = copy.copy(axis)
-    else: #transform into global coordinates, then everything works same
-        pJoint = A0 @ point + p0
-        vAxis = A0 @ axis
-
-    #compute joint frame (not unique, only rotation axis must coincide)
-    AJ = ComputeOrthonormalBasis(vAxis) #axis = x-axis
-    
-    #compute joint position and axis in body0 / 1 coordinates:
-    pJ0 = A0.T @ (np.array(pJoint) - p0)
-    pJ1 = A1.T @ (np.array(pJoint) - p1)
-
-    #compute joint marker orientations:
-    MR0 = A0.T @ AJ  
-    MR1 = A1.T @ AJ  
-    
-    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body0, localPosition=pJ0))
-    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body1, localPosition=pJ1))
-    
-    oJoint = mbs.AddObject(eii.ObjectJointPrismaticX(markerNumbers=[mBody0,mBody1],
-                                                rotationMarker0=MR0,
-                                                rotationMarker1=MR1,
-             visualization=eii.VPrismaticJointX(show=showJoint, axisRadius=axisRadius, axisLength=axisLength) ))
-
-    return [oJoint, mBody0, mBody1]
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Advanced utility/mathematical functions for reference frames, rigid body kinematics
+#           and dynamics. Useful Euler parameter and Tait-Bryan angle conversion functions
+#           are included. A class for rigid body inertia creating and transformation is available.
+#
+# Author:   Johannes Gerstmayr, Stefan Holzinger (rotation vector and Tait-Bryan angles)
+# Date:     2020-03-10 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#constants and fixed structures:
+import numpy as np #LoadSolutionFile
+import exudyn.itemInterface as eii
+import exudyn as exu 
+from exudyn.basicUtilities import NormL2
+from exudyn.advancedUtilities import ExpectedType, RaiseTypeError, IsValidBool, IsValidRealInt, IsVector, IsSquareMatrix, IsValidObjectIndex
+from math import sin, cos #, sqrt, atan2
+
+import copy
+
+eulerParameters0 = [1.,0.,0.,0.] #Euler parameters for case where rotation angle is zero (rotation axis arbitrary)
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute orthogonal basis vectors (normal1, normal2) for given vector0 (non-unique solution!); the length of vector0 must not be 1; if vector0 == [0,0,0], then any normal basis is returned
+#**output: returns [vector0normalized, normal1, normal2], in which vector0normalized is the normalized vector0 (has unit length); all vectors in numpy array format
+def ComputeOrthonormalBasisVectors(vector0):
+    v = np.array([vector0[0],vector0[1],vector0[2]])
+
+    L0 = np.linalg.norm(v)
+    if L0 == 0:
+        n1 = np.array([1,0,0])
+        n2 = np.array([0,1,0])
+    else:
+        v = (1. / L0)*v;
+    
+        if (abs(v[0]) > 0.5) and (abs(v[1]) < 0.1) and (abs(v[2]) < 0.1):
+            n1 = np.array([0., 1., 0.])
+        else:
+            n1 = np.array([1., 0., 0.])
+    
+        h = np.dot(n1, v);
+        n1 -= h * v;
+        n1 = (1/np.linalg.norm(n1))*n1;
+        n2 = np.cross(v,n1)
+    #print("basis=", v,n1,n2)
+    return [v, n1, n2]
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute orthogonal basis, in which the normalized vector0 is the first column and the other columns are normals to vector0 (non-unique solution!); the length of vector0 must not be 1; if vector0 == [0,0,0], then any normal basis is returned
+#**output: returns A, a rotation matrix, in which the first column is parallel to vector0; A is a 2D numpy array
+def ComputeOrthonormalBasis(vector0):
+    return np.vstack(ComputeOrthonormalBasisVectors(vector0)).T
+    
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute Gram-Schmidt projection of given 3D vector 1 on vector 0 and return normalized triad (vector0, vector1, vector0 x vector1)
+def GramSchmidt(vector0, vector1):
+
+    v0 = np.array([vector0[0],vector0[1],vector0[2]])
+    L0 = np.linalg.norm(v0)
+    v0 = (1. / L0)*v0;
+    
+    v1 = np.array([vector1[0],vector1[1],vector1[2]])
+    L1 = np.linalg.norm(v1)
+    v1 = (1. / L1)*v1;
+    
+    h = np.dot(v1, v0);
+    v1 -= h * v0;
+    v1 = (1/np.linalg.norm(v1))*v1;
+    n2 = np.cross(v0,v1)
+    #print("basis=", v,n1,n2)
+    return [v0, v1, n2]
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute skew symmetric 3x3-matrix from 3x1- or 1x3-vector
+def Skew(vector):
+    skewsymmetricMatrix = np.array([[ 0.,       -vector[2], vector[1]], 
+                                    [ vector[2], 0.,       -vector[0]],
+                                    [-vector[1], vector[0], 0.]])
+    return skewsymmetricMatrix
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: convert skew symmetric matrix m to vector
+def Skew2Vec(skew):
+    shape = skew.shape
+    if shape == (3,3):
+        w1 = skew[2][1]
+        w2 = skew[0][2]
+        w3 = -skew[0][1]
+        vec = np.array([w1, w2, w3])
+    if shape == (4,4):
+        w1 = skew[2][1]
+        w2 = skew[0][2]
+        w3 = -skew[0][1]
+        u1 = skew[0][3]
+        u2 = skew[1][3]
+        u3 = skew[2][3]
+        vec = np.array([u1, u2, u3, w1, w2, w3])       
+    return vec
+
+
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute skew matrix from vector or matrix; used for ObjectFFRF and CMS implementation
+#**input: a vector v in np.array format, containing 3*n components or a matrix with m columns of same shape
+#**output: if v is a vector, output is (3*n x 3) skew matrix in np.array format; if v is a (n x m) matrix, the output is a (3*n x m) skew matrix in np.array format
+def ComputeSkewMatrix(v):
+    if type(v) == list or v.ndim == 1:
+        n = int(len(v)/3) #number of nodes
+        sm = np.zeros((3*n,3))
+
+        for i in range(n):
+            off = 3*i
+            x=v[off+0]
+            y=v[off+1]
+            z=v[off+2]
+            mLoc = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
+            sm[off:off+3,:] = mLoc[:,:]
+    
+        return sm
+    elif v.ndim==2: #dim=2
+        (nRows,nCols) = v.shape
+        n = int(nRows/3) #number of nodes
+        sm = np.zeros((3*n,3*nCols))
+
+        for j in range(nCols):
+            for i in range(n):
+                off = 3*i
+                x=v[off+0,j]
+                y=v[off+1,j]
+                z=v[off+2,j]
+                mLoc = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
+                sm[off:off+3,3*j:3*j+3] = mLoc[:,:]
+    else: 
+        print("ERROR: wrong dimension in ComputeSkewMatrix(...)")
+    return sm
+
+#tests for ComputeSkewMatrix
+#x = np.array([1,2,3,4,5,6])
+#print(ComputeSkewMatrix(x))
+#x = np.array([[1,2],[3,4],[5,6],[1,2],[3,4],[5,6]])
+#print(ComputeSkewMatrix(x))
+
+
+# OLD / duplicate with less functionality!
+# #**function: compute (3 x 3*n) skew matrix from (3*n) vector
+# def ComputeSkewMatrix(v):
+#     n = int(len(v)/3) #number of nodes
+#     sm = np.zeros((3*n,3))
+
+#     for i in range(n):
+#         off = 3*i
+#         x=v[off+0]
+#         y=v[off+1]
+#         z=v[off+2]
+#         sm[off:off+3,:] = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
+#         # mLoc = np.array([[0,-z,y],[z,0,-x],[-y,x,0]])
+#         # sm[off:off+3,:] = mLoc[:,:]
+    
+#     return sm
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#helper functions for RIGID BODY KINEMATICS:
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: convert Euler parameters (ep) to G-matrix (=$\partial \tomega  / \partial \pv_t$)
+#**input: vector of 4 eulerParameters as list or np.array
+#**output: 3x4 matrix G as np.array
+def EulerParameters2G(eulerParameters):
+    ep = eulerParameters
+    return np.array([[-2.*ep[1], 2.*ep[0],-2.*ep[3], 2.*ep[2]],
+                     [-2.*ep[2], 2.*ep[3], 2.*ep[0],-2.*ep[1]],
+                     [-2.*ep[3],-2.*ep[2], 2.*ep[1], 2.*ep[0]] ])
+
+#**function: convert Euler parameters (ep) to local G-matrix (=$\partial \LU{b}{\tomega} / \partial \pv_t$)
+#**input: vector of 4 eulerParameters as list or np.array
+#**output: 3x4 matrix G as np.array
+def EulerParameters2GLocal(eulerParameters):
+    ep = eulerParameters
+    return np.array([[-2.*ep[1], 2.*ep[0], 2.*ep[3],-2.*ep[2]],
+                     [-2.*ep[2],-2.*ep[3], 2.*ep[0], 2.*ep[1]],
+                     [-2.*ep[3], 2.*ep[2],-2.*ep[1], 2.*ep[0]] ])
+
+#**function: compute rotation matrix from eulerParameters    
+#**input: vector of 4 eulerParameters as list or np.array
+#**output: 3x3 rotation matrix as np.array
+def EulerParameters2RotationMatrix(eulerParameters):
+    ep = eulerParameters
+    return np.array([[-2.0*ep[3]*ep[3] - 2.0*ep[2]*ep[2] + 1.0, -2.0*ep[3]*ep[0] + 2.0*ep[2]*ep[1], 2.0*ep[3]*ep[1] + 2.0*ep[2]*ep[0]],
+                     [ 2.0*ep[3]*ep[0] + 2.0*ep[2]*ep[1], -2.0*ep[3]*ep[3] - 2.0*ep[1]*ep[1] + 1.0, 2.0*ep[3]*ep[2] - 2.0*ep[1]*ep[0]],
+                     [-2.0*ep[2]*ep[0] + 2.0*ep[3]*ep[1], 2.0*ep[3]*ep[2] + 2.0*ep[1]*ep[0], -2.0*ep[2]*ep[2] - 2.0*ep[1]*ep[1] + 1.0] ])
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute Euler parameters from given rotation matrix
+#**input: 3x3 rotation matrix as list of lists or as np.array
+#**output: vector of 4 eulerParameters as np.array
+def RotationMatrix2EulerParameters(rotationMatrix):
+    A=np.array(rotationMatrix)
+    trace = A[0,0] + A[1,1] + A[2,2] + 1.0
+    M_EPSILON = 1e-15 #small number to avoid division by zero
+
+    if (abs(trace) > M_EPSILON):
+        s = 0.5 / np.sqrt(abs(trace))
+        ep0 = 0.25 / s
+        ep1 = (A[2,1] - A[1,2]) * s
+        ep2 = (A[0,2] - A[2,0]) * s
+        ep3 = (A[1,0] - A[0,1]) * s
+    else:
+        if (A[0,0] > A[1,1]) and (A[0,0] > A[2,2]):
+            s = 2.0 * np.sqrt(abs(1.0 + A[0,0] - A[1,1] - A[2,2]))
+            ep1 = 0.25 * s
+            ep2 = (A[0,1] + A[1,0]) / s
+            ep3 = (A[0,2] + A[2,0]) / s
+            ep0 = (A[1,2] - A[2,1]) / s
+        elif A[1,1] > A[2,2]:
+            s = 2.0 * np.sqrt(abs(1.0 + A[1,1] - A[0,0] - A[2,2]))
+            ep1 = (A[0,1] + A[1,0]) / s
+            ep2 = 0.25 * s
+            ep3 = (A[1,2] + A[2,1]) / s
+            ep0 = (A[0,2] - A[2,0]) / s
+        else:
+            s = 2.0 * np.sqrt(abs(1.0 + A[2,2] - A[0,0] - A[1,1]));
+            ep1 = (A[0,2] + A[2,0]) / s
+            ep2 = (A[1,2] + A[2,1]) / s
+            ep3 = 0.25 * s
+            ep0 = (A[0,1] - A[1,0]) / s
+
+    ep=np.array([ep0,ep1,ep2,ep3])
+    #normalize Euler parameters, if rotation matrix is inaccurate; otherwise, may lead to errors in checkPreAssemble
+    epNorm = np.linalg.norm(ep)
+    if epNorm != 0.:
+        ep *= 1./epNorm
+    return ep
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute time derivative of Euler parameters from (global) angular velocity vector
+#note that for Euler parameters $\pv$, we have $\tomega=\Gm \dot \pv$ ==> $\Gm^T \tomega = \Gm^T\cdot \Gm\cdot \dot \pv$ ==> $\Gm^T \Gm=4(\Im_{4 \times 4} - \pv\cdot \pv^T)\dot\pv = 4 (\Im_{4x4}) \dot \pv$
+#**input: 
+#  angularVelocity: 3D vector of angular velocity in global frame, as lists or as np.array
+#  eulerParameters: vector of 4 eulerParameters as np.array or list
+#**output: vector of time derivatives of 4 eulerParameters as np.array
+def AngularVelocity2EulerParameters_t(angularVelocity, eulerParameters):
+    
+    GT = np.transpose(EulerParameters2G(eulerParameters))
+    return 0.25*(GT.dot(angularVelocity))
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#            ROTATION VECTOR
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: rotaton matrix from rotation vector, see appendix B in \cite{Simo1988}
+#**input: 3D rotation vector as list or np.array
+#**output: 3x3 rotation matrix as np.array
+#**notes: gets inaccurate for very large rotations, $\phi \\gg 2*\pi$
+def RotationVector2RotationMatrix(rotationVector):
+    phi = np.linalg.norm(rotationVector)
+    if phi == 0.:
+        R = np.eye(3)
+    else:
+        OmegaSkew = Skew(rotationVector)
+        alpha = np.sin(phi)/phi
+        beta = 2*(1-np.cos(phi))/phi**2 #the loss of digits in 1-np.cos(phi) is compensated by OmegaSkew@OmegaSkew
+        R = np.eye(3) + alpha*OmegaSkew + 0.5*beta*np.matmul(OmegaSkew, OmegaSkew)
+
+    
+    return R  
+
+
+#**function: compute rotation vector from rotation matrix
+#**input: 3x3 rotation matrix as list of lists or as np.array
+#**output: vector of 3 components of rotation vector as np.array
+def RotationMatrix2RotationVector(rotationMatrix):
+    ep = RotationMatrix2EulerParameters(rotationMatrix)
+    
+    n = ep[1:]
+    norm = np.linalg.norm(n)
+    
+    #phi = 2.*acos(ep[0])
+    phi = 2.*np.arctan2(norm, ep[0])
+    
+    if norm != 0.:
+        n = (1./norm)*n
+
+    return phi*n
+    
+    # # compute a  rotation vector from given rotation matrix according to 
+    # # 2015 - Sonneville - A geometrical local frame approach for flexible multibody systems, p45
+    # if np.linalg.norm(rotationMatrix - np.eye(3)) == 0.:
+    #     rotationVector = np.zeros(3)
+    # else:
+    #     theta = np.arccos(0.5*(np.trace(rotationMatrix)-1))
+    #     if abs(theta) < np.pi and abs(theta) > 0:
+    #         logR = (theta/(2*np.sin(theta)))*(rotationMatrix - np.transpose(rotationMatrix))
+    #         rotationVector = Skew2Vec(logR)
+    #     else:
+    #         rotationVector = np.zeros(3)
+
+    # return rotationVector
+
+
+#**function: compute rotation axis from given rotation vector
+#**input: 3D rotation vector as np.array
+#**output: 3D vector as np.array representing the rotation axis
+def ComputeRotationAxisFromRotationVector(rotationVector):
+    
+    # compute rotation angle
+    rotationAngle = np.linalg.norm(rotationVector)
+    
+    # compute rotation axis
+    if rotationAngle == 0.0:
+        rotationAxis = np.zeros(3)
+    else:
+        rotationAxis = rotationVector/rotationAngle
+    
+    # return rotation axis 
+    return rotationAxis
+
+
+#**function: convert rotation vector (parameters) (v) to G-matrix (=$\partial \tomega  / \partial \dot \vv$)
+#**input: vector of rotation vector (len=3) as list or np.array
+#**output: 3x3 matrix G as np.array
+def RotationVector2G(rotationVector):
+    return RotationVector2RotationMatrix(rotationVector)
+
+#**function: convert rotation vector (parameters) (v) to local G-matrix (=$\partial \LU{b}{\tomega}   / \partial \vv_t$)
+#**input: vector of rotation vector (len=3) as list or np.array
+#**output: 3x3 matrix G as np.array
+def RotationVector2GLocal(eulerParameters):
+    return np.eye(3)
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#            TAIT BRYAN ANGLES
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**function: compute rotation matrix from consecutive xyz \acp{Rot} (Tait-Bryan angles); A=Ax*Ay*Az; rot=[rotX, rotY, rotZ]
+#**input: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
+#**output: 3x3 rotation matrix as np.array
+def RotXYZ2RotationMatrix(rot):
+    c0 = np.cos(rot[0])
+    s0 = np.sin(rot[0])
+    c1 = np.cos(rot[1])
+    s1 = np.sin(rot[1])
+    c2 = np.cos(rot[2])
+    s2 = np.sin(rot[2])
+    
+    return np.array([[ c1*c2           ,-c1*s2           , s1    ],
+                     [ s0*s1*c2 + c0*s2,-s0*s1*s2 + c0*c2,-s0*c1 ],
+                     [-c0*s1*c2 + s0*s2, c0*s1*s2 + s0*c2, c0*c1 ]]);
+
+#**function: convert rotation matrix to xyz Euler angles (Tait-Bryan angles);  A=Ax*Ay*Az; 
+#**input:  3x3 rotation matrix as list of lists or np.array
+#**output: vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array
+#**notes: due to gimbal lock / singularity at rot[1] = pi/2, -pi/2, ... the reconstruction of 
+#  \texttt{RotationMatrix2RotXYZ( RotXYZ2RotationMatrix(rot) )} may fail, but 
+#  \texttt{RotXYZ2RotationMatrix( RotationMatrix2RotXYZ( RotXYZ2RotationMatrix(rot) ) )} works always
+def RotationMatrix2RotXYZ(rotationMatrix):
+    R=np.array(rotationMatrix)
+    #rot=np.array([0,0,0])
+    rot=np.zeros(3)
+    absC1 = np.sqrt((-R[1,2])**2+R[2,2]**2)
+    rot[1] = np.arctan2(R[0,2], absC1)
+    if absC1 > 1e-14:
+        rot[0] = np.arctan2(-R[1,2], R[2,2])
+        rot[2] = np.arctan2(-R[0,1], R[0,0])
+    else: #rot[0] and rot[2] represent same axes, set one of them zero!
+        rot[0] = 0.
+        #c1=0,s0=0,c0=1
+        #s0*s1*c2 + c0*s2,-s0*s1*s2 + c0*c2 => c0*s2, c0*c2
+        rot[2] = np.arctan2(R[1,0], R[1,1])
+        
+    return rot
+
+# #OLD, problems at rot[1]=pi/2: rotation represents different rotation matrix
+# def RotationMatrix2RotXYZ(rotationMatrix):
+#     R=np.array(rotationMatrix)
+#     #rot=np.array([0,0,0])
+#     rot=[0,0,0]
+#     rot[0] = np.arctan2(-R[1,2], R[2,2])
+#     rot[1] = np.arctan2(R[0,2], np.sqrt(abs(1. - R[0,2] * R[0,2]))) #fabs for safety, if small round up error in rotation matrix ...
+#     rot[2] = np.arctan2(-R[0,1], R[0,0])
+#     return np.array(rot);
+
+
+#**function: compute (global-frame) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{0}{\Gm} = \partial \LU{0}{\tomega}  / \partial \dot \ttheta$)
+#**input:  3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
+#**output: 3x3 matrix G as np.array
+def RotXYZ2G(rot):
+    c0 = cos(rot[0])
+    s0 = sin(rot[0])
+    c1 = cos(rot[1])
+    s1 = sin(rot[1])
+
+    return np.array([[1, 0, s1],
+                     [0, c0, -c1*s0],
+                     [0, s0,  c0*c1 ]])
+
+#**function: compute time derivative of (global-frame) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{0}{\Gm} = \partial \LU{0}{\tomega}  / \partial \dot \ttheta$)
+#**input:  
+#    rot: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
+#    rot_t: 3D vector of time derivative of Tait-Bryan rotation parameters [X,Y,Z] in radiant/s
+#**output: 3x3 matrix G\_t as np.array
+def RotXYZ2G_t(rot, rot_t):
+    c0 = cos(rot[0])
+    s0 = sin(rot[0])
+    c1 = cos(rot[1])
+    s1 = sin(rot[1])
+
+    return np.array([[0, 0, rot_t[1]*c1],
+                     [0, -rot_t[0]*s0, rot_t[1]*s0*s1 - rot_t[0]*c0*c1],
+                     [0, rot_t[0]*c0, -rot_t[0]*c1*s0 - rot_t[1]*c0*s1]])
+
+
+#**function: compute local (body-fixed) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{b}{\Gm} = \partial \LU{b}{\tomega}  / \partial \ttheta_t$)
+#**input:  3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
+#**output: 3x3 matrix GLocal as np.array
+def RotXYZ2GLocal(rot):
+    c1 = cos(rot[1])
+    s1 = sin(rot[1])
+    c2 = cos(rot[2])
+    s2 = sin(rot[2])
+
+    return np.array([[ c1*c2, s2, 0],
+                     [-c1*s2, c2, 0],
+                     [ s1,     0,  1]])
+
+#**function: compute time derivative of (body-fixed) G-matrix for xyz Euler angles (Tait-Bryan angles) ($\LU{b}{\Gm} = \partial \LU{b}{\tomega}  / \partial \ttheta_t$)
+#**input:  
+#    rot: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
+#    rot_t: 3D vector of time derivative of Tait-Bryan rotation parameters [X,Y,Z] in radiant/s
+#**output: 3x3 matrix GLocal\_t as np.array
+def RotXYZ2GLocal_t(rot, rot_t):
+    c1 = cos(rot[1])
+    s1 = sin(rot[1])
+    c2 = cos(rot[2])
+    s2 = sin(rot[2])
+
+    return np.array([[-rot_t[2]*c1*s2 - rot_t[1]*c2*s1, rot_t[2]*c2, 0],
+                     [ rot_t[1]*s2*s1 - rot_t[2]*c2*c1, -rot_t[2]*s2, 0],
+                     [ rot_t[1]*c1, 0, 0 ]])
+
+
+
+
+
+
+#**function: compute time derivatives of angles RotXYZ from (global) angular velocity vector and given rotation
+#**input:  
+#  angularVelocity: global angular velocity vector as list or np.array
+#  rotation: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
+#**output: time derivative of vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array
+def AngularVelocity2RotXYZ_t(angularVelocity, rotation):
+    psi = rotation[0]
+    theta = rotation[1]
+    #phi = rotation[2] #not needed
+    cTheta = np.cos(theta)
+    if cTheta == 0:
+        print('AngularVelocity2RotXYZ_t: not possible for rotation[1] == pi/2, 3*pi/2, ...')
+
+    GInv = (1/cTheta)*np.array([[np.cos(theta), np.sin(psi)*np.sin(theta),-np.cos(psi)*np.sin(theta)],
+                                [0            , np.cos(psi)*np.cos(theta)   , np.sin(psi)*np.cos(theta)],
+                                [0            ,-np.sin(psi)              , np.cos(psi)]])
+    return np.dot(GInv,angularVelocity)
+  
+    
+#**function: compute four Euler parameters from given RotXYZ angles, see \cite{Henderson1977}
+#**input: 
+#   alpha: 3D vector as np.array containing RotXYZ angles
+#**output: 4D vector as np.array containing four Euler parameters 
+#          entry zero of output represent the scalar part of Euler parameters
+def RotXYZ2EulerParameters(alpha):
+    psi   = alpha[0]
+    theta = alpha[1]
+    phi   = alpha[2]   
+    u = 0.5*psi
+    v = 0.5*theta
+    w = 0.5*phi    
+    cPsi   = np.cos(u)
+    cTheta = np.cos(v)
+    cPhi   = np.cos(w)    
+    sPsi   = np.sin(u)
+    sTheta = np.sin(v)
+    sPhi   = np.sin(w)    
+    q0 = -sPsi*sTheta*sPhi + cPsi*cTheta*cPhi
+    q1 =  sPsi*cTheta*cPhi + sTheta*sPhi*cPsi    
+    q2 = -sPsi*sPhi*cTheta + sTheta*cPsi*cPhi 
+    q3 =  sPsi*sTheta*cPhi + sPhi*cPsi*cTheta 
+    return np.array([q0, q1, q2, q3])
+
+
+#%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#            Euler ANGLES
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**function: convert rotation matrix to zyz Euler angles;  A=Az*Ay*Az;
+#**input:
+#  rotationMatrix: 3x3 rotation matrix as list of lists or np.array
+#  flip:           argument to choose first Euler angle to be in quadrant 2 or 3.
+#**output: vector of Euler rotation parameters [Z,Y,Z] (in radiant) as np.array
+#**notes: tested (compared with Robotics, Vision and Control book of P. Corke)
+#**author: Martin Sereinig
+def RotationMatrix2RotZYZ(rotationMatrix, flip):
+    R=np.array(rotationMatrix)
+    # Method as per Paul, p 69.
+    # euler = [phi theta psi]
+    eulangles = np.zeros([3])
+    eps = 10**(-14)
+
+    if abs(R[0, 2]) < eps and abs(R[1, 2]) < eps:
+        # singularity
+        eulangles[0] = 0
+        sp = 0
+        cp = 1
+        eulangles[1] = np.arctan2(
+            cp*R[0, 2] + sp*R[1, 2], R[2, 2])
+        eulangles[2] = np.arctan2(-sp * R[0, 0] + cp *
+                                  R[1, 0], -sp*R[0, 1] + cp*R[1, 1])
+    else:
+        # non singular
+        # Only positive phi is returned.
+        if flip:
+            eulangles[0] = np.arctan2(-R[1, 2], -R[0, 2])
+        else:
+            eulangles[0] = np.arctan2(R[1, 2], R[0, 2])
+
+        sp = np.sin(eulangles[0])
+        cp = np.cos(eulangles[0])
+        eulangles[1] = np.arctan2(
+            cp*R[0, 2] + sp*R[1, 2], R[2, 2])
+        eulangles[2] = np.arctan2(-sp * R[0, 0] + cp *
+                                  R[1, 0], -sp*R[0, 1] + cp*R[1, 1])
+    return eulangles
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute rotation matrix w.r.t. X-axis (first axis)
+#**input: angle around X-axis in radiant
+#**output: 3x3 rotation matrix as np.array
+def RotationMatrixX(angleRad):
+    return np.array([[1, 0, 0],
+                     [0, np.cos(angleRad),-np.sin(angleRad)],
+                     [0, np.sin(angleRad), np.cos(angleRad)] ])
+
+#**function: compute rotation matrix w.r.t. Y-axis (second axis)
+#**input: angle around Y-axis in radiant
+#**output: 3x3 rotation matrix as np.array
+def RotationMatrixY(angleRad):
+    return np.array([ [ np.cos(angleRad), 0, np.sin(angleRad)],
+                      [0,        1, 0],
+                      [-np.sin(angleRad),0, np.cos(angleRad)] ])
+
+#**function: compute rotation matrix w.r.t. Z-axis (third axis)
+#**input: angle around Z-axis in radiant
+#**output: 3x3 rotation matrix as np.array
+def RotationMatrixZ(angleRad):
+    return np.array([ [np.cos(angleRad),-np.sin(angleRad), 0],
+                      [np.sin(angleRad), np.cos(angleRad), 0],
+                      [0,        0,        1] ]);
+
+    
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#functions for homogeneous transformations (HT)
+#**function: compute \ac{HT} matrix from rotation matrix A and translation vector r
+def HomogeneousTransformation(A, r):
+    T = np.zeros((4,4))
+    T[0:3,0:3] = A
+    T[0:3,3] = r
+    T[3,3] = 1
+    return T
+
+HT = HomogeneousTransformation #shortcut
+
+#**function: \ac{HT} for translation with vector r
+def HTtranslate(r):
+    T = np.eye(4)
+    T[0:3,3] = r
+    return T
+
+#**function: \ac{HT} for translation along x axis with value x
+def HTtranslateX(x):
+    T = np.eye(4)
+    T[0,3] = x
+    return T
+
+#**function: \ac{HT} for translation along y axis with value y
+def HTtranslateY(y):
+    T = np.eye(4)
+    T[1,3] = y
+    return T
+
+#**function: \ac{HT} for translation along z axis with value z
+def HTtranslateZ(z):
+    T = np.eye(4)
+    T[2,3] = z
+    return T
+
+#**function: identity \ac{HT}:
+def HT0():
+    return np.eye(4)
+
+#**function: \ac{HT} for rotation around axis X (first axis)
+def HTrotateX(angle):
+    T = np.eye(4)
+    T[0:3,0:3] = RotationMatrixX(angle)
+    return T
+    
+#**function: \ac{HT} for rotation around axis X (first axis)
+def HTrotateY(angle):
+    T = np.eye(4)
+    T[0:3,0:3] = RotationMatrixY(angle)
+    return T
+    
+#**function: \ac{HT} for rotation around axis X (first axis)
+def HTrotateZ(angle):
+    T = np.eye(4)
+    T[0:3,0:3] = RotationMatrixZ(angle)
+    return T
+
+#**function: return translation part of \ac{HT}
+def HT2translation(T):
+    return T[0:3,3]
+
+#**function: return rotation matrix of \ac{HT}
+def HT2rotationMatrix(T):
+    return T[0:3,0:3]
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: return inverse \ac{HT} such that inv(T)*T = np.eye(4)
+def InverseHT(T):
+    Tinv = np.eye(4)
+    Ainv = T[0:3,0:3].T #inverse rotation part
+    Tinv[0:3,0:3] = Ainv
+    r = T[0:3,3]        #translation part
+    Tinv[0:3,3]  = -Ainv @ r       #inverse translation part
+    return Tinv
+
+################################################################################
+#Test (compared with Robotcs, Vision and Control book of P. Corke:
+#T=HTtranslate([1,0,0]) @ HTrotateX(np.pi/2) @ HTtranslate([0,1,0])
+#print("T=",T.round(8))
+#
+#R = RotationMatrixZ(0.1) @ RotationMatrixY(0.2) @ RotationMatrixZ(0.3) 
+#print("R=",R.round(4))
+
+################################################################################
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#functions for 6x6 coordinate transformation matrices (\ac{T66}), see Featherstone / Handbook of robotics \cite{Siciliano2016}
+#**function: compute 6x6 coordinate transformation matrix for rotation around X axis; output: first 3 components for rotation, second 3 components for translation! See Featherstone / Handbook of robotics \cite{Siciliano2016}
+def RotationX2T66(angle):
+    c = cos(angle);
+    s = sin(angle);
+    return np.array(
+        [[1,  0,  0,  0,  0,  0],
+         [0,  c, -s,  0,  0,  0],
+         [0,  s,  c,  0,  0,  0],
+         [0,  0,  0,  1,  0,  0],
+         [0,  0,  0,  0,  c, -s],
+         [0,  0,  0,  0,  s,  c]])
+
+#**function: compute 6x6 transformation matrix for rotation around Y axis; output: first 3 components for rotation, second 3 components for translation
+def RotationY2T66(angle):
+    c = cos(angle);
+    s = sin(angle);
+    return np.array(
+        [[c,  0,  s,  0,  0,  0],
+         [0,  1,  0,  0,  0,  0],
+         [-s, 0,  c,  0,  0,  0],
+         [0,  0,  0,  c,  0,  s],
+         [0,  0,  0,  0,  1,  0],
+         [0,  0,  0, -s,  0,  c]])
+
+#**function: compute 6x6 transformation matrix for rotation around Z axis; output: first 3 components for rotation, second 3 components for translation
+def RotationZ2T66(angle):
+    c = cos(angle);
+    s = sin(angle);
+    return np.array(
+        [[ c, -s,  0,  0,  0,  0],
+         [ s,  c,  0,  0,  0,  0],
+         [ 0,  0,  1,  0,  0,  0],
+         [ 0,  0,  0,  c, -s,  0],
+         [ 0,  0,  0,  s,  c,  0],
+         [ 0,  0,  0,  0,  0,  1]])
+
+#**function: compute 6x6 transformation matrix for translation according to 3D vector translation3D; output: first 3 components for rotation, second 3 components for translation!
+def Translation2T66(translation3D):
+    t = translation3D
+    return np.array(
+        [[    1,    0,    0,  0,  0,  0],
+         [    0,    1,    0,  0,  0,  0],
+         [    0,    0,    1,  0,  0,  0],
+         [    0, t[2],-t[1],  1,  0,  0],
+         [-t[2],    0, t[0],  0,  1,  0],
+         [ t[1],-t[0],    0,  0,  0,  1]])
+
+#**function: compute 6x6 transformation matrix for translation along X axis; output: first 3 components for rotation, second 3 components for translation!
+def TranslationX2T66(translation):
+    return Translation2T66([translation,0,0])
+
+#**function: compute 6x6 transformation matrix for translation along Y axis; output: first 3 components for rotation, second 3 components for translation!
+def TranslationY2T66(translation):
+    return Translation2T66([0,translation,0])
+
+#**function: compute 6x6 transformation matrix for translation along Z axis; output: first 3 components for rotation, second 3 components for translation!
+def TranslationZ2T66(translation):
+    return Translation2T66([0,0,translation])
+
+#**function convert 6x6 coordinate transformation (Pl\"ucker transform) into rotation and translation
+#**input: T66 given as  6x6 numpy array
+#**output: [A, v] with 3x3 rotation matrix A and 3D translation vector v
+def T66toRotationTranslation(T66):
+    A = T66[0:3,0:3]
+    v = Skew2Vec(T66[3:6,0:3]@A.T) #this leads to identical backtransformation
+    return [A, v] 
+
+#**function convert inverse 6x6 coordinate transformation (Pl\"ucker transform) into rotation and translation
+#**input: inverse T66 given as  6x6 numpy array
+#**output: [A, v] with 3x3 rotation matrix A and 3D translation vector v
+def InverseT66toRotationTranslation(T66):
+    A = (T66[0:3,0:3]).T
+    v = -Skew2Vec(A@T66[3:6,0:3])
+    return [A, v] 
+
+#**function convert rotation and translation into 6x6 coordinate transformation (Pl\"ucker transform)
+#**input:
+#  A: 3x3 rotation matrix A
+#  v: 3D translation vector v
+#**output: return 6x6 transformation matrix 'T66'
+def RotationTranslation2T66(A, v):
+    return np.block([
+        [A, np.zeros((3,3))], 
+        [Skew(v)@A, A]]) 
+
+#**function convert rotation and translation into INVERSE 6x6 coordinate transformation (Pl\"ucker transform)
+#**input:
+#  A: 3x3 rotation matrix A
+#  v: 3D translation vector v
+#**output: return 6x6 transformation matrix 'T66'
+def RotationTranslation2T66Inverse(A, v):
+    return np.block([
+        [A.T, np.zeros((3,3))], 
+        [-A.T@Skew(v), A.T]]) 
+
+#**compute inverse of 6x6 coordinate transformation (Pl\"ucker transform)
+#**input:
+#  T66: 6x6 coordinate transformation (Pl\"ucker transform)
+#**output: return inverse 6x6 transformation matrix 'T66'
+#**note: Skew(A@v) = A@Skew(v)@A.T; v=ApB: -BRA@Skew(ApB) = Skew(BpA)@BRA
+def T66Inverse(T66):
+    A = T66[0:3,0:3] #BRA in Handbook of robotics
+    v = Skew2Vec(T66[3:6,0:3]@A.T) #v=BpA in in Handbook of robotics ==> ApB=-BRA.T@BpA = -A.T@v
+        
+    return np.block([
+        [         A.T, np.zeros((3,3))], 
+        [-A.T@Skew(v), A.T            ]])
+# #identical (using an inverse representation of v):
+#     A = T66[0:3,0:3] #BRA in Handbook of robotics
+#     v = -Skew2Vec(A.T @ T66[3:6,0:3]) #v=ApB in in Handbook of robotics ==> BpA=-BRA@ApB = -A@v
+        
+#     return np.block([
+#         [A.T, np.zeros((3,3))], 
+#         [A.T@Skew(A@v), A.T]])
+
+#**function convert 6x6 coordinate transformation (Pl\"ucker transform) into 4x4 homogeneous transformation; NOTE that the homogeneous transformation is the inverse of what is computed in function pluho() of Featherstone
+#**input: T66 given as 6x6 numpy array
+#**output: homogeneous transformation (4x4 numpy array)
+def T66toHT(T66):
+    A = T66[0:3,0:3]
+    T = np.zeros((4,4))
+    T[0:3,0:3] = A
+    T[0:3,3] = Skew2Vec(T66[3:6,0:3] @ A.T)
+    T[3,3] = 1
+    return T
+
+#**function: convert 4x4 homogeneous transformation into 6x6 coordinate transformation (Pl\"ucker transform); NOTE that the homogeneous transformation is the inverse of what is computed in function pluho() of Featherstone
+#**output: 4x4 homogeneous transformation in numpy array format
+#**outputinput: T66 (6x6 numpy array)
+def HT2T66Inverse(T):
+    A = T[0:3,0:3].T 
+    v = T[0:3,3]
+    return np.block([
+        [A, np.zeros((3,3))],
+        [-A@Skew(v), A]])
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#inertia 6D functions
+
+#**function: convert a 3x3 matrix (list or numpy array) into a list with 6 inertia components, sorted as J00, J11, J22, J12, J02, J01
+def InertiaTensor2Inertia6D(inertiaTensor):
+    J = np.array(inertiaTensor)
+    return [J[0,0], J[1,1], J[2,2],  J[1,2], J[0,2], J[0,1]]
+
+#**function: convert a list or numpy array with 6 inertia components (sorted as [J00, J11, J22, J12, J02, J01]) (list or numpy array) into a 3x3 matrix (np.array)
+def Inertia6D2InertiaTensor(inertia6D):
+    J = inertia6D
+    return np.array([[J[0],J[5],J[4]],
+                     [J[5],J[1],J[3]],
+                     [J[4],J[3],J[2]]])
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: helper class for rigid body inertia (see also derived classes Inertia...).
+#Provides a structure to define mass, inertia and center of mass (COM) of a rigid body.
+#The inertia tensor and center of mass must correspond when initializing the body!
+#**notes:
+#   in the default mode, inertiaTensorAtCOM = False, the inertia tensor must be provided with respect to the reference point; otherwise, it is given at COM; internally, the inertia tensor is always with respect to the reference point, not w.r.t. to COM!
+#**example:
+#i0 = RigidBodyInertia(10,np.diag([1,2,3]))
+#i1 = i0.Rotated(RotationMatrixX(np.pi/2))
+#i2 = i1.Translated([1,0,0])
+class RigidBodyInertia:
+    #**classFunction: initialize RigidBodyInertia with scalar mass, 3x3 inertiaTensor (w.r.t. reference point!!!) and center of mass com
+    #**input:
+    #  mass: mass of rigid body (dimensions need to be consistent, should be in SI-units)
+    #  inertiaTensor: tensor given w.r.t.\ reference point, NOT w.r.t.\ center of mass!
+    #  com: center of mass relative to reference point, in same coordinate system as inertiaTensor
+    def __init__(self, mass=0, inertiaTensor=np.zeros([3,3]), com=np.zeros(3), inertiaTensorAtCOM = False):
+        
+        if np.array(inertiaTensor).shape != (3,3): #shape is a tuple
+            raise ValueError('RigidBodyInertia: inertiaTensor must have shape (3,3), but received '+str(inertiaTensor.shape))
+        if np.array(com).shape != (3,): #shape is a tuple
+            raise ValueError('RigidBodyInertia: com must have 3 components, but received '+str(np.array(inertiaTensor).shape))
+        self.mass = mass
+        self.inertiaTensor = np.array(inertiaTensor)
+        self.com = np.array(com)
+        if inertiaTensorAtCOM:
+            self.inertiaTensor = self.inertiaTensor + self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
+        
+    #**classFunction: add (+) operator allows adding another inertia information with SAME local coordinate system and reference point!
+    #only inertias with same center of rotation can be added!
+    #**example: 
+    #J = InertiaSphere(2,0.1) + InertiaRodX(1,2)
+    def __add__(self, otherBodyInertia):
+        sumMass = self.mass + otherBodyInertia.mass
+        return RigidBodyInertia(mass=sumMass,
+                                inertiaTensor = self.inertiaTensor + otherBodyInertia.inertiaTensor,
+                                com=1./sumMass*(self.mass*self.com + otherBodyInertia.mass*otherBodyInertia.com))
+
+    #**classFunction: += operator allows adding another inertia information with SAME local coordinate system and reference point!
+    #only inertias with same center of rotation can be added!
+    #**example: 
+    #J = InertiaSphere(2,0.1) 
+    #J += InertiaRodX(1,2)
+    def __iadd__(self, otherBodyInertia):
+        self = self + otherBodyInertia
+        return self
+        
+    #**classFunction: set RigidBodyInertia with scalar mass, 3x3 inertiaTensor (w.r.t.\ com) and center of mass com
+    #**input:
+    #  mass: mass of rigid body (dimensions need to be consistent, should be in SI-units)
+    #  inertiaTensorCOM: tensor given w.r.t.\ reference point, NOT w.r.t.\ center of mass!
+    #  com: center of mass relative to reference point, in same coordinate system as inertiaTensor
+    def SetWithCOMinertia(self, mass, inertiaTensorCOM, com):
+        if np.array(inertiaTensorCOM).shape != (3,3): #shape is a tuple
+            raise ValueError('RigidBodyInertia: inertiaTensorCOMmust have shape (3,3), but received '+str(np.array(inertiaTensorCOM).shape))
+        if np.array(com).shape != (3,): #shape is a tuple
+            raise ValueError('RigidBodyInertia: com must have 3 components, but received '+str(np.array(inertiaTensorCOM).shape))
+        self.mass = mass
+        self.com = np.array(com)
+        self.inertiaTensor = np.array(inertiaTensorCOM) + self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
+        
+        
+    #**classFunction: returns 3x3 inertia tensor with respect to chosen reference point (not necessarily COM)
+    def Inertia(self):
+        return self.inertiaTensor
+
+    #**classFunction: returns 3x3 inertia tensor with respect to COM
+    def InertiaCOM(self):
+        return self.inertiaTensor - self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
+
+    #**classFunction: returns center of mass (COM) w.r.t. chosen reference point
+    def COM(self):
+        return self.com
+
+    #**classFunction: returns mass
+    def Mass(self):
+        return self.mass
+
+    #**classFunction: returns a RigidBodyInertia with center of mass com shifted by vec; $\ra$ transforms the returned inertiaTensor to the new center of rotation
+    def Translated(self, vec):
+        #transform inertia to com=[0,0,0]
+        inertiaCOM = self.inertiaTensor - self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
+        try:
+            newCOM = self.com + vec
+        except:
+            raise ValueError("ERROR in RigidBodyInertia.Translated(vec): vec must be a vector with 3 components")
+        inertiaCOM += self.mass*np.dot(Skew(newCOM).transpose(),Skew(newCOM))
+        return RigidBodyInertia(mass=self.mass, 
+                                inertiaTensor=inertiaCOM,
+                                com=newCOM)
+
+    #**classFunction: returns a RigidBodyInertia rotated by 3x3 rotation matrix rot, such that for a given J, the new inertia tensor reads Jnew = rot*J*rot.T
+    #**notes: only allowed if COM=0 !
+    def Rotated(self, rot):
+        if NormL2(self.com) != 0:
+            print("ERROR: RigidBodyInertia.Rotated only allowed in case of com=0")
+            return 0
+        try:
+            inertia = np.dot(np.array(rot),np.dot(self.inertiaTensor,rot.transpose()))
+        except:
+            raise ValueError("ERROR in RigidBodyInertia.Rotated(rot): rot must be a 3x3 rotation matrix")
+        return RigidBodyInertia(mass=self.mass, 
+                                inertiaTensor=inertia,
+                                com=self.com)
+
+    #**classFunction: return rigid body inertia transformed by homogeneous transformation HT
+    def Transformed(self, HT):
+        A = HT2rotationMatrix(HT)
+        v = HT2translation(HT)
+        
+        inertiaCOM = self.inertiaTensor - self.mass*np.dot(Skew(self.com).transpose(),Skew(self.com))
+        inertiaCOM = A @ inertiaCOM @ A.T #tested with general rigid body and shifted reference point
+
+        newCOM = A @ self.com + v
+
+        inertiaCOM += self.mass*np.dot(Skew(newCOM).transpose(),Skew(newCOM))
+        return RigidBodyInertia(mass=self.mass, 
+                                inertiaTensor=inertiaCOM,
+                                com=newCOM)
+
+    #**classFunction: get vector with 6 inertia components (Jxx, Jyy, Jzz, Jyz, Jxz, Jxy) as needed in ObjectRigidBody
+    def GetInertia6D(self):
+        return InertiaTensor2Inertia6D(self.inertiaTensor)
+        # J = self.inertiaTensor
+        # return [J[0][0], J[1][1], J[2][2],  J[1][2], J[0][2], J[0][1]]
+
+
+    def __str__(self):
+        s = 'mass = ' + str(self.mass)
+        s += '\nCOM = ' + str(self.com)
+        s += '\ninertiaTensorAtOrigin = \n' + str(self.inertiaTensor)
+        s += '\ninertiaTensorAtCOM = \n' + str(self.InertiaCOM())
+        return s
+    def __repr__(self):
+        return str(self)
+
+
+#**class: create RigidBodyInertia with moment of inertia and mass of a cuboid with density and side lengths sideLengths along local axes 1, 2, 3; inertia w.r.t. center of mass, com=[0,0,0]
+#**example: 
+# InertiaCuboid(density=1000,sideLengths=[1,0.1,0.1])
+class InertiaCuboid(RigidBodyInertia):
+    #**classFunction: initialize inertia
+    def __init__(self, density, sideLengths):
+        L1=sideLengths[0]
+        L2=sideLengths[1]
+        L3=sideLengths[2]
+        newMass=density*L1*L2*L3
+        RigidBodyInertia.__init__(self, mass=newMass,
+                                  inertiaTensor=newMass/12.*np.diag([(L2**2 + L3**2),(L1**2 + L3**2),(L1**2 + L2**2)]),
+                                  com=np.zeros(3))
+
+#**class: create RigidBodyInertia with moment of inertia and mass of a rod with mass m and length L in local 1-direction (x-direction); inertia w.r.t. center of mass, com=[0,0,0]
+class InertiaRodX(RigidBodyInertia):
+    #**classFunction: initialize inertia with mass and length of rod
+    def __init__(self, mass, length):
+        RigidBodyInertia.__init__(self, mass=mass,
+                                  inertiaTensor=mass/12.*np.diag([0.,length**2,length**2]),
+                                  com=np.zeros(3))
+        
+#**class: create RigidBodyInertia with moment of inertia and mass of mass point with 'mass'; inertia w.r.t. center of mass, com=[0,0,0]
+class InertiaMassPoint(RigidBodyInertia):
+    #**classFunction: initialize inertia with mass of point
+    def __init__(self, mass):
+        RigidBodyInertia.__init__(self, mass=mass,
+                                  inertiaTensor=np.zeros([3,3]),
+                                  com=np.zeros(3))
+
+#**class: create RigidBodyInertia with moment of inertia and mass of sphere with mass and radius; inertia w.r.t. center of mass, com=[0,0,0]
+class InertiaSphere(RigidBodyInertia):
+    #**classFunction: initialize inertia with mass and radius of sphere
+    def __init__(self, mass, radius):
+        J = 2.*mass/5.*radius**2
+        RigidBodyInertia.__init__(self, mass=mass,
+                                  inertiaTensor=np.diag([J,J,J]),
+                                  com=np.zeros(3))
+        
+#**class: create RigidBodyInertia with moment of inertia and mass of hollow sphere with mass (concentrated at circumference) and radius; inertia w.r.t. center of mass, com=0
+class InertiaHollowSphere(RigidBodyInertia):
+    #**classFunction: initialize inertia with mass and (inner==outer) radius of hollow sphere
+    def __init__(self, mass, radius):
+        J = 2.*mass/3.*radius**2
+        RigidBodyInertia.__init__(self, mass=mass,
+                                  inertiaTensor=np.diag([J,J,J]),
+                                  com=np.zeros(3))
+
+#**class: create RigidBodyInertia with moment of inertia and mass of cylinder with density, length and outerRadius; axis defines the orientation of the cylinder axis (0=x-axis, 1=y-axis, 2=z-axis); for hollow cylinder use innerRadius != 0; inertia w.r.t. center of mass, com=[0,0,0]
+class InertiaCylinder(RigidBodyInertia):
+    #**classFunction: initialize inertia with density, length, outer radius, axis (0=x-axis, 1=y-axis, 2=z-axis) and optional inner radius (for hollow cylinder)
+    def __init__(self, density, length, outerRadius, axis, innerRadius=0):
+        m = density*length*np.pi*(outerRadius**2-innerRadius**2)
+        Jaxis = 0.5*m*(outerRadius**2+innerRadius**2)
+        Jtt = 1./12.*m*(3*(outerRadius**2+innerRadius**2)+length**2)
+
+        if axis==0:
+            RigidBodyInertia.__init__(self, mass=m,
+                                      inertiaTensor=np.diag([Jaxis,Jtt,Jtt]),
+                                      com=np.zeros(3))
+        elif axis==1:
+            RigidBodyInertia.__init__(self, mass=m,
+                                      inertiaTensor=np.diag([Jtt,Jaxis,Jtt]),
+                                      com=np.zeros(3))
+        elif axis==2:
+            RigidBodyInertia.__init__(self, mass=m,
+                                      inertiaTensor=np.diag([Jtt,Jtt,Jaxis]),
+                                      com=np.zeros(3))
+        else:
+            raise ValueError("InertiaCylinder: axis must be 0, 1 or 2!")
+        
+
+#**function: convert string into exudyn.NodeType; call e.g. with 'NodeType.RotationEulerParameters' or 'RotationEulerParameters'
+#**notes: function is not very fast, so should be avoided in time-critical situations
+def StrNodeType2NodeType(sNodeType):
+    s = str(sNodeType) #if called with type
+    s = s.replace('NodeType.','')
+    nodeTypes = exu.NodeType.__members__
+    if s in nodeTypes:
+        return nodeTypes[s]
+    else:
+        raise ValueError('StrNodeType2NodeType: no valid NodeType: "'+s+'"')
+    # for key in nodeTypes:
+    #     if s == str(key) or s == str(nodeTypes[key]):
+    #         return int(nodeTypes[key])
+    
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: get node item interface according to nodeType, using initialization with position, velocity, angularVelocity and rotationMatrix
+#**input:
+#   nodeType: a node type according to exudyn.NodeType, or a string of it, e.g., 'NodeType.RotationEulerParameters' (fastest, but additional algebraic constraint equation), 'NodeType.RotationRxyz' (Tait-Bryan angles, singularity for second angle at +/- 90 degrees), 'NodeType.RotationRotationVector' (used for Lie group integration)
+#   position: reference position as list or numpy array with 3 components (in global/world frame)
+#   velocity: initial translational velocity as list or numpy array with 3 components (in global/world frame)
+#   rotationMatrix: 3x3 list or numpy matrix to define reference rotation; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
+#   rotationParameters: reference rotation parameters; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
+#   angularVelocity: initial angular velocity as list or numpy array with 3 components (in global/world frame)
+#**output: returns list containing node number and body number: [nodeNumber, bodyNumber]
+def GetRigidBodyNode(nodeType, 
+                 position=[0,0,0], 
+                 velocity=[0,0,0], 
+                 rotationMatrix= [],
+                 rotationParameters = [],
+                 angularVelocity=[0,0,0]):
+
+    rotationMatrixNew = copy.copy(rotationMatrix)
+    if len(rotationMatrixNew) != 0 and len(rotationParameters) != 0:
+        raise ValueError('GetRigidBodyNode: either rotationMatrixNew or rotationParameters must empty!')
+    if len(rotationMatrixNew) == 0 and len(rotationParameters) == 0:
+        rotationMatrixNew=np.eye(3)
+
+    strNodeType = str(nodeType) #works both for nodeType and for strings (if exudyn not available)
+
+    nodeItem = []
+    if strNodeType == 'NodeType.RotationEulerParameters':
+        if len(rotationParameters) == 0:
+            ep0 = RotationMatrix2EulerParameters(rotationMatrixNew)
+        else:
+            ep0 = rotationParameters
+           
+        ep_t0 = AngularVelocity2EulerParameters_t(angularVelocity, ep0)
+        nodeItem = eii.NodeRigidBodyEP(referenceCoordinates=list(position)+list(ep0),
+                                   initialVelocities=list(velocity)+list(ep_t0))       
+    elif strNodeType == 'NodeType.RotationRxyz':
+        if len(rotationParameters) == 0:
+            rot0 = RotationMatrix2RotXYZ(rotationMatrixNew)
+        else:
+            rot0 = rotationParameters
+
+        rot_t0 = AngularVelocity2RotXYZ_t(angularVelocity, rot0)
+        nodeItem = eii.NodeRigidBodyRxyz(referenceCoordinates=list(position)+list(rot0),
+                                     initialVelocities=list(velocity)+list(rot_t0))
+    elif strNodeType == 'NodeType.RotationRotationVector':
+        if len(rotationParameters) == 0:
+            #raise ValueError('NodeType.RotationRotationVector not implemented!')
+            rot0 = RotationMatrix2RotationVector(rotationMatrixNew)
+        else:
+            rot0 = rotationParameters
+        
+        rotMatrix = RotationVector2RotationMatrix(rot0) #rotationMatrixNew needed!
+        angularVelocityLocal = np.dot(rotMatrix.transpose(),angularVelocity)
+            
+        nodeItem = eii.NodeRigidBodyRotVecLG(referenceCoordinates=list(position) + list(rot0), 
+                                         initialVelocities=list(velocity)+list(angularVelocityLocal))
+        
+    elif strNodeType == 'NodeType.LieGroupWithDirectUpdate':
+        if len(rotationParameters) == 0:
+            #raise ValueError('NodeType.RotationRotationVector not implemented!')
+            rot0 = RotationMatrix2RotationVector(rotationMatrixNew)
+        else:
+            rot0 = rotationParameters
+        
+        rotMatrix = RotationVector2RotationMatrix(rot0) #rotationMatrixNew needed!
+        angularVelocityLocal = np.dot(rotMatrix.transpose(),angularVelocity)
+            
+        nodeItem = eii.NodeRigidBodyRotVecLG(referenceCoordinates=list(position) + list(rot0), 
+                                         initialVelocities=list(velocity)+list(angularVelocityLocal))  
+        
+    # elif strNodeType == 'NodeType.LieGroupWithDataCoordinates':
+    #     if len(rotationParameters) == 0:
+    #         #raise ValueError('NodeType.RotationRotationVector not implemented!')
+    #         rot0 = RotationMatrix2RotationVector(rotationMatrixNew)
+    #     else:
+    #         rot0 = rotationParameters
+        
+    #     rotMatrix = RotationVector2RotationMatrix(rot0) #rotationMatrixNew needed!
+    #     angularVelocityLocal = np.dot(rotMatrix.transpose(),angularVelocity)
+            
+    #     nodeItem = eii.NodeRigidBodyRotVecDataLG(referenceCoordinates=list(position) + list(rot0),
+    #                                                     initialCoordinates=list(position)+list(rot0), #initializes data coordinates
+    #                                                     initialVelocities=list(velocity)+list(angularVelocityLocal))  
+        
+    else:
+        raise ValueError("GetRigidBodyNode: invalid node type:"+strNodeType)
+
+    return nodeItem
+
+#soon: DEPRECATED (use MainSystem function instead): 
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: adds a node (with str(exu.NodeType. ...)) and body for a given rigid body; all quantities (esp. velocity and angular velocity) are given in global coordinates!
+#**input:
+#   inertia: an inertia object as created by class RigidBodyInertia; containing mass, COM and inertia
+#   nodeType: a node type according to exudyn.NodeType, or a string of it, e.g., 'NodeType.RotationEulerParameters' (fastest, but additional algebraic constraint equation), 'NodeType.RotationRxyz' (Tait-Bryan angles, singularity for second angle at +/- 90 degrees), 'NodeType.RotationRotationVector' (used for Lie group integration)
+#   position: reference position as list or numpy array with 3 components (in global/world frame)
+#   velocity: initial translational velocity as list or numpy array with 3 components (in global/world frame)
+#   rotationMatrix: 3x3 list or numpy matrix to define reference rotation; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
+#   rotationParameters: reference rotation parameters; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[]) 
+#   angularVelocity: initial angular velocity as list or numpy array with 3 components (in global/world frame)
+#   gravity: if provided as list or numpy array with 3 components, it adds gravity force to the body at the COM, i.e., fAdd = m*gravity
+#   graphicsDataList: list of graphicsData objects to define appearance of body
+#**output: returns list containing node number and body number: [nodeNumber, bodyNumber]
+def AddRigidBody(mainSys, inertia, 
+                 nodeType = exu.NodeType.RotationEulerParameters, 
+                 position=[0,0,0], velocity=[0,0,0], 
+                 rotationMatrix= [],
+                 rotationParameters = [],
+                 angularVelocity=[0,0,0],
+                 gravity=[0,0,0],
+                 graphicsDataList=[]):
+
+    rotationMatrixNew = copy.copy(rotationMatrix)
+
+    if not isinstance(inertia, RigidBodyInertia): #do not use 'exu.rigidBodyUtilities.' in front, even not outside of module!
+        RaiseTypeError(where='AddRigidBody', argumentName='inertia', received = inertia, expectedType = ExpectedType.RigidBodyInertia, dim=None)
+    #MISSING: check for nodeType
+    if not IsVector(position, 3):
+        RaiseTypeError(where='AddRigidBody', argumentName='position', received = position, expectedType = ExpectedType.Vector, dim=3)
+    if not IsVector(velocity, 3):
+        RaiseTypeError(where='AddRigidBody', argumentName='velocity', received = velocity, expectedType = ExpectedType.Vector, dim=3)
+    if not IsVector(angularVelocity, 3):
+        RaiseTypeError(where='AddRigidBody', argumentName='angularVelocity', received = angularVelocity, expectedType = ExpectedType.Vector, dim=3)
+    if not IsVector(gravity, 3):
+        RaiseTypeError(where='AddRigidBody', argumentName='gravity', received = gravity, expectedType = ExpectedType.Vector, dim=3)
+
+    if type(graphicsDataList) != list:
+        raise ValueError('AddRigidBody: graphicsDataList must be a (possibly empty) list of dictionaries of graphics data!')
+
+
+    if not IsSquareMatrix(rotationMatrixNew):
+        raise ValueError('AddRigidBody: rotationMatrix must be a (possibly empty) list or numpy array!')
+    if not IsVector(rotationParameters):
+        raise ValueError('AddRigidBody: rotationParameters must be a (possibly empty) list or numpy array!')
+    
+    if len(rotationMatrixNew) != 0 and len(rotationParameters) != 0:
+        raise ValueError('AddRigidBody: either rotationMatrix or rotationParameters must be empty list or numpy array!')
+    if len(rotationMatrixNew) == 0 and len(rotationParameters) == 0:
+        rotationMatrixNew=np.eye(3)
+    else:
+        if len(rotationMatrixNew) == 0:
+            expectedSize = 3
+            if str(nodeType) == 'NodeType.RotationEulerParameters': 
+                expectedSize = 4
+            if not IsVector(rotationParameters, expectedSize):
+                RaiseTypeError(where='AddRigidBody', argumentName='rotationParameters', received = rotationParameters, expectedType = ExpectedType.Vector, dim=expectedSize)
+        else:
+            if not IsSquareMatrix(rotationMatrixNew, 3):
+                RaiseTypeError(where='AddRigidBody', argumentName='rotationMatrix', received = rotationMatrixNew, expectedType = ExpectedType.Matrix, dim=3)
+            
+            
+    nodeItem = GetRigidBodyNode(nodeType, position, velocity, rotationMatrixNew, rotationParameters, angularVelocity)
+    nodeNumber = mainSys.AddNode(nodeItem)
+    
+    bodyNumber = mainSys.AddObject(eii.ObjectRigidBody(physicsMass=inertia.mass, physicsInertia=inertia.GetInertia6D(), 
+                                                   physicsCenterOfMass=inertia.com,
+                                                   nodeNumber=nodeNumber, 
+                                                   visualization=eii.VObjectRigidBody(graphicsData=graphicsDataList)))
+    
+    if NormL2(gravity) != 0.:
+        markerNumber = mainSys.AddMarker(eii.MarkerBodyMass(bodyNumber=bodyNumber))
+        mainSys.AddLoad(eii.LoadMassProportional(markerNumber=markerNumber, loadVector=gravity))
+    
+    return [nodeNumber, bodyNumber]
+
+
+#**function: DEPRECATED (use MainSystem function instead): add revolute joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
+#**input:
+#  mbs: the MainSystem to which the joint and markers shall be added
+#  body0: a object number for body0, must be rigid body or ground object
+#  body1: a object number for body1, must be rigid body or ground object
+#  point: a 3D vector as list or np.array containing the global center point of the joint in reference configuration
+#  axis: a 3D vector as list or np.array containing the global rotation axis of the joint in reference configuration
+#  useGlobalFrame: if False, the point and axis vectors are defined in the local coordinate system of body0
+#**output: returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+def AddRevoluteJoint(mbs, body0, body1, point, axis, useGlobalFrame=True, 
+                     showJoint=True, axisRadius=0.1, axisLength=0.4):
+
+    #perform some checks:
+    if not IsValidObjectIndex(body0):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='body0', received = body0, expectedType = ExpectedType.ObjectIndex)
+    if not IsValidObjectIndex(body1):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='body1', received = body1, expectedType = ExpectedType.ObjectIndex)
+        
+    if not IsVector(point, 3):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='point', received = point, expectedType = ExpectedType.Vector, dim=3)
+    if not IsVector(axis, 3):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
+
+    if not IsValidBool(useGlobalFrame):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
+    if not IsValidBool(showJoint):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='showJoint', received = showJoint, expectedType = ExpectedType.Bool)
+
+    if not IsValidRealInt(axisRadius):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
+    if not IsValidRealInt(axisLength):
+        RaiseTypeError(where='AddRevoluteJoint', argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
+
+    p0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.Position,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference)
+    A0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.RotationMatrix,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
+    p1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.Position,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference)
+    A1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.RotationMatrix,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
+
+    if useGlobalFrame:
+        pJoint = point
+        vAxis = copy.copy(axis)
+    else: #transform into global coordinates, then everything works same
+        pJoint = A0 @ point + p0
+        vAxis = A0 @ axis
+
+    #compute joint frame (not unique, only rotation axis must coincide)
+    B = ComputeOrthonormalBasis(vAxis) #axis = x-axis
+    #interchange z and x axis (needs sign change, otherwise det(A)=-1)
+    AJ = np.eye(3)
+    AJ[:,0]=-B[:,2]
+    AJ[:,1]= B[:,1]
+    AJ[:,2]= B[:,0] #axis ==> rotation axis z for revolute joint ... 
+    #print(AJ)
+    
+    #compute joint position and axis in body0 / 1 coordinates:
+    pJ0 = A0.T @ (np.array(pJoint) - p0)
+    pJ1 = A1.T @ (np.array(pJoint) - p1)
+
+    #compute joint marker orientations:
+    MR0 = A0.T @ AJ  
+    MR1 = A1.T @ AJ  
+    
+    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body0, localPosition=pJ0))
+    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body1, localPosition=pJ1))
+    
+    oJoint = mbs.AddObject(eii.ObjectJointRevoluteZ(markerNumbers=[mBody0,mBody1],
+                                                rotationMarker0=MR0,
+                                                rotationMarker1=MR1,
+             visualization=eii.VRevoluteJointZ(show=showJoint, axisRadius=axisRadius, axisLength=axisLength) ))
+
+    return [oJoint, mBody0, mBody1]
+
+
+#**function: DEPRECATED (use MainSystem function instead): add prismatic joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
+#**input:
+#  mbs: the MainSystem to which the joint and markers shall be added
+#  body0: a object number for body0, must be rigid body or ground object
+#  body1: a object number for body1, must be rigid body or ground object
+#  point: a 3D vector as list or np.array containing the global center point of the joint in reference configuration
+#  axis: a 3D vector as list or np.array containing the global translation axis of the joint in reference configuration
+#  useGlobalFrame: if False, the point and axis vectors are defined in the local coordinate system of body0
+#**output: returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
+def AddPrismaticJoint(mbs, body0, body1, point, axis, useGlobalFrame=True, 
+                     showJoint=True, axisRadius=0.1, axisLength=0.4):
+        
+    if not IsValidObjectIndex(body0):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='body0', received = body0, expectedType = ExpectedType.ObjectIndex)
+    if not IsValidObjectIndex(body1):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='body1', received = body1, expectedType = ExpectedType.ObjectIndex)
+        
+    if not IsVector(point, 3):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='point', received = point, expectedType = ExpectedType.Vector, dim=3)
+    if not IsVector(axis, 3):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='axis', received = axis, expectedType = ExpectedType.Vector, dim=3)
+
+    if not IsValidBool(useGlobalFrame):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='useGlobalFrame', received = useGlobalFrame, expectedType = ExpectedType.Bool)
+    if not IsValidBool(showJoint):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='showJoint', received = showJoint, expectedType = ExpectedType.Bool)
+
+    if not IsValidRealInt(axisRadius):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='axisRadius', received = axisRadius, expectedType = ExpectedType.Real)
+    if not IsValidRealInt(axisLength):
+        RaiseTypeError(where='AddPrismaticJoint', argumentName='axisLength', received = axisLength, expectedType = ExpectedType.Real)
+
+    p0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.Position,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference)
+    A0 = mbs.GetObjectOutputBody(body0,exu.OutputVariableType.RotationMatrix,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
+    p1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.Position,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference)
+    A1 = mbs.GetObjectOutputBody(body1,exu.OutputVariableType.RotationMatrix,
+                                 localPosition=[0,0,0],
+                                 configuration=exu.ConfigurationType.Reference).reshape((3,3))
+
+    if useGlobalFrame:
+        pJoint = point
+        vAxis = copy.copy(axis)
+    else: #transform into global coordinates, then everything works same
+        pJoint = A0 @ point + p0
+        vAxis = A0 @ axis
+
+    #compute joint frame (not unique, only rotation axis must coincide)
+    AJ = ComputeOrthonormalBasis(vAxis) #axis = x-axis
+    
+    #compute joint position and axis in body0 / 1 coordinates:
+    pJ0 = A0.T @ (np.array(pJoint) - p0)
+    pJ1 = A1.T @ (np.array(pJoint) - p1)
+
+    #compute joint marker orientations:
+    MR0 = A0.T @ AJ  
+    MR1 = A1.T @ AJ  
+    
+    mBody0 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body0, localPosition=pJ0))
+    mBody1 = mbs.AddMarker(eii.MarkerBodyRigid(bodyNumber=body1, localPosition=pJ1))
+    
+    oJoint = mbs.AddObject(eii.ObjectJointPrismaticX(markerNumbers=[mBody0,mBody1],
+                                                rotationMarker0=MR0,
+                                                rotationMarker1=MR1,
+             visualization=eii.VPrismaticJointX(show=showJoint, axisRadius=axisRadius, axisLength=axisLength) ))
+
+    return [oJoint, mBody0, mBody1]
+
+
+
+
```

## exudyn/signalProcessing.py

 * *Ordering differences only*

```diff
@@ -1,303 +1,303 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  The signal library supports processing of signals for import (e.g. measurement data)
-#           and for filtering result data.
-#
-# Authors:  Johannes Gerstmayr, Stefan Holzinger 
-# Date:     2020-12-10
-# Notes:    This module is still under construction and should be used with care!
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-from exudyn.advancedUtilities import IsListOrArray
-import copy
-
-#**function: filter output of sensors (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal
-#**input:
-#   signal: numpy array (2D array with column-wise storage of signals, as exported by EXUDYN position, displacement, etc. sensors); first column = time, other columns = signals to operate on; note that it is assumed, that time devided in almost constant steps!
-#   derivative: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
-#   polyOrder: order of polynomial for interpolation filtering
-#   filterWindow: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
-#   centralDifferentiate: if True, it uses a central differentiation for first order, unfiltered derivatives; leads to less phase shift of signal!
-#**output: numpy array containing same columns, but with filtered signal and according derivatives
-def FilterSensorOutput(signal, filterWindow=5, polyOrder=3, derivative=0, centralDifferentiate=True):
-    data = np.copy(signal)
-    if len(data.shape) < 2:
-        raise ValueError("FilterSensorOutput: signal must have 2 dimensions (rows and columns)")
-    nColumns = data.shape[1]
-    if nColumns < 2:
-        raise ValueError("FilterSensorOutput: signal must have at least two columns: first column for time and second column for data")
-    
-    #first column is time!
-    t = signal[:,0]
-    #symmetrically extend step sizes:
-    derT0 = np.diff(t)
-    derT1 = np.diff(t)
-    derT0 = np.append(derT0,derT0[-1])
-    derT1 = np.append(derT1[0], derT1)
-    # print("derT0=",derT0)
-    # print("derT1=",derT1)
-    for i in range(nColumns-1):
-        x = signal[:,i+1]
-        if filterWindow == 0 and derivative != 0: #regular mode
-            if derivative == 1:
-                der = np.diff(x,n=derivative, append=x[-1])/derT0 #append duplicate of last entry
-                if centralDifferentiate:
-                    der = 0.5*(der + np.diff(x,n=derivative, prepend=x[0])/derT1)
-            elif derivative == 2:
-                der = np.diff(x,n=derivative, prepend=x[0], append=x[-1]) #append duplicate of last entry
-                der = der/derT0**2
-                if len(x)>2:
-                    der[0] = der[1] #boundary values are extended
-                    der[-1] = der[-2] #boundary values are extended
-            else:
-                raise ValueError("FilterSensorOutput: unfiltered signals only supported up to 2nd derivatives")
-            data[:,i+1] = der
-        elif filterWindow == 0 and derivative == 0:
-            print("WARNING: FilterSensorOutput: no processing")
-        else:
-            if filterWindow%2 != 1:
-                raise ValueError("FilterSensorOutput: filterWindow must be ODD integer and >= 1")
-                
-            from scipy.signal import savgol_filter
-            y = savgol_filter(x, window_length=filterWindow, polyorder=polyOrder, deriv=derivative)
-            if derivative > 0:
-                y = y/derT0**derivative #for n-th derivative, needs to divide by stepsize^n
-            data[:,i+1] = y
-            
-    return data
-
-#**function: filter 1D signal (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal
-#**input:
-#   signal: 1D numpy array 
-#   samplingRate: (time increment) of signal values, needed for derivatives
-#   derivative: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
-#   polyOrder: order of polynomial for interpolation filtering
-#   filterWindow: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
-#   centralDifferentiate: if True, it uses a central differentiation for first order, unfiltered derivatives; leads to less phase shift of signal!
-#**output: numpy array containing same columns, but with filtered signal and according derivatives
-def FilterSignal(signal, samplingRate=-1, filterWindow=5, polyOrder=3, derivative=0, centralDifferentiate=True):
-    data = np.copy(signal)
-    
-    dt = samplingRate
-    x = signal
-
-    if filterWindow == 0 and derivative != 0: #regular mode
-        if derivative == 1:
-            der = np.diff(x,n=derivative, append=x[-1])/dt #append duplicate of last entry
-            if centralDifferentiate:
-                der = 0.5*(der + np.diff(x,n=derivative, prepend=x[0])/dt)
-        elif derivative == 2:
-            der = np.diff(x,n=derivative, prepend=x[0], append=x[-1]) #append duplicate of last entry
-            der = der/dt**2
-            if len(x)>2:
-                der[0] = der[1] #boundary values are extended
-                der[-1] = der[-2] #boundary values are extended
-        else:
-            raise ValueError("FilterSignal: unfiltered signals only supported up to 2nd derivatives")
-        data = der
-    elif filterWindow == 0 and derivative == 0:
-        print("WARNING: FilterSignal: no processing")
-    else:
-        if filterWindow%2 != 1:
-            raise ValueError("FilterSignal: filterWindow must be ODD integer and >= 1")
-            
-        from scipy.signal import savgol_filter
-        y = savgol_filter(x, window_length=filterWindow, polyorder=polyOrder, deriv=derivative)
-        if derivative > 0:
-            y = y/(dt**derivative) #for n-th derivative, needs to divide by stepsize^n
-        data = y
-            
-    return data
-
-
-#**function: computes fast-fourier-transform (FFT) resulting in frequency, magnitude and phase of signal data using numpy.fft of numpy
-#**author: Stefan Holzinger
-#**date: 02.04.2020
-#**input: 
-#   time ... time vector in SECONDS in numpy format, having constant sampling rate (not checked!)
-#   data ... data vector in numpy format
-#**output:
-#   frequency ... frequency vector (Hz, if time is in SECONDS)   
-#   magnitude ... magnitude vector
-#   phase     ... phase vector (in radiant)
-def ComputeFFT(time, data):
-    from math import floor
-
-    # compute sample time
-    sampleTime = time[1] - time[0]
-    
-    # compute FFT 
-    Y = np.fft.fftn(data)
-    #Y = np.fft.fft(data)
-    
-    # number of values
-    numberOfDataPoints     = len(data)  
-    halfNumberOfDataPoints = floor(numberOfDataPoints/2)
-    
-    # generate frequency vector in (Hz)
-    frequency = 1./(numberOfDataPoints*sampleTime)*np.linspace(0, halfNumberOfDataPoints+1, halfNumberOfDataPoints+1, endpoint=False)
-    
-    # compute amplitude vector 
-    magnitude = 2.*abs( Y[0:halfNumberOfDataPoints+1] ) / numberOfDataPoints
-    
-    # compute phase vector in (rad)
-    phase = np.angle( Y[0:halfNumberOfDataPoints+1] )
-    
-    return [frequency, magnitude, phase]      
-
-
-
-
-#**function: Interpolate signal having time values with constant sampling rate in timeArray and according data in dataArray
-#**input: 
-#  time: time at which the data should be evaluated
-#  dataArray: 1D numpy array containing data values to be interpolated [alternatively: 2D numpy array, rows containg the data of the according time point; use dataArrayColumnIndex to specify the column of requested data]
-#  timeArray: 1D numpy array containing time values with CONSTANT SAMPLING RATE to be interpolated [alternatively: 2D numpy array, rows containg the time and data of the according time point; use timeArrayColumnIndex to specify the column representing time]; if timeArray is empty list [], dataArray is used instead!
-#  rangeWarning: print warning if resulting index gets out of range
-#  dataArrayColumnIndex: in case of 2D arrays, this represents the column of the requested data
-#  timeArrayColumnIndex: in case of 2D arrays, this represents the column of time values
-#  tolerance: this tolerance is used to check, if the timeArray has equidistant interpolation and if the found indices are correct; use e.g. 1e10 in order to ignore this tolerance
-#**notes: for interpolation of data WITHOUT constant data rate, use numpy.interp(time, timeArray, dataArray) in case that timeArray and dataArray are 1D arrays
-#**output: interpolated value
-def GetInterpolatedSignalValue(time, dataArray, timeArray=[], dataArrayIndex = -1, timeArrayIndex = -1, rangeWarning=True, tolerance=1e-6):
-
-    timeArrayNew = timeArray #as this should be fast, we avoid copy here; should be safe, as timeArrayNew is not modified
-    if IsListOrArray(timeArrayNew) and len(timeArrayNew) == 0:
-        timeArrayNew=dataArray
-    if dataArray.ndim != 1 and dataArrayIndex == -1:
-        raise ValueError('GetInterpolatedSignalValue: in case of 2D dataArray, dataArrayIndex must be provided!')
-    if timeArrayNew.ndim != 1 and timeArrayIndex == -1:
-        raise ValueError('GetInterpolatedSignalValue: in case of 2D timeArray, timeArrayIndex must be provided!')
-
-    t0 = -1 #time of first value
-    tEnd = -1 #time of last value
-    if len(dataArray) > 1 and len(timeArrayNew) > 1:
-        if timeArrayIndex == -1: #1D array
-            t0 = timeArrayNew[0]
-            tEnd = timeArrayNew[-1]
-            dt = timeArrayNew[1] - t0 #sampling rate
-        else: #2D array
-            t0 = timeArrayNew[0,timeArrayIndex]
-            tEnd = timeArrayNew[-1,timeArrayIndex]
-            dt = timeArrayNew[1,timeArrayIndex] - t0
-            
-        if dt == 0.:
-            raise ValueError('GetInterpolatedSignalValue: sample rate is zero!')
-    else:
-        raise ValueError('GetInterpolatedSignalValue: dataArray or timeArray does not contain sufficient rows!')
-
-    
-    index = int((time-t0) / dt)
-    #print('index=', index, ', t0=', t0, ', dt=', dt)
-    if (time-t0) < 0.: #no interpolation
-        index = 0
-        if rangeWarning:
-            print('Warning: GetInterpolatedSignalValue: index returned smaller than 0; using 0 instead')
-        if dataArrayIndex == -1: #1D array
-            value = dataArray[0]
-        else: #2D array
-            value = dataArray[0,dataArrayIndex]
-    elif index >= len(dataArray)-1: #no interpolation any more
-        if time > tEnd and rangeWarning:
-            print('Warning: GetInterpolatedSignalValue: time larger than available time data; using last row of dataArray instead')
-        index = len(dataArray)-1
-        if dataArrayIndex == -1: #1D array
-            value = dataArray[-1]
-        else: #2D array
-            value = dataArray[-1,dataArrayIndex]
-    else:
-        
-        #interpolate
-        tA = dt*index + t0
-        tB = tA+dt 
-        #check if time index is correct:
-        if timeArrayIndex == -1: #1D array
-            if abs(tA-timeArrayNew[index]) > tolerance or abs(tB-timeArrayNew[index+1]) > tolerance :
-                print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
-        else: #2D array
-            if (abs(tA-timeArrayNew[index,timeArrayIndex]) > tolerance or 
-                abs(tB-timeArrayNew[index+1,timeArrayIndex]) > tolerance):
-                print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
-            
-
-        if dataArrayIndex == -1: #1D array
-            valueA = dataArray[index]
-            valueB = dataArray[index+1]
-        else: #2D array
-            valueA = dataArray[index,dataArrayIndex]
-            valueB = dataArray[index+1,dataArrayIndex]
-
-        #print('tA=', tA, ', tB=', tB, ', valueA=', valueA, ', valueB=', valueB)
-        value = valueA*(tB-time)/dt + valueB*(time-tA)/dt
-
-    return value
-
-
-
-#simple tests:
-if __name__ == '__main__':
-    
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #GetInterpolatedSignalValue
-    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #create 1D signal
-    t = np.linspace(1,10,40)
-    x = np.sin(t)
-    
-    #coarsen
-    t2 = np.linspace(0,11,15)
-    x2 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t2])
-
-    #refine
-    t3 = np.linspace(0,11,90)
-    x3 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t3])
-    
-    from exudyn.plot import PlotSensor
-    PlotSensor(None, sensorNumbers=[np.vstack((t,x)).T, np.vstack((t2,x2)).T, np.vstack((t3,x3)).T], closeAll=True, title='1D array')
-    
-    #create 2D signal
-    t = np.linspace(1,10,40)
-    x = np.sin(t)
-    y = np.cos(t)
-    data = np.vstack((t,np.vstack((x,y)))).T
-    
-    #coarsen, data is 2D
-    t2 = np.linspace(0,11,15)
-    x2 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, dataArrayIndex=1, timeArrayIndex=0, rangeWarning=False) for ti in t2])
-
-    #refine, data is 2D
-    t3 = np.linspace(0,11,90)
-    x3 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, dataArrayIndex=2, timeArrayIndex=0, rangeWarning=False) for ti in t3])
-
-    #refine, use 'different' time and data arrays; both arrays are 2D arrays
-    t4 = np.linspace(0,11,45)
-    x4 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, timeArray=data, dataArrayIndex=1, timeArrayIndex=0, rangeWarning=False) for ti in t4])
-    
-    #refine, use different time and data arrays; data is 2D, time is 1D
-    t5 = np.linspace(0,11,45)
-    x5 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, timeArray=t, dataArrayIndex=2, rangeWarning=False) for ti in t5])
-
-    #refine, use different time and data arrays; data is 1D, time is 2D
-    t6 = np.linspace(0,11,45)
-    x6 = np.array([GetInterpolatedSignalValue(ti, dataArray=y, timeArray=data, timeArrayIndex=0, rangeWarning=False) for ti in t6])
-    
-    PlotSensor(None, sensorNumbers=[np.vstack((t,x)).T, np.vstack((t,y)).T, 
-                                    np.vstack((t2,x2)).T, np.vstack((t3,x3)).T, np.vstack((t4,x4)).T, np.vstack((t5,x5)).T, np.vstack((t6,x6)).T
-                                    ], newFigure=True, title='2D array')
-    
-    import time
-    ts = -time.time()    
-    t2 = np.linspace(0,11,500000)
-    x2 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t2])
-
-    #about 1.4 seconds on 3GHz i7 processor
-    print('5e5 x GetInterpolatedSignalValue takes', time.time()+ts, 'seconds')
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  The signal library supports processing of signals for import (e.g. measurement data)
+#           and for filtering result data.
+#
+# Authors:  Johannes Gerstmayr, Stefan Holzinger 
+# Date:     2020-12-10
+# Notes:    This module is still under construction and should be used with care!
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+from exudyn.advancedUtilities import IsListOrArray
+import copy
+
+#**function: filter output of sensors (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal
+#**input:
+#   signal: numpy array (2D array with column-wise storage of signals, as exported by EXUDYN position, displacement, etc. sensors); first column = time, other columns = signals to operate on; note that it is assumed, that time devided in almost constant steps!
+#   derivative: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
+#   polyOrder: order of polynomial for interpolation filtering
+#   filterWindow: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
+#   centralDifferentiate: if True, it uses a central differentiation for first order, unfiltered derivatives; leads to less phase shift of signal!
+#**output: numpy array containing same columns, but with filtered signal and according derivatives
+def FilterSensorOutput(signal, filterWindow=5, polyOrder=3, derivative=0, centralDifferentiate=True):
+    data = np.copy(signal)
+    if len(data.shape) < 2:
+        raise ValueError("FilterSensorOutput: signal must have 2 dimensions (rows and columns)")
+    nColumns = data.shape[1]
+    if nColumns < 2:
+        raise ValueError("FilterSensorOutput: signal must have at least two columns: first column for time and second column for data")
+    
+    #first column is time!
+    t = signal[:,0]
+    #symmetrically extend step sizes:
+    derT0 = np.diff(t)
+    derT1 = np.diff(t)
+    derT0 = np.append(derT0,derT0[-1])
+    derT1 = np.append(derT1[0], derT1)
+    # print("derT0=",derT0)
+    # print("derT1=",derT1)
+    for i in range(nColumns-1):
+        x = signal[:,i+1]
+        if filterWindow == 0 and derivative != 0: #regular mode
+            if derivative == 1:
+                der = np.diff(x,n=derivative, append=x[-1])/derT0 #append duplicate of last entry
+                if centralDifferentiate:
+                    der = 0.5*(der + np.diff(x,n=derivative, prepend=x[0])/derT1)
+            elif derivative == 2:
+                der = np.diff(x,n=derivative, prepend=x[0], append=x[-1]) #append duplicate of last entry
+                der = der/derT0**2
+                if len(x)>2:
+                    der[0] = der[1] #boundary values are extended
+                    der[-1] = der[-2] #boundary values are extended
+            else:
+                raise ValueError("FilterSensorOutput: unfiltered signals only supported up to 2nd derivatives")
+            data[:,i+1] = der
+        elif filterWindow == 0 and derivative == 0:
+            print("WARNING: FilterSensorOutput: no processing")
+        else:
+            if filterWindow%2 != 1:
+                raise ValueError("FilterSensorOutput: filterWindow must be ODD integer and >= 1")
+                
+            from scipy.signal import savgol_filter
+            y = savgol_filter(x, window_length=filterWindow, polyorder=polyOrder, deriv=derivative)
+            if derivative > 0:
+                y = y/derT0**derivative #for n-th derivative, needs to divide by stepsize^n
+            data[:,i+1] = y
+            
+    return data
+
+#**function: filter 1D signal (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal
+#**input:
+#   signal: 1D numpy array 
+#   samplingRate: (time increment) of signal values, needed for derivatives
+#   derivative: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
+#   polyOrder: order of polynomial for interpolation filtering
+#   filterWindow: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
+#   centralDifferentiate: if True, it uses a central differentiation for first order, unfiltered derivatives; leads to less phase shift of signal!
+#**output: numpy array containing same columns, but with filtered signal and according derivatives
+def FilterSignal(signal, samplingRate=-1, filterWindow=5, polyOrder=3, derivative=0, centralDifferentiate=True):
+    data = np.copy(signal)
+    
+    dt = samplingRate
+    x = signal
+
+    if filterWindow == 0 and derivative != 0: #regular mode
+        if derivative == 1:
+            der = np.diff(x,n=derivative, append=x[-1])/dt #append duplicate of last entry
+            if centralDifferentiate:
+                der = 0.5*(der + np.diff(x,n=derivative, prepend=x[0])/dt)
+        elif derivative == 2:
+            der = np.diff(x,n=derivative, prepend=x[0], append=x[-1]) #append duplicate of last entry
+            der = der/dt**2
+            if len(x)>2:
+                der[0] = der[1] #boundary values are extended
+                der[-1] = der[-2] #boundary values are extended
+        else:
+            raise ValueError("FilterSignal: unfiltered signals only supported up to 2nd derivatives")
+        data = der
+    elif filterWindow == 0 and derivative == 0:
+        print("WARNING: FilterSignal: no processing")
+    else:
+        if filterWindow%2 != 1:
+            raise ValueError("FilterSignal: filterWindow must be ODD integer and >= 1")
+            
+        from scipy.signal import savgol_filter
+        y = savgol_filter(x, window_length=filterWindow, polyorder=polyOrder, deriv=derivative)
+        if derivative > 0:
+            y = y/(dt**derivative) #for n-th derivative, needs to divide by stepsize^n
+        data = y
+            
+    return data
+
+
+#**function: computes fast-fourier-transform (FFT) resulting in frequency, magnitude and phase of signal data using numpy.fft of numpy
+#**author: Stefan Holzinger
+#**date: 02.04.2020
+#**input: 
+#   time ... time vector in SECONDS in numpy format, having constant sampling rate (not checked!)
+#   data ... data vector in numpy format
+#**output:
+#   frequency ... frequency vector (Hz, if time is in SECONDS)   
+#   magnitude ... magnitude vector
+#   phase     ... phase vector (in radiant)
+def ComputeFFT(time, data):
+    from math import floor
+
+    # compute sample time
+    sampleTime = time[1] - time[0]
+    
+    # compute FFT 
+    Y = np.fft.fftn(data)
+    #Y = np.fft.fft(data)
+    
+    # number of values
+    numberOfDataPoints     = len(data)  
+    halfNumberOfDataPoints = floor(numberOfDataPoints/2)
+    
+    # generate frequency vector in (Hz)
+    frequency = 1./(numberOfDataPoints*sampleTime)*np.linspace(0, halfNumberOfDataPoints+1, halfNumberOfDataPoints+1, endpoint=False)
+    
+    # compute amplitude vector 
+    magnitude = 2.*abs( Y[0:halfNumberOfDataPoints+1] ) / numberOfDataPoints
+    
+    # compute phase vector in (rad)
+    phase = np.angle( Y[0:halfNumberOfDataPoints+1] )
+    
+    return [frequency, magnitude, phase]      
+
+
+
+
+#**function: Interpolate signal having time values with constant sampling rate in timeArray and according data in dataArray
+#**input: 
+#  time: time at which the data should be evaluated
+#  dataArray: 1D numpy array containing data values to be interpolated [alternatively: 2D numpy array, rows containg the data of the according time point; use dataArrayColumnIndex to specify the column of requested data]
+#  timeArray: 1D numpy array containing time values with CONSTANT SAMPLING RATE to be interpolated [alternatively: 2D numpy array, rows containg the time and data of the according time point; use timeArrayColumnIndex to specify the column representing time]; if timeArray is empty list [], dataArray is used instead!
+#  rangeWarning: print warning if resulting index gets out of range
+#  dataArrayColumnIndex: in case of 2D arrays, this represents the column of the requested data
+#  timeArrayColumnIndex: in case of 2D arrays, this represents the column of time values
+#  tolerance: this tolerance is used to check, if the timeArray has equidistant interpolation and if the found indices are correct; use e.g. 1e10 in order to ignore this tolerance
+#**notes: for interpolation of data WITHOUT constant data rate, use numpy.interp(time, timeArray, dataArray) in case that timeArray and dataArray are 1D arrays
+#**output: interpolated value
+def GetInterpolatedSignalValue(time, dataArray, timeArray=[], dataArrayIndex = -1, timeArrayIndex = -1, rangeWarning=True, tolerance=1e-6):
+
+    timeArrayNew = timeArray #as this should be fast, we avoid copy here; should be safe, as timeArrayNew is not modified
+    if IsListOrArray(timeArrayNew) and len(timeArrayNew) == 0:
+        timeArrayNew=dataArray
+    if dataArray.ndim != 1 and dataArrayIndex == -1:
+        raise ValueError('GetInterpolatedSignalValue: in case of 2D dataArray, dataArrayIndex must be provided!')
+    if timeArrayNew.ndim != 1 and timeArrayIndex == -1:
+        raise ValueError('GetInterpolatedSignalValue: in case of 2D timeArray, timeArrayIndex must be provided!')
+
+    t0 = -1 #time of first value
+    tEnd = -1 #time of last value
+    if len(dataArray) > 1 and len(timeArrayNew) > 1:
+        if timeArrayIndex == -1: #1D array
+            t0 = timeArrayNew[0]
+            tEnd = timeArrayNew[-1]
+            dt = timeArrayNew[1] - t0 #sampling rate
+        else: #2D array
+            t0 = timeArrayNew[0,timeArrayIndex]
+            tEnd = timeArrayNew[-1,timeArrayIndex]
+            dt = timeArrayNew[1,timeArrayIndex] - t0
+            
+        if dt == 0.:
+            raise ValueError('GetInterpolatedSignalValue: sample rate is zero!')
+    else:
+        raise ValueError('GetInterpolatedSignalValue: dataArray or timeArray does not contain sufficient rows!')
+
+    
+    index = int((time-t0) / dt)
+    #print('index=', index, ', t0=', t0, ', dt=', dt)
+    if (time-t0) < 0.: #no interpolation
+        index = 0
+        if rangeWarning:
+            print('Warning: GetInterpolatedSignalValue: index returned smaller than 0; using 0 instead')
+        if dataArrayIndex == -1: #1D array
+            value = dataArray[0]
+        else: #2D array
+            value = dataArray[0,dataArrayIndex]
+    elif index >= len(dataArray)-1: #no interpolation any more
+        if time > tEnd and rangeWarning:
+            print('Warning: GetInterpolatedSignalValue: time larger than available time data; using last row of dataArray instead')
+        index = len(dataArray)-1
+        if dataArrayIndex == -1: #1D array
+            value = dataArray[-1]
+        else: #2D array
+            value = dataArray[-1,dataArrayIndex]
+    else:
+        
+        #interpolate
+        tA = dt*index + t0
+        tB = tA+dt 
+        #check if time index is correct:
+        if timeArrayIndex == -1: #1D array
+            if abs(tA-timeArrayNew[index]) > tolerance or abs(tB-timeArrayNew[index+1]) > tolerance :
+                print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
+        else: #2D array
+            if (abs(tA-timeArrayNew[index,timeArrayIndex]) > tolerance or 
+                abs(tB-timeArrayNew[index+1,timeArrayIndex]) > tolerance):
+                print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
+            
+
+        if dataArrayIndex == -1: #1D array
+            valueA = dataArray[index]
+            valueB = dataArray[index+1]
+        else: #2D array
+            valueA = dataArray[index,dataArrayIndex]
+            valueB = dataArray[index+1,dataArrayIndex]
+
+        #print('tA=', tA, ', tB=', tB, ', valueA=', valueA, ', valueB=', valueB)
+        value = valueA*(tB-time)/dt + valueB*(time-tA)/dt
+
+    return value
+
+
+
+#simple tests:
+if __name__ == '__main__':
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #GetInterpolatedSignalValue
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #create 1D signal
+    t = np.linspace(1,10,40)
+    x = np.sin(t)
+    
+    #coarsen
+    t2 = np.linspace(0,11,15)
+    x2 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t2])
+
+    #refine
+    t3 = np.linspace(0,11,90)
+    x3 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t3])
+    
+    from exudyn.plot import PlotSensor
+    PlotSensor(None, sensorNumbers=[np.vstack((t,x)).T, np.vstack((t2,x2)).T, np.vstack((t3,x3)).T], closeAll=True, title='1D array')
+    
+    #create 2D signal
+    t = np.linspace(1,10,40)
+    x = np.sin(t)
+    y = np.cos(t)
+    data = np.vstack((t,np.vstack((x,y)))).T
+    
+    #coarsen, data is 2D
+    t2 = np.linspace(0,11,15)
+    x2 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, dataArrayIndex=1, timeArrayIndex=0, rangeWarning=False) for ti in t2])
+
+    #refine, data is 2D
+    t3 = np.linspace(0,11,90)
+    x3 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, dataArrayIndex=2, timeArrayIndex=0, rangeWarning=False) for ti in t3])
+
+    #refine, use 'different' time and data arrays; both arrays are 2D arrays
+    t4 = np.linspace(0,11,45)
+    x4 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, timeArray=data, dataArrayIndex=1, timeArrayIndex=0, rangeWarning=False) for ti in t4])
+    
+    #refine, use different time and data arrays; data is 2D, time is 1D
+    t5 = np.linspace(0,11,45)
+    x5 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, timeArray=t, dataArrayIndex=2, rangeWarning=False) for ti in t5])
+
+    #refine, use different time and data arrays; data is 1D, time is 2D
+    t6 = np.linspace(0,11,45)
+    x6 = np.array([GetInterpolatedSignalValue(ti, dataArray=y, timeArray=data, timeArrayIndex=0, rangeWarning=False) for ti in t6])
+    
+    PlotSensor(None, sensorNumbers=[np.vstack((t,x)).T, np.vstack((t,y)).T, 
+                                    np.vstack((t2,x2)).T, np.vstack((t3,x3)).T, np.vstack((t4,x4)).T, np.vstack((t5,x5)).T, np.vstack((t6,x6)).T
+                                    ], newFigure=True, title='2D array')
+    
+    import time
+    ts = -time.time()    
+    t2 = np.linspace(0,11,500000)
+    x2 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t2])
+
+    #about 1.4 seconds on 3GHz i7 processor
+    print('5e5 x GetInterpolatedSignalValue takes', time.time()+ts, 'seconds')
+
+
+
```

## exudyn/solver.py

```diff
@@ -1,787 +1,826 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  The solver module provides interfaces to static, dynamic and eigenvalue solvers.
-#           Most of the solvers are implemented inside the C++ core.
-#
-# Author:   Johannes Gerstmayr 
-# Date:     2020-12-02
-# Notes:    Solver functions are included directly in exudyn and can be used with exu.SolveStatic(...)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#import is necessary, otherwise the solvers cannot be called
-import numpy as np
-import exudyn
-
-solverCheckMemoryAllocations = True
-solverCheckMemoryAllocationsThreshold = 100000 #treshold for warning on too many news during solving
-
-#**function: (internal) helper function for unique error and helper messages
-def SolverErrorMessage(solver, mbs, isStatic=False, 
-                       showCausingObjects=True, showCausingNodes=True, showHints=True):
-    s = ''
-    s += '\n******************************\n'
-    if isStatic:
-        s += 'STATIC SOLVER FAILED:\n'
-    else:        
-        s += 'DYNAMIC SOLVER FAILED:\n'
-    #print(solver.conv)
-    massMatrixNotInvertible = solver.conv.massMatrixNotInvertible
-    linearSolverFailed = solver.conv.linearSolverFailed
-    causingRow = solver.conv.linearSolverCausingRow
-    newtonFailed = solver.conv.stepReductionFailed or solver.conv.newtonSolutionDiverged
-
-    if showHints:
-        s += '  POSSIBLE REASONS for solver abort:\n'
-        if linearSolverFailed:
-            s += '  * unused node or no equations supplied for node\n'
-            s += '  * redundant definition of constraints\n'
-        if (solver.conv.stepReductionFailed and (not solver.conv.newtonSolutionDiverged)
-            and solver.conv.residual < 1e-3): #indicates that solution is not very wrong
-            s += '  * your tolerances (in newton) may be too tight, see solutions below\n'
-            
-        s += '  * inconsistent or inappropriate initial conditions\n'
-        s += '  * system is nearly singular due to high (penalty) stiffness or singularities in your system\n'
-        if isStatic:
-            s += '  * static problem has unconstrained coordinates (that can move freely)\n'
-            if newtonFailed:
-                s += '  * the system is very nonlinear and thus requires smaller (load) steps\n'
-        else:
-            if newtonFailed:
-                s += '  * too large step size, which prevents Newton to converge\n'
-            if linearSolverFailed:
-                s += '  * singular mass matrix (no mass/inertia assigned?)\n'
-
-        s += '  -------------------\n'
-        s += '  POSSIBLE SOLUTIONS:\n'
-        s += '  * check your Python model!\n'
-        s += '  * check the causing nodes, objects, connectors, etc.\n'
-        s += '  * check your nodes, objects, connectors, and markers\n'
-        s += '  * change solver and solver settings (e.g. change index 3/index 2 solver)\n'
-        s += '  * try linearSolverSettings.ignoreSingularJacobian and EigenDense solver type in case of redundant constraints\n'
-        s += '  * for small systems (<1000 coordinates), try mbs. ComputeSystemDegreeOfFreedom() to check system\n'
-        s += '  * step-by-step remove constraints, until you find the causing item\n'
-        s += '  * step-by-step remove objects and nodes, until you find the causing item\n'
-        s += '  * check joint axes (using visualization), which may be incompatible\n'
-        s += '  * use lower (penalty) stiffness factors\n'
-        if newtonFailed:
-            if isStatic:
-                s += '  * adjust your tolerances: the newton solver may not be able to reach the relative or absolute tolerance, so increase them, e.g., staticSolver.newton.absoluteTolerance; if no loads are applied, usually absolute tolerances should be around 1e-5 to 1e-2\n'
-            else:
-                s += '  * adjust your tolerances: the newton solver may not be able to reach the relative or absolute tolerance, so increase them, e.g., timeIntegration.newton.absoluteTolerance; if no loads are applied, usually absolute tolerances should be around 1e-5 to 1e-2\n'
-            s += '  * use smaller step size or load steps\n'
-            s += '  * use adaptiveStep to reduce step size in static or dynamic simulation\n'
-            s += '  * adjust the way you initialize your model and how to apply loads, etc.\n'
-        s += '  * report error, clearly describing (a minimal description) of your problem, at reply.exudyn@gmail.com\n'
-    else:
-        s += "  use showHints=True to show helpful information\n"
-    s += '******************************\n'
-    
-    nODE2 = solver.GetODE2size()
-    nODE1 = solver.GetODE1size()
-    nAE = solver.GetAEsize()
-    nSys = nODE2+nODE1+nAE
-
-    causingObjects = []
-    if linearSolverFailed and causingRow >=0 and causingRow < nSys:
-        s+="The causing system equation "+str(causingRow)+" belongs to a "
-        if causingRow < nODE2:
-            s+="ODE2 coordinate"
-        elif causingRow < nODE2+nODE1:
-            s+="ODE1 coordinate"
-        else:
-            s+="algebraic variable (Lagrange multiplier)"
-        s+='\n'
-
-        if showCausingObjects:
-            for objectIndex in range(mbs.systemData.NumberOfObjects()):
-                ltg = mbs.systemData.GetObjectLTGODE2(objectIndex)
-                addObject = False
-                if causingRow in ltg:
-                    addObject = True
-                ltg = mbs.systemData.GetObjectLTGODE1(objectIndex)
-                if causingRow - (nODE2) in ltg:
-                    addObject = True
-                ltg = mbs.systemData.GetObjectLTGAE(objectIndex)
-                if causingRow - (nODE2+nODE1) in ltg:
-                    addObject = True
-
-                if addObject and (objectIndex not in causingObjects):
-                    causingObjects += [objectIndex]
-            s+="Potential object number(s) causing linear solver to fail: "+str(causingObjects)+"\n"
-            for i in causingObjects:
-                oDict = mbs.GetObject(i)
-                s += "    object "+str(i)+", name='"+oDict['name']+"', type="+ str(oDict['objectType']) +"\n"
-
-    if massMatrixNotInvertible:
-        s+='The mass matrix is not to invertable; check that every node/coordinate has appropriate mass!'
-
-    return s
-
-
-#**function: solves the static mbs problem using simulationSettings; check theDoc.pdf for MainSolverStatic for further details of the static solver; this function is also available in exudyn (using exudyn.SolveStatic(...))
-#**input:
-#   mbs: the MainSystem containing the assembled system; note that mbs may be changed upon several runs of this function
-#   simulationSettings: specific simulation settings out of exu.SimulationSettings(), as described in \refSection{sec:SolutionSettings}; use options for newton, discontinuous settings, etc., from staticSolver sub-items
-#   updateInitialValues: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
-#   storeSolver: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver'], and simulationSettings are stored as mbs.sys['simulationSettings']
-#**output: bool; returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.itemInterface import *
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# #create simple system:
-# ground = mbs.AddObject(ObjectGround())
-# mbs.AddNode(NodePoint())
-# body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
-# m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
-# m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
-# mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
-# mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings()
-# simulationSettings.timeIntegration.endTime = 10
-# success = mbs.SolveStatic(simulationSettings, storeSolver = True)
-# print("success =", success)
-# print("iterations = ", mbs.sys['staticSolver'].it)
-# print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0], 
-#       variableType=exu.OutputVariableType.Position))
-def SolveStatic(mbs, simulationSettings = exudyn.SimulationSettings(), 
-                updateInitialValues = False,
-                storeSolver = True,
-                showHints = False,
-                showCausingItems = True,
-                ):
-    staticSolver = exudyn.MainSolverStatic()
-    if storeSolver:
-        mbs.sys['staticSolver'] = staticSolver #copy solver structure to sys variable
-        mbs.sys['simulationSettings'] = simulationSettings #link to last simulation settings
-    success = False
-    try:
-        success = staticSolver.SolveSystem(mbs, simulationSettings)
-    except:
-        pass
-    finally:
-        if not success:
-            #resolved (delete):
-            # exudyn.Print not shown in Spyder at this time (because of exception?)
-            # print(SolverErrorMessage(staticSolver, mbs, isStatic=True, showCausingObjects=showCausingItems, 
-            #                          showCausingNodes=showCausingItems, showHints=showHints), flush=True)
-            exudyn.Print(SolverErrorMessage(staticSolver, mbs, isStatic=True, showCausingObjects=showCausingItems, 
-                                     showCausingNodes=showCausingItems, showHints=showHints))
-            raise ValueError("SolveStatic terminated due to errors")
-
-        elif updateInitialValues:
-            currentState = mbs.systemData.GetSystemState() #get current values
-            mbs.systemData.SetSystemState(systemStateList=currentState, configuration = exudyn.ConfigurationType.Initial)
-
-
-    return success
-
-#**function: solves the dynamic mbs problem using simulationSettings and solver type; check theDoc.pdf for MainSolverImplicitSecondOrder for further details of the dynamic solver; this function is also available in exudyn (using exudyn.SolveDynamic(...))
-#**input:
-#   mbs: the MainSystem containing the assembled system; note that mbs may be changed upon several runs of this function
-#   simulationSettings: specific simulation settings out of exu.SimulationSettings(), as described in \refSection{sec:SolutionSettings}; use options for newton, discontinuous settings, etc., from timeIntegration; therein, implicit second order solvers use settings from generalizedAlpha and explict solvers from explicitIntegration; be careful with settings, as the influence accuracy (step size!), convergence and performance (see special \refSection{sec:overview:basics:speedup})
-#   solverType: use exudyn.DynamicSolverType to set specific solver (default=generalized alpha)
-#   updateInitialValues: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
-#   storeSolver: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver'], and simulationSettings are stored as mbs.sys['simulationSettings']
-#   showHints: show additional hints, if solver fails
-#   showCausingItems: if linear solver fails, this option helps to identify objects, etc. which are related to a singularity in the linearized system matrix
-#**output: bool; returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.itemInterface import *
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# #create simple system:
-# ground = mbs.AddObject(ObjectGround())
-# mbs.AddNode(NodePoint())
-# body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
-# m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
-# m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
-# mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
-# mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
-# #
-# mbs.Assemble()
-# simulationSettings = exu.SimulationSettings()
-# simulationSettings.timeIntegration.endTime = 10
-# success = mbs.SolveDynamic(simulationSettings, storeSolver = True)
-# print("success =", success)
-# print("iterations = ", mbs.sys['dynamicSolver'].it)
-# print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0], 
-#       variableType=exu.OutputVariableType.Position))
-def SolveDynamic(mbs,
-                simulationSettings = exudyn.SimulationSettings(), 
-                solverType = exudyn.DynamicSolverType.GeneralizedAlpha,
-                updateInitialValues = False,
-                storeSolver = True,
-                showHints = False,
-                showCausingItems = True,
-                ):
-    success = False
-    if (solverType == exudyn.DynamicSolverType.TrapezoidalIndex2 or solverType == exudyn.DynamicSolverType.GeneralizedAlpha):
-    
-        dynamicSolver = exudyn.MainSolverImplicitSecondOrder()
-        if storeSolver:
-            mbs.sys['dynamicSolver'] = dynamicSolver #copy solver structure to sys variable
-            mbs.sys['simulationSettings'] = simulationSettings #link to last simulation settings
-        #if (experimentalNewSolver or #solver flag
-        #    ('experimentalNewSolver' in exudyn.sys)): #flag set in test suite
-        #    dynamicSolver.experimentalUseSolverNew = True #must be set at the very beginning when MainSolverImplicitSecondOrder() is initialized
-    
-        #store old settings:
-        newmarkOld = simulationSettings.timeIntegration.generalizedAlpha.useNewmark
-        index2Old = simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints
-
-        if solverType == exudyn.DynamicSolverType.TrapezoidalIndex2:
-            #manually override settings for integrator
-            simulationSettings.timeIntegration.generalizedAlpha.useNewmark = True
-            simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints = True
-    
-        stat = exudyn.InfoStat(False)
-        success = False
-        try:
-            success = dynamicSolver.SolveSystem(mbs, simulationSettings)
-        except:
-            pass
-        finally:
-            if not success:
-                #resolved (delete):
-                # print(SolverErrorMessage(dynamicSolver, mbs, isStatic=False, showCausingObjects=showCausingItems, 
-                #                          showCausingNodes=showCausingItems, showHints=showHints), flush=True)
-                exudyn.Print(SolverErrorMessage(dynamicSolver, mbs, isStatic=False, showCausingObjects=showCausingItems, 
-                                         showCausingNodes=showCausingItems, showHints=showHints))
-                raise ValueError("SolveDynamic terminated")
-                
-            CheckSolverInfoStatistics(dynamicSolver.GetSolverName(), stat, dynamicSolver.it.newtonStepsCount) #now check if these statistics are ok
-    
-            #restore old settings:
-            simulationSettings.timeIntegration.generalizedAlpha.useNewmark = newmarkOld
-            simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints = index2Old
-    elif (solverType == exudyn.DynamicSolverType.ExplicitEuler or 
-            solverType == exudyn.DynamicSolverType.ExplicitMidpoint or
-            solverType == exudyn.DynamicSolverType.RK33 or
-            solverType == exudyn.DynamicSolverType.RK44 or
-            solverType == exudyn.DynamicSolverType.RK67 or
-            solverType == exudyn.DynamicSolverType.ODE23 or
-            solverType == exudyn.DynamicSolverType.DOPRI5
-            ):
-        simulationSettings.timeIntegration.explicitIntegration.dynamicSolverType = solverType
-        #print('solverType=', simulationSettings.timeIntegration.explicitIntegration.dynamicSolverType)
-        dynamicSolver = exudyn.MainSolverExplicit()
-        if storeSolver:
-            mbs.sys['dynamicSolver'] = dynamicSolver #copy solver structure to sys variable
-            mbs.sys['simulationSettings'] = simulationSettings #link to last simulation settings
-
-        stat = exudyn.InfoStat(False)
-        success = dynamicSolver.SolveSystem(mbs, simulationSettings)
-        CheckSolverInfoStatistics(dynamicSolver.GetSolverName(), stat, dynamicSolver.it.currentStepIndex*dynamicSolver.GetNumberOfStages()) #now check if these statistics are ok
-    else:
-        raise ValueError("SolveDynamic: solver type not implemented: ", solverType)
-    
-    if updateInitialValues:
-        currentState = mbs.systemData.GetSystemState() #get current values
-        mbs.systemData.SetSystemState(systemStateList=currentState, 
-                                        configuration = exudyn.ConfigurationType.Initial)
-        mbs.systemData.SetODE2Coordinates_tt(coordinates = mbs.systemData.GetODE2Coordinates_tt(), 
-                                                configuration = exudyn.ConfigurationType.Initial)
-
-    return success
-
-#**function: return success (True/False) and error message of solver after SolveSteps(...), SolveSystem(...), SolveDynamic(...) or SolveStatic(...) have been called. May also be set if other higher level functions called e.g. SolveSystem(...)
-#**input: 
-#  solverStructure: solver structure, as stored in mbs.sys or as created e.g. by exudyn.MainSolverExplicit()
-#**output: [success, errorString], returns success=True or False and in case of no success, information is provided in errorString
-#**example:
-#  #assume MainSystem mbs, exu library and simulationSettings:
-#  try:
-#      mbs.SolveDynamic(simulationSettings)
-#  except:
-#      [success, msg] = exu.SolverSuccess(mbs.sys['dynamicSolver'])
-#      print('success=',success)
-#      print('error message=',msg)
-#
-#  #alternative:
-#  solver=exu.MainSolverImplicitSecondOrder()
-#  ...
-#  [success, msg] = exu.SolverSuccess(solver)
-def SolverSuccess(solverStructure):
-    return [solverStructure.output.finishedSuccessfully, solverStructure.GetErrorString()]
-
-#internal function: uniquely turn off all output and file writing - this would potentially erase user's output files ...
-def DeactivateWritingOfSolvers(simulationSettings):
-    store = {}
-    store['verboseModeOld'] = simulationSettings.staticSolver.verboseMode
-    simulationSettings.staticSolver.verboseMode = 0
-    store['writeSolutionToFileOld'] = simulationSettings.solutionSettings.writeSolutionToFile
-    simulationSettings.solutionSettings.writeSolutionToFile = False
-    store['sensorsStoreAndWriteFilesOld'] = simulationSettings.solutionSettings.sensorsStoreAndWriteFiles
-    simulationSettings.solutionSettings.sensorsStoreAndWriteFiles = False
-    return store
-
-#internal function for special solver functions; uniquely restores some settings
-def RestoreSimulationSettings(simulationSettings, store):
-    simulationSettings.staticSolver.verboseMode = store['verboseModeOld']
-    simulationSettings.solutionSettings.writeSolutionToFile = store['writeSolutionToFileOld']
-    simulationSettings.solutionSettings.sensorsStoreAndWriteFiles = store['sensorsStoreAndWriteFilesOld']
-    
-
-#**function: compute linearized system of equations for ODE2 part of mbs, not considering the effects of algebraic constraints
-#**input:    
-#   mbs: the MainSystem containing the assembled system
-#   simulationSettings: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
-#   useSparseSolver: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
-#**output: [ArrayLike, ArrayLike, ArrayLike]; [M, K, D]; list containing numpy mass matrix M, stiffness matrix K and damping matrix D
-#**notes: consider paper of Agundez, Vallejo, Freire, Mikkola, "The dependent coordinates in the linearization of constrained multibody systems: Handling and elimination", https://www.sciencedirect.com/science/article/pii/S0020740324000791
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# #
-# b0 = mbs.CreateMassPoint(referencePosition = [2,0,0],
-#                          initialVelocity = [2*0,5,0],
-#                          physicsMass = 1, gravity = [0,-9.81,0],
-#                          drawSize = 0.5, color=color4blue)
-# #
-# oGround = mbs.AddObject(ObjectGround())
-# #add vertical spring
-# oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
-#                              localPosition0=[2,1,0],
-#                              localPosition1=[0,0,0],
-#                              stiffness=1e4, damping=1e2,
-#                              drawSize=0.2)
-# #
-# mbs.Assemble()
-# [M,K,D] = mbs.ComputeLinearizedSystem()
-# exu.Print('M=\n',M,'\nK=\n',K,'\nD=\n',D) 
-def ComputeLinearizedSystem(mbs, 
-                            simulationSettings = exudyn.SimulationSettings(),
-                            useSparseSolver = False):
-    #do not overide sensor files or solution files ...
-    store = DeactivateWritingOfSolvers(simulationSettings)
-
-    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
-    staticSolver = exudyn.MainSolverStatic()
-
-    #initialize solver with initial values
-    staticSolver.InitializeSolver(mbs, simulationSettings)
-
-    staticSolver.ComputeMassMatrix(mbs)
-    M = staticSolver.GetSystemMassMatrix()
-
-    nODE2 = staticSolver.GetODE2size()
-    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
-                                        scalarFactor_ODE2_t=0, 
-                                        scalarFactor_ODE1=0)    #compute ODE2 part of jacobian ==> stored internally in solver
-    jacobian = staticSolver.GetSystemJacobian() #read out stored jacobian
-
-    K = jacobian[0:nODE2,0:nODE2]    #obtain ODE2 part from jacobian == stiffness matrix
-
-    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=0,
-                                        scalarFactor_ODE2_t=-1, 
-                                        scalarFactor_ODE1=0)    #reset jacobian
-    jacobian_t = staticSolver.GetSystemJacobian() #read out stored jacobian
-    
-    
-    D = jacobian_t[0:nODE2,0:nODE2] #obtain ODE2_t part from jacobian == damping matrix
-
-    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
-    RestoreSimulationSettings(simulationSettings, store)
-
-    return [M, K, D]
-
-#**function: compute eigenvalues for unconstrained ODE2 part of mbs; the computation may include constraints in case that ignoreAlgebraicEquations=False; for algebraic constraints, however, a dense singular value decomposition of the constraint jacobian is used for the nullspace projection; the computation is done for the initial values of the mbs, independently of previous computations. If you would like to use the current state for the eigenvalue computation, you need to copy the current state to the initial state (using GetSystemState, SetSystemState, see \refSection{sec:mbs:systemData}); note that mass and stiffness matrices are computed in dense mode so far, while eigenvalues are computed according to useSparseSolver.
-#**input:    
-#   mbs: the MainSystem containing the assembled system
-#   simulationSettings: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
-#   useSparseSolver: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
-#   numberOfEigenvalues: number of eigenvalues and eivenvectors to be computed; if numberOfEigenvalues==0, all eigenvalues will be computed (may be impossible for larger or sparse problems!)
-#   constrainedCoordinates: if this list is non-empty (and there are no algebraic equations of ignoreAlgebraicEquations=True), the integer indices represent constrained coordinates of the system, which are fixed during eigenvalue/vector computation; according rows/columns of mass and stiffness matrices are erased; in this case, algebraic equations of the system are ignored
-#   convert2Frequencies: if True, the eigen values are converted into frequencies (Hz) and the output is [eigenFrequencies, eigenVectors]
-#   useAbsoluteValues: if True, abs(eigenvalues) is used, which avoids problems for small (close to zero) eigenvalues; needed, when converting to frequencies
-#   ignoreAlgebraicEquations: if True, algebraic equations (and constraint jacobian) are not considered for eigenvalue computation; otherwise, the solver tries to automatically project the system into the nullspace kernel of the constraint jacobian using a SVD; this gives eigenvalues of the constrained system; eigenvectors are not computed
-#   singularValuesTolerance: tolerance used to distinguish between zero and nonzero singular values for algebraic constraints projection
-#**output: [ArrayLike, ArrayLike]; [eigenValues, eigenVectors]; eigenValues being a numpy array of eigen values ($\omega_i^2$, being the squared eigen frequencies in ($\omega_i$ in rad/s)!), eigenVectors a numpy array containing the eigenvectors in every column
-#**belongsTo: MainSystem
-#**author: Johannes Gerstmayr, Michael Pieber
-#**example:
-#  #take any example from the Examples or TestModels folder, e.g., 'cartesianSpringDamper.py' and run it
-#  #specific example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# #
-# b0 = mbs.CreateMassPoint(referencePosition = [2,0,0],
-#                          initialVelocity = [2*0,5,0],
-#                          physicsMass = 1, gravity = [0,-9.81,0],
-#                          drawSize = 0.5, color=color4blue)
-# #
-# oGround = mbs.AddObject(ObjectGround())
-# #add vertical spring
-# oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
-#                              localPosition0=[2,1,0],
-#                              localPosition1=[0,0,0],
-#                              stiffness=1e4, damping=1e2,
-#                              drawSize=0.2)
-# #
-# mbs.Assemble()
-# #
-# [eigenvalues, eigenvectors] = mbs.ComputeODE2Eigenvalues()
-#  #==>eigenvalues contain the eigenvalues of the ODE2 part of the system in the current configuration
-def ComputeODE2Eigenvalues(mbs, 
-                           simulationSettings = exudyn.SimulationSettings(),
-                           useSparseSolver = False, numberOfEigenvalues = 0, constrainedCoordinates=[],
-                           convert2Frequencies = False, useAbsoluteValues = True, 
-                           ignoreAlgebraicEquations=False, singularValuesTolerance=1e-12):
-
-    store = DeactivateWritingOfSolvers(simulationSettings)
-
-    try:
-        from scipy.linalg import eigh, svd  #eigh for symmetric matrices, positive definite; eig for standard eigen value problems
-        from scipy.sparse.linalg import eigsh #eigh for symmetric matrices, positive definite
-        from scipy.sparse import csr_matrix
-    except:
-        raise ValueError('ComputeODE2Eigenvalues: missing scipy package; install with: pip install scipy')
-
-    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
-    staticSolver = exudyn.MainSolverStatic()
-
-    #initialize solver with initial values
-    staticSolver.InitializeSolver(mbs, simulationSettings)
-
-    nODE2 = staticSolver.GetODE2size()
-    nODE1 = staticSolver.GetODE1size()
-    nAE = staticSolver.GetAEsize()
-    if nODE1 != 0:
-        print('ComputeODE2Eigenvalues: not implemented for ODE1 coordinates; results may be wrong and solver may fail')
-
-    staticSolver.ComputeMassMatrix(mbs)
-    Mode2 = staticSolver.GetSystemMassMatrix()
-
-    #compute ODE2 part of jacobian ==> stored internally in solver
-    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
-                                        scalarFactor_ODE2_t=0, 
-                                        scalarFactor_ODE1=0)    #could be 1 to include ODE1 part
-    if nAE != 0:
-        #compute AE part of jacobian if needed for constraint projection
-        staticSolver.ComputeJacobianAE(mbs, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., 
-                                       scalarFactor_ODE1=0., #could be 1 to include ODE1 part
-                                       velocityLevel=False)          
-    
-    jacobian = staticSolver.GetSystemJacobian() #read out stored jacobian; includes ODE2, ODE1 and nAE part
-    
-    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
-    RestoreSimulationSettings(simulationSettings, store)
-
-    #obtain ODE2 part from jacobian == stiffness matrix
-    Kode2 = jacobian[0:nODE2,0:nODE2]
-
-    remappingIndices = np.arange(nODE2) #maps new coordinates to original (full) ones
-    if constrainedCoordinates != []:
-        Mode2 = np.delete(np.delete(Mode2, constrainedCoordinates, 0), constrainedCoordinates, 1)
-        Kode2 = np.delete(np.delete(Kode2, constrainedCoordinates, 0), constrainedCoordinates, 1)
-        remappingIndices = np.delete(remappingIndices, constrainedCoordinates)
-
-    if nAE != 0 and not ignoreAlgebraicEquations and constrainedCoordinates != []:
-        raise ValueError('ComputeODE2Eigenvalues: in case of algebraic equations, either ignoreAlgebraicEquations=True or constrainedCoordinates=[]')
-
-    if constrainedCoordinates != [] or nAE == 0:
-        if not useSparseSolver:
-            [eigenValuesUnsorted, eigenVectors] = eigh(Kode2, Mode2) #this gives omega^2 ... squared eigen frequencies (rad/s)
-            if useAbsoluteValues:
-                sortIndices = np.argsort(abs(eigenValuesUnsorted)) #get resorting index
-                eigenValues = np.sort(a=abs(eigenValuesUnsorted)) #eigh returns unsorted eigenvalues...
-            else:
-                sortIndices = np.argsort(eigenValuesUnsorted) #get resorting index
-                eigenValues = np.sort(a=eigenValuesUnsorted) #eigh returns unsorted eigenvalues...
-            if numberOfEigenvalues > 0:
-                eigenValues = eigenValues[0:numberOfEigenvalues]
-                sortIndices = sortIndices[0:numberOfEigenvalues]
-            eigenVectors = eigenVectors[:,sortIndices] #eigenvectors are given in columns!
-        else:
-            if numberOfEigenvalues == 0: #compute all eigenvalues
-                numberOfEigenvalues = nODE2
-    
-            Kcsr = csr_matrix(Kode2)
-            Mcsr = csr_matrix(Mode2)
-    
-            #use "LM" (largest magnitude), but shift-inverted mode with sigma=0, to find the zero-eigenvalues:
-            #see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html
-            [eigenValues, eigenVectors] = eigsh(A=Kcsr, k=numberOfEigenvalues, M=Mcsr, 
-                                       which='LM', sigma=0, mode='normal') 
-    
-            #sort eigenvalues
-            if useAbsoluteValues:
-                sortIndices = np.argsort(abs(eigenValues)) #get resorting index
-                eigenValues = np.sort(a=abs(eigenValues))
-            else:
-                sortIndices = np.argsort(eigenValues) #get resorting index
-                eigenValues = np.sort(a=eigenValues)
-            eigenVectors = eigenVectors[:,sortIndices] #eigenvectors are given in columns!
-
-        eigenVectorsNew = np.zeros((nODE2,numberOfEigenvalues))
-        if constrainedCoordinates != []:
-            # print('remap=', remappingIndices)
-            for i in range(numberOfEigenvalues):
-                eigenVectorsNew[remappingIndices,i] = eigenVectors[:,i]
-            eigenVectors = eigenVectorsNew
-    else:
-        if useSparseSolver:
-            raise ValueError('ComputeODE2Eigenvalues: in case of algebraic equations and ignoreAlgebraicEquations=False, useSparseSolver must be False')
-        #use SVD to project equations into nullspace
-        #constraint jacobian:
-        C = jacobian[0:nODE2,nODE2+nODE1:]
-        
-        #compute SVD; D includes singular values
-        [U,D,V] = svd(C)
-        
-        nnz = (abs(D) > singularValuesTolerance).sum() #size of constraints, often number of cols of C
-        
-        nullspace = U[:,nnz:].T #U[nnz:]
-        Knullspace = nullspace@Kode2@nullspace.T
-        Mnullspace = nullspace@Mode2@nullspace.T
-
-        # print('nODE2=',nODE2)
-        # print('nAE=',nAE)
-        # print('nnz=',nnz)
-        # print('C=',C.shape)
-        # print('U=',U.shape)
-        # print('sing.val.=',D.round(5))
-        # print('Knullspace=',Knullspace.round(5))
-        # print('Mnullspace=',Mnullspace.round(5))
-        # print('nullspace=',nullspace.round(3))
-
-        [eigenValuesUnsorted, eigenVectorsReduced] = eigh(Knullspace,Mnullspace)
-        if useAbsoluteValues:
-            sortIndices = np.argsort(abs(eigenValuesUnsorted)) #get resorting index
-            eigenValues = np.sort(a=abs(eigenValuesUnsorted)) #eigh returns unsorted eigenvalues...
-        else:
-            sortIndices = np.argsort(eigenValuesUnsorted) #get resorting index
-            eigenValues = np.sort(a=eigenValuesUnsorted) #eigh returns unsorted eigenvalues...
-
-        if numberOfEigenvalues > 0:
-            eigenValues = eigenValues[0:numberOfEigenvalues]
-            sortIndices = sortIndices[0:numberOfEigenvalues]
-        eigenVectorsReduced = eigenVectorsReduced[:,sortIndices] #eigenvectors are given in columns!
-
-        eigenVectors = nullspace.T @ eigenVectorsReduced
-
-
-
-    if convert2Frequencies:
-        eigenFrequencies = np.sqrt(eigenValues)/(2*np.pi)
-        return [eigenFrequencies, eigenVectors]
-    else:
-        return [eigenValues, eigenVectors]
-    
-
-#**function: compute system DOF numerically, considering Gr{\"u}bler-Kutzbach formula as well as redundant constraints; uses numpy matrix rank or singular value decomposition of scipy (useSVD=True)
-#**input:
-#  mbs: MainSystem for which DOF shall be computed
-#  simulationSettings: used e.g. for settings regarding numerical differentiation; default settings may be used in most cases
-#  threshold: threshold factor for singular values which estimate the redundant constraints
-#  useSVD: use singular value decomposition directly, also showing SVD values if verbose=True
-#  verbose: if True, it will show the singular values and one may decide if the threshold shall be adapted
-#**output: dict; returns dictionary with key words 'degreeOfFreedom', 'redundantConstraints', 'nODE2', 'nODE1', 'nAE', 'nPureAE', where: degreeOfFreedom = the system degree of freedom computed numerically, redundantConstraints=the number of redundant constraints, nODE2=number of ODE2 coordinates, nODE1=number of ODE1 coordinates, nAE=total number of constraints, nPureAE=number of constraints on algebraic variables (e.g., lambda=0) that are not coupled to ODE2 coordinates
-#**notes: this approach could possibly fail with special constraints! Currently only works with dense matrices, thus it will be slow for larger systems
-#**belongsTo: MainSystem
-#**example:
-# import exudyn as exu
-# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
-# import numpy as np
-# SC = exu.SystemContainer()
-# mbs = SC.AddSystem()
-# #
-# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
-#                                                  sideLengths=[1,0.1,0.1]),
-#                          referencePosition = [6,0,0],
-#                          initialAngularVelocity = [0,8,0],
-#                          gravity = [0,-9.81,0],
-#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
-#                                                                       color=color4orange)])
-# oGround = mbs.AddObject(ObjectGround())
-# mbs.CreateGenericJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
-#                        constrainedAxes=[1,1,1, 1,0,0],
-#                        rotationMatrixAxes=RotationMatrixX(0.125*pi), #tilt axes
-#                        useGlobalFrame=True, axesRadius=0.02, axesLength=0.2)
-# #
-# mbs.Assemble()
-# dof = mbs.ComputeSystemDegreeOfFreedom(verbose=1)['degreeOfFreedom'] #print out details
-def ComputeSystemDegreeOfFreedom(mbs, 
-                simulationSettings = exudyn.SimulationSettings(),
-                threshold = 1e-12, verbose=False, useSVD=False):
-    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
-    
-    store = DeactivateWritingOfSolvers(simulationSettings)
-
-    staticSolver = exudyn.MainSolverStatic()
-    #initialize solver with initial values
-    staticSolver.InitializeSolver(mbs, simulationSettings)
-
-    nODE2 = staticSolver.GetODE2size()
-    nODE1 = staticSolver.GetODE1size()
-    if nODE1 != 0:
-        print('WARNING: ComputeSystemDegreeOfFreedom(...) not suitable in case of ODE1 coordinates; ODE1 coordinates will not count as additional DOF!')
-    nODE12 = nODE2+nODE1
-    nAE = staticSolver.GetAEsize()
-
-    #reset jacobian    
-    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
-                                        scalarFactor_ODE2_t=0, 
-                                        scalarFactor_ODE1=0)    #compute ODE2 part of jacobian ==> stored internally in solver
-    staticSolver.ComputeJacobianAE(mbs, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., velocityLevel=False)
-    jacobian = staticSolver.GetSystemJacobian()#.round(20) #read out stored jacobian
-
-    Code2 = jacobian[0:nODE2, nODE12:]    #C_q: constraint jacobian
-    Cae = jacobian[nODE12:,nODE12:]       #C_lambda
-    Call =  jacobian[:, nODE12:]
-    
-    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
-    #restore old settings:
-    RestoreSimulationSettings(simulationSettings, store)
-    
-    if verbose == 2:
-        print('Code2=\n', Code2, sep='')
-        print('Cae  =\n', Cae, sep='')
-
-    if useSVD:
-        try:
-            from scipy.linalg import svdvals#, svd
-        except:
-            raise ValueError('ComputeSystemDegreeOfFreedom: missing scipy package; install with: pip install scipy')
-
-    
-    nRedundant = 0
-    nPureAE = 0
-    if nAE != 0:
-
-        if useSVD:
-            #s = svd(Call, compute_uv=False, full_matrices=False)#, lapack_driver='gesvd')
-            s = svdvals(Call)
-    
-            if verbose:
-                print('singular values ODE2+AE=',s)
-    
-            sAE = svdvals(Cae)
-            #sAE = svd(Cae, compute_uv=False, full_matrices=False)#, lapack_driver='gesvd')
-    
-            if verbose:
-                print('singular values pure AE=',sAE)
-            
-            nRedundant = (abs(s) <= threshold).sum() #counts True=1, False=0
-            #these are constraints on AE coordinates, which do not count as constraints!
-            nPureAE = (abs(sAE) > threshold).sum() #counts True=1, False=0
-        else:
-            nRedundant = nAE - np.linalg.matrix_rank(Call)
-            nPureAE = np.linalg.matrix_rank(Cae)
-
-    dof = nODE2-(nAE-nPureAE)+nRedundant
-    if verbose:
-        print('ODE2 coordinates          =',nODE2)
-        print('total constraints         =',nAE)
-        print('redundant constraints     =',nRedundant)
-        print('pure algebraic constraints=',nPureAE)
-        print('degree of freedom         =',dof)
-
-    #return [dof, nRedundant, nODE2, nODE1, nAE, nPureAE] #old mode
-    return {'degreeOfFreedom':dof, 
-            'redundantConstraints':nRedundant, 
-            'nODE2':nODE2, 'nODE1':nODE1, 
-            'nAE':nAE, 'nPureAE':nPureAE}
-
-
-    
-#**function: helper function for solvers to check e.g. if high number of memory allocations happened during simulation
-#            This can happen, if large amount of sensors are attached and output is written in every time step
-#**input: stat=exudyn.InfoStat() from previous step, numberOfEvaluations is a counter which is proportional to number of RHS evaluations in method
-def CheckSolverInfoStatistics(solverName, infoStat, numberOfEvaluations):
-    stat = np.array(exudyn.InfoStat(False)) - np.array(infoStat)
-
-    newCnt = max(stat[0],stat[2],stat[4]) #array, vector, matrix new counts
-
-    if newCnt > solverCheckMemoryAllocationsThreshold and newCnt >= numberOfEvaluations:
-        exudyn.Print("WARNING: "+solverName+" detected large amount ("+str(newCnt)+") of memory allocations, which seem to occur in every time step; this may be due to user functions; solver may be slow")
-
-    #print("newcnt=", newCnt)
-
-#%%+++++++++++++++++++
-if __name__ == '__main__':
-    import exudyn.demos as demos
-    if True:
-        [mbs, SC] = demos.Demo1(False)
-        res = exudyn.ComputeSystemDegreeOfFreedom(mbs, verbose=True)
-        print('Demo1 dof=',res['degreeOfFreedom'],'\n') #2 DOF (2D mass point freely moving)
-
-    #takes some seconds to compute:
-    if True:
-        [mbs, SC] = demos.Demo2(False)
-        res = exudyn.ComputeSystemDegreeOfFreedom(mbs)
-        print('Demo2=',res,'\n') #12*3=36 (12 bodies with 12 spherical joints)
-    
-        res = exudyn.ComputeSystemDegreeOfFreedom(mbs, verbose=True, useSVD=True)
-        print('Demo2 using SVD=',res) #12*3=36 (12 bodies with 12 spherical joints)
-
-
-    #3D rigid-body with revolute joint and spring, same as in TestModels/ComputeODE2AEeigenvaluesTest.py
-    #compared to analytical solution
-    if True:
-        from exudyn.utilities import *
-        import numpy as np
-
-        SC = exudyn.SystemContainer()
-        mbs = SC.AddSystem()
-
-        beamL=0.1 #in m
-        beamW=0.01
-        beamH=0.001
-        rho=5000 #kg/m**3
-        springL=0.02 #in m
-        springK=1e1 #in N/m
-    
-        oGround = mbs.AddObject(ObjectGround())
-    
-        inertiaCuboid=InertiaCuboid(density=rho,
-                                sideLengths=[beamL,beamH,beamW])
-    
-        bBeam = mbs.CreateRigidBody(inertia = inertiaCuboid,
-                                referencePosition = [beamL*0.5,0,0],
-                                gravity = [0,-9.81*0,0],
-                                graphicsDataList = [GraphicsDataOrthoCubePoint(size=[beamL,beamH,beamW],
-                                color=color4orange)])
-        mBeamRight = mbs.AddMarker(MarkerBodyRigid(bodyNumber=bBeam, localPosition=[beamL*0.5,0,0]))
-
-        mbs.CreateGenericJoint(bodyNumbers= [oGround,bBeam], position= [0.,0.,0.], 
-                                      rotationMatrixAxes= np.eye(3), constrainedAxes= [1,1,1,1,1,0], 
-                                      axesRadius=0.001, axesLength= 0.01, color= color4default)
-    
-        markerToConnect = mbs.AddMarker(MarkerBodyRigid(bodyNumber=oGround, localPosition=[beamL,-springL,0])) 
-    
-        mbs.AddObject(CartesianSpringDamper(markerNumbers=[markerToConnect,mBeamRight],
-                                            stiffness=[0,springK,0],
-                                            damping=[0,0,0],
-                                            offset=[0,springL,0],
-                                            visualization=VObjectConnectorCartesianSpringDamper(show=True,drawSize=0.01)
-                                            ))    
-        mbs.Assemble()
-        [ew, ev] = mbs.ComputeODE2Eigenvalues()
-
-        evNumerical = np.sqrt(ew[0]) / (2*np.pi)
-        
-        thetaZZ=inertiaCuboid.Translated([-beamL/2,0,0]).Inertia()[2,2]
-        evAnalytical = np.sqrt( springK*beamL**2/thetaZZ ) / (2*np.pi)
-
-        print('numerical eigenvalues in Hz:',evNumerical)
-        print('analytical eigenvalues in Hz:',evAnalytical)
-        print('error eigenvalues:', (evAnalytical-evNumerical)/evAnalytical)
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  The solver module provides interfaces to static, dynamic and eigenvalue solvers.
+#           Most of the solvers are implemented inside the C++ core.
+#
+# Author:   Johannes Gerstmayr 
+# Date:     2020-12-02
+# Notes:    Solver functions are included directly in exudyn and can be used with exu.SolveStatic(...)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#import is necessary, otherwise the solvers cannot be called
+import numpy as np
+import exudyn
+
+solverCheckMemoryAllocations = True
+solverCheckMemoryAllocationsThreshold = 100000 #treshold for warning on too many news during solving
+
+#**function: (internal) helper function for unique error and helper messages
+def SolverErrorMessage(solver, mbs, isStatic=False, 
+                       showCausingObjects=True, showCausingNodes=True, showHints=True):
+    s = ''
+    s += '\n******************************\n'
+    if isStatic:
+        s += 'STATIC SOLVER FAILED:\n'
+    else:        
+        s += 'DYNAMIC SOLVER FAILED:\n'
+    #print(solver.conv)
+    massMatrixNotInvertible = solver.conv.massMatrixNotInvertible
+    linearSolverFailed = solver.conv.linearSolverFailed
+    causingRow = solver.conv.linearSolverCausingRow
+    newtonFailed = solver.conv.stepReductionFailed or solver.conv.newtonSolutionDiverged
+
+    if showHints:
+        s += '  POSSIBLE REASONS for solver abort:\n'
+        if linearSolverFailed:
+            s += '  * unused node or no equations supplied for node\n'
+            s += '  * redundant definition of constraints\n'
+        if (solver.conv.stepReductionFailed and (not solver.conv.newtonSolutionDiverged)
+            and solver.conv.residual < 1e-3): #indicates that solution is not very wrong
+            s += '  * your tolerances (in newton) may be too tight, see solutions below\n'
+            
+        s += '  * inconsistent or inappropriate initial conditions\n'
+        s += '  * system is nearly singular due to high (penalty) stiffness or singularities in your system\n'
+        if isStatic:
+            s += '  * static problem has unconstrained coordinates (that can move freely)\n'
+            if newtonFailed:
+                s += '  * the system is very nonlinear and thus requires smaller (load) steps\n'
+        else:
+            if newtonFailed:
+                s += '  * too large step size, which prevents Newton to converge\n'
+            if linearSolverFailed:
+                s += '  * singular mass matrix (no mass/inertia assigned?)\n'
+
+        s += '  -------------------\n'
+        s += '  POSSIBLE SOLUTIONS:\n'
+        s += '  * check your Python model!\n'
+        s += '  * check the causing nodes, objects, connectors, etc.\n'
+        s += '  * check your nodes, objects, connectors, and markers\n'
+        s += '  * change solver and solver settings (e.g. change index 3/index 2 solver)\n'
+        s += '  * try linearSolverSettings.ignoreSingularJacobian and EigenDense solver type in case of redundant constraints\n'
+        s += '  * for small systems (<1000 coordinates), try mbs. ComputeSystemDegreeOfFreedom() to check system\n'
+        s += '  * step-by-step remove constraints, until you find the causing item\n'
+        s += '  * step-by-step remove objects and nodes, until you find the causing item\n'
+        s += '  * check joint axes (using visualization), which may be incompatible\n'
+        s += '  * use lower (penalty) stiffness factors\n'
+        if newtonFailed:
+            if isStatic:
+                s += '  * adjust your tolerances: the newton solver may not be able to reach the relative or absolute tolerance, so increase them, e.g., staticSolver.newton.absoluteTolerance; if no loads are applied, usually absolute tolerances should be around 1e-5 to 1e-2\n'
+            else:
+                s += '  * adjust your tolerances: the newton solver may not be able to reach the relative or absolute tolerance, so increase them, e.g., timeIntegration.newton.absoluteTolerance; if no loads are applied, usually absolute tolerances should be around 1e-5 to 1e-2\n'
+            s += '  * use smaller step size or load steps\n'
+            s += '  * use adaptiveStep to reduce step size in static or dynamic simulation\n'
+            s += '  * adjust the way you initialize your model and how to apply loads, etc.\n'
+        s += '  * report error, clearly describing (a minimal description) of your problem, at reply.exudyn@gmail.com\n'
+    else:
+        s += "  use showHints=True to show helpful information\n"
+    s += '******************************\n'
+    
+    nODE2 = solver.GetODE2size()
+    nODE1 = solver.GetODE1size()
+    nAE = solver.GetAEsize()
+    nSys = nODE2+nODE1+nAE
+
+    causingObjects = []
+    if linearSolverFailed and causingRow >=0 and causingRow < nSys:
+        s+="The causing system equation "+str(causingRow)+" belongs to a "
+        if causingRow < nODE2:
+            s+="ODE2 coordinate"
+        elif causingRow < nODE2+nODE1:
+            s+="ODE1 coordinate"
+        else:
+            s+="algebraic variable (Lagrange multiplier)"
+        s+='\n'
+
+        if showCausingObjects:
+            for objectIndex in range(mbs.systemData.NumberOfObjects()):
+                ltg = mbs.systemData.GetObjectLTGODE2(objectIndex)
+                addObject = False
+                if causingRow in ltg:
+                    addObject = True
+                ltg = mbs.systemData.GetObjectLTGODE1(objectIndex)
+                if causingRow - (nODE2) in ltg:
+                    addObject = True
+                ltg = mbs.systemData.GetObjectLTGAE(objectIndex)
+                if causingRow - (nODE2+nODE1) in ltg:
+                    addObject = True
+
+                if addObject and (objectIndex not in causingObjects):
+                    causingObjects += [objectIndex]
+            s+="Potential object number(s) causing linear solver to fail: "+str(causingObjects)+"\n"
+            for i in causingObjects:
+                oDict = mbs.GetObject(i)
+                s += "    object "+str(i)+", name='"+oDict['name']+"', type="+ str(oDict['objectType']) +"\n"
+
+    if massMatrixNotInvertible:
+        s+='The mass matrix is not to invertable; check that every node/coordinate has appropriate mass!'
+
+    return s
+
+
+#**function: solves the static mbs problem using simulationSettings; check theDoc.pdf for MainSolverStatic for further details of the static solver; this function is also available in exudyn (using exudyn.SolveStatic(...))
+#**input:
+#   mbs: the MainSystem containing the assembled system; note that mbs may be changed upon several runs of this function
+#   simulationSettings: specific simulation settings out of exu.SimulationSettings(), as described in \refSection{sec:SolutionSettings}; use options for newton, discontinuous settings, etc., from staticSolver sub-items
+#   updateInitialValues: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
+#   storeSolver: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver'], and simulationSettings are stored as mbs.sys['simulationSettings']
+#**output: bool; returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.itemInterface import *
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# #create simple system:
+# ground = mbs.AddObject(ObjectGround())
+# mbs.AddNode(NodePoint())
+# body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
+# m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
+# m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
+# mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
+# mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings()
+# simulationSettings.timeIntegration.endTime = 10
+# success = mbs.SolveStatic(simulationSettings, storeSolver = True)
+# print("success =", success)
+# print("iterations = ", mbs.sys['staticSolver'].it)
+# print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0], 
+#       variableType=exu.OutputVariableType.Position))
+def SolveStatic(mbs, simulationSettings = exudyn.SimulationSettings(), 
+                updateInitialValues = False,
+                storeSolver = True,
+                showHints = False,
+                showCausingItems = True,
+                ):
+    staticSolver = exudyn.MainSolverStatic()
+    if storeSolver:
+        mbs.sys['staticSolver'] = staticSolver #copy solver structure to sys variable
+        mbs.sys['simulationSettings'] = simulationSettings #link to last simulation settings
+    success = False
+    try:
+        success = staticSolver.SolveSystem(mbs, simulationSettings)
+    except:
+        pass
+    finally:
+        if not success:
+            #resolved (delete):
+            # exudyn.Print not shown in Spyder at this time (because of exception?)
+            # print(SolverErrorMessage(staticSolver, mbs, isStatic=True, showCausingObjects=showCausingItems, 
+            #                          showCausingNodes=showCausingItems, showHints=showHints), flush=True)
+            exudyn.Print(SolverErrorMessage(staticSolver, mbs, isStatic=True, showCausingObjects=showCausingItems, 
+                                     showCausingNodes=showCausingItems, showHints=showHints))
+            raise ValueError("SolveStatic terminated due to errors")
+
+        elif updateInitialValues:
+            currentState = mbs.systemData.GetSystemState() #get current values
+            mbs.systemData.SetSystemState(systemStateList=currentState, configuration = exudyn.ConfigurationType.Initial)
+
+
+    return success
+
+#**function: solves the dynamic mbs problem using simulationSettings and solver type; check theDoc.pdf for MainSolverImplicitSecondOrder for further details of the dynamic solver; this function is also available in exudyn (using exudyn.SolveDynamic(...))
+#**input:
+#   mbs: the MainSystem containing the assembled system; note that mbs may be changed upon several runs of this function
+#   simulationSettings: specific simulation settings out of exu.SimulationSettings(), as described in \refSection{sec:SolutionSettings}; use options for newton, discontinuous settings, etc., from timeIntegration; therein, implicit second order solvers use settings from generalizedAlpha and explict solvers from explicitIntegration; be careful with settings, as the influence accuracy (step size!), convergence and performance (see special \refSection{sec:overview:basics:speedup})
+#   solverType: use exudyn.DynamicSolverType to set specific solver (default=generalized alpha)
+#   updateInitialValues: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
+#   storeSolver: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver'], and simulationSettings are stored as mbs.sys['simulationSettings']
+#   showHints: show additional hints, if solver fails
+#   showCausingItems: if linear solver fails, this option helps to identify objects, etc. which are related to a singularity in the linearized system matrix
+#**output: bool; returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.itemInterface import *
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# #create simple system:
+# ground = mbs.AddObject(ObjectGround())
+# mbs.AddNode(NodePoint())
+# body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
+# m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
+# m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
+# mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
+# mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
+# #
+# mbs.Assemble()
+# simulationSettings = exu.SimulationSettings()
+# simulationSettings.timeIntegration.endTime = 10
+# success = mbs.SolveDynamic(simulationSettings, storeSolver = True)
+# print("success =", success)
+# print("iterations = ", mbs.sys['dynamicSolver'].it)
+# print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0], 
+#       variableType=exu.OutputVariableType.Position))
+def SolveDynamic(mbs,
+                simulationSettings = exudyn.SimulationSettings(), 
+                solverType = exudyn.DynamicSolverType.GeneralizedAlpha,
+                updateInitialValues = False,
+                storeSolver = True,
+                showHints = False,
+                showCausingItems = True,
+                ):
+    success = False
+    if (solverType == exudyn.DynamicSolverType.TrapezoidalIndex2 or solverType == exudyn.DynamicSolverType.GeneralizedAlpha):
+    
+        dynamicSolver = exudyn.MainSolverImplicitSecondOrder()
+        if storeSolver:
+            mbs.sys['dynamicSolver'] = dynamicSolver #copy solver structure to sys variable
+            mbs.sys['simulationSettings'] = simulationSettings #link to last simulation settings
+        #if (experimentalNewSolver or #solver flag
+        #    ('experimentalNewSolver' in exudyn.sys)): #flag set in test suite
+        #    dynamicSolver.experimentalUseSolverNew = True #must be set at the very beginning when MainSolverImplicitSecondOrder() is initialized
+    
+        #store old settings:
+        newmarkOld = simulationSettings.timeIntegration.generalizedAlpha.useNewmark
+        index2Old = simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints
+
+        if solverType == exudyn.DynamicSolverType.TrapezoidalIndex2:
+            #manually override settings for integrator
+            simulationSettings.timeIntegration.generalizedAlpha.useNewmark = True
+            simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints = True
+    
+        stat = exudyn.InfoStat(False)
+        success = False
+        try:
+            success = dynamicSolver.SolveSystem(mbs, simulationSettings)
+        except:
+            pass
+        finally:
+            if not success:
+                #resolved (delete):
+                # print(SolverErrorMessage(dynamicSolver, mbs, isStatic=False, showCausingObjects=showCausingItems, 
+                #                          showCausingNodes=showCausingItems, showHints=showHints), flush=True)
+                exudyn.Print(SolverErrorMessage(dynamicSolver, mbs, isStatic=False, showCausingObjects=showCausingItems, 
+                                         showCausingNodes=showCausingItems, showHints=showHints))
+                raise ValueError("SolveDynamic terminated")
+                
+            CheckSolverInfoStatistics(dynamicSolver.GetSolverName(), stat, dynamicSolver.it.newtonStepsCount) #now check if these statistics are ok
+    
+            #restore old settings:
+            simulationSettings.timeIntegration.generalizedAlpha.useNewmark = newmarkOld
+            simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints = index2Old
+    elif (solverType == exudyn.DynamicSolverType.ExplicitEuler or 
+            solverType == exudyn.DynamicSolverType.ExplicitMidpoint or
+            solverType == exudyn.DynamicSolverType.RK33 or
+            solverType == exudyn.DynamicSolverType.RK44 or
+            solverType == exudyn.DynamicSolverType.RK67 or
+            solverType == exudyn.DynamicSolverType.ODE23 or
+            solverType == exudyn.DynamicSolverType.DOPRI5
+            ):
+        simulationSettings.timeIntegration.explicitIntegration.dynamicSolverType = solverType
+        #print('solverType=', simulationSettings.timeIntegration.explicitIntegration.dynamicSolverType)
+        dynamicSolver = exudyn.MainSolverExplicit()
+        if storeSolver:
+            mbs.sys['dynamicSolver'] = dynamicSolver #copy solver structure to sys variable
+            mbs.sys['simulationSettings'] = simulationSettings #link to last simulation settings
+
+        stat = exudyn.InfoStat(False)
+        success = dynamicSolver.SolveSystem(mbs, simulationSettings)
+        CheckSolverInfoStatistics(dynamicSolver.GetSolverName(), stat, dynamicSolver.it.currentStepIndex*dynamicSolver.GetNumberOfStages()) #now check if these statistics are ok
+    else:
+        raise ValueError("SolveDynamic: solver type not implemented: ", solverType)
+    
+    if updateInitialValues:
+        currentState = mbs.systemData.GetSystemState() #get current values
+        mbs.systemData.SetSystemState(systemStateList=currentState, 
+                                        configuration = exudyn.ConfigurationType.Initial)
+        mbs.systemData.SetODE2Coordinates_tt(coordinates = mbs.systemData.GetODE2Coordinates_tt(), 
+                                                configuration = exudyn.ConfigurationType.Initial)
+
+    return success
+
+#**function: return success (True/False) and error message of solver after SolveSteps(...), SolveSystem(...), SolveDynamic(...) or SolveStatic(...) have been called. May also be set if other higher level functions called e.g. SolveSystem(...)
+#**input: 
+#  solverStructure: solver structure, as stored in mbs.sys or as created e.g. by exudyn.MainSolverExplicit()
+#**output: [success, errorString], returns success=True or False and in case of no success, information is provided in errorString
+#**example:
+#  #assume MainSystem mbs, exu library and simulationSettings:
+#  try:
+#      mbs.SolveDynamic(simulationSettings)
+#  except:
+#      [success, msg] = exu.SolverSuccess(mbs.sys['dynamicSolver'])
+#      print('success=',success)
+#      print('error message=',msg)
+#
+#  #alternative:
+#  solver=exu.MainSolverImplicitSecondOrder()
+#  ...
+#  [success, msg] = exu.SolverSuccess(solver)
+def SolverSuccess(solverStructure):
+    return [solverStructure.output.finishedSuccessfully, solverStructure.GetErrorString()]
+
+#internal function: uniquely turn off all output and file writing - this would potentially erase user's output files ...
+def DeactivateWritingOfSolvers(simulationSettings):
+    store = {}
+    store['verboseModeOld'] = simulationSettings.staticSolver.verboseMode
+    simulationSettings.staticSolver.verboseMode = 0
+    store['writeSolutionToFileOld'] = simulationSettings.solutionSettings.writeSolutionToFile
+    simulationSettings.solutionSettings.writeSolutionToFile = False
+    store['sensorsStoreAndWriteFilesOld'] = simulationSettings.solutionSettings.sensorsStoreAndWriteFiles
+    simulationSettings.solutionSettings.sensorsStoreAndWriteFiles = False
+    return store
+
+#internal function for special solver functions; uniquely restores some settings
+def RestoreSimulationSettings(simulationSettings, store):
+    simulationSettings.staticSolver.verboseMode = store['verboseModeOld']
+    simulationSettings.solutionSettings.writeSolutionToFile = store['writeSolutionToFileOld']
+    simulationSettings.solutionSettings.sensorsStoreAndWriteFiles = store['sensorsStoreAndWriteFilesOld']
+    
+
+#**function: compute linearized system of equations for ODE2 part of mbs, not considering the effects of algebraic constraints
+#**input:    
+#   mbs: the MainSystem containing the assembled system
+#   simulationSettings: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
+#   useSparseSolver: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
+#**output: [ArrayLike, ArrayLike, ArrayLike]; [M, K, D]; list containing numpy mass matrix M, stiffness matrix K and damping matrix D
+#**notes: consider paper of Agundez, Vallejo, Freire, Mikkola, "The dependent coordinates in the linearization of constrained multibody systems: Handling and elimination", https://www.sciencedirect.com/science/article/pii/S0020740324000791
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# #
+# b0 = mbs.CreateMassPoint(referencePosition = [2,0,0],
+#                          initialVelocity = [2*0,5,0],
+#                          physicsMass = 1, gravity = [0,-9.81,0],
+#                          drawSize = 0.5, color=color4blue)
+# #
+# oGround = mbs.AddObject(ObjectGround())
+# #add vertical spring
+# oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
+#                              localPosition0=[2,1,0],
+#                              localPosition1=[0,0,0],
+#                              stiffness=1e4, damping=1e2,
+#                              drawSize=0.2)
+# #
+# mbs.Assemble()
+# [M,K,D] = mbs.ComputeLinearizedSystem()
+# exu.Print('M=\n',M,'\nK=\n',K,'\nD=\n',D) 
+def ComputeLinearizedSystem(mbs, 
+                            simulationSettings = exudyn.SimulationSettings(),
+                            useSparseSolver = False):
+    #do not overide sensor files or solution files ...
+    store = DeactivateWritingOfSolvers(simulationSettings)
+
+    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
+    staticSolver = exudyn.MainSolverStatic()
+
+    #initialize solver with initial values
+    staticSolver.InitializeSolver(mbs, simulationSettings)
+
+    staticSolver.ComputeMassMatrix(mbs)
+    M = staticSolver.GetSystemMassMatrix()
+
+    nODE2 = staticSolver.GetODE2size()
+    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
+                                        scalarFactor_ODE2_t=0, 
+                                        scalarFactor_ODE1=0)    #compute ODE2 part of jacobian ==> stored internally in solver
+    jacobian = staticSolver.GetSystemJacobian() #read out stored jacobian
+
+    K = jacobian[0:nODE2,0:nODE2]    #obtain ODE2 part from jacobian == stiffness matrix
+
+    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=0,
+                                        scalarFactor_ODE2_t=-1, 
+                                        scalarFactor_ODE1=0)    #reset jacobian
+    jacobian_t = staticSolver.GetSystemJacobian() #read out stored jacobian
+    
+    
+    D = jacobian_t[0:nODE2,0:nODE2] #obtain ODE2_t part from jacobian == damping matrix
+
+    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
+    RestoreSimulationSettings(simulationSettings, store)
+
+    return [M, K, D]
+
+#**function: compute eigenvalues for unconstrained ODE2 part of mbs; the computation may include constraints in case that ignoreAlgebraicEquations=False; for algebraic constraints, however, a dense singular value decomposition of the constraint jacobian is used for the nullspace projection; the computation is done for the initial values of the mbs, independently of previous computations. If you would like to use the current state for the eigenvalue computation, you need to copy the current state to the initial state (using GetSystemState, SetSystemState, see \refSection{sec:mbs:systemData}); note that mass and stiffness matrices are computed in dense mode so far, while eigenvalues are computed according to useSparseSolver.
+#**input:    
+#   mbs: the MainSystem containing the assembled system
+#   simulationSettings: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
+#   useSparseSolver: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
+#   numberOfEigenvalues: number of eigenvalues and eivenvectors to be computed; if numberOfEigenvalues==0, all eigenvalues will be computed (may be impossible for larger or sparse problems!)
+#   constrainedCoordinates: if this list is non-empty (and there are no algebraic equations or ignoreAlgebraicEquations=True), the integer indices represent constrained coordinates of the system, which are fixed during eigenvalue/vector computation; according rows/columns of mass and stiffness matrices are erased; in this case, algebraic equations of the system are ignored
+#   convert2Frequencies: if True, the eigen values are converted into frequencies (Hz) and the output is [eigenFrequencies, eigenVectors]
+#   useAbsoluteValues: if True, abs(eigenvalues) is used, which avoids problems for small (close to zero) eigenvalues; needed, when converting to frequencies
+#   computeComplexEigenvalues: if True, the system is converted into a system of first order differential equations, including damping; only implemented for dense solver!
+#   ignoreAlgebraicEquations: if True, algebraic equations (and constraint jacobian) are not considered for eigenvalue computation; otherwise, the solver tries to automatically project the system into the nullspace kernel of the constraint jacobian using a SVD; this gives eigenvalues of the constrained system; eigenvectors are not computed
+#   singularValuesTolerance: tolerance used to distinguish between zero and nonzero singular values for algebraic constraints projection
+#**output: [ArrayLike, ArrayLike]; [eigenValues, eigenVectors]; eigenValues being a numpy array of eigen values ($\omega_i^2$, being the squared eigen frequencies in ($\omega_i$ in rad/s)!), eigenVectors a numpy array containing the eigenvectors in every column
+#**belongsTo: MainSystem
+#**author: Johannes Gerstmayr, Michael Pieber
+#**example:
+#  #take any example from the Examples or TestModels folder, e.g., 'cartesianSpringDamper.py' and run it
+#  #specific example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# #
+# b0 = mbs.CreateMassPoint(referencePosition = [2,0,0],
+#                          initialVelocity = [2*0,5,0],
+#                          physicsMass = 1, gravity = [0,-9.81,0],
+#                          drawSize = 0.5, color=color4blue)
+# #
+# oGround = mbs.AddObject(ObjectGround())
+# #add vertical spring
+# oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
+#                              localPosition0=[2,1,0],
+#                              localPosition1=[0,0,0],
+#                              stiffness=1e4, damping=1e2,
+#                              drawSize=0.2)
+# #
+# mbs.Assemble()
+# #
+# [eigenvalues, eigenvectors] = mbs.ComputeODE2Eigenvalues()
+#  #==>eigenvalues contain the eigenvalues of the ODE2 part of the system in the current configuration
+def ComputeODE2Eigenvalues(mbs, 
+                           simulationSettings = exudyn.SimulationSettings(),
+                           useSparseSolver = False, numberOfEigenvalues = 0, constrainedCoordinates=[],
+                           convert2Frequencies = False, useAbsoluteValues = True, 
+                           computeComplexEigenvalues = False,
+                           ignoreAlgebraicEquations=False, singularValuesTolerance=1e-12):
+
+    store = DeactivateWritingOfSolvers(simulationSettings)
+
+    try:
+        from scipy.linalg import eigh, eig, svd  #eigh for symmetric matrices, positive definite; eig for standard eigen value problems
+        from scipy.sparse.linalg import eigsh #eigh for symmetric matrices, positive definite
+        from scipy.sparse import csr_matrix
+    except:
+        raise ValueError('ComputeODE2Eigenvalues: missing scipy package; install with: pip install scipy')
+
+    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
+    staticSolver = exudyn.MainSolverStatic()
+
+    #initialize solver with initial values
+    staticSolver.InitializeSolver(mbs, simulationSettings)
+
+    nODE2 = staticSolver.GetODE2size()
+    nODE1 = staticSolver.GetODE1size()
+    nAE = staticSolver.GetAEsize()
+    if nODE1 != 0:
+        print('ComputeODE2Eigenvalues: not implemented for ODE1 coordinates; results may be wrong and solver may fail')
+
+    staticSolver.ComputeMassMatrix(mbs)
+    Mode2 = staticSolver.GetSystemMassMatrix()
+
+    #compute ODE2 part of jacobian ==> stored internally in solver
+    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
+                                        scalarFactor_ODE2_t=0, 
+                                        scalarFactor_ODE1=0)    #could be 1 to include ODE1 part
+    if nAE != 0:
+        #compute AE part of jacobian if needed for constraint projection
+        staticSolver.ComputeJacobianAE(mbs, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., 
+                                       scalarFactor_ODE1=0., #could be 1 to include ODE1 part
+                                       velocityLevel=False)          
+    
+    jacobian = staticSolver.GetSystemJacobian() #read out stored jacobian; includes ODE2, ODE1 and nAE part
+
+    #obtain ODE2 part from jacobian == stiffness matrix
+    Kode2 = jacobian[0:nODE2,0:nODE2]
+
+    if computeComplexEigenvalues:
+        #compute damping matrix
+        staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=0,
+                                                scalarFactor_ODE2_t=-1, 
+                                                scalarFactor_ODE1=0)    #could be 1 to include ODE1 part
+        jacobianD = staticSolver.GetSystemJacobian() #read out stored jacobian; includes ODE2, ODE1 and nAE part
+        Dode2 = jacobianD[0:nODE2,0:nODE2]
+
+    remappingIndices = np.arange(nODE2) #maps new coordinates to original (full) ones
+    if constrainedCoordinates != []:
+        Mode2 = np.delete(np.delete(Mode2, constrainedCoordinates, 0), constrainedCoordinates, 1)
+        Kode2 = np.delete(np.delete(Kode2, constrainedCoordinates, 0), constrainedCoordinates, 1)
+        if computeComplexEigenvalues:
+            Dode2 = np.delete(np.delete(Dode2, constrainedCoordinates, 0), constrainedCoordinates, 1)
+        
+        remappingIndices = np.delete(remappingIndices, constrainedCoordinates)
+
+    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
+    RestoreSimulationSettings(simulationSettings, store)
+
+    if nAE != 0 and not ignoreAlgebraicEquations and constrainedCoordinates != []:
+        raise ValueError('ComputeODE2Eigenvalues: in case of algebraic equations, either ignoreAlgebraicEquations=True or constrainedCoordinates=[]')
+
+
+    if constrainedCoordinates != [] or nAE == 0 or ignoreAlgebraicEquations:
+        if not useSparseSolver:
+            if not computeComplexEigenvalues:
+                [eigenValuesUnsorted, eigenVectors] = eigh(Kode2, Mode2) #this gives omega^2 ... squared eigen frequencies (rad/s)
+            else:
+                #complex eigenvalues
+                B = np.block([[                  Kode2, Dode2     ],
+                              [np.zeros((nODE2,nODE2)),-Mode2     ]])
+            
+                A = np.block([[np.zeros((nODE2,nODE2)), Mode2                    ],
+                              [                  Mode2, np.zeros((nODE2,nODE2))]])                
+                Amod = -np.dot(np.linalg.inv(A),B)
+                [eigenValuesUnsorted, eigenVectors] = eig(Amod)
+            
+            if useAbsoluteValues:
+                sortIndices = np.argsort(abs(eigenValuesUnsorted)) #get resorting index
+                eigenValues = np.sort(a=abs(eigenValuesUnsorted)) #eigh returns unsorted eigenvalues...
+            else:
+                sortIndices = np.argsort(eigenValuesUnsorted) #get resorting index
+                eigenValues = np.sort(a=eigenValuesUnsorted) #eigh returns unsorted eigenvalues...
+            if numberOfEigenvalues > 0:
+                eigenValues = eigenValues[0:numberOfEigenvalues]
+                sortIndices = sortIndices[0:numberOfEigenvalues]
+            eigenVectors = eigenVectors[:,sortIndices] #eigenvectors are given in columns!
+        else:
+            if computeComplexEigenvalues:
+                raise ValueError('ComputeODE2Eigenvalues: computeComplexEigenvalues must be False with sparse solvers')
+            if numberOfEigenvalues == 0: #compute all eigenvalues
+                numberOfEigenvalues = nODE2
+    
+            Kcsr = csr_matrix(Kode2)
+            Mcsr = csr_matrix(Mode2)
+    
+            #use "LM" (largest magnitude), but shift-inverted mode with sigma=0, to find the zero-eigenvalues:
+            #see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html
+            [eigenValues, eigenVectors] = eigsh(A=Kcsr, k=numberOfEigenvalues, M=Mcsr, 
+                                       which='LM', sigma=0, mode='normal') 
+    
+            #sort eigenvalues
+            if useAbsoluteValues:
+                sortIndices = np.argsort(abs(eigenValues)) #get resorting index
+                eigenValues = np.sort(a=abs(eigenValues))
+            else:
+                sortIndices = np.argsort(eigenValues) #get resorting index
+                eigenValues = np.sort(a=eigenValues)
+            eigenVectors = eigenVectors[:,sortIndices] #eigenvectors are given in columns!
+
+        eigenVectorsNew = np.zeros((nODE2,numberOfEigenvalues))
+        if constrainedCoordinates != []:
+            # print('remap=', remappingIndices)
+            for i in range(numberOfEigenvalues):
+                eigenVectorsNew[remappingIndices,i] = eigenVectors[:,i]
+            eigenVectors = eigenVectorsNew
+    else: #this includes general constraints and requires different solvers
+                             
+        if useSparseSolver:
+            raise ValueError('ComputeODE2Eigenvalues: in case of algebraic equations and ignoreAlgebraicEquations=False, useSparseSolver must be False')
+        #use SVD to project equations into nullspace
+        #constraint jacobian:
+        C = jacobian[0:nODE2,nODE2+nODE1:]
+        
+        #compute SVD; D includes singular values
+        [U,D,V] = svd(C)
+        
+        nnz = (abs(D) > singularValuesTolerance).sum() #size of constraints, often number of cols of C
+        
+        nullspace = U[:,nnz:].T #U[nnz:]
+        Knullspace = nullspace@Kode2@nullspace.T
+        Mnullspace = nullspace@Mode2@nullspace.T
+        nODE2ns = Knullspace.shape[0]
+            
+        if computeComplexEigenvalues:
+            Dnullspace = nullspace@Dode2@nullspace.T
+            #A*q_t + B*q=0 => q=[x,v]
+            #[0  M] [x_t]   [K  D] [x]
+            #[    ]*[   ] + [    ]*[ ] = 0
+            #[I  0] [v_t]   [0 -I] [v]
+            #complex eigenvalues
+            B = np.block([[                 Knullspace,  Dnullspace                   ],
+                          [np.zeros((nODE2ns,nODE2ns)), -Mnullspace                   ]])
+        
+            A = np.block([[np.zeros((nODE2ns,nODE2ns)), Mnullspace                 ],
+                          [                 Mnullspace, np.zeros((nODE2ns,nODE2ns))]])                
+            Amod = -np.dot(np.linalg.inv(A),B)
+            [eigenValuesUnsorted, eigenVectorsReduced] = eig(Amod)
+        else:
+            [eigenValuesUnsorted, eigenVectorsReduced] = eigh(Knullspace,Mnullspace)
+            
+        if useAbsoluteValues:
+            sortIndices = np.argsort(abs(eigenValuesUnsorted)) #get resorting index
+            eigenValues = np.sort(a=abs(eigenValuesUnsorted)) #eigh returns unsorted eigenvalues...
+        else:
+            sortIndices = np.argsort(eigenValuesUnsorted) #get resorting index
+            eigenValues = np.sort(a=eigenValuesUnsorted) #eigh returns unsorted eigenvalues...
+
+        if numberOfEigenvalues > 0:
+            eigenValues = eigenValues[0:numberOfEigenvalues]
+            sortIndices = sortIndices[0:numberOfEigenvalues]
+        eigenVectorsReduced = eigenVectorsReduced[:,sortIndices] #eigenvectors are given in columns!
+
+        if computeComplexEigenvalues:
+            eigenVectors = np.block([nullspace.T, nullspace.T]) @ eigenVectorsReduced
+        else:
+            eigenVectors = nullspace.T @ eigenVectorsReduced
+
+
+
+    if convert2Frequencies:
+        eigenFrequencies = np.sqrt(eigenValues)/(2*np.pi)
+        return [eigenFrequencies, eigenVectors]
+    else:
+        return [eigenValues, eigenVectors]
+
+    
+
+#**function: compute system DOF numerically, considering Gr{\"u}bler-Kutzbach formula as well as redundant constraints; uses numpy matrix rank or singular value decomposition of scipy (useSVD=True)
+#**input:
+#  mbs: MainSystem for which DOF shall be computed
+#  simulationSettings: used e.g. for settings regarding numerical differentiation; default settings may be used in most cases
+#  threshold: threshold factor for singular values which estimate the redundant constraints
+#  useSVD: use singular value decomposition directly, also showing SVD values if verbose=True
+#  verbose: if True, it will show the singular values and one may decide if the threshold shall be adapted
+#**output: dict; returns dictionary with key words 'degreeOfFreedom', 'redundantConstraints', 'nODE2', 'nODE1', 'nAE', 'nPureAE', where: degreeOfFreedom = the system degree of freedom computed numerically, redundantConstraints=the number of redundant constraints, nODE2=number of ODE2 coordinates, nODE1=number of ODE1 coordinates, nAE=total number of constraints, nPureAE=number of constraints on algebraic variables (e.g., lambda=0) that are not coupled to ODE2 coordinates
+#**notes: this approach could possibly fail with special constraints! Currently only works with dense matrices, thus it will be slow for larger systems
+#**belongsTo: MainSystem
+#**example:
+# import exudyn as exu
+# from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
+# import numpy as np
+# SC = exu.SystemContainer()
+# mbs = SC.AddSystem()
+# #
+# b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000, 
+#                                                  sideLengths=[1,0.1,0.1]),
+#                          referencePosition = [6,0,0],
+#                          initialAngularVelocity = [0,8,0],
+#                          gravity = [0,-9.81,0],
+#                          graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1], 
+#                                                                       color=color4orange)])
+# oGround = mbs.AddObject(ObjectGround())
+# mbs.CreateGenericJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
+#                        constrainedAxes=[1,1,1, 1,0,0],
+#                        rotationMatrixAxes=RotationMatrixX(0.125*pi), #tilt axes
+#                        useGlobalFrame=True, axesRadius=0.02, axesLength=0.2)
+# #
+# mbs.Assemble()
+# dof = mbs.ComputeSystemDegreeOfFreedom(verbose=1)['degreeOfFreedom'] #print out details
+def ComputeSystemDegreeOfFreedom(mbs, 
+                simulationSettings = exudyn.SimulationSettings(),
+                threshold = 1e-12, verbose=False, useSVD=False):
+    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
+    
+    store = DeactivateWritingOfSolvers(simulationSettings)
+
+    staticSolver = exudyn.MainSolverStatic()
+    #initialize solver with initial values
+    staticSolver.InitializeSolver(mbs, simulationSettings)
+
+    nODE2 = staticSolver.GetODE2size()
+    nODE1 = staticSolver.GetODE1size()
+    if nODE1 != 0:
+        print('WARNING: ComputeSystemDegreeOfFreedom(...) not suitable in case of ODE1 coordinates; ODE1 coordinates will not count as additional DOF!')
+    nODE12 = nODE2+nODE1
+    nAE = staticSolver.GetAEsize()
+
+    #reset jacobian    
+    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
+                                        scalarFactor_ODE2_t=0, 
+                                        scalarFactor_ODE1=0)    #compute ODE2 part of jacobian ==> stored internally in solver
+    staticSolver.ComputeJacobianAE(mbs, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., velocityLevel=False)
+    jacobian = staticSolver.GetSystemJacobian()#.round(20) #read out stored jacobian
+
+    Code2 = jacobian[0:nODE2, nODE12:]    #C_q: constraint jacobian
+    Cae = jacobian[nODE12:,nODE12:]       #C_lambda
+    Call =  jacobian[:, nODE12:]
+    
+    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
+    #restore old settings:
+    RestoreSimulationSettings(simulationSettings, store)
+    
+    if verbose == 2:
+        print('Code2=\n', Code2, sep='')
+        print('Cae  =\n', Cae, sep='')
+
+    if useSVD:
+        try:
+            from scipy.linalg import svdvals#, svd
+        except:
+            raise ValueError('ComputeSystemDegreeOfFreedom: missing scipy package; install with: pip install scipy')
+
+    
+    nRedundant = 0
+    nPureAE = 0
+    if nAE != 0:
+
+        if useSVD:
+            #s = svd(Call, compute_uv=False, full_matrices=False)#, lapack_driver='gesvd')
+            s = svdvals(Call)
+    
+            if verbose:
+                print('singular values ODE2+AE=',s)
+    
+            sAE = svdvals(Cae)
+            #sAE = svd(Cae, compute_uv=False, full_matrices=False)#, lapack_driver='gesvd')
+    
+            if verbose:
+                print('singular values pure AE=',sAE)
+            
+            nRedundant = (abs(s) <= threshold).sum() #counts True=1, False=0
+            #these are constraints on AE coordinates, which do not count as constraints!
+            nPureAE = (abs(sAE) > threshold).sum() #counts True=1, False=0
+        else:
+            nRedundant = nAE - np.linalg.matrix_rank(Call)
+            nPureAE = np.linalg.matrix_rank(Cae)
+
+    dof = nODE2-(nAE-nPureAE)+nRedundant
+    if verbose:
+        print('ODE2 coordinates          =',nODE2)
+        print('total constraints         =',nAE)
+        print('redundant constraints     =',nRedundant)
+        print('pure algebraic constraints=',nPureAE)
+        print('degree of freedom         =',dof)
+
+    #return [dof, nRedundant, nODE2, nODE1, nAE, nPureAE] #old mode
+    return {'degreeOfFreedom':dof, 
+            'redundantConstraints':nRedundant, 
+            'nODE2':nODE2, 'nODE1':nODE1, 
+            'nAE':nAE, 'nPureAE':nPureAE}
+
+
+    
+#**function: helper function for solvers to check e.g. if high number of memory allocations happened during simulation
+#            This can happen, if large amount of sensors are attached and output is written in every time step
+#**input: stat=exudyn.InfoStat() from previous step, numberOfEvaluations is a counter which is proportional to number of RHS evaluations in method
+def CheckSolverInfoStatistics(solverName, infoStat, numberOfEvaluations):
+    stat = np.array(exudyn.InfoStat(False)) - np.array(infoStat)
+
+    newCnt = max(stat[0],stat[2],stat[4]) #array, vector, matrix new counts
+
+    if newCnt > solverCheckMemoryAllocationsThreshold and newCnt >= numberOfEvaluations:
+        exudyn.Print("WARNING: "+solverName+" detected large amount ("+str(newCnt)+") of memory allocations, which seem to occur in every time step; this may be due to user functions; solver may be slow")
+
+    #print("newcnt=", newCnt)
+
+#%%+++++++++++++++++++
+if __name__ == '__main__':
+    import exudyn.demos as demos
+    if True:
+        [mbs, SC] = demos.Demo1(False)
+        res = exudyn.ComputeSystemDegreeOfFreedom(mbs, verbose=True)
+        print('Demo1 dof=',res['degreeOfFreedom'],'\n') #2 DOF (2D mass point freely moving)
+
+    #takes some seconds to compute:
+    if True:
+        [mbs, SC] = demos.Demo2(False)
+        res = exudyn.ComputeSystemDegreeOfFreedom(mbs)
+        print('Demo2=',res,'\n') #12*3=36 (12 bodies with 12 spherical joints)
+    
+        res = exudyn.ComputeSystemDegreeOfFreedom(mbs, verbose=True, useSVD=True)
+        print('Demo2 using SVD=',res) #12*3=36 (12 bodies with 12 spherical joints)
+
+
+    #3D rigid-body with revolute joint and spring, same as in TestModels/ComputeODE2AEeigenvaluesTest.py
+    #compared to analytical solution
+    if True:
+        from exudyn.utilities import *
+        import numpy as np
+
+        SC = exudyn.SystemContainer()
+        mbs = SC.AddSystem()
+
+        beamL=0.1 #in m
+        beamW=0.01
+        beamH=0.001
+        rho=5000 #kg/m**3
+        springL=0.02 #in m
+        springK=1e1 #in N/m
+    
+        oGround = mbs.AddObject(ObjectGround())
+    
+        inertiaCuboid=InertiaCuboid(density=rho,
+                                sideLengths=[beamL,beamH,beamW])
+    
+        bBeam = mbs.CreateRigidBody(inertia = inertiaCuboid,
+                                referencePosition = [beamL*0.5,0,0],
+                                gravity = [0,-9.81*0,0],
+                                graphicsDataList = [GraphicsDataOrthoCubePoint(size=[beamL,beamH,beamW],
+                                color=color4orange)])
+        mBeamRight = mbs.AddMarker(MarkerBodyRigid(bodyNumber=bBeam, localPosition=[beamL*0.5,0,0]))
+
+        mbs.CreateGenericJoint(bodyNumbers= [oGround,bBeam], position= [0.,0.,0.], 
+                                      rotationMatrixAxes= np.eye(3), constrainedAxes= [1,1,1,1,1,0], 
+                                      axesRadius=0.001, axesLength= 0.01, color= color4default)
+    
+        markerToConnect = mbs.AddMarker(MarkerBodyRigid(bodyNumber=oGround, localPosition=[beamL,-springL,0])) 
+    
+        mbs.AddObject(CartesianSpringDamper(markerNumbers=[markerToConnect,mBeamRight],
+                                            stiffness=[0,springK,0],
+                                            damping=[0,0,0],
+                                            offset=[0,springL,0],
+                                            visualization=VObjectConnectorCartesianSpringDamper(show=True,drawSize=0.01)
+                                            ))    
+        mbs.Assemble()
+        [ew, ev] = mbs.ComputeODE2Eigenvalues()
+
+        evNumerical = np.sqrt(ew[0]) / (2*np.pi)
+        
+        thetaZZ=inertiaCuboid.Translated([-beamL/2,0,0]).Inertia()[2,2]
+        evAnalytical = np.sqrt( springK*beamL**2/thetaZZ ) / (2*np.pi)
+
+        print('numerical eigenvalues in Hz:',evNumerical)
+        print('analytical eigenvalues in Hz:',evAnalytical)
+        print('error eigenvalues:', (evAnalytical-evNumerical)/evAnalytical)
+
```

## exudyn/symbolic.pyi

 * *Ordering differences only*

```diff
@@ -1,241 +1,241 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is the EXUDYN stub file initialization
-#
-# Author:   Johannes Gerstmayr
-# Date:     2023-05-09
-#
-# Notes:    Under development; see https://peps.python.org/pep-0484/#stub-files
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#from typing import Dict, List, Optional
-
-from typing import (
-    Annotated, 
-    Any,
-    # ByteString,
-    # Callable,
-    # Container,
-    Callable,
-    Dict,
-    # Generic,
-    # IO,
-    # Iterable,
-    # Iterator,
-    List,
-    Literal,
-    # Mapping,
-    # NoReturn,
-    # Optional,
-    overload,
-    # Sequence,
-    # Sized,
-    # SupportsComplex,
-    # SupportsFloat,
-    # SupportsInt,
-    # Text,
-    Tuple, #for Tuple[int, int]
-    # Type,
-    TypeVar,
-    Union,
-)
-from numpy.typing import ArrayLike, NDArray
-from enum import Enum
-import numpy as np
-
-
-#DType = TypeVar("DType", bound=np.generic)
-# NPreal3D = Annotated[NDArray[float], Literal[3]]
-# NPint3D = Annotated[NDArray[int], Literal[3]]
-
-#type variables for size in numpy arrays
-T1 = TypeVar("T1", bound=int)
-T2 = TypeVar("T2", bound=int)
-
-# Dimension types represented as typles
-Shape = Tuple
-Shape1D = Shape[T1]
-Shape2D = Shape[T1, T2]
-# Shape3D = Shape[T1, T2, T3]
-# ShapeND = Shape[T1, ...]
-# ShapeNDType = TypeVar("ShapeNDType", bound=ShapeND)
-
-#LENGTH = Literal[2]
-#NDArray[Shape2D[3,3], np.float64]
-
-
-import exudyn
-from exudyn import (ObjectIndex, NodeIndex, MarkerIndex, LoadIndex, SensorIndex)
-
-from exudyn.graphicsDataUtilities import color4red, color4default
-
-
-
-#stub information for class Real functions
-class Real:
-    @overload
-    def __init__(self, value: float) -> None: ...
-    @overload
-    def __init__(self, name: str, value: float) -> None: ...
-    @overload
-    def SetValue(self, valueInit: float) -> None: ...
-    @overload
-    def Evaluate(self) -> float: ...
-    @overload
-    def Diff(self, var: Real) -> float: ...
-    value:float
-    @overload
-    def __float__(self) -> float: ...
-    @overload
-    def __str__(self) -> str: ...
-    @overload
-    def __repr__(self) -> str: ...
-
-#functions directly in symbolic module:
-@overload
-def isfinite(x: Real) -> Real: ...
-@overload
-def abs(x: Real) -> Real: ...
-@overload
-def round(x: Real) -> Real: ...
-@overload
-def ceil(x: Real) -> Real: ...
-@overload
-def floor(x: Real) -> Real: ...
-@overload
-def sqrt(x: Real) -> Real: ...
-@overload
-def exp(x: Real) -> Real: ...
-@overload
-def log(x: Real) -> Real: ...
-@overload
-def sin(x: Real) -> Real: ...
-@overload
-def cos(x: Real) -> Real: ...
-@overload
-def tan(x: Real) -> Real: ...
-@overload
-def asin(x: Real) -> Real: ...
-@overload
-def acos(x: Real) -> Real: ...
-@overload
-def atan(x: Real) -> Real: ...
-@overload
-def sinh(x: Real) -> Real: ...
-@overload
-def cosh(x: Real) -> Real: ...
-@overload
-def tanh(x: Real) -> Real: ...
-@overload
-def asinh(x: Real) -> Real: ...
-@overload
-def acosh(x: Real) -> Real: ...
-@overload
-def atanh(x: Real) -> Real: ...
-@overload
-def sign(x: Real) -> Real: ...
-@overload
-def Not(x: Real) -> Real: ...
-@overload
-def min(x: Real, y: Real) -> Real: ...
-@overload
-def max(x: Real, y: Real) -> Real: ...
-@overload
-def mod(x: Real, y: Real) -> Real: ...
-@overload
-def pow(x: Real, y: Real) -> Real: ...
-@overload
-def max(x: Real, y: Real) -> Real: ...
-@overload
-def IfThenElse(condition: Real, ifTrue: Real, ifFalse: Real) -> Real: ...
-@overload
-def SetRecording(flag: bool) -> None: ...
-@overload
-def GetRecording() -> bool: ...
-
-
-#stub information for class Vector functions
-class Vector:
-    @overload
-    def __init__(self, vector: List[float]) -> None: ...
-    @overload
-    def __init__(self, name: str, vector: List[float]) -> None: ...
-    @overload
-    def Evaluate(self) -> List[float]: ...
-    @overload
-    def SetVector(self, vector: Vector) -> None: ...
-    @overload
-    def NumberOfItems(self) -> int: ...
-    @overload
-    def __setitem__(self, index: Real) -> Real: ...
-    @overload
-    def NormL2(self) -> Real: ...
-    @overload
-    def MultComponents(self, other: Vector) -> Real: ...
-    @overload
-    def __getitem__(self, index: Real) -> Real: ...
-    @overload
-    def __str__(self) -> str: ...
-    @overload
-    def __repr__(self) -> str: ...
-
-#stub information for class Matrix functions
-class Matrix:
-    @overload
-    def __init__(self, matrix: List[List[float]]) -> None: ...
-    @overload
-    def __init__(self, name: str, matrix: List[List[float]]) -> None: ...
-    @overload
-    def Evaluate(self) -> List[float]: ...
-    @overload
-    def SetMatrix(self, matrix: NDArray[Any, float]) -> None: ...
-    @overload
-    def NumberOfRows(self) -> int: ...
-    @overload
-    def NumberOfColumns(self) -> int: ...
-    @overload
-    def __setitem__(self, row: Real, column: Real) -> Real: ...
-    @overload
-    def __getitem__(self, row: Real, column: Real) -> Real: ...
-    @overload
-    def __str__(self) -> str: ...
-    @overload
-    def __repr__(self) -> str: ...
-
-#stub information for class VariableSet functions
-class VariableSet:
-    @overload
-    def Add(self, name: str, value: float) -> None: ...
-    @overload
-    def Add(self, namedReal: Real) -> None: ...
-    @overload
-    def Set(self, name: str, value: float) -> None: ...
-    @overload
-    def Get(self, name: str) -> Real: ...
-    @overload
-    def Exists(self, name: str) -> bool: ...
-    @overload
-    def Reset(self) -> None: ...
-    @overload
-    def NumberOfItems(self, name: str) -> bool: ...
-    @overload
-    def GetNames(self) -> List[str]: ...
-    @overload
-    def __setitem__(self, name: str, value: float) -> None: ...
-    @overload
-    def __getitem__(self, name: str) -> Real: ...
-    @overload
-    def __str__(self) -> str: ...
-    @overload
-    def __repr__(self) -> str: ...
-
-#stub information for class UserFunction functions
-class UserFunction:
-    @overload
-    def SetUserFunctionFromDict(self, mainSystem: MainSystem, fcnDict: dict, itemIndex: ItemIndex, userFunctionName: str) -> None: ...
-    @overload
-    def __repr__(self) -> str: ...
-    @overload
-    def __str__(self) -> str: ...
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is the EXUDYN stub file initialization
+#
+# Author:   Johannes Gerstmayr
+# Date:     2023-05-09
+#
+# Notes:    Under development; see https://peps.python.org/pep-0484/#stub-files
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#from typing import Dict, List, Optional
+
+from typing import (
+    Annotated, 
+    Any,
+    # ByteString,
+    # Callable,
+    # Container,
+    Callable,
+    Dict,
+    # Generic,
+    # IO,
+    # Iterable,
+    # Iterator,
+    List,
+    Literal,
+    # Mapping,
+    # NoReturn,
+    # Optional,
+    overload,
+    # Sequence,
+    # Sized,
+    # SupportsComplex,
+    # SupportsFloat,
+    # SupportsInt,
+    # Text,
+    Tuple, #for Tuple[int, int]
+    # Type,
+    TypeVar,
+    Union,
+)
+from numpy.typing import ArrayLike, NDArray
+from enum import Enum
+import numpy as np
+
+
+#DType = TypeVar("DType", bound=np.generic)
+# NPreal3D = Annotated[NDArray[float], Literal[3]]
+# NPint3D = Annotated[NDArray[int], Literal[3]]
+
+#type variables for size in numpy arrays
+T1 = TypeVar("T1", bound=int)
+T2 = TypeVar("T2", bound=int)
+
+# Dimension types represented as typles
+Shape = Tuple
+Shape1D = Shape[T1]
+Shape2D = Shape[T1, T2]
+# Shape3D = Shape[T1, T2, T3]
+# ShapeND = Shape[T1, ...]
+# ShapeNDType = TypeVar("ShapeNDType", bound=ShapeND)
+
+#LENGTH = Literal[2]
+#NDArray[Shape2D[3,3], np.float64]
+
+
+import exudyn
+from exudyn import (ObjectIndex, NodeIndex, MarkerIndex, LoadIndex, SensorIndex)
+
+from exudyn.graphicsDataUtilities import color4red, color4default
+
+
+
+#stub information for class Real functions
+class Real:
+    @overload
+    def __init__(self, value: float) -> None: ...
+    @overload
+    def __init__(self, name: str, value: float) -> None: ...
+    @overload
+    def SetValue(self, valueInit: float) -> None: ...
+    @overload
+    def Evaluate(self) -> float: ...
+    @overload
+    def Diff(self, var: Real) -> float: ...
+    value:float
+    @overload
+    def __float__(self) -> float: ...
+    @overload
+    def __str__(self) -> str: ...
+    @overload
+    def __repr__(self) -> str: ...
+
+#functions directly in symbolic module:
+@overload
+def isfinite(x: Real) -> Real: ...
+@overload
+def abs(x: Real) -> Real: ...
+@overload
+def round(x: Real) -> Real: ...
+@overload
+def ceil(x: Real) -> Real: ...
+@overload
+def floor(x: Real) -> Real: ...
+@overload
+def sqrt(x: Real) -> Real: ...
+@overload
+def exp(x: Real) -> Real: ...
+@overload
+def log(x: Real) -> Real: ...
+@overload
+def sin(x: Real) -> Real: ...
+@overload
+def cos(x: Real) -> Real: ...
+@overload
+def tan(x: Real) -> Real: ...
+@overload
+def asin(x: Real) -> Real: ...
+@overload
+def acos(x: Real) -> Real: ...
+@overload
+def atan(x: Real) -> Real: ...
+@overload
+def sinh(x: Real) -> Real: ...
+@overload
+def cosh(x: Real) -> Real: ...
+@overload
+def tanh(x: Real) -> Real: ...
+@overload
+def asinh(x: Real) -> Real: ...
+@overload
+def acosh(x: Real) -> Real: ...
+@overload
+def atanh(x: Real) -> Real: ...
+@overload
+def sign(x: Real) -> Real: ...
+@overload
+def Not(x: Real) -> Real: ...
+@overload
+def min(x: Real, y: Real) -> Real: ...
+@overload
+def max(x: Real, y: Real) -> Real: ...
+@overload
+def mod(x: Real, y: Real) -> Real: ...
+@overload
+def pow(x: Real, y: Real) -> Real: ...
+@overload
+def max(x: Real, y: Real) -> Real: ...
+@overload
+def IfThenElse(condition: Real, ifTrue: Real, ifFalse: Real) -> Real: ...
+@overload
+def SetRecording(flag: bool) -> None: ...
+@overload
+def GetRecording() -> bool: ...
+
+
+#stub information for class Vector functions
+class Vector:
+    @overload
+    def __init__(self, vector: List[float]) -> None: ...
+    @overload
+    def __init__(self, name: str, vector: List[float]) -> None: ...
+    @overload
+    def Evaluate(self) -> List[float]: ...
+    @overload
+    def SetVector(self, vector: Vector) -> None: ...
+    @overload
+    def NumberOfItems(self) -> int: ...
+    @overload
+    def __setitem__(self, index: Real) -> Real: ...
+    @overload
+    def NormL2(self) -> Real: ...
+    @overload
+    def MultComponents(self, other: Vector) -> Real: ...
+    @overload
+    def __getitem__(self, index: Real) -> Real: ...
+    @overload
+    def __str__(self) -> str: ...
+    @overload
+    def __repr__(self) -> str: ...
+
+#stub information for class Matrix functions
+class Matrix:
+    @overload
+    def __init__(self, matrix: List[List[float]]) -> None: ...
+    @overload
+    def __init__(self, name: str, matrix: List[List[float]]) -> None: ...
+    @overload
+    def Evaluate(self) -> List[float]: ...
+    @overload
+    def SetMatrix(self, matrix: NDArray[Any, float]) -> None: ...
+    @overload
+    def NumberOfRows(self) -> int: ...
+    @overload
+    def NumberOfColumns(self) -> int: ...
+    @overload
+    def __setitem__(self, row: Real, column: Real) -> Real: ...
+    @overload
+    def __getitem__(self, row: Real, column: Real) -> Real: ...
+    @overload
+    def __str__(self) -> str: ...
+    @overload
+    def __repr__(self) -> str: ...
+
+#stub information for class VariableSet functions
+class VariableSet:
+    @overload
+    def Add(self, name: str, value: float) -> None: ...
+    @overload
+    def Add(self, namedReal: Real) -> None: ...
+    @overload
+    def Set(self, name: str, value: float) -> None: ...
+    @overload
+    def Get(self, name: str) -> Real: ...
+    @overload
+    def Exists(self, name: str) -> bool: ...
+    @overload
+    def Reset(self) -> None: ...
+    @overload
+    def NumberOfItems(self, name: str) -> bool: ...
+    @overload
+    def GetNames(self) -> List[str]: ...
+    @overload
+    def __setitem__(self, name: str, value: float) -> None: ...
+    @overload
+    def __getitem__(self, name: str) -> Real: ...
+    @overload
+    def __str__(self) -> str: ...
+    @overload
+    def __repr__(self) -> str: ...
+
+#stub information for class UserFunction functions
+class UserFunction:
+    @overload
+    def SetUserFunctionFromDict(self, mainSystem: MainSystem, fcnDict: dict, itemIndex: ItemIndex, userFunctionName: str) -> None: ...
+    @overload
+    def __repr__(self) -> str: ...
+    @overload
+    def __str__(self) -> str: ...
```

## exudyn/utilities.py

 * *Ordering differences only*

```diff
@@ -1,1300 +1,1300 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library
-#
-# Details:  Basic support functions for simpler creation of Exudyn models.
-#           Advanced functions for loading and animating solutions and for drawing a graph of the mbs system.
-#           This library requires numpy (as well as time and copy)
-#
-# Author:   Johannes Gerstmayr
-# Date:     2019-07-26 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# Utility functions and structures for Exudyn
-
-import numpy as np
-#import copy as copy #to be able to copy e.g. lists
-from math import sin, cos, pi, sqrt
-
-import exudyn
-from exudyn.basicUtilities import *
-from exudyn.advancedUtilities import *
-from exudyn.rigidBodyUtilities import *
-from exudyn.graphicsDataUtilities import *
-from exudyn.itemInterface import *
-
-#for compatibility with older models:
-from exudyn.beams import GenerateStraightLineANCFCable2D, GenerateSlidingJoint, GenerateAleSlidingJoint,\
-                         GenerateStraightBeam
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**function: function to hide all objects in mbs except for those listed in objectNumbers
-#**input: 
-#  mbs: mbs containing object
-#  objectNumbers: integer object number or list of object numbers to be shown; if empty list [], then all objects are shown
-#  showOthers: if True, then all other objects are shown again
-#**output: changes all colors in mbs, which is NOT reversible
-def ShowOnlyObjects(mbs, objectNumbers=[], showOthers=False):
-    if not isinstance(objectNumbers,list):
-        listObjects = [objectNumbers]
-    else:
-        listObjects = objectNumbers
-    isEmpty = len(listObjects) == 0
-    
-    for objectIndex in range(mbs.systemData.NumberOfObjects()):
-        oDict = mbs.GetObject(objectIndex)
-        flag = showOthers
-        if objectIndex in listObjects or isEmpty: #if no objects to show,  
-            flag = not showOthers
-        if 'Vshow' in oDict:
-            mbs.SetObjectParameter(objectIndex,'Vshow', flag)
-    mbs.SendRedrawSignal()
-
-#**function: highlight a certain item with number itemNumber; set itemNumber to -1 to show again all objects
-#**input: 
-#  mbs: mbs containing object
-#  itemNumbers: integer object/node/etc number to be highlighted
-#  itemType: type of items to be highlighted
-#  showNumbers: if True, then the numbers of these items are shown
-def HighlightItem(SC, mbs, itemNumber, itemType=exudyn.ItemType.Object, showNumbers=True):
-    SC.visualizationSettings.interactive.highlightItemIndex = itemNumber
-    SC.visualizationSettings.interactive.highlightItemType = itemType
-    if showNumbers and itemType == exudyn.ItemType.Node:
-        SC.visualizationSettings.nodes.showNumbers = True
-        SC.visualizationSettings.nodes.show = True
-    else:
-        SC.visualizationSettings.nodes.showNumbers = False
-    if showNumbers and itemType == exudyn.ItemType.Object:
-        SC.visualizationSettings.bodies.showNumbers = True
-        SC.visualizationSettings.connectors.showNumbers = True
-        SC.visualizationSettings.bodies.show = True
-        SC.visualizationSettings.connectors.show = True
-    else:
-        SC.visualizationSettings.bodies.showNumbers = False
-        SC.visualizationSettings.connectors.showNumbers = False
-    if showNumbers and itemType == exudyn.ItemType.Marker:
-        SC.visualizationSettings.markers.showNumbers = True
-        SC.visualizationSettings.markers.show = True
-    else:
-        SC.visualizationSettings.markers.showNumbers = False
-    if showNumbers and itemType == exudyn.ItemType.Load:
-        SC.visualizationSettings.loads.showNumbers = True
-        SC.visualizationSettings.loads.show = True
-    else:
-        SC.visualizationSettings.loads.showNumbers = False
-    if showNumbers and itemType == exudyn.ItemType.Sensor:
-        SC.visualizationSettings.sensors.showNumbers = True
-        SC.visualizationSettings.sensors.show = True
-    else:
-        SC.visualizationSettings.sensors.showNumbers = False
-
-    mbs.SendRedrawSignal()
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**function: internal function used for CreateDistanceSensor
-def __UFsensorDistance(mbs, t, sensorNumbers, factors, configuration):
-
-    generalContactIndex = int(factors[0])
-    dirSensor = factors[5:8]
-    markerNumber = int(factors[1])
-    hasRotation = False
-    if markerNumber != -1:
-        p0 = mbs.GetMarkerOutput(markerNumber, variableType=exudyn.OutputVariableType.Position)
-        hasRotation = ('Rigid' in mbs.GetMarker(markerNumber)['markerType'])
-        if hasRotation:
-            A0 = mbs.GetMarkerOutput(markerNumber, variableType=exudyn.OutputVariableType.RotationMatrix).reshape((3,3))
-            dirSensor = A0 @ dirSensor
-    else:
-        p0 = np.array(factors[2:5])
-
-    [minDistance, maxDistance, cylinderRadius, selectedTypeIndex, measureVelocity, graphicsObject, flags] = factors[8:15]
-    selectedTypeIndex = exudyn.ContactTypeIndex(int(selectedTypeIndex)) #only converts from int
-    measureVelocity = bool(measureVelocity)
-    graphicsObject = int(graphicsObject)
-
-    gContact = mbs.GetGeneralContact(generalContactIndex)
-    data = gContact.ShortestDistanceAlongLine(pStart = p0, direction = dirSensor, 
-                                           minDistance=minDistance, maxDistance=maxDistance,
-                                           cylinderRadius=cylinderRadius, asDictionary=(measureVelocity==True),
-                                           typeIndex=selectedTypeIndex,
-                                           )
-    if measureVelocity:
-        d = data['distance']
-        v = data['velocityAlongLine']
-        rv = [d, v]
-    else:
-        d = data
-        rv = [d]
-
-    if graphicsObject != -1:
-        factLen = 1
-        if int(flags) == 0:
-            factLen = 0
-
-        mbs.SetObjectParameter(graphicsObject,'referencePosition',p0 + factLen*(d*np.array(Normalize(dirSensor))) )
-        if hasRotation:
-            mbs.SetObjectParameter(graphicsObject,'referenceRotation', A0)
-            
-    return rv
-
-
-
-#**function: Add geometry for distance sensor given by points and triangles (point indices) to mbs; use a rigid body marker where the geometry is put on; 
-#           Creates a GeneralContact for efficient search on background. If you have several sets of points and trigs, first merge them or add them manually to the contact
-#**input: 
-#  mbs: MainSystem where contact is created
-#  meshPoints: list of points (3D), as returned by GraphicsData2PointsAndTrigs()
-#  meshTrigs: list of trigs (3 node indices each), as returned by GraphicsData2PointsAndTrigs()
-#  rigidBodyMarkerIndex: rigid body marker to which the triangles are fixed on (ground or moving object)
-#  searchTreeCellSize: size of search tree (X,Y,Z); use larger values in directions where more triangles are located
-#**output: int; returns ngc, which is the number of GeneralContact in mbs, to be used in CreateDistanceSensor(...); keep the gContact as deletion may corrupt data
-#**notes: should be used by CreateDistanceSensor(...) and AddLidar(...) for simple initialization of GeneralContact; old name: DistanceSensorSetupGeometry(...)
-#**belongsTo: MainSystem
-def CreateDistanceSensorGeometry(mbs, meshPoints, meshTrigs, rigidBodyMarkerIndex, searchTreeCellSize=[8,8,8]):
-    gContact = mbs.AddGeneralContact()
-    gContact.SetFrictionPairings(0*np.eye(1)) #may not be empty
-    gContact.SetSearchTreeCellSize(numberOfCells=searchTreeCellSize)
-    # [meshPoints, meshTrigs] = RefineMesh(meshPoints, meshTrigs) #just to have more triangles on floor
-    gContact.AddTrianglesRigidBodyBased(rigidBodyMarkerIndex=rigidBodyMarkerIndex,
-                                        contactStiffness=1, contactDamping=1, #dummy values
-                                        frictionMaterialIndex=0, pointList=meshPoints, triangleList=meshTrigs)
-    gContact.isActive=False #no contact computation; could also be done later on, if many moving objects are used ...
-    ngc = mbs.NumberOfGeneralContacts()-1
-    gContact = mbs.GetGeneralContact(ngc) #keeps reference to gContact, while other functions work with automatic ...
-
-    return ngc
-
-#**function: Function to create distance sensor based on GeneralContact in mbs; sensor can be either placed on absolute position or attached to rigid body marker; in case of marker, dirSensor is relative to the marker
-#**input:
-#  mbs: the MainSystem where distance sensor is created
-#  generalContactIndex: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
-#  positionOrMarker: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
-#  dirSensor: the direction (no need to normalize) along which the distance is measured (must not be normalized); in case of marker, the direction is relative to marker orientation if marker contains orientation (BodyRigid, NodeRigid)
-#  minDistance: the minimum distance which is accepted; smaller distance will be ignored
-#  maxDistance: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
-#  cylinderRadius: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
-#  selectedTypeIndex: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
-#  storeInternal: like with any SensorUserFunction, setting to True stores sensor data internally
-#  fileName: if defined, recorded data of SensorUserFunction is written to specified file
-#  measureVelocity: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
-#  addGraphicsObject: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
-#  drawDisplaced: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
-#  color: optional color for 'laser beam' to be drawn
-#**output: SensorIndex; creates sensor and returns according sensor number of SensorUserFunction
-#**notes: use generalContactIndex = CreateDistanceSensorGeometry(...) before to create GeneralContact module containing geometry; old name: AddDistanceSensor(...)
-#**belongsTo: MainSystem
-def CreateDistanceSensor(mbs, generalContactIndex,
-                      positionOrMarker, dirSensor, minDistance=-1e7, 
-                      maxDistance=1e7, cylinderRadius=0, 
-                      selectedTypeIndex=exudyn.ContactTypeIndex.IndexEndOfEnumList,
-                      storeInternal = False, fileName = '', measureVelocity = False,
-                      addGraphicsObject=False, drawDisplaced=True, color=color4red):
-    
-    markerNumber = -1
-    p0list = [0,0,0]
-    if type(positionOrMarker) == list or type(positionOrMarker) == np.ndarray:
-        p0list = list(positionOrMarker)
-    elif type(positionOrMarker)==exudyn.MarkerIndex:
-        markerNumber = float(int(positionOrMarker))
-        try:
-            p0list = mbs.GetMarkerOutput(markerNumber=positionOrMarker,variableType=exu.OutputVariableType.Position, configuration=exu.ConfigurationType.Reference)
-            p0list = list(p0list)
-        except:
-            p0list = [0,0,0] #this was just a trial, otherwise initialize with zeros (e.g. for special objects where this does not work)
-    else:
-        raise ValueError('CreateDistanceSensor: positionOrMarker must be either MarkerIndex or 3D position as list or numpy.array')
-
-    graphicsObject = -1 #signals that there is no graphics object
-    sign = 1.
-    if drawDisplaced:
-        sign = -1.
-    if addGraphicsObject:
-        if cylinderRadius == 0:
-            gData = GraphicsDataLine([[0,0,0],list(sign*np.array(dirSensor))], color = color)
-        else: 
-            gData = GraphicsDataCylinder([0,0,0],sign*np.array(dirSensor), radius=cylinderRadius, color = color)
-            
-        graphicsObject=mbs.AddObject(ObjectGround(referencePosition= p0list,
-                                      visualization=VObjectGround(graphicsData=[gData])))
-
-    flags = int(drawDisplaced)
-    dataUF = [float(generalContactIndex)]
-    dataUF += [markerNumber] + p0list + list(dirSensor)
-    dataUF += [ minDistance, maxDistance, cylinderRadius, float(int(selectedTypeIndex)), float(measureVelocity), float(int(graphicsObject)), float(flags)] 
-
-
-    sUF = mbs.AddSensor(SensorUserFunction(sensorNumbers=[], factors=dataUF,
-                                              storeInternal=True,
-                                              sensorUserFunction=__UFsensorDistance))
-
-    return sUF
-
-
-#**function: DEPRECATED: Internal SensorUserFunction, used in function AddSensorRecorder
-#**notes: Warning: this method is DEPRECATED, use storeInternal in Sensors, which is much more performant; Note, that a sensor usually just passes through values of an existing sensor, while recording the values to a numpy array row-wise (time in first column, data in remaining columns)
-def UFsensorRecord(mbs, t, sensorNumbers, factors, configuration):
-    iSensor = sensorNumbers[0]
-    val = mbs.GetSensorValues(iSensor, configuration=configuration) #get all values
-    if type(val) == float:# or type(x) == nd.float64:
-        val = np.array([val]) #for scalar values
-    ti = int((t+1e-9)/factors[0]) #add 1e-10 safety factor due to rounding errors when adding time steps (may lead to small errors after 1e7 steps)
-    if ti >= 0 and ti < len(mbs.variables['sensorRecord'+str(iSensor)]):
-        mbs.variables['sensorRecord'+str(iSensor)][ti,0] = t
-        mbs.variables['sensorRecord'+str(iSensor)][ti,1:] = val
-        
-    return val #return value usually not used further
-
-#**function: DEPRECATED: Add a SensorUserFunction object in order to record sensor output internally; this avoids creation of files for sensors, which can speedup and simplify evaluation in ParameterVariation and GeneticOptimization; values are stored internally in mbs.variables['sensorRecord'+str(sensorNumber)] where sensorNumber is the mbs sensor number
-#**input: 
-#  mbs: mbs containing object
-#  sensorNumber: integer sensor number to be recorded
-#  endTime: end time of simulation, as given in simulationSettings.timeIntegration.endTime 
-#  sensorsWritePeriod: as given in simulationSettings.solutionSettings.sensorsWritePeriod
-#  sensorOutputSize: size of sensor data: 3 for Displacement, Position, etc. sensors; may be larger for RotationMatrix or Coordinates sensors; check this size by calling mbs.GetSensorValues(sensorNumber)
-#**output: adds an according SensorUserFunction sensor to mbs; returns new sensor number; during initialization a new numpy array is allocated in  mbs.variables['sensorRecord'+str(sensorNumber)] and the information is written row-wise: [time, sensorValue1, sensorValue2, ...]
-#**notes: Warning: this method is DEPRECATED, use storeInternal in Sensors, which is much more performant; Note, that a sensor usually just passes through values of an existing sensor, while recording the values to a numpy array row-wise (time in first column, data in remaining columns)
-def AddSensorRecorder(mbs, sensorNumber, endTime, sensorsWritePeriod, sensorOutputSize=3):
-    print('WARNING: AddSensorRecorder is DEPRECATED, use sensors and set storeInternal=True to achieve similar functionality')
-    nSteps = int(endTime/sensorsWritePeriod)
-    mbs.variables['sensorRecord'+str(sensorNumber)] = np.zeros((nSteps+1,1+sensorOutputSize)) #time+3 sensor values
-
-    sUserRecord = mbs.AddSensor(SensorUserFunction(sensorNumbers=[sensorNumber], 
-                                                   factors=[sensorsWritePeriod],
-                                                   writeToFile=False,
-                                                   sensorUserFunction=UFsensorRecord))
-    
-    return sUserRecord    
-    
-    
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++++   LOAD SOLUTION AND ANIMATION   ++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: read coordinates solution file (exported during static or dynamic simulation with option exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName='...') into dictionary:
-#**input: 
-#  fileName: string containing directory and filename of stored coordinatesSolutionFile
-#  saveMode: if True, it loads lines directly to load inconsistent lines as well; use this for huge files (>2GB); is slower but needs less memory!
-#  verbose: if True, some information is written when importing file (use for huge files to track progress)
-#  maxRows: maximum number of data rows loaded, if saveMode=True; use this for huge files to reduce loading time; set -1 to load all rows
-#  hasHeader: set to False, if file is expected to have no header; if False, then some error checks related to file header are not performed
-#**output: dictionary with 'data': the matrix of stored solution vectors, 'columnsExported': a list with integer values showing the exported sizes [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData], 'nColumns': the number of data columns and 'nRows': the number of data rows
-def LoadSolutionFile(fileName, safeMode=False, maxRows=-1, verbose=True, hasHeader=True):
-
-    #check if is binary or ASCII
-    isBinary = False
-    with open(fileName, 'r') as file:
-        data = np.fromfile(file, dtype=np.byte, count=6)
-        if data.size==6:
-            s = NumpyInt8ArrayToString(data)
-            if s=='EXUBIN':
-                isBinary=True
-
-    if isBinary:
-        return LoadBinarySolutionFile(fileName,maxRows,verbose)
-    
-    #read HEADER
-    if hasHeader:
-        with open(fileName) as fileRead:
-            # fileRead=open(fileName,'r') 
-            fileLines = []
-            fileLines += [fileRead.readline()]
-            fileLines += [fileRead.readline()]
-            fileLines += [fileRead.readline()]
-            fileLines += [fileRead.readline()]
-            fileLines += [fileRead.readline()]
-            # fileRead.close()
-    
-        if len(fileLines[4]) == 0:
-            raise ValueError('ERROR in LoadSolution: file empty or header missing')
-            
-        leftStr=fileLines[4].split('=')[0]
-        if leftStr[0:30] != '#number of written coordinates': 
-            raise ValueError('ERROR in LoadSolution: file header corrupted')
-    
-        columnsExported = eval(fileLines[4].split('=')[1]) #load according column information into vector: [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData]
-        nColumns = sum(columnsExported)
-
-    #read DATA
-    if not safeMode:
-        data = np.loadtxt(fileName, comments='#', delimiter=',')
-    else:
-        #alternative, but needs factor 5 times the memory of data loaded:
-        #  data = np.genfromtxt(fileName,comments='#',delimiter=',',invalid_raise=False)
-
-        with open(fileName) as file:
-            lines = file.readlines()
-        
-        if verbose: print('text file loaded ... converting ...')
-        
-        cntDataRows = 0
-        dataRowStart = -1
-        dataRowLast = 0
-
-        cnt = 0
-        cntComments = 0
-        for line in lines: 
-            if line[0]!='#': 
-                if dataRowStart == -1:
-                    dataRowStart = cnt
-                cntDataRows+=1
-                dataRowLast = cnt
-            else:
-                cntComments += 1
-            cnt+=1
-        
-        if verbose: print('found',cntComments,'lines with comments, which are ignored')
-            
-        if maxRows != -1 and cntDataRows > maxRows:
-            cntDataRows = maxRows
-        
-        if cntDataRows == 0 or dataRowStart == -1:
-            raise ValueError('LoadSolutionFile: no rows found')
-        else:
-            if verbose: print('data starts at ',dataRowStart, ', found ', cntDataRows, ' rows', sep='')
-
-        if verbose: print('check columns ...')
-        
-        cols = len(lines[dataRowStart].split(','))
-        if hasHeader:
-            if cols != nColumns+1:
-                raise ValueError('ERROR in LoadSolution: number of columns in first data row is inconsistent: got ',cols,' columns, but expected ', nColumns+1)
-        else:
-            nColumns=cols-1
-            columnsExported=[] #unknown ...
-            
-        #check last line, which may be incomplete:
-        #colsLastLine = len(lines[dataRowStart+cntDataRows-1].split(','))
-        colsLastLine = len(lines[dataRowLast].split(','))
-        skipLast = 0
-        if colsLastLine != cols:
-            if verbose: print('LoadSolution: WARNING number of columns in last data row is inconsistent; will be skipped')
-            skipLast = 1
-        
-        if verbose: print('file contains ',cntDataRows, ' rows and ', cols, ' columns (incl. time)',sep='')
-        
-        data = np.zeros((cntDataRows, nColumns+1))
-        
-        progress = 0
-        progressInfo = 5000000
-        skipLine = 0 #counter for skipping additional lines with comments
-        for i in range(cntDataRows-skipLast):
-            if verbose and progress>=progressInfo: #update progress
-                print('import data row', i, '/', cntDataRows)
-                progress = 0
-            progress+=nColumns
-            
-            while i+dataRowStart+skipLine<len(lines) and lines[i+dataRowStart+skipLine][0]=='#':
-                skipLine += 1
-            
-            ylist = lines[i+dataRowStart+skipLine].split(',')
-            if len(ylist) == nColumns+1:
-                y=np.array(ylist, dtype=float)
-                data[i,:] = y[:]
-            elif verbose:
-                print('  data row', i, 'is inconsistent:',len(ylist), nColumns+1,' ... skipped')
-
-    if verbose: print('columns imported =', columnsExported)
-    if verbose: print('total columns to be imported =', nColumns, ', array size of file =', np.size(data,1))
-
-    if (nColumns + 1) != np.size(data,1): #one additional column for time!
-        raise ValueError('ERROR in LoadSolution: number of columns is inconsistent')
-
-    nRows = np.size(data,0)
-
-    return dict({'data': data, 'columnsExported': columnsExported,'nColumns': nColumns,'nRows': nRows})
-
-
-#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#helper functions for reading binary files:
-
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: simple conversion of int8 arrays into strings (not highly efficient, so use only for short strings)
-def NumpyInt8ArrayToString(npArray):
-    s=''
-    for x in npArray:
-        s+=chr(x)
-    return s
-
-#**function: read single Index from current file position in binary solution file
-def BinaryReadIndex(file, intType):
-    data = np.fromfile(file, dtype=intType, count=1)
-    if data.size != 1: return [0,True] #end of file
-    return [data[0], False]
-
-#**function: read single Real from current file position in binary solution file
-def BinaryReadReal(file, realType):
-    data = np.fromfile(file, dtype=realType, count=1)
-    if data.size != 1: return [0,True] #end of file
-    return [data[0], False]
-
-#**function: read string from current file position in binary solution file
-def BinaryReadString(file, intType):
-    dataLength = np.fromfile(file, dtype=intType, count=1)[0]
-    data = np.fromfile(file, dtype=np.byte, count=dataLength)
-    return [NumpyInt8ArrayToString(data), False]
-
-#**function: read Index array from current file position in binary solution file
-def BinaryReadArrayIndex(file, intType):
-    dataLength = np.fromfile(file, dtype=intType, count=1)[0]
-    data = np.fromfile(file, dtype=intType, count=dataLength)
-    return [data, False]
-
-#**function: read Real vector from current file position in binary solution file
-#**output: return data as numpy array, or False if no data read
-def BinaryReadRealVector(file, intType, realType):
-    sizeData = np.fromfile(file, dtype=intType, count=1)
-    if sizeData.size != 1: return [[],True] #end of file
-    dataLength = sizeData[0]
-    data = np.fromfile(file, dtype=realType, count=dataLength)
-    if data.size != dataLength: return [[],True] #end of file
-    return [data, False]
-
-
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: read BINARY coordinates solution file (exported during static or dynamic simulation with option exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName='...') into dictionary
-#**input: 
-#  fileName: string containing directory and filename of stored coordinatesSolutionFile
-#  verbose: if True, some information is written when importing file (use for huge files to track progress)
-#  maxRows: maximum number of data rows loaded, if saveMode=True; use this for huge files to reduce loading time; set -1 to load all rows
-#**output: dictionary with 'data': the matrix of stored solution vectors, 'columnsExported': a list with integer values showing the exported sizes [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData], 'nColumns': the number of data columns and 'nRows': the number of data rows
-def LoadBinarySolutionFile(fileName, maxRows=-1, verbose=True):
-    print('verbose=',verbose)
-    with open(fileName, 'r') as file:
-        data = np.fromfile(file, dtype=np.byte, count=6)
-        s = NumpyInt8ArrayToString(data)
-        if int(verbose)>1: print(s)
-        if s!='EXUBIN':
-            raise ValueError('LoadBinarySolutionFile: no binary header found!')
-
-        if verbose: print('read binary file')
-        fileEnd = False
-#             ExuFile::BinaryWriteHeader(solFile, bfs);
-        dataHeader = np.fromfile(file, dtype=np.byte, count=10)
-        #dataHeader[0] == '\n'
-        indexSize = int(dataHeader[1])
-        realSize = int(dataHeader[2])
-        pointerSize = int(dataHeader[3])
-        bigEndian = int(dataHeader[4])
-        
-        if indexSize==4:
-            intType = np.int32
-        elif indexSize==8:
-            intType = np.int64
-        else:
-            raise ValueError('Read binary file: invalid Index type size!')
-        
-        if realSize==4:
-            realType = np.float32
-        elif realSize==8:
-            realType = np.float64
-        else:
-            raise ValueError('LoadBinarySolutionFile: invalid Real type size!')
-        
-        if verbose>1: 
-            print('  indexSize=',indexSize)
-            print('  realSize=',realSize)
-            print('  pointerSize=',pointerSize)
-            print('  bigEndian=',bigEndian)
-
-#         ExuFile::BinaryWrite(EXUstd::exudynVersion, solFile, bfs);
-        sVersion, fileEnd=BinaryReadString(file, intType)
-        if verbose: print('  version=',sVersion)
-
-#         ExuFile::BinaryWrite(STDstring("Mode0000"), solFile, bfs); //change this in future to add new features
-        sMode, fileEnd=BinaryReadString(file, intType)
-        if int(verbose)>1: print('  mode=',sMode)
-
-#             STDstring str = "Exudyn " + GetSolverName() + " ";
-#             if (isStatic) { str+="static "; }
-#             str+="solver solution file";
-#             ExuFile::BinaryWrite(str, solFile, bfs);
-        sSolver, fileEnd=BinaryReadString(file, intType)
-        if int(verbose)>1: print('  solver=',sSolver)
-
-#             //solFile << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
-#             ExuFile::BinaryWrite(EXUstd::GetDateTimeString(), solFile, bfs);
-        sTime, fileEnd=BinaryReadString(file, intType)
-        if int(verbose)>1: print('  data/time=',sTime)
-
-#             //not needed in binary format:
-#             //solFile << "#columns contain: time, ODE2 displacements";
-#             //if (solutionSettings.exportVelocities) { solFile << ", ODE2 velocities"; }
-#             //if (solutionSettings.exportAccelerations) { solFile << ", ODE2 accelerations"; }
-#             //if (nODE1) { solFile << ", ODE1 coordinates"; } //currently not available, but for future solFile structure necessary!
-#             //if (nVel1) { solFile << ", ODE1 velocities"; }
-#             //if (solutionSettings.exportAlgebraicCoordinates) { solFile << ", AE coordinates"; }
-#             //if (solutionSettings.exportDataCoordinates) { solFile << ", ODE2 velocities"; }
-#             //solFile << "\n";
-
-#             //solFile << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
-#             //    nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
-#             ArrayIndex sysCoords({nODE2, nODE1, nAE, nData});
-#             ExuFile::BinaryWrite(sysCoords, solFile, bfs);
-        systemSizes, fileEnd=BinaryReadArrayIndex(file, intType)
-        if verbose: print('  systemSizes=',systemSizes)
-
-
-#             //solFile << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
-#             //    nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])
-#             ArrayIndex writtenCoords({ nODE2, nVel2, nAcc2, nODE1, nVel1, nAEexported, nDataExported });
-#             ExuFile::BinaryWrite(writtenCoords, solFile, bfs);
-        columnsExported, fileEnd=BinaryReadArrayIndex(file, intType)
-        if verbose: print('  columnsExported=',columnsExported)
-        nColumns = sum(columnsExported) #total size of data per row
-        
-#             //solFile << "#total columns exported  (excl. time) = " << totalCoordinates << "\n";
-#             ExuFile::BinaryWrite(totalCoordinates, solFile, bfs);
-        totalCoordinates, fileEnd = BinaryReadIndex(file, intType)
-
-#             Index numberOfSteps;
-#             if (!isStatic) { numberOfSteps = timeint.numberOfSteps; }
-#             else { numberOfSteps = staticSolver.numberOfLoadSteps; }
-#             ExuFile::BinaryWrite(numberOfSteps, solFile, bfs);
-        numberOfSteps, fileEnd = BinaryReadIndex(file, intType)
-        
-#             //solution information: always export string, even if has zero length:
-#             ExuFile::BinaryWrite(solutionSettings.solutionInformation, solFile, bfs);
-        solutionInformation, fileEnd=BinaryReadString(file, intType)
-        if int(verbose)>1: print('  solutionInformation="'+solutionInformation+'"')
-
-#             //add some checksum ...
-#             ExuFile::BinaryWrite(STDstring("EndOfHeader"), solFile, bfs);
-#             //next byte starts with solution
-        EndOfHeader, fileEnd=BinaryReadString(file, intType)
-        if int(verbose)>1: print('  EndOfHeader found: ',EndOfHeader)
-        if EndOfHeader!='EndOfHeader':
-            raise ValueError('LoadBinarySolutionFile: EndOfHeader not found')
-
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #read time steps
-#         if (isBinary) //add size, only in binary mode
-#         {
-#             //including 1 real for time+1 Index for nVectors, but excluding bytes for this Index
-#             Index lineSizeBytes = nVectors * bfs.indexSize + nValues * bfs.realSize + bfs.indexSize + bfs.realSize;
-#             ExuFile::BinaryWrite(lineSizeBytes, solFile, bfs); //size of line, for fast skipping of solution line
-#             ExuFile::BinaryWrite(nVectors, solFile, bfs); //number of vectors could vary if needed
-#         }
-        if fileEnd: print('  ==> end of file found during in header')
-        fileEnd = False
-        data = np.zeros((0,nColumns+1))
-        nRows = 0
-        line = np.zeros(nColumns+1)
-        validEndFound = False
-        dataList = [] #list is much faster than hstack !
-        
-        while not fileEnd:
-            #print('read row ',nRows)
-            if maxRows != -1 and nRows >= maxRows:
-                fileEnd = True
-                break
-
-            #includes time and all values for solution according to header    
-            sizeData = np.fromfile(file, dtype=intType, count=1)
-            if sizeData.size != 1: 
-                fileEnd=True
-                break
-            dataLength = sizeData[0]
-            if dataLength  == -1:
-                if int(verbose)>1: print('end of file reached')
-                validEndFound = True
-                break
-            if int(verbose)>1: 
-                print('  dataLength=',dataLength)
-                
-            line = np.fromfile(file, dtype=realType, count=dataLength)
-            if line.size != dataLength: 
-                fileEnd=True
-                break
-            #line, fileEnd=BinaryReadRealVector(file, intType, realType)
-            if int(verbose)>1: 
-                print('  read',line.size, 'columns (',nColumns+1,'expected)')
-                print('  line=',line)
-            if fileEnd: break
-            if line.size != nColumns+1:
-                raise ValueError('LoadBinarySolutionFile: rows are inconsistent')
-            
-            nRows += 1
-
-            dataList+=[line]
-            #data = np.vstack((data, line)) #slow!
-
-        if verbose: print('  read '+str(nRows)+' rows from file')
-        
-        data = np.array(dataList)
-        nRows = np.size(data,0)
-
-        if not validEndFound:
-            print('LoadBinarySolutionFile: WARNING: end of file inconsistent!')
-        else:
-            if int(verbose)>1: 
-                print('  valid end of data found')
-                print('LoadBinarySolutionFile finished')
-    
-        return dict({'data': data, 'columnsExported': columnsExported,'nColumns': nColumns,'nRows': nRows})
-        
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: recover solution file with last row not completely written (e.g., if crashed, interrupted or no flush file option set)
-#**input: 
-#  fileName: string containing directory and filename of stored coordinatesSolutionFile
-#  newFileName: string containing directory and filename of new coordinatesSolutionFile
-#  verbose: 0=no information, 1=basic information, 2=information per row
-#**output: writes only consistent rows of file to file with name newFileName
-def RecoverSolutionFile(fileName, newFileName, verbose=0):
-    #read file header
-    fileRead=open(fileName,'r') 
-    fileLines = []
-    fileLines += [fileRead.readline()]
-    fileLines += [fileRead.readline()]
-    fileLines += [fileRead.readline()]
-    fileLines += [fileRead.readline()]
-    fileLines += [fileRead.readline()]
-    fileRead.close()
-    if len(fileLines[4]) == 0:
-        raise ValueError('ERROR in LoadSolution: file empty or header missing')
-        
-    leftStr=fileLines[4].split('=')[0]
-    if leftStr[0:30] != '#number of written coordinates': 
-        raise ValueError('ERROR in LoadSolution: file header corrupted')
-
-    columnsExported = eval(fileLines[4].split('=')[1]) #load according column information into vector: [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData]
-    nColumns = sum(columnsExported)
-    expectedColumns = nColumns+1
-    if verbose >= 1:
-        print('columns imported =', columnsExported)
-        print('total columns to be imported =', expectedColumns, '(incl. time)\n')
-
-
-    with open(newFileName, 'w') as fileWrite:
-        with open(fileName) as file:
-            cnt = 0
-            cntSolution = 0
-            for line in file:
-                if line[0] == '#':
-                    if len(line) < 1000 and verbose >= 1:
-                        print('HEADER:', line, end='')
-                    fileWrite.write(line)
-                else:
-                    #cols = len(line.split(','))
-                    cols = line.count(',')+1 #+1 needed, because two columns for one comma
-                    if cols == expectedColumns:
-                        if verbose >= 2:
-                            print('data row ',cntSolution,', #cols=',cols, ', text=',line[0:12],'...', sep='')
-                        fileWrite.write(line)
-                    else:
-                        if verbose >= 1:
-                            print('\nWARNING: ignored solution data',cntSolution, '(file line',cnt,'), columns=', cols, '\n')
-                    cntSolution += 1
-                
-                cnt += 1
-
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: recover initial coordinates, time, etc. from given restart file
-#**input: 
-#  mbs: MainSystem to be operated with
-#  simulationSettings: simulationSettings which is updated and shall be used afterwards for SolveDynamic(...) or SolveStatic(...)
-#  restartFileName: string containing directory and filename of stored restart file, as given in solutionSettings.restartFileName
-#  verbose: False=no information, True=basic information
-#**output: modifies simulationSettings and sets according initial conditions in mbs
-def InitializeFromRestartFile(mbs, simulationSettings, restartFileName, verbose=True):
-    raise ValueError('InitializeFromRestartFile: not fully implemented')
-
-    fileRead=open(fileName,'r') 
-    fileLines = fileRead.readlines()
-    
-    #fileLines = []
-    #fileLines += [fileRead.readline()]
-    #fileLines += [fileRead.readline()]
-    #fileLines += [fileRead.readline()]
-    #fileLines += [fileRead.readline()]
-    #fileLines += [fileRead.readline()]
-    fileRead.close()
-    if len(fileLines[4]) == 0:
-        raise ValueError('ERROR in InitializeFromRestartFile: file empty or header missing')
-        
-    leftStr=fileLines[4].split('=')[0]
-    if leftStr[0:30] != '#number of written coordinates': 
-        raise ValueError('ERROR in InitializeFromRestartFile: file header corrupted')
-
-    columnsExported = eval(fileLines[4].split('=')[1]) #load according column information into vector: [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData]
-    nColumns = sum(columnsExported)
-    expectedColumns = nColumns+1
-    if verbose:
-        print('columns available in restart file =', columnsExported)
-        print('total columns to be imported =', expectedColumns, '(incl. time)\n')
-
-    if fileLines[-1][0:9]!='#FINISHED':
-        raise ValueError('ERROR in InitializeFromRestartFile: last line does not contain "#FINISHED" and is thus expected to be corrupted!')
-
-    #now everything should be ok and we can just read the line with numpy:
-    data = np.loadtxt(fileName, comments='#', delimiter=',')
-    nRows = np.size(data,0) #should be 1
-    if nRows != 1:
-        raise ValueError('ERROR in InitializeFromRestartFile: got more than one rows, but expected one')
-
-    row = 0 #first row used 
-    rowData = data[row]
-    #cols = solution['columnsExported']
-    [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = columnsExported
-
-    #note that these visualization updates are not threading safe!
-    mbs.systemData.SetODE2Coordinates(rowData[1:1+nODE2], configuration)
-    if (nVel2): mbs.systemData.SetODE2Coordinates_t(rowData[1+nODE2:1+nODE2+nVel2], configuration)
-    if (nAcc2): mbs.systemData.SetODE2Coordinates_tt(rowData[1+nODE2+nVel2:1+nODE2+nVel2+nAcc2], configuration)
-    if (nODE1): mbs.systemData.SetODE1Coordinates(rowData[1+nODE2+nVel2+nAcc2:1+nODE2+nVel2+nAcc2+nODE1], configuration)
-    if (nVel1): mbs.systemData.SetODE1Coordinates_t(rowData[1+nODE2+nVel2+nAcc2+nODE1:1+nODE2+nVel2+nAcc2+nODE1+nVel1], configuration)
-    
-    if (nAlgebraic): mbs.systemData.SetAECoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic], configuration)
-    if (nData): mbs.systemData.SetDataCoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic+nData], configuration)
-
-    if configuration == exudyn.ConfigurationType.Visualization:
-        mbs.systemData.SetTime(rowData[0], exudyn.ConfigurationType.Visualization)
-        mbs.SendRedrawSignal()
-    
-    #add integration parameters to simulationSettings ...
-    
-    if verbose: print('\nInitializeFromRestartFile finished\n')
-    
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: load selected row of solution dictionary (previously loaded with LoadSolutionFile) into specific state; flag sendRedrawSignal is only used if configuration = exudyn.ConfigurationType.Visualization
-def SetSolutionState(mbs, solution, row, configuration=exudyn.ConfigurationType.Current, sendRedrawSignal=True):
-    if row < solution['nRows']:
-        rowData = solution['data'][row]
-        #cols = solution['columnsExported']
-        [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = solution['columnsExported']
-
-        #note that these visualization updates are not threading safe!
-        mbs.systemData.SetODE2Coordinates(rowData[1:1+nODE2], configuration)
-        if (nVel2): mbs.systemData.SetODE2Coordinates_t(rowData[1+nODE2:1+nODE2+nVel2], configuration)
-        if (nAcc2): mbs.systemData.SetODE2Coordinates_tt(rowData[1+nODE2+nVel2:1+nODE2+nVel2+nAcc2], configuration)
-        if (nODE1): mbs.systemData.SetODE1Coordinates(rowData[1+nODE2+nVel2+nAcc2:1+nODE2+nVel2+nAcc2+nODE1], configuration)
-        if (nVel1): mbs.systemData.SetODE1Coordinates_t(rowData[1+nODE2+nVel2+nAcc2+nODE1:1+nODE2+nVel2+nAcc2+nODE1+nVel1], configuration)
-        
-        if (nAlgebraic): mbs.systemData.SetAECoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic], configuration)
-        if (nData): mbs.systemData.SetDataCoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic+nData], configuration)
-
-        if configuration == exudyn.ConfigurationType.Visualization:
-            mbs.systemData.SetTime(rowData[0], exudyn.ConfigurationType.Visualization)
-            mbs.SendRedrawSignal()
-    else:
-        print("ERROR in SetVisualizationState: invalid row (out of range)")
-
-#++++++++++++++++++++++++++++++++++++++++++++
-#**function: This function is not further maintaned and should only be used if you do not have tkinter (like on some MacOS versions); use exudyn.interactive.SolutionViewer() instead! AnimateSolution consecutively load the rows of a solution file and visualize the result
-#**input: 
-#  mbs: the system used for animation
-#  solution: solution dictionary previously loaded with LoadSolutionFile; will be played from first to last row
-#  rowIncrement: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
-#  timeout: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
-#  createImages: creates consecutively images from the animation, which can be converted into an animation
-#  runLoop: if True, the animation is played in a loop until 'q' is pressed in render window
-#**output: renders the scene in mbs and changes the visualization state in mbs continuously
-def AnimateSolution(mbs, solution, rowIncrement = 1, timeout=0.04, createImages = False, runLoop = False):
-    SC = mbs.GetSystemContainer()
-    nRows = solution['nRows']
-    if nRows == 0:
-        print('ERROR in AnimateSolution: solution file is empty')
-        return
-    if (rowIncrement < 1) or (rowIncrement > nRows):
-        print('ERROR in AnimateSolution: rowIncrement must be at least 1 and must not be larger than the number of rows in the solution file')
-    oldUpdateInterval = SC.visualizationSettings.general.graphicsUpdateInterval
-    SC.visualizationSettings.general.graphicsUpdateInterval = 0.5*min(timeout, 2e-3) #avoid too small values to run multithreading properly
-    mbs.SetRenderEngineStopFlag(False) #not to stop right at the beginning
-
-    while runLoop and not mbs.GetRenderEngineStopFlag():
-        for i in range(0,nRows,rowIncrement):
-            if not(mbs.GetRenderEngineStopFlag()):
-                #SetVisualizationState(exudyn, mbs, solution, i) #OLD
-                SetSolutionState(mbs, solution, i, exudyn.ConfigurationType.Visualization)
-                if createImages:
-                    SC.RedrawAndSaveImage() #create images for animation
-                #time.sleep(timeout)
-                exudyn.DoRendererIdleTasks(timeout)
-
-    SC.visualizationSettings.general.graphicsUpdateInterval = oldUpdateInterval #set values back to original
-
-
-
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: helper function which draws system graph of a MainSystem (mbs); several options let adjust the appearance of the graph; the graph visualization uses randomizer, which results in different graphs after every run!
-#**input:
-#   mbs: MainSystem to be operated with
-#   showLoads: toggle appearance of loads in mbs
-#   showSensors: toggle appearance of sensors in mbs
-#   useItemNames: if True, object names are shown instead of basic object types (Node, Load, ...)
-#   useItemTypes: if True, object type names (MassPoint, JointRevolute, ...) are shown instead of basic object types (Node, Load, ...); Note that Node, Object, is omitted at the beginning of itemName (as compared to theDoc.pdf); item classes become clear from the legend
-#   addItemTypeNames: if True, type nymes (Node, Load, etc.) are added
-#   multiLine: if True, labels are multiline, improving readability
-#   fontSizeFactor: use this factor to scale fonts, allowing to fit larger graphs on the screen with values < 1
-#   showLegend: shows legend for different item types
-#   layoutDistanceFactor: this factor influences the arrangement of labels; larger distance values lead to circle-like results
-#   layoutIterations: more iterations lead to better arrangement of the layout, but need more time for larger systems (use 1000-10000 to get good results)
-#   tightLayout: if True, uses matplotlib plt.tight\_layout() which may raise warning
-#**output: [Any, Any, Any]; returns [networkx, G, items] with nx being networkx, G the graph and item what is returned by nx.draw\_networkx\_labels(...)
-#**belongsTo: MainSystem
-def DrawSystemGraph(mbs, showLoads=True, showSensors=True, useItemNames = False, 
-                    useItemTypes = False, addItemTypeNames=True, multiLine=True, fontSizeFactor=1., 
-                    layoutDistanceFactor=3., layoutIterations=100, showLegend = True, tightLayout = True):
-    
-    try:
-        #all imports are part of anaconda (e.g. anaconda 5.2.0, python 3.6.5)
-        import numpy as np
-        import networkx as nx #for generating graphs and graph arrangement
-        import matplotlib.pyplot as plt #for drawing
-    except ImportError as e:
-        raise ImportError("numpy, networkx and matplotlib required for DrawSystemGraph(...)") from e
-    except :
-        print("DrawSystemGraph(...): unexpected error during import of numpy, networkx and matplotlib")
-        raise
-    
-    itemColors = {'Node':'red', 'Object':'skyblue', 'Oconnector':'dodgerblue', 'Ojoint':'dodgerblue', 'Ocontact':'dodgerblue', #turqoise, skyblue
-                      'Marker': 'orange', 'Load': 'mediumorchid', 
-                      'Sensor': 'forestgreen'} #https://matplotlib.org/examples/color/named_colors.html
-    
-    plt.clf()
-    
-    itemColorMap=[]     #color per item
-    itemNames=[]        #name per item 
-    itemTypes=[]        #name per item 
-    edgeColorMap=[]
-    nodesToItems=[]     #maps mbs-node numbers to item numbers
-    markersToItems=[]   #maps mbs-marker numbers to item numbers
-    objectsToItems=[]   #maps mbs-object numbers to item numbers
-    loadsToItems=[]     #maps mbs-load numbers to item numbers
-    sensorsToItems=[]   #maps mbs-sensor numbers to item numbers
-    
-    objectNodeColor = 'navy' #color for edges between nodes and objects, to be highlighted
-            
-    G = nx.Graph()
-    
-    #showLegend = False
-    #addItemTypeNames = False #Object, Node, ... not added but legend added
-    # if useItemTypes or useItemNames:
-    #     showLegend = True
-
-    sLineBreak = ''
-    if multiLine:
-        sLineBreak = '-\n'
-
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    itemType = 'Node'
-    n = mbs.systemData.NumberOfNodes()
-    for i in range(n):
-        item = mbs.GetNode(i)
-        itemName=itemType+str(i)
-    
-        nodeName = 'Node'
-        if item['nodeType'].find('Ground') != -1:
-            nodeName = nodeName + 'Ground'
-    
-        if useItemNames:
-            itemName=item['name'] #+str(i)
-        elif useItemTypes:
-            itemName=item['nodeType']+str(i)
-            if addItemTypeNames:
-                itemName = nodeName + sLineBreak + itemName
-
-            if sLineBreak != '':
-                itemName=itemName.replace('Node'+sLineBreak+'Rigid','NodeRigid'+sLineBreak)
-                itemName=itemName.replace('Node'+sLineBreak+'Generic','NodeGeneric'+sLineBreak)
-    
-        G.add_node(itemName) #attributes: size, weight, ...
-        nodesToItems += [len(itemColorMap)]
-        itemColorMap += [itemColors[itemType]]
-        itemNames += [itemName]
-        itemTypes += [itemType]
-    
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #add markers without edges
-    itemType = 'Marker'
-    n = mbs.systemData.NumberOfMarkers()
-    for i in range(n):
-        item = mbs.GetMarker(i)
-        itemName=itemType+str(i)
-        if useItemNames:
-            itemName=item['name']#+str(i)
-        elif useItemTypes:
-            itemName=item['markerType']+str(i)
-            if addItemTypeNames:
-                itemName = 'Marker' + sLineBreak + itemName
-
-            if sLineBreak != '':
-                itemName=itemName.replace('Marker'+sLineBreak+'Body','MarkerBody'+sLineBreak)
-                itemName=itemName.replace('Marker'+sLineBreak+'Object','MarkerObject'+sLineBreak)
-                itemName=itemName.replace('Marker'+sLineBreak+'Node','MarkerNode'+sLineBreak)
-                itemName=itemName.replace('Marker'+sLineBreak+'SuperElement','MarkerSuperElement'+sLineBreak)
-                itemName=itemName.replace('Marker'+sLineBreak+'Kinematic','MarkerKinematic'+sLineBreak)
-    
-        G.add_node(itemName) #attributes: size, weight, ...
-        markersToItems += [len(itemColorMap)]
-        itemColorMap += [itemColors[itemType]]
-        itemNames += [itemName]
-        itemTypes += [itemType]
-    
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    itemType = 'Object'
-    n = mbs.systemData.NumberOfObjects()
-    for i in range(n):
-        objectType = itemType
-        item = mbs.GetObject(i)
-        if item['objectType'].find('Connector') != -1:
-            objectType = 'Oconnector'
-        elif item['objectType'].find('Contact') != -1:
-            objectType = 'Ocontact'
-        elif item['objectType'].find('Joint') != -1:
-            objectType = 'Ojoint'
-        itemName=objectType+str(i)
-    
-        if useItemNames:
-            itemName=item['name']#+str(i)
-        elif useItemTypes:
-            itemName=item['objectType']+str(i)
-            if addItemTypeNames:
-                itemName = 'Object' + sLineBreak + itemName
-            
-            if sLineBreak != '':
-                itemName=itemName.replace('Object'+sLineBreak+'Joint','ObjectJoint'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'Mass','ObjectMass'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'Beam','ObjectBeam'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'ANCF','ObjectANCF'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'Contact','ObjectContact'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'Connector','ObjectConnector'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'Rigid','ObjectRigid'+sLineBreak)
-                itemName=itemName.replace('Object'+sLineBreak+'FFRFr','ObjectFFRF'+sLineBreak+'r')
-            
-        G.add_node(itemName) #attributes: size, weight, ...
-        objectsToItems += [len(itemColorMap)]
-        itemNames += [itemName]
-        itemTypes += [itemType]
-        itemColorMap += [itemColors[objectType]]
-    
-    #    objectColor = ''
-        #for objects: add edges to nodes
-        nodeNumbers = []
-        if 'nodeNumber' in item:
-            nodeNumbers += [item['nodeNumber']]
-        if 'nodeNumbers' in item:
-            nodeNumbers += item['nodeNumbers']
-    
-        for j in range(len(nodeNumbers)):
-            nodeNumbers[j] = int(nodeNumbers[j])
-    
-        for j in nodeNumbers:
-            if j != exudyn.InvalidIndex(): #for RigidBodySpringDamper
-                G.add_edge(itemNames[objectsToItems[i]],itemNames[nodesToItems[j]],color=objectNodeColor)
-    
-        #for connectors, contact, joint: add edges to these objects
-        markerNumbers = []
-        if 'markerNumbers' in item: #should only be markerNumbers ...
-            markerNumbers += item['markerNumbers']
-    
-        for j in range(len(markerNumbers)):
-            markerNumbers[j] = int(markerNumbers[j])
-    
-        for j in markerNumbers:
-            G.add_edge(itemNames[objectsToItems[i]],itemNames[markersToItems[j]], color=itemColors['Oconnector'])
-            
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #now add only edges for markers:
-    itemType = 'Marker'
-    n = mbs.systemData.NumberOfMarkers()
-    for i in range(n):
-        objectType = itemType
-        item = mbs.GetMarker(i)
-    
-        #for node markers:
-        nodeNumbers = []
-        if 'nodeNumber' in item:
-            nodeNumbers += [item['nodeNumber']]
-       
-        for j in range(len(nodeNumbers)):
-            nodeNumbers[j] = int(nodeNumbers[j])
-    
-        for j in nodeNumbers:
-            G.add_edge(itemNames[markersToItems[i]],itemNames[nodesToItems[j]],color='orange')
-    
-        #for object markers:
-        objectNumbers = []
-        if 'objectNumber' in item: objectNumbers += [item['objectNumber']]
-        if 'bodyNumber' in item: objectNumbers += [item['bodyNumber']]
-       
-        for j in range(len(objectNumbers)):
-            objectNumbers[j] = int(objectNumbers[j])
-    
-        for j in objectNumbers:
-            G.add_edge(itemNames[markersToItems[i]],itemNames[objectsToItems[j]],color='orange')
-            
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #add loads
-    if showLoads:
-        itemType = 'Load'
-        n = mbs.systemData.NumberOfLoads()
-        for i in range(n):
-            item = mbs.GetLoad(i)
-            itemName=itemType+str(i)
-            if useItemNames:
-                itemName=item['name']#+str(i)
-            elif useItemTypes:
-                itemName=item['loadType']+str(i)
-                if addItemTypeNames:
-                    itemName = 'Load' + sLineBreak + itemName
-
-                if sLineBreak != '':
-                    itemName=itemName.replace('Load'+sLineBreak+'Mass','LoadMass'+sLineBreak)
-
-        
-            G.add_node(itemName) #attributes: size, weight, ...
-            loadsToItems += [len(itemColorMap)]
-            itemColorMap += [itemColors[itemType]]
-            itemNames += [itemName]
-            itemTypes += [itemType]
-    
-            markerNumbers = [int(item['markerNumber'])]
-            
-            for j in markerNumbers:
-                G.add_edge(itemNames[loadsToItems[i]],itemNames[markersToItems[j]], color=itemColors['Load'])
-    
-    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
-    #add sensors
-    if showSensors:
-        itemType = 'Sensor'
-        n = mbs.systemData.NumberOfSensors() #only available for Exudyn version >= 1.0.15
-        for i in range(n):
-            item = mbs.GetSensor(i)
-            itemName=itemType+str(i)
-            if useItemNames:
-                itemName=item['name']#+str(i)
-            elif useItemTypes:
-                itemName=item['sensorType']+str(i)
-                if addItemTypeNames:
-                    itemName = 'Sensor' + sLineBreak + itemName
-        
-            G.add_node(itemName) #attributes: size, weight, ...
-            sensorsToItems += [len(itemColorMap)]
-            itemColorMap += [itemColors[itemType]]
-            itemNames += [itemName]
-            itemTypes += [itemType]
-    
-            #for object sensors:
-            objectNumbers = []
-            if 'objectNumber' in item: objectNumbers += [item['objectNumber']]
-            if 'bodyNumber' in item: objectNumbers += [item['bodyNumber']]
-           
-            for j in range(len(objectNumbers)):
-                objectNumbers[j] = int(objectNumbers[j])
-        
-            for j in objectNumbers:
-                G.add_edge(itemNames[sensorsToItems[i]],itemNames[objectsToItems[j]],color=itemColors[itemType])
-
-            #for node sensors:
-            nodeNumbers = []
-            if 'nodeNumber' in item: nodeNumbers += [int(item['nodeNumber'])]
-                   
-            for j in nodeNumbers:
-                G.add_edge(itemNames[sensorsToItems[i]],itemNames[nodesToItems[j]],color=itemColors[itemType])
-       
-    if showLegend:
-        legendColors = {'Node':'red', 'Object':'skyblue', 'Object(Connector)':'dodgerblue', 
-                      'Marker': 'orange', 'Load': 'mediumorchid', 
-                      'Sensor': 'forestgreen'} 
-        #f = plt.figure(1)
-        #ax = f.add_subplot(1,1,1)
-        for label in legendColors:
-            plt.plot([0],[0],linewidth=8,color=legendColors[label],label=label)
-        
-        fontSizeLegend = 10
-        if fontSizeFactor > 1: #do not make font size smaller!
-            fontSizeLegend *= fontSizeFactor
-        plt.legend(fontsize=fontSizeLegend)
-
-    
-    #now get out the right sorting of colors ...
-    edgeColorMap = []
-    edgeWidths = []
-    edges=G.edges()
-    for item in edges.items(): 
-        edgeColorMap += [item[1]['color']] #color is in item[1], which is a dictionary ...
-        edgeWidth = 2
-        if item[1]['color'] == objectNodeColor: #object-node should be emphasized
-            edgeWidth = 4
-        edgeWidths += [edgeWidth]
-    
-    pos = nx.drawing.spring_layout(G, scale=0.5, k=layoutDistanceFactor*1/sqrt(G.size()), 
-                                   threshold = 1e-5, iterations = layoutIterations)
-    nx.draw_networkx_nodes(G, pos, node_size=1)
-    nx.draw_networkx_edges(G, pos, edge_color=edgeColorMap, width=edgeWidths)#width=2)
-    
-    #reproduce what draw_networkx_labels does, allowing different colors for nodes
-    #check: https://networkx.github.io/documentation/stable/_modules/networkx/drawing/nx_pylab.html
-    items = nx.draw_networkx_labels(G, pos, font_size=10*fontSizeFactor, clip_on=False, #clip at plot boundary
-                                    bbox=dict(facecolor='skyblue', edgecolor='black', 
-                                              boxstyle='round,pad=0.1', lw=10*fontSizeFactor)) #lw is border size (no effect?)
-
-    
-    #now assign correct colors:
-    for i in range(len(itemNames)):
-        currentColor = itemColorMap[i]
-        itemType = itemTypes[i]
-        boxStyle = 'round,pad=0.2'
-        fontSize = 10*fontSizeFactor
-        if itemType == 'Object':
-            boxStyle = 'round,pad=0.2'
-            fontSize = 12*fontSizeFactor
-        if itemType == 'Node':  
-            boxStyle = 'square,pad=0.1'
-            fontSize = 10*fontSizeFactor
-        if itemType == 'Marker':  
-            boxStyle = 'square,pad=0.1'
-            fontSize = 8*fontSizeFactor
-    
-        #print("color=",currentColor)
-        items[itemNames[i]].set_bbox(dict(facecolor=currentColor,  
-              edgecolor=currentColor, boxstyle=boxStyle))
-        items[itemNames[i]].set_fontsize(fontSize)
-    
-    plt.axis('off') #do not show frame, because usually some nodes are very close to frame ...
-    if tightLayout:
-        plt.tight_layout()
-    plt.margins(x=0.1*fontSizeFactor, y=0.1*fontSizeFactor) #larger margin, to avoid clipping of long texts
-    plt.draw() #force redraw after colors have changed
-    
-    return [nx, G, items]
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#                              SPECIAL FUNCTIONS FOR EXUDYN
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#TCP/IP functionality
-#**class: helper class for CreateTCPIPconnection and for TCPIPsendReceive
-class TCPIPdata:
-    def __init__(self, sendSize, receiveSize, packerSend, packerReceive, 
-                  socketTCP, connection, address, lastReceiveTime):
-        self.sendSize = sendSize
-        self.receiveSize = receiveSize
-        self.packerSend = packerSend
-        self.packerReceive = packerReceive
-        self.socket = socketTCP
-        self.connection = connection
-        self.address = address
-        self.lastReceiveTime = lastReceiveTime #usually zero; used to make substeps in mbs
-        
-        
-#**function: function which has to be called before simulation to setup TCP/IP socket (server) for 
-#  sending and receiving data; can be used to communicate with other Python interpreters
-#  or for communication with MATLAB/Simulink
-#**input:
-#  sendSize: number of double values to be sent to TCPIP client
-#  receiveSize: number of double values to be received from TCPIP client
-#  IPaddress: string containing IP address of client (e.g., '127.0.0.1')
-#  port: port for communication with client
-#  bigEndian: if True, it uses bigEndian, otherwise littleEndian is used for byte order
-#**output: returns information (TCPIPdata class) on socket; recommended to store this in mbs.sys['TCPIPobject']
-#**example:
-# mbs.sys['TCPIPobject'] = CreateTCPIPconnection(sendSize=3, receiveSize=2, 
-#                                                bigEndian=True, verbose=True)
-# sampleTime = 0.01 #sample time in MATLAB! must be same!
-# mbs.variables['tLast'] = 0 #in case that exudyn makes finer steps than sample time
-
-# def PreStepUserFunction(mbs, t):
-#     if t >= mbs.variables['tLast'] + sampleTime:
-#         mbs.variables['tLast'] += sampleTime
-
-#         tcp = mbs.sys['TCPIPobject']
-#         y = TCPIPsendReceive(tcp, np.array([t, np.sin(t), np.cos(t)])) #time, torque
-#         tau = y[1]
-#         print('tau=',tau)
-#     return True
-
-
-# try:
-#     mbs.SetPreStepUserFunction(PreStepUserFunction)
-    
-#     #%%++++++++++++++++++++++++++++++++++++++++++++++++++
-#     mbs.Assemble()
-#     [...] #start renderer; simulate model
-# finally: #use this to always close connection, even in case of errors
-#     CloseTCPIPconnection(mbs.sys['TCPIPobject'])
-#
-# #*****************************************
-# #the following settings work between Python and MATLAB-Simulink (client), and gives stable results(with only delay of one step):
-# # TCP/IP Client Send:
-# #   priority = 2 (in properties)
-# #   blocking = false
-# #   Transfer Delay on (but off also works)
-# # TCP/IP Client Receive:
-# #   priority = 1 (in properties)
-# #   blocking = true
-# #   Sourec Data type = double
-# #   data size = number of double in packer
-# #   Byte order = BigEndian
-# #   timeout = 10
-def CreateTCPIPconnection(sendSize, receiveSize, IPaddress='127.0.0.1', port=52421, 
-                          bigEndian=False, verbose=False):
-    import socket
-    import struct
-    s = ''
-    if bigEndian:
-        s = '>' #signals bigEndian format
-    packerSend = struct.Struct(s+'d '*sendSize) #'>' for big endian in matlab, I=unsigned int, i=int, d=double
-    packerReceive = struct.Struct(s+'d '*receiveSize) #'>' for big endian in matlab, I=unsigned int, i=int, d=double
-    if verbose:
-        print('setup TCP/IP socket ...')
-    socketTCP = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    socketTCP.bind((IPaddress, port))
-    socketTCP.listen()
-    connection, address = socketTCP.accept()
-
-    if verbose:
-        print('TCP/IP connection running!')
-
-    return TCPIPdata(sendSize, receiveSize, packerSend, packerReceive, 
-                     socketTCP, connection, address, 0.)
-
-#**function: call this function at every simulation step at which you intend to communicate with
-#  other programs via TCPIP; e.g., call this function in preStepUserFunction of a mbs model
-#**input:
-#  TCPIPobject: the object returned by CreateTCPIPconnection(...)
-#  sendData: numpy array containing data (double array) to be sent; must agree with sendSize
-#**output: returns array as received from TCPIP
-#**example:
-#mbs.sys['TCPIPobject']=CreateTCPIPconnection(sendSize=2, receiveSize=1, IPaddress='127.0.0.1')
-#y = TCPIPsendReceive(mbs.sys['TCPIPobject'], np.array([1.,2.]))
-#print(y)
-#
-def TCPIPsendReceive(TCPIPobject, sendData):
-    #first send data (no other way in MATLAB):
-    TCPIPobject.connection.sendall(TCPIPobject.packerSend.pack(*sendData))
-
-    #now receive data:
-    data = TCPIPobject.connection.recv(TCPIPobject.packerReceive.size) #data size in bytes
-    if not data:
-        print('WARNING: TCPIPsendReceive: loss of data') #usually does not happen!
-        return np.zeros(TCPIPobject.receiveSize)
-    else:
-        return TCPIPobject.packerReceive.unpack(data)
-
-#**function: close a previously created TCPIP connection
-def CloseTCPIPconnection(TCPIPobject):
-    TCPIPobject.connection.close()
-    TCPIPobject.socket.close()
-    
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library
+#
+# Details:  Basic support functions for simpler creation of Exudyn models.
+#           Advanced functions for loading and animating solutions and for drawing a graph of the mbs system.
+#           This library requires numpy (as well as time and copy)
+#
+# Author:   Johannes Gerstmayr
+# Date:     2019-07-26 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# Utility functions and structures for Exudyn
+
+import numpy as np
+#import copy as copy #to be able to copy e.g. lists
+from math import sin, cos, pi, sqrt
+
+import exudyn
+from exudyn.basicUtilities import *
+from exudyn.advancedUtilities import *
+from exudyn.rigidBodyUtilities import *
+from exudyn.graphicsDataUtilities import *
+from exudyn.itemInterface import *
+
+#for compatibility with older models:
+from exudyn.beams import GenerateStraightLineANCFCable2D, GenerateSlidingJoint, GenerateAleSlidingJoint,\
+                         GenerateStraightBeam
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**function: function to hide all objects in mbs except for those listed in objectNumbers
+#**input: 
+#  mbs: mbs containing object
+#  objectNumbers: integer object number or list of object numbers to be shown; if empty list [], then all objects are shown
+#  showOthers: if True, then all other objects are shown again
+#**output: changes all colors in mbs, which is NOT reversible
+def ShowOnlyObjects(mbs, objectNumbers=[], showOthers=False):
+    if not isinstance(objectNumbers,list):
+        listObjects = [objectNumbers]
+    else:
+        listObjects = objectNumbers
+    isEmpty = len(listObjects) == 0
+    
+    for objectIndex in range(mbs.systemData.NumberOfObjects()):
+        oDict = mbs.GetObject(objectIndex)
+        flag = showOthers
+        if objectIndex in listObjects or isEmpty: #if no objects to show,  
+            flag = not showOthers
+        if 'Vshow' in oDict:
+            mbs.SetObjectParameter(objectIndex,'Vshow', flag)
+    mbs.SendRedrawSignal()
+
+#**function: highlight a certain item with number itemNumber; set itemNumber to -1 to show again all objects
+#**input: 
+#  mbs: mbs containing object
+#  itemNumbers: integer object/node/etc number to be highlighted
+#  itemType: type of items to be highlighted
+#  showNumbers: if True, then the numbers of these items are shown
+def HighlightItem(SC, mbs, itemNumber, itemType=exudyn.ItemType.Object, showNumbers=True):
+    SC.visualizationSettings.interactive.highlightItemIndex = itemNumber
+    SC.visualizationSettings.interactive.highlightItemType = itemType
+    if showNumbers and itemType == exudyn.ItemType.Node:
+        SC.visualizationSettings.nodes.showNumbers = True
+        SC.visualizationSettings.nodes.show = True
+    else:
+        SC.visualizationSettings.nodes.showNumbers = False
+    if showNumbers and itemType == exudyn.ItemType.Object:
+        SC.visualizationSettings.bodies.showNumbers = True
+        SC.visualizationSettings.connectors.showNumbers = True
+        SC.visualizationSettings.bodies.show = True
+        SC.visualizationSettings.connectors.show = True
+    else:
+        SC.visualizationSettings.bodies.showNumbers = False
+        SC.visualizationSettings.connectors.showNumbers = False
+    if showNumbers and itemType == exudyn.ItemType.Marker:
+        SC.visualizationSettings.markers.showNumbers = True
+        SC.visualizationSettings.markers.show = True
+    else:
+        SC.visualizationSettings.markers.showNumbers = False
+    if showNumbers and itemType == exudyn.ItemType.Load:
+        SC.visualizationSettings.loads.showNumbers = True
+        SC.visualizationSettings.loads.show = True
+    else:
+        SC.visualizationSettings.loads.showNumbers = False
+    if showNumbers and itemType == exudyn.ItemType.Sensor:
+        SC.visualizationSettings.sensors.showNumbers = True
+        SC.visualizationSettings.sensors.show = True
+    else:
+        SC.visualizationSettings.sensors.showNumbers = False
+
+    mbs.SendRedrawSignal()
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**function: internal function used for CreateDistanceSensor
+def __UFsensorDistance(mbs, t, sensorNumbers, factors, configuration):
+
+    generalContactIndex = int(factors[0])
+    dirSensor = factors[5:8]
+    markerNumber = int(factors[1])
+    hasRotation = False
+    if markerNumber != -1:
+        p0 = mbs.GetMarkerOutput(markerNumber, variableType=exudyn.OutputVariableType.Position)
+        hasRotation = ('Rigid' in mbs.GetMarker(markerNumber)['markerType'])
+        if hasRotation:
+            A0 = mbs.GetMarkerOutput(markerNumber, variableType=exudyn.OutputVariableType.RotationMatrix).reshape((3,3))
+            dirSensor = A0 @ dirSensor
+    else:
+        p0 = np.array(factors[2:5])
+
+    [minDistance, maxDistance, cylinderRadius, selectedTypeIndex, measureVelocity, graphicsObject, flags] = factors[8:15]
+    selectedTypeIndex = exudyn.ContactTypeIndex(int(selectedTypeIndex)) #only converts from int
+    measureVelocity = bool(measureVelocity)
+    graphicsObject = int(graphicsObject)
+
+    gContact = mbs.GetGeneralContact(generalContactIndex)
+    data = gContact.ShortestDistanceAlongLine(pStart = p0, direction = dirSensor, 
+                                           minDistance=minDistance, maxDistance=maxDistance,
+                                           cylinderRadius=cylinderRadius, asDictionary=(measureVelocity==True),
+                                           typeIndex=selectedTypeIndex,
+                                           )
+    if measureVelocity:
+        d = data['distance']
+        v = data['velocityAlongLine']
+        rv = [d, v]
+    else:
+        d = data
+        rv = [d]
+
+    if graphicsObject != -1:
+        factLen = 1
+        if int(flags) == 0:
+            factLen = 0
+
+        mbs.SetObjectParameter(graphicsObject,'referencePosition',p0 + factLen*(d*np.array(Normalize(dirSensor))) )
+        if hasRotation:
+            mbs.SetObjectParameter(graphicsObject,'referenceRotation', A0)
+            
+    return rv
+
+
+
+#**function: Add geometry for distance sensor given by points and triangles (point indices) to mbs; use a rigid body marker where the geometry is put on; 
+#           Creates a GeneralContact for efficient search on background. If you have several sets of points and trigs, first merge them or add them manually to the contact
+#**input: 
+#  mbs: MainSystem where contact is created
+#  meshPoints: list of points (3D), as returned by GraphicsData2PointsAndTrigs()
+#  meshTrigs: list of trigs (3 node indices each), as returned by GraphicsData2PointsAndTrigs()
+#  rigidBodyMarkerIndex: rigid body marker to which the triangles are fixed on (ground or moving object)
+#  searchTreeCellSize: size of search tree (X,Y,Z); use larger values in directions where more triangles are located
+#**output: int; returns ngc, which is the number of GeneralContact in mbs, to be used in CreateDistanceSensor(...); keep the gContact as deletion may corrupt data
+#**notes: should be used by CreateDistanceSensor(...) and AddLidar(...) for simple initialization of GeneralContact; old name: DistanceSensorSetupGeometry(...)
+#**belongsTo: MainSystem
+def CreateDistanceSensorGeometry(mbs, meshPoints, meshTrigs, rigidBodyMarkerIndex, searchTreeCellSize=[8,8,8]):
+    gContact = mbs.AddGeneralContact()
+    gContact.SetFrictionPairings(0*np.eye(1)) #may not be empty
+    gContact.SetSearchTreeCellSize(numberOfCells=searchTreeCellSize)
+    # [meshPoints, meshTrigs] = RefineMesh(meshPoints, meshTrigs) #just to have more triangles on floor
+    gContact.AddTrianglesRigidBodyBased(rigidBodyMarkerIndex=rigidBodyMarkerIndex,
+                                        contactStiffness=1, contactDamping=1, #dummy values
+                                        frictionMaterialIndex=0, pointList=meshPoints, triangleList=meshTrigs)
+    gContact.isActive=False #no contact computation; could also be done later on, if many moving objects are used ...
+    ngc = mbs.NumberOfGeneralContacts()-1
+    gContact = mbs.GetGeneralContact(ngc) #keeps reference to gContact, while other functions work with automatic ...
+
+    return ngc
+
+#**function: Function to create distance sensor based on GeneralContact in mbs; sensor can be either placed on absolute position or attached to rigid body marker; in case of marker, dirSensor is relative to the marker
+#**input:
+#  mbs: the MainSystem where distance sensor is created
+#  generalContactIndex: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
+#  positionOrMarker: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
+#  dirSensor: the direction (no need to normalize) along which the distance is measured (must not be normalized); in case of marker, the direction is relative to marker orientation if marker contains orientation (BodyRigid, NodeRigid)
+#  minDistance: the minimum distance which is accepted; smaller distance will be ignored
+#  maxDistance: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
+#  cylinderRadius: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
+#  selectedTypeIndex: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
+#  storeInternal: like with any SensorUserFunction, setting to True stores sensor data internally
+#  fileName: if defined, recorded data of SensorUserFunction is written to specified file
+#  measureVelocity: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
+#  addGraphicsObject: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
+#  drawDisplaced: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
+#  color: optional color for 'laser beam' to be drawn
+#**output: SensorIndex; creates sensor and returns according sensor number of SensorUserFunction
+#**notes: use generalContactIndex = CreateDistanceSensorGeometry(...) before to create GeneralContact module containing geometry; old name: AddDistanceSensor(...)
+#**belongsTo: MainSystem
+def CreateDistanceSensor(mbs, generalContactIndex,
+                      positionOrMarker, dirSensor, minDistance=-1e7, 
+                      maxDistance=1e7, cylinderRadius=0, 
+                      selectedTypeIndex=exudyn.ContactTypeIndex.IndexEndOfEnumList,
+                      storeInternal = False, fileName = '', measureVelocity = False,
+                      addGraphicsObject=False, drawDisplaced=True, color=color4red):
+    
+    markerNumber = -1
+    p0list = [0,0,0]
+    if type(positionOrMarker) == list or type(positionOrMarker) == np.ndarray:
+        p0list = list(positionOrMarker)
+    elif type(positionOrMarker)==exudyn.MarkerIndex:
+        markerNumber = float(int(positionOrMarker))
+        try:
+            p0list = mbs.GetMarkerOutput(markerNumber=positionOrMarker,variableType=exu.OutputVariableType.Position, configuration=exu.ConfigurationType.Reference)
+            p0list = list(p0list)
+        except:
+            p0list = [0,0,0] #this was just a trial, otherwise initialize with zeros (e.g. for special objects where this does not work)
+    else:
+        raise ValueError('CreateDistanceSensor: positionOrMarker must be either MarkerIndex or 3D position as list or numpy.array')
+
+    graphicsObject = -1 #signals that there is no graphics object
+    sign = 1.
+    if drawDisplaced:
+        sign = -1.
+    if addGraphicsObject:
+        if cylinderRadius == 0:
+            gData = GraphicsDataLine([[0,0,0],list(sign*np.array(dirSensor))], color = color)
+        else: 
+            gData = GraphicsDataCylinder([0,0,0],sign*np.array(dirSensor), radius=cylinderRadius, color = color)
+            
+        graphicsObject=mbs.AddObject(ObjectGround(referencePosition= p0list,
+                                      visualization=VObjectGround(graphicsData=[gData])))
+
+    flags = int(drawDisplaced)
+    dataUF = [float(generalContactIndex)]
+    dataUF += [markerNumber] + p0list + list(dirSensor)
+    dataUF += [ minDistance, maxDistance, cylinderRadius, float(int(selectedTypeIndex)), float(measureVelocity), float(int(graphicsObject)), float(flags)] 
+
+
+    sUF = mbs.AddSensor(SensorUserFunction(sensorNumbers=[], factors=dataUF,
+                                              storeInternal=True,
+                                              sensorUserFunction=__UFsensorDistance))
+
+    return sUF
+
+
+#**function: DEPRECATED: Internal SensorUserFunction, used in function AddSensorRecorder
+#**notes: Warning: this method is DEPRECATED, use storeInternal in Sensors, which is much more performant; Note, that a sensor usually just passes through values of an existing sensor, while recording the values to a numpy array row-wise (time in first column, data in remaining columns)
+def UFsensorRecord(mbs, t, sensorNumbers, factors, configuration):
+    iSensor = sensorNumbers[0]
+    val = mbs.GetSensorValues(iSensor, configuration=configuration) #get all values
+    if type(val) == float:# or type(x) == nd.float64:
+        val = np.array([val]) #for scalar values
+    ti = int((t+1e-9)/factors[0]) #add 1e-10 safety factor due to rounding errors when adding time steps (may lead to small errors after 1e7 steps)
+    if ti >= 0 and ti < len(mbs.variables['sensorRecord'+str(iSensor)]):
+        mbs.variables['sensorRecord'+str(iSensor)][ti,0] = t
+        mbs.variables['sensorRecord'+str(iSensor)][ti,1:] = val
+        
+    return val #return value usually not used further
+
+#**function: DEPRECATED: Add a SensorUserFunction object in order to record sensor output internally; this avoids creation of files for sensors, which can speedup and simplify evaluation in ParameterVariation and GeneticOptimization; values are stored internally in mbs.variables['sensorRecord'+str(sensorNumber)] where sensorNumber is the mbs sensor number
+#**input: 
+#  mbs: mbs containing object
+#  sensorNumber: integer sensor number to be recorded
+#  endTime: end time of simulation, as given in simulationSettings.timeIntegration.endTime 
+#  sensorsWritePeriod: as given in simulationSettings.solutionSettings.sensorsWritePeriod
+#  sensorOutputSize: size of sensor data: 3 for Displacement, Position, etc. sensors; may be larger for RotationMatrix or Coordinates sensors; check this size by calling mbs.GetSensorValues(sensorNumber)
+#**output: adds an according SensorUserFunction sensor to mbs; returns new sensor number; during initialization a new numpy array is allocated in  mbs.variables['sensorRecord'+str(sensorNumber)] and the information is written row-wise: [time, sensorValue1, sensorValue2, ...]
+#**notes: Warning: this method is DEPRECATED, use storeInternal in Sensors, which is much more performant; Note, that a sensor usually just passes through values of an existing sensor, while recording the values to a numpy array row-wise (time in first column, data in remaining columns)
+def AddSensorRecorder(mbs, sensorNumber, endTime, sensorsWritePeriod, sensorOutputSize=3):
+    print('WARNING: AddSensorRecorder is DEPRECATED, use sensors and set storeInternal=True to achieve similar functionality')
+    nSteps = int(endTime/sensorsWritePeriod)
+    mbs.variables['sensorRecord'+str(sensorNumber)] = np.zeros((nSteps+1,1+sensorOutputSize)) #time+3 sensor values
+
+    sUserRecord = mbs.AddSensor(SensorUserFunction(sensorNumbers=[sensorNumber], 
+                                                   factors=[sensorsWritePeriod],
+                                                   writeToFile=False,
+                                                   sensorUserFunction=UFsensorRecord))
+    
+    return sUserRecord    
+    
+    
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++++   LOAD SOLUTION AND ANIMATION   ++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: read coordinates solution file (exported during static or dynamic simulation with option exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName='...') into dictionary:
+#**input: 
+#  fileName: string containing directory and filename of stored coordinatesSolutionFile
+#  saveMode: if True, it loads lines directly to load inconsistent lines as well; use this for huge files (>2GB); is slower but needs less memory!
+#  verbose: if True, some information is written when importing file (use for huge files to track progress)
+#  maxRows: maximum number of data rows loaded, if saveMode=True; use this for huge files to reduce loading time; set -1 to load all rows
+#  hasHeader: set to False, if file is expected to have no header; if False, then some error checks related to file header are not performed
+#**output: dictionary with 'data': the matrix of stored solution vectors, 'columnsExported': a list with integer values showing the exported sizes [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData], 'nColumns': the number of data columns and 'nRows': the number of data rows
+def LoadSolutionFile(fileName, safeMode=False, maxRows=-1, verbose=True, hasHeader=True):
+
+    #check if is binary or ASCII
+    isBinary = False
+    with open(fileName, 'r') as file:
+        data = np.fromfile(file, dtype=np.byte, count=6)
+        if data.size==6:
+            s = NumpyInt8ArrayToString(data)
+            if s=='EXUBIN':
+                isBinary=True
+
+    if isBinary:
+        return LoadBinarySolutionFile(fileName,maxRows,verbose)
+    
+    #read HEADER
+    if hasHeader:
+        with open(fileName) as fileRead:
+            # fileRead=open(fileName,'r') 
+            fileLines = []
+            fileLines += [fileRead.readline()]
+            fileLines += [fileRead.readline()]
+            fileLines += [fileRead.readline()]
+            fileLines += [fileRead.readline()]
+            fileLines += [fileRead.readline()]
+            # fileRead.close()
+    
+        if len(fileLines[4]) == 0:
+            raise ValueError('ERROR in LoadSolution: file empty or header missing')
+            
+        leftStr=fileLines[4].split('=')[0]
+        if leftStr[0:30] != '#number of written coordinates': 
+            raise ValueError('ERROR in LoadSolution: file header corrupted')
+    
+        columnsExported = eval(fileLines[4].split('=')[1]) #load according column information into vector: [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData]
+        nColumns = sum(columnsExported)
+
+    #read DATA
+    if not safeMode:
+        data = np.loadtxt(fileName, comments='#', delimiter=',')
+    else:
+        #alternative, but needs factor 5 times the memory of data loaded:
+        #  data = np.genfromtxt(fileName,comments='#',delimiter=',',invalid_raise=False)
+
+        with open(fileName) as file:
+            lines = file.readlines()
+        
+        if verbose: print('text file loaded ... converting ...')
+        
+        cntDataRows = 0
+        dataRowStart = -1
+        dataRowLast = 0
+
+        cnt = 0
+        cntComments = 0
+        for line in lines: 
+            if line[0]!='#': 
+                if dataRowStart == -1:
+                    dataRowStart = cnt
+                cntDataRows+=1
+                dataRowLast = cnt
+            else:
+                cntComments += 1
+            cnt+=1
+        
+        if verbose: print('found',cntComments,'lines with comments, which are ignored')
+            
+        if maxRows != -1 and cntDataRows > maxRows:
+            cntDataRows = maxRows
+        
+        if cntDataRows == 0 or dataRowStart == -1:
+            raise ValueError('LoadSolutionFile: no rows found')
+        else:
+            if verbose: print('data starts at ',dataRowStart, ', found ', cntDataRows, ' rows', sep='')
+
+        if verbose: print('check columns ...')
+        
+        cols = len(lines[dataRowStart].split(','))
+        if hasHeader:
+            if cols != nColumns+1:
+                raise ValueError('ERROR in LoadSolution: number of columns in first data row is inconsistent: got ',cols,' columns, but expected ', nColumns+1)
+        else:
+            nColumns=cols-1
+            columnsExported=[] #unknown ...
+            
+        #check last line, which may be incomplete:
+        #colsLastLine = len(lines[dataRowStart+cntDataRows-1].split(','))
+        colsLastLine = len(lines[dataRowLast].split(','))
+        skipLast = 0
+        if colsLastLine != cols:
+            if verbose: print('LoadSolution: WARNING number of columns in last data row is inconsistent; will be skipped')
+            skipLast = 1
+        
+        if verbose: print('file contains ',cntDataRows, ' rows and ', cols, ' columns (incl. time)',sep='')
+        
+        data = np.zeros((cntDataRows, nColumns+1))
+        
+        progress = 0
+        progressInfo = 5000000
+        skipLine = 0 #counter for skipping additional lines with comments
+        for i in range(cntDataRows-skipLast):
+            if verbose and progress>=progressInfo: #update progress
+                print('import data row', i, '/', cntDataRows)
+                progress = 0
+            progress+=nColumns
+            
+            while i+dataRowStart+skipLine<len(lines) and lines[i+dataRowStart+skipLine][0]=='#':
+                skipLine += 1
+            
+            ylist = lines[i+dataRowStart+skipLine].split(',')
+            if len(ylist) == nColumns+1:
+                y=np.array(ylist, dtype=float)
+                data[i,:] = y[:]
+            elif verbose:
+                print('  data row', i, 'is inconsistent:',len(ylist), nColumns+1,' ... skipped')
+
+    if verbose: print('columns imported =', columnsExported)
+    if verbose: print('total columns to be imported =', nColumns, ', array size of file =', np.size(data,1))
+
+    if (nColumns + 1) != np.size(data,1): #one additional column for time!
+        raise ValueError('ERROR in LoadSolution: number of columns is inconsistent')
+
+    nRows = np.size(data,0)
+
+    return dict({'data': data, 'columnsExported': columnsExported,'nColumns': nColumns,'nRows': nRows})
+
+
+#%%+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#helper functions for reading binary files:
+
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: simple conversion of int8 arrays into strings (not highly efficient, so use only for short strings)
+def NumpyInt8ArrayToString(npArray):
+    s=''
+    for x in npArray:
+        s+=chr(x)
+    return s
+
+#**function: read single Index from current file position in binary solution file
+def BinaryReadIndex(file, intType):
+    data = np.fromfile(file, dtype=intType, count=1)
+    if data.size != 1: return [0,True] #end of file
+    return [data[0], False]
+
+#**function: read single Real from current file position in binary solution file
+def BinaryReadReal(file, realType):
+    data = np.fromfile(file, dtype=realType, count=1)
+    if data.size != 1: return [0,True] #end of file
+    return [data[0], False]
+
+#**function: read string from current file position in binary solution file
+def BinaryReadString(file, intType):
+    dataLength = np.fromfile(file, dtype=intType, count=1)[0]
+    data = np.fromfile(file, dtype=np.byte, count=dataLength)
+    return [NumpyInt8ArrayToString(data), False]
+
+#**function: read Index array from current file position in binary solution file
+def BinaryReadArrayIndex(file, intType):
+    dataLength = np.fromfile(file, dtype=intType, count=1)[0]
+    data = np.fromfile(file, dtype=intType, count=dataLength)
+    return [data, False]
+
+#**function: read Real vector from current file position in binary solution file
+#**output: return data as numpy array, or False if no data read
+def BinaryReadRealVector(file, intType, realType):
+    sizeData = np.fromfile(file, dtype=intType, count=1)
+    if sizeData.size != 1: return [[],True] #end of file
+    dataLength = sizeData[0]
+    data = np.fromfile(file, dtype=realType, count=dataLength)
+    if data.size != dataLength: return [[],True] #end of file
+    return [data, False]
+
+
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: read BINARY coordinates solution file (exported during static or dynamic simulation with option exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName='...') into dictionary
+#**input: 
+#  fileName: string containing directory and filename of stored coordinatesSolutionFile
+#  verbose: if True, some information is written when importing file (use for huge files to track progress)
+#  maxRows: maximum number of data rows loaded, if saveMode=True; use this for huge files to reduce loading time; set -1 to load all rows
+#**output: dictionary with 'data': the matrix of stored solution vectors, 'columnsExported': a list with integer values showing the exported sizes [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData], 'nColumns': the number of data columns and 'nRows': the number of data rows
+def LoadBinarySolutionFile(fileName, maxRows=-1, verbose=True):
+    print('verbose=',verbose)
+    with open(fileName, 'r') as file:
+        data = np.fromfile(file, dtype=np.byte, count=6)
+        s = NumpyInt8ArrayToString(data)
+        if int(verbose)>1: print(s)
+        if s!='EXUBIN':
+            raise ValueError('LoadBinarySolutionFile: no binary header found!')
+
+        if verbose: print('read binary file')
+        fileEnd = False
+#             ExuFile::BinaryWriteHeader(solFile, bfs);
+        dataHeader = np.fromfile(file, dtype=np.byte, count=10)
+        #dataHeader[0] == '\n'
+        indexSize = int(dataHeader[1])
+        realSize = int(dataHeader[2])
+        pointerSize = int(dataHeader[3])
+        bigEndian = int(dataHeader[4])
+        
+        if indexSize==4:
+            intType = np.int32
+        elif indexSize==8:
+            intType = np.int64
+        else:
+            raise ValueError('Read binary file: invalid Index type size!')
+        
+        if realSize==4:
+            realType = np.float32
+        elif realSize==8:
+            realType = np.float64
+        else:
+            raise ValueError('LoadBinarySolutionFile: invalid Real type size!')
+        
+        if verbose>1: 
+            print('  indexSize=',indexSize)
+            print('  realSize=',realSize)
+            print('  pointerSize=',pointerSize)
+            print('  bigEndian=',bigEndian)
+
+#         ExuFile::BinaryWrite(EXUstd::exudynVersion, solFile, bfs);
+        sVersion, fileEnd=BinaryReadString(file, intType)
+        if verbose: print('  version=',sVersion)
+
+#         ExuFile::BinaryWrite(STDstring("Mode0000"), solFile, bfs); //change this in future to add new features
+        sMode, fileEnd=BinaryReadString(file, intType)
+        if int(verbose)>1: print('  mode=',sMode)
+
+#             STDstring str = "Exudyn " + GetSolverName() + " ";
+#             if (isStatic) { str+="static "; }
+#             str+="solver solution file";
+#             ExuFile::BinaryWrite(str, solFile, bfs);
+        sSolver, fileEnd=BinaryReadString(file, intType)
+        if int(verbose)>1: print('  solver=',sSolver)
+
+#             //solFile << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
+#             ExuFile::BinaryWrite(EXUstd::GetDateTimeString(), solFile, bfs);
+        sTime, fileEnd=BinaryReadString(file, intType)
+        if int(verbose)>1: print('  data/time=',sTime)
+
+#             //not needed in binary format:
+#             //solFile << "#columns contain: time, ODE2 displacements";
+#             //if (solutionSettings.exportVelocities) { solFile << ", ODE2 velocities"; }
+#             //if (solutionSettings.exportAccelerations) { solFile << ", ODE2 accelerations"; }
+#             //if (nODE1) { solFile << ", ODE1 coordinates"; } //currently not available, but for future solFile structure necessary!
+#             //if (nVel1) { solFile << ", ODE1 velocities"; }
+#             //if (solutionSettings.exportAlgebraicCoordinates) { solFile << ", AE coordinates"; }
+#             //if (solutionSettings.exportDataCoordinates) { solFile << ", ODE2 velocities"; }
+#             //solFile << "\n";
+
+#             //solFile << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
+#             //    nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
+#             ArrayIndex sysCoords({nODE2, nODE1, nAE, nData});
+#             ExuFile::BinaryWrite(sysCoords, solFile, bfs);
+        systemSizes, fileEnd=BinaryReadArrayIndex(file, intType)
+        if verbose: print('  systemSizes=',systemSizes)
+
+
+#             //solFile << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
+#             //    nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])
+#             ArrayIndex writtenCoords({ nODE2, nVel2, nAcc2, nODE1, nVel1, nAEexported, nDataExported });
+#             ExuFile::BinaryWrite(writtenCoords, solFile, bfs);
+        columnsExported, fileEnd=BinaryReadArrayIndex(file, intType)
+        if verbose: print('  columnsExported=',columnsExported)
+        nColumns = sum(columnsExported) #total size of data per row
+        
+#             //solFile << "#total columns exported  (excl. time) = " << totalCoordinates << "\n";
+#             ExuFile::BinaryWrite(totalCoordinates, solFile, bfs);
+        totalCoordinates, fileEnd = BinaryReadIndex(file, intType)
+
+#             Index numberOfSteps;
+#             if (!isStatic) { numberOfSteps = timeint.numberOfSteps; }
+#             else { numberOfSteps = staticSolver.numberOfLoadSteps; }
+#             ExuFile::BinaryWrite(numberOfSteps, solFile, bfs);
+        numberOfSteps, fileEnd = BinaryReadIndex(file, intType)
+        
+#             //solution information: always export string, even if has zero length:
+#             ExuFile::BinaryWrite(solutionSettings.solutionInformation, solFile, bfs);
+        solutionInformation, fileEnd=BinaryReadString(file, intType)
+        if int(verbose)>1: print('  solutionInformation="'+solutionInformation+'"')
+
+#             //add some checksum ...
+#             ExuFile::BinaryWrite(STDstring("EndOfHeader"), solFile, bfs);
+#             //next byte starts with solution
+        EndOfHeader, fileEnd=BinaryReadString(file, intType)
+        if int(verbose)>1: print('  EndOfHeader found: ',EndOfHeader)
+        if EndOfHeader!='EndOfHeader':
+            raise ValueError('LoadBinarySolutionFile: EndOfHeader not found')
+
+
+        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        #read time steps
+#         if (isBinary) //add size, only in binary mode
+#         {
+#             //including 1 real for time+1 Index for nVectors, but excluding bytes for this Index
+#             Index lineSizeBytes = nVectors * bfs.indexSize + nValues * bfs.realSize + bfs.indexSize + bfs.realSize;
+#             ExuFile::BinaryWrite(lineSizeBytes, solFile, bfs); //size of line, for fast skipping of solution line
+#             ExuFile::BinaryWrite(nVectors, solFile, bfs); //number of vectors could vary if needed
+#         }
+        if fileEnd: print('  ==> end of file found during in header')
+        fileEnd = False
+        data = np.zeros((0,nColumns+1))
+        nRows = 0
+        line = np.zeros(nColumns+1)
+        validEndFound = False
+        dataList = [] #list is much faster than hstack !
+        
+        while not fileEnd:
+            #print('read row ',nRows)
+            if maxRows != -1 and nRows >= maxRows:
+                fileEnd = True
+                break
+
+            #includes time and all values for solution according to header    
+            sizeData = np.fromfile(file, dtype=intType, count=1)
+            if sizeData.size != 1: 
+                fileEnd=True
+                break
+            dataLength = sizeData[0]
+            if dataLength  == -1:
+                if int(verbose)>1: print('end of file reached')
+                validEndFound = True
+                break
+            if int(verbose)>1: 
+                print('  dataLength=',dataLength)
+                
+            line = np.fromfile(file, dtype=realType, count=dataLength)
+            if line.size != dataLength: 
+                fileEnd=True
+                break
+            #line, fileEnd=BinaryReadRealVector(file, intType, realType)
+            if int(verbose)>1: 
+                print('  read',line.size, 'columns (',nColumns+1,'expected)')
+                print('  line=',line)
+            if fileEnd: break
+            if line.size != nColumns+1:
+                raise ValueError('LoadBinarySolutionFile: rows are inconsistent')
+            
+            nRows += 1
+
+            dataList+=[line]
+            #data = np.vstack((data, line)) #slow!
+
+        if verbose: print('  read '+str(nRows)+' rows from file')
+        
+        data = np.array(dataList)
+        nRows = np.size(data,0)
+
+        if not validEndFound:
+            print('LoadBinarySolutionFile: WARNING: end of file inconsistent!')
+        else:
+            if int(verbose)>1: 
+                print('  valid end of data found')
+                print('LoadBinarySolutionFile finished')
+    
+        return dict({'data': data, 'columnsExported': columnsExported,'nColumns': nColumns,'nRows': nRows})
+        
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: recover solution file with last row not completely written (e.g., if crashed, interrupted or no flush file option set)
+#**input: 
+#  fileName: string containing directory and filename of stored coordinatesSolutionFile
+#  newFileName: string containing directory and filename of new coordinatesSolutionFile
+#  verbose: 0=no information, 1=basic information, 2=information per row
+#**output: writes only consistent rows of file to file with name newFileName
+def RecoverSolutionFile(fileName, newFileName, verbose=0):
+    #read file header
+    fileRead=open(fileName,'r') 
+    fileLines = []
+    fileLines += [fileRead.readline()]
+    fileLines += [fileRead.readline()]
+    fileLines += [fileRead.readline()]
+    fileLines += [fileRead.readline()]
+    fileLines += [fileRead.readline()]
+    fileRead.close()
+    if len(fileLines[4]) == 0:
+        raise ValueError('ERROR in LoadSolution: file empty or header missing')
+        
+    leftStr=fileLines[4].split('=')[0]
+    if leftStr[0:30] != '#number of written coordinates': 
+        raise ValueError('ERROR in LoadSolution: file header corrupted')
+
+    columnsExported = eval(fileLines[4].split('=')[1]) #load according column information into vector: [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData]
+    nColumns = sum(columnsExported)
+    expectedColumns = nColumns+1
+    if verbose >= 1:
+        print('columns imported =', columnsExported)
+        print('total columns to be imported =', expectedColumns, '(incl. time)\n')
+
+
+    with open(newFileName, 'w') as fileWrite:
+        with open(fileName) as file:
+            cnt = 0
+            cntSolution = 0
+            for line in file:
+                if line[0] == '#':
+                    if len(line) < 1000 and verbose >= 1:
+                        print('HEADER:', line, end='')
+                    fileWrite.write(line)
+                else:
+                    #cols = len(line.split(','))
+                    cols = line.count(',')+1 #+1 needed, because two columns for one comma
+                    if cols == expectedColumns:
+                        if verbose >= 2:
+                            print('data row ',cntSolution,', #cols=',cols, ', text=',line[0:12],'...', sep='')
+                        fileWrite.write(line)
+                    else:
+                        if verbose >= 1:
+                            print('\nWARNING: ignored solution data',cntSolution, '(file line',cnt,'), columns=', cols, '\n')
+                    cntSolution += 1
+                
+                cnt += 1
+
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: recover initial coordinates, time, etc. from given restart file
+#**input: 
+#  mbs: MainSystem to be operated with
+#  simulationSettings: simulationSettings which is updated and shall be used afterwards for SolveDynamic(...) or SolveStatic(...)
+#  restartFileName: string containing directory and filename of stored restart file, as given in solutionSettings.restartFileName
+#  verbose: False=no information, True=basic information
+#**output: modifies simulationSettings and sets according initial conditions in mbs
+def InitializeFromRestartFile(mbs, simulationSettings, restartFileName, verbose=True):
+    raise ValueError('InitializeFromRestartFile: not fully implemented')
+
+    fileRead=open(fileName,'r') 
+    fileLines = fileRead.readlines()
+    
+    #fileLines = []
+    #fileLines += [fileRead.readline()]
+    #fileLines += [fileRead.readline()]
+    #fileLines += [fileRead.readline()]
+    #fileLines += [fileRead.readline()]
+    #fileLines += [fileRead.readline()]
+    fileRead.close()
+    if len(fileLines[4]) == 0:
+        raise ValueError('ERROR in InitializeFromRestartFile: file empty or header missing')
+        
+    leftStr=fileLines[4].split('=')[0]
+    if leftStr[0:30] != '#number of written coordinates': 
+        raise ValueError('ERROR in InitializeFromRestartFile: file header corrupted')
+
+    columnsExported = eval(fileLines[4].split('=')[1]) #load according column information into vector: [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData]
+    nColumns = sum(columnsExported)
+    expectedColumns = nColumns+1
+    if verbose:
+        print('columns available in restart file =', columnsExported)
+        print('total columns to be imported =', expectedColumns, '(incl. time)\n')
+
+    if fileLines[-1][0:9]!='#FINISHED':
+        raise ValueError('ERROR in InitializeFromRestartFile: last line does not contain "#FINISHED" and is thus expected to be corrupted!')
+
+    #now everything should be ok and we can just read the line with numpy:
+    data = np.loadtxt(fileName, comments='#', delimiter=',')
+    nRows = np.size(data,0) #should be 1
+    if nRows != 1:
+        raise ValueError('ERROR in InitializeFromRestartFile: got more than one rows, but expected one')
+
+    row = 0 #first row used 
+    rowData = data[row]
+    #cols = solution['columnsExported']
+    [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = columnsExported
+
+    #note that these visualization updates are not threading safe!
+    mbs.systemData.SetODE2Coordinates(rowData[1:1+nODE2], configuration)
+    if (nVel2): mbs.systemData.SetODE2Coordinates_t(rowData[1+nODE2:1+nODE2+nVel2], configuration)
+    if (nAcc2): mbs.systemData.SetODE2Coordinates_tt(rowData[1+nODE2+nVel2:1+nODE2+nVel2+nAcc2], configuration)
+    if (nODE1): mbs.systemData.SetODE1Coordinates(rowData[1+nODE2+nVel2+nAcc2:1+nODE2+nVel2+nAcc2+nODE1], configuration)
+    if (nVel1): mbs.systemData.SetODE1Coordinates_t(rowData[1+nODE2+nVel2+nAcc2+nODE1:1+nODE2+nVel2+nAcc2+nODE1+nVel1], configuration)
+    
+    if (nAlgebraic): mbs.systemData.SetAECoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic], configuration)
+    if (nData): mbs.systemData.SetDataCoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic+nData], configuration)
+
+    if configuration == exudyn.ConfigurationType.Visualization:
+        mbs.systemData.SetTime(rowData[0], exudyn.ConfigurationType.Visualization)
+        mbs.SendRedrawSignal()
+    
+    #add integration parameters to simulationSettings ...
+    
+    if verbose: print('\nInitializeFromRestartFile finished\n')
+    
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: load selected row of solution dictionary (previously loaded with LoadSolutionFile) into specific state; flag sendRedrawSignal is only used if configuration = exudyn.ConfigurationType.Visualization
+def SetSolutionState(mbs, solution, row, configuration=exudyn.ConfigurationType.Current, sendRedrawSignal=True):
+    if row < solution['nRows']:
+        rowData = solution['data'][row]
+        #cols = solution['columnsExported']
+        [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = solution['columnsExported']
+
+        #note that these visualization updates are not threading safe!
+        mbs.systemData.SetODE2Coordinates(rowData[1:1+nODE2], configuration)
+        if (nVel2): mbs.systemData.SetODE2Coordinates_t(rowData[1+nODE2:1+nODE2+nVel2], configuration)
+        if (nAcc2): mbs.systemData.SetODE2Coordinates_tt(rowData[1+nODE2+nVel2:1+nODE2+nVel2+nAcc2], configuration)
+        if (nODE1): mbs.systemData.SetODE1Coordinates(rowData[1+nODE2+nVel2+nAcc2:1+nODE2+nVel2+nAcc2+nODE1], configuration)
+        if (nVel1): mbs.systemData.SetODE1Coordinates_t(rowData[1+nODE2+nVel2+nAcc2+nODE1:1+nODE2+nVel2+nAcc2+nODE1+nVel1], configuration)
+        
+        if (nAlgebraic): mbs.systemData.SetAECoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic], configuration)
+        if (nData): mbs.systemData.SetDataCoordinates(rowData[1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic:1+nODE2+nVel2+nAcc2+nODE1+nVel1+nAlgebraic+nData], configuration)
+
+        if configuration == exudyn.ConfigurationType.Visualization:
+            mbs.systemData.SetTime(rowData[0], exudyn.ConfigurationType.Visualization)
+            mbs.SendRedrawSignal()
+    else:
+        print("ERROR in SetVisualizationState: invalid row (out of range)")
+
+#++++++++++++++++++++++++++++++++++++++++++++
+#**function: This function is not further maintaned and should only be used if you do not have tkinter (like on some MacOS versions); use exudyn.interactive.SolutionViewer() instead! AnimateSolution consecutively load the rows of a solution file and visualize the result
+#**input: 
+#  mbs: the system used for animation
+#  solution: solution dictionary previously loaded with LoadSolutionFile; will be played from first to last row
+#  rowIncrement: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
+#  timeout: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
+#  createImages: creates consecutively images from the animation, which can be converted into an animation
+#  runLoop: if True, the animation is played in a loop until 'q' is pressed in render window
+#**output: renders the scene in mbs and changes the visualization state in mbs continuously
+def AnimateSolution(mbs, solution, rowIncrement = 1, timeout=0.04, createImages = False, runLoop = False):
+    SC = mbs.GetSystemContainer()
+    nRows = solution['nRows']
+    if nRows == 0:
+        print('ERROR in AnimateSolution: solution file is empty')
+        return
+    if (rowIncrement < 1) or (rowIncrement > nRows):
+        print('ERROR in AnimateSolution: rowIncrement must be at least 1 and must not be larger than the number of rows in the solution file')
+    oldUpdateInterval = SC.visualizationSettings.general.graphicsUpdateInterval
+    SC.visualizationSettings.general.graphicsUpdateInterval = 0.5*min(timeout, 2e-3) #avoid too small values to run multithreading properly
+    mbs.SetRenderEngineStopFlag(False) #not to stop right at the beginning
+
+    while runLoop and not mbs.GetRenderEngineStopFlag():
+        for i in range(0,nRows,rowIncrement):
+            if not(mbs.GetRenderEngineStopFlag()):
+                #SetVisualizationState(exudyn, mbs, solution, i) #OLD
+                SetSolutionState(mbs, solution, i, exudyn.ConfigurationType.Visualization)
+                if createImages:
+                    SC.RedrawAndSaveImage() #create images for animation
+                #time.sleep(timeout)
+                exudyn.DoRendererIdleTasks(timeout)
+
+    SC.visualizationSettings.general.graphicsUpdateInterval = oldUpdateInterval #set values back to original
+
+
+
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: helper function which draws system graph of a MainSystem (mbs); several options let adjust the appearance of the graph; the graph visualization uses randomizer, which results in different graphs after every run!
+#**input:
+#   mbs: MainSystem to be operated with
+#   showLoads: toggle appearance of loads in mbs
+#   showSensors: toggle appearance of sensors in mbs
+#   useItemNames: if True, object names are shown instead of basic object types (Node, Load, ...)
+#   useItemTypes: if True, object type names (MassPoint, JointRevolute, ...) are shown instead of basic object types (Node, Load, ...); Note that Node, Object, is omitted at the beginning of itemName (as compared to theDoc.pdf); item classes become clear from the legend
+#   addItemTypeNames: if True, type nymes (Node, Load, etc.) are added
+#   multiLine: if True, labels are multiline, improving readability
+#   fontSizeFactor: use this factor to scale fonts, allowing to fit larger graphs on the screen with values < 1
+#   showLegend: shows legend for different item types
+#   layoutDistanceFactor: this factor influences the arrangement of labels; larger distance values lead to circle-like results
+#   layoutIterations: more iterations lead to better arrangement of the layout, but need more time for larger systems (use 1000-10000 to get good results)
+#   tightLayout: if True, uses matplotlib plt.tight\_layout() which may raise warning
+#**output: [Any, Any, Any]; returns [networkx, G, items] with nx being networkx, G the graph and item what is returned by nx.draw\_networkx\_labels(...)
+#**belongsTo: MainSystem
+def DrawSystemGraph(mbs, showLoads=True, showSensors=True, useItemNames = False, 
+                    useItemTypes = False, addItemTypeNames=True, multiLine=True, fontSizeFactor=1., 
+                    layoutDistanceFactor=3., layoutIterations=100, showLegend = True, tightLayout = True):
+    
+    try:
+        #all imports are part of anaconda (e.g. anaconda 5.2.0, python 3.6.5)
+        import numpy as np
+        import networkx as nx #for generating graphs and graph arrangement
+        import matplotlib.pyplot as plt #for drawing
+    except ImportError as e:
+        raise ImportError("numpy, networkx and matplotlib required for DrawSystemGraph(...)") from e
+    except :
+        print("DrawSystemGraph(...): unexpected error during import of numpy, networkx and matplotlib")
+        raise
+    
+    itemColors = {'Node':'red', 'Object':'skyblue', 'Oconnector':'dodgerblue', 'Ojoint':'dodgerblue', 'Ocontact':'dodgerblue', #turqoise, skyblue
+                      'Marker': 'orange', 'Load': 'mediumorchid', 
+                      'Sensor': 'forestgreen'} #https://matplotlib.org/examples/color/named_colors.html
+    
+    plt.clf()
+    
+    itemColorMap=[]     #color per item
+    itemNames=[]        #name per item 
+    itemTypes=[]        #name per item 
+    edgeColorMap=[]
+    nodesToItems=[]     #maps mbs-node numbers to item numbers
+    markersToItems=[]   #maps mbs-marker numbers to item numbers
+    objectsToItems=[]   #maps mbs-object numbers to item numbers
+    loadsToItems=[]     #maps mbs-load numbers to item numbers
+    sensorsToItems=[]   #maps mbs-sensor numbers to item numbers
+    
+    objectNodeColor = 'navy' #color for edges between nodes and objects, to be highlighted
+            
+    G = nx.Graph()
+    
+    #showLegend = False
+    #addItemTypeNames = False #Object, Node, ... not added but legend added
+    # if useItemTypes or useItemNames:
+    #     showLegend = True
+
+    sLineBreak = ''
+    if multiLine:
+        sLineBreak = '-\n'
+
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    itemType = 'Node'
+    n = mbs.systemData.NumberOfNodes()
+    for i in range(n):
+        item = mbs.GetNode(i)
+        itemName=itemType+str(i)
+    
+        nodeName = 'Node'
+        if item['nodeType'].find('Ground') != -1:
+            nodeName = nodeName + 'Ground'
+    
+        if useItemNames:
+            itemName=item['name'] #+str(i)
+        elif useItemTypes:
+            itemName=item['nodeType']+str(i)
+            if addItemTypeNames:
+                itemName = nodeName + sLineBreak + itemName
+
+            if sLineBreak != '':
+                itemName=itemName.replace('Node'+sLineBreak+'Rigid','NodeRigid'+sLineBreak)
+                itemName=itemName.replace('Node'+sLineBreak+'Generic','NodeGeneric'+sLineBreak)
+    
+        G.add_node(itemName) #attributes: size, weight, ...
+        nodesToItems += [len(itemColorMap)]
+        itemColorMap += [itemColors[itemType]]
+        itemNames += [itemName]
+        itemTypes += [itemType]
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #add markers without edges
+    itemType = 'Marker'
+    n = mbs.systemData.NumberOfMarkers()
+    for i in range(n):
+        item = mbs.GetMarker(i)
+        itemName=itemType+str(i)
+        if useItemNames:
+            itemName=item['name']#+str(i)
+        elif useItemTypes:
+            itemName=item['markerType']+str(i)
+            if addItemTypeNames:
+                itemName = 'Marker' + sLineBreak + itemName
+
+            if sLineBreak != '':
+                itemName=itemName.replace('Marker'+sLineBreak+'Body','MarkerBody'+sLineBreak)
+                itemName=itemName.replace('Marker'+sLineBreak+'Object','MarkerObject'+sLineBreak)
+                itemName=itemName.replace('Marker'+sLineBreak+'Node','MarkerNode'+sLineBreak)
+                itemName=itemName.replace('Marker'+sLineBreak+'SuperElement','MarkerSuperElement'+sLineBreak)
+                itemName=itemName.replace('Marker'+sLineBreak+'Kinematic','MarkerKinematic'+sLineBreak)
+    
+        G.add_node(itemName) #attributes: size, weight, ...
+        markersToItems += [len(itemColorMap)]
+        itemColorMap += [itemColors[itemType]]
+        itemNames += [itemName]
+        itemTypes += [itemType]
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    itemType = 'Object'
+    n = mbs.systemData.NumberOfObjects()
+    for i in range(n):
+        objectType = itemType
+        item = mbs.GetObject(i)
+        if item['objectType'].find('Connector') != -1:
+            objectType = 'Oconnector'
+        elif item['objectType'].find('Contact') != -1:
+            objectType = 'Ocontact'
+        elif item['objectType'].find('Joint') != -1:
+            objectType = 'Ojoint'
+        itemName=objectType+str(i)
+    
+        if useItemNames:
+            itemName=item['name']#+str(i)
+        elif useItemTypes:
+            itemName=item['objectType']+str(i)
+            if addItemTypeNames:
+                itemName = 'Object' + sLineBreak + itemName
+            
+            if sLineBreak != '':
+                itemName=itemName.replace('Object'+sLineBreak+'Joint','ObjectJoint'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'Mass','ObjectMass'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'Beam','ObjectBeam'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'ANCF','ObjectANCF'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'Contact','ObjectContact'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'Connector','ObjectConnector'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'Rigid','ObjectRigid'+sLineBreak)
+                itemName=itemName.replace('Object'+sLineBreak+'FFRFr','ObjectFFRF'+sLineBreak+'r')
+            
+        G.add_node(itemName) #attributes: size, weight, ...
+        objectsToItems += [len(itemColorMap)]
+        itemNames += [itemName]
+        itemTypes += [itemType]
+        itemColorMap += [itemColors[objectType]]
+    
+    #    objectColor = ''
+        #for objects: add edges to nodes
+        nodeNumbers = []
+        if 'nodeNumber' in item:
+            nodeNumbers += [item['nodeNumber']]
+        if 'nodeNumbers' in item:
+            nodeNumbers += item['nodeNumbers']
+    
+        for j in range(len(nodeNumbers)):
+            nodeNumbers[j] = int(nodeNumbers[j])
+    
+        for j in nodeNumbers:
+            if j != exudyn.InvalidIndex(): #for RigidBodySpringDamper
+                G.add_edge(itemNames[objectsToItems[i]],itemNames[nodesToItems[j]],color=objectNodeColor)
+    
+        #for connectors, contact, joint: add edges to these objects
+        markerNumbers = []
+        if 'markerNumbers' in item: #should only be markerNumbers ...
+            markerNumbers += item['markerNumbers']
+    
+        for j in range(len(markerNumbers)):
+            markerNumbers[j] = int(markerNumbers[j])
+    
+        for j in markerNumbers:
+            G.add_edge(itemNames[objectsToItems[i]],itemNames[markersToItems[j]], color=itemColors['Oconnector'])
+            
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #now add only edges for markers:
+    itemType = 'Marker'
+    n = mbs.systemData.NumberOfMarkers()
+    for i in range(n):
+        objectType = itemType
+        item = mbs.GetMarker(i)
+    
+        #for node markers:
+        nodeNumbers = []
+        if 'nodeNumber' in item:
+            nodeNumbers += [item['nodeNumber']]
+       
+        for j in range(len(nodeNumbers)):
+            nodeNumbers[j] = int(nodeNumbers[j])
+    
+        for j in nodeNumbers:
+            G.add_edge(itemNames[markersToItems[i]],itemNames[nodesToItems[j]],color='orange')
+    
+        #for object markers:
+        objectNumbers = []
+        if 'objectNumber' in item: objectNumbers += [item['objectNumber']]
+        if 'bodyNumber' in item: objectNumbers += [item['bodyNumber']]
+       
+        for j in range(len(objectNumbers)):
+            objectNumbers[j] = int(objectNumbers[j])
+    
+        for j in objectNumbers:
+            G.add_edge(itemNames[markersToItems[i]],itemNames[objectsToItems[j]],color='orange')
+            
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #add loads
+    if showLoads:
+        itemType = 'Load'
+        n = mbs.systemData.NumberOfLoads()
+        for i in range(n):
+            item = mbs.GetLoad(i)
+            itemName=itemType+str(i)
+            if useItemNames:
+                itemName=item['name']#+str(i)
+            elif useItemTypes:
+                itemName=item['loadType']+str(i)
+                if addItemTypeNames:
+                    itemName = 'Load' + sLineBreak + itemName
+
+                if sLineBreak != '':
+                    itemName=itemName.replace('Load'+sLineBreak+'Mass','LoadMass'+sLineBreak)
+
+        
+            G.add_node(itemName) #attributes: size, weight, ...
+            loadsToItems += [len(itemColorMap)]
+            itemColorMap += [itemColors[itemType]]
+            itemNames += [itemName]
+            itemTypes += [itemType]
+    
+            markerNumbers = [int(item['markerNumber'])]
+            
+            for j in markerNumbers:
+                G.add_edge(itemNames[loadsToItems[i]],itemNames[markersToItems[j]], color=itemColors['Load'])
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #add sensors
+    if showSensors:
+        itemType = 'Sensor'
+        n = mbs.systemData.NumberOfSensors() #only available for Exudyn version >= 1.0.15
+        for i in range(n):
+            item = mbs.GetSensor(i)
+            itemName=itemType+str(i)
+            if useItemNames:
+                itemName=item['name']#+str(i)
+            elif useItemTypes:
+                itemName=item['sensorType']+str(i)
+                if addItemTypeNames:
+                    itemName = 'Sensor' + sLineBreak + itemName
+        
+            G.add_node(itemName) #attributes: size, weight, ...
+            sensorsToItems += [len(itemColorMap)]
+            itemColorMap += [itemColors[itemType]]
+            itemNames += [itemName]
+            itemTypes += [itemType]
+    
+            #for object sensors:
+            objectNumbers = []
+            if 'objectNumber' in item: objectNumbers += [item['objectNumber']]
+            if 'bodyNumber' in item: objectNumbers += [item['bodyNumber']]
+           
+            for j in range(len(objectNumbers)):
+                objectNumbers[j] = int(objectNumbers[j])
+        
+            for j in objectNumbers:
+                G.add_edge(itemNames[sensorsToItems[i]],itemNames[objectsToItems[j]],color=itemColors[itemType])
+
+            #for node sensors:
+            nodeNumbers = []
+            if 'nodeNumber' in item: nodeNumbers += [int(item['nodeNumber'])]
+                   
+            for j in nodeNumbers:
+                G.add_edge(itemNames[sensorsToItems[i]],itemNames[nodesToItems[j]],color=itemColors[itemType])
+       
+    if showLegend:
+        legendColors = {'Node':'red', 'Object':'skyblue', 'Object(Connector)':'dodgerblue', 
+                      'Marker': 'orange', 'Load': 'mediumorchid', 
+                      'Sensor': 'forestgreen'} 
+        #f = plt.figure(1)
+        #ax = f.add_subplot(1,1,1)
+        for label in legendColors:
+            plt.plot([0],[0],linewidth=8,color=legendColors[label],label=label)
+        
+        fontSizeLegend = 10
+        if fontSizeFactor > 1: #do not make font size smaller!
+            fontSizeLegend *= fontSizeFactor
+        plt.legend(fontsize=fontSizeLegend)
+
+    
+    #now get out the right sorting of colors ...
+    edgeColorMap = []
+    edgeWidths = []
+    edges=G.edges()
+    for item in edges.items(): 
+        edgeColorMap += [item[1]['color']] #color is in item[1], which is a dictionary ...
+        edgeWidth = 2
+        if item[1]['color'] == objectNodeColor: #object-node should be emphasized
+            edgeWidth = 4
+        edgeWidths += [edgeWidth]
+    
+    pos = nx.drawing.spring_layout(G, scale=0.5, k=layoutDistanceFactor*1/sqrt(G.size()), 
+                                   threshold = 1e-5, iterations = layoutIterations)
+    nx.draw_networkx_nodes(G, pos, node_size=1)
+    nx.draw_networkx_edges(G, pos, edge_color=edgeColorMap, width=edgeWidths)#width=2)
+    
+    #reproduce what draw_networkx_labels does, allowing different colors for nodes
+    #check: https://networkx.github.io/documentation/stable/_modules/networkx/drawing/nx_pylab.html
+    items = nx.draw_networkx_labels(G, pos, font_size=10*fontSizeFactor, clip_on=False, #clip at plot boundary
+                                    bbox=dict(facecolor='skyblue', edgecolor='black', 
+                                              boxstyle='round,pad=0.1', lw=10*fontSizeFactor)) #lw is border size (no effect?)
+
+    
+    #now assign correct colors:
+    for i in range(len(itemNames)):
+        currentColor = itemColorMap[i]
+        itemType = itemTypes[i]
+        boxStyle = 'round,pad=0.2'
+        fontSize = 10*fontSizeFactor
+        if itemType == 'Object':
+            boxStyle = 'round,pad=0.2'
+            fontSize = 12*fontSizeFactor
+        if itemType == 'Node':  
+            boxStyle = 'square,pad=0.1'
+            fontSize = 10*fontSizeFactor
+        if itemType == 'Marker':  
+            boxStyle = 'square,pad=0.1'
+            fontSize = 8*fontSizeFactor
+    
+        #print("color=",currentColor)
+        items[itemNames[i]].set_bbox(dict(facecolor=currentColor,  
+              edgecolor=currentColor, boxstyle=boxStyle))
+        items[itemNames[i]].set_fontsize(fontSize)
+    
+    plt.axis('off') #do not show frame, because usually some nodes are very close to frame ...
+    if tightLayout:
+        plt.tight_layout()
+    plt.margins(x=0.1*fontSizeFactor, y=0.1*fontSizeFactor) #larger margin, to avoid clipping of long texts
+    plt.draw() #force redraw after colors have changed
+    
+    return [nx, G, items]
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#                              SPECIAL FUNCTIONS FOR EXUDYN
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#TCP/IP functionality
+#**class: helper class for CreateTCPIPconnection and for TCPIPsendReceive
+class TCPIPdata:
+    def __init__(self, sendSize, receiveSize, packerSend, packerReceive, 
+                  socketTCP, connection, address, lastReceiveTime):
+        self.sendSize = sendSize
+        self.receiveSize = receiveSize
+        self.packerSend = packerSend
+        self.packerReceive = packerReceive
+        self.socket = socketTCP
+        self.connection = connection
+        self.address = address
+        self.lastReceiveTime = lastReceiveTime #usually zero; used to make substeps in mbs
+        
+        
+#**function: function which has to be called before simulation to setup TCP/IP socket (server) for 
+#  sending and receiving data; can be used to communicate with other Python interpreters
+#  or for communication with MATLAB/Simulink
+#**input:
+#  sendSize: number of double values to be sent to TCPIP client
+#  receiveSize: number of double values to be received from TCPIP client
+#  IPaddress: string containing IP address of client (e.g., '127.0.0.1')
+#  port: port for communication with client
+#  bigEndian: if True, it uses bigEndian, otherwise littleEndian is used for byte order
+#**output: returns information (TCPIPdata class) on socket; recommended to store this in mbs.sys['TCPIPobject']
+#**example:
+# mbs.sys['TCPIPobject'] = CreateTCPIPconnection(sendSize=3, receiveSize=2, 
+#                                                bigEndian=True, verbose=True)
+# sampleTime = 0.01 #sample time in MATLAB! must be same!
+# mbs.variables['tLast'] = 0 #in case that exudyn makes finer steps than sample time
+
+# def PreStepUserFunction(mbs, t):
+#     if t >= mbs.variables['tLast'] + sampleTime:
+#         mbs.variables['tLast'] += sampleTime
+
+#         tcp = mbs.sys['TCPIPobject']
+#         y = TCPIPsendReceive(tcp, np.array([t, np.sin(t), np.cos(t)])) #time, torque
+#         tau = y[1]
+#         print('tau=',tau)
+#     return True
+
+
+# try:
+#     mbs.SetPreStepUserFunction(PreStepUserFunction)
+    
+#     #%%++++++++++++++++++++++++++++++++++++++++++++++++++
+#     mbs.Assemble()
+#     [...] #start renderer; simulate model
+# finally: #use this to always close connection, even in case of errors
+#     CloseTCPIPconnection(mbs.sys['TCPIPobject'])
+#
+# #*****************************************
+# #the following settings work between Python and MATLAB-Simulink (client), and gives stable results(with only delay of one step):
+# # TCP/IP Client Send:
+# #   priority = 2 (in properties)
+# #   blocking = false
+# #   Transfer Delay on (but off also works)
+# # TCP/IP Client Receive:
+# #   priority = 1 (in properties)
+# #   blocking = true
+# #   Sourec Data type = double
+# #   data size = number of double in packer
+# #   Byte order = BigEndian
+# #   timeout = 10
+def CreateTCPIPconnection(sendSize, receiveSize, IPaddress='127.0.0.1', port=52421, 
+                          bigEndian=False, verbose=False):
+    import socket
+    import struct
+    s = ''
+    if bigEndian:
+        s = '>' #signals bigEndian format
+    packerSend = struct.Struct(s+'d '*sendSize) #'>' for big endian in matlab, I=unsigned int, i=int, d=double
+    packerReceive = struct.Struct(s+'d '*receiveSize) #'>' for big endian in matlab, I=unsigned int, i=int, d=double
+    if verbose:
+        print('setup TCP/IP socket ...')
+    socketTCP = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    socketTCP.bind((IPaddress, port))
+    socketTCP.listen()
+    connection, address = socketTCP.accept()
+
+    if verbose:
+        print('TCP/IP connection running!')
+
+    return TCPIPdata(sendSize, receiveSize, packerSend, packerReceive, 
+                     socketTCP, connection, address, 0.)
+
+#**function: call this function at every simulation step at which you intend to communicate with
+#  other programs via TCPIP; e.g., call this function in preStepUserFunction of a mbs model
+#**input:
+#  TCPIPobject: the object returned by CreateTCPIPconnection(...)
+#  sendData: numpy array containing data (double array) to be sent; must agree with sendSize
+#**output: returns array as received from TCPIP
+#**example:
+#mbs.sys['TCPIPobject']=CreateTCPIPconnection(sendSize=2, receiveSize=1, IPaddress='127.0.0.1')
+#y = TCPIPsendReceive(mbs.sys['TCPIPobject'], np.array([1.,2.]))
+#print(y)
+#
+def TCPIPsendReceive(TCPIPobject, sendData):
+    #first send data (no other way in MATLAB):
+    TCPIPobject.connection.sendall(TCPIPobject.packerSend.pack(*sendData))
+
+    #now receive data:
+    data = TCPIPobject.connection.recv(TCPIPobject.packerReceive.size) #data size in bytes
+    if not data:
+        print('WARNING: TCPIPsendReceive: loss of data') #usually does not happen!
+        return np.zeros(TCPIPobject.receiveSize)
+    else:
+        return TCPIPobject.packerReceive.unpack(data)
+
+#**function: close a previously created TCPIP connection
+def CloseTCPIPconnection(TCPIPobject):
+    TCPIPobject.connection.close()
+    TCPIPobject.socket.close()
+    
+
+
```

## exudyn/robotics/__init__.py

 * *Ordering differences only*

```diff
@@ -1,24 +1,24 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library for robotics
-#
-# Details:  This the EXUDYN robotics submodule initialization file
-#
-# Author:   Johannes Gerstmayr
-# Date:     2021-12-02
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#roboticsCore is the core robotics module;
-#everything inside roboticsCore goes into exudyn.robotics !
-from .roboticsCore import *
-
-##this makes the submodules available; does not work under Python 3.6:
-#import exudyn.robotics.utilities as utilities
-#import exudyn.robotics.future as future
-#import exudyn.robotics.special as special
-#import exudyn.robotics.models as models
-#import exudyn.robotics.mobile as mobile
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library for robotics
+#
+# Details:  This the EXUDYN robotics submodule initialization file
+#
+# Author:   Johannes Gerstmayr
+# Date:     2021-12-02
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#roboticsCore is the core robotics module;
+#everything inside roboticsCore goes into exudyn.robotics !
+from .roboticsCore import *
+
+##this makes the submodules available; does not work under Python 3.6:
+#import exudyn.robotics.utilities as utilities
+#import exudyn.robotics.future as future
+#import exudyn.robotics.special as special
+#import exudyn.robotics.models as models
+#import exudyn.robotics.mobile as mobile
+
+
```

## exudyn/robotics/future.py

 * *Ordering differences only*

```diff
@@ -1,557 +1,557 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is a submodule of the EXUDYN python robotics library
-#
-# Details:  The future module contains functionality which is currently under development
-#           and will be moved in other robotics libraries in future
-#
-# Authors:  Martin Sereinig
-# Date:     2023-03-27
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-
-import numpy as np
-import exudyn.robotics as rob
-from exudyn.basicUtilities import ScalarMult
-from exudyn.rigidBodyUtilities import RotationMatrix2RotZYZ, HT2rotationMatrix, HT2translation, Skew, HTtranslate
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#            Interaction with Toolbox by Peter Corke
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: makeCorkeRobot, creates robot using the peter corke toolbox using standard (stdDH) or modified (modKKDH) Denavid Hartenberg parameters
-#**input: 
-#  robotDic: robot dictionary by exudyn robotic models
-#  dhpara: stDH for standard DH parameter, modKKDH for modified DH parameter 
-#**output: serial robot object by corke
-#**author: Martin Sereinig
-#**notes: 
-#    DH Parameter Information:
-#    stdH = [theta, d, a, alpha] with Rz(theta) * Tz(d) * Tx(a) * Rx(alpha)
-#    modDH = [alpha, dx, theta, rz] with 
-#    used by Corke and Lynch: Rx(alpha) * Tx(a) * Rz(theta) * Tz(d)
-#    used by Khali:           Rx(alpha) * Tx(d) * Rz(theta) * Tz(r)
-#    Important note:  d(khali)=a(corke)  and r(khali)=d(corke)  
-def MakeCorkeRobot(robotDic):
-    
-    try:
-        import roboticstoolbox as rtb
-        from spatialmath import SE3
-        print('roboticstoolbox and spatialmath module are installed')
-
-        nLinks = len(robotDic['links'])
-        dhpara = robotDic['dhMode']
-        Links = []
-        if dhpara == 'stdDH':
-            for i in range(nLinks):
-                Links += [rtb.RevoluteDH(d = robotDic['links'][i][dhpara][1], a = robotDic['links'][i][dhpara][2], alpha = robotDic['links'][i][dhpara][3])]
-                
-        elif dhpara == 'modKKDH':
-            for i in range(nLinks):   
-                Links += [rtb.RevoluteMDH(d = robotDic['links'][i][dhpara][3], a = robotDic['links'][i][dhpara][1], alpha = robotDic['links'][i][dhpara][0])]
-        
-        robotCorke = rtb.robot.DHRobot ( Links )
-        
-    except Exception as e: 
-        
-        print('Error form exception! Check installation of roboticstoolbox from Peter Corke:',e)
-        
-
-    return robotCorke
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#            INVERSE KINEMATICS
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#**function: calculates the analytical inverse kinematics for 3R elbow type serial robot manipulator
-#**input:
-#  robotDic: robot dictionary
-#  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
-#**output: solutions, list of lists with posible joint angles [q1,q2,q3] (in radiant)
-#          to achive the desired position (4 posible solutions,schoulder left/right, ellbow up/down ) in following order: left/down, left/up, right/up, right/down
-#**author: Martin Sereinig
-#**notes:  only applicable for standard Denavit-Hartenberg parameters
-#**status: testet with various configurations and joint angels
-def ComputeIK3R(robotDic, HT):
-    ZERO = 10e-10
-    # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
-    qSolutions = np.empty((4, 3))
-
-    d1 = robotDic['links'][0]['stdDH'][1]
-    a2 = robotDic['links'][1]['stdDH'][2]
-    a3 = robotDic['links'][2]['stdDH'][2]
-
-    Px = HT[0][3]
-    Py = HT[1][3]
-    Pz = HT[2][3]
-
-    # calculations following the steps by De Luca / Standard geometric approach
-    # calculations for theta 1
-    if Px**2+Py**2 > ZERO:
-        qSolutions[0, 0] = np.arctan2(Py, Px)
-        qSolutions[1, 0] = np.arctan2(-Py, -Px)
-        qSolutions[2, 0] = np.arctan2(Py, Px)
-        qSolutions[3, 0] = np.arctan2(-Py, -Px)
-    else:
-        print('infinite solutions for th1,it is undefined but here set to 0')
-    
-    for i in range(len(qSolutions)):
-        HT01 = rob.DH2HT([qSolutions[i, 0]]+robotDic['links'][0]['stdDH'][1:4])
-        #print(HT01)
-        Dhelp = ((Px-HT01[0][3])**2+(Py-HT01[1][3])**2+(Pz-HT01[2][3])**2-a2**2-a3**2)/(2*a2*a3)
-        #print(Dhelp)
-        if np.abs(Dhelp)<=1:
-           if i <= 1:
-                qSolutions[i,2] = np.arctan2(np.sqrt((1-Dhelp**2)), Dhelp)
-                qSolutions[i,1] = np.arctan2(Pz-HT01[2][3], np.sqrt((Px)**2+(Py)**2))-np.arctan2(a3*np.sin(qSolutions[i,2]), a2+a3*np.cos(qSolutions[i,2]))
-           else:
-                qSolutions[i, 2] = np.arctan2(-np.sqrt((1-Dhelp**2)), Dhelp)
-                qSolutions[i,1] = np.arctan2(Pz-HT01[2][3], np.sqrt((Px)**2+(Py)**2))-np.arctan2(a3*np.sin(qSolutions[i,2]), a2+a3*np.cos(qSolutions[i,2]))
-           if i==1 or i==3:
-                qSolutions[i,1]=np.pi-qSolutions[i,1]
-                qSolutions[i,2]=-qSolutions[i,2]
-        else:
-            #print('no solution found for this point')
-            qSolutions[i,2]=np.nan
-            qSolutions[i,1]=np.nan
-        
-
-    solutionsarray = np.array(qSolutions)
-    index2delete = []
-    for i in range(len(solutionsarray)):
-        TSol = rob.ComputeJointHT(robotDic, solutionsarray[i])[2]
-        errorSolution = np.linalg.det(HT)-np.linalg.det(TSol)
-
-        # print(errorSolution)
-        if errorSolution > ZERO or np.isnan(errorSolution):
-            index2delete += [i]
-
-
-    #solutionsarray=np.delete(solutionsarray,index2delete,axis=0)   # to delete a row of wrong or nan solutions
-    #print(['Solutions to delete: ']+[str((index2delete))])
-
-    return solutionsarray
-
-
-
-#**function: calculates the analytical inverse kinematics for Puma560 serial 6R robotDic manipulator
-#**input:
-#  robotDic: robotDictionary
-#  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
-#**output: qSolutions, list of lists with posible joint angles [q1,q2,q3,q4,q5,q6] (in radiant)
-#          to achive the desired position and orientation (8 posible solutions,schoulder left/right, ellbow up/down, wrist flipped/notflipped (rotated by pi) )
-#          left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped
-#**author: Martin Sereinig
-#**notes:  Usage for different manipulators with sperical wrist posible, only applicable for standard Denavit-Hartenberg parameters
-#**status: tested (compared with robotDiccs, Vision and Control book of P. Corke
-def ComputeIKPuma560(robotDic, HT):
-    # - Inverse kinematics for a PUMA 560,
-    #   Paul and Zhang,
-    #   The International Journal of Robotics Research,
-    #   Vol. 5, No. 2, Summer 1986, p. 32-44
-    # Solve for theta(1)
-    # r is defined in equation 38, p. 39.
-    # theta(1) uses equations 40 and 41, p.39,
-
-
-    # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
-
-    a2 = robotDic['links'][1]['stdDH'][2]
-    a3 = robotDic['links'][2]['stdDH'][2]
-    d3 = robotDic['links'][2]['stdDH'][1]
-    d4 = robotDic['links'][3]['stdDH'][1]
-
-    a5= robotDic['links'][4]['stdDH'][2]
-    d6= robotDic['links'][5]['stdDH'][1]
-
-
-    # The following parameters are extracted from the homogeneous
-    # transformation as defined in equation 1, p. 34
-    # Positon of Wrist Center
-    Px = HT[0][3]
-    Py = HT[1][3]
-    Pz= HT[2][3] - robotDic['links'][0]['stdDH'][1]
-
-    # Solve for theta(1)
-    r = np.sqrt(Px**2 + Py**2)
-
-
-    theta1_1 = np.arctan2(Py, Px) + np.pi - np.arcsin(d3/r) # base left
-    theta1_2 = np.arctan2(Py, Px) + np.arcsin(d3/r)         # base right
-
-    #
-    # Solve for theta(2)
-    #
-    # V114 is defined in equation 43, p.39.
-    # r is defined in equation 47, p.39.
-    # Psi is defined in equation 49, p.40.
-    # theta(2) uses equations 50 and 51, p.40, based on the configuration
-    # parameter n2
-
-    V114_1 = Px*np.cos(theta1_1) + Py*np.sin(theta1_1)
-    r_1 = np.sqrt(V114_1**2 + Pz**2)
-    Psi_1 = np.arccos((a2**2-d4**2-a3**2+V114_1**2+Pz**2)/(2.0*a2*r_1))
-    theta2_11 = np.arctan2(Pz, V114_1) + Psi_1
-
-    V114_1 = Px*np.cos(theta1_1) + Py*np.sin(theta1_1)
-    r_1 = np.sqrt(V114_1**2 + Pz**2)
-    Psi_1 = np.arccos((a2**2-d4**2-a3**2+V114_1**2+Pz**2)/(2.0*a2*r_1))
-    theta2_12 = np.arctan2(Pz, V114_1) - Psi_1
-
-    V114_2 = Px*np.cos(theta1_2) + Py*np.sin(theta1_2)
-    r_2 = np.sqrt(V114_2**2 + Pz**2)
-    Psi_2 = np.arccos((a2**2-d4**2-a3**2+V114_2**2+Pz**2)/(2.0*a2*r_2))
-    theta2_21 = np.arctan2(Pz, V114_2) + Psi_2
-
-    V114_2 = Px*np.cos(theta1_2) + Py*np.sin(theta1_2)
-    r_2 = np.sqrt(V114_2**2 + Pz**2)
-    Psi_2 = np.arccos((a2**2-d4**2-a3**2+V114_2**2+Pz**2)/(2.0*a2*r_2))
-    theta2_22 = np.arctan2(Pz, V114_2) - Psi_2
-
-    # Solve for theta(3)
-    # theta(3) uses equation 57, p. 40.
-    num = np.cos(theta2_11)*V114_1+np.sin(theta2_11)*Pz-a2
-    den = np.cos(theta2_11)*Pz - np.sin(theta2_11)*V114_1
-    theta3_11= np.arctan2(a3, d4) - np.arctan2(num, den)
-
-    num = np.cos(theta2_12)*V114_1+np.sin(theta2_12)*Pz-a2
-    den = np.cos(theta2_12)*Pz - np.sin(theta2_12)*V114_1
-    theta3_12= np.arctan2(a3, d4) - np.arctan2(num, den)
-
-    num = np.cos(theta2_21)*V114_2+np.sin(theta2_21)*Pz-a2
-    den = np.cos(theta2_21)*Pz - np.sin(theta2_21)*V114_2
-    theta3_21= np.arctan2(a3, d4) - np.arctan2(num, den)
-
-    num = np.cos(theta2_22)*V114_2+np.sin(theta2_22)*Pz-a2
-    den = np.cos(theta2_22)*Pz - np.sin(theta2_22)*V114_2
-    theta3_22= np.arctan2(a3, d4) - np.arctan2(num, den)
-
-    qSolution =      [[theta1_1, theta2_11, theta3_11]]
-    qSolution.append([theta1_1, theta2_12, theta3_12])
-    qSolution.append([theta1_2, theta2_21, theta3_21])
-    qSolution.append([theta1_2, theta2_22, theta3_22])
-
-
-
-    qSolutions = []
-    # spherical wrist inverse orientation
-    for i in range(len(qSolution)):
-        # we need to account for some random translations between the first and last 3
-        # joints (d4) and also d6,a6,alpha6 in the final frame.
-        T13_1= rob.ComputeJointHT(robotDic, [qSolution[i][0], qSolution[i][1], qSolution[i][2], 0, 0, 0])[2]
-        # print(T13_1)
-        Td4 = rob.HTtranslate([0, 0, d4])
-        # print(Td4)
-        Tt = rob.HTtranslate([a5, 0, d6]) @ rob.HTrotateX(robotDic['links'][5]['stdDH'][3])
-        # print(Tt)
-        TR = np.linalg.inv(Td4)  @  np.linalg.inv(T13_1) @ HT @ np.linalg.inv(Tt)
-
-        R = HT2rotationMatrix(TR)
-        # print(R)
-        eul= [RotationMatrix2RotZYZ(R, flip=True)]
-        eul.append(RotationMatrix2RotZYZ(R, flip=False))
-
-        if (robotDic['links'][3]['stdDH'][3]) > 0:
-            eul[0][1] = -1*eul[0][1]
-            eul[1][1] = -1*eul[1][1]
-        qSolutions += ([[qSolution[i][0], qSolution[i][1], qSolution[i][2], eul[0][0], eul[0][1], eul[0][2]],
-                       [qSolution[i][0], qSolution[i][1], qSolution[i][2], eul[1][0], eul[1][1], eul[1][2]]])
-
-    return qSolutions
-
-#**function: calculates the analytical inverse kinematics for UR type serial 6R robot manipulator without sperical wrist
-#**input:
-#  robotDic: robot dictionary
-#  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
-#**output: solutions, list of lists with posible joint angles [q1,q2,q3,q4,q5,q6] (in radiant)
-#          to achive the desired position and orientation (8 posible solutions,schoulder left/right, ellbow up/down, wrist flipped/notflipped (rotated by pi) )
-#          [left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped]
-#**notes:  Usage for different manipulators without sperical wrist posible UR3,UR5,UR10, only applicable for standard Denavit-Hartenberg parameters
-#**author: Martin Sereinig
-#**status: under development, works for most configurations, singularities not checked -> ZeroConfiguration not working
-def ComputeIKUR(robotDic, HTdes):
-    # - Inverse kinematics for a URType
-    ZERO = 10e-8
-    SolWarning = ['NoWarning']*4
-
-    # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
-    a1 = robotDic['links'][0]['stdDH'][2]
-    a2 = robotDic['links'][1]['stdDH'][2]
-    a3 = robotDic['links'][2]['stdDH'][2]
-    a4 = robotDic['links'][3]['stdDH'][2]
-    a5 = robotDic['links'][4]['stdDH'][2]
-    a6 = robotDic['links'][5]['stdDH'][2]
-
-    d1 = robotDic['links'][0]['stdDH'][1]
-    d2 = robotDic['links'][1]['stdDH'][1]
-    d3 = robotDic['links'][2]['stdDH'][1]
-    d4 = robotDic['links'][3]['stdDH'][1]
-    d5 = robotDic['links'][4]['stdDH'][1]
-    d6 = robotDic['links'][5]['stdDH'][1]
-    # The following parameters are extracted from the Homogeneous
-    # Transformation as defined in equation 1, p. 34
-    # Positon of Wrist Center
-    Px = HTdes[0][3]
-    Py = HTdes[1][3]
-    Pz = HTdes[2][3]
-
-    # Solutions= np.matrix(np.zeros((8, 6)))
-    Solutions = np.empty((8, 6))
-
-# [left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped]
-
-    # Solve for theta(1), shoulder left, shoulder right
-    HT05= HTdes@([0, 0, -d6, 1])
-
-    R= np.sqrt(HT05[0]**2+HT05[1]**2)  # xy-plane distance from the base frame to frame 5
-    # consider special case
-    if np.abs(R) < ZERO:
-        # infinite Solutions, Solution set to 0
-        # print('Infinit solutions for theta 1, set to 0')
-        SolWarning[0] = ['Infinit solutions for theta 1, set to 0']
-        Solutions[0:8, 0]= 0
-    elif np.abs(d4) > np.abs(R):
-        # print('No solution exist for theta 1')
-        SolWarning[0] = ['No solution exist for theta 1']
-        Solutions[0:8, 0]= np.nan
-
-    else:
-        if np.abs(d4/R-1) < ZERO:
-            psi2 = np.pi/2
-        elif np.abs(d4/R+1) < ZERO:
-            psi2 = -np.pi/2
-        else:
-            psi2= np.arccos(d4/(np.sqrt(HT05[0]**2+HT05[1]**2)))  # cos in paper, sin in kunzer
-
-        psi1= np.arctan2(HT05[1], HT05[0])
-        theta1_1 = np.pi/2+psi1+psi2
-        theta1_2 = np.pi/2+psi1-psi2
-        Solutions[0:4, 0]= theta1_1
-        Solutions[4:8, 0]= theta1_2
-
-
-
-    # Solve for theta(5) wrist flippt, wrist not flipped
-    Pnum1 = (Px*np.sin(theta1_1)-Py*np.cos(theta1_1)-d4)
-    Pnum2 = (Px*np.sin(theta1_2)-Py*np.cos(theta1_2)-d4)
-    if np.abs(Pnum1) <= np.abs(d6) or np.abs(Pnum2) <= np.abs(d6):
-        if np.abs((Pnum1/d6)-1) < ZERO or np.abs((Pnum2/d6)-1) < ZERO:  # Solutions near zero
-            # print(np.abs((Pnum1/d6)-1))
-            # print(np.abs((Pnum2/d6)-1))
-            Solutions[0:8, 4]= 0
-        elif np.abs((Pnum1/d6)+1) < ZERO or np.abs((Pnum2/d6)+1) < ZERO:  # Solutions near pi
-            Solutions[0:8, 4]= np.pi
-        else:
-            # with theta1_1
-            Solutions[0:2, 4]= np.arccos((Px*np.sin(theta1_1)-Py*np.cos(theta1_1)-d4)/d6)
-            Solutions[2:4, 4]= -np.arccos((Px*np.sin(theta1_1)-Py*np.cos(theta1_1)-d4)/d6)
-            # with theta1_2
-            Solutions[4:6, 4]= np.arccos((Px*np.sin(theta1_2)-Py*np.cos(theta1_2)-d4)/d6)
-            Solutions[6:8, 4]= -np.arccos((Px*np.sin(theta1_2)-Py*np.cos(theta1_2)-d4)/d6)
-    else:
-        # print('No solution for theta 5')
-        SolWarning[1] = ['No solution for theta 5']
-        Solutions[0:8, 4]= np.nan
-
-
-    # Solve for theta(6)
-    for i in range(8):
-        if np.abs(np.sin(Solutions[i, 4])) < ZERO:
-            # print('Joint axes 2,3,4,6 are aligned->too many degrees of feedom theta6=arbitrary 0')
-            SolWarning[2] = ['Joint axes 2,3,4,6 are aligned->too many degrees of feedom theta6=arbitrary 0']
-            Solutions[i, 5]= 0
-
-        else:
-            HTinv = np.linalg.inv(HTdes)
-            # with theta1_1 -> theta51_1 and theta51_2
-            for i in range(8):
-                Solutions[i, 5] = (np.arctan2((-HTinv[1][0]*np.sin(Solutions[i, 0])+HTinv[1][1]*np.cos(Solutions[i, 0]))/np.sin(Solutions[i, 4]),
-                                           (HTinv[0][0]*np.sin(Solutions[i, 0])-HTinv[0][1]*np.cos(Solutions[i, 0]))/np.sin(Solutions[i, 4]))
-                                )
-
-
-        # Solve for theta(3), elbow up and elbow down
-        for i in range(8):
-            HTJoint = rob.ComputeJointHT(robotDic, [Solutions[i, 0], 0*Solutions[i, 1], 0*Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
-            T01 = HTJoint[0]
-            T45 = rob.DH2HT([Solutions[i, 4]]+robotDic['links'][4]['stdDH'][1:4])
-            T56 = rob.DH2HT([Solutions[i, 5]]+robotDic['links'][5]['stdDH'][1:4])
-            T14 = np.linalg.inv(T01) @ HTdes @ np.linalg.inv(T45 @ T56)
-            argumentCosine= ((np.linalg.norm(T14[0:2, 3]))**2-a2**2-a3**2) / (2*(a2)*(a3))
-            print(argumentCosine)
-            if argumentCosine <= 1 and argumentCosine >= -1:
-                solTheta3= np.arccos(argumentCosine)
-
-                if i % 2 == 0:
-                    Solutions[i, 2]= solTheta3
-                else:
-                    Solutions[i, 2] = -solTheta3
-
-                # Solve for theta(2)
-                Solutions[i, 1] = np.arctan2(-T14[1][3], -T14[0][3])-np.arcsin(-(a3)*np.sin(Solutions[i, 2])/(np.linalg.norm(T14[0:2, 3])))
-                # T14[1][3] not totaly clear, schould be [2][3]
-
-
-                # Solve for theta(4)
-                for i in range(8):
-                    HTJoint = rob.ComputeJointHT(robotDic, [Solutions[i, 0], Solutions[i, 1], Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
-                    T03 = HTJoint[2]
-                    T45 = rob.DH2HT([Solutions[i, 4]]+robotDic['links'][4]['stdDH'][1:4])
-                    T56 = rob.DH2HT([Solutions[i, 5]]+robotDic['links'][5]['stdDH'][1:4])
-                    T34 = np.linalg.inv(T03) @ HTdes @ np.linalg.inv(T45 @ T56)
-                    Solutions[i, 3]= np.arctan2(T34[1][0], T34[0][0])
-            else:
-                # print('No Solutions for theta 2, theta 3 and theta 4') # solutions not existing
-                SolWarning[3] = ['No Solutions for theta 2, theta 3 and theta 4']
-                Solutions[i, 2]= np.nan
-                Solutions[i, 3]= np.nan
-                Solutions[i, 1]= np.nan
-    solutionsarray = np.array(Solutions)
-    index2delete = []
-    for i in range(len(solutionsarray)):
-        TSol = rob.ComputeJointHT(robotDic, solutionsarray[i])[5]
-        errorSolution = np.linalg.det(HTdes)-np.linalg.det(TSol)
-
-        # print(errorSolution)
-        if errorSolution > ZERO or np.isnan(errorSolution):
-            index2delete += [i]
-
-
-    # solutionsarray=np.delete(solutionsarray,index2delete,axis=0)   # to delete a row of wrong or nan solutions
-    print(['Solutions delete: ']+[str((index2delete))])
-    print(SolWarning)
-    return solutionsarray
-
-
-
-#%%++++++++++++++++++++++++
-#testing of module future
-if __name__ == '__main__':
-    
-    #imports
-    from exudyn.utilities import *
-    from exudyn.rigidBodyUtilities import *
-    from exudyn.graphicsDataUtilities import *
-    from exudyn.robotics import *   # to import  robotics core functions
-    import exudyn.robotics.models as models
-    
-    # define robot base parameter 
-    graphicsBaseList = [GraphicsDataOrthoCubePoint([0,0,-0.15], [0.4,0.4,0.1], color4grey)]
-    graphicsBaseList +=[GraphicsDataCylinder([0,0,0], [0.5,0,0], 0.0025, color4red)]
-    graphicsBaseList +=[GraphicsDataCylinder([0,0,0], [0,0.5,0], 0.0025, color4green)]
-    graphicsBaseList +=[GraphicsDataCylinder([0,0,0], [0,0,0.5], 0.0025, color4blue)]
-    toolSize= [0.0,0.0,0.0]
-    graphicsToolList = [GraphicsDataCylinder(pAxis=[0,0,0], vAxis= [0,0,0], radius=0, color=color4red)]
-    graphicsToolList+= [GraphicsDataOrthoCubePoint([0,0,0], toolSize, color4grey)]
-    graphicsToolList+= [GraphicsDataOrthoCubePoint([0,0,0], toolSize, color4grey)]
-
-    basePose2HT= HTtranslate([0,0,0]) @ HTrotateZ(0)    #robot base position and orientation  
-    toolPose2HT=HTtranslate([0,0,0]) @ HTrotateZ(0)      #robot tool position and orientation 
-
-    
-    # choose robot to test 
-    robotModel= '3R' # '3R'   'Puma560'    'UR'
-    
-    if robotModel == '3R':
-        # build robot from exudyn models
-        myRobotDic = models.Manipulator3RSimple() 
-
-    elif robotModel == 'Puma560':
-        # build robot from exudyn models
-        myRobotDic = models.ManipulatorPuma560()
-         
-    elif robotModel == 'UR':
-        # build robot from exudyn models
-        myRobotDic = models.ManipulatorUR5()
-        
-    
-    
-    jointRef = myRobotDic['referenceConfiguration']
-    myRobotModel = Robot(gravity=[0,0,-9.81],
-                  base = RobotBase(HT=basePose2HT, visualization=VRobotBase(graphicsData=graphicsBaseList)),
-                  tool = RobotTool(HT=toolPose2HT, visualization=VRobotTool(graphicsData=graphicsToolList)),
-                  referenceConfiguration = jointRef) #referenceConfiguration created with 0s automatically   
-         
-
-    
-    myRobotModel= models.LinkDict2Robot(myRobotDic, myRobotModel)
-    # build robot from corke toolbox
-    corkeRobot = MakeCorkeRobot(myRobotDic)
-    # set joint values
-    numberOfJoints= len(myRobotDic['referenceConfiguration'])
-    qZero = np.zeros(numberOfJoints)
-    qRand = (np.random.rand(numberOfJoints)*2 - np.ones(numberOfJoints) ) * np.pi
-    
-    # calculate forwarde kinematics    
-    HTZeroCorke = corkeRobot.fkine(qZero)
-    HTRandCorke = corkeRobot.fkine(qRand)
-
-    HTZeroExu = myRobotModel.LinkHT(qZero)
-    HTRandExu = myRobotModel.LinkHT(qRand)
-     
-    HTZeroError = HTZeroCorke - HTZeroExu[-1]
-    HTRandError = HTRandCorke - HTRandExu[-1]
-    
-    print('Forward kinematics check:\n zero config error = \n',HTZeroError)
-    print('Forward kinematics check:\n rand config error = \n',HTRandError)
-
-    # calculate inverse kinematics corke 
-
-    ikSolutionCorkeZero = corkeRobot.ikine_LM(HTZeroCorke,q0=qZero)
-    if ikSolutionCorkeZero.success==True:
-        print('corke solution found: \n qSolution=',ikSolutionCorkeZero.q)
-       
-    ikSolutionCorkeRand = corkeRobot.ikine_LM(HTRandCorke,q0=qRand-0.5)
-    if ikSolutionCorkeRand.success==True:
-        print('corke solution found: \n qSolution=',ikSolutionCorkeRand.q)
-    else:
-        print('corke no solution found for rand configuratio!')
-   
-
-
-    # calculate inverse kinematics exu 
-
-    if robotModel == '3R':
-        ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
-        ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
-        
-    elif robotModel == 'Puma560':
-        ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
-        ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
-        
-    # elif robotModel == 'UR':
-    #     ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
-    #     ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
-
-
-
-    #MS Todo: compare inverse kinematics solution  PUMA560 and UR
-
-    for sol in ikSolutionRandExu:
-        HTRandExuCheck = myRobotModel.LinkHT(sol)[-1]
-        HTErrorExu = HTRandExu[-1] - HTRandExuCheck
-        print('Error in position for solution q='+str(sol)+' \n Error=', HTErrorExu[0:3,3])
-        print('Error in orientation for solution q='+str(sol)+' \n Error=\n', HTErrorExu[0:3,0:3])
-
-
-
-
-
-
-
-
-
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is a submodule of the EXUDYN python robotics library
+#
+# Details:  The future module contains functionality which is currently under development
+#           and will be moved in other robotics libraries in future
+#
+# Authors:  Martin Sereinig
+# Date:     2023-03-27
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+import numpy as np
+import exudyn.robotics as rob
+from exudyn.basicUtilities import ScalarMult
+from exudyn.rigidBodyUtilities import RotationMatrix2RotZYZ, HT2rotationMatrix, HT2translation, Skew, HTtranslate
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#            Interaction with Toolbox by Peter Corke
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: makeCorkeRobot, creates robot using the peter corke toolbox using standard (stdDH) or modified (modKKDH) Denavid Hartenberg parameters
+#**input: 
+#  robotDic: robot dictionary by exudyn robotic models
+#  dhpara: stDH for standard DH parameter, modKKDH for modified DH parameter 
+#**output: serial robot object by corke
+#**author: Martin Sereinig
+#**notes: 
+#    DH Parameter Information:
+#    stdH = [theta, d, a, alpha] with Rz(theta) * Tz(d) * Tx(a) * Rx(alpha)
+#    modDH = [alpha, dx, theta, rz] with 
+#    used by Corke and Lynch: Rx(alpha) * Tx(a) * Rz(theta) * Tz(d)
+#    used by Khali:           Rx(alpha) * Tx(d) * Rz(theta) * Tz(r)
+#    Important note:  d(khali)=a(corke)  and r(khali)=d(corke)  
+def MakeCorkeRobot(robotDic):
+    
+    try:
+        import roboticstoolbox as rtb
+        from spatialmath import SE3
+        print('roboticstoolbox and spatialmath module are installed')
+
+        nLinks = len(robotDic['links'])
+        dhpara = robotDic['dhMode']
+        Links = []
+        if dhpara == 'stdDH':
+            for i in range(nLinks):
+                Links += [rtb.RevoluteDH(d = robotDic['links'][i][dhpara][1], a = robotDic['links'][i][dhpara][2], alpha = robotDic['links'][i][dhpara][3])]
+                
+        elif dhpara == 'modKKDH':
+            for i in range(nLinks):   
+                Links += [rtb.RevoluteMDH(d = robotDic['links'][i][dhpara][3], a = robotDic['links'][i][dhpara][1], alpha = robotDic['links'][i][dhpara][0])]
+        
+        robotCorke = rtb.robot.DHRobot ( Links )
+        
+    except Exception as e: 
+        
+        print('Error form exception! Check installation of roboticstoolbox from Peter Corke:',e)
+        
+
+    return robotCorke
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#            INVERSE KINEMATICS
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#**function: calculates the analytical inverse kinematics for 3R elbow type serial robot manipulator
+#**input:
+#  robotDic: robot dictionary
+#  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
+#**output: solutions, list of lists with posible joint angles [q1,q2,q3] (in radiant)
+#          to achive the desired position (4 posible solutions,schoulder left/right, ellbow up/down ) in following order: left/down, left/up, right/up, right/down
+#**author: Martin Sereinig
+#**notes:  only applicable for standard Denavit-Hartenberg parameters
+#**status: testet with various configurations and joint angels
+def ComputeIK3R(robotDic, HT):
+    ZERO = 10e-10
+    # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
+    qSolutions = np.empty((4, 3))
+
+    d1 = robotDic['links'][0]['stdDH'][1]
+    a2 = robotDic['links'][1]['stdDH'][2]
+    a3 = robotDic['links'][2]['stdDH'][2]
+
+    Px = HT[0][3]
+    Py = HT[1][3]
+    Pz = HT[2][3]
+
+    # calculations following the steps by De Luca / Standard geometric approach
+    # calculations for theta 1
+    if Px**2+Py**2 > ZERO:
+        qSolutions[0, 0] = np.arctan2(Py, Px)
+        qSolutions[1, 0] = np.arctan2(-Py, -Px)
+        qSolutions[2, 0] = np.arctan2(Py, Px)
+        qSolutions[3, 0] = np.arctan2(-Py, -Px)
+    else:
+        print('infinite solutions for th1,it is undefined but here set to 0')
+    
+    for i in range(len(qSolutions)):
+        HT01 = rob.DH2HT([qSolutions[i, 0]]+robotDic['links'][0]['stdDH'][1:4])
+        #print(HT01)
+        Dhelp = ((Px-HT01[0][3])**2+(Py-HT01[1][3])**2+(Pz-HT01[2][3])**2-a2**2-a3**2)/(2*a2*a3)
+        #print(Dhelp)
+        if np.abs(Dhelp)<=1:
+           if i <= 1:
+                qSolutions[i,2] = np.arctan2(np.sqrt((1-Dhelp**2)), Dhelp)
+                qSolutions[i,1] = np.arctan2(Pz-HT01[2][3], np.sqrt((Px)**2+(Py)**2))-np.arctan2(a3*np.sin(qSolutions[i,2]), a2+a3*np.cos(qSolutions[i,2]))
+           else:
+                qSolutions[i, 2] = np.arctan2(-np.sqrt((1-Dhelp**2)), Dhelp)
+                qSolutions[i,1] = np.arctan2(Pz-HT01[2][3], np.sqrt((Px)**2+(Py)**2))-np.arctan2(a3*np.sin(qSolutions[i,2]), a2+a3*np.cos(qSolutions[i,2]))
+           if i==1 or i==3:
+                qSolutions[i,1]=np.pi-qSolutions[i,1]
+                qSolutions[i,2]=-qSolutions[i,2]
+        else:
+            #print('no solution found for this point')
+            qSolutions[i,2]=np.nan
+            qSolutions[i,1]=np.nan
+        
+
+    solutionsarray = np.array(qSolutions)
+    index2delete = []
+    for i in range(len(solutionsarray)):
+        TSol = rob.ComputeJointHT(robotDic, solutionsarray[i])[2]
+        errorSolution = np.linalg.det(HT)-np.linalg.det(TSol)
+
+        # print(errorSolution)
+        if errorSolution > ZERO or np.isnan(errorSolution):
+            index2delete += [i]
+
+
+    #solutionsarray=np.delete(solutionsarray,index2delete,axis=0)   # to delete a row of wrong or nan solutions
+    #print(['Solutions to delete: ']+[str((index2delete))])
+
+    return solutionsarray
+
+
+
+#**function: calculates the analytical inverse kinematics for Puma560 serial 6R robotDic manipulator
+#**input:
+#  robotDic: robotDictionary
+#  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
+#**output: qSolutions, list of lists with posible joint angles [q1,q2,q3,q4,q5,q6] (in radiant)
+#          to achive the desired position and orientation (8 posible solutions,schoulder left/right, ellbow up/down, wrist flipped/notflipped (rotated by pi) )
+#          left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped
+#**author: Martin Sereinig
+#**notes:  Usage for different manipulators with sperical wrist posible, only applicable for standard Denavit-Hartenberg parameters
+#**status: tested (compared with robotDiccs, Vision and Control book of P. Corke
+def ComputeIKPuma560(robotDic, HT):
+    # - Inverse kinematics for a PUMA 560,
+    #   Paul and Zhang,
+    #   The International Journal of Robotics Research,
+    #   Vol. 5, No. 2, Summer 1986, p. 32-44
+    # Solve for theta(1)
+    # r is defined in equation 38, p. 39.
+    # theta(1) uses equations 40 and 41, p.39,
+
+
+    # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
+
+    a2 = robotDic['links'][1]['stdDH'][2]
+    a3 = robotDic['links'][2]['stdDH'][2]
+    d3 = robotDic['links'][2]['stdDH'][1]
+    d4 = robotDic['links'][3]['stdDH'][1]
+
+    a5= robotDic['links'][4]['stdDH'][2]
+    d6= robotDic['links'][5]['stdDH'][1]
+
+
+    # The following parameters are extracted from the homogeneous
+    # transformation as defined in equation 1, p. 34
+    # Positon of Wrist Center
+    Px = HT[0][3]
+    Py = HT[1][3]
+    Pz= HT[2][3] - robotDic['links'][0]['stdDH'][1]
+
+    # Solve for theta(1)
+    r = np.sqrt(Px**2 + Py**2)
+
+
+    theta1_1 = np.arctan2(Py, Px) + np.pi - np.arcsin(d3/r) # base left
+    theta1_2 = np.arctan2(Py, Px) + np.arcsin(d3/r)         # base right
+
+    #
+    # Solve for theta(2)
+    #
+    # V114 is defined in equation 43, p.39.
+    # r is defined in equation 47, p.39.
+    # Psi is defined in equation 49, p.40.
+    # theta(2) uses equations 50 and 51, p.40, based on the configuration
+    # parameter n2
+
+    V114_1 = Px*np.cos(theta1_1) + Py*np.sin(theta1_1)
+    r_1 = np.sqrt(V114_1**2 + Pz**2)
+    Psi_1 = np.arccos((a2**2-d4**2-a3**2+V114_1**2+Pz**2)/(2.0*a2*r_1))
+    theta2_11 = np.arctan2(Pz, V114_1) + Psi_1
+
+    V114_1 = Px*np.cos(theta1_1) + Py*np.sin(theta1_1)
+    r_1 = np.sqrt(V114_1**2 + Pz**2)
+    Psi_1 = np.arccos((a2**2-d4**2-a3**2+V114_1**2+Pz**2)/(2.0*a2*r_1))
+    theta2_12 = np.arctan2(Pz, V114_1) - Psi_1
+
+    V114_2 = Px*np.cos(theta1_2) + Py*np.sin(theta1_2)
+    r_2 = np.sqrt(V114_2**2 + Pz**2)
+    Psi_2 = np.arccos((a2**2-d4**2-a3**2+V114_2**2+Pz**2)/(2.0*a2*r_2))
+    theta2_21 = np.arctan2(Pz, V114_2) + Psi_2
+
+    V114_2 = Px*np.cos(theta1_2) + Py*np.sin(theta1_2)
+    r_2 = np.sqrt(V114_2**2 + Pz**2)
+    Psi_2 = np.arccos((a2**2-d4**2-a3**2+V114_2**2+Pz**2)/(2.0*a2*r_2))
+    theta2_22 = np.arctan2(Pz, V114_2) - Psi_2
+
+    # Solve for theta(3)
+    # theta(3) uses equation 57, p. 40.
+    num = np.cos(theta2_11)*V114_1+np.sin(theta2_11)*Pz-a2
+    den = np.cos(theta2_11)*Pz - np.sin(theta2_11)*V114_1
+    theta3_11= np.arctan2(a3, d4) - np.arctan2(num, den)
+
+    num = np.cos(theta2_12)*V114_1+np.sin(theta2_12)*Pz-a2
+    den = np.cos(theta2_12)*Pz - np.sin(theta2_12)*V114_1
+    theta3_12= np.arctan2(a3, d4) - np.arctan2(num, den)
+
+    num = np.cos(theta2_21)*V114_2+np.sin(theta2_21)*Pz-a2
+    den = np.cos(theta2_21)*Pz - np.sin(theta2_21)*V114_2
+    theta3_21= np.arctan2(a3, d4) - np.arctan2(num, den)
+
+    num = np.cos(theta2_22)*V114_2+np.sin(theta2_22)*Pz-a2
+    den = np.cos(theta2_22)*Pz - np.sin(theta2_22)*V114_2
+    theta3_22= np.arctan2(a3, d4) - np.arctan2(num, den)
+
+    qSolution =      [[theta1_1, theta2_11, theta3_11]]
+    qSolution.append([theta1_1, theta2_12, theta3_12])
+    qSolution.append([theta1_2, theta2_21, theta3_21])
+    qSolution.append([theta1_2, theta2_22, theta3_22])
+
+
+
+    qSolutions = []
+    # spherical wrist inverse orientation
+    for i in range(len(qSolution)):
+        # we need to account for some random translations between the first and last 3
+        # joints (d4) and also d6,a6,alpha6 in the final frame.
+        T13_1= rob.ComputeJointHT(robotDic, [qSolution[i][0], qSolution[i][1], qSolution[i][2], 0, 0, 0])[2]
+        # print(T13_1)
+        Td4 = rob.HTtranslate([0, 0, d4])
+        # print(Td4)
+        Tt = rob.HTtranslate([a5, 0, d6]) @ rob.HTrotateX(robotDic['links'][5]['stdDH'][3])
+        # print(Tt)
+        TR = np.linalg.inv(Td4)  @  np.linalg.inv(T13_1) @ HT @ np.linalg.inv(Tt)
+
+        R = HT2rotationMatrix(TR)
+        # print(R)
+        eul= [RotationMatrix2RotZYZ(R, flip=True)]
+        eul.append(RotationMatrix2RotZYZ(R, flip=False))
+
+        if (robotDic['links'][3]['stdDH'][3]) > 0:
+            eul[0][1] = -1*eul[0][1]
+            eul[1][1] = -1*eul[1][1]
+        qSolutions += ([[qSolution[i][0], qSolution[i][1], qSolution[i][2], eul[0][0], eul[0][1], eul[0][2]],
+                       [qSolution[i][0], qSolution[i][1], qSolution[i][2], eul[1][0], eul[1][1], eul[1][2]]])
+
+    return qSolutions
+
+#**function: calculates the analytical inverse kinematics for UR type serial 6R robot manipulator without sperical wrist
+#**input:
+#  robotDic: robot dictionary
+#  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
+#**output: solutions, list of lists with posible joint angles [q1,q2,q3,q4,q5,q6] (in radiant)
+#          to achive the desired position and orientation (8 posible solutions,schoulder left/right, ellbow up/down, wrist flipped/notflipped (rotated by pi) )
+#          [left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped]
+#**notes:  Usage for different manipulators without sperical wrist posible UR3,UR5,UR10, only applicable for standard Denavit-Hartenberg parameters
+#**author: Martin Sereinig
+#**status: under development, works for most configurations, singularities not checked -> ZeroConfiguration not working
+def ComputeIKUR(robotDic, HTdes):
+    # - Inverse kinematics for a URType
+    ZERO = 10e-8
+    SolWarning = ['NoWarning']*4
+
+    # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
+    a1 = robotDic['links'][0]['stdDH'][2]
+    a2 = robotDic['links'][1]['stdDH'][2]
+    a3 = robotDic['links'][2]['stdDH'][2]
+    a4 = robotDic['links'][3]['stdDH'][2]
+    a5 = robotDic['links'][4]['stdDH'][2]
+    a6 = robotDic['links'][5]['stdDH'][2]
+
+    d1 = robotDic['links'][0]['stdDH'][1]
+    d2 = robotDic['links'][1]['stdDH'][1]
+    d3 = robotDic['links'][2]['stdDH'][1]
+    d4 = robotDic['links'][3]['stdDH'][1]
+    d5 = robotDic['links'][4]['stdDH'][1]
+    d6 = robotDic['links'][5]['stdDH'][1]
+    # The following parameters are extracted from the Homogeneous
+    # Transformation as defined in equation 1, p. 34
+    # Positon of Wrist Center
+    Px = HTdes[0][3]
+    Py = HTdes[1][3]
+    Pz = HTdes[2][3]
+
+    # Solutions= np.matrix(np.zeros((8, 6)))
+    Solutions = np.empty((8, 6))
+
+# [left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped]
+
+    # Solve for theta(1), shoulder left, shoulder right
+    HT05= HTdes@([0, 0, -d6, 1])
+
+    R= np.sqrt(HT05[0]**2+HT05[1]**2)  # xy-plane distance from the base frame to frame 5
+    # consider special case
+    if np.abs(R) < ZERO:
+        # infinite Solutions, Solution set to 0
+        # print('Infinit solutions for theta 1, set to 0')
+        SolWarning[0] = ['Infinit solutions for theta 1, set to 0']
+        Solutions[0:8, 0]= 0
+    elif np.abs(d4) > np.abs(R):
+        # print('No solution exist for theta 1')
+        SolWarning[0] = ['No solution exist for theta 1']
+        Solutions[0:8, 0]= np.nan
+
+    else:
+        if np.abs(d4/R-1) < ZERO:
+            psi2 = np.pi/2
+        elif np.abs(d4/R+1) < ZERO:
+            psi2 = -np.pi/2
+        else:
+            psi2= np.arccos(d4/(np.sqrt(HT05[0]**2+HT05[1]**2)))  # cos in paper, sin in kunzer
+
+        psi1= np.arctan2(HT05[1], HT05[0])
+        theta1_1 = np.pi/2+psi1+psi2
+        theta1_2 = np.pi/2+psi1-psi2
+        Solutions[0:4, 0]= theta1_1
+        Solutions[4:8, 0]= theta1_2
+
+
+
+    # Solve for theta(5) wrist flippt, wrist not flipped
+    Pnum1 = (Px*np.sin(theta1_1)-Py*np.cos(theta1_1)-d4)
+    Pnum2 = (Px*np.sin(theta1_2)-Py*np.cos(theta1_2)-d4)
+    if np.abs(Pnum1) <= np.abs(d6) or np.abs(Pnum2) <= np.abs(d6):
+        if np.abs((Pnum1/d6)-1) < ZERO or np.abs((Pnum2/d6)-1) < ZERO:  # Solutions near zero
+            # print(np.abs((Pnum1/d6)-1))
+            # print(np.abs((Pnum2/d6)-1))
+            Solutions[0:8, 4]= 0
+        elif np.abs((Pnum1/d6)+1) < ZERO or np.abs((Pnum2/d6)+1) < ZERO:  # Solutions near pi
+            Solutions[0:8, 4]= np.pi
+        else:
+            # with theta1_1
+            Solutions[0:2, 4]= np.arccos((Px*np.sin(theta1_1)-Py*np.cos(theta1_1)-d4)/d6)
+            Solutions[2:4, 4]= -np.arccos((Px*np.sin(theta1_1)-Py*np.cos(theta1_1)-d4)/d6)
+            # with theta1_2
+            Solutions[4:6, 4]= np.arccos((Px*np.sin(theta1_2)-Py*np.cos(theta1_2)-d4)/d6)
+            Solutions[6:8, 4]= -np.arccos((Px*np.sin(theta1_2)-Py*np.cos(theta1_2)-d4)/d6)
+    else:
+        # print('No solution for theta 5')
+        SolWarning[1] = ['No solution for theta 5']
+        Solutions[0:8, 4]= np.nan
+
+
+    # Solve for theta(6)
+    for i in range(8):
+        if np.abs(np.sin(Solutions[i, 4])) < ZERO:
+            # print('Joint axes 2,3,4,6 are aligned->too many degrees of feedom theta6=arbitrary 0')
+            SolWarning[2] = ['Joint axes 2,3,4,6 are aligned->too many degrees of feedom theta6=arbitrary 0']
+            Solutions[i, 5]= 0
+
+        else:
+            HTinv = np.linalg.inv(HTdes)
+            # with theta1_1 -> theta51_1 and theta51_2
+            for i in range(8):
+                Solutions[i, 5] = (np.arctan2((-HTinv[1][0]*np.sin(Solutions[i, 0])+HTinv[1][1]*np.cos(Solutions[i, 0]))/np.sin(Solutions[i, 4]),
+                                           (HTinv[0][0]*np.sin(Solutions[i, 0])-HTinv[0][1]*np.cos(Solutions[i, 0]))/np.sin(Solutions[i, 4]))
+                                )
+
+
+        # Solve for theta(3), elbow up and elbow down
+        for i in range(8):
+            HTJoint = rob.ComputeJointHT(robotDic, [Solutions[i, 0], 0*Solutions[i, 1], 0*Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
+            T01 = HTJoint[0]
+            T45 = rob.DH2HT([Solutions[i, 4]]+robotDic['links'][4]['stdDH'][1:4])
+            T56 = rob.DH2HT([Solutions[i, 5]]+robotDic['links'][5]['stdDH'][1:4])
+            T14 = np.linalg.inv(T01) @ HTdes @ np.linalg.inv(T45 @ T56)
+            argumentCosine= ((np.linalg.norm(T14[0:2, 3]))**2-a2**2-a3**2) / (2*(a2)*(a3))
+            print(argumentCosine)
+            if argumentCosine <= 1 and argumentCosine >= -1:
+                solTheta3= np.arccos(argumentCosine)
+
+                if i % 2 == 0:
+                    Solutions[i, 2]= solTheta3
+                else:
+                    Solutions[i, 2] = -solTheta3
+
+                # Solve for theta(2)
+                Solutions[i, 1] = np.arctan2(-T14[1][3], -T14[0][3])-np.arcsin(-(a3)*np.sin(Solutions[i, 2])/(np.linalg.norm(T14[0:2, 3])))
+                # T14[1][3] not totaly clear, schould be [2][3]
+
+
+                # Solve for theta(4)
+                for i in range(8):
+                    HTJoint = rob.ComputeJointHT(robotDic, [Solutions[i, 0], Solutions[i, 1], Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
+                    T03 = HTJoint[2]
+                    T45 = rob.DH2HT([Solutions[i, 4]]+robotDic['links'][4]['stdDH'][1:4])
+                    T56 = rob.DH2HT([Solutions[i, 5]]+robotDic['links'][5]['stdDH'][1:4])
+                    T34 = np.linalg.inv(T03) @ HTdes @ np.linalg.inv(T45 @ T56)
+                    Solutions[i, 3]= np.arctan2(T34[1][0], T34[0][0])
+            else:
+                # print('No Solutions for theta 2, theta 3 and theta 4') # solutions not existing
+                SolWarning[3] = ['No Solutions for theta 2, theta 3 and theta 4']
+                Solutions[i, 2]= np.nan
+                Solutions[i, 3]= np.nan
+                Solutions[i, 1]= np.nan
+    solutionsarray = np.array(Solutions)
+    index2delete = []
+    for i in range(len(solutionsarray)):
+        TSol = rob.ComputeJointHT(robotDic, solutionsarray[i])[5]
+        errorSolution = np.linalg.det(HTdes)-np.linalg.det(TSol)
+
+        # print(errorSolution)
+        if errorSolution > ZERO or np.isnan(errorSolution):
+            index2delete += [i]
+
+
+    # solutionsarray=np.delete(solutionsarray,index2delete,axis=0)   # to delete a row of wrong or nan solutions
+    print(['Solutions delete: ']+[str((index2delete))])
+    print(SolWarning)
+    return solutionsarray
+
+
+
+#%%++++++++++++++++++++++++
+#testing of module future
+if __name__ == '__main__':
+    
+    #imports
+    from exudyn.utilities import *
+    from exudyn.rigidBodyUtilities import *
+    from exudyn.graphicsDataUtilities import *
+    from exudyn.robotics import *   # to import  robotics core functions
+    import exudyn.robotics.models as models
+    
+    # define robot base parameter 
+    graphicsBaseList = [GraphicsDataOrthoCubePoint([0,0,-0.15], [0.4,0.4,0.1], color4grey)]
+    graphicsBaseList +=[GraphicsDataCylinder([0,0,0], [0.5,0,0], 0.0025, color4red)]
+    graphicsBaseList +=[GraphicsDataCylinder([0,0,0], [0,0.5,0], 0.0025, color4green)]
+    graphicsBaseList +=[GraphicsDataCylinder([0,0,0], [0,0,0.5], 0.0025, color4blue)]
+    toolSize= [0.0,0.0,0.0]
+    graphicsToolList = [GraphicsDataCylinder(pAxis=[0,0,0], vAxis= [0,0,0], radius=0, color=color4red)]
+    graphicsToolList+= [GraphicsDataOrthoCubePoint([0,0,0], toolSize, color4grey)]
+    graphicsToolList+= [GraphicsDataOrthoCubePoint([0,0,0], toolSize, color4grey)]
+
+    basePose2HT= HTtranslate([0,0,0]) @ HTrotateZ(0)    #robot base position and orientation  
+    toolPose2HT=HTtranslate([0,0,0]) @ HTrotateZ(0)      #robot tool position and orientation 
+
+    
+    # choose robot to test 
+    robotModel= '3R' # '3R'   'Puma560'    'UR'
+    
+    if robotModel == '3R':
+        # build robot from exudyn models
+        myRobotDic = models.Manipulator3RSimple() 
+
+    elif robotModel == 'Puma560':
+        # build robot from exudyn models
+        myRobotDic = models.ManipulatorPuma560()
+         
+    elif robotModel == 'UR':
+        # build robot from exudyn models
+        myRobotDic = models.ManipulatorUR5()
+        
+    
+    
+    jointRef = myRobotDic['referenceConfiguration']
+    myRobotModel = Robot(gravity=[0,0,-9.81],
+                  base = RobotBase(HT=basePose2HT, visualization=VRobotBase(graphicsData=graphicsBaseList)),
+                  tool = RobotTool(HT=toolPose2HT, visualization=VRobotTool(graphicsData=graphicsToolList)),
+                  referenceConfiguration = jointRef) #referenceConfiguration created with 0s automatically   
+         
+
+    
+    myRobotModel= models.LinkDict2Robot(myRobotDic, myRobotModel)
+    # build robot from corke toolbox
+    corkeRobot = MakeCorkeRobot(myRobotDic)
+    # set joint values
+    numberOfJoints= len(myRobotDic['referenceConfiguration'])
+    qZero = np.zeros(numberOfJoints)
+    qRand = (np.random.rand(numberOfJoints)*2 - np.ones(numberOfJoints) ) * np.pi
+    
+    # calculate forwarde kinematics    
+    HTZeroCorke = corkeRobot.fkine(qZero)
+    HTRandCorke = corkeRobot.fkine(qRand)
+
+    HTZeroExu = myRobotModel.LinkHT(qZero)
+    HTRandExu = myRobotModel.LinkHT(qRand)
+     
+    HTZeroError = HTZeroCorke - HTZeroExu[-1]
+    HTRandError = HTRandCorke - HTRandExu[-1]
+    
+    print('Forward kinematics check:\n zero config error = \n',HTZeroError)
+    print('Forward kinematics check:\n rand config error = \n',HTRandError)
+
+    # calculate inverse kinematics corke 
+
+    ikSolutionCorkeZero = corkeRobot.ikine_LM(HTZeroCorke,q0=qZero)
+    if ikSolutionCorkeZero.success==True:
+        print('corke solution found: \n qSolution=',ikSolutionCorkeZero.q)
+       
+    ikSolutionCorkeRand = corkeRobot.ikine_LM(HTRandCorke,q0=qRand-0.5)
+    if ikSolutionCorkeRand.success==True:
+        print('corke solution found: \n qSolution=',ikSolutionCorkeRand.q)
+    else:
+        print('corke no solution found for rand configuratio!')
+   
+
+
+    # calculate inverse kinematics exu 
+
+    if robotModel == '3R':
+        ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
+        ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
+        
+    elif robotModel == 'Puma560':
+        ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
+        ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
+        
+    # elif robotModel == 'UR':
+    #     ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
+    #     ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
+
+
+
+    #MS Todo: compare inverse kinematics solution  PUMA560 and UR
+
+    for sol in ikSolutionRandExu:
+        HTRandExuCheck = myRobotModel.LinkHT(sol)[-1]
+        HTErrorExu = HTRandExu[-1] - HTRandExuCheck
+        print('Error in position for solution q='+str(sol)+' \n Error=', HTErrorExu[0:3,3])
+        print('Error in orientation for solution q='+str(sol)+' \n Error=\n', HTErrorExu[0:3,0:3])
+
+
+
+
+
+
+
+
+
+
+
+
+
```

## exudyn/robotics/mobile.py

 * *Ordering differences only*

```diff
@@ -1,552 +1,552 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is a submodule of the EXUDYN python robotics library
-#
-# Details:  The utilities contains functionality for mobile robots 
-#           based on the EXUDYN example MecanumWheel RollingDiscPenality
-#           specific friction angle of rolling disc is used to model rolls of mecanum wheels
-#           
-#
-# Author:   Martin Sereinig, Peter Manzl and Johannes Gerstmayr
-# Date:     2021-10-01
-# Updated:  2023-09-15
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute 
-# it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-# Notes: formulation is still under development
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-# exudyn imports
-import exudyn as exu
-from exudyn.itemInterface import *
-from exudyn.utilities import *
-from exudyn.graphicsDataUtilities import *
-from exudyn.robotics import *
-
-import numpy as np
-
-#**function:    add items to existing mbs to build up a mobile robot platform, 
-#               there are options that can be passed as args / kwargs, which can contains options as described below. 
-#               The robot platform is built out of rigid bodies where the wheels can be modeled as rolling discs 
-#               (mecanum wheel x/o configuration) or with a detailed mecanum wheel simulation approach 
-#**input: 
-#   mbs: the multibody system which will be extended
-#   markerGround: a rigid body marker, at which the robot will be placed (usually ground)
-#   mobileRobot: a dictionary including all information about the mobile robot platform 
-#**output: the function returns a dictionary containing nodes, body, object and marker numbers of individual mobile robot parts 
-#           nPlatformList, bPlatformList, oPlatformList, mPlatformList; nodes, bodies, objects and marker of the platform [nPlattform] [bPlattform] [oPlattform]  []  
-#           oAxisList, mAxlesList; objects and marker of the axles  [a1, a2, a3, a4]
-#           nWheelsList, bWheelsList, oRollingDiscsList, mWheelsList; nodes, bodys, objects and markers of the four wheels [w1, w2, w3, w4]
-#**notes: for coordinate system, see Python function definition
-def mobileRobot2MBS(mbs, mobileRobot, markerGround, flagGraphicsRollers=True, *args, **kwargs):
-    # platform setup:
-    # ^Y
-    # |    W3 +---------+ W1
-    # |       |         |
-    # |       |    +    | car center point
-    # |       |         |
-    # |    W4 +---------+ W2 
-    # |
-    # |
-    # +-------->X
-    # define mobile robot platform, example values taken from the mobile robot Leobot, build from the university of Innsbruck 2019-2021 
-    # mobileRobot = { 'gravity':                    [0,0,-9.81],             # gravity in m/s^2
-    #                 'platformDimensions':        [0.5, 0.7 , 0.2612-0.0452],       # [width, length, hight]
-    #                 'platformMass':               58.6-16.06,                    # platform mass- manipulator mass 
-    #                 'platformInitialPose':        HTrotateZ(0)@HTtranslate([0.0,0,(0.0452+(0.2612-0.0452)/2.0)]),  # platform initial pose as HT middle of platform (box representation) 
-    #                 'platformInitialOmega':       [0,0,0],  # platform initial rotational velocity around x,y,z axis
-    #                 'platformInitialVelocity':    [0,0,0],  # platform initial translational velocity in x,y,z direction
-    #                 'platformCOM':                [0.0, 0.0, 0.0],       # center of mass shift to base coordinate system
-    #                 'platformBaseCoordinate':     [0.0 ,0.0 ,0.0], # geometric center  in middle of platform                   
-    #                 'platformInertia':            InertiaCuboid,     # platform inertia w.r.t. COM!                    
-    #                 'platformRepresentation':     'stl',          # 'box' or 'stl' graphical representation of the mobile platform 
-    #                 'platformStlFile':            'stl/huellgeometrie.STL',  # path to the used stl file 
-    #                 'wheelType':                  0,                      # 0=wheeltype wheel o-config, 1=mecanum wheel x-config, 2=standard wheel  (always in bottom view)
-    #                 'friction':                   [0.4, 0.0075, 0.05],    # [dryFriction1, dryFriction2,rollFriction]= [0.4,0.0075,0.05] for LeoBot (Master Thesis Manzl)
-    #                 'frictionAngel':              pi/4,                   # friction angle theta=pi/4 for mecanum wheel, theta=0 for standard wheel  
-    #                 'wheelBase':                  0.400,                    # distance between center of wheels (wheel axes) between front and back  
-    #                 'wheelTrack':                 0.390,                    # distance between center of wheels between left and right 
-    #                 'wheelRoh':                   1800,                    # density of wheel in kg/m^3
-    #                 'wheelRadius':                0.0762,                   # radius of wheel in m 
-    #                 'wheelWidth':                 0.076,                  # width of wheel in m, just for graphics     
-    #                 'wheelMass':                  2.406,                    # Mass of one mecanum wheel, leobot measured
-    #                 'wheelInertia':               InertiaCylinder,   # inertia for infinitely small ring:
-    #                 'wheelNumbers':               4,                       # number of wheels on platform
-    #                 'serialRobotMountpoint':      HTtranslate([0.211,0,-0.105]),  # serial robot mount point as HT from platform center coordinate system in middle of platform center
-    #                 'debugOffset':                debugOffsetNumber       # number to set the initial position in z, to a new value avoid oscillations
-    #                 'flagFlexible':                False                   # if True change RigidBody plate to flexible plate
-    #                 }  
-
-    # node, body,marker and object number for platform 
-    nPlatformList = []           
-    bPlatformList = []           
-    mPlatformList = []    
-    oPlatformList =[]   
-
-    # node, body, marker number for wheels
-    nWheelsList = [] 
-    bWheelsList = []
-    mWheelsList = []
-    oRollingDiscsList = []   
-    mAxlesList = []
-    oAxlesList =  []
-    if not('linearRegularization' in mobileRobot): 
-        mobileRobot['linearRegularization'] = True
-
-    # wheel parameter
-    rWheel = mobileRobot['wheelRadius']        
-    wWheel = mobileRobot['wheelWidth']        
-    p0Wheel = [0,0,rWheel+mobileRobot['debugOffset']    ]      # origin of disc center point at reference, such that initial contact point is at [0,0,0]
-    omega0Wheel = [0,0,0]       # initial angular velocity around z-axis
-    inertiaWheel = mobileRobot['wheelInertia']
-    mobileRobot['wheelRoh'] = mobileRobot['wheelMass'] /  (wWheel*rWheel**2*np.pi) # mass / Volume
-    inertiaWheel = InertiaCylinder(density=mobileRobot['wheelRoh']  , length=wWheel, outerRadius=rWheel, axis=0)
-
-    #platform parameters:
-    p0Car = HT2translation(mobileRobot['platformInitialPose']) 
-    p0Car[2] += mobileRobot['debugOffset'] 
-    wCar = mobileRobot['platformDimensions'][0]
-    lCar = mobileRobot['platformDimensions'][1]
-    hCar = mobileRobot['platformDimensions'][2] 
-    mCar = mobileRobot['platformMass']-4*inertiaWheel.mass #
-    inertiaPlatform = mobileRobot['platformInertia']
-    inertiaPlatform = InertiaCuboid(density=mCar/(lCar*wCar*hCar), sideLengths=[wCar, lCar, hCar])
-    inertiaPlatform = inertiaPlatform.Translated(mobileRobot['comShiftPlatform'])
-    inertiaPlatform.com  = mobileRobot['platformCOM'] #translate COM
-
-    # to make mobileRobot dictionary global 
-    mbs.variables['mobileRobot'] = mobileRobot
-    ################
-    graphicsPlatformList=[]
-    # drawing platform coordinate system 
-    graphicsPlatformList += [GraphicsDataCylinder([0,0,0], [0.5,0,0], 0.001, color4red)]
-    graphicsPlatformList += [GraphicsDataCylinder([0,0,0], [0,0.5,0], 0.001, color4green)]
-    graphicsPlatformList += [GraphicsDataCylinder([0,0,0], [0,0,0.2], 0.001, color4blue)]
-
-    if mobileRobot['platformRepresentation']=='box':
-        graphicsPlatformList += [GraphicsDataOrthoCubePoint(centerPoint=[0.0,0.0,0.0],size=[lCar, wCar-1.1*wWheel, hCar], color=color4steelblue[0:3]+[0.2])]
-    if mobileRobot['platformRepresentation'] == 'stl':
-        try:
-            stlGrafics = GraphicsDataFromSTLfileTxt(mobileRobot['platformStlFile'],color=[1,1,1,1])
-            graphicsPlatformList += [stlGrafics]
-        except:
-            print('stl not found, maybe wrong directory, use box instead')
-            graphicsPlatformList += [GraphicsDataOrthoCubePoint(centerPoint=[0,0,2.0],size=[lCar, wCar-1.1*wWheel, hCar], color=color4steelblue[0:3]+[0.2])]
-
-    [nPlatform,bPlatform] = AddRigidBody(mainSys = mbs, 
-                            inertia = inertiaPlatform, 
-                            nodeType = str(exu.NodeType.RotationEulerParameters), 
-                            position = p0Car, 
-                            rotationMatrix = HT2rotationMatrix(mobileRobot['platformInitialPose'])  ,
-                            angularVelocity =  mobileRobot['platformInitialOmega'],
-                            velocity=mobileRobot['platformInitialVelocity'],
-                            gravity = mobileRobot['gravity'], 
-                            graphicsDataList = graphicsPlatformList)
-    mbs.SetObjectParameter(bPlatform, 'name', 'Base')
-    mbs.SetNodeParameter(nPlatform, 'name', 'BaseCenter')
-    nPlatformList += [nPlatform]
-    bPlatformList += [bPlatform]
-    # marker in center of platform
-    mCenterPlatform = mbs.AddMarker(MarkerBodyRigid(name='mCenterPlatform',bodyNumber=bPlatform, localPosition=[0,0,0]))   #p0Car     
-    mPlatformList += [mCenterPlatform]
-    # marker in center of baseplate
-    mCenterBase = mbs.AddMarker(MarkerBodyRigid(name='mCenterBase',bodyNumber=bPlatform, localPosition=[0,0,-mobileRobot['platformDimensions'][2]/2]))     #VAdd (p0Car)
-    mPlatformList += [mCenterBase]
-    # generic joint in center of base plate            
-    oBasePlateJoint = mbs.AddObject(GenericJoint(markerNumbers=[markerGround, mCenterBase], activeConnector = True, 
-                            constrainedAxes=[0,0,0,0,0,0],
-                            visualization=VObjectJointGeneric(axesRadius=0.05, axesLength=2.4,color = [0.5,1.,0,0.1])))  
-    oPlatformList += [oBasePlateJoint]
-    
-    # marker on platform for serial robot placement
-    # note that the local coordinate system of the base must be in accordance with the DH-parameters, i.e., the z-axis must be the first rotation axis. For correction of the base coordinate system, use rotationMarkerBase
-    mRobotArmMounting = mbs.AddMarker(MarkerBodyRigid(name='mRobotArmMounting',bodyNumber=bPlatform, localPosition= HT2translation(mobileRobot['serialRobotMountpoint'])))
-    mPlatformList += [mRobotArmMounting]
-    mRevoluteBody0 = []
-    mRevoluteBody1 = []
-    # wheel parameter
-    param = {'r':  mobileRobot['wheelRadius'], 
-            'lRoll': wWheel, 
-            'nRolls': 8, 
-            'delta': np.pi/4,
-            'rRoll': mobileRobot['wheelRadius']*0.25}
-    param['dRoll'] = param['r'] - param['rRoll']
-    
-    if flagGraphicsRollers: 
-        Generatrix2Polynomial(param, GeneratrixRoll, tol=1e-8, nTest = 1001)
-    rCyl = param['rRoll']
-    nCyl = param['nRolls']
-    
-    ################## build all 4 wheels and add them to main platform body 
-    for iWheel in range( mobileRobot['wheelNumbers'] ):
-        strWheelNum = str(iWheel)
-
-        # setup friction angle regarding wheelType 0->0configuration, 1->Xconfiguration, 2->standard wheel
-        frictionAngle = -mobileRobot['frictionAngle']*pow(-1,(1-mobileRobot['wheelType'])) #45°
-        if iWheel == 1 or iWheel == 2: #difference in diagonal
-            frictionAngle *= -1
-        if mobileRobot['wheelType']==2:
-            frictionAngle = 0
-        # additional graphics for visualization of rollers on the wheel (JUST FOR DRAWING!):
-        # graphicsWheel = [GraphicsDataOrthoCubePoint(centerPoint=[0,0,0],size=[1.1*wWheel,0.7*rWheel,0.7*rWheel], color=color4lightred)]
-        graphicsWheel = [GraphicsDataCylinder(pAxis=[-0.55*wWheel,0,0], vAxis=[1.1*wWheel,0,0], radius=0.34*rWheel, color=color4lightred)]
-        if 0: # debugging roller orientations
-            graphicsWheel += [GraphicsDataCylinder([-0.1,0,0], [0.001, 0, 0], radius = param['r'], nTiles = 64, color=color4lawngreen)]
-        
-        if flagGraphicsRollers: 
-            contour =  [[-param['lRoll']/2, 0]]  
-            x = np.linspace(start = - param['lRoll']/2, stop = param['lRoll']/2, num=21) 
-            for i in range(np.size(x)):
-                contour+= [[x[i], np.polyval(param['aPoly'], x[i])]]
-            contour += [[param['lRoll']/2, 0]] # for a closed contour
-            graphRoll = []
-                
-        # draw cylinders on each wheel
-        for i in range(nCyl): 
-            iPhi = i/nCyl*2*np.pi
-            # drawing as cylinders
-            if flagGraphicsRollers: # draw as cylinders
-                pAxle = np.array([0,-(param['r']-param['rRoll'])*np.sin(iPhi), - (param['r']-param['rRoll'])*np.cos(iPhi)])    
-                vAxle = RotationMatrixX(-iPhi ) @  RotationMatrixZ(frictionAngle) @ [0.5*param['lRoll'],0,0]
-                graphicsWheel += [GraphicsDataSolidOfRevolution(pAxis=pAxle, vAxis=vAxle, contour=contour, color=color4blue[0:3]+[1],# color=color4blue[0:3] +[alpha], 
-                                                nTiles = 16)]        
-            else:
-                pAxle = np.array([0,rWheel*np.sin(iPhi),-rWheel*np.cos(iPhi)])
-                vAxle = [0.5*wWheel*np.cos(frictionAngle+np.pi/2),0.5*wWheel*np.sin(frictionAngle+np.pi/2),0]
-                vAxle2 = RotationMatrixX(iPhi)@vAxle
-                rColor = color4grey
-                if i >= nCyl/2: rColor = color4darkgrey
-                graphicsWheel += [GraphicsDataCylinder(pAxis=pAxle-vAxle2, vAxis=2*vAxle2, radius=rCyl, 
-                                                color=rColor)]
-        # mounting wheels according platform setup
-        dx = 0.5 * mobileRobot['wheelBase']
-        dy = 0.5 * mobileRobot['wheelTrack']
-        if iWheel == 2 or iWheel == 3: dx *= -1
-        if iWheel == 1 or iWheel == 3: dy *= -1
-        kRolling = mobileRobot['wheelContactStiffness']
-        dRolling = mobileRobot['wheelContactDamping']
-        #v0Wheel = Skew(omega0Wheel) @ initialRotationWheel @ [0,0,rWheel]   #initial angular velocity of center point
-        v0Wheel = mobileRobot['platformInitialVelocity'] #approx.
-        initialRotation = RotationMatrixZ(-pi/2)
-        pOff = [dx,dy,0-p0Car[2]]    #[dx,dy,0]
-        poseWheel = VAdd(p0Car, HT2rotationMatrix(mobileRobot['platformInitialPose'])  @ VAdd(p0Wheel,pOff))
-        #add a wheel body to the main platform body
-        [nWheeln,bWheeln]=AddRigidBody(mainSys = mbs, 
-                            inertia = inertiaWheel, 
-                            nodeType = str(exu.NodeType.RotationEulerParameters), 
-                            position = poseWheel, 
-                            rotationMatrix = HT2rotationMatrix(mobileRobot['platformInitialPose'])  @ initialRotation, 
-                            angularVelocity = omega0Wheel,
-                            velocity=v0Wheel,
-                            gravity = mobileRobot['gravity']  , 
-                            graphicsDataList = graphicsWheel)
-        nWheelsList += [nWheeln]
-        bWheelsList += [bWheeln]
-        #markers for rigid body:
-        mWheel = mbs.AddMarker(MarkerBodyRigid(bodyNumber=bWheeln, localPosition=[0,0,0]))
-        mWheelsList += [mWheel]
-        mAxle = mbs.AddMarker(MarkerBodyRigid(bodyNumber=bPlatform, localPosition=VAdd(pOff,[0,0,p0Wheel[2]])))
-        mAxlesList += [mAxle]
-        jointLink, mBody0, mBody1 = AddRevoluteJoint(mbs=mbs, 
-                                            body0=bPlatform, 
-                                            body1=bWheeln, 
-                                            point= pOff[0:2] + [pOff[2] + p0Wheel[2]],
-                                            axis=[0,1,0] ,
-                                            #axis=rotAxis, 
-                                            useGlobalFrame=False, 
-                                            showJoint=True, axisRadius=4e-3, axisLength=0.12)
-        mRevoluteBody0 += [mBody0]
-        mRevoluteBody1 += [mBody1]
-        oAxlesList +=[jointLink]  
-        nGeneric = mbs.AddNode(NodeGenericData(initialCoordinates=[0,0,0], numberOfDataCoordinates=3))
-        dataGap = (poseWheel[-1] - mobileRobot['wheelRadius'])
-        if dataGap < 0: # initialize contact with the current gap between the wheel and ground
-            mbs.SetNodeParameter(nGeneric, 'initialCoordinates', [0,0,dataGap])
-        oRolling = mbs.AddObject(ObjectConnectorRollingDiscPenalty(name='wheel'+strWheelNum,markerNumbers=[markerGround, mWheel], nodeNumber = nGeneric,
-                                                    discRadius=rWheel, dryFriction=[mobileRobot['friction'][0], mobileRobot['friction'][1]], dryFrictionAngle=frictionAngle,
-                                                    viscousFriction = mobileRobot['viscousFrictionWheel'], 
-                                                    dryFrictionProportionalZone= mobileRobot['proportionalZone'], 
-                                                    rollingFrictionViscous=mobileRobot['friction'][2], 
-                                                    useLinearProportionalZone=mobileRobot['linearRegularization'], 
-                                                    contactStiffness=kRolling, contactDamping=dRolling,
-                                                    # visualization=VObjectConnectorRollingDiscPenalty(discWidth=wWheel, color=color4blue)))
-                                                    visualization=VObjectConnectorRollingDiscPenalty(show=False)))
-        oRollingDiscsList += [oRolling]
-    d = {'nPlatformList': nPlatformList,
-        'bPlatformList': bPlatformList,
-        'oRollingDiscsList': oRollingDiscsList,
-        'oAxlesList': oAxlesList, 
-        'oPlatformList':oPlatformList,
-        'mPlatformList': mPlatformList,
-        'nWheelsList':nWheelsList,
-        'bWheelsList':bWheelsList,
-        'mWheelsList': mWheelsList,
-        'mAxlesList': mAxlesList,
-        'mAxlesBodyRot0': mRevoluteBody0, 
-        'mAxlesBodyRot1':  mRevoluteBody1
-        }
-    return d
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: calculate 4 wheel velocities for a mecanum wheel driven platform with given platform velocities  
-#**author: Peter Manzl, Johannes Gerstmayr
-#**notes: still under development; wheel axis is mounted at y-axis; positive angVel rotates CCW in x/y plane viewed from top; for coordinate system, see Python class definition
-class MobileKinematics:
-# platform setup:
-# ^Y
-# |    W3 +---------+ W1
-# |       |         |
-# |       |    +    | car center point
-# |       |         |
-# |    W4 +---------+ W2 
-# |
-# |
-# +-------->X
-
-    #**classFunction: initialize mobileKinematics class
-    #**input: 
-    #  R: wheel radius
-    #  lx: wheel track width 
-    #  ly: wheel base 
-    #  wheeltype: 1=x-config (bad), 0=o-config (good) 
-    #**author: Peter Manzl
-    def __init__(self, R, lx, ly, flagAdjusted = False, lcx=0, lcy=0, wheeltype=0): 
-        if wheeltype ==0: cc = 1
-        elif wheeltype == 1: cc = -1
-        else: print('wheeltype {} not implemented (yet)!'.format(wheeltype))
-        
-        if not(flagAdjusted): 
-            self.Jacobian = 1/R * np.array([[1, -cc, -lx - cc*ly], 
-                                            [1,   cc,   lx + cc*ly], 
-                                            [1,   cc,  -lx - cc*ly], 
-                                            [1,   -cc,  lx + cc*ly]])
-        else:  # todo: add wheeltype to adjusted, this is used to test adjusted kinematics 
-            # self.Jacobian = 1/R * np.array([[1, -1, -lx - ly + lcx + lcy], 
-            #                                [1,   1,   lx + ly-lcx + lcy], 
-            #                                [1,   1,  -lx - ly - lcx + lcy], 
-            #                                [1,   -1,  lx + ly + lcx + lcy]])
-            c1 = 1/(4*lx*ly) # m*g/(4*Lx*Ly)
-            c2 = ly*lcx
-            F1 = ((ly+lcy)*lx + c2) * c1
-            F2 = ((ly-lcy)*lx + c2) * c1
-            F3 = ((ly+lcy)*lx - c2) * c1
-            F4 = ((ly-lcy)*lx - c2) * c1
-            self.Jacobian = 1/R * np.array([[1,  -1*F1, -lx - ly + lcx + lcy], 
-                                            [1,    1*F2,   lx + ly-lcx + lcy], 
-                                            [1,    1*F3,  -lx - ly - lcx + lcy], 
-                                            [1,   -1*F4,  lx + ly + lcx + lcy]])
-        self.JacobianPInv = np.linalg.pinv(self.Jacobian)
-    
-    #**classFunction: calculate wheel velocities from Cartesian velocities
-    #**input:
-    #  vDes: desired velocity [vx, vy, omega] in the robot's local frame
-    #  vx: platform  translational velocity in local x direction
-    #  vy: platform translational velocity in local y direction
-    #  omega: platform rotational velocity around local z axis
-    #**output: 
-    #   w: wheel velocities w=[w0,w1,w2,w3]
-    #**author: Peter Manzl
-    def getWheelVelocities(self, vDes):
-        if len(vDes) == 3: 
-            return self.Jacobian @ vDes
-        else: 
-            if len(vDes[0,:]) > len(vDes[:,0]): vDes = vDes.transpose()
-            if len(vDes.shape) != 2: 
-                raise Exception('kinematics can not be calculated for given vDes')
-            if len(vDes[0,:]) != 3: 
-                raise Exception('wrong dimensions for Kinematics equation! ')
-            nSteps = len(vDes[:,0])
-            w = np.zeros([nSteps, 4]) 
-            for i in range(nSteps): 
-                w[i,:] = self.Jacobian @ vDes[i,:]
-            return w
-
-    #**classFunction: calculate Cartesian velocities from wheel velocities
-    #**input:
-    #   w: wheel velocities w=[w0,w1,w2,w3]
-    #**output: 
-    #  v: Cartesian velocity [vx, vy, omega] in the robot's local frame
-    #  vx: platform  translational velocity in local x direction
-    #  vy: platform translational velocity in local y direction
-    #  omega: platform rotational velocity around local z axis
-    #**author: Peter Manzl
-    def getCartesianVelocities(self, w): 
-        if len(w) == 4: 
-            return self.JacobianPInv @ w
-        else: 
-            if len(w[0,:]) > len(w[:,0]): w = w.transpose()
-            if len(w.shape) != 2: 
-                raise Exception('kinematics can not be calculated for given vDes')
-            if len(w[0,:]) != 4: 
-                raise Exception('wrong dimensions for Kinematics equation! ')
-            nSteps = len(w[:,0])
-            v = np.zeros([nSteps, 3]) 
-            for i in range(nSteps): 
-                v[i,:] = self.JacobianPInv @ w[i,:]
-            return v   
-
-#**function: create a polynomial describing a generatrix function 
-#**input: 
-#   param: list containing data (lRoll, aPoly, ...)
-#   
-#**author: Peter Manzl
-#**note: create and fit a polynomial of an order high enough to approximate the given GeneratrixFunction
-#   with a given tolerance. The error is measured as the Chebyshev distance.  
-def Generatrix2Polynomial(param, GeneratrixFunction, tol=1e-14, nFit=101, nTest = 1001): 
-    u = np.linspace(-np.pi/4, np.pi/4 , nFit) # calculate error with more! 
-    x, y = GeneratrixFunction(u, param)
-
-    # to check error 
-    uTest = np.linspace(-np.pi/4, np.pi/4 , nTest)
-    xTest, yTest =  GeneratrixFunction(uTest, param)
-
-    iRoll = np.array(x > -param['lRoll']/2) & np.array(x < param['lRoll']/2)
-    iRollTest = np.array(xTest > -param['lRoll']/2) & np.array(xTest < param['lRoll']/2)
-    try: # add one additional index at start and end of the Roll if it exists. 
-        iRoll[np.where(iRoll==True)[0][[0,-1]] + [-1,1]] = True 
-        iRollTest[np.where(iRollTest==True)[0][[0,-1]] + [-1,1]] = True 
-    except: 
-        pass
-    x = x[iRoll]
-    y = y[iRoll]
-    xTest = xTest[iRollTest]
-    yTest = yTest[iRollTest]
-    coefficients = []
-    y_fit = []
-    err = []
-    order = [] 
-    nFits = 10
-    #++++++++++++++++++++++++++++++++++++++++++
-    #approximate function values y via polynomial given by ** coeffs
-    #iterate over polyfit until error of approximation is smaller than tol
-    #==>nFits ==> int(maxOrder/2)
-    for i in range(nFits): 
-        order += [2*i]
-        coefficients += [np.polyfit(x, y, order[i], rcond=None, full=False, w=None, cov=False)]
-        # for j in range(i):  #  only use the even coefficients
-        #     if (j % 2) == 1:
-        #         coefficients[i][j] = 0
-        err     += [yTest - np.polyval(coefficients[i], xTest)]
-        # exu.Print('Polynomial of order ' + str(order[i]) + ' is used for Roll Geometry, max err = ' + str(max(abs(err[i]))))
-        
-        #break for loop if tolerance reached
-        if max(abs(err[i])) < tol:
-            ibest = i
-            # print('tolerance reached for order '+ str(order[i]) + '.')
-            break
-    maxErr = np.max(np.abs(err),1)
-    if np.min(maxErr) > tol:
-        print('Warning: err fitted polynomial = ' + str(np.min(maxErr))+  ' of Polynomial > tol = ' + str(tol))
-        ibest = np.argmin(maxErr)
-    param['aPoly'] = coefficients[ibest]
-    param['aPoly0'] = coefficients[1] # use for starting point of Newton
-    # a strictly convex function is required, therefore the derivative is 
-    # changing monotonously and the second derivative is positive! 
-    ddy = np.zeros(xTest.size)
-    for i in range(xTest.size): 
-        ddy[i] = FunDDiffPoly(xTest[i], param['aPoly']) #
-    if (min(ddy) >= 0): 
-        exu.Print('Warning: the function seems not to be strictly convex: dd(f)/ddt <= 0 occurs! ')
-        
-    param['dyBoundary'] = [-FunDiffPoly(-param['lRoll']/2, param['aPoly']), -FunDiffPoly(param['lRoll']/2, param['aPoly'])] 
-    param['xBoundary'] = [-param['lRoll']/2, param['lRoll']/2]
-    return 
-
-#**function: generatrix function for a roll of a Mecanum wheel
-#**input: 
-#   u: parameter, max. +- pi/2
-#   param['r']: radius of the associated Mecanum wheel
-#   param['delta']: angle of the rolls rotation axis to the wheels rotation axis
-#   param['dRoll']: smallest distance of roll axis to the wheel axis
-#**output: 
-#   x and y values for the function in the local frame. The rotation around the 
-#   local x-yxis creates the surface of the roll. 
-#**author: Peter Manzl
-#**notes: parametric equation, x,y are the generatrix of the roll in 
-#   its local frame with the axis of rotation x, see \cite{Gfrerrer2008}.
-def GeneratrixRoll(u, param): 
-    x = param['dRoll']*np.cos(param['delta'])**2/np.sin(param['delta']) * np.tan(u) + param['r'] *np.sin(param['delta'])*np.sin(u);
-    y = np.sqrt(np.cos(param['delta'])**2 * np.tan(u)**2 + 1) * (param['r']*np.cos(u)- param['dRoll']);
-    return x, y
-
-#**function: calculates the derivative of the polynomial $a0*x^n + ... $
-#**input:
-#   x: value at which the polynomial is evaluated
-#   a: coefficients
-#**output:
-#   f: 
-#**author: Peter Manzl
-#**note: helper function polynomial describing a generatrix function 
-def FunDiffPoly(x,a): 
-    f = 0
-    k = np.size(a)-1
-    for i in range(k): 
-        f += (k-i)*x**(k-i-1)*a[i] 
-    return f
-
-#**function:  calculates the second derivative of a polynomial
-#**input:
-#   x: value at which the polynomial is evaluated
-#   a: coefficients
-#**output:
-#   f: 
-#**author: Peter Manzl
-#**note: helper function polynomial describing a generatrix function 
-def FunDDiffPoly(x, a): 
-    k = a.size -2  # order of the new polynomial 
-    ddf = 0
-    for i in range(k):
-        ddf += (k-i+1)*(k-i)*(x** (k-i-1)) *a[i]
-    return ddf
-
-
-
-
-
-# old functions deprecated
-################################################################################
-def MecanumXYphi2WheelVelocities(xVel, yVel, angVel, R, Lx, Ly, wheeltype):
-    if wheeltype == 0: # O-configuration
-        LxLy2 = (Lx+Ly)/2
-        mat = (1/R)*np.array([[1,-1,-LxLy2],
-                            [1,+1,+LxLy2],
-                            [1,+1,-LxLy2],
-                            [1,-1,+LxLy2]])
-    elif wheeltype == 1:# X-configuration 
-        LxLy2 = (Lx-Ly)/2
-        mat = (1/R)*np.array([[-1,-1,-LxLy2],
-                            [+1,-1,+LxLy2],
-                            [+1,-1,-LxLy2],
-                            [-1,-1,+LxLy2]])    
-        return mat @ [xVel, yVel, angVel]
-    elif wheeltype == 2: # standard wheel
-        print('Warning! Standardwheel not implemented yet, this Function is only a Placeholder!')
-        LxLy2 = (Lx+Ly)/2
-        mat = (1/R)*np.array([[-1,+1,+LxLy2],
-                            [-1,-1,-LxLy2],
-                            [-1,-1,+LxLy2],
-                            [-1,+1,-LxLy2]])
-    return mat @ [xVel, yVel, angVel]
-
-def MecanumWheelVelocity2XYphi(w, R, Lx, Ly, wheeltype): 
-    c = 0
-    LxLy2 = 0
-    
-    if wheeltype == 0: 
-        LxLy2 = (Lx+Ly)/2
-        c = 1
-    elif wheeltype == 1: 
-        LxLy2 = (Lx-Ly)/2
-        c = -1
-    elif wheeltype == 2: 
-        print('ToDo: Implement Standard wheels')
-    else: 
-        print('Warning: Only Wheeltypes 0 (O-Configuration) and 1 (X-Configuration) are considered!') 
-        return []
-    mat = R/(4) * np.array([[1, 1, 1, 1], 
-                            [-c, c, c, -c], 
-                            [-1/LxLy2, 1/LxLy2, -1/LxLy2, 1/LxLy2]])
-    return mat @ w
-    
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is a submodule of the EXUDYN python robotics library
+#
+# Details:  The utilities contains functionality for mobile robots 
+#           based on the EXUDYN example MecanumWheel RollingDiscPenality
+#           specific friction angle of rolling disc is used to model rolls of mecanum wheels
+#           
+#
+# Author:   Martin Sereinig, Peter Manzl and Johannes Gerstmayr
+# Date:     2021-10-01
+# Updated:  2023-09-15
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute 
+# it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+# Notes: formulation is still under development
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+# exudyn imports
+import exudyn as exu
+from exudyn.itemInterface import *
+from exudyn.utilities import *
+from exudyn.graphicsDataUtilities import *
+from exudyn.robotics import *
+
+import numpy as np
+
+#**function:    add items to existing mbs to build up a mobile robot platform, 
+#               there are options that can be passed as args / kwargs, which can contains options as described below. 
+#               The robot platform is built out of rigid bodies where the wheels can be modeled as rolling discs 
+#               (mecanum wheel x/o configuration) or with a detailed mecanum wheel simulation approach 
+#**input: 
+#   mbs: the multibody system which will be extended
+#   markerGround: a rigid body marker, at which the robot will be placed (usually ground)
+#   mobileRobot: a dictionary including all information about the mobile robot platform 
+#**output: the function returns a dictionary containing nodes, body, object and marker numbers of individual mobile robot parts 
+#           nPlatformList, bPlatformList, oPlatformList, mPlatformList; nodes, bodies, objects and marker of the platform [nPlattform] [bPlattform] [oPlattform]  []  
+#           oAxisList, mAxlesList; objects and marker of the axles  [a1, a2, a3, a4]
+#           nWheelsList, bWheelsList, oRollingDiscsList, mWheelsList; nodes, bodys, objects and markers of the four wheels [w1, w2, w3, w4]
+#**notes: for coordinate system, see Python function definition
+def mobileRobot2MBS(mbs, mobileRobot, markerGround, flagGraphicsRollers=True, *args, **kwargs):
+    # platform setup:
+    # ^Y
+    # |    W3 +---------+ W1
+    # |       |         |
+    # |       |    +    | car center point
+    # |       |         |
+    # |    W4 +---------+ W2 
+    # |
+    # |
+    # +-------->X
+    # define mobile robot platform, example values taken from the mobile robot Leobot, build from the university of Innsbruck 2019-2021 
+    # mobileRobot = { 'gravity':                    [0,0,-9.81],             # gravity in m/s^2
+    #                 'platformDimensions':        [0.5, 0.7 , 0.2612-0.0452],       # [width, length, hight]
+    #                 'platformMass':               58.6-16.06,                    # platform mass- manipulator mass 
+    #                 'platformInitialPose':        HTrotateZ(0)@HTtranslate([0.0,0,(0.0452+(0.2612-0.0452)/2.0)]),  # platform initial pose as HT middle of platform (box representation) 
+    #                 'platformInitialOmega':       [0,0,0],  # platform initial rotational velocity around x,y,z axis
+    #                 'platformInitialVelocity':    [0,0,0],  # platform initial translational velocity in x,y,z direction
+    #                 'platformCOM':                [0.0, 0.0, 0.0],       # center of mass shift to base coordinate system
+    #                 'platformBaseCoordinate':     [0.0 ,0.0 ,0.0], # geometric center  in middle of platform                   
+    #                 'platformInertia':            InertiaCuboid,     # platform inertia w.r.t. COM!                    
+    #                 'platformRepresentation':     'stl',          # 'box' or 'stl' graphical representation of the mobile platform 
+    #                 'platformStlFile':            'stl/huellgeometrie.STL',  # path to the used stl file 
+    #                 'wheelType':                  0,                      # 0=wheeltype wheel o-config, 1=mecanum wheel x-config, 2=standard wheel  (always in bottom view)
+    #                 'friction':                   [0.4, 0.0075, 0.05],    # [dryFriction1, dryFriction2,rollFriction]= [0.4,0.0075,0.05] for LeoBot (Master Thesis Manzl)
+    #                 'frictionAngel':              pi/4,                   # friction angle theta=pi/4 for mecanum wheel, theta=0 for standard wheel  
+    #                 'wheelBase':                  0.400,                    # distance between center of wheels (wheel axes) between front and back  
+    #                 'wheelTrack':                 0.390,                    # distance between center of wheels between left and right 
+    #                 'wheelRoh':                   1800,                    # density of wheel in kg/m^3
+    #                 'wheelRadius':                0.0762,                   # radius of wheel in m 
+    #                 'wheelWidth':                 0.076,                  # width of wheel in m, just for graphics     
+    #                 'wheelMass':                  2.406,                    # Mass of one mecanum wheel, leobot measured
+    #                 'wheelInertia':               InertiaCylinder,   # inertia for infinitely small ring:
+    #                 'wheelNumbers':               4,                       # number of wheels on platform
+    #                 'serialRobotMountpoint':      HTtranslate([0.211,0,-0.105]),  # serial robot mount point as HT from platform center coordinate system in middle of platform center
+    #                 'debugOffset':                debugOffsetNumber       # number to set the initial position in z, to a new value avoid oscillations
+    #                 'flagFlexible':                False                   # if True change RigidBody plate to flexible plate
+    #                 }  
+
+    # node, body,marker and object number for platform 
+    nPlatformList = []           
+    bPlatformList = []           
+    mPlatformList = []    
+    oPlatformList =[]   
+
+    # node, body, marker number for wheels
+    nWheelsList = [] 
+    bWheelsList = []
+    mWheelsList = []
+    oRollingDiscsList = []   
+    mAxlesList = []
+    oAxlesList =  []
+    if not('linearRegularization' in mobileRobot): 
+        mobileRobot['linearRegularization'] = True
+
+    # wheel parameter
+    rWheel = mobileRobot['wheelRadius']        
+    wWheel = mobileRobot['wheelWidth']        
+    p0Wheel = [0,0,rWheel+mobileRobot['debugOffset']    ]      # origin of disc center point at reference, such that initial contact point is at [0,0,0]
+    omega0Wheel = [0,0,0]       # initial angular velocity around z-axis
+    inertiaWheel = mobileRobot['wheelInertia']
+    mobileRobot['wheelRoh'] = mobileRobot['wheelMass'] /  (wWheel*rWheel**2*np.pi) # mass / Volume
+    inertiaWheel = InertiaCylinder(density=mobileRobot['wheelRoh']  , length=wWheel, outerRadius=rWheel, axis=0)
+
+    #platform parameters:
+    p0Car = HT2translation(mobileRobot['platformInitialPose']) 
+    p0Car[2] += mobileRobot['debugOffset'] 
+    wCar = mobileRobot['platformDimensions'][0]
+    lCar = mobileRobot['platformDimensions'][1]
+    hCar = mobileRobot['platformDimensions'][2] 
+    mCar = mobileRobot['platformMass']-4*inertiaWheel.mass #
+    inertiaPlatform = mobileRobot['platformInertia']
+    inertiaPlatform = InertiaCuboid(density=mCar/(lCar*wCar*hCar), sideLengths=[wCar, lCar, hCar])
+    inertiaPlatform = inertiaPlatform.Translated(mobileRobot['comShiftPlatform'])
+    inertiaPlatform.com  = mobileRobot['platformCOM'] #translate COM
+
+    # to make mobileRobot dictionary global 
+    mbs.variables['mobileRobot'] = mobileRobot
+    ################
+    graphicsPlatformList=[]
+    # drawing platform coordinate system 
+    graphicsPlatformList += [GraphicsDataCylinder([0,0,0], [0.5,0,0], 0.001, color4red)]
+    graphicsPlatformList += [GraphicsDataCylinder([0,0,0], [0,0.5,0], 0.001, color4green)]
+    graphicsPlatformList += [GraphicsDataCylinder([0,0,0], [0,0,0.2], 0.001, color4blue)]
+
+    if mobileRobot['platformRepresentation']=='box':
+        graphicsPlatformList += [GraphicsDataOrthoCubePoint(centerPoint=[0.0,0.0,0.0],size=[lCar, wCar-1.1*wWheel, hCar], color=color4steelblue[0:3]+[0.2])]
+    if mobileRobot['platformRepresentation'] == 'stl':
+        try:
+            stlGrafics = GraphicsDataFromSTLfileTxt(mobileRobot['platformStlFile'],color=[1,1,1,1])
+            graphicsPlatformList += [stlGrafics]
+        except:
+            print('stl not found, maybe wrong directory, use box instead')
+            graphicsPlatformList += [GraphicsDataOrthoCubePoint(centerPoint=[0,0,2.0],size=[lCar, wCar-1.1*wWheel, hCar], color=color4steelblue[0:3]+[0.2])]
+
+    [nPlatform,bPlatform] = AddRigidBody(mainSys = mbs, 
+                            inertia = inertiaPlatform, 
+                            nodeType = str(exu.NodeType.RotationEulerParameters), 
+                            position = p0Car, 
+                            rotationMatrix = HT2rotationMatrix(mobileRobot['platformInitialPose'])  ,
+                            angularVelocity =  mobileRobot['platformInitialOmega'],
+                            velocity=mobileRobot['platformInitialVelocity'],
+                            gravity = mobileRobot['gravity'], 
+                            graphicsDataList = graphicsPlatformList)
+    mbs.SetObjectParameter(bPlatform, 'name', 'Base')
+    mbs.SetNodeParameter(nPlatform, 'name', 'BaseCenter')
+    nPlatformList += [nPlatform]
+    bPlatformList += [bPlatform]
+    # marker in center of platform
+    mCenterPlatform = mbs.AddMarker(MarkerBodyRigid(name='mCenterPlatform',bodyNumber=bPlatform, localPosition=[0,0,0]))   #p0Car     
+    mPlatformList += [mCenterPlatform]
+    # marker in center of baseplate
+    mCenterBase = mbs.AddMarker(MarkerBodyRigid(name='mCenterBase',bodyNumber=bPlatform, localPosition=[0,0,-mobileRobot['platformDimensions'][2]/2]))     #VAdd (p0Car)
+    mPlatformList += [mCenterBase]
+    # generic joint in center of base plate            
+    oBasePlateJoint = mbs.AddObject(GenericJoint(markerNumbers=[markerGround, mCenterBase], activeConnector = True, 
+                            constrainedAxes=[0,0,0,0,0,0],
+                            visualization=VObjectJointGeneric(axesRadius=0.05, axesLength=2.4,color = [0.5,1.,0,0.1])))  
+    oPlatformList += [oBasePlateJoint]
+    
+    # marker on platform for serial robot placement
+    # note that the local coordinate system of the base must be in accordance with the DH-parameters, i.e., the z-axis must be the first rotation axis. For correction of the base coordinate system, use rotationMarkerBase
+    mRobotArmMounting = mbs.AddMarker(MarkerBodyRigid(name='mRobotArmMounting',bodyNumber=bPlatform, localPosition= HT2translation(mobileRobot['serialRobotMountpoint'])))
+    mPlatformList += [mRobotArmMounting]
+    mRevoluteBody0 = []
+    mRevoluteBody1 = []
+    # wheel parameter
+    param = {'r':  mobileRobot['wheelRadius'], 
+            'lRoll': wWheel, 
+            'nRolls': 8, 
+            'delta': np.pi/4,
+            'rRoll': mobileRobot['wheelRadius']*0.25}
+    param['dRoll'] = param['r'] - param['rRoll']
+    
+    if flagGraphicsRollers: 
+        Generatrix2Polynomial(param, GeneratrixRoll, tol=1e-8, nTest = 1001)
+    rCyl = param['rRoll']
+    nCyl = param['nRolls']
+    
+    ################## build all 4 wheels and add them to main platform body 
+    for iWheel in range( mobileRobot['wheelNumbers'] ):
+        strWheelNum = str(iWheel)
+
+        # setup friction angle regarding wheelType 0->0configuration, 1->Xconfiguration, 2->standard wheel
+        frictionAngle = -mobileRobot['frictionAngle']*pow(-1,(1-mobileRobot['wheelType'])) #45°
+        if iWheel == 1 or iWheel == 2: #difference in diagonal
+            frictionAngle *= -1
+        if mobileRobot['wheelType']==2:
+            frictionAngle = 0
+        # additional graphics for visualization of rollers on the wheel (JUST FOR DRAWING!):
+        # graphicsWheel = [GraphicsDataOrthoCubePoint(centerPoint=[0,0,0],size=[1.1*wWheel,0.7*rWheel,0.7*rWheel], color=color4lightred)]
+        graphicsWheel = [GraphicsDataCylinder(pAxis=[-0.55*wWheel,0,0], vAxis=[1.1*wWheel,0,0], radius=0.34*rWheel, color=color4lightred)]
+        if 0: # debugging roller orientations
+            graphicsWheel += [GraphicsDataCylinder([-0.1,0,0], [0.001, 0, 0], radius = param['r'], nTiles = 64, color=color4lawngreen)]
+        
+        if flagGraphicsRollers: 
+            contour =  [[-param['lRoll']/2, 0]]  
+            x = np.linspace(start = - param['lRoll']/2, stop = param['lRoll']/2, num=21) 
+            for i in range(np.size(x)):
+                contour+= [[x[i], np.polyval(param['aPoly'], x[i])]]
+            contour += [[param['lRoll']/2, 0]] # for a closed contour
+            graphRoll = []
+                
+        # draw cylinders on each wheel
+        for i in range(nCyl): 
+            iPhi = i/nCyl*2*np.pi
+            # drawing as cylinders
+            if flagGraphicsRollers: # draw as cylinders
+                pAxle = np.array([0,-(param['r']-param['rRoll'])*np.sin(iPhi), - (param['r']-param['rRoll'])*np.cos(iPhi)])    
+                vAxle = RotationMatrixX(-iPhi ) @  RotationMatrixZ(frictionAngle) @ [0.5*param['lRoll'],0,0]
+                graphicsWheel += [GraphicsDataSolidOfRevolution(pAxis=pAxle, vAxis=vAxle, contour=contour, color=color4blue[0:3]+[1],# color=color4blue[0:3] +[alpha], 
+                                                nTiles = 16)]        
+            else:
+                pAxle = np.array([0,rWheel*np.sin(iPhi),-rWheel*np.cos(iPhi)])
+                vAxle = [0.5*wWheel*np.cos(frictionAngle+np.pi/2),0.5*wWheel*np.sin(frictionAngle+np.pi/2),0]
+                vAxle2 = RotationMatrixX(iPhi)@vAxle
+                rColor = color4grey
+                if i >= nCyl/2: rColor = color4darkgrey
+                graphicsWheel += [GraphicsDataCylinder(pAxis=pAxle-vAxle2, vAxis=2*vAxle2, radius=rCyl, 
+                                                color=rColor)]
+        # mounting wheels according platform setup
+        dx = 0.5 * mobileRobot['wheelBase']
+        dy = 0.5 * mobileRobot['wheelTrack']
+        if iWheel == 2 or iWheel == 3: dx *= -1
+        if iWheel == 1 or iWheel == 3: dy *= -1
+        kRolling = mobileRobot['wheelContactStiffness']
+        dRolling = mobileRobot['wheelContactDamping']
+        #v0Wheel = Skew(omega0Wheel) @ initialRotationWheel @ [0,0,rWheel]   #initial angular velocity of center point
+        v0Wheel = mobileRobot['platformInitialVelocity'] #approx.
+        initialRotation = RotationMatrixZ(-pi/2)
+        pOff = [dx,dy,0-p0Car[2]]    #[dx,dy,0]
+        poseWheel = VAdd(p0Car, HT2rotationMatrix(mobileRobot['platformInitialPose'])  @ VAdd(p0Wheel,pOff))
+        #add a wheel body to the main platform body
+        [nWheeln,bWheeln]=AddRigidBody(mainSys = mbs, 
+                            inertia = inertiaWheel, 
+                            nodeType = str(exu.NodeType.RotationEulerParameters), 
+                            position = poseWheel, 
+                            rotationMatrix = HT2rotationMatrix(mobileRobot['platformInitialPose'])  @ initialRotation, 
+                            angularVelocity = omega0Wheel,
+                            velocity=v0Wheel,
+                            gravity = mobileRobot['gravity']  , 
+                            graphicsDataList = graphicsWheel)
+        nWheelsList += [nWheeln]
+        bWheelsList += [bWheeln]
+        #markers for rigid body:
+        mWheel = mbs.AddMarker(MarkerBodyRigid(bodyNumber=bWheeln, localPosition=[0,0,0]))
+        mWheelsList += [mWheel]
+        mAxle = mbs.AddMarker(MarkerBodyRigid(bodyNumber=bPlatform, localPosition=VAdd(pOff,[0,0,p0Wheel[2]])))
+        mAxlesList += [mAxle]
+        jointLink, mBody0, mBody1 = AddRevoluteJoint(mbs=mbs, 
+                                            body0=bPlatform, 
+                                            body1=bWheeln, 
+                                            point= pOff[0:2] + [pOff[2] + p0Wheel[2]],
+                                            axis=[0,1,0] ,
+                                            #axis=rotAxis, 
+                                            useGlobalFrame=False, 
+                                            showJoint=True, axisRadius=4e-3, axisLength=0.12)
+        mRevoluteBody0 += [mBody0]
+        mRevoluteBody1 += [mBody1]
+        oAxlesList +=[jointLink]  
+        nGeneric = mbs.AddNode(NodeGenericData(initialCoordinates=[0,0,0], numberOfDataCoordinates=3))
+        dataGap = (poseWheel[-1] - mobileRobot['wheelRadius'])
+        if dataGap < 0: # initialize contact with the current gap between the wheel and ground
+            mbs.SetNodeParameter(nGeneric, 'initialCoordinates', [0,0,dataGap])
+        oRolling = mbs.AddObject(ObjectConnectorRollingDiscPenalty(name='wheel'+strWheelNum,markerNumbers=[markerGround, mWheel], nodeNumber = nGeneric,
+                                                    discRadius=rWheel, dryFriction=[mobileRobot['friction'][0], mobileRobot['friction'][1]], dryFrictionAngle=frictionAngle,
+                                                    viscousFriction = mobileRobot['viscousFrictionWheel'], 
+                                                    dryFrictionProportionalZone= mobileRobot['proportionalZone'], 
+                                                    rollingFrictionViscous=mobileRobot['friction'][2], 
+                                                    useLinearProportionalZone=mobileRobot['linearRegularization'], 
+                                                    contactStiffness=kRolling, contactDamping=dRolling,
+                                                    # visualization=VObjectConnectorRollingDiscPenalty(discWidth=wWheel, color=color4blue)))
+                                                    visualization=VObjectConnectorRollingDiscPenalty(show=False)))
+        oRollingDiscsList += [oRolling]
+    d = {'nPlatformList': nPlatformList,
+        'bPlatformList': bPlatformList,
+        'oRollingDiscsList': oRollingDiscsList,
+        'oAxlesList': oAxlesList, 
+        'oPlatformList':oPlatformList,
+        'mPlatformList': mPlatformList,
+        'nWheelsList':nWheelsList,
+        'bWheelsList':bWheelsList,
+        'mWheelsList': mWheelsList,
+        'mAxlesList': mAxlesList,
+        'mAxlesBodyRot0': mRevoluteBody0, 
+        'mAxlesBodyRot1':  mRevoluteBody1
+        }
+    return d
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: calculate 4 wheel velocities for a mecanum wheel driven platform with given platform velocities  
+#**author: Peter Manzl, Johannes Gerstmayr
+#**notes: still under development; wheel axis is mounted at y-axis; positive angVel rotates CCW in x/y plane viewed from top; for coordinate system, see Python class definition
+class MobileKinematics:
+# platform setup:
+# ^Y
+# |    W3 +---------+ W1
+# |       |         |
+# |       |    +    | car center point
+# |       |         |
+# |    W4 +---------+ W2 
+# |
+# |
+# +-------->X
+
+    #**classFunction: initialize mobileKinematics class
+    #**input: 
+    #  R: wheel radius
+    #  lx: wheel track width 
+    #  ly: wheel base 
+    #  wheeltype: 1=x-config (bad), 0=o-config (good) 
+    #**author: Peter Manzl
+    def __init__(self, R, lx, ly, flagAdjusted = False, lcx=0, lcy=0, wheeltype=0): 
+        if wheeltype ==0: cc = 1
+        elif wheeltype == 1: cc = -1
+        else: print('wheeltype {} not implemented (yet)!'.format(wheeltype))
+        
+        if not(flagAdjusted): 
+            self.Jacobian = 1/R * np.array([[1, -cc, -lx - cc*ly], 
+                                            [1,   cc,   lx + cc*ly], 
+                                            [1,   cc,  -lx - cc*ly], 
+                                            [1,   -cc,  lx + cc*ly]])
+        else:  # todo: add wheeltype to adjusted, this is used to test adjusted kinematics 
+            # self.Jacobian = 1/R * np.array([[1, -1, -lx - ly + lcx + lcy], 
+            #                                [1,   1,   lx + ly-lcx + lcy], 
+            #                                [1,   1,  -lx - ly - lcx + lcy], 
+            #                                [1,   -1,  lx + ly + lcx + lcy]])
+            c1 = 1/(4*lx*ly) # m*g/(4*Lx*Ly)
+            c2 = ly*lcx
+            F1 = ((ly+lcy)*lx + c2) * c1
+            F2 = ((ly-lcy)*lx + c2) * c1
+            F3 = ((ly+lcy)*lx - c2) * c1
+            F4 = ((ly-lcy)*lx - c2) * c1
+            self.Jacobian = 1/R * np.array([[1,  -1*F1, -lx - ly + lcx + lcy], 
+                                            [1,    1*F2,   lx + ly-lcx + lcy], 
+                                            [1,    1*F3,  -lx - ly - lcx + lcy], 
+                                            [1,   -1*F4,  lx + ly + lcx + lcy]])
+        self.JacobianPInv = np.linalg.pinv(self.Jacobian)
+    
+    #**classFunction: calculate wheel velocities from Cartesian velocities
+    #**input:
+    #  vDes: desired velocity [vx, vy, omega] in the robot's local frame
+    #  vx: platform  translational velocity in local x direction
+    #  vy: platform translational velocity in local y direction
+    #  omega: platform rotational velocity around local z axis
+    #**output: 
+    #   w: wheel velocities w=[w0,w1,w2,w3]
+    #**author: Peter Manzl
+    def getWheelVelocities(self, vDes):
+        if len(vDes) == 3: 
+            return self.Jacobian @ vDes
+        else: 
+            if len(vDes[0,:]) > len(vDes[:,0]): vDes = vDes.transpose()
+            if len(vDes.shape) != 2: 
+                raise Exception('kinematics can not be calculated for given vDes')
+            if len(vDes[0,:]) != 3: 
+                raise Exception('wrong dimensions for Kinematics equation! ')
+            nSteps = len(vDes[:,0])
+            w = np.zeros([nSteps, 4]) 
+            for i in range(nSteps): 
+                w[i,:] = self.Jacobian @ vDes[i,:]
+            return w
+
+    #**classFunction: calculate Cartesian velocities from wheel velocities
+    #**input:
+    #   w: wheel velocities w=[w0,w1,w2,w3]
+    #**output: 
+    #  v: Cartesian velocity [vx, vy, omega] in the robot's local frame
+    #  vx: platform  translational velocity in local x direction
+    #  vy: platform translational velocity in local y direction
+    #  omega: platform rotational velocity around local z axis
+    #**author: Peter Manzl
+    def getCartesianVelocities(self, w): 
+        if len(w) == 4: 
+            return self.JacobianPInv @ w
+        else: 
+            if len(w[0,:]) > len(w[:,0]): w = w.transpose()
+            if len(w.shape) != 2: 
+                raise Exception('kinematics can not be calculated for given vDes')
+            if len(w[0,:]) != 4: 
+                raise Exception('wrong dimensions for Kinematics equation! ')
+            nSteps = len(w[:,0])
+            v = np.zeros([nSteps, 3]) 
+            for i in range(nSteps): 
+                v[i,:] = self.JacobianPInv @ w[i,:]
+            return v   
+
+#**function: create a polynomial describing a generatrix function 
+#**input: 
+#   param: list containing data (lRoll, aPoly, ...)
+#   
+#**author: Peter Manzl
+#**note: create and fit a polynomial of an order high enough to approximate the given GeneratrixFunction
+#   with a given tolerance. The error is measured as the Chebyshev distance.  
+def Generatrix2Polynomial(param, GeneratrixFunction, tol=1e-14, nFit=101, nTest = 1001): 
+    u = np.linspace(-np.pi/4, np.pi/4 , nFit) # calculate error with more! 
+    x, y = GeneratrixFunction(u, param)
+
+    # to check error 
+    uTest = np.linspace(-np.pi/4, np.pi/4 , nTest)
+    xTest, yTest =  GeneratrixFunction(uTest, param)
+
+    iRoll = np.array(x > -param['lRoll']/2) & np.array(x < param['lRoll']/2)
+    iRollTest = np.array(xTest > -param['lRoll']/2) & np.array(xTest < param['lRoll']/2)
+    try: # add one additional index at start and end of the Roll if it exists. 
+        iRoll[np.where(iRoll==True)[0][[0,-1]] + [-1,1]] = True 
+        iRollTest[np.where(iRollTest==True)[0][[0,-1]] + [-1,1]] = True 
+    except: 
+        pass
+    x = x[iRoll]
+    y = y[iRoll]
+    xTest = xTest[iRollTest]
+    yTest = yTest[iRollTest]
+    coefficients = []
+    y_fit = []
+    err = []
+    order = [] 
+    nFits = 10
+    #++++++++++++++++++++++++++++++++++++++++++
+    #approximate function values y via polynomial given by ** coeffs
+    #iterate over polyfit until error of approximation is smaller than tol
+    #==>nFits ==> int(maxOrder/2)
+    for i in range(nFits): 
+        order += [2*i]
+        coefficients += [np.polyfit(x, y, order[i], rcond=None, full=False, w=None, cov=False)]
+        # for j in range(i):  #  only use the even coefficients
+        #     if (j % 2) == 1:
+        #         coefficients[i][j] = 0
+        err     += [yTest - np.polyval(coefficients[i], xTest)]
+        # exu.Print('Polynomial of order ' + str(order[i]) + ' is used for Roll Geometry, max err = ' + str(max(abs(err[i]))))
+        
+        #break for loop if tolerance reached
+        if max(abs(err[i])) < tol:
+            ibest = i
+            # print('tolerance reached for order '+ str(order[i]) + '.')
+            break
+    maxErr = np.max(np.abs(err),1)
+    if np.min(maxErr) > tol:
+        print('Warning: err fitted polynomial = ' + str(np.min(maxErr))+  ' of Polynomial > tol = ' + str(tol))
+        ibest = np.argmin(maxErr)
+    param['aPoly'] = coefficients[ibest]
+    param['aPoly0'] = coefficients[1] # use for starting point of Newton
+    # a strictly convex function is required, therefore the derivative is 
+    # changing monotonously and the second derivative is positive! 
+    ddy = np.zeros(xTest.size)
+    for i in range(xTest.size): 
+        ddy[i] = FunDDiffPoly(xTest[i], param['aPoly']) #
+    if (min(ddy) >= 0): 
+        exu.Print('Warning: the function seems not to be strictly convex: dd(f)/ddt <= 0 occurs! ')
+        
+    param['dyBoundary'] = [-FunDiffPoly(-param['lRoll']/2, param['aPoly']), -FunDiffPoly(param['lRoll']/2, param['aPoly'])] 
+    param['xBoundary'] = [-param['lRoll']/2, param['lRoll']/2]
+    return 
+
+#**function: generatrix function for a roll of a Mecanum wheel
+#**input: 
+#   u: parameter, max. +- pi/2
+#   param['r']: radius of the associated Mecanum wheel
+#   param['delta']: angle of the rolls rotation axis to the wheels rotation axis
+#   param['dRoll']: smallest distance of roll axis to the wheel axis
+#**output: 
+#   x and y values for the function in the local frame. The rotation around the 
+#   local x-yxis creates the surface of the roll. 
+#**author: Peter Manzl
+#**notes: parametric equation, x,y are the generatrix of the roll in 
+#   its local frame with the axis of rotation x, see \cite{Gfrerrer2008}.
+def GeneratrixRoll(u, param): 
+    x = param['dRoll']*np.cos(param['delta'])**2/np.sin(param['delta']) * np.tan(u) + param['r'] *np.sin(param['delta'])*np.sin(u);
+    y = np.sqrt(np.cos(param['delta'])**2 * np.tan(u)**2 + 1) * (param['r']*np.cos(u)- param['dRoll']);
+    return x, y
+
+#**function: calculates the derivative of the polynomial $a0*x^n + ... $
+#**input:
+#   x: value at which the polynomial is evaluated
+#   a: coefficients
+#**output:
+#   f: 
+#**author: Peter Manzl
+#**note: helper function polynomial describing a generatrix function 
+def FunDiffPoly(x,a): 
+    f = 0
+    k = np.size(a)-1
+    for i in range(k): 
+        f += (k-i)*x**(k-i-1)*a[i] 
+    return f
+
+#**function:  calculates the second derivative of a polynomial
+#**input:
+#   x: value at which the polynomial is evaluated
+#   a: coefficients
+#**output:
+#   f: 
+#**author: Peter Manzl
+#**note: helper function polynomial describing a generatrix function 
+def FunDDiffPoly(x, a): 
+    k = a.size -2  # order of the new polynomial 
+    ddf = 0
+    for i in range(k):
+        ddf += (k-i+1)*(k-i)*(x** (k-i-1)) *a[i]
+    return ddf
+
+
+
+
+
+# old functions deprecated
+################################################################################
+def MecanumXYphi2WheelVelocities(xVel, yVel, angVel, R, Lx, Ly, wheeltype):
+    if wheeltype == 0: # O-configuration
+        LxLy2 = (Lx+Ly)/2
+        mat = (1/R)*np.array([[1,-1,-LxLy2],
+                            [1,+1,+LxLy2],
+                            [1,+1,-LxLy2],
+                            [1,-1,+LxLy2]])
+    elif wheeltype == 1:# X-configuration 
+        LxLy2 = (Lx-Ly)/2
+        mat = (1/R)*np.array([[-1,-1,-LxLy2],
+                            [+1,-1,+LxLy2],
+                            [+1,-1,-LxLy2],
+                            [-1,-1,+LxLy2]])    
+        return mat @ [xVel, yVel, angVel]
+    elif wheeltype == 2: # standard wheel
+        print('Warning! Standardwheel not implemented yet, this Function is only a Placeholder!')
+        LxLy2 = (Lx+Ly)/2
+        mat = (1/R)*np.array([[-1,+1,+LxLy2],
+                            [-1,-1,-LxLy2],
+                            [-1,-1,+LxLy2],
+                            [-1,+1,-LxLy2]])
+    return mat @ [xVel, yVel, angVel]
+
+def MecanumWheelVelocity2XYphi(w, R, Lx, Ly, wheeltype): 
+    c = 0
+    LxLy2 = 0
+    
+    if wheeltype == 0: 
+        LxLy2 = (Lx+Ly)/2
+        c = 1
+    elif wheeltype == 1: 
+        LxLy2 = (Lx-Ly)/2
+        c = -1
+    elif wheeltype == 2: 
+        print('ToDo: Implement Standard wheels')
+    else: 
+        print('Warning: Only Wheeltypes 0 (O-Configuration) and 1 (X-Configuration) are considered!') 
+        return []
+    mat = R/(4) * np.array([[1, 1, 1, 1], 
+                            [-c, c, c, -c], 
+                            [-1/LxLy2, 1/LxLy2, -1/LxLy2, 1/LxLy2]])
+    return mat @ w
+
```

## exudyn/robotics/models.py

 * *Ordering differences only*

```diff
@@ -1,690 +1,690 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is a submodule of the EXUDYN python robotics library
-#
-# Details:  This module contains robotics models; They can be imported by simply calling the functions,
-#           which return the according robot dictionary;
-#            the library is built on Denavit-Hartenberg Parameters and
-#            Homogeneous Transformations (HT) to describe transformations and coordinate systems
-#
-# Authors:   Martin Sereinig; Peter Manzl; Johannes Gerstmayr
-# Date:     2021-01-10
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-import exudyn.graphicsDataUtilities as gdu
-import exudyn.robotics as rob
-from exudyn.rigidBodyUtilities import HT2rotationMatrix, HT2translation, Skew, HTtranslate, InverseHT,\
-                                      HT0, HTrotateY, HTrotateX, RigidBodyInertia
-import scipy.io
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# DH Parameter Information:
-# stdH = [theta, d, a, alpha] with Rz(theta) * Tz(d) * Tx(a) * Rx(alpha)
-# modDH = [alpha, dx, theta, rz] with 
-# used by Corke and Lynch: Rx(alpha) * Tx(a) * Rz(theta) * Tz(d)
-# used by Khali:           Rx(alpha) * Tx(d) * Rz(theta) * Tz(r)
-# Important note:  d(khali)=a(corke)  and r(khali)=d(corke)  
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate 4R manipulator as myRobot dictionary, settings are done in function 
-#**output: myRobot dictionary
-#**author: Martin Sereinig
-#**notes: the 4th joint is used to simulate a paralell kinematics manipulator 
-def Manipulator4Rsimple():
-    inertiaLink0=np.array([ [  0.703370,   -0.0001390,    0.0067720],
-                            [ -0.000139,    0.7066100,    0.0192169],
-                            [  0.006772,    0.0192169,    0.0091170]  ])
-    
-    inertiaLink1=np.array([ [  0.007962,   -0.003925,    0.010254],
-                            [ -0.003925,    0.028110,    0.000704],
-                            [  0.010254,    0.000704,    0.025995]  ])
-    
-    inertiaLink2=np.array([ [  0.037242,   -0.004761,   -0.011396],
-                            [ -0.004761,    0.036155,   -0.012805],
-                            [ -0.011396,   -0.012805,    0.010830]  ])
-    
-    inertiaLink3=np.array([ [  0.025853,    0.007796,   -0.001332],
-                            [  0.007796,    0.019552,    0.008641],
-                            [ -0.001332,    0.008641,    0.028323]  ])
-    
-    link0={'stdDH':[0,0,0,np.pi/2*0],  
-           'modDHKK':[0,0,0,0],          
-            'mass':4,  
-            'inertia':inertiaLink0,         #w.r.t. COM!
-            'jointStiffness':70000,         # placeholder 
-            'jointTorqueMax': 50,           # placeholder 
-            'jointLimits': [-np.pi, np.pi], # placeholder 
-            'COM':[0,0,0]}                  #w.r.t. stdDH joint coordinatesystem
-    
-    link1={'stdDH':[0,0,0.25,0],   
-           'modDHKK':[-np.pi/2,0,0,0], 
-            'mass':1, 
-            'inertia':inertiaLink1, #w.r.t. COM!
-            'jointStiffness':70000,# placeholder 
-            'jointTorqueMax': 50,# placeholder 
-            'jointLimits': [-np.pi, np.pi],# placeholder Value
-            'COM':[0.25/2,0,0]} #w.r.t. stdDH joint coordinatesystem
-    
-    link2={'stdDH':[0,0,0.25,0],
-            'modDHKK':[0,0.25,0,0],            
-            'mass':1, 
-            'inertia':inertiaLink2, #w.r.t. COM!
-            'jointStiffness':70000, # placeholder 
-            'jointTorqueMax': 50, # placeholder 
-            'jointLimits': [-np.pi, np.pi], # placeholder 
-            'COM':[0.25/2,0,0]}  #w.r.t. stdDH joint coordinatesystem
-    
-    link3={'stdDH':[0,0,0,0],
-           'modDHKK':[0,0.25,0,0],         
-            'mass':1, 
-            'inertia':inertiaLink3, #w.r.t. COM!
-            'jointStiffness':70000, # placeholder 
-            'jointTorqueMax': 50, # placeholder 
-            'jointLimits': [-np.pi, np.pi],# placeholder value
-            'COM':[ 0,0,0]} #w.r.t. stdDH joint coordinatesystem
-    
-    
-    linkList=[link0, link1, link2]
-    Tmax=[]
-    JointStiffness=[]
-    for link in linkList:
-         JointStiffness += [link['jointStiffness']]
-         Tmax += [link['jointTorqueMax']]   
-    
-    #this is the global myRobot structure
-    myRobot={'links':linkList,
-           'jointType':[1,1,1], #1=revolute, 0=prismatic
-           'jointStiffnessMatrix':   np.diag(JointStiffness),
-           'joinTorqueMaxMatrix':    np.diag(Tmax),
-           'base':{'HT':HTtranslate([0,0,0])},
-           'tool':{'HT':HTtranslate([0,0,0]) @HTrotateX(np.pi/2)   @HTrotateY(np.pi/2)},
-           'gravity':[0,0,-9.81],
-           'referenceConfiguration':[0]*3, #reference configuration for bodies; at which the myRobot is built
-           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
-           'Pcontrol': np.array([1000, 1000, 100, 100,  ]), #UNTESTED; some assumed values, not taken from real robot
-           'Dcontrol': np.array([10,   10,   10,   10,   ]),#UNTESTED; some assumed values, not taken from real robot
-           } 
-
-    return myRobot
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate 3R manipulator as myRobot dictionary, settings are done in function 
-#**output: myRobot dictionary
-#**author: Martin Sereinig
-#**notes: DH-parameters: [theta, d, a, alpha], according to P. Corke
-#       Values according to Wörnle simple example with l1=0
-#       d=[h1 0 0];
-#       theta=[beta1 beta2 beta3];
-#       a=[l1 l2 l3];
-#       alpha=[pi/2 0 0];
-def Manipulator3RSimple():
-        
-    l1=0.0
-    l2=0.5
-    l3=0.5
-    
-    b1=0.1
-    b2=0.1
-    b3=0.1
-    
-    h1=0.5
-    
-    m1=3
-    m2=2
-    m3=1
-    A1=0.1
-    B1=0.2
-    C1=0.3
-    A2=0.5
-    B2=0.6
-    C2=0.7
-    A3=0.8
-    B3=0.9
-    C3=0.1
-
-
-    link0={'stdDH':[0,h1,l1*0,np.pi/2],    # here l1*0 to point out it is zero 
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':m1,  #not needed!
-           'inertia':np.diag([A1,B1,C1]), #w.r.t. COM!  
-           'jointStiffness':70000, #  placeholder 
-           'jointTorqueMax': 50, # placeholder
-           'jointLimits': [-np.pi, np.pi], # placeholder
-           'COM':[-l1,-(h1-b1),0]}    #w.r.t. stdDH joint coordinatesystem
-    
-    link1={'stdDH':  [0,0,l2,0 ],
-           'modDHKK':[-np.pi/2,0,0,0],    
-           'mass':m2, 
-           'inertia':np.diag([A2,B2,C2]), #w.r.t. COM!
-           'jointStiffness':60000, # placeholder
-           'jointTorqueMax': 90, # placeholder
-           'jointLimits': [-np.pi, np.pi], # placeholder
-           'COM':[-(l2-b2),0, 0]} #w.r.t. stdDH joint coordinatesystem
-    
-    link2={'stdDH':  [0,0,l3,0], 
-           'modDHKK':[0,l3,0,0],
-           'mass':m3, 
-           'inertia':np.diag([A3,B3,C3]), #w.r.t. COM!
-           'jointStiffness': 20000, # placeholder
-           'jointTorqueMax': 50,  # placeholder
-           'jointLimits': [-np.pi, np.pi], # placeholder
-           'COM':[-(l3-b3),0,0]} #w.r.t. stdDH joint coordinatesystem
-    
-    
-    linkList=[link0, link1, link2]
-    Tmax=[]
-    JointStiffness=[]
-    for link in linkList:
-         JointStiffness += [link['jointStiffness']]
-         Tmax += [link['jointTorqueMax']]   
-    
-    
-    #this is the global myRobot structure
-    myRobot={'links':linkList,
-           'jointType':[1,1,1], #1=revolute, 0=prismatic
-           'jointStiffnessMatrix':   np.diag(JointStiffness),
-           'joinTorqueMaxMatrix':    np.diag(Tmax),
-           'base':{'HT':HTtranslate([0,0,0])},
-           'tool':{'HT':HTtranslate([0,0,l3])},
-           'gravity':[0,0,-9.81],
-           'referenceConfiguration':[0]*3, #reference configuration for bodies; at which the myRobot is built
-           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
-           'Pcontrol': np.array([1000, 1000, 100,  ]), #UNTESTED; some assumed values, not taken from real robot
-           'Dcontrol': np.array([10,   10,   10,   ]), #UNTESTED; some assumed values, not taken from real robot
-           } 
-
-    return myRobot
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate Franka Emika Panda manipulator as myRobot dictionary, settings are done in function 
-#**output: myRobot dictionary
-#**author: Martin Sereinig
-#**notes:  all Parameter according to Gaz et. al \cite{GazDeLuca2019}
-#       DH-parameters(std): [theta, d, a, alpha], according to P. Corke
-#       Standard DH Parameters, masses, inertias and com according P.Corke and Gaz et. al (they working with modified DH parameter)
-#       changes to standard DH Parameter checked with P.Corke toolbox                             
-def ManipulatorPANDA():
-
-       
-    inertiaLink0=np.array([ [  0.703370,   -0.0001390,    0.0067720],
-                            [ -0.000139,    0.7066100,    0.0192169],
-                            [  0.006772,    0.0192169,    0.0091170]  ])
-    
-    inertiaLink1=np.array([ [  0.007962,   -0.003925,    0.010254],
-                            [ -0.003925,    0.028110,    0.000704],
-                            [  0.010254,    0.000704,    0.025995]  ])
-    
-    inertiaLink2=np.array([ [  0.037242,   -0.004761,   -0.011396],
-                            [ -0.004761,    0.036155,   -0.012805],
-                            [ -0.011396,   -0.012805,    0.010830]  ])
-    
-    inertiaLink3=np.array([ [  0.025853,    0.007796,   -0.001332],
-                            [  0.007796,    0.019552,    0.008641],
-                            [ -0.001332,    0.008641,    0.028323]  ])
-    
-    inertiaLink4=np.array([ [  0.035549,   -0.002117,   -0.004037],
-                            [ -0.002117,    0.029474,    0.000229],
-                            [ -0.004037,    0.000229,    0.008627]  ])
-    
-    inertiaLink5=np.array([ [  0.001964,    0.000109,   -0.001158],
-                            [  0.000109,    0.004354,    0.000341],
-                            [ -0.001158,    0.000341,    0.005433]  ])
-    
-    inertiaLink6=np.array([ [  0.012516,   -0.000428,   -0.001196],
-                            [ -0.000428,    0.010027,   -0.000741],
-                            [ -0.001196,   -0.000741,    0.004815]  ])
-    
-    stdDHparameter=([[0,      0.333,      0,                np.pi/2],
-                     [0,          0,      0,                -np.pi/2],
-                     [0,      0.316,      0.088,            np.pi/2],
-                     [0,      0,         -0.088,           -np.pi/2],
-                     [0,      0.384,      0,                np.pi/2],
-                     [0,      0,          0.088,            np.pi/2],
-                     [0,      0.107,      0,                   0]])
-    
-    torqueMax= [1,1,1,1,1,1,1]#some assumed values, not taken from real robot
-    stiffness= [1,1,1,1,1,1,1]#some assumed values, not taken from real robot
-
-    
-    link0={'stdDH':[0,0.333,0,np.pi/2], 
-           'modDHKK':[0,0,0,0.333],
-            'mass':4.970684,  #not needed!
-            'inertia':inertiaLink0, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 87, # from datasheet
-            'jointLimits': [-2.8973, 2.8973],   # from datasheet
-            'COM':[3.875e-03,2.081e-03,0]} #w.r.t. modDH joint coordinatesystem
-    
-    link1={'stdDH':[0,0,0,-np.pi/2],
-           'modDHKK':[-np.pi/2,0,0,0], 
-            'mass':0.646926, 
-            'inertia':inertiaLink1, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 87, # from datasheet
-            'jointLimits': [-1.7628,1.7628],  # from datasheet
-            'COM':[-3.141e-03,-2.872e-02,3.495e-03]} #w.r.t. modDH joint coordinatesystem
-    
-    link2={'stdDH':[0,0.316,0.088,np.pi/2], 
-           'modDHKK':[np.pi/2,0,0,0.316],
-            'mass':3.228604, 
-            'inertia':inertiaLink2, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 87, # not set correctly yet
-            'jointLimits': [-2.8973,2.8973], # from datasheet
-            'COM':[ 2.7518e-02,3.9252e-02,-6.6502e-02]} #w.r.t. modDH joint coordinatesystem
-    
-    link3={'stdDH':[0,0,-0.088,-np.pi/2], 
-           'modDHKK':[np.pi/2,0.0825,0,0],
-            'mass':3.587895, 
-            'inertia':inertiaLink3, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 87, # from datasheet
-            'jointLimits': [-3.0718,-0.0698], # from datasheet
-            'COM':[ -5.317e-02,1.04419e-01,2.7454e-02]} #w.r.t. modDH joint coordinatesystem
-    
-    link4={'stdDH':[0,0.384,0,np.pi/2], 
-           'modDHKK':[-np.pi/2,-0.0825,0,0.384],
-            'mass':1.225946, 
-            'inertia':inertiaLink4, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 12, # from datasheet
-            'jointLimits': [-2.8973,2.8973], # from datasheet
-            'COM':[-1.1953e-02,4.1065e-02,-3.8437e-02]} #w.r.t. modDH joint coordinatesystem
-    
-    link5={'stdDH':[0,0,0.088,np.pi/2], 
-           'modDHKK':[np.pi/2,0,0,0],
-            'mass':1.666555, 
-            'inertia':inertiaLink5, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 12, # from datasheet
-            'jointLimits': [-0.0175,3.7525], 
-            'COM':[6.0149e-02,-1.4117e-02,-1.0517e-02]} #w.r.t. modDH joint coordinatesystem
-    
-    link6={'stdDH':[0,0.107,0,0], 
-           'modDHKK':[np.pi/2,0.088,0,0.107],
-            'mass':0.735522, 
-            'inertia':inertiaLink6, #w.r.t. COM!
-            'jointStiffness':1, # not set correctly yet
-            'jointTorqueMax': 12, # from datasheet
-            'jointLimits': [-2.8973,2.8973], # from datasheet
-            'COM':[1.0517e-02,-4.252e-03,6.1597e-02]} #w.r.t. modDH joint coordinatesystem
-    massRobotArm=0
-    
-    linkList=[link0, link1, link2, link3, link4, link5, link6]
-    Tmax=[]
-    JointStiffness=[]
-    for link in linkList:
-         JointStiffness += [link['jointStiffness']]
-         Tmax += [link['jointTorqueMax']]    
-        
-    #this is the global myRobot structure
-    myRobot={'links':linkList,
-           'jointType':[1,1,1,1,1,1,1], #1=revolute, 0=prismatic
-           'jointStiffnessMatrix':   np.diag(JointStiffness),
-           'joinTorqueMaxMatrix':    np.diag(Tmax),
-           'base':{'HT':HTtranslate([0,0,0])},
-           'tool':{'HT':HTtranslate([0,0,0.11])},
-           'gravity':[0,0,-9.81],
-           'referenceConfiguration':[0]*7, #reference configuration for bodies; at which the myRobot is built
-           'dhMode':'modDHKK', #this mode prescribes the default DH mode to be used; 
-           'Pcontrol': np.array([40000, 40000, 40000, 100, 100, 100, 10]), #UNTESTED; some assumed values, not taken from real robot
-           'Dcontrol': np.array([400,   400,   100,   1,   1,   1,   0.1]),#UNTESTED; some assumed values, not taken from real robot
-           } 
-
-
-    return myRobot
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate UR5 manipulator as myRobot dictionary, settings are done in function 
-#**output: myRobot dictionary
-#**author: Martin Sereinig
-#**notes: define myRobot kinematics, UR5 Universal Robotics, 
-#  Standard DH-parameters: [theta, d, a, alpha], according to P. Corke, 
-#  Links modeld as cylindrical tubes, Inertia from Parham M. Kebria2016 / Kuefeta2014
-def ManipulatorUR5():
-
-     
-    link0={'stdDH':[0,0.089459,0,np.pi/2], 
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':3.7,  #not needed!
-           'inertia':np.diag([84*1e-04,64*1e-04,84*1e-04]), #w.r.t. COM!
-           'jointStiffness':1000, # not set correctly yet
-           'jointTorqueMax': 150, # from datasheet
-           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
-           'COM':[0,-0.02561,0.00193]} #w.r.t. stdDH joint coordinatesystem
-    
-    link1={'stdDH':[0,0,-0.4250,0],
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':8.393, 
-           'inertia':np.diag([78*1e-04,21*1e-04,21*1e-04]), #w.r.t. COM!
-           'jointStiffness':1000, # not set correctly yet
-           'jointTorqueMax': 150, # from datasheet
-           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
-           'COM':[0.2125, 0, 0.11336]} #w.r.t. stdDH joint coordinatesystem
-    
-    link2={'stdDH':[0,0,-0.39225,0], 
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':2.33, 
-           'inertia':np.diag([16*1e-04,462*1e-04,462*1e-04]), #w.r.t. COM!
-           'jointStiffness':1000, # not set correctly yet
-           'jointTorqueMax': 150, # from datasheet
-           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
-           'COM':[0.150,0,0.02650]} #w.r.t. stdDH joint coordinatesystem
-    
-    link3={'stdDH':[0,0.10915,0,np.pi/2], 
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':1.2190, 
-           'inertia':np.diag([16*1e-04,16*1e-04,9*1e-04]), #w.r.t. COM!
-           'jointStiffness':1000, # not set correctly yet
-           'jointTorqueMax': 28, # from datasheet
-           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
-           'COM':[0,-0.00180,0.016340]} #w.r.t. stdDH joint coordinatesystem
-    
-    link4={'stdDH':[0,0.09465,0,-np.pi/2], 
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':1.2190, 
-           'inertia':np.diag([16*1e-04,16*1e-04,9*1e-04]), #w.r.t. COM!
-           'jointStiffness':1000, # not set correctly yet
-           'jointTorqueMax': 28, # from datasheet
-           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
-           'COM':[0,-0.00180,0.016340]} #w.r.t. stdDH joint coordinatesystem
-    
-    link5={'stdDH':[0,0.0823,0,0], 
-           'modDHKK':[0,0,0,0], # not set correctly yet
-           'mass':0.1897, 
-           'inertia':np.diag([1*1e-04,1*1e-04,1*1e-04]), #w.r.t. COM!
-           'jointStiffness':1000, # not set correctly yet
-           'jointTorqueMax': 28, # from datasheet
-           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
-           'COM':[0,0,-0.0011590]} #w.r.t. stdDH joint coordinatesystem
-    linkList=[link0, link1, link2, link3, link4, link5]
-    Tmax=[]
-    JointStiffness=[]
-    for link in linkList:
-         JointStiffness += [link['jointStiffness']]
-         Tmax += [link['jointTorqueMax']]    
-    #this is the global myRobot structure
-    myRobot={'links':[link0, link1, link2, link3, link4, link5],
-           'jointType':[1,1,1,1,1,1], #1=revolute, 0=prismatic
-           'jointStiffnessMatrix':   np.diag(JointStiffness),
-           'joinTorqueMaxMatrix':    np.diag(Tmax),
-           'base':{'HT':HTtranslate([0,0,0])},
-           'tool':{'HT':HTtranslate([0,0,0])},
-           'gravity':[0,0,-9.81],
-           'referenceConfiguration':[0]*6, #reference configuration for bodies; at which the myRobot is built
-           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
-           'Pcontrol': np.array([40000, 40000, 40000, 100, 100, 10]), #some assumed values, not taken from real robot
-           'Dcontrol': np.array([400,   400,   100,   1,   1,   0.1]),#some assumed values, not taken from real robot
-           } 
-    return myRobot
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate puma560 manipulator as myRobot dictionary, settings are done in function 
-#**output: myRobot dictionary
-#**author: Martin Sereinig
-#**notes: std DH-parameters: [theta, d, a, alpha], according to P. Corke page 138, 
-#       puma p560 limits, taken from Corke Visual Control of Robots 
-
-def ManipulatorPuma560():
-    link0={'stdDH':[0,0,0,np.pi/2], 
-           'modDHKK':[0,0,0,0],
-           'mass':20,  #not needed!
-           'inertia':np.diag([0,0.35,0]), #w.r.t. COM!
-           'jointStiffness':68000, # Values from literature described in KIM1995 Puma Joint Stiffness
-           'jointTorqueMax': 56,  # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
-           'jointLimits': [-np.pi, np.pi], # taken from Corke Visual Control of Robots 
-           'COM':[0,0,0]} # w.r.t. stdDH joint coordinatesystem
-    
-    link1={'stdDH':[0,0,0.4318,0],
-           'modDHKK':[np.pi/2,0,0,0.0],
-           'mass':17.4, 
-           'inertia':np.diag([0.13,0.524,0.539]), #w.r.t. COM!
-           'jointStiffness':66500,  # Values from literature described in KIM1995 Puma Joint Stiffness
-           'jointTorqueMax': 97, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
-           'jointLimits': [-2.9671, 2.8798], # taken from Corke Visual Control of Robots 
-           'COM':[-0.3638, 0.006, 0.2275]} # w.r.t. stdDH joint coordinatesystem
-    
-    link2={'stdDH':[0,0.15005,0.0203,-np.pi/2],
-           'modDHKK':[0,0.4318,0,0.15005],
-           'mass':4.8, 
-           'inertia':np.diag([0.066,0.086,0.0125]), #w.r.t. COM!
-           'jointStiffness':11650,  # Values from literature described in KIM1995 Puma Joint Stiffness
-           'jointTorqueMax': 52, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
-           'jointLimits': [-2.79253, 2.61799], # taken from Corke Visual Control of Robots 
-           'COM':[-0.0203,-0.0141,0.07]}     # .r.t. stdDH joint coordinatesystem
-
-    link3={'stdDH':[0,0.4318,0,np.pi/2],
-           'modDHKK':[-np.pi/2,0.0203,0,0.4318],
-           'mass':0.82, 
-           'inertia':np.diag([0.0018,0.0013,0.0018]), #w.r.t. COM!
-           'jointStiffness':2150,  # Values from literature described in KIM1995 Puma Joint Stiffness
-           'jointTorqueMax': 10, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
-           'jointLimits': [-np.pi, np.pi], # taken from Corke Visual Control of Robots 
-           'COM':[0,0.019,0]}# w.r.t. stdDH joint coordinatesystem
-    
-    link4={'stdDH':[0,0,0,-np.pi/2],
-           'modDHKK':[np.pi/2,0,0,0],
-           'mass':0.34, 
-           'inertia':np.diag([0.0003,0.0004,0.0003]), #w.r.t. COM!
-           'jointStiffness':1130,  # Values from literature described in KIM1995 Puma Joint Stiffness
-           'jointTorqueMax': 10, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
-           'jointLimits': [-0.17453, 1.74533], # taken from Corke Visual Control of Robots 
-           'COM':[0,0,0]}# w.r.t. stdDH joint coordinatesystem
-    
-    link5={'stdDH':[0,0,0,0], 
-           'modDHKK':[-np.pi/2,0,0,0],
-           'mass':0.09, 
-           'inertia':np.diag([0.00015,0.00015,4e-5]), #w.r.t. COM!
-           'jointStiffness':1680,  # Values from literature described in KIM1995 Puma Joint Stiffness
-           'jointTorqueMax': 10, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
-           'jointLimits': [-np.pi, np.pi], # taken from Corke Visual Control of Robots 
-           'COM':[0,0,0.032]} # w.r.t. stdDH joint coordinatesystem
-    linkList=[link0, link1, link2, link3, link4, link5]
-    Tmax=[]
-    JointStiffness=[]
-    for link in linkList:
-         JointStiffness += [link['jointStiffness']]
-         Tmax += [link['jointTorqueMax']]             
-
-
-    #this is the global myRobot structure
-    myRobot={'links':[link0, link1, link2, link3, link4, link5],
-           'jointType':[1,1,1,1,1,1], #1=revolute, 0=prismatic
-           'jointStiffnessMatrix':   np.diag(JointStiffness),
-           'joinTorqueMaxMatrix':    np.diag(Tmax),
-           'base':{'HT':HTtranslate([0,0,0])},
-           'tool':{'HT':HTtranslate([0,0,0])},
-           'gravity':[0,0,-9.81],
-           'referenceConfiguration':[0]*6, #reference configuration for bodies; at which the myRobot is built
-           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
-           'Pcontrol': np.array([40000, 40000, 40000, 100, 100, 10]), #some assumed values, not taken from real robot
-           'Dcontrol': np.array([400,   400,   100,   1,   1,   0.1]),#some assumed values, not taken from real robot
-           } 
-    return myRobot
-
-
-
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: generate serial manipulator as robotClass object from robotLinkDict
-#**input: 
-#  robotClass: robot class object from roboticsCore; if robotClass is provided, gravity, tool and base are used from there
-#  robotLinkDict: list of robot links generated by manipulator import for individual robot dictionary
-#**output: updated robot class
-#**author: Martin Sereinig
-#**notes: DH Parameter Information
-#  stdH = [theta, d, a, alpha] with Rz(theta) * Tz(d) * Tx(a) * Rx(alpha)
-#  modDH = [alpha, dx, theta, rz] with 
-#  used by Corke and Lynch: Rx(alpha) * Tx(a) * Rz(theta) * Tz(d)
-#  used by Khali:           Rx(alpha) * Tx(d) * Rz(theta) * Tz(r)
-#  Important note:  d(khali)=a(corke)  and r(khali)=d(corke)  
-def LinkDict2Robot(robotLinkDict, robotClass=None):
-    dhMode = robotLinkDict['dhMode']
-    
-    if robotClass == None:
-        gravity = [0,0,0]
-        if 'gravity' in robotLinkDict:
-            gravity = robotLinkDict['gravity']
-
-        robotClass=rob.Robot(gravity=gravity)
-
-        if 'base' in robotLinkDict:
-            robotClass.base = rob.RobotBase(HT=robotLinkDict['base']['HT'])
-        if 'tool' in robotLinkDict:
-            robotClass.tool = rob.RobotTool(HT=robotLinkDict['tool']['HT'])
-
-        if 'referenceConfiguration' in robotLinkDict:
-            robotClass.referenceConfiguration = robotLinkDict['referenceConfiguration']
-
-    if dhMode=='stdDH':
-        for i, link in enumerate(robotLinkDict['links']):
-            stdLocalHT =  rob.StdDH2HT(link['stdDH'])
-            com = HTtranslate(link['COM'])
-            PDcontrol = (None, None)
-            if 'Pcontrol' in robotLinkDict and 'Dcontrol' in robotLinkDict :
-                PDcontrol = (robotLinkDict['Pcontrol'][i], robotLinkDict['Dcontrol'][i])
-            
-            robotClass.AddLink(rob.RobotLink(mass=link['mass'], 
-                               COM=link['COM'], 
-                               inertia=link['inertia'], 
-                               localHT= rob.StdDH2HT(link['stdDH']), 
-                               PDcontrol = PDcontrol, 
-                               visualization=rob.VRobotLink(linkColor=gdu.color4list[i])
-                                ))
-    elif dhMode=='modDHKK':
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        raise ValueError('WARNING: LinkDict2Robot: untested for modDHKK')
-        #@Martin: #MS Todo!!
-        #  NEEDED: this branch should create the robot from modDHKK in case that inertia is defined according to
-        #          modDHKK (Panda)
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-    else:
-        raise ValueError('LinkDict2Robot: dhMode not set in robotLinkDict')
-    
-    return robotClass
-
-
-
-#**function: special test function to generate serial manipulator as robotClass object from robotLinkDict using inertia parameters defined in stdDH coordinates, but creating robot from modDHKK; will be ERASED in future
-#**input: 
-#  robotLinkDict: list of robot links generated by manipulator import for individual robot dictionary
-#  robotClass: robot class object from roboticsCore; if robotClass is provided, gravity, tool and base are used from there
-#**output: updated robot class
-#**author: Martin Sereinig
-#**notes: DEPRECATED; function uses modDHKK in robotLinkDict for creation, transforms inertia parameters; should only be used for testing!
-def LinkDictModDHKK2Robot(robotLinkDict, robotClass=None):
-    print('WARNING: LinkDictModDHKK2Robot: untested')
-    dhMode = robotLinkDict['dhMode']
-    
-    if robotClass == None:
-        gravity = [0,0,0]
-        if 'gravity' in robotLinkDict:
-            gravity = robotLinkDict['gravity']
-
-        robotClass=rob.Robot(gravity=gravity)
-
-        if 'base' in robotLinkDict:
-            robotClass.base = rob.RobotBase(HT=robotLinkDict['base'])
-        if 'tool' in robotLinkDict:
-            robotClass.tool = rob.RobotTool(HT=robotLinkDict['tool'])
-
-        if 'referenceConfiguration' in robotLinkDict:
-            robotClass.referenceConfiguration = robotLinkDict['referenceConfiguration']
-
-    if dhMode=='stdDH':
-
-        # puma with modified DH Parameter (craig)
-        for link in robotLinkDict['links']:
-            if 'modDHKK' not in link:
-                raise ValueError('LinkDictModDHKK2Robot: modDHKK not available')
-
-            [preHT, localHT] =  rob.ModDHKK2HT(link['modDHKK'])
-            stdLocalHT =  rob.StdDH2HT(link['stdDH'])
-            HT = InverseHT(stdLocalHT) @ (localHT) #from stdHT back and forward in localHT of ModDHKK
-            
-            rbi = RigidBodyInertia()
-            rbi.SetWithCOMinertia(link['mass'], link['inertia'], link['COM'])
-    
-            rbi = rbi.Transformed(InverseHT(HT)) #inertia parameters need to be transformed to new modDHKK link frame
-            
-            robotClass.AddLink(rob.RobotLink(mass=rbi.mass,
-                                           COM=rbi.COM(), 
-                                           inertia=rbi.InertiaCOM(),
-                                           preHT = preHT,
-                                           localHT=localHT,
-                                           ))
-
-            #old, Martin:
-            # [preHT, localHT] =  rob.ModDHKK2HT(link['modDHKK'])
-            # stdLocalHT =  rob.StdDH2HT(link['stdDH'])
-            # com = HTtranslate(link['COM'])
-            # comNew = InverseHT(localHT) @ (stdLocalHT) @ com
-            # Astd = HT2rotationMatrix(stdLocalHT)
-            # Amod = HT2rotationMatrix(localHT)
-            # A = Amod.T @ Astd #transforms from std to mod joint orientation
-            # J = link['inertia']
-            # Jmod = A.T @ J @ A
-            # robotClass.AddLink(rob.RobotLink(mass=link['mass'], 
-            #                            COM=HT2translation(comNew), 
-            #                            inertia=Jmod, 
-            #                            #preHT = preHT,
-            #                            preHT = preHT@localHT,
-            #                            #localHT=localHT,
-            #                            localHT=HT0(),
-            #                            ))
-    else:
-        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        raise ValueError('LinkDictModDHKK2Robot: dhMode not set in robotLinkDict')
-    
-    return robotClass
-
-
-#%%++++++++++++++++++++++++
-#testing of module models
-if __name__ == '__main__':
-
-    #imports
-    from exudyn.utilities import *
-    from exudyn.rigidBodyUtilities import *
-    from exudyn.graphicsDataUtilities import *
-    from exudyn.robotics import *   # to import  robotics core functions
-
-
-
-#MS Todo: write test for each model 
-
-
-
-
-
-
-
-
-
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is a submodule of the EXUDYN python robotics library
+#
+# Details:  This module contains robotics models; They can be imported by simply calling the functions,
+#           which return the according robot dictionary;
+#            the library is built on Denavit-Hartenberg Parameters and
+#            Homogeneous Transformations (HT) to describe transformations and coordinate systems
+#
+# Authors:   Martin Sereinig; Peter Manzl; Johannes Gerstmayr
+# Date:     2021-01-10
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+import exudyn.graphicsDataUtilities as gdu
+import exudyn.robotics as rob
+from exudyn.rigidBodyUtilities import HT2rotationMatrix, HT2translation, Skew, HTtranslate, InverseHT,\
+                                      HT0, HTrotateY, HTrotateX, RigidBodyInertia
+import scipy.io
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# DH Parameter Information:
+# stdH = [theta, d, a, alpha] with Rz(theta) * Tz(d) * Tx(a) * Rx(alpha)
+# modDH = [alpha, dx, theta, rz] with 
+# used by Corke and Lynch: Rx(alpha) * Tx(a) * Rz(theta) * Tz(d)
+# used by Khali:           Rx(alpha) * Tx(d) * Rz(theta) * Tz(r)
+# Important note:  d(khali)=a(corke)  and r(khali)=d(corke)  
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate 4R manipulator as myRobot dictionary, settings are done in function 
+#**output: myRobot dictionary
+#**author: Martin Sereinig
+#**notes: the 4th joint is used to simulate a paralell kinematics manipulator 
+def Manipulator4Rsimple():
+    inertiaLink0=np.array([ [  0.703370,   -0.0001390,    0.0067720],
+                            [ -0.000139,    0.7066100,    0.0192169],
+                            [  0.006772,    0.0192169,    0.0091170]  ])
+    
+    inertiaLink1=np.array([ [  0.007962,   -0.003925,    0.010254],
+                            [ -0.003925,    0.028110,    0.000704],
+                            [  0.010254,    0.000704,    0.025995]  ])
+    
+    inertiaLink2=np.array([ [  0.037242,   -0.004761,   -0.011396],
+                            [ -0.004761,    0.036155,   -0.012805],
+                            [ -0.011396,   -0.012805,    0.010830]  ])
+    
+    inertiaLink3=np.array([ [  0.025853,    0.007796,   -0.001332],
+                            [  0.007796,    0.019552,    0.008641],
+                            [ -0.001332,    0.008641,    0.028323]  ])
+    
+    link0={'stdDH':[0,0,0,np.pi/2*0],  
+           'modDHKK':[0,0,0,0],          
+            'mass':4,  
+            'inertia':inertiaLink0,         #w.r.t. COM!
+            'jointStiffness':70000,         # placeholder 
+            'jointTorqueMax': 50,           # placeholder 
+            'jointLimits': [-np.pi, np.pi], # placeholder 
+            'COM':[0,0,0]}                  #w.r.t. stdDH joint coordinatesystem
+    
+    link1={'stdDH':[0,0,0.25,0],   
+           'modDHKK':[-np.pi/2,0,0,0], 
+            'mass':1, 
+            'inertia':inertiaLink1, #w.r.t. COM!
+            'jointStiffness':70000,# placeholder 
+            'jointTorqueMax': 50,# placeholder 
+            'jointLimits': [-np.pi, np.pi],# placeholder Value
+            'COM':[0.25/2,0,0]} #w.r.t. stdDH joint coordinatesystem
+    
+    link2={'stdDH':[0,0,0.25,0],
+            'modDHKK':[0,0.25,0,0],            
+            'mass':1, 
+            'inertia':inertiaLink2, #w.r.t. COM!
+            'jointStiffness':70000, # placeholder 
+            'jointTorqueMax': 50, # placeholder 
+            'jointLimits': [-np.pi, np.pi], # placeholder 
+            'COM':[0.25/2,0,0]}  #w.r.t. stdDH joint coordinatesystem
+    
+    link3={'stdDH':[0,0,0,0],
+           'modDHKK':[0,0.25,0,0],         
+            'mass':1, 
+            'inertia':inertiaLink3, #w.r.t. COM!
+            'jointStiffness':70000, # placeholder 
+            'jointTorqueMax': 50, # placeholder 
+            'jointLimits': [-np.pi, np.pi],# placeholder value
+            'COM':[ 0,0,0]} #w.r.t. stdDH joint coordinatesystem
+    
+    
+    linkList=[link0, link1, link2]
+    Tmax=[]
+    JointStiffness=[]
+    for link in linkList:
+         JointStiffness += [link['jointStiffness']]
+         Tmax += [link['jointTorqueMax']]   
+    
+    #this is the global myRobot structure
+    myRobot={'links':linkList,
+           'jointType':[1,1,1], #1=revolute, 0=prismatic
+           'jointStiffnessMatrix':   np.diag(JointStiffness),
+           'joinTorqueMaxMatrix':    np.diag(Tmax),
+           'base':{'HT':HTtranslate([0,0,0])},
+           'tool':{'HT':HTtranslate([0,0,0]) @HTrotateX(np.pi/2)   @HTrotateY(np.pi/2)},
+           'gravity':[0,0,-9.81],
+           'referenceConfiguration':[0]*3, #reference configuration for bodies; at which the myRobot is built
+           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
+           'Pcontrol': np.array([1000, 1000, 100, 100,  ]), #UNTESTED; some assumed values, not taken from real robot
+           'Dcontrol': np.array([10,   10,   10,   10,   ]),#UNTESTED; some assumed values, not taken from real robot
+           } 
+
+    return myRobot
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate 3R manipulator as myRobot dictionary, settings are done in function 
+#**output: myRobot dictionary
+#**author: Martin Sereinig
+#**notes: DH-parameters: [theta, d, a, alpha], according to P. Corke
+#       Values according to Wörnle simple example with l1=0
+#       d=[h1 0 0];
+#       theta=[beta1 beta2 beta3];
+#       a=[l1 l2 l3];
+#       alpha=[pi/2 0 0];
+def Manipulator3RSimple():
+        
+    l1=0.0
+    l2=0.5
+    l3=0.5
+    
+    b1=0.1
+    b2=0.1
+    b3=0.1
+    
+    h1=0.5
+    
+    m1=3
+    m2=2
+    m3=1
+    A1=0.1
+    B1=0.2
+    C1=0.3
+    A2=0.5
+    B2=0.6
+    C2=0.7
+    A3=0.8
+    B3=0.9
+    C3=0.1
+
+
+    link0={'stdDH':[0,h1,l1*0,np.pi/2],    # here l1*0 to point out it is zero 
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':m1,  #not needed!
+           'inertia':np.diag([A1,B1,C1]), #w.r.t. COM!  
+           'jointStiffness':70000, #  placeholder 
+           'jointTorqueMax': 50, # placeholder
+           'jointLimits': [-np.pi, np.pi], # placeholder
+           'COM':[-l1,-(h1-b1),0]}    #w.r.t. stdDH joint coordinatesystem
+    
+    link1={'stdDH':  [0,0,l2,0 ],
+           'modDHKK':[-np.pi/2,0,0,0],    
+           'mass':m2, 
+           'inertia':np.diag([A2,B2,C2]), #w.r.t. COM!
+           'jointStiffness':60000, # placeholder
+           'jointTorqueMax': 90, # placeholder
+           'jointLimits': [-np.pi, np.pi], # placeholder
+           'COM':[-(l2-b2),0, 0]} #w.r.t. stdDH joint coordinatesystem
+    
+    link2={'stdDH':  [0,0,l3,0], 
+           'modDHKK':[0,l3,0,0],
+           'mass':m3, 
+           'inertia':np.diag([A3,B3,C3]), #w.r.t. COM!
+           'jointStiffness': 20000, # placeholder
+           'jointTorqueMax': 50,  # placeholder
+           'jointLimits': [-np.pi, np.pi], # placeholder
+           'COM':[-(l3-b3),0,0]} #w.r.t. stdDH joint coordinatesystem
+    
+    
+    linkList=[link0, link1, link2]
+    Tmax=[]
+    JointStiffness=[]
+    for link in linkList:
+         JointStiffness += [link['jointStiffness']]
+         Tmax += [link['jointTorqueMax']]   
+    
+    
+    #this is the global myRobot structure
+    myRobot={'links':linkList,
+           'jointType':[1,1,1], #1=revolute, 0=prismatic
+           'jointStiffnessMatrix':   np.diag(JointStiffness),
+           'joinTorqueMaxMatrix':    np.diag(Tmax),
+           'base':{'HT':HTtranslate([0,0,0])},
+           'tool':{'HT':HTtranslate([0,0,l3])},
+           'gravity':[0,0,-9.81],
+           'referenceConfiguration':[0]*3, #reference configuration for bodies; at which the myRobot is built
+           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
+           'Pcontrol': np.array([1000, 1000, 100,  ]), #UNTESTED; some assumed values, not taken from real robot
+           'Dcontrol': np.array([10,   10,   10,   ]), #UNTESTED; some assumed values, not taken from real robot
+           } 
+
+    return myRobot
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate Franka Emika Panda manipulator as myRobot dictionary, settings are done in function 
+#**output: myRobot dictionary
+#**author: Martin Sereinig
+#**notes:  all Parameter according to Gaz et. al \cite{GazDeLuca2019}
+#       DH-parameters(std): [theta, d, a, alpha], according to P. Corke
+#       Standard DH Parameters, masses, inertias and com according P.Corke and Gaz et. al (they working with modified DH parameter)
+#       changes to standard DH Parameter checked with P.Corke toolbox                             
+def ManipulatorPANDA():
+
+       
+    inertiaLink0=np.array([ [  0.703370,   -0.0001390,    0.0067720],
+                            [ -0.000139,    0.7066100,    0.0192169],
+                            [  0.006772,    0.0192169,    0.0091170]  ])
+    
+    inertiaLink1=np.array([ [  0.007962,   -0.003925,    0.010254],
+                            [ -0.003925,    0.028110,    0.000704],
+                            [  0.010254,    0.000704,    0.025995]  ])
+    
+    inertiaLink2=np.array([ [  0.037242,   -0.004761,   -0.011396],
+                            [ -0.004761,    0.036155,   -0.012805],
+                            [ -0.011396,   -0.012805,    0.010830]  ])
+    
+    inertiaLink3=np.array([ [  0.025853,    0.007796,   -0.001332],
+                            [  0.007796,    0.019552,    0.008641],
+                            [ -0.001332,    0.008641,    0.028323]  ])
+    
+    inertiaLink4=np.array([ [  0.035549,   -0.002117,   -0.004037],
+                            [ -0.002117,    0.029474,    0.000229],
+                            [ -0.004037,    0.000229,    0.008627]  ])
+    
+    inertiaLink5=np.array([ [  0.001964,    0.000109,   -0.001158],
+                            [  0.000109,    0.004354,    0.000341],
+                            [ -0.001158,    0.000341,    0.005433]  ])
+    
+    inertiaLink6=np.array([ [  0.012516,   -0.000428,   -0.001196],
+                            [ -0.000428,    0.010027,   -0.000741],
+                            [ -0.001196,   -0.000741,    0.004815]  ])
+    
+    stdDHparameter=([[0,      0.333,      0,                np.pi/2],
+                     [0,          0,      0,                -np.pi/2],
+                     [0,      0.316,      0.088,            np.pi/2],
+                     [0,      0,         -0.088,           -np.pi/2],
+                     [0,      0.384,      0,                np.pi/2],
+                     [0,      0,          0.088,            np.pi/2],
+                     [0,      0.107,      0,                   0]])
+    
+    torqueMax= [1,1,1,1,1,1,1]#some assumed values, not taken from real robot
+    stiffness= [1,1,1,1,1,1,1]#some assumed values, not taken from real robot
+
+    
+    link0={'stdDH':[0,0.333,0,np.pi/2], 
+           'modDHKK':[0,0,0,0.333],
+            'mass':4.970684,  #not needed!
+            'inertia':inertiaLink0, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 87, # from datasheet
+            'jointLimits': [-2.8973, 2.8973],   # from datasheet
+            'COM':[3.875e-03,2.081e-03,0]} #w.r.t. modDH joint coordinatesystem
+    
+    link1={'stdDH':[0,0,0,-np.pi/2],
+           'modDHKK':[-np.pi/2,0,0,0], 
+            'mass':0.646926, 
+            'inertia':inertiaLink1, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 87, # from datasheet
+            'jointLimits': [-1.7628,1.7628],  # from datasheet
+            'COM':[-3.141e-03,-2.872e-02,3.495e-03]} #w.r.t. modDH joint coordinatesystem
+    
+    link2={'stdDH':[0,0.316,0.088,np.pi/2], 
+           'modDHKK':[np.pi/2,0,0,0.316],
+            'mass':3.228604, 
+            'inertia':inertiaLink2, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 87, # not set correctly yet
+            'jointLimits': [-2.8973,2.8973], # from datasheet
+            'COM':[ 2.7518e-02,3.9252e-02,-6.6502e-02]} #w.r.t. modDH joint coordinatesystem
+    
+    link3={'stdDH':[0,0,-0.088,-np.pi/2], 
+           'modDHKK':[np.pi/2,0.0825,0,0],
+            'mass':3.587895, 
+            'inertia':inertiaLink3, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 87, # from datasheet
+            'jointLimits': [-3.0718,-0.0698], # from datasheet
+            'COM':[ -5.317e-02,1.04419e-01,2.7454e-02]} #w.r.t. modDH joint coordinatesystem
+    
+    link4={'stdDH':[0,0.384,0,np.pi/2], 
+           'modDHKK':[-np.pi/2,-0.0825,0,0.384],
+            'mass':1.225946, 
+            'inertia':inertiaLink4, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 12, # from datasheet
+            'jointLimits': [-2.8973,2.8973], # from datasheet
+            'COM':[-1.1953e-02,4.1065e-02,-3.8437e-02]} #w.r.t. modDH joint coordinatesystem
+    
+    link5={'stdDH':[0,0,0.088,np.pi/2], 
+           'modDHKK':[np.pi/2,0,0,0],
+            'mass':1.666555, 
+            'inertia':inertiaLink5, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 12, # from datasheet
+            'jointLimits': [-0.0175,3.7525], 
+            'COM':[6.0149e-02,-1.4117e-02,-1.0517e-02]} #w.r.t. modDH joint coordinatesystem
+    
+    link6={'stdDH':[0,0.107,0,0], 
+           'modDHKK':[np.pi/2,0.088,0,0.107],
+            'mass':0.735522, 
+            'inertia':inertiaLink6, #w.r.t. COM!
+            'jointStiffness':1, # not set correctly yet
+            'jointTorqueMax': 12, # from datasheet
+            'jointLimits': [-2.8973,2.8973], # from datasheet
+            'COM':[1.0517e-02,-4.252e-03,6.1597e-02]} #w.r.t. modDH joint coordinatesystem
+    massRobotArm=0
+    
+    linkList=[link0, link1, link2, link3, link4, link5, link6]
+    Tmax=[]
+    JointStiffness=[]
+    for link in linkList:
+         JointStiffness += [link['jointStiffness']]
+         Tmax += [link['jointTorqueMax']]    
+        
+    #this is the global myRobot structure
+    myRobot={'links':linkList,
+           'jointType':[1,1,1,1,1,1,1], #1=revolute, 0=prismatic
+           'jointStiffnessMatrix':   np.diag(JointStiffness),
+           'joinTorqueMaxMatrix':    np.diag(Tmax),
+           'base':{'HT':HTtranslate([0,0,0])},
+           'tool':{'HT':HTtranslate([0,0,0.11])},
+           'gravity':[0,0,-9.81],
+           'referenceConfiguration':[0]*7, #reference configuration for bodies; at which the myRobot is built
+           'dhMode':'modDHKK', #this mode prescribes the default DH mode to be used; 
+           'Pcontrol': np.array([40000, 40000, 40000, 100, 100, 100, 10]), #UNTESTED; some assumed values, not taken from real robot
+           'Dcontrol': np.array([400,   400,   100,   1,   1,   1,   0.1]),#UNTESTED; some assumed values, not taken from real robot
+           } 
+
+
+    return myRobot
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate UR5 manipulator as myRobot dictionary, settings are done in function 
+#**output: myRobot dictionary
+#**author: Martin Sereinig
+#**notes: define myRobot kinematics, UR5 Universal Robotics, 
+#  Standard DH-parameters: [theta, d, a, alpha], according to P. Corke, 
+#  Links modeld as cylindrical tubes, Inertia from Parham M. Kebria2016 / Kuefeta2014
+def ManipulatorUR5():
+
+     
+    link0={'stdDH':[0,0.089459,0,np.pi/2], 
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':3.7,  #not needed!
+           'inertia':np.diag([84*1e-04,64*1e-04,84*1e-04]), #w.r.t. COM!
+           'jointStiffness':1000, # not set correctly yet
+           'jointTorqueMax': 150, # from datasheet
+           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
+           'COM':[0,-0.02561,0.00193]} #w.r.t. stdDH joint coordinatesystem
+    
+    link1={'stdDH':[0,0,-0.4250,0],
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':8.393, 
+           'inertia':np.diag([78*1e-04,21*1e-04,21*1e-04]), #w.r.t. COM!
+           'jointStiffness':1000, # not set correctly yet
+           'jointTorqueMax': 150, # from datasheet
+           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
+           'COM':[0.2125, 0, 0.11336]} #w.r.t. stdDH joint coordinatesystem
+    
+    link2={'stdDH':[0,0,-0.39225,0], 
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':2.33, 
+           'inertia':np.diag([16*1e-04,462*1e-04,462*1e-04]), #w.r.t. COM!
+           'jointStiffness':1000, # not set correctly yet
+           'jointTorqueMax': 150, # from datasheet
+           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
+           'COM':[0.150,0,0.02650]} #w.r.t. stdDH joint coordinatesystem
+    
+    link3={'stdDH':[0,0.10915,0,np.pi/2], 
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':1.2190, 
+           'inertia':np.diag([16*1e-04,16*1e-04,9*1e-04]), #w.r.t. COM!
+           'jointStiffness':1000, # not set correctly yet
+           'jointTorqueMax': 28, # from datasheet
+           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
+           'COM':[0,-0.00180,0.016340]} #w.r.t. stdDH joint coordinatesystem
+    
+    link4={'stdDH':[0,0.09465,0,-np.pi/2], 
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':1.2190, 
+           'inertia':np.diag([16*1e-04,16*1e-04,9*1e-04]), #w.r.t. COM!
+           'jointStiffness':1000, # not set correctly yet
+           'jointTorqueMax': 28, # from datasheet
+           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
+           'COM':[0,-0.00180,0.016340]} #w.r.t. stdDH joint coordinatesystem
+    
+    link5={'stdDH':[0,0.0823,0,0], 
+           'modDHKK':[0,0,0,0], # not set correctly yet
+           'mass':0.1897, 
+           'inertia':np.diag([1*1e-04,1*1e-04,1*1e-04]), #w.r.t. COM!
+           'jointStiffness':1000, # not set correctly yet
+           'jointTorqueMax': 28, # from datasheet
+           'jointLimits': [-2*np.pi, 2*np.pi], # from datasheet
+           'COM':[0,0,-0.0011590]} #w.r.t. stdDH joint coordinatesystem
+    linkList=[link0, link1, link2, link3, link4, link5]
+    Tmax=[]
+    JointStiffness=[]
+    for link in linkList:
+         JointStiffness += [link['jointStiffness']]
+         Tmax += [link['jointTorqueMax']]    
+    #this is the global myRobot structure
+    myRobot={'links':[link0, link1, link2, link3, link4, link5],
+           'jointType':[1,1,1,1,1,1], #1=revolute, 0=prismatic
+           'jointStiffnessMatrix':   np.diag(JointStiffness),
+           'joinTorqueMaxMatrix':    np.diag(Tmax),
+           'base':{'HT':HTtranslate([0,0,0])},
+           'tool':{'HT':HTtranslate([0,0,0])},
+           'gravity':[0,0,-9.81],
+           'referenceConfiguration':[0]*6, #reference configuration for bodies; at which the myRobot is built
+           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
+           'Pcontrol': np.array([40000, 40000, 40000, 100, 100, 10]), #some assumed values, not taken from real robot
+           'Dcontrol': np.array([400,   400,   100,   1,   1,   0.1]),#some assumed values, not taken from real robot
+           } 
+    return myRobot
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate puma560 manipulator as myRobot dictionary, settings are done in function 
+#**output: myRobot dictionary
+#**author: Martin Sereinig
+#**notes: std DH-parameters: [theta, d, a, alpha], according to P. Corke page 138, 
+#       puma p560 limits, taken from Corke Visual Control of Robots 
+
+def ManipulatorPuma560():
+    link0={'stdDH':[0,0,0,np.pi/2], 
+           'modDHKK':[0,0,0,0],
+           'mass':20,  #not needed!
+           'inertia':np.diag([0,0.35,0]), #w.r.t. COM!
+           'jointStiffness':68000, # Values from literature described in KIM1995 Puma Joint Stiffness
+           'jointTorqueMax': 56,  # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
+           'jointLimits': [-np.pi, np.pi], # taken from Corke Visual Control of Robots 
+           'COM':[0,0,0]} # w.r.t. stdDH joint coordinatesystem
+    
+    link1={'stdDH':[0,0,0.4318,0],
+           'modDHKK':[np.pi/2,0,0,0.0],
+           'mass':17.4, 
+           'inertia':np.diag([0.13,0.524,0.539]), #w.r.t. COM!
+           'jointStiffness':66500,  # Values from literature described in KIM1995 Puma Joint Stiffness
+           'jointTorqueMax': 97, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
+           'jointLimits': [-2.9671, 2.8798], # taken from Corke Visual Control of Robots 
+           'COM':[-0.3638, 0.006, 0.2275]} # w.r.t. stdDH joint coordinatesystem
+    
+    link2={'stdDH':[0,0.15005,0.0203,-np.pi/2],
+           'modDHKK':[0,0.4318,0,0.15005],
+           'mass':4.8, 
+           'inertia':np.diag([0.066,0.086,0.0125]), #w.r.t. COM!
+           'jointStiffness':11650,  # Values from literature described in KIM1995 Puma Joint Stiffness
+           'jointTorqueMax': 52, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
+           'jointLimits': [-2.79253, 2.61799], # taken from Corke Visual Control of Robots 
+           'COM':[-0.0203,-0.0141,0.07]}     # .r.t. stdDH joint coordinatesystem
+
+    link3={'stdDH':[0,0.4318,0,np.pi/2],
+           'modDHKK':[-np.pi/2,0.0203,0,0.4318],
+           'mass':0.82, 
+           'inertia':np.diag([0.0018,0.0013,0.0018]), #w.r.t. COM!
+           'jointStiffness':2150,  # Values from literature described in KIM1995 Puma Joint Stiffness
+           'jointTorqueMax': 10, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
+           'jointLimits': [-np.pi, np.pi], # taken from Corke Visual Control of Robots 
+           'COM':[0,0.019,0]}# w.r.t. stdDH joint coordinatesystem
+    
+    link4={'stdDH':[0,0,0,-np.pi/2],
+           'modDHKK':[np.pi/2,0,0,0],
+           'mass':0.34, 
+           'inertia':np.diag([0.0003,0.0004,0.0003]), #w.r.t. COM!
+           'jointStiffness':1130,  # Values from literature described in KIM1995 Puma Joint Stiffness
+           'jointTorqueMax': 10, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
+           'jointLimits': [-0.17453, 1.74533], # taken from Corke Visual Control of Robots 
+           'COM':[0,0,0]}# w.r.t. stdDH joint coordinatesystem
+    
+    link5={'stdDH':[0,0,0,0], 
+           'modDHKK':[-np.pi/2,0,0,0],
+           'mass':0.09, 
+           'inertia':np.diag([0.00015,0.00015,4e-5]), #w.r.t. COM!
+           'jointStiffness':1680,  # Values from literature described in KIM1995 Puma Joint Stiffness
+           'jointTorqueMax': 10, # maximum joint torques Puma560, taken from taken from Corke Visual Control of Robots, p58 table2.21
+           'jointLimits': [-np.pi, np.pi], # taken from Corke Visual Control of Robots 
+           'COM':[0,0,0.032]} # w.r.t. stdDH joint coordinatesystem
+    linkList=[link0, link1, link2, link3, link4, link5]
+    Tmax=[]
+    JointStiffness=[]
+    for link in linkList:
+         JointStiffness += [link['jointStiffness']]
+         Tmax += [link['jointTorqueMax']]             
+
+
+    #this is the global myRobot structure
+    myRobot={'links':[link0, link1, link2, link3, link4, link5],
+           'jointType':[1,1,1,1,1,1], #1=revolute, 0=prismatic
+           'jointStiffnessMatrix':   np.diag(JointStiffness),
+           'joinTorqueMaxMatrix':    np.diag(Tmax),
+           'base':{'HT':HTtranslate([0,0,0])},
+           'tool':{'HT':HTtranslate([0,0,0])},
+           'gravity':[0,0,-9.81],
+           'referenceConfiguration':[0]*6, #reference configuration for bodies; at which the myRobot is built
+           'dhMode':'stdDH', #this mode prescribes the default DH mode to be used; 
+           'Pcontrol': np.array([40000, 40000, 40000, 100, 100, 10]), #some assumed values, not taken from real robot
+           'Dcontrol': np.array([400,   400,   100,   1,   1,   0.1]),#some assumed values, not taken from real robot
+           } 
+    return myRobot
+
+
+
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: generate serial manipulator as robotClass object from robotLinkDict
+#**input: 
+#  robotClass: robot class object from roboticsCore; if robotClass is provided, gravity, tool and base are used from there
+#  robotLinkDict: list of robot links generated by manipulator import for individual robot dictionary
+#**output: updated robot class
+#**author: Martin Sereinig
+#**notes: DH Parameter Information
+#  stdH = [theta, d, a, alpha] with Rz(theta) * Tz(d) * Tx(a) * Rx(alpha)
+#  modDH = [alpha, dx, theta, rz] with 
+#  used by Corke and Lynch: Rx(alpha) * Tx(a) * Rz(theta) * Tz(d)
+#  used by Khali:           Rx(alpha) * Tx(d) * Rz(theta) * Tz(r)
+#  Important note:  d(khali)=a(corke)  and r(khali)=d(corke)  
+def LinkDict2Robot(robotLinkDict, robotClass=None):
+    dhMode = robotLinkDict['dhMode']
+    
+    if robotClass == None:
+        gravity = [0,0,0]
+        if 'gravity' in robotLinkDict:
+            gravity = robotLinkDict['gravity']
+
+        robotClass=rob.Robot(gravity=gravity)
+
+        if 'base' in robotLinkDict:
+            robotClass.base = rob.RobotBase(HT=robotLinkDict['base']['HT'])
+        if 'tool' in robotLinkDict:
+            robotClass.tool = rob.RobotTool(HT=robotLinkDict['tool']['HT'])
+
+        if 'referenceConfiguration' in robotLinkDict:
+            robotClass.referenceConfiguration = robotLinkDict['referenceConfiguration']
+
+    if dhMode=='stdDH':
+        for i, link in enumerate(robotLinkDict['links']):
+            stdLocalHT =  rob.StdDH2HT(link['stdDH'])
+            com = HTtranslate(link['COM'])
+            PDcontrol = (None, None)
+            if 'Pcontrol' in robotLinkDict and 'Dcontrol' in robotLinkDict :
+                PDcontrol = (robotLinkDict['Pcontrol'][i], robotLinkDict['Dcontrol'][i])
+            
+            robotClass.AddLink(rob.RobotLink(mass=link['mass'], 
+                               COM=link['COM'], 
+                               inertia=link['inertia'], 
+                               localHT= rob.StdDH2HT(link['stdDH']), 
+                               PDcontrol = PDcontrol, 
+                               visualization=rob.VRobotLink(linkColor=gdu.color4list[i])
+                                ))
+    elif dhMode=='modDHKK':
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        raise ValueError('WARNING: LinkDict2Robot: untested for modDHKK')
+        #@Martin: #MS Todo!!
+        #  NEEDED: this branch should create the robot from modDHKK in case that inertia is defined according to
+        #          modDHKK (Panda)
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    else:
+        raise ValueError('LinkDict2Robot: dhMode not set in robotLinkDict')
+    
+    return robotClass
+
+
+
+#**function: special test function to generate serial manipulator as robotClass object from robotLinkDict using inertia parameters defined in stdDH coordinates, but creating robot from modDHKK; will be ERASED in future
+#**input: 
+#  robotLinkDict: list of robot links generated by manipulator import for individual robot dictionary
+#  robotClass: robot class object from roboticsCore; if robotClass is provided, gravity, tool and base are used from there
+#**output: updated robot class
+#**author: Martin Sereinig
+#**notes: DEPRECATED; function uses modDHKK in robotLinkDict for creation, transforms inertia parameters; should only be used for testing!
+def LinkDictModDHKK2Robot(robotLinkDict, robotClass=None):
+    print('WARNING: LinkDictModDHKK2Robot: untested')
+    dhMode = robotLinkDict['dhMode']
+    
+    if robotClass == None:
+        gravity = [0,0,0]
+        if 'gravity' in robotLinkDict:
+            gravity = robotLinkDict['gravity']
+
+        robotClass=rob.Robot(gravity=gravity)
+
+        if 'base' in robotLinkDict:
+            robotClass.base = rob.RobotBase(HT=robotLinkDict['base'])
+        if 'tool' in robotLinkDict:
+            robotClass.tool = rob.RobotTool(HT=robotLinkDict['tool'])
+
+        if 'referenceConfiguration' in robotLinkDict:
+            robotClass.referenceConfiguration = robotLinkDict['referenceConfiguration']
+
+    if dhMode=='stdDH':
+
+        # puma with modified DH Parameter (craig)
+        for link in robotLinkDict['links']:
+            if 'modDHKK' not in link:
+                raise ValueError('LinkDictModDHKK2Robot: modDHKK not available')
+
+            [preHT, localHT] =  rob.ModDHKK2HT(link['modDHKK'])
+            stdLocalHT =  rob.StdDH2HT(link['stdDH'])
+            HT = InverseHT(stdLocalHT) @ (localHT) #from stdHT back and forward in localHT of ModDHKK
+            
+            rbi = RigidBodyInertia()
+            rbi.SetWithCOMinertia(link['mass'], link['inertia'], link['COM'])
+    
+            rbi = rbi.Transformed(InverseHT(HT)) #inertia parameters need to be transformed to new modDHKK link frame
+            
+            robotClass.AddLink(rob.RobotLink(mass=rbi.mass,
+                                           COM=rbi.COM(), 
+                                           inertia=rbi.InertiaCOM(),
+                                           preHT = preHT,
+                                           localHT=localHT,
+                                           ))
+
+            #old, Martin:
+            # [preHT, localHT] =  rob.ModDHKK2HT(link['modDHKK'])
+            # stdLocalHT =  rob.StdDH2HT(link['stdDH'])
+            # com = HTtranslate(link['COM'])
+            # comNew = InverseHT(localHT) @ (stdLocalHT) @ com
+            # Astd = HT2rotationMatrix(stdLocalHT)
+            # Amod = HT2rotationMatrix(localHT)
+            # A = Amod.T @ Astd #transforms from std to mod joint orientation
+            # J = link['inertia']
+            # Jmod = A.T @ J @ A
+            # robotClass.AddLink(rob.RobotLink(mass=link['mass'], 
+            #                            COM=HT2translation(comNew), 
+            #                            inertia=Jmod, 
+            #                            #preHT = preHT,
+            #                            preHT = preHT@localHT,
+            #                            #localHT=localHT,
+            #                            localHT=HT0(),
+            #                            ))
+    else:
+        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        raise ValueError('LinkDictModDHKK2Robot: dhMode not set in robotLinkDict')
+    
+    return robotClass
+
+
+#%%++++++++++++++++++++++++
+#testing of module models
+if __name__ == '__main__':
+
+    #imports
+    from exudyn.utilities import *
+    from exudyn.rigidBodyUtilities import *
+    from exudyn.graphicsDataUtilities import *
+    from exudyn.robotics import *   # to import  robotics core functions
+
+
+
+#MS Todo: write test for each model 
+
+
+
+
+
+
+
+
+
+
+
+
+
```

## exudyn/robotics/motion.py

 * *Ordering differences only*

```diff
@@ -1,562 +1,562 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library for robotics
-#
-# Details:  functionality for motion including generation of trajectories with acceleration profiles,
-#           path planning and motion
-#
-# Author:   Johannes Gerstmayr
-# Date:     2022-02-16
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-#constants and fixed structures:
-import numpy as np
-
-from copy import copy, deepcopy
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#internal class, which stores information on PTP profiles
-#DO NOT USE this class, as it is an internal interface, which will be adapted significantly in future!
-class BasicProfile:
-    #
-    def __init__(self, coordinateSets, initialTime, finalTime,
-                 accelerationTimes, maxVelocities, maxAccelerations):
-        self.initialTime = initialTime
-        self.finalTime = finalTime
-        self.accelerationTimes = accelerationTimes
-        self.maxVelocities = maxVelocities
-        self.maxAccelerations = maxAccelerations
-        self.coordinateSets = []
-        self.coordinateSets += [np.array(coordinateSets[0],dtype=float)]
-        self.coordinateSets += [np.array(coordinateSets[1],dtype=float)]
-        self.distances = self.coordinateSets[1]-self.coordinateSets[0]
-    
-    #classFunction: iterator allows conversion into dict and easy inspection of data
-    def __iter__(self):
-        yield('initialTime',self.initialTime)
-        yield('finalTime',self.finalTime)
-        yield('accelerationTimes',self.accelerationTimes)
-        yield('maxVelocities',self.maxVelocities)
-        yield('maxAccelerations',self.maxAccelerations)
-        yield('coordinateSets',self.coordinateSets)
-        yield('distances',self.distances)
-
-    #classFunction: allow operator [] access as dictionary, allowing easy access to data via subclasses
-    def __getitem__(self, key):
-        return dict(self)[key]
-
-    #classFunction: representation of profile is given as dict string, allowing easy inspection of data
-    def __repr__(self):
-        return str(dict(self))
-    
-    #classFunction: return set of coordinates at start of profile
-    def GetInitialCoordinates(self):
-        return self.coordinateSets[0]
-
-    #classFunction: return set of coordinates at end of profile
-    def GetFinalCoordinates(self):
-        return self.coordinateSets[-1]
-
-    #classFunction: return interpolation of coordinates, velocities and accelerations at given time
-    #output: [s, v, a] as numpy arrays representing coordinates, velocities and accelerations
-    def Evaluate(self, time):
-        deltaT = self.finalTime - self.initialTime
-
-        s0 = copy(self.coordinateSets[0])
-        s = 0.*s0
-        v = 0.*s0
-        a = 0.*s0
-        sign = np.sign(self.distances)
-        
-        tAcc = self.accelerationTimes
-        vMax = self.maxVelocities
-        aMax = self.maxAccelerations
-        
-        t = time - self.initialTime
-        #needs for loop because of possible differene in tAcc for joints
-        for i in range(len(s)):
-            if t < 0:
-                s[i] = s0[i]
-            elif t < tAcc[i]:
-                s[i] = s0[i] + sign[i]*0.5*aMax[i]*(t*t)
-                v[i] = t*sign[i]*aMax[i]
-                a[i] = sign[i]*aMax[i]
-            elif t < deltaT-tAcc[i]:
-                #s = q0[joint] + vMax * t - 0.5*vMax**2/aMax
-                s[i] = s0[i] + sign[i]*(vMax[i] * (t-tAcc[i]) + 0.5*aMax[i]*(tAcc[i]**2))
-                v[i] = sign[i]*vMax[i]
-            elif t <= deltaT:
-                tv = deltaT-tAcc[i]
-                s[i] = s0[i] + sign[i]*(vMax[i]*tv - aMax[i]*0.5*(deltaT-t)**2)
-                v[i] = sign[i]*aMax[i]*(deltaT-t)
-                a[i] = -sign[i]*aMax[i]
-            else:
-                s[i] = self.coordinateSets[1][i]
-
-        return [s,v,a]
-    
-    #interpolate coordinates at time
-    def EvaluateCoordinate(self, time, coordinate):
-        deltaT = self.finalTime - self.initialTime
-
-        s = 0.
-        v = 0.
-        a = 0.
-
-        s0 = self.coordinateSets[0][coordinate]
-        sign = np.sign(self.distances[coordinate])
-        
-        tAcc = self.accelerationTimes[coordinate]
-        vMax = self.maxVelocities[coordinate]
-        aMax = self.maxAccelerations[coordinate]
-        
-        t = time - self.initialTime
-
-        if t < 0:
-            s = s0
-        elif t < tAcc:
-            s = s0 + sign*0.5*aMax*(t*t)
-            v = t*sign*aMax
-            a = sign*aMax
-        elif t < deltaT-tAcc:
-            s = s0 + sign*(vMax * (t-tAcc) + 0.5*aMax*(tAcc*tAcc))
-            v = sign*vMax
-        elif t <= deltaT:
-            tv = deltaT-tAcc
-            s = s0 + sign*(vMax*tv - aMax*0.5*(deltaT-t)**2)
-            v = sign*aMax*(deltaT-t)
-            a = -sign*aMax
-        else:
-            s = self.coordinateSets[1][coordinate]
-
-        return [s,v,a]
-    
-#**class: class to create a constant acceleration (optimal) PTP trajectory; trajectory ignores global max. velocities and accelerations
-#**input: 
-#  finalCoordinates: list or numpy array with final coordinates for profile
-#  duration: duration (time) for profile
-#**output: returns profile object, which is then used to compute interpolated trajectory
-class ProfileConstantAcceleration:
-    #**classFunction: initialize ProfileConstantAcceleration with vector of final coordinates and duration (time span)
-    def __init__(self, finalCoordinates, duration):
-        self.duration = duration
-        self.finalCoordinates = np.array(finalCoordinates,dtype=float)
-    
-    #**classFunction: return a class representing profile which is used in Trajectory
-    def GetBasicProfile(self, initialTime, initialCoordinates,
-                      globalMaxVelocities, globalMaxAccelerations):
-        if len(globalMaxVelocities)+len(globalMaxAccelerations) != 0:
-            print('WARNING: ProfileConstantAcceleration: max acceleration and velocities in Trajectory not applicable')
-        distances = self.finalCoordinates-initialCoordinates
-        aMax=abs(4.*distances/self.duration**2)
-        return BasicProfile(coordinateSets=[np.array(initialCoordinates,dtype=float),self.finalCoordinates],
-                          initialTime=initialTime, 
-                          finalTime=initialTime+self.duration,
-                          accelerationTimes=[0.5*self.duration]*len(aMax), 
-                          maxVelocities=abs(aMax * distances)**0.5,
-                          maxAccelerations=aMax)
-
-#**class: class to create a linear acceleration PTP profile, using a list of accelerations to define the profile; the (joint) coordinates and velocities are computed relative to values of previous profiles; ignores global max. accelerations and velocities of Trajectory
-#**input: 
-#  accelerationList: list of tuples (relativeTime, accelerationVector) in which relativeTime is the time relative to the start of the profile (first time must be zero!) and accelerationVector is the list of accelerations of this time point, which is then linearly interpolated
-#**output: returns profile object, which is then used to compute interpolated trajectory in class Trajectory
-#**example:
-#   profile = ProfileLinearAccelerationsList([(0,[0.,1.,2]), (0,[1.,1.,-2])])
-class ProfileLinearAccelerationsList:
-    #**classFunction: initialize ProfileLinearAccelerationsList with a list of tuples containing time and acceleration vector
-    def __init__(self, accelerationList):
-        self.accelerationList = accelerationList
-        
-        if len(accelerationList) < 2:
-            raise ValueError('ProfileLinearAccelerationsList (robotics.motion): profile needs at least two times and accelerations')
-        if accelerationList[0][0] != 0.:
-            raise ValueError('ProfileLinearAccelerationsList (robotics.motion): first time in acceleration profile needs to be zero!')
-            
-    
-    #**classFunction: return a class representing profile which is used in Trajectory
-    def GetBasicProfile(self, initialTime, initialCoordinates,
-                      globalMaxVelocities, globalMaxAccelerations):
-        if len(self.accelerationList[0][1]) != len(initialCoordinates):
-            raise ValueError('ProfileLinearAccelerationsList (robotics.motion): length of acceleration vectors are different from size of initialCoordinates!')
-        if len(globalMaxVelocities)+len(globalMaxAccelerations) != 0:
-            print('WARNING: ProfileLinearAccelerationsList: max acceleration and velocities in Trajectory not applicable')
-
-        return BasicProfileLinearAcceleration(initialCoordinates, initialTime, self.accelerationList)
-        
-#**class: class to create a synchronous motion PTP trajectory, using max. accelerations and max velocities; duration automatically computed
-#**input: 
-#  finalCoordinates: list or numpy array with final coordinates for profile
-#  maxVelocities: list or numpy array with maximum velocities; may be empty list []; used if smaller than globalMaxVelocities
-#  maxAccelerations: list or numpy array with maximum accelerations; may be empty list []; used if smaller than globalMaxAccelerations
-#**output: returns profile object, which is then used to compute interpolated trajectory
-class ProfilePTP:
-    #**classFunction: initialize ProfilePTP with final coordinates of motion, optionally max. velocities and accelerations just for this profile (overrides global settings)
-    def __init__(self, finalCoordinates, syncAccTimes=True, maxVelocities=[], maxAccelerations=[]):
-        self.finalCoordinates = np.array(finalCoordinates,dtype=float)
-        self.maxVelocities = np.array(maxVelocities,dtype=float)
-        self.maxAccelerations = np.array(maxAccelerations,dtype=float)
-        self.syncAccTimes = syncAccTimes
-        if min(list(maxVelocities)+[1]) <= 0:
-            raise ValueError('ProfilePTP: maxVelocities must by > 0')
-        if min(list(maxAccelerations)+[1]) <= 0:
-            raise ValueError('ProfilePTP: maxAccelerations must by > 0')
-        if syncAccTimes==True:
-            raise ValueError('ProfilePTP: syncAccTime must be False; other case yet not implemented')
-        
-    #**classFunction: return a class representing profile which is used in Trajectory
-    def GetBasicProfile(self, initialTime, initialCoordinates,
-                      globalMaxVelocities, globalMaxAccelerations):
-        
-        if len(globalMaxAccelerations)+len(self.maxAccelerations)==0:
-            raise ValueError('ProfilePTP: maxAccelerations must either in Trajectory or in ProfilePTP be non-empty')
-
-        sMax = self.finalCoordinates - initialCoordinates
-        
-        if len(globalMaxAccelerations) != 0:
-            if len(self.maxAccelerations) != 0:
-                aMax = np.minimum(globalMaxAccelerations,self.maxAccelerations)
-            else:
-                aMax = globalMaxAccelerations
-        else:
-            aMax = self.maxAccelerations
-
-        if min(aMax) == 0.:
-            raise ValueError('ProfilePTP: maxAccelerations may not be zero for any coordinate; check your trajectory')
-
-
-        vMax = np.sqrt(aMax*abs(sMax))
-        if len(globalMaxVelocities) != 0:
-            vMax = np.minimum(vMax, globalMaxVelocities)
-        if len(self.maxVelocities) != 0:
-            vMax = np.minimum(vMax, self.maxVelocities)
-        
-        #does not work in case that sMax[i]=0 ==> vMax[i]=0
-        #durations = abs(sMax)/vMax + vMax/aMax
-        durations = vMax/aMax
-        for i in range(len(durations)):
-            if vMax[i] != 0:
-                durations[i] = durations[i] + abs(sMax[i])/vMax[i]
-            elif sMax[i] != 0:
-                raise ValueError('ProfilePTP: maxVelocity may only be zero in case that distance is zero; check your trajectory')
-        
-        
-        maxDuration = max(durations)
-    
-        #solve quadratic equation for vMax of joint axis (may be vectorized?):
-        vMaxSync = copy(vMax)
-        tAccSync = 0.*vMaxSync
-
-        for joint in range(len(aMax)):
-            
-            b=-aMax[joint]*maxDuration
-            c=abs(sMax[joint])*aMax[joint]
-            det = b*b-4*c
-            if det < 0:
-                if det > -1e-10: #small round off, ignore because this is at max velocity
-                    det = 0
-                else:
-                    raise ValueError('SynchronousMotion: invalid parameters in trajectory: cannot resolve synchronous profile')
-            vMaxSync[joint] = min((-b-np.sqrt(det))*0.5, vMax[joint])
-            # aMaxSync[joint] = aMax[joint]
-            tAccSync[joint] = vMaxSync[joint]/aMax[joint]
-
-        return BasicProfile(coordinateSets=[np.array(initialCoordinates,dtype=float),self.finalCoordinates],
-                          initialTime=initialTime, 
-                          finalTime=initialTime+maxDuration,
-                          accelerationTimes=tAccSync, 
-                          maxVelocities=vMaxSync,
-                          maxAccelerations=aMax)
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**class: class to define (PTP) trajectories for robots and multibody systems; trajectories are defined for a set of coordinates (e.g. joint angles or other coordinates which need to be interpolated over time)
-#**example:
-##create simple trajectory for two joint coordinates:
-#traj = Trajectory(initialCoordinates=[1,1], initialTime=1)
-##add optimal trajectory with max. accelerations:
-#traj.Add(ProfileConstantAcceleration([2.,3.],2.))
-#traj.Add(ProfileConstantAcceleration([3.,-1.],2.))
-##add profile with limited velocities and accelerations:
-#traj.Add(ProfilePTP([1,1],syncAccTimes=False, maxVelocities=[1,1], maxAccelerations=[5,5]))
-##now evaluate trajectory at certain time point (this could be now applied in a user function)
-#[s,v,a] = traj.Evaluate(t=0.5)
-class Trajectory:
-    #**classFunction: initialize robot link with parameters, being self-explaining
-    #**input:
-    #  initialTime: initial time for initial coordinates
-    #  initialCoordinates: initial coordinates for profile
-    #  maxVelocities: list or numpy array to describe global maximum velocities per coordinate
-    #  maxAccelerations: list or numpy array to describe global maximum accelerations per coordinate
-    def __init__(self, initialCoordinates, initialTime = 0, maxVelocities=[], maxAccelerations=[]):
-        self.initialTime = initialTime
-        self.initialCoordinates = initialCoordinates
-        self.globalMaxVelocities = maxVelocities
-        self.globalMaxAccelerations = maxAccelerations
-
-        self.profiles = []
-        self.initialized = False #this marks that the trajectory has been changed and is not initialized
-        self.timesList = []
-        if min(list(maxVelocities)+[1]) <= 0:
-            raise ValueError('Trajectory: maxVelocities must by > 0')
-        if min(list(maxAccelerations)+[1]) <= 0:
-            raise ValueError('Trajectory: maxAccelerations must by > 0')
-
-    #**classFunction: returns the coordinates at the end of the (currently) Final profile
-    def GetFinalCoordinates(self):
-        if len(self.profiles) == 0:
-            return self.initialCoordinates
-        else:
-            return self.profiles[-1].GetFinalCoordinates()
-
-
-    #**classFunction: add successively profiles, using MotionProfile class
-    def Add(self, profile):
-        self.initialized = False
-        ptp = profile.GetBasicProfile(self.GetTimes()[-1], self.GetFinalCoordinates(),
-                                    self.globalMaxVelocities,self.globalMaxAccelerations)
-        self.profiles+=[ptp]
-
-    #**classFunction: return vector of times of start/end of profiles
-    def GetTimes(self):
-        timesList = [self.initialTime]
-        for profile in self.profiles:
-            timesList+=[profile.finalTime]
-        return timesList
-
-    #**classFunction: initialize some parameters for faster evaluation
-    def Initialize(self):
-        self.timesList = self.GetTimes();
-        self.initialized = True
-
-    #**classFunction: return interpolation of trajectory for coordinates, velocities and accelerations at given time
-    #**output: [s, v, a] as numpy arrays representing coordinates, velocities and accelerations
-    def Evaluate(self, t):
-        if not self.initialized: self.Initialize()
-
-        cnt = 0
-        while cnt < len(self.timesList) and t > self.timesList[cnt]:
-            cnt += 1
-        
-        if cnt > 0 and cnt < len(self.timesList):
-            return self.profiles[cnt-1].Evaluate(t)
-        elif cnt == 0:
-            u0 = self.profiles[0].GetInitialCoordinates()
-            n = len(u0)
-            return [u0, np.zeros(n), np.zeros(n)] 
-        else:
-            uL = self.profiles[-1].GetFinalCoordinates()
-            n = len(uL)
-            return [uL, np.zeros(n), np.zeros(n)]
-
-    #**classFunction: return interpolation of trajectory for coordinate, including velocity and acceleration coordinate at given time
-    #**output: [s, v, a] being scalar position, velocity and acceleration
-    #**notes: faster for single coordinate than Evaluate(...)
-    def EvaluateCoordinate(self, t, coordinate):
-        if not self.initialized: 
-            self.Initialize()
-
-        cnt = 0
-        while cnt < len(self.timesList) and t > self.timesList[cnt]:
-            cnt += 1
-        
-        if cnt > 0 and cnt < len(self.timesList):
-            return self.profiles[cnt-1].EvaluateCoordinate(t, coordinate)
-        elif cnt == 0:
-            return [self.profiles[0].GetInitialCoordinates()[coordinate], 0., 0.]
-        else:
-            return [self.profiles[-1].GetFinalCoordinates()[coordinate], 0., 0.]
-
-    #**classFunction: iterator allows to use for x in trajectory: ... constructs
-    def __iter__(self):
-        return iter(self.profiles)
-
-    #**classFunction: access to profiles via operator [], allowing trajectory[0], etc.
-    def __getitem__(self, key):
-        return self.profiles[key]
-
-    #**classFunction: allow using len(trajectory)
-    def __len__(self):
-        return len(self.profiles)
-
-
-    #**classFunction: representation of Trajectory is given a list of profiles, allowing easy inspection of data
-    def __repr__(self):
-        return str(self.profiles)
-
-    # slower version:
-    # def EvaluateCoordinate(self, t, coordinate):
-    # [s,v,a] = self.Evaluate(t)
-    # return [s[coordinate], v[coordinate], a[coordinate]]
-            
-
-# #Example:
-# traj = Trajectory(initialCoordinates=[1,1], initialTime=1)
-# traj.Add(ProfileConstantAcceleration([2.,3.],2.))
-# traj.Add(ProfileConstantAcceleration([3.,-1.],2.))
-# traj.Add(ProfilePTP([1,1],syncAccTimes=False, maxVelocities=[1,1], maxAccelerations=[5,5]))
-
-# n=200*2
-# vals=np.zeros((n,3+2+2))
-# for i in range(n):
-#     t=i/n*12
-#     vals[i,0] = t
-#     [s,v,a] = traj.Evaluate(t)
-#     vals[i,1:3] = s
-#     vals[i,3:5] = v
-#     vals[i,5:7] = a
-
-
-# import matplotlib.pyplot as plt
-# plt.close('all')
-# plt.figure('pos')
-# plt.plot(vals[:,0],vals[:,1],'r-')
-# plt.plot(vals[:,0],vals[:,2],'b-')
-# plt.figure('vel')
-# plt.plot(vals[:,0],vals[:,3],'r-')
-# plt.plot(vals[:,0],vals[:,4],'b-')
-# plt.figure('acc')
-# plt.plot(vals[:,0],vals[:,5],'r-')
-# plt.plot(vals[:,0],vals[:,6],'b-')
-# plt.show()
-
-#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#internal class, which stores information on PTP profiles with linear accelerations
-#DO NOT USE this class, as it is an internal interface, which will be adapted significantly in future!
-#provides initialCoordinates of profile, initial time and list of tuples with (tOffset, acceleration), in which tOffset is relative to initial time and acceleration is the current value of acceleration, linearly interpolated
-class BasicProfileLinearAcceleration:
-    #
-    def __init__(self, initialCoordinates, initialTime, 
-                 accelerationList):
-        self.initialTime = initialTime
-        self.accelerationList= accelerationList
-
-        self.coordinateSets = [np.array(initialCoordinates,dtype=float)]
-        self.coordinateSets_t = [0.*np.array(initialCoordinates,dtype=float)] #zero velocities at beginning
-
-        self.Initialize() #computes according missing values
-
-        # #to be computed:
-        # self.finalTime
-        # self.coordinateSets
-        # self.coordinateSets_t
-        # self.distances = self.coordinateSets[1]-self.coordinateSets[0]
-
-        #not available:
-        # self.maxVelocities = maxVelocities
-        # self.maxAccelerations = maxAccelerations
-
-    #classFunction: initialize profile, finalTime, final coordinates and distances
-    def Initialize(self):
-        nAcc = len(self.accelerationList)
-        if nAcc < 2:
-            raise ValueError('BasicProfileLinearAcceleration (robotics.motion): profile needs at least two times and accelerations')
-        
-        pos0 = copy(self.coordinateSets[0])
-        vel0 = copy(self.coordinateSets_t[0])
-        tSpan = 0.
-        
-        lenAcc = len(self.accelerationList[0][1])
-        #update position and velocity of profile points, using quadratic velocity and cubic position trajectory
-        for i in range(nAcc-1):
-            accTime0 = self.accelerationList[i]
-            accTime1 = self.accelerationList[i+1]
-            t0 = accTime0[0]
-            if i == 0 and t0 != 0.:
-                raise ValueError('BasicProfileLinearAcceleration (robotics.motion): first time in acceleration profile needs to be zero!')
-            acc0 = np.array(accTime0[1],dtype=float)
-            t1 = accTime1[0]
-            acc1 = np.array(accTime1[1],dtype=float)
-            if len(acc1) != lenAcc:
-                raise ValueError('BasicProfileLinearAcceleration (robotics.motion): acceleration vectors seem to be inconsistent; check, if all acceleration vectors have same length!')
-            dt = t1-t0
-            if dt == 0.:
-                raise ValueError('BasicProfileLinearAcceleration (robotics.motion): duration of single acceleration profiles must not be zero!')
-            tSpan += dt
-            
-            deltaPos = vel0*dt + (0.5*dt*dt)*acc0 + (dt**2/6.)*(acc1-acc0)
-            deltaVel = dt*acc0 + (dt*0.5)*(-acc0 + acc1)
-            
-            pos0 += deltaPos 
-            vel0 += deltaVel
-        
-            self.coordinateSets += [copy(pos0)]
-            self.coordinateSets_t += [copy(vel0)] #zero velocities at beginning
-
-        #to be computed:
-        self.finalTime = self.initialTime + tSpan
-        self.distances = self.coordinateSets[-1]-self.coordinateSets[0]
-    
-    #classFunction: iterator allows conversion into dict and easy inspection of data
-    def __iter__(self):
-        yield('initialTime',self.initialTime)
-        yield('accelerationList',self.accelerationList)
-        yield('finalTime',self.finalTime)
-        yield('coordinateSets',self.coordinateSets)
-        yield('coordinateSets_t',self.coordinateSets_t)
-        yield('distances',self.distances)
-
-    #classFunction: allow operator [] access as dictionary, allowing easy access to data via subclasses
-    def __getitem__(self, key):
-        return dict(self)[key]
-
-    #classFunction: representation of profile is given as dict string, allowing easy inspection of data
-    def __repr__(self):
-        return str(dict(self))
-    
-    #classFunction: return set of coordinates at start of profile
-    def GetInitialCoordinates(self):
-        return self.coordinateSets[0]
-
-    #classFunction: return set of coordinates at end of profile
-    def GetFinalCoordinates(self):
-        return self.coordinateSets[-1]
-
-    #classFunction: return interpolation of positions, velocities and accelerations at given time
-    #output: [s, v, a] as numpy arrays representing coordinates, velocities and accelerations
-    def Evaluate(self, time):
-
-        nAcc = len(self.accelerationList)
-        
-        t = time-self.initialTime
-        
-        if time < self.initialTime:
-            return [self.coordinateSets[0], self.coordinateSets_t[0], self.accelerationList[0][1]]
-        if time > self.finalTime:
-            return [self.coordinateSets[-1], self.coordinateSets_t[-1], self.accelerationList[-1][1]]
-
-        for i in range(nAcc-1):
-            accTime1 = self.accelerationList[i+1]
-            t1 = accTime1[0]
-            if t > t1: #search for according interval
-                continue
-
-            accTime0 = self.accelerationList[i]
-            t0 = accTime0[0]
-            pos0 = self.coordinateSets[i]
-            vel0 = self.coordinateSets_t[i]
-            acc0 = np.array(accTime0[1],dtype=float)
-            acc1 = np.array(accTime1[1],dtype=float)
-
-            dt = t1-t0
-            tRel = time - (self.initialTime + t0) #relative time within sub-interval with linear acceleration (acc0,acc1)
-            
-            posAct = pos0 + 0.5*(tRel*tRel)*acc0 + tRel*vel0 + (tRel**3/(6.*dt))*(acc1-acc0)
-            velAct = vel0 + tRel*acc0 + (tRel*tRel)*(acc1-acc0)/(2.*dt)
-            accAct = acc0 + (tRel/dt)*(acc1-acc0)
-
-            return [posAct, velAct, accAct]
-    
-    #classFunction: return interpolation of chosen (joint) position, velocity and acceleration at given time, joint coordinate/axis=coordinate
-    #output: [s, v, a] as scalar values representing position, velocity and acceleration
-    def EvaluateCoordinate(self, time, coordinate):
-        [posAct, velAct, accAct] = self.Evaluate(time)
-        return [posAct[coordinate], velAct[coordinate], accAct[coordinate]]
-    
-
-
-
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library for robotics
+#
+# Details:  functionality for motion including generation of trajectories with acceleration profiles,
+#           path planning and motion
+#
+# Author:   Johannes Gerstmayr
+# Date:     2022-02-16
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#constants and fixed structures:
+import numpy as np
+
+from copy import copy, deepcopy
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#internal class, which stores information on PTP profiles
+#DO NOT USE this class, as it is an internal interface, which will be adapted significantly in future!
+class BasicProfile:
+    #
+    def __init__(self, coordinateSets, initialTime, finalTime,
+                 accelerationTimes, maxVelocities, maxAccelerations):
+        self.initialTime = initialTime
+        self.finalTime = finalTime
+        self.accelerationTimes = accelerationTimes
+        self.maxVelocities = maxVelocities
+        self.maxAccelerations = maxAccelerations
+        self.coordinateSets = []
+        self.coordinateSets += [np.array(coordinateSets[0],dtype=float)]
+        self.coordinateSets += [np.array(coordinateSets[1],dtype=float)]
+        self.distances = self.coordinateSets[1]-self.coordinateSets[0]
+    
+    #classFunction: iterator allows conversion into dict and easy inspection of data
+    def __iter__(self):
+        yield('initialTime',self.initialTime)
+        yield('finalTime',self.finalTime)
+        yield('accelerationTimes',self.accelerationTimes)
+        yield('maxVelocities',self.maxVelocities)
+        yield('maxAccelerations',self.maxAccelerations)
+        yield('coordinateSets',self.coordinateSets)
+        yield('distances',self.distances)
+
+    #classFunction: allow operator [] access as dictionary, allowing easy access to data via subclasses
+    def __getitem__(self, key):
+        return dict(self)[key]
+
+    #classFunction: representation of profile is given as dict string, allowing easy inspection of data
+    def __repr__(self):
+        return str(dict(self))
+    
+    #classFunction: return set of coordinates at start of profile
+    def GetInitialCoordinates(self):
+        return self.coordinateSets[0]
+
+    #classFunction: return set of coordinates at end of profile
+    def GetFinalCoordinates(self):
+        return self.coordinateSets[-1]
+
+    #classFunction: return interpolation of coordinates, velocities and accelerations at given time
+    #output: [s, v, a] as numpy arrays representing coordinates, velocities and accelerations
+    def Evaluate(self, time):
+        deltaT = self.finalTime - self.initialTime
+
+        s0 = copy(self.coordinateSets[0])
+        s = 0.*s0
+        v = 0.*s0
+        a = 0.*s0
+        sign = np.sign(self.distances)
+        
+        tAcc = self.accelerationTimes
+        vMax = self.maxVelocities
+        aMax = self.maxAccelerations
+        
+        t = time - self.initialTime
+        #needs for loop because of possible differene in tAcc for joints
+        for i in range(len(s)):
+            if t < 0:
+                s[i] = s0[i]
+            elif t < tAcc[i]:
+                s[i] = s0[i] + sign[i]*0.5*aMax[i]*(t*t)
+                v[i] = t*sign[i]*aMax[i]
+                a[i] = sign[i]*aMax[i]
+            elif t < deltaT-tAcc[i]:
+                #s = q0[joint] + vMax * t - 0.5*vMax**2/aMax
+                s[i] = s0[i] + sign[i]*(vMax[i] * (t-tAcc[i]) + 0.5*aMax[i]*(tAcc[i]**2))
+                v[i] = sign[i]*vMax[i]
+            elif t <= deltaT:
+                tv = deltaT-tAcc[i]
+                s[i] = s0[i] + sign[i]*(vMax[i]*tv - aMax[i]*0.5*(deltaT-t)**2)
+                v[i] = sign[i]*aMax[i]*(deltaT-t)
+                a[i] = -sign[i]*aMax[i]
+            else:
+                s[i] = self.coordinateSets[1][i]
+
+        return [s,v,a]
+    
+    #interpolate coordinates at time
+    def EvaluateCoordinate(self, time, coordinate):
+        deltaT = self.finalTime - self.initialTime
+
+        s = 0.
+        v = 0.
+        a = 0.
+
+        s0 = self.coordinateSets[0][coordinate]
+        sign = np.sign(self.distances[coordinate])
+        
+        tAcc = self.accelerationTimes[coordinate]
+        vMax = self.maxVelocities[coordinate]
+        aMax = self.maxAccelerations[coordinate]
+        
+        t = time - self.initialTime
+
+        if t < 0:
+            s = s0
+        elif t < tAcc:
+            s = s0 + sign*0.5*aMax*(t*t)
+            v = t*sign*aMax
+            a = sign*aMax
+        elif t < deltaT-tAcc:
+            s = s0 + sign*(vMax * (t-tAcc) + 0.5*aMax*(tAcc*tAcc))
+            v = sign*vMax
+        elif t <= deltaT:
+            tv = deltaT-tAcc
+            s = s0 + sign*(vMax*tv - aMax*0.5*(deltaT-t)**2)
+            v = sign*aMax*(deltaT-t)
+            a = -sign*aMax
+        else:
+            s = self.coordinateSets[1][coordinate]
+
+        return [s,v,a]
+    
+#**class: class to create a constant acceleration (optimal) PTP trajectory; trajectory ignores global max. velocities and accelerations
+#**input: 
+#  finalCoordinates: list or numpy array with final coordinates for profile
+#  duration: duration (time) for profile
+#**output: returns profile object, which is then used to compute interpolated trajectory
+class ProfileConstantAcceleration:
+    #**classFunction: initialize ProfileConstantAcceleration with vector of final coordinates and duration (time span)
+    def __init__(self, finalCoordinates, duration):
+        self.duration = duration
+        self.finalCoordinates = np.array(finalCoordinates,dtype=float)
+    
+    #**classFunction: return a class representing profile which is used in Trajectory
+    def GetBasicProfile(self, initialTime, initialCoordinates,
+                      globalMaxVelocities, globalMaxAccelerations):
+        if len(globalMaxVelocities)+len(globalMaxAccelerations) != 0:
+            print('WARNING: ProfileConstantAcceleration: max acceleration and velocities in Trajectory not applicable')
+        distances = self.finalCoordinates-initialCoordinates
+        aMax=abs(4.*distances/self.duration**2)
+        return BasicProfile(coordinateSets=[np.array(initialCoordinates,dtype=float),self.finalCoordinates],
+                          initialTime=initialTime, 
+                          finalTime=initialTime+self.duration,
+                          accelerationTimes=[0.5*self.duration]*len(aMax), 
+                          maxVelocities=abs(aMax * distances)**0.5,
+                          maxAccelerations=aMax)
+
+#**class: class to create a linear acceleration PTP profile, using a list of accelerations to define the profile; the (joint) coordinates and velocities are computed relative to values of previous profiles; ignores global max. accelerations and velocities of Trajectory
+#**input: 
+#  accelerationList: list of tuples (relativeTime, accelerationVector) in which relativeTime is the time relative to the start of the profile (first time must be zero!) and accelerationVector is the list of accelerations of this time point, which is then linearly interpolated
+#**output: returns profile object, which is then used to compute interpolated trajectory in class Trajectory
+#**example:
+#   profile = ProfileLinearAccelerationsList([(0,[0.,1.,2]), (0,[1.,1.,-2])])
+class ProfileLinearAccelerationsList:
+    #**classFunction: initialize ProfileLinearAccelerationsList with a list of tuples containing time and acceleration vector
+    def __init__(self, accelerationList):
+        self.accelerationList = accelerationList
+        
+        if len(accelerationList) < 2:
+            raise ValueError('ProfileLinearAccelerationsList (robotics.motion): profile needs at least two times and accelerations')
+        if accelerationList[0][0] != 0.:
+            raise ValueError('ProfileLinearAccelerationsList (robotics.motion): first time in acceleration profile needs to be zero!')
+            
+    
+    #**classFunction: return a class representing profile which is used in Trajectory
+    def GetBasicProfile(self, initialTime, initialCoordinates,
+                      globalMaxVelocities, globalMaxAccelerations):
+        if len(self.accelerationList[0][1]) != len(initialCoordinates):
+            raise ValueError('ProfileLinearAccelerationsList (robotics.motion): length of acceleration vectors are different from size of initialCoordinates!')
+        if len(globalMaxVelocities)+len(globalMaxAccelerations) != 0:
+            print('WARNING: ProfileLinearAccelerationsList: max acceleration and velocities in Trajectory not applicable')
+
+        return BasicProfileLinearAcceleration(initialCoordinates, initialTime, self.accelerationList)
+        
+#**class: class to create a synchronous motion PTP trajectory, using max. accelerations and max velocities; duration automatically computed
+#**input: 
+#  finalCoordinates: list or numpy array with final coordinates for profile
+#  maxVelocities: list or numpy array with maximum velocities; may be empty list []; used if smaller than globalMaxVelocities
+#  maxAccelerations: list or numpy array with maximum accelerations; may be empty list []; used if smaller than globalMaxAccelerations
+#**output: returns profile object, which is then used to compute interpolated trajectory
+class ProfilePTP:
+    #**classFunction: initialize ProfilePTP with final coordinates of motion, optionally max. velocities and accelerations just for this profile (overrides global settings)
+    def __init__(self, finalCoordinates, syncAccTimes=True, maxVelocities=[], maxAccelerations=[]):
+        self.finalCoordinates = np.array(finalCoordinates,dtype=float)
+        self.maxVelocities = np.array(maxVelocities,dtype=float)
+        self.maxAccelerations = np.array(maxAccelerations,dtype=float)
+        self.syncAccTimes = syncAccTimes
+        if min(list(maxVelocities)+[1]) <= 0:
+            raise ValueError('ProfilePTP: maxVelocities must by > 0')
+        if min(list(maxAccelerations)+[1]) <= 0:
+            raise ValueError('ProfilePTP: maxAccelerations must by > 0')
+        if syncAccTimes==True:
+            raise ValueError('ProfilePTP: syncAccTime must be False; other case yet not implemented')
+        
+    #**classFunction: return a class representing profile which is used in Trajectory
+    def GetBasicProfile(self, initialTime, initialCoordinates,
+                      globalMaxVelocities, globalMaxAccelerations):
+        
+        if len(globalMaxAccelerations)+len(self.maxAccelerations)==0:
+            raise ValueError('ProfilePTP: maxAccelerations must either in Trajectory or in ProfilePTP be non-empty')
+
+        sMax = self.finalCoordinates - initialCoordinates
+        
+        if len(globalMaxAccelerations) != 0:
+            if len(self.maxAccelerations) != 0:
+                aMax = np.minimum(globalMaxAccelerations,self.maxAccelerations)
+            else:
+                aMax = globalMaxAccelerations
+        else:
+            aMax = self.maxAccelerations
+
+        if min(aMax) == 0.:
+            raise ValueError('ProfilePTP: maxAccelerations may not be zero for any coordinate; check your trajectory')
+
+
+        vMax = np.sqrt(aMax*abs(sMax))
+        if len(globalMaxVelocities) != 0:
+            vMax = np.minimum(vMax, globalMaxVelocities)
+        if len(self.maxVelocities) != 0:
+            vMax = np.minimum(vMax, self.maxVelocities)
+        
+        #does not work in case that sMax[i]=0 ==> vMax[i]=0
+        #durations = abs(sMax)/vMax + vMax/aMax
+        durations = vMax/aMax
+        for i in range(len(durations)):
+            if vMax[i] != 0:
+                durations[i] = durations[i] + abs(sMax[i])/vMax[i]
+            elif sMax[i] != 0:
+                raise ValueError('ProfilePTP: maxVelocity may only be zero in case that distance is zero; check your trajectory')
+        
+        
+        maxDuration = max(durations)
+    
+        #solve quadratic equation for vMax of joint axis (may be vectorized?):
+        vMaxSync = copy(vMax)
+        tAccSync = 0.*vMaxSync
+
+        for joint in range(len(aMax)):
+            
+            b=-aMax[joint]*maxDuration
+            c=abs(sMax[joint])*aMax[joint]
+            det = b*b-4*c
+            if det < 0:
+                if det > -1e-10: #small round off, ignore because this is at max velocity
+                    det = 0
+                else:
+                    raise ValueError('SynchronousMotion: invalid parameters in trajectory: cannot resolve synchronous profile')
+            vMaxSync[joint] = min((-b-np.sqrt(det))*0.5, vMax[joint])
+            # aMaxSync[joint] = aMax[joint]
+            tAccSync[joint] = vMaxSync[joint]/aMax[joint]
+
+        return BasicProfile(coordinateSets=[np.array(initialCoordinates,dtype=float),self.finalCoordinates],
+                          initialTime=initialTime, 
+                          finalTime=initialTime+maxDuration,
+                          accelerationTimes=tAccSync, 
+                          maxVelocities=vMaxSync,
+                          maxAccelerations=aMax)
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**class: class to define (PTP) trajectories for robots and multibody systems; trajectories are defined for a set of coordinates (e.g. joint angles or other coordinates which need to be interpolated over time)
+#**example:
+##create simple trajectory for two joint coordinates:
+#traj = Trajectory(initialCoordinates=[1,1], initialTime=1)
+##add optimal trajectory with max. accelerations:
+#traj.Add(ProfileConstantAcceleration([2.,3.],2.))
+#traj.Add(ProfileConstantAcceleration([3.,-1.],2.))
+##add profile with limited velocities and accelerations:
+#traj.Add(ProfilePTP([1,1],syncAccTimes=False, maxVelocities=[1,1], maxAccelerations=[5,5]))
+##now evaluate trajectory at certain time point (this could be now applied in a user function)
+#[s,v,a] = traj.Evaluate(t=0.5)
+class Trajectory:
+    #**classFunction: initialize robot link with parameters, being self-explaining
+    #**input:
+    #  initialTime: initial time for initial coordinates
+    #  initialCoordinates: initial coordinates for profile
+    #  maxVelocities: list or numpy array to describe global maximum velocities per coordinate
+    #  maxAccelerations: list or numpy array to describe global maximum accelerations per coordinate
+    def __init__(self, initialCoordinates, initialTime = 0, maxVelocities=[], maxAccelerations=[]):
+        self.initialTime = initialTime
+        self.initialCoordinates = initialCoordinates
+        self.globalMaxVelocities = maxVelocities
+        self.globalMaxAccelerations = maxAccelerations
+
+        self.profiles = []
+        self.initialized = False #this marks that the trajectory has been changed and is not initialized
+        self.timesList = []
+        if min(list(maxVelocities)+[1]) <= 0:
+            raise ValueError('Trajectory: maxVelocities must by > 0')
+        if min(list(maxAccelerations)+[1]) <= 0:
+            raise ValueError('Trajectory: maxAccelerations must by > 0')
+
+    #**classFunction: returns the coordinates at the end of the (currently) Final profile
+    def GetFinalCoordinates(self):
+        if len(self.profiles) == 0:
+            return self.initialCoordinates
+        else:
+            return self.profiles[-1].GetFinalCoordinates()
+
+
+    #**classFunction: add successively profiles, using MotionProfile class
+    def Add(self, profile):
+        self.initialized = False
+        ptp = profile.GetBasicProfile(self.GetTimes()[-1], self.GetFinalCoordinates(),
+                                    self.globalMaxVelocities,self.globalMaxAccelerations)
+        self.profiles+=[ptp]
+
+    #**classFunction: return vector of times of start/end of profiles
+    def GetTimes(self):
+        timesList = [self.initialTime]
+        for profile in self.profiles:
+            timesList+=[profile.finalTime]
+        return timesList
+
+    #**classFunction: initialize some parameters for faster evaluation
+    def Initialize(self):
+        self.timesList = self.GetTimes();
+        self.initialized = True
+
+    #**classFunction: return interpolation of trajectory for coordinates, velocities and accelerations at given time
+    #**output: [s, v, a] as numpy arrays representing coordinates, velocities and accelerations
+    def Evaluate(self, t):
+        if not self.initialized: self.Initialize()
+
+        cnt = 0
+        while cnt < len(self.timesList) and t > self.timesList[cnt]:
+            cnt += 1
+        
+        if cnt > 0 and cnt < len(self.timesList):
+            return self.profiles[cnt-1].Evaluate(t)
+        elif cnt == 0:
+            u0 = self.profiles[0].GetInitialCoordinates()
+            n = len(u0)
+            return [u0, np.zeros(n), np.zeros(n)] 
+        else:
+            uL = self.profiles[-1].GetFinalCoordinates()
+            n = len(uL)
+            return [uL, np.zeros(n), np.zeros(n)]
+
+    #**classFunction: return interpolation of trajectory for coordinate, including velocity and acceleration coordinate at given time
+    #**output: [s, v, a] being scalar position, velocity and acceleration
+    #**notes: faster for single coordinate than Evaluate(...)
+    def EvaluateCoordinate(self, t, coordinate):
+        if not self.initialized: 
+            self.Initialize()
+
+        cnt = 0
+        while cnt < len(self.timesList) and t > self.timesList[cnt]:
+            cnt += 1
+        
+        if cnt > 0 and cnt < len(self.timesList):
+            return self.profiles[cnt-1].EvaluateCoordinate(t, coordinate)
+        elif cnt == 0:
+            return [self.profiles[0].GetInitialCoordinates()[coordinate], 0., 0.]
+        else:
+            return [self.profiles[-1].GetFinalCoordinates()[coordinate], 0., 0.]
+
+    #**classFunction: iterator allows to use for x in trajectory: ... constructs
+    def __iter__(self):
+        return iter(self.profiles)
+
+    #**classFunction: access to profiles via operator [], allowing trajectory[0], etc.
+    def __getitem__(self, key):
+        return self.profiles[key]
+
+    #**classFunction: allow using len(trajectory)
+    def __len__(self):
+        return len(self.profiles)
+
+
+    #**classFunction: representation of Trajectory is given a list of profiles, allowing easy inspection of data
+    def __repr__(self):
+        return str(self.profiles)
+
+    # slower version:
+    # def EvaluateCoordinate(self, t, coordinate):
+    # [s,v,a] = self.Evaluate(t)
+    # return [s[coordinate], v[coordinate], a[coordinate]]
+            
+
+# #Example:
+# traj = Trajectory(initialCoordinates=[1,1], initialTime=1)
+# traj.Add(ProfileConstantAcceleration([2.,3.],2.))
+# traj.Add(ProfileConstantAcceleration([3.,-1.],2.))
+# traj.Add(ProfilePTP([1,1],syncAccTimes=False, maxVelocities=[1,1], maxAccelerations=[5,5]))
+
+# n=200*2
+# vals=np.zeros((n,3+2+2))
+# for i in range(n):
+#     t=i/n*12
+#     vals[i,0] = t
+#     [s,v,a] = traj.Evaluate(t)
+#     vals[i,1:3] = s
+#     vals[i,3:5] = v
+#     vals[i,5:7] = a
+
+
+# import matplotlib.pyplot as plt
+# plt.close('all')
+# plt.figure('pos')
+# plt.plot(vals[:,0],vals[:,1],'r-')
+# plt.plot(vals[:,0],vals[:,2],'b-')
+# plt.figure('vel')
+# plt.plot(vals[:,0],vals[:,3],'r-')
+# plt.plot(vals[:,0],vals[:,4],'b-')
+# plt.figure('acc')
+# plt.plot(vals[:,0],vals[:,5],'r-')
+# plt.plot(vals[:,0],vals[:,6],'b-')
+# plt.show()
+
+#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#internal class, which stores information on PTP profiles with linear accelerations
+#DO NOT USE this class, as it is an internal interface, which will be adapted significantly in future!
+#provides initialCoordinates of profile, initial time and list of tuples with (tOffset, acceleration), in which tOffset is relative to initial time and acceleration is the current value of acceleration, linearly interpolated
+class BasicProfileLinearAcceleration:
+    #
+    def __init__(self, initialCoordinates, initialTime, 
+                 accelerationList):
+        self.initialTime = initialTime
+        self.accelerationList= accelerationList
+
+        self.coordinateSets = [np.array(initialCoordinates,dtype=float)]
+        self.coordinateSets_t = [0.*np.array(initialCoordinates,dtype=float)] #zero velocities at beginning
+
+        self.Initialize() #computes according missing values
+
+        # #to be computed:
+        # self.finalTime
+        # self.coordinateSets
+        # self.coordinateSets_t
+        # self.distances = self.coordinateSets[1]-self.coordinateSets[0]
+
+        #not available:
+        # self.maxVelocities = maxVelocities
+        # self.maxAccelerations = maxAccelerations
+
+    #classFunction: initialize profile, finalTime, final coordinates and distances
+    def Initialize(self):
+        nAcc = len(self.accelerationList)
+        if nAcc < 2:
+            raise ValueError('BasicProfileLinearAcceleration (robotics.motion): profile needs at least two times and accelerations')
+        
+        pos0 = copy(self.coordinateSets[0])
+        vel0 = copy(self.coordinateSets_t[0])
+        tSpan = 0.
+        
+        lenAcc = len(self.accelerationList[0][1])
+        #update position and velocity of profile points, using quadratic velocity and cubic position trajectory
+        for i in range(nAcc-1):
+            accTime0 = self.accelerationList[i]
+            accTime1 = self.accelerationList[i+1]
+            t0 = accTime0[0]
+            if i == 0 and t0 != 0.:
+                raise ValueError('BasicProfileLinearAcceleration (robotics.motion): first time in acceleration profile needs to be zero!')
+            acc0 = np.array(accTime0[1],dtype=float)
+            t1 = accTime1[0]
+            acc1 = np.array(accTime1[1],dtype=float)
+            if len(acc1) != lenAcc:
+                raise ValueError('BasicProfileLinearAcceleration (robotics.motion): acceleration vectors seem to be inconsistent; check, if all acceleration vectors have same length!')
+            dt = t1-t0
+            if dt == 0.:
+                raise ValueError('BasicProfileLinearAcceleration (robotics.motion): duration of single acceleration profiles must not be zero!')
+            tSpan += dt
+            
+            deltaPos = vel0*dt + (0.5*dt*dt)*acc0 + (dt**2/6.)*(acc1-acc0)
+            deltaVel = dt*acc0 + (dt*0.5)*(-acc0 + acc1)
+            
+            pos0 += deltaPos 
+            vel0 += deltaVel
+        
+            self.coordinateSets += [copy(pos0)]
+            self.coordinateSets_t += [copy(vel0)] #zero velocities at beginning
+
+        #to be computed:
+        self.finalTime = self.initialTime + tSpan
+        self.distances = self.coordinateSets[-1]-self.coordinateSets[0]
+    
+    #classFunction: iterator allows conversion into dict and easy inspection of data
+    def __iter__(self):
+        yield('initialTime',self.initialTime)
+        yield('accelerationList',self.accelerationList)
+        yield('finalTime',self.finalTime)
+        yield('coordinateSets',self.coordinateSets)
+        yield('coordinateSets_t',self.coordinateSets_t)
+        yield('distances',self.distances)
+
+    #classFunction: allow operator [] access as dictionary, allowing easy access to data via subclasses
+    def __getitem__(self, key):
+        return dict(self)[key]
+
+    #classFunction: representation of profile is given as dict string, allowing easy inspection of data
+    def __repr__(self):
+        return str(dict(self))
+    
+    #classFunction: return set of coordinates at start of profile
+    def GetInitialCoordinates(self):
+        return self.coordinateSets[0]
+
+    #classFunction: return set of coordinates at end of profile
+    def GetFinalCoordinates(self):
+        return self.coordinateSets[-1]
+
+    #classFunction: return interpolation of positions, velocities and accelerations at given time
+    #output: [s, v, a] as numpy arrays representing coordinates, velocities and accelerations
+    def Evaluate(self, time):
+
+        nAcc = len(self.accelerationList)
+        
+        t = time-self.initialTime
+        
+        if time < self.initialTime:
+            return [self.coordinateSets[0], self.coordinateSets_t[0], self.accelerationList[0][1]]
+        if time > self.finalTime:
+            return [self.coordinateSets[-1], self.coordinateSets_t[-1], self.accelerationList[-1][1]]
+
+        for i in range(nAcc-1):
+            accTime1 = self.accelerationList[i+1]
+            t1 = accTime1[0]
+            if t > t1: #search for according interval
+                continue
+
+            accTime0 = self.accelerationList[i]
+            t0 = accTime0[0]
+            pos0 = self.coordinateSets[i]
+            vel0 = self.coordinateSets_t[i]
+            acc0 = np.array(accTime0[1],dtype=float)
+            acc1 = np.array(accTime1[1],dtype=float)
+
+            dt = t1-t0
+            tRel = time - (self.initialTime + t0) #relative time within sub-interval with linear acceleration (acc0,acc1)
+            
+            posAct = pos0 + 0.5*(tRel*tRel)*acc0 + tRel*vel0 + (tRel**3/(6.*dt))*(acc1-acc0)
+            velAct = vel0 + tRel*acc0 + (tRel*tRel)*(acc1-acc0)/(2.*dt)
+            accAct = acc0 + (tRel/dt)*(acc1-acc0)
+
+            return [posAct, velAct, accAct]
+    
+    #classFunction: return interpolation of chosen (joint) position, velocity and acceleration at given time, joint coordinate/axis=coordinate
+    #output: [s, v, a] as scalar values representing position, velocity and acceleration
+    def EvaluateCoordinate(self, time, coordinate):
+        [posAct, velAct, accAct] = self.Evaluate(time)
+        return [posAct[coordinate], velAct[coordinate], accAct[coordinate]]
+    
+
+
+
+
+
+
+
```

## exudyn/robotics/roboticsCore.py

```diff
@@ -1,6138 +1,6022 @@
 00000000: 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  #+++++++++++++++
 00000010: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000020: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000030: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00000040: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0d0a  ++++++++++++++..
-00000050: 2320 5468 6973 2069 7320 616e 2045 5855  # This is an EXU
-00000060: 4459 4e20 7079 7468 6f6e 2075 7469 6c69  DYN python utili
-00000070: 7479 206c 6962 7261 7279 2066 6f72 2072  ty library for r
-00000080: 6f62 6f74 6963 730d 0a23 0d0a 2320 4465  obotics..#..# De
-00000090: 7461 696c 733a 2020 4120 6c69 6272 6172  tails:  A librar
-000000a0: 7920 7768 6963 6820 696e 636c 7564 6573  y which includes
-000000b0: 2073 7570 706f 7274 2066 756e 6374 696f   support functio
-000000c0: 6e73 2066 6f72 2072 6f62 6f74 6963 733b  ns for robotics;
-000000d0: 0d0a 2320 2020 2020 2020 2020 2020 7468  ..#           th
-000000e0: 6520 6c69 6272 6172 7920 6973 2062 7569  e library is bui
-000000f0: 6c74 206f 6e20 7374 616e 6461 7264 2044  lt on standard D
-00000100: 656e 6176 6974 2d48 6172 7465 6e62 6572  enavit-Hartenber
-00000110: 6720 5061 7261 6d65 7465 7273 2061 6e64  g Parameters and
-00000120: 0d0a 2320 2020 2020 2020 2020 2020 486f  ..#           Ho
-00000130: 6d6f 6765 6e65 6f75 7320 5472 616e 7366  mogeneous Transf
-00000140: 6f72 6d61 7469 6f6e 7320 2848 5429 2074  ormations (HT) t
-00000150: 6f20 6465 7363 7269 6265 2074 7261 6e73  o describe trans
-00000160: 666f 726d 6174 696f 6e73 2061 6e64 2063  formations and c
-00000170: 6f6f 7264 696e 6174 6520 7379 7374 656d  oordinate system
-00000180: 733b 0d0a 2320 2020 2020 2020 2020 2020  s;..#           
-00000190: 696d 706f 7274 2074 6869 7320 6c69 6272  import this libr
-000001a0: 6172 7920 652e 672e 2077 6974 6820 696d  ary e.g. with im
-000001b0: 706f 7274 2065 7875 6479 6e2e 726f 626f  port exudyn.robo
-000001c0: 7469 6373 2061 7320 726f 626f 7469 6373  tics as robotics
-000001d0: 0d0a 230d 0a23 2041 7574 686f 723a 2020  ..#..# Author:  
-000001e0: 204a 6f68 616e 6e65 7320 4765 7273 746d   Johannes Gerstm
-000001f0: 6179 720d 0a23 2044 6174 653a 2020 2020  ayr..# Date:    
-00000200: 2032 3032 302d 3034 2d31 340d 0a23 0d0a   2020-04-14..#..
-00000210: 2320 436f 7079 7269 6768 743a 5468 6973  # Copyright:This
-00000220: 2066 696c 6520 6973 2070 6172 7420 6f66   file is part of
-00000230: 2045 7875 6479 6e2e 2045 7875 6479 6e20   Exudyn. Exudyn 
-00000240: 6973 2066 7265 6520 736f 6674 7761 7265  is free software
-00000250: 2e20 596f 7520 6361 6e20 7265 6469 7374  . You can redist
-00000260: 7269 6275 7465 2069 7420 616e 642f 6f72  ribute it and/or
-00000270: 206d 6f64 6966 7920 6974 2075 6e64 6572   modify it under
-00000280: 2074 6865 2074 6572 6d73 206f 6620 7468   the terms of th
-00000290: 6520 4578 7564 796e 206c 6963 656e 7365  e Exudyn license
-000002a0: 2e20 5365 6520 274c 4943 454e 5345 2e74  . See 'LICENSE.t
-000002b0: 7874 2720 666f 7220 6d6f 7265 2064 6574  xt' for more det
-000002c0: 6169 6c73 2e0d 0a23 0d0a 2320 4578 616d  ails...#..# Exam
-000002d0: 706c 653a 2020 2020 4e65 7720 726f 626f  ple:    New robo
-000002e0: 7420 6d6f 6465 6c20 7573 6573 2074 6865  t model uses the
-000002f0: 2063 6c61 7373 2052 6f62 6f74 2077 6974   class Robot wit
-00000300: 6820 636c 6173 7320 526f 626f 744c 696e  h class RobotLin
-00000310: 6b3b 2074 6865 206f 6c64 2064 6963 7469  k; the old dicti
-00000320: 6f6e 6172 7920 7374 7275 6374 7572 6520  onary structure 
-00000330: 6973 2064 6566 696e 6564 2069 6e20 7468  is defined in th
-00000340: 6520 6578 616d 706c 6520 696e 2043 6f6d  e example in Com
-00000350: 7075 7465 4a6f 696e 7448 5420 666f 7220  puteJointHT for 
-00000360: 7468 6520 6465 6669 6e69 7469 6f6e 206f  the definition o
-00000370: 6620 7468 6520 2772 6f62 6f74 2720 6469  f the 'robot' di
-00000380: 6374 696f 6e61 7279 2e0d 0a23 0d0a 232b  ctionary...#..#+
+00000040: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0a23  ++++++++++++++.#
+00000050: 2054 6869 7320 6973 2061 6e20 4558 5544   This is an EXUD
+00000060: 594e 2070 7974 686f 6e20 7574 696c 6974  YN python utilit
+00000070: 7920 6c69 6272 6172 7920 666f 7220 726f  y library for ro
+00000080: 626f 7469 6373 0a23 0a23 2044 6574 6169  botics.#.# Detai
+00000090: 6c73 3a20 2041 206c 6962 7261 7279 2077  ls:  A library w
+000000a0: 6869 6368 2069 6e63 6c75 6465 7320 7375  hich includes su
+000000b0: 7070 6f72 7420 6675 6e63 7469 6f6e 7320  pport functions 
+000000c0: 666f 7220 726f 626f 7469 6373 3b0a 2320  for robotics;.# 
+000000d0: 2020 2020 2020 2020 2020 7468 6520 6c69            the li
+000000e0: 6272 6172 7920 6973 2062 7569 6c74 206f  brary is built o
+000000f0: 6e20 7374 616e 6461 7264 2044 656e 6176  n standard Denav
+00000100: 6974 2d48 6172 7465 6e62 6572 6720 5061  it-Hartenberg Pa
+00000110: 7261 6d65 7465 7273 2061 6e64 0a23 2020  rameters and.#  
+00000120: 2020 2020 2020 2020 2048 6f6d 6f67 656e           Homogen
+00000130: 656f 7573 2054 7261 6e73 666f 726d 6174  eous Transformat
+00000140: 696f 6e73 2028 4854 2920 746f 2064 6573  ions (HT) to des
+00000150: 6372 6962 6520 7472 616e 7366 6f72 6d61  cribe transforma
+00000160: 7469 6f6e 7320 616e 6420 636f 6f72 6469  tions and coordi
+00000170: 6e61 7465 2073 7973 7465 6d73 3b0a 2320  nate systems;.# 
+00000180: 2020 2020 2020 2020 2020 696d 706f 7274            import
+00000190: 2074 6869 7320 6c69 6272 6172 7920 652e   this library e.
+000001a0: 672e 2077 6974 6820 696d 706f 7274 2065  g. with import e
+000001b0: 7875 6479 6e2e 726f 626f 7469 6373 2061  xudyn.robotics a
+000001c0: 7320 726f 626f 7469 6373 0a23 0a23 2041  s robotics.#.# A
+000001d0: 7574 686f 723a 2020 204a 6f68 616e 6e65  uthor:   Johanne
+000001e0: 7320 4765 7273 746d 6179 720a 2320 4461  s Gerstmayr.# Da
+000001f0: 7465 3a20 2020 2020 3230 3230 2d30 342d  te:     2020-04-
+00000200: 3134 0a23 0a23 2043 6f70 7972 6967 6874  14.#.# Copyright
+00000210: 3a54 6869 7320 6669 6c65 2069 7320 7061  :This file is pa
+00000220: 7274 206f 6620 4578 7564 796e 2e20 4578  rt of Exudyn. Ex
+00000230: 7564 796e 2069 7320 6672 6565 2073 6f66  udyn is free sof
+00000240: 7477 6172 652e 2059 6f75 2063 616e 2072  tware. You can r
+00000250: 6564 6973 7472 6962 7574 6520 6974 2061  edistribute it a
+00000260: 6e64 2f6f 7220 6d6f 6469 6679 2069 7420  nd/or modify it 
+00000270: 756e 6465 7220 7468 6520 7465 726d 7320  under the terms 
+00000280: 6f66 2074 6865 2045 7875 6479 6e20 6c69  of the Exudyn li
+00000290: 6365 6e73 652e 2053 6565 2027 4c49 4345  cense. See 'LICE
+000002a0: 4e53 452e 7478 7427 2066 6f72 206d 6f72  NSE.txt' for mor
+000002b0: 6520 6465 7461 696c 732e 0a23 0a23 2045  e details..#.# E
+000002c0: 7861 6d70 6c65 3a20 2020 204e 6577 2072  xample:    New r
+000002d0: 6f62 6f74 206d 6f64 656c 2075 7365 7320  obot model uses 
+000002e0: 7468 6520 636c 6173 7320 526f 626f 7420  the class Robot 
+000002f0: 7769 7468 2063 6c61 7373 2052 6f62 6f74  with class Robot
+00000300: 4c69 6e6b 3b20 7468 6520 6f6c 6420 6469  Link; the old di
+00000310: 6374 696f 6e61 7279 2073 7472 7563 7475  ctionary structu
+00000320: 7265 2069 7320 6465 6669 6e65 6420 696e  re is defined in
+00000330: 2074 6865 2065 7861 6d70 6c65 2069 6e20   the example in 
+00000340: 436f 6d70 7574 654a 6f69 6e74 4854 2066  ComputeJointHT f
+00000350: 6f72 2074 6865 2064 6566 696e 6974 696f  or the definitio
+00000360: 6e20 6f66 2074 6865 2027 726f 626f 7427  n of the 'robot'
+00000370: 2064 6963 7469 6f6e 6172 792e 0a23 0a23   dictionary..#.#
+00000380: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000390: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 000003a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 000003b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000003c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000003d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0d0a 0d0a  ++++++++++++....
-000003e0: 2363 6f6e 7374 616e 7473 2061 6e64 2066  #constants and f
-000003f0: 6978 6564 2073 7472 7563 7475 7265 733a  ixed structures:
-00000400: 0d0a 696d 706f 7274 206e 756d 7079 2061  ..import numpy a
-00000410: 7320 6e70 0d0a 0d0a 696d 706f 7274 2065  s np....import e
-00000420: 7875 6479 6e0d 0a0d 0a69 6d70 6f72 7420  xudyn....import 
-00000430: 6578 7564 796e 2e69 7465 6d49 6e74 6572  exudyn.itemInter
-00000440: 6661 6365 2061 7320 6569 690d 0a69 6d70  face as eii..imp
-00000450: 6f72 7420 6578 7564 796e 2e62 6173 6963  ort exudyn.basic
-00000460: 5574 696c 6974 6965 7320 6173 2065 6275  Utilities as ebu
-00000470: 0d0a 696d 706f 7274 2065 7875 6479 6e2e  ..import exudyn.
-00000480: 6164 7661 6e63 6564 5574 696c 6974 6965  advancedUtilitie
-00000490: 7320 6173 2065 6175 0d0a 0d0a 2369 6d70  s as eau....#imp
-000004a0: 6f72 7420 6578 7564 796e 2e75 7469 6c69  ort exudyn.utili
-000004b0: 7469 6573 2061 7320 6575 740d 0a69 6d70  ties as eut..imp
-000004c0: 6f72 7420 6578 7564 796e 2e72 6967 6964  ort exudyn.rigid
-000004d0: 426f 6479 5574 696c 6974 6965 7320 6173  BodyUtilities as
-000004e0: 2065 7262 0d0a 696d 706f 7274 2065 7875   erb..import exu
-000004f0: 6479 6e2e 6772 6170 6869 6373 4461 7461  dyn.graphicsData
-00000500: 5574 696c 6974 6965 7320 6173 2065 6764  Utilities as egd
-00000510: 0d0a 0d0a 6672 6f6d 2063 6f70 7920 696d  ....from copy im
-00000520: 706f 7274 2063 6f70 792c 2064 6565 7063  port copy, deepc
-00000530: 6f70 790d 0a69 6d70 6f72 7420 7469 6d65  opy..import time
-00000540: 2023 666f 7220 7469 6d65 7220 696e 2049   #for timer in I
-00000550: 6e76 6572 7365 4b69 6e65 6d61 7469 6373  nverseKinematics
-00000560: 4e75 6d65 7269 6361 6c0d 0a0d 0a0d 0a23  Numerical......#
+000003c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0a 0a23  +++++++++++++..#
+000003d0: 636f 6e73 7461 6e74 7320 616e 6420 6669  constants and fi
+000003e0: 7865 6420 7374 7275 6374 7572 6573 3a0a  xed structures:.
+000003f0: 696d 706f 7274 206e 756d 7079 2061 7320  import numpy as 
+00000400: 6e70 0a0a 696d 706f 7274 2065 7875 6479  np..import exudy
+00000410: 6e0a 0a69 6d70 6f72 7420 6578 7564 796e  n..import exudyn
+00000420: 2e69 7465 6d49 6e74 6572 6661 6365 2061  .itemInterface a
+00000430: 7320 6569 690a 696d 706f 7274 2065 7875  s eii.import exu
+00000440: 6479 6e2e 6261 7369 6355 7469 6c69 7469  dyn.basicUtiliti
+00000450: 6573 2061 7320 6562 750a 696d 706f 7274  es as ebu.import
+00000460: 2065 7875 6479 6e2e 6164 7661 6e63 6564   exudyn.advanced
+00000470: 5574 696c 6974 6965 7320 6173 2065 6175  Utilities as eau
+00000480: 0a0a 2369 6d70 6f72 7420 6578 7564 796e  ..#import exudyn
+00000490: 2e75 7469 6c69 7469 6573 2061 7320 6575  .utilities as eu
+000004a0: 740a 696d 706f 7274 2065 7875 6479 6e2e  t.import exudyn.
+000004b0: 7269 6769 6442 6f64 7955 7469 6c69 7469  rigidBodyUtiliti
+000004c0: 6573 2061 7320 6572 620a 696d 706f 7274  es as erb.import
+000004d0: 2065 7875 6479 6e2e 6772 6170 6869 6373   exudyn.graphics
+000004e0: 4461 7461 5574 696c 6974 6965 7320 6173  DataUtilities as
+000004f0: 2065 6764 0a0a 6672 6f6d 2063 6f70 7920   egd..from copy 
+00000500: 696d 706f 7274 2063 6f70 792c 2064 6565  import copy, dee
+00000510: 7063 6f70 790a 696d 706f 7274 2074 696d  pcopy.import tim
+00000520: 6520 2366 6f72 2074 696d 6572 2069 6e20  e #for timer in 
+00000530: 496e 7665 7273 654b 696e 656d 6174 6963  InverseKinematic
+00000540: 734e 756d 6572 6963 616c 0a0a 0a23 2b2b  sNumerical...#++
+00000550: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00000560: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000570: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000580: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000590: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000005a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000005b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000005c0: 2b2b 2b2b 0d0a 232b 2b2b 2020 4465 6669  ++++..#+++  Defi
-000005d0: 6e65 2072 6f62 6f74 206c 696e 6b20 2b2b  ne robot link ++
+000005a0: 2b2b 0a23 2b2b 2b20 2044 6566 696e 6520  ++.#+++  Define 
+000005b0: 726f 626f 7420 6c69 6e6b 202b 2b2b 2b2b  robot link +++++
+000005c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000005d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 000005e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000005f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000005f0: 2b2b 2b2b 2b2b 2b2b 0a23 2b2b 2b2b 2b2b  ++++++++.#++++++
 00000600: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00000610: 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d 0a23 2b2b  +++++++++++..#++
+00000610: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000620: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00000630: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00000640: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00000650: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00000660: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00000670: 2b2b 0d0a 2364 6566 696e 6520 636f 6e76  ++..#define conv
-00000680: 6572 7420 7465 7874 206e 616d 6564 206a  ert text named j
-00000690: 6f69 6e74 2074 7970 6573 2074 6f20 6578  oint types to ex
-000006a0: 7564 796e 206a 6f69 6e74 2074 7970 6573  udyn joint types
-000006b0: 0d0a 6469 6374 4a6f 696e 7454 7970 6554  ..dictJointTypeT
-000006c0: 6578 7432 4578 7564 796e 203d 207b 0d0a  ext2Exudyn = {..
-000006d0: 2020 2020 2752 7827 3a65 7875 6479 6e2e      'Rx':exudyn.
-000006e0: 4a6f 696e 7454 7970 652e 5265 766f 6c75  JointType.Revolu
-000006f0: 7465 582c 2023 7265 766f 6c75 7465 206a  teX, #revolute j
-00000700: 6f69 6e74 2066 6f72 206c 6f63 616c 2058  oint for local X
-00000710: 2061 7869 730d 0a20 2020 2027 5279 273a   axis..    'Ry':
-00000720: 6578 7564 796e 2e4a 6f69 6e74 5479 7065  exudyn.JointType
-00000730: 2e52 6576 6f6c 7574 6559 2c20 2372 6576  .RevoluteY, #rev
-00000740: 6f6c 7574 6520 6a6f 696e 7420 666f 7220  olute joint for 
-00000750: 6c6f 6361 6c20 5920 6178 6973 0d0a 2020  local Y axis..  
-00000760: 2020 2752 7a27 3a65 7875 6479 6e2e 4a6f    'Rz':exudyn.Jo
-00000770: 696e 7454 7970 652e 5265 766f 6c75 7465  intType.Revolute
-00000780: 5a2c 2023 7265 766f 6c75 7465 206a 6f69  Z, #revolute joi
-00000790: 6e74 2066 6f72 206c 6f63 616c 205a 2061  nt for local Z a
-000007a0: 7869 730d 0a20 2020 2027 5078 273a 6578  xis..    'Px':ex
-000007b0: 7564 796e 2e4a 6f69 6e74 5479 7065 2e50  udyn.JointType.P
-000007c0: 7269 736d 6174 6963 582c 2023 7072 6973  rismaticX, #pris
-000007d0: 6d61 7469 6320 6a6f 696e 7420 666f 7220  matic joint for 
-000007e0: 6c6f 6361 6c20 5820 6178 6973 0d0a 2020  local X axis..  
-000007f0: 2020 2750 7927 3a65 7875 6479 6e2e 4a6f    'Py':exudyn.Jo
-00000800: 696e 7454 7970 652e 5072 6973 6d61 7469  intType.Prismati
-00000810: 6359 2c20 2370 7269 736d 6174 6963 206a  cY, #prismatic j
-00000820: 6f69 6e74 2066 6f72 206c 6f63 616c 2059  oint for local Y
-00000830: 2061 7869 730d 0a20 2020 2027 507a 273a   axis..    'Pz':
-00000840: 6578 7564 796e 2e4a 6f69 6e74 5479 7065  exudyn.JointType
-00000850: 2e50 7269 736d 6174 6963 5a2c 2023 7072  .PrismaticZ, #pr
-00000860: 6973 6d61 7469 6320 6a6f 696e 7420 666f  ismatic joint fo
-00000870: 7220 6c6f 6361 6c20 5a20 6178 6973 0d0a  r local Z axis..
-00000880: 2020 2020 7d0d 0a0d 0a23 6465 6669 6e65      }....#define
-00000890: 2064 6963 7469 6f6e 6172 7920 666f 7220   dictionary for 
-000008a0: 6a6f 696e 7420 7472 616e 7366 6f72 6d61  joint transforma
-000008b0: 7469 6f6e 7320 6173 2068 6f6d 6f67 656e  tions as homogen
-000008c0: 656f 7573 2074 7261 6e73 666f 726d 6174  eous transformat
-000008d0: 696f 6e73 2c20 7265 706c 6163 656d 656e  ions, replacemen
-000008e0: 7420 666f 7220 7377 6974 6368 2f63 6173  t for switch/cas
-000008f0: 650d 0a64 6963 744a 6f69 6e74 5479 7065  e..dictJointType
-00000900: 3248 5420 3d20 7b0d 0a20 2020 2027 5278  2HT = {..    'Rx
-00000910: 273a 6572 622e 4854 726f 7461 7465 582c  ':erb.HTrotateX,
-00000920: 2023 7265 766f 6c75 7465 206a 6f69 6e74   #revolute joint
-00000930: 2066 6f72 206c 6f63 616c 2058 2061 7869   for local X axi
-00000940: 730d 0a20 2020 2027 5279 273a 6572 622e  s..    'Ry':erb.
-00000950: 4854 726f 7461 7465 592c 2023 7265 766f  HTrotateY, #revo
-00000960: 6c75 7465 206a 6f69 6e74 2066 6f72 206c  lute joint for l
-00000970: 6f63 616c 2059 2061 7869 730d 0a20 2020  ocal Y axis..   
-00000980: 2027 527a 273a 6572 622e 4854 726f 7461   'Rz':erb.HTrota
-00000990: 7465 5a2c 2023 7265 766f 6c75 7465 206a  teZ, #revolute j
-000009a0: 6f69 6e74 2066 6f72 206c 6f63 616c 205a  oint for local Z
-000009b0: 2061 7869 730d 0a20 2020 2027 5078 273a   axis..    'Px':
-000009c0: 6572 622e 4854 7472 616e 736c 6174 6558  erb.HTtranslateX
-000009d0: 2c20 2370 7269 736d 6174 6963 206a 6f69  , #prismatic joi
-000009e0: 6e74 2066 6f72 206c 6f63 616c 2058 2061  nt for local X a
-000009f0: 7869 730d 0a20 2020 2027 5079 273a 6572  xis..    'Py':er
-00000a00: 622e 4854 7472 616e 736c 6174 6559 2c20  b.HTtranslateY, 
-00000a10: 2370 7269 736d 6174 6963 206a 6f69 6e74  #prismatic joint
-00000a20: 2066 6f72 206c 6f63 616c 2059 2061 7869   for local Y axi
-00000a30: 730d 0a20 2020 2027 507a 273a 6572 622e  s..    'Pz':erb.
-00000a40: 4854 7472 616e 736c 6174 655a 2c20 2370  HTtranslateZ, #p
-00000a50: 7269 736d 6174 6963 206a 6f69 6e74 2066  rismatic joint f
-00000a60: 6f72 206c 6f63 616c 205a 2061 7869 730d  or local Z axis.
-00000a70: 0a20 2020 207d 0d0a 0d0a 2364 6566 696e  .    }....#defin
-00000a80: 6520 6469 6374 696f 6e61 7279 2066 6f72  e dictionary for
-00000a90: 206a 6f69 6e74 2074 7261 6e73 666f 726d   joint transform
-00000aa0: 6174 696f 6e73 2061 7320 686f 6d6f 6765  ations as homoge
-00000ab0: 6e65 6f75 7320 7472 616e 7366 6f72 6d61  neous transforma
-00000ac0: 7469 6f6e 732c 2072 6570 6c61 6365 6d65  tions, replaceme
-00000ad0: 6e74 2066 6f72 2073 7769 7463 682f 6361  nt for switch/ca
-00000ae0: 7365 0d0a 6469 6374 4a6f 696e 7454 7970  se..dictJointTyp
-00000af0: 6532 4178 6973 203d 207b 0d0a 2020 2020  e2Axis = {..    
-00000b00: 2752 7827 3a6e 702e 6172 7261 7928 5b31  'Rx':np.array([1
-00000b10: 2c30 2c30 5d29 2c20 2372 6576 6f6c 7574  ,0,0]), #revolut
-00000b20: 6520 6a6f 696e 7420 666f 7220 6c6f 6361  e joint for loca
-00000b30: 6c20 5820 6178 6973 0d0a 2020 2020 2752  l X axis..    'R
-00000b40: 7927 3a6e 702e 6172 7261 7928 5b30 2c31  y':np.array([0,1
-00000b50: 2c30 5d29 2c20 2372 6576 6f6c 7574 6520  ,0]), #revolute 
-00000b60: 6a6f 696e 7420 666f 7220 6c6f 6361 6c20  joint for local 
-00000b70: 5920 6178 6973 0d0a 2020 2020 2752 7a27  Y axis..    'Rz'
-00000b80: 3a6e 702e 6172 7261 7928 5b30 2c30 2c31  :np.array([0,0,1
-00000b90: 5d29 2c20 2372 6576 6f6c 7574 6520 6a6f  ]), #revolute jo
-00000ba0: 696e 7420 666f 7220 6c6f 6361 6c20 5a20  int for local Z 
-00000bb0: 6178 6973 0d0a 2020 2020 2750 7827 3a6e  axis..    'Px':n
-00000bc0: 702e 6172 7261 7928 5b31 2c30 2c30 5d29  p.array([1,0,0])
+00000640: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0a23  ++++++++++++++.#
+00000650: 6465 6669 6e65 2063 6f6e 7665 7274 2074  define convert t
+00000660: 6578 7420 6e61 6d65 6420 6a6f 696e 7420  ext named joint 
+00000670: 7479 7065 7320 746f 2065 7875 6479 6e20  types to exudyn 
+00000680: 6a6f 696e 7420 7479 7065 730a 6469 6374  joint types.dict
+00000690: 4a6f 696e 7454 7970 6554 6578 7432 4578  JointTypeText2Ex
+000006a0: 7564 796e 203d 207b 0a20 2020 2027 5278  udyn = {.    'Rx
+000006b0: 273a 6578 7564 796e 2e4a 6f69 6e74 5479  ':exudyn.JointTy
+000006c0: 7065 2e52 6576 6f6c 7574 6558 2c20 2372  pe.RevoluteX, #r
+000006d0: 6576 6f6c 7574 6520 6a6f 696e 7420 666f  evolute joint fo
+000006e0: 7220 6c6f 6361 6c20 5820 6178 6973 0a20  r local X axis. 
+000006f0: 2020 2027 5279 273a 6578 7564 796e 2e4a     'Ry':exudyn.J
+00000700: 6f69 6e74 5479 7065 2e52 6576 6f6c 7574  ointType.Revolut
+00000710: 6559 2c20 2372 6576 6f6c 7574 6520 6a6f  eY, #revolute jo
+00000720: 696e 7420 666f 7220 6c6f 6361 6c20 5920  int for local Y 
+00000730: 6178 6973 0a20 2020 2027 527a 273a 6578  axis.    'Rz':ex
+00000740: 7564 796e 2e4a 6f69 6e74 5479 7065 2e52  udyn.JointType.R
+00000750: 6576 6f6c 7574 655a 2c20 2372 6576 6f6c  evoluteZ, #revol
+00000760: 7574 6520 6a6f 696e 7420 666f 7220 6c6f  ute joint for lo
+00000770: 6361 6c20 5a20 6178 6973 0a20 2020 2027  cal Z axis.    '
+00000780: 5078 273a 6578 7564 796e 2e4a 6f69 6e74  Px':exudyn.Joint
+00000790: 5479 7065 2e50 7269 736d 6174 6963 582c  Type.PrismaticX,
+000007a0: 2023 7072 6973 6d61 7469 6320 6a6f 696e   #prismatic join
+000007b0: 7420 666f 7220 6c6f 6361 6c20 5820 6178  t for local X ax
+000007c0: 6973 0a20 2020 2027 5079 273a 6578 7564  is.    'Py':exud
+000007d0: 796e 2e4a 6f69 6e74 5479 7065 2e50 7269  yn.JointType.Pri
+000007e0: 736d 6174 6963 592c 2023 7072 6973 6d61  smaticY, #prisma
+000007f0: 7469 6320 6a6f 696e 7420 666f 7220 6c6f  tic joint for lo
+00000800: 6361 6c20 5920 6178 6973 0a20 2020 2027  cal Y axis.    '
+00000810: 507a 273a 6578 7564 796e 2e4a 6f69 6e74  Pz':exudyn.Joint
+00000820: 5479 7065 2e50 7269 736d 6174 6963 5a2c  Type.PrismaticZ,
+00000830: 2023 7072 6973 6d61 7469 6320 6a6f 696e   #prismatic join
+00000840: 7420 666f 7220 6c6f 6361 6c20 5a20 6178  t for local Z ax
+00000850: 6973 0a20 2020 207d 0a0a 2364 6566 696e  is.    }..#defin
+00000860: 6520 6469 6374 696f 6e61 7279 2066 6f72  e dictionary for
+00000870: 206a 6f69 6e74 2074 7261 6e73 666f 726d   joint transform
+00000880: 6174 696f 6e73 2061 7320 686f 6d6f 6765  ations as homoge
+00000890: 6e65 6f75 7320 7472 616e 7366 6f72 6d61  neous transforma
+000008a0: 7469 6f6e 732c 2072 6570 6c61 6365 6d65  tions, replaceme
+000008b0: 6e74 2066 6f72 2073 7769 7463 682f 6361  nt for switch/ca
+000008c0: 7365 0a64 6963 744a 6f69 6e74 5479 7065  se.dictJointType
+000008d0: 3248 5420 3d20 7b0a 2020 2020 2752 7827  2HT = {.    'Rx'
+000008e0: 3a65 7262 2e48 5472 6f74 6174 6558 2c20  :erb.HTrotateX, 
+000008f0: 2372 6576 6f6c 7574 6520 6a6f 696e 7420  #revolute joint 
+00000900: 666f 7220 6c6f 6361 6c20 5820 6178 6973  for local X axis
+00000910: 0a20 2020 2027 5279 273a 6572 622e 4854  .    'Ry':erb.HT
+00000920: 726f 7461 7465 592c 2023 7265 766f 6c75  rotateY, #revolu
+00000930: 7465 206a 6f69 6e74 2066 6f72 206c 6f63  te joint for loc
+00000940: 616c 2059 2061 7869 730a 2020 2020 2752  al Y axis.    'R
+00000950: 7a27 3a65 7262 2e48 5472 6f74 6174 655a  z':erb.HTrotateZ
+00000960: 2c20 2372 6576 6f6c 7574 6520 6a6f 696e  , #revolute join
+00000970: 7420 666f 7220 6c6f 6361 6c20 5a20 6178  t for local Z ax
+00000980: 6973 0a20 2020 2027 5078 273a 6572 622e  is.    'Px':erb.
+00000990: 4854 7472 616e 736c 6174 6558 2c20 2370  HTtranslateX, #p
+000009a0: 7269 736d 6174 6963 206a 6f69 6e74 2066  rismatic joint f
+000009b0: 6f72 206c 6f63 616c 2058 2061 7869 730a  or local X axis.
+000009c0: 2020 2020 2750 7927 3a65 7262 2e48 5474      'Py':erb.HTt
+000009d0: 7261 6e73 6c61 7465 592c 2023 7072 6973  ranslateY, #pris
+000009e0: 6d61 7469 6320 6a6f 696e 7420 666f 7220  matic joint for 
+000009f0: 6c6f 6361 6c20 5920 6178 6973 0a20 2020  local Y axis.   
+00000a00: 2027 507a 273a 6572 622e 4854 7472 616e   'Pz':erb.HTtran
+00000a10: 736c 6174 655a 2c20 2370 7269 736d 6174  slateZ, #prismat
+00000a20: 6963 206a 6f69 6e74 2066 6f72 206c 6f63  ic joint for loc
+00000a30: 616c 205a 2061 7869 730a 2020 2020 7d0a  al Z axis.    }.
+00000a40: 0a23 6465 6669 6e65 2064 6963 7469 6f6e  .#define diction
+00000a50: 6172 7920 666f 7220 6a6f 696e 7420 7472  ary for joint tr
+00000a60: 616e 7366 6f72 6d61 7469 6f6e 7320 6173  ansformations as
+00000a70: 2068 6f6d 6f67 656e 656f 7573 2074 7261   homogeneous tra
+00000a80: 6e73 666f 726d 6174 696f 6e73 2c20 7265  nsformations, re
+00000a90: 706c 6163 656d 656e 7420 666f 7220 7377  placement for sw
+00000aa0: 6974 6368 2f63 6173 650a 6469 6374 4a6f  itch/case.dictJo
+00000ab0: 696e 7454 7970 6532 4178 6973 203d 207b  intType2Axis = {
+00000ac0: 0a20 2020 2027 5278 273a 6e70 2e61 7272  .    'Rx':np.arr
+00000ad0: 6179 285b 312c 302c 305d 292c 2023 7265  ay([1,0,0]), #re
+00000ae0: 766f 6c75 7465 206a 6f69 6e74 2066 6f72  volute joint for
+00000af0: 206c 6f63 616c 2058 2061 7869 730a 2020   local X axis.  
+00000b00: 2020 2752 7927 3a6e 702e 6172 7261 7928    'Ry':np.array(
+00000b10: 5b30 2c31 2c30 5d29 2c20 2372 6576 6f6c  [0,1,0]), #revol
+00000b20: 7574 6520 6a6f 696e 7420 666f 7220 6c6f  ute joint for lo
+00000b30: 6361 6c20 5920 6178 6973 0a20 2020 2027  cal Y axis.    '
+00000b40: 527a 273a 6e70 2e61 7272 6179 285b 302c  Rz':np.array([0,
+00000b50: 302c 315d 292c 2023 7265 766f 6c75 7465  0,1]), #revolute
+00000b60: 206a 6f69 6e74 2066 6f72 206c 6f63 616c   joint for local
+00000b70: 205a 2061 7869 730a 2020 2020 2750 7827   Z axis.    'Px'
+00000b80: 3a6e 702e 6172 7261 7928 5b31 2c30 2c30  :np.array([1,0,0
+00000b90: 5d29 2c20 2370 7269 736d 6174 6963 206a  ]), #prismatic j
+00000ba0: 6f69 6e74 2066 6f72 206c 6f63 616c 2058  oint for local X
+00000bb0: 2061 7869 730a 2020 2020 2750 7927 3a6e   axis.    'Py':n
+00000bc0: 702e 6172 7261 7928 5b30 2c31 2c30 5d29  p.array([0,1,0])
 00000bd0: 2c20 2370 7269 736d 6174 6963 206a 6f69  , #prismatic joi
-00000be0: 6e74 2066 6f72 206c 6f63 616c 2058 2061  nt for local X a
-00000bf0: 7869 730d 0a20 2020 2027 5079 273a 6e70  xis..    'Py':np
-00000c00: 2e61 7272 6179 285b 302c 312c 305d 292c  .array([0,1,0]),
-00000c10: 2023 7072 6973 6d61 7469 6320 6a6f 696e   #prismatic join
-00000c20: 7420 666f 7220 6c6f 6361 6c20 5920 6178  t for local Y ax
-00000c30: 6973 0d0a 2020 2020 2750 7a27 3a6e 702e  is..    'Pz':np.
-00000c40: 6172 7261 7928 5b30 2c30 2c31 5d29 2c20  array([0,0,1]), 
-00000c50: 2370 7269 736d 6174 6963 206a 6f69 6e74  #prismatic joint
-00000c60: 2066 6f72 206c 6f63 616c 205a 2061 7869   for local Z axi
-00000c70: 730d 0a20 2020 207d 0d0a 0d0a 236d 6170  s..    }....#map
-00000c80: 7320 6a6f 696e 7420 7479 7065 2074 6f20  s joint type to 
-00000c90: 2863 6f6e 7374 7261 696e 6564 2920 636f  (constrained) co
-00000ca0: 6f72 6469 6e61 7465 2030 2e2e 323a 2074  ordinate 0..2: t
-00000cb0: 7261 6e73 6c61 7469 6f6e 2c20 332e 2e35  ranslation, 3..5
-00000cc0: 3a20 726f 7461 7469 6f6e 0d0a 6469 6374  : rotation..dict
-00000cd0: 4a6f 696e 7454 7970 6532 636f 6f72 6469  JointType2coordi
-00000ce0: 6e61 7465 3644 203d 207b 0d0a 2020 2020  nate6D = {..    
-00000cf0: 2750 7827 3a30 2c20 2372 6576 6f6c 7574  'Px':0, #revolut
-00000d00: 6520 6a6f 696e 7420 666f 7220 6c6f 6361  e joint for loca
-00000d10: 6c20 5820 6178 6973 0d0a 2020 2020 2750  l X axis..    'P
-00000d20: 7927 3a31 2c20 2372 6576 6f6c 7574 6520  y':1, #revolute 
-00000d30: 6a6f 696e 7420 666f 7220 6c6f 6361 6c20  joint for local 
-00000d40: 5920 6178 6973 0d0a 2020 2020 2750 7a27  Y axis..    'Pz'
-00000d50: 3a32 2c20 2372 6576 6f6c 7574 6520 6a6f  :2, #revolute jo
-00000d60: 696e 7420 666f 7220 6c6f 6361 6c20 5a20  int for local Z 
-00000d70: 6178 6973 0d0a 2020 2020 2752 7827 3a33  axis..    'Rx':3
-00000d80: 2c20 2370 7269 736d 6174 6963 206a 6f69  , #prismatic joi
-00000d90: 6e74 2066 6f72 206c 6f63 616c 2058 2061  nt for local X a
-00000da0: 7869 730d 0a20 2020 2027 5279 273a 342c  xis..    'Ry':4,
-00000db0: 2023 7072 6973 6d61 7469 6320 6a6f 696e   #prismatic join
-00000dc0: 7420 666f 7220 6c6f 6361 6c20 5920 6178  t for local Y ax
-00000dd0: 6973 0d0a 2020 2020 2752 7a27 3a35 2c20  is..    'Rz':5, 
-00000de0: 2370 7269 736d 6174 6963 206a 6f69 6e74  #prismatic joint
-00000df0: 2066 6f72 206c 6f63 616c 205a 2061 7869   for local Z axi
-00000e00: 730d 0a7d 0d0a 0d0a 2352 6f62 6f74 4c69  s..}....#RobotLi
-00000e10: 6e6b 2063 6861 6e67 6573 2032 3032 312d  nk changes 2021-
-00000e20: 3038 2d31 363a 0d0a 236c 6f63 616c 6572  08-16:..#localer
-00000e30: 622e 4854 2d3e 6c6f 6361 6c65 7262 2e48  b.HT->localerb.H
-00000e40: 5420 2864 6f65 7320 6e6f 7420 696e 636c  T (does not incl
-00000e50: 7564 6520 726f 7461 7469 6f6e 293b 2074  ude rotation); t
-00000e60: 6869 7320 6a6f 696e 7420 746f 2074 6869  his joint to thi
-00000e70: 7320 6c69 6e6b 2065 7262 2e48 540d 0a23  s link erb.HT..#
-00000e80: 6164 6420 7072 6565 7262 2e48 543a 2070  add preerb.HT: p
-00000e90: 7265 7669 6f75 7320 6c69 6e6b 2074 6f20  revious link to 
-00000ea0: 7468 6973 206a 6f69 6e74 2065 7262 2e48  this joint erb.H
-00000eb0: 540d 0a23 6469 6374 4a6f 696e 7454 7970  T..#dictJointTyp
-00000ec0: 6532 6572 622e 4854 5b6c 696e 6b2e 6a6f  e2erb.HT[link.jo
-00000ed0: 696e 7454 7970 655d 2871 5b69 5d29 3a20  intType](q[i]): 
-00000ee0: 6465 6669 6e65 7320 6a6f 696e 7420 6572  defines joint er
-00000ef0: 622e 4854 0d0a 236c 6f63 616c 6572 622e  b.HT..#localerb.
-00000f00: 4854 2069 6e20 4d42 5320 6d6f 6465 6c69  HT in MBS modeli
-00000f10: 6e67 2028 696e 6572 7469 612c 2065 7463  ng (inertia, etc
-00000f20: 2e29 2069 7320 6b65 7074 2073 616d 652c  .) is kept same,
-00000f30: 2077 6869 6c65 206c 6f63 616c 6572 622e   while localerb.
-00000f40: 4854 203d 2049 4434 2066 6f72 204d 6f64  HT = ID4 for Mod
-00000f50: 4448 0d0a 2370 7265 6572 622e 4854 206d  DH..#preerb.HT m
-00000f60: 7573 7420 6265 2061 6464 6564 2066 6f72  ust be added for
-00000f70: 206a 6f69 6e74 2061 7865 7320 6465 6669   joint axes defi
-00000f80: 6e69 7469 6f6e 7320 616e 6420 666f 7220  nitions and for 
-00000f90: 6375 7272 656e 7448 540d 0a23 696e 6572  currentHT..#iner
-00000fa0: 7469 6120 616e 6420 434f 4d20 6e65 6564  tia and COM need
-00000fb0: 2074 6f20 6265 2063 6f6e 7665 7274 6564   to be converted
-00000fc0: 2062 7920 6c6f 6361 6c48 5420 6f66 2053   by localHT of S
-00000fd0: 7464 4448 2069 6e74 6f20 4d6f 6444 4820  tdDH into ModDH 
-00000fe0: 636f 6e66 6967 7572 6174 696f 6e21 2121  configuration!!!
-00000ff0: 0d0a 0d0a 232a 2a63 6c61 7373 3a20 636c  ....#**class: cl
-00001000: 6173 7320 746f 2064 6566 696e 6520 7669  ass to define vi
-00001010: 7375 616c 697a 6174 696f 6e20 6f66 2052  sualization of R
-00001020: 6f62 6f74 4c69 6e6b 0d0a 636c 6173 7320  obotLink..class 
-00001030: 5652 6f62 6f74 4c69 6e6b 3a0d 0a20 2020  VRobotLink:..   
-00001040: 2023 2a2a 636c 6173 7346 756e 6374 696f   #**classFunctio
-00001050: 6e3a 2069 6e69 7469 616c 697a 6520 726f  n: initialize ro
-00001060: 626f 7420 6c69 6e6b 2077 6974 6820 7061  bot link with pa
-00001070: 7261 6d65 7465 7273 2c20 6265 696e 6720  rameters, being 
-00001080: 7365 6c66 2d65 7870 6c61 696e 696e 670d  self-explaining.
-00001090: 0a20 2020 2023 2a2a 696e 7075 743a 0d0a  .    #**input:..
-000010a0: 2020 2020 2320 206a 6f69 6e74 5261 6469      #  jointRadi
-000010b0: 7573 3a20 7261 6469 7573 206f 6620 6a6f  us: radius of jo
-000010c0: 696e 7420 746f 2064 7261 770d 0a20 2020  int to draw..   
-000010d0: 2023 2020 6a6f 696e 7457 6964 7468 3a20   #  jointWidth: 
-000010e0: 6c65 6e67 7468 206f 7220 7769 6474 6820  length or width 
-000010f0: 6f66 206a 6f69 6e74 2028 6465 7065 6e64  of joint (depend
-00001100: 696e 6720 6f6e 2074 7970 6520 6f66 206a  ing on type of j
-00001110: 6f69 6e74 290d 0a20 2020 2023 2020 7368  oint)..    #  sh
-00001120: 6f77 4d42 536a 6f69 6e74 3a20 6966 2046  owMBSjoint: if F
-00001130: 616c 7365 2c20 6a6f 696e 7420 6973 206e  alse, joint is n
-00001140: 6f74 2064 7261 776e 0d0a 2020 2020 2320  ot drawn..    # 
-00001150: 206c 696e 6b57 6964 7468 3a20 7769 6474   linkWidth: widt
-00001160: 6820 6f66 206c 696e 6b20 666f 7220 6465  h of link for de
-00001170: 6661 756c 7420 6472 6177 696e 670d 0a20  fault drawing.. 
-00001180: 2020 2023 2020 6c69 6e6b 436f 6c6f 723a     #  linkColor:
-00001190: 2063 6f6c 6f72 206f 6620 6c69 6e6b 2066   color of link f
-000011a0: 6f72 2064 6566 6175 6c74 2064 7261 7769  or default drawi
-000011b0: 6e67 0d0a 2020 2020 2320 2073 686f 7743  ng..    #  showC
-000011c0: 4f4d 3a20 6966 2054 7275 652c 2063 656e  OM: if True, cen
-000011d0: 7465 7220 6f66 206d 6173 7320 6973 206d  ter of mass is m
-000011e0: 6172 6b65 6420 7769 7468 2063 7562 650d  arked with cube.
-000011f0: 0a20 2020 2023 2020 6772 6170 6869 6373  .    #  graphics
-00001200: 4461 7461 3a20 6c69 7374 206f 6620 4772  Data: list of Gr
-00001210: 6170 6869 6373 4461 7461 2074 6f20 7265  aphicsData to re
-00001220: 7072 6573 656e 7420 6c69 6e6b 3b20 6966  present link; if
-00001230: 206c 6973 7420 6973 2065 6d70 7479 2c20   list is empty, 
-00001240: 6c69 6e6b 2067 7261 7068 6963 7320 7769  link graphics wi
-00001250: 6c6c 2062 6520 6765 6e65 7261 7465 6420  ll be generated 
-00001260: 6672 6f6d 206c 696e 6b20 6765 6f6d 6574  from link geomet
-00001270: 7279 2064 6174 613b 206f 7468 6572 7769  ry data; otherwi
-00001280: 7365 2c20 6472 6177 696e 6720 7769 6c6c  se, drawing will
-00001290: 2062 6520 7461 6b65 6e20 6672 6f6d 2067   be taken from g
-000012a0: 7261 7068 6963 7344 6174 612c 2061 6e64  raphicsData, and
-000012b0: 206f 6e6c 7920 7368 6f77 4d42 536a 6f69   only showMBSjoi
-000012c0: 6e74 2061 6e64 2073 686f 7743 4f4d 2066  nt and showCOM f
-000012d0: 6c61 6773 2077 696c 6c20 6164 6420 6164  lags will add ad
-000012e0: 6469 7469 6f6e 616c 2067 7261 7068 6963  ditional graphic
-000012f0: 730d 0a20 2020 2064 6566 205f 5f69 6e69  s..    def __ini
-00001300: 745f 5f28 7365 6c66 2c20 6a6f 696e 7452  t__(self, jointR
-00001310: 6164 6975 7320 3d20 302e 3036 2c20 6a6f  adius = 0.06, jo
-00001320: 696e 7457 6964 7468 203d 2030 2e31 322c  intWidth = 0.12,
-00001330: 206c 696e 6b57 6964 7468 203d 2030 2e31   linkWidth = 0.1
-00001340: 2c20 7368 6f77 4d42 536a 6f69 6e74 203d  , showMBSjoint =
-00001350: 2054 7275 652c 2073 686f 7743 4f4d 203d   True, showCOM =
-00001360: 2054 7275 652c 200d 0a20 2020 2020 2020   True, ..       
-00001370: 2020 2020 2020 2020 2020 6c69 6e6b 436f            linkCo
-00001380: 6c6f 7220 3d20 5b30 2e34 2c30 2e34 2c30  lor = [0.4,0.4,0
-00001390: 2e34 2c31 5d2c 2067 7261 7068 6963 7344  .4,1], graphicsD
-000013a0: 6174 6120 3d20 5b5d 2029 3a0d 0a20 2020  ata = [] ):..   
-000013b0: 2020 2020 2073 656c 662e 6a6f 696e 7452       self.jointR
-000013c0: 6164 6975 7320 3d20 6a6f 696e 7452 6164  adius = jointRad
-000013d0: 6975 730d 0a20 2020 2020 2020 2073 656c  ius..        sel
-000013e0: 662e 6a6f 696e 7457 6964 7468 203d 206a  f.jointWidth = j
-000013f0: 6f69 6e74 5769 6474 6820 0d0a 2020 2020  ointWidth ..    
-00001400: 2020 2020 7365 6c66 2e73 686f 774d 4253      self.showMBS
-00001410: 6a6f 696e 7420 3d20 7368 6f77 4d42 536a  joint = showMBSj
-00001420: 6f69 6e74 0d0a 2020 2020 2020 2020 7365  oint..        se
-00001430: 6c66 2e6c 696e 6b57 6964 7468 203d 206c  lf.linkWidth = l
-00001440: 696e 6b57 6964 7468 200d 0a20 2020 2020  inkWidth ..     
-00001450: 2020 2073 656c 662e 6c69 6e6b 436f 6c6f     self.linkColo
-00001460: 7220 3d20 6c69 6e6b 436f 6c6f 720d 0a20  r = linkColor.. 
-00001470: 2020 2020 2020 2073 656c 662e 7368 6f77         self.show
-00001480: 434f 4d20 3d20 7368 6f77 434f 4d0d 0a20  COM = showCOM.. 
-00001490: 2020 2020 2020 2073 656c 662e 6772 6170         self.grap
-000014a0: 6869 6373 4461 7461 203d 2067 7261 7068  hicsData = graph
-000014b0: 6963 7344 6174 610d 0a0d 0a20 2020 2064  icsData....    d
-000014c0: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
-000014d0: 3a0d 0a20 2020 2020 2020 2073 203d 2027  :..        s = '
-000014e0: 2020 6a6f 696e 7452 6164 6975 7320 3d20    jointRadius = 
-000014f0: 2720 2b20 7374 7228 7365 6c66 2e6a 6f69  ' + str(self.joi
-00001500: 6e74 5261 6469 7573 290d 0a20 2020 2020  ntRadius)..     
-00001510: 2020 2073 202b 3d20 275c 6e20 206a 6f69     s += '\n  joi
-00001520: 6e74 5769 6474 6820 3d20 2720 2b20 7374  ntWidth = ' + st
-00001530: 7228 7365 6c66 2e6a 6f69 6e74 5769 6474  r(self.jointWidt
-00001540: 6829 0d0a 2020 2020 2020 2020 7320 2b3d  h)..        s +=
-00001550: 2027 5c6e 2020 7368 6f77 4d42 536a 6f69   '\n  showMBSjoi
-00001560: 6e74 203d 2027 202b 2073 7472 2873 656c  nt = ' + str(sel
-00001570: 662e 7368 6f77 4d42 536a 6f69 6e74 290d  f.showMBSjoint).
-00001580: 0a20 2020 2020 2020 2073 202b 3d20 275c  .        s += '\
-00001590: 6e20 206c 696e 6b57 6964 7468 203d 2027  n  linkWidth = '
-000015a0: 202b 2073 7472 2873 656c 662e 6c69 6e6b   + str(self.link
-000015b0: 5769 6474 6829 0d0a 2020 2020 2020 2020  Width)..        
-000015c0: 7320 2b3d 2027 5c6e 2020 6c69 6e6b 436f  s += '\n  linkCo
-000015d0: 6c6f 7220 3d20 2720 2b20 7374 7228 7365  lor = ' + str(se
-000015e0: 6c66 2e6c 696e 6b43 6f6c 6f72 290d 0a20  lf.linkColor).. 
-000015f0: 2020 2020 2020 2073 202b 3d20 275c 6e20         s += '\n 
-00001600: 2073 686f 7743 4f4d 203d 2027 202b 2073   showCOM = ' + s
-00001610: 7472 2873 656c 662e 7368 6f77 434f 4d29  tr(self.showCOM)
-00001620: 0d0a 2020 2020 2020 2020 6744 6174 6153  ..        gDataS
-00001630: 7472 203d 2027 270d 0a20 2020 2020 2020  tr = ''..       
-00001640: 2069 6620 6c65 6e28 7365 6c66 2e67 7261   if len(self.gra
-00001650: 7068 6963 7344 6174 6129 2021 3d20 303a  phicsData) != 0:
-00001660: 0d0a 2020 2020 2020 2020 2020 2020 6744  ..            gD
-00001670: 6174 6153 7472 203d 2027 2e2e 2e27 0d0a  ataStr = '...'..
-00001680: 2020 2020 2020 2020 7320 2b3d 2027 5c6e          s += '\n
-00001690: 2020 6772 6170 6869 6373 4461 7461 203d    graphicsData =
-000016a0: 205b 2720 2b20 6744 6174 6153 7472 202b   [' + gDataStr +
-000016b0: 2027 5d27 0d0a 2020 2020 2020 2020 2020   ']'..          
-000016c0: 2020 0d0a 2020 2020 2020 2020 7265 7475    ..        retu
-000016d0: 726e 2073 0d0a 2020 2020 6465 6620 5f5f  rn s..    def __
-000016e0: 7265 7072 5f5f 2873 656c 6629 3a0d 0a20  repr__(self):.. 
-000016f0: 2020 2020 2020 2072 6574 7572 6e20 7374         return st
-00001700: 7228 7365 6c66 290d 0a0d 0a0d 0a23 2a2a  r(self)......#**
-00001710: 636c 6173 733a 2063 6c61 7373 2074 6f20  class: class to 
-00001720: 6465 6669 6e65 206f 6e65 206c 696e 6b20  define one link 
-00001730: 6f66 2061 2072 6f62 6f74 0d0a 636c 6173  of a robot..clas
-00001740: 7320 526f 626f 744c 696e 6b3a 0d0a 2020  s RobotLink:..  
-00001750: 2020 232a 2a63 6c61 7373 4675 6e63 7469    #**classFuncti
-00001760: 6f6e 3a20 696e 6974 6961 6c69 7a65 2072  on: initialize r
-00001770: 6f62 6f74 206c 696e 6b0d 0a20 2020 2023  obot link..    #
-00001780: 2a2a 696e 7075 743a 0d0a 2020 2020 2320  **input:..    # 
-00001790: 206d 6173 733a 206d 6173 7320 6f66 2072   mass: mass of r
-000017a0: 6f62 6f74 206c 696e 6b0d 0a20 2020 2023  obot link..    #
-000017b0: 2020 434f 4d3a 2063 656e 7465 7220 6f66    COM: center of
-000017c0: 206d 6173 7320 696e 206c 696e 6b20 636f   mass in link co
-000017d0: 6f72 6469 6e61 7465 2073 7973 7465 6d0d  ordinate system.
-000017e0: 0a20 2020 2023 2020 696e 6572 7469 613a  .    #  inertia:
-000017f0: 2033 7833 206d 6174 7269 7820 286c 6973   3x3 matrix (lis
-00001800: 7420 6f66 206c 6973 7473 202f 206e 756d  t of lists / num
-00001810: 7079 2061 7272 6179 2920 636f 6e74 6169  py array) contai
-00001820: 6e69 6e67 2069 6e65 7274 6961 2074 656e  ning inertia ten
-00001830: 736f 7220 696e 206c 696e 6b20 636f 6f72  sor in link coor
-00001840: 6469 6e61 7465 732c 2077 6974 6820 7265  dinates, with re
-00001850: 7370 6563 7420 746f 2063 656e 7465 7220  spect to center 
-00001860: 6f66 206d 6173 730d 0a20 2020 2023 2020  of mass..    #  
-00001870: 6c6f 6361 6c48 543a 2034 7834 206d 6174  localHT: 4x4 mat
-00001880: 7269 7820 286c 6973 7420 6f66 206c 6973  rix (list of lis
-00001890: 7473 202f 206e 756d 7079 2061 7272 6179  ts / numpy array
-000018a0: 2920 636f 6e74 6169 6e69 6e67 2068 6f6d  ) containing hom
-000018b0: 6f67 656e 656f 7573 2074 7261 6e73 666f  ogeneous transfo
-000018c0: 726d 6174 696f 6e20 6672 6f6d 206c 6f63  rmation from loc
-000018d0: 616c 206a 6f69 6e74 2074 6f20 6c69 6e6b  al joint to link
-000018e0: 2063 6f6f 7264 696e 6174 6573 3b20 6465   coordinates; de
-000018f0: 6661 756c 7420 3d20 6964 656e 7469 7479  fault = identity
-00001900: 3b20 6375 7272 656e 746c 792c 2074 6869  ; currently, thi
-00001910: 7320 7472 616e 7366 6f72 6d61 7469 6f6e  s transformation
-00001920: 2069 7320 6e6f 7420 6176 6169 6c61 626c   is not availabl
-00001930: 6520 696e 204b 696e 656d 6174 6963 5472  e in KinematicTr
-00001940: 6565 2c20 7468 6572 6566 6f72 6520 7468  ee, therefore th
-00001950: 6520 6c69 6e6b 2069 6e65 7274 6961 2061  e link inertia a
-00001960: 6e64 2043 4f4d 206d 7573 7420 6265 2074  nd COM must be t
-00001970: 7261 6e73 666f 726d 6564 2061 6363 6f72  ransformed accor
-00001980: 6469 6e67 6c79 0d0a 2020 2020 2320 2070  dingly..    #  p
-00001990: 7265 4854 3a20 3478 3420 6d61 7472 6978  reHT: 4x4 matrix
-000019a0: 2028 6c69 7374 206f 6620 6c69 7374 7320   (list of lists 
-000019b0: 2f20 6e75 6d70 7920 6172 7261 7929 2063  / numpy array) c
-000019c0: 6f6e 7461 696e 696e 6720 686f 6d6f 6765  ontaining homoge
-000019d0: 6e65 6f75 7320 7472 616e 7366 6f72 6d61  neous transforma
-000019e0: 7469 6f6e 2066 726f 6d20 7072 6576 696f  tion from previo
-000019f0: 7573 206c 696e 6b20 746f 2074 6869 7320  us link to this 
-00001a00: 6a6f 696e 743b 2064 6566 6175 6c74 203d  joint; default =
-00001a10: 2069 6465 6e74 6974 790d 0a20 2020 2023   identity..    #
-00001a20: 2020 6a6f 696e 7454 7970 653a 2073 7472    jointType: str
-00001a30: 696e 6720 636f 6e74 6169 6e69 6e67 206a  ing containing j
-00001a40: 6f69 6e74 2074 7970 652c 206f 7574 206f  oint type, out o
-00001a50: 663a 2027 5278 272c 2027 5279 272c 2027  f: 'Rx', 'Ry', '
-00001a60: 527a 2720 666f 7220 7265 766f 6c75 7465  Rz' for revolute
-00001a70: 206a 6f69 6e74 7320 616e 6420 2750 7827   joints and 'Px'
-00001a80: 2c20 2750 7927 2c20 2750 7a27 2066 6f72  , 'Py', 'Pz' for
-00001a90: 2070 7269 736d 6174 6963 206a 6f69 6e74   prismatic joint
-00001aa0: 7320 6172 6f75 6e64 2f61 6c6f 6e67 2074  s around/along t
-00001ab0: 6865 2072 6573 7065 6369 7469 7665 206c  he respecitive l
-00001ac0: 6f63 616c 2061 7865 730d 0a20 2020 2023  ocal axes..    #
-00001ad0: 2020 7061 7265 6e74 3a20 666f 7220 6275    parent: for bu
-00001ae0: 696c 6469 6e67 2072 6f62 6f74 7320 6173  ilding robots as
-00001af0: 206b 696e 656d 6174 6963 2074 7265 653b   kinematic tree;
-00001b00: 2075 7365 2027 2d32 2720 746f 2061 7574   use '-2' to aut
-00001b10: 6f6d 6174 6963 616c 6c79 2073 6574 2070  omatically set p
-00001b20: 6172 656e 7473 2066 6f72 2073 6572 6961  arents for seria
-00001b30: 6c20 726f 626f 7420 286f 6e20 6669 7865  l robot (on fixe
-00001b40: 6420 6261 7365 292c 2075 7365 2027 2d31  d base), use '-1
-00001b50: 2720 666f 7220 6772 6f75 6e64 2d70 6172  ' for ground-par
-00001b60: 656e 7420 616e 6420 616e 7920 6f74 6865  ent and any othe
-00001b70: 7220 302d 6261 7365 6420 696e 6465 7820  r 0-based index 
-00001b80: 666f 7220 636f 6e6e 6563 7469 6f6e 2074  for connection t
-00001b90: 6f20 7061 7265 6e74 206c 696e 6b0d 0a20  o parent link.. 
-00001ba0: 2020 2023 2020 5044 636f 6e74 726f 6c3a     #  PDcontrol:
-00001bb0: 2074 7570 6c65 206f 6620 5020 616e 6420   tuple of P and 
-00001bc0: 4420 636f 6e74 726f 6c20 7661 6c75 6573  D control values
-00001bd0: 2c20 6465 6669 6e69 6e67 2070 6f73 6974  , defining posit
-00001be0: 696f 6e20 2872 6f74 6174 696f 6e29 2070  ion (rotation) p
-00001bf0: 726f 706f 7274 696f 6e61 6c20 7661 6c75  roportional valu
-00001c00: 6520 5020 616e 6420 7665 6c6f 6369 7469  e P and velociti
-00001c10: 7920 7072 6f70 6f72 7469 6f6e 616c 2076  y proportional v
-00001c20: 616c 7565 2044 0d0a 2020 2020 2320 2076  alue D..    #  v
-00001c30: 6973 7561 6c69 7a61 7469 6f6e 3a20 5652  isualization: VR
-00001c40: 6f62 6f74 4c69 6e6b 2073 7472 7563 7475  obotLink structu
-00001c50: 7265 2063 6f6e 7461 696e 696e 6720 6f70  re containing op
-00001c60: 7469 6f6e 7320 666f 7220 6472 6177 696e  tions for drawin
-00001c70: 6720 6f66 206c 696e 6b20 616e 6420 6a6f  g of link and jo
-00001c80: 696e 7473 3b20 7365 6520 636c 6173 7320  ints; see class 
-00001c90: 5652 6f62 6f74 4c69 6e6b 0d0a 2020 2020  VRobotLink..    
-00001ca0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00001cb0: 662c 206d 6173 732c 2043 4f4d 2c20 696e  f, mass, COM, in
-00001cc0: 6572 7469 612c 206c 6f63 616c 4854 3d65  ertia, localHT=e
-00001cd0: 7262 2e48 5430 2829 2c20 6a6f 696e 7454  rb.HT0(), jointT
-00001ce0: 7970 653d 2752 7a27 2c20 7061 7265 6e74  ype='Rz', parent
-00001cf0: 3d2d 322c 2070 7265 4854 3d65 7262 2e48  =-2, preHT=erb.H
-00001d00: 5430 2829 2c20 5044 636f 6e74 726f 6c3d  T0(), PDcontrol=
-00001d10: 284e 6f6e 652c 4e6f 6e65 292c 2076 6973  (None,None), vis
-00001d20: 7561 6c69 7a61 7469 6f6e 3d56 526f 626f  ualization=VRobo
-00001d30: 744c 696e 6b28 2929 3a0d 0a20 2020 2020  tLink()):..     
-00001d40: 2020 2073 656c 662e 6d61 7373 203d 206d     self.mass = m
-00001d50: 6173 730d 0a20 2020 2020 2020 2073 656c  ass..        sel
-00001d60: 662e 434f 4d20 3d20 6e70 2e61 7272 6179  f.COM = np.array
-00001d70: 2843 4f4d 290d 0a20 2020 2020 2020 2073  (COM)..        s
-00001d80: 656c 662e 696e 6572 7469 6120 3d20 6e70  elf.inertia = np
-00001d90: 2e61 7272 6179 2869 6e65 7274 6961 290d  .array(inertia).
-00001da0: 0a20 2020 2020 2020 2073 656c 662e 6c6f  .        self.lo
-00001db0: 6361 6c48 5420 3d20 6e70 2e61 7272 6179  calHT = np.array
-00001dc0: 286c 6f63 616c 4854 290d 0a20 2020 2020  (localHT)..     
-00001dd0: 2020 2073 656c 662e 7072 6548 5420 3d20     self.preHT = 
-00001de0: 6e70 2e61 7272 6179 2870 7265 4854 290d  np.array(preHT).
-00001df0: 0a20 2020 2020 2020 2073 656c 662e 6a6f  .        self.jo
-00001e00: 696e 7454 7970 6520 3d20 6a6f 696e 7454  intType = jointT
-00001e10: 7970 650d 0a20 2020 2020 2020 2073 656c  ype..        sel
-00001e20: 662e 7061 7265 6e74 203d 2070 6172 656e  f.parent = paren
-00001e30: 740d 0a20 2020 2020 2020 2073 656c 662e  t..        self.
-00001e40: 7669 7375 616c 697a 6174 696f 6e20 3d20  visualization = 
-00001e50: 6465 6570 636f 7079 2876 6973 7561 6c69  deepcopy(visuali
-00001e60: 7a61 7469 6f6e 290d 0a20 2020 2020 2020  zation)..       
-00001e70: 2069 6620 5044 636f 6e74 726f 6c5b 305d   if PDcontrol[0]
-00001e80: 2021 3d20 4e6f 6e65 3a0d 0a20 2020 2020   != None:..     
-00001e90: 2020 2020 2020 2073 656c 662e 5044 636f         self.PDco
-00001ea0: 6e74 726f 6c20 3d20 5044 636f 6e74 726f  ntrol = PDcontro
-00001eb0: 6c0d 0a0d 0a20 2020 2023 2a2a 636c 6173  l....    #**clas
-00001ec0: 7346 756e 6374 696f 6e3a 2073 6574 2050  sFunction: set P
-00001ed0: 4420 636f 6e74 726f 6c20 7661 6c75 6573  D control values
-00001ee0: 2066 6f72 2064 7269 7665 206f 6620 6a6f   for drive of jo
-00001ef0: 696e 7420 7265 6c61 7465 6420 746f 206c  int related to l
-00001f00: 696e 6b20 7573 696e 6720 706f 7369 7469  ink using positi
-00001f10: 6f6e 2d70 726f 706f 7274 696f 6e61 6c20  on-proportional 
-00001f20: 7661 6c75 6520 5020 616e 6420 6469 6666  value P and diff
-00001f30: 6572 656e 7469 616c 2076 616c 7565 2028  erential value (
-00001f40: 7665 6c6f 6369 7479 2070 726f 706f 7274  velocity proport
-00001f50: 696f 6e61 6c29 2044 0d0a 2020 2020 6465  ional) D..    de
-00001f60: 6620 5365 7450 4463 6f6e 7472 6f6c 2873  f SetPDcontrol(s
-00001f70: 656c 662c 2050 7661 6c75 652c 2044 7661  elf, Pvalue, Dva
-00001f80: 6c75 6529 3a0d 0a20 2020 2020 2020 2073  lue):..        s
-00001f90: 656c 662e 5044 636f 6e74 726f 6c20 3d20  elf.PDcontrol = 
-00001fa0: 2850 7661 6c75 652c 2044 7661 6c75 6529  (Pvalue, Dvalue)
-00001fb0: 0d0a 0d0a 2020 2020 232a 2a63 6c61 7373  ....    #**class
-00001fc0: 4675 6e63 7469 6f6e 3a20 6368 6563 6b20  Function: check 
-00001fd0: 6966 2063 6f6e 7472 6c20 6973 2061 7661  if contrl is ava
-00001fe0: 696c 6162 6c65 0d0a 2020 2020 6465 6620  ilable..    def 
-00001ff0: 4861 7350 4463 6f6e 7472 6f6c 2873 656c  HasPDcontrol(sel
-00002000: 6629 3a0d 0a20 2020 2020 2020 2072 6574  f):..        ret
-00002010: 7572 6e20 6861 7361 7474 7228 7365 6c66  urn hasattr(self
-00002020: 2c20 2750 4463 6f6e 7472 6f6c 2729 0d0a  , 'PDcontrol')..
-00002030: 0d0a 2020 2020 232a 2a63 6c61 7373 4675  ..    #**classFu
-00002040: 6e63 7469 6f6e 3a20 6765 7420 5044 2063  nction: get PD c
-00002050: 6f6e 7472 6f6c 2076 616c 7565 730d 0a20  ontrol values.. 
-00002060: 2020 2064 6566 2047 6574 5044 636f 6e74     def GetPDcont
-00002070: 726f 6c28 7365 6c66 293a 0d0a 2020 2020  rol(self):..    
-00002080: 2020 2020 6966 206e 6f74 2068 6173 6174      if not hasat
-00002090: 7472 2873 656c 662c 2027 5044 636f 6e74  tr(self, 'PDcont
-000020a0: 726f 6c27 293a 0d0a 2020 2020 2020 2020  rol'):..        
-000020b0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-000020c0: 7272 6f72 2827 526f 626f 744c 696e 6b3a  rror('RobotLink:
-000020d0: 2050 4463 6f6e 7472 6f6c 2069 7320 6e6f   PDcontrol is no
-000020e0: 7420 6465 6669 6e65 6420 666f 7220 6c69  t defined for li
-000020f0: 6e6b 2120 5573 6520 5365 7450 4463 6f6e  nk! Use SetPDcon
-00002100: 7472 6f6c 2074 6f20 6465 6669 6e65 2070  trol to define p
-00002110: 6172 616d 6574 6572 7320 6265 666f 7265  arameters before
-00002120: 2075 7369 6e67 2729 0d0a 2020 2020 2020   using')..      
-00002130: 2020 7265 7475 726e 2073 656c 662e 5044    return self.PD
-00002140: 636f 6e74 726f 6c0d 0a0d 0a20 2020 2064  control....    d
-00002150: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
-00002160: 3a0d 0a20 2020 2020 2020 2073 203d 2027  :..        s = '
-00002170: 2020 6d61 7373 203d 2027 202b 2073 7472    mass = ' + str
-00002180: 2873 656c 662e 6d61 7373 290d 0a20 2020  (self.mass)..   
-00002190: 2020 2020 2073 202b 3d20 275c 6e20 2043       s += '\n  C
-000021a0: 4f4d 203d 2027 202b 2073 7472 2873 656c  OM = ' + str(sel
-000021b0: 662e 434f 4d29 0d0a 2020 2020 2020 2020  f.COM)..        
-000021c0: 7320 2b3d 2027 5c6e 2020 696e 6572 7469  s += '\n  inerti
-000021d0: 6120 3d20 2720 2b20 7374 7228 7365 6c66  a = ' + str(self
-000021e0: 2e69 6e65 7274 6961 290d 0a20 2020 2020  .inertia)..     
-000021f0: 2020 2073 202b 3d20 275c 6e20 206c 6f63     s += '\n  loc
-00002200: 616c 4854 203d 2027 202b 2073 7472 2873  alHT = ' + str(s
-00002210: 656c 662e 6c6f 6361 6c48 5429 0d0a 2020  elf.localHT)..  
-00002220: 2020 2020 2020 7320 2b3d 2027 5c6e 2020        s += '\n  
-00002230: 7072 6548 5420 3d20 2720 2b20 7374 7228  preHT = ' + str(
-00002240: 7365 6c66 2e70 7265 4854 290d 0a20 2020  self.preHT)..   
-00002250: 2020 2020 2073 202b 3d20 275c 6e20 206a       s += '\n  j
-00002260: 6f69 6e74 5479 7065 203d 2027 202b 2073  ointType = ' + s
-00002270: 7472 2873 656c 662e 6a6f 696e 7454 7970  tr(self.jointTyp
-00002280: 6529 0d0a 2020 2020 2020 2020 7320 2b3d  e)..        s +=
-00002290: 2027 5c6e 2020 7061 7265 6e74 203d 2027   '\n  parent = '
-000022a0: 202b 2073 7472 2873 656c 662e 7061 7265   + str(self.pare
-000022b0: 6e74 290d 0a20 2020 2020 2020 2073 202b  nt)..        s +
-000022c0: 3d20 275c 6e20 2076 6973 7561 6c69 7a61  = '\n  visualiza
-000022d0: 7469 6f6e 3a5c 6e27 202b 2073 7472 2873  tion:\n' + str(s
-000022e0: 656c 662e 7669 7375 616c 697a 6174 696f  elf.visualizatio
-000022f0: 6e29 0d0a 2020 2020 2020 2020 6966 2073  n)..        if s
-00002300: 656c 662e 4861 7350 4463 6f6e 7472 6f6c  elf.HasPDcontrol
-00002310: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-00002320: 2073 202b 3d20 275c 6e20 2050 4463 6f6e   s += '\n  PDcon
-00002330: 7472 6f6c 203d 2027 202b 2073 7472 2873  trol = ' + str(s
-00002340: 656c 662e 5044 636f 6e74 726f 6c29 0d0a  elf.PDcontrol)..
-00002350: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00002360: 0d0a 0d0a 2020 2020 6465 6620 5f5f 7265  ....    def __re
-00002370: 7072 5f5f 2873 656c 6629 3a0d 0a20 2020  pr__(self):..   
-00002380: 2020 2020 2072 6574 7572 6e20 7374 7228       return str(
-00002390: 7365 6c66 290d 0a20 2020 2020 2020 200d  self)..        .
-000023a0: 0a23 2a2a 636c 6173 733a 2063 6c61 7373  .#**class: class
-000023b0: 2074 6f20 6465 6669 6e65 2076 6973 7561   to define visua
-000023c0: 6c69 7a61 7469 6f6e 206f 6620 526f 626f  lization of Robo
-000023d0: 7454 6f6f 6c0d 0a63 6c61 7373 2056 526f  tTool..class VRo
-000023e0: 626f 7454 6f6f 6c3a 0d0a 2020 2020 232a  botTool:..    #*
-000023f0: 2a63 6c61 7373 4675 6e63 7469 6f6e 3a20  *classFunction: 
-00002400: 696e 6974 6961 6c69 7a65 2072 6f62 6f74  initialize robot
-00002410: 2074 6f6f 6c20 7769 7468 2070 6172 616d   tool with param
-00002420: 6574 6572 733b 2063 7572 7265 6e74 6c79  eters; currently
-00002430: 206f 6e6c 7920 6772 6170 6869 6373 4461   only graphicsDa
-00002440: 7461 2c20 7768 6963 6820 6973 2061 206c  ta, which is a l
-00002450: 6973 7420 6f66 2047 7261 7068 6963 7344  ist of GraphicsD
-00002460: 6174 6120 7361 6d65 2061 7320 696e 206d  ata same as in m
-00002470: 6273 204f 626a 6563 7473 0d0a 2020 2020  bs Objects..    
-00002480: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00002490: 662c 2067 7261 7068 6963 7344 6174 613d  f, graphicsData=
-000024a0: 5b5d 293a 0d0a 2020 2020 2020 2020 7365  []):..        se
-000024b0: 6c66 2e67 7261 7068 6963 7344 6174 6120  lf.graphicsData 
-000024c0: 3d20 636f 7079 2867 7261 7068 6963 7344  = copy(graphicsD
-000024d0: 6174 6129 0d0a 0d0a 232a 2a63 6c61 7373  ata)....#**class
-000024e0: 3a20 6465 6669 6e65 2074 6f6f 6c20 6f66  : define tool of
-000024f0: 2072 6f62 6f74 3a20 636f 6e74 6169 6e69   robot: containi
-00002500: 6e67 2067 7261 7068 6963 7320 616e 6420  ng graphics and 
-00002510: 4854 2028 6d61 7920 6164 6420 6665 6174  HT (may add feat
-00002520: 7572 6573 2069 6e20 6675 7475 7265 290d  ures in future).
-00002530: 0a63 6c61 7373 2052 6f62 6f74 546f 6f6c  .class RobotTool
-00002540: 3a0d 0a20 2020 2023 2a2a 636c 6173 7346  :..    #**classF
-00002550: 756e 6374 696f 6e3a 2069 6e69 7469 616c  unction: initial
-00002560: 697a 6520 726f 626f 7420 746f 6f6c 0d0a  ize robot tool..
-00002570: 2020 2020 232a 2a69 6e70 7574 3a0d 0a20      #**input:.. 
-00002580: 2020 2023 2020 4854 3a20 3478 3420 6d61     #  HT: 4x4 ma
-00002590: 7472 6978 2028 6c69 7374 206f 6620 6c69  trix (list of li
-000025a0: 7374 7320 2f20 6e75 6d70 7920 6172 7261  sts / numpy arra
-000025b0: 7929 2063 6f6e 7461 696e 696e 6720 686f  y) containing ho
-000025c0: 6d6f 6765 6e65 6f75 7320 7472 616e 7366  mogeneous transf
-000025d0: 6f72 6d61 7469 6f6e 2074 6f20 7472 616e  ormation to tran
-000025e0: 7366 6f72 6d20 6672 6f6d 206c 6173 7420  sform from last 
-000025f0: 6c69 6e6b 2074 6f20 746f 6f6c 0d0a 2020  link to tool..  
-00002600: 2020 2320 2067 7261 7068 6963 7344 6174    #  graphicsDat
-00002610: 613a 2064 6963 7469 6f6e 6172 7920 636f  a: dictionary co
-00002620: 6e74 6169 6e69 6e67 2061 206c 6973 7420  ntaining a list 
-00002630: 6f66 2047 7261 7068 6963 7344 6174 612c  of GraphicsData,
-00002640: 2073 616d 6520 6173 2069 6e20 6578 7564   same as in exud
-00002650: 796e 204f 626a 6563 7473 0d0a 2020 2020  yn Objects..    
-00002660: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00002670: 662c 2048 543d 6572 622e 4854 3028 292c  f, HT=erb.HT0(),
-00002680: 2076 6973 7561 6c69 7a61 7469 6f6e 3d56   visualization=V
-00002690: 526f 626f 7454 6f6f 6c28 2929 3a0d 0a20  RobotTool()):.. 
-000026a0: 2020 2020 2020 2073 656c 662e 4854 203d         self.HT =
-000026b0: 206e 702e 6172 7261 7928 4854 290d 0a20   np.array(HT).. 
-000026c0: 2020 2020 2020 2073 656c 662e 7669 7375         self.visu
-000026d0: 616c 697a 6174 696f 6e20 3d20 7669 7375  alization = visu
-000026e0: 616c 697a 6174 696f 6e0d 0a20 2020 2020  alization..     
-000026f0: 2020 200d 0a20 2020 2064 6566 205f 5f73     ..    def __s
-00002700: 7472 5f5f 2873 656c 6629 3a0d 0a20 2020  tr__(self):..   
-00002710: 2020 2020 2073 203d 2027 2020 4854 203d       s = '  HT =
-00002720: 2027 202b 2073 7472 2873 656c 662e 4854   ' + str(self.HT
-00002730: 290d 0a20 2020 2020 2020 2023 7320 2b3d  )..        #s +=
-00002740: 2027 5c6e 7669 7375 616c 697a 6174 696f   '\nvisualizatio
-00002750: 6e20 3d20 2720 2b20 7374 7228 7365 6c66  n = ' + str(self
-00002760: 2e76 6973 7561 6c69 7a61 7469 6f6e 290d  .visualization).
-00002770: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00002780: 730d 0a20 2020 2064 6566 205f 5f72 6570  s..    def __rep
-00002790: 725f 5f28 7365 6c66 293a 0d0a 2020 2020  r__(self):..    
-000027a0: 2020 2020 7265 7475 726e 2073 7472 2873      return str(s
-000027b0: 656c 6629 0d0a 0d0a 232a 2a63 6c61 7373  elf)....#**class
-000027c0: 3a20 636c 6173 7320 746f 2064 6566 696e  : class to defin
-000027d0: 6520 7669 7375 616c 697a 6174 696f 6e20  e visualization 
-000027e0: 6f66 2052 6f62 6f74 4261 7365 0d0a 636c  of RobotBase..cl
-000027f0: 6173 7320 5652 6f62 6f74 4261 7365 3a0d  ass VRobotBase:.
-00002800: 0a20 2020 2023 2a2a 636c 6173 7346 756e  .    #**classFun
-00002810: 6374 696f 6e3a 2069 6e69 7469 616c 697a  ction: initializ
-00002820: 6520 726f 626f 7420 6261 7365 2077 6974  e robot base wit
-00002830: 6820 7061 7261 6d65 7465 7273 3b20 6375  h parameters; cu
-00002840: 7272 656e 746c 7920 6f6e 6c79 2067 7261  rrently only gra
-00002850: 7068 6963 7344 6174 612c 2077 6869 6368  phicsData, which
-00002860: 2069 7320 6120 6c69 7374 206f 6620 4772   is a list of Gr
-00002870: 6170 6869 6373 4461 7461 2073 616d 6520  aphicsData same 
-00002880: 6173 2069 6e20 6d62 7320 4f62 6a65 6374  as in mbs Object
-00002890: 730d 0a20 2020 2064 6566 205f 5f69 6e69  s..    def __ini
-000028a0: 745f 5f28 7365 6c66 2c20 6772 6170 6869  t__(self, graphi
-000028b0: 6373 4461 7461 3d5b 5d29 3a0d 0a20 2020  csData=[]):..   
-000028c0: 2020 2020 2073 656c 662e 6772 6170 6869       self.graphi
-000028d0: 6373 4461 7461 203d 2063 6f70 7928 6772  csData = copy(gr
-000028e0: 6170 6869 6373 4461 7461 290d 0a0d 0a20  aphicsData).... 
-000028f0: 2020 200d 0a23 2a2a 636c 6173 733a 2064     ..#**class: d
-00002900: 6566 696e 6520 6261 7365 206f 6620 726f  efine base of ro
-00002910: 626f 743a 2063 6f6e 7461 696e 696e 6720  bot: containing 
-00002920: 6772 6170 6869 6373 2061 6e64 2048 5420  graphics and HT 
-00002930: 286d 6179 2061 6464 2066 6561 7475 7265  (may add feature
-00002940: 7320 696e 2066 7574 7572 6529 0d0a 636c  s in future)..cl
-00002950: 6173 7320 526f 626f 7442 6173 653a 0d0a  ass RobotBase:..
-00002960: 2020 2020 232a 2a63 6c61 7373 4675 6e63      #**classFunc
-00002970: 7469 6f6e 3a20 696e 6974 6961 6c69 7a65  tion: initialize
-00002980: 2072 6f62 6f74 2062 6173 650d 0a20 2020   robot base..   
-00002990: 2023 2a2a 696e 7075 743a 0d0a 2020 2020   #**input:..    
-000029a0: 2320 2048 543a 2034 7834 206d 6174 7269  #  HT: 4x4 matri
-000029b0: 7820 286c 6973 7420 6f66 206c 6973 7473  x (list of lists
-000029c0: 202f 206e 756d 7079 2061 7272 6179 2920   / numpy array) 
-000029d0: 636f 6e74 6169 6e69 6e67 2068 6f6d 6f67  containing homog
-000029e0: 656e 656f 7573 2074 7261 6e73 666f 726d  eneous transform
-000029f0: 6174 696f 6e20 746f 2074 7261 6e73 666f  ation to transfo
-00002a00: 726d 2066 726f 6d20 776f 726c 6420 636f  rm from world co
-00002a10: 6f72 6469 6e61 7465 7320 746f 2062 6173  ordinates to bas
-00002a20: 6520 636f 6f72 6469 6e61 7465 7320 2863  e coordinates (c
-00002a30: 6861 6e67 6573 206f 7269 656e 7461 7469  hanges orientati
-00002a40: 6f6e 2061 6e64 2070 6f73 6974 696f 6e20  on and position 
-00002a50: 6f66 2072 6f62 6f74 290d 0a20 2020 2023  of robot)..    #
-00002a60: 2020 6772 6170 6869 6373 4461 7461 3a20    graphicsData: 
-00002a70: 6469 6374 696f 6e61 7279 2063 6f6e 7461  dictionary conta
-00002a80: 696e 696e 6720 6120 6c69 7374 206f 6620  ining a list of 
-00002a90: 4772 6170 6869 6373 4461 7461 2c20 7361  GraphicsData, sa
-00002aa0: 6d65 2061 7320 696e 2065 7875 6479 6e20  me as in exudyn 
-00002ab0: 4f62 6a65 6374 730d 0a20 2020 2064 6566  Objects..    def
-00002ac0: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
-00002ad0: 4854 3d65 7262 2e48 5430 2829 2c20 7669  HT=erb.HT0(), vi
-00002ae0: 7375 616c 697a 6174 696f 6e3d 5652 6f62  sualization=VRob
-00002af0: 6f74 4261 7365 2829 293a 0d0a 2020 2020  otBase()):..    
-00002b00: 2020 2020 7365 6c66 2e48 5420 3d20 6e70      self.HT = np
-00002b10: 2e61 7272 6179 2848 5429 0d0a 2020 2020  .array(HT)..    
-00002b20: 2020 2020 7365 6c66 2e76 6973 7561 6c69      self.visuali
-00002b30: 7a61 7469 6f6e 203d 2076 6973 7561 6c69  zation = visuali
-00002b40: 7a61 7469 6f6e 0d0a 2020 2020 0d0a 2020  zation..    ..  
-00002b50: 2020 6465 6620 5f5f 7374 725f 5f28 7365    def __str__(se
-00002b60: 6c66 293a 0d0a 2020 2020 2020 2020 7320  lf):..        s 
-00002b70: 3d20 2720 2048 5420 3d20 2720 2b20 7374  = '  HT = ' + st
-00002b80: 7228 7365 6c66 2e48 5429 0d0a 2020 2020  r(self.HT)..    
-00002b90: 2020 2020 2373 202b 3d20 275c 6e76 6973      #s += '\nvis
-00002ba0: 7561 6c69 7a61 7469 6f6e 203d 2027 202b  ualization = ' +
-00002bb0: 2073 7472 2873 656c 662e 7669 7375 616c   str(self.visual
-00002bc0: 697a 6174 696f 6e29 0d0a 2020 2020 2020  ization)..      
-00002bd0: 2020 7265 7475 726e 2073 0d0a 0d0a 2020    return s....  
-00002be0: 2020 6465 6620 5f5f 7265 7072 5f5f 2873    def __repr__(s
-00002bf0: 656c 6629 3a0d 0a20 2020 2020 2020 2072  elf):..        r
-00002c00: 6574 7572 6e20 7374 7228 7365 6c66 290d  eturn str(self).
-00002c10: 0a0d 0a0d 0a62 7569 6c64 4672 6f6d 4469  .....buildFromDi
-00002c20: 6374 696f 6e61 7279 5761 726e 6564 203d  ctionaryWarned =
-00002c30: 2046 616c 7365 2023 646f 206e 6f74 2075   False #do not u
-00002c40: 7365 2074 6869 7320 7661 7269 6162 6c65  se this variable
-00002c50: 2c20 6974 2069 7320 666f 7220 6465 7072  , it is for depr
-00002c60: 6563 6174 696f 6e20 7761 726e 696e 6773  ecation warnings
-00002c70: 210d 0a23 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  !..#++++++++++++
+00000be0: 6e74 2066 6f72 206c 6f63 616c 2059 2061  nt for local Y a
+00000bf0: 7869 730a 2020 2020 2750 7a27 3a6e 702e  xis.    'Pz':np.
+00000c00: 6172 7261 7928 5b30 2c30 2c31 5d29 2c20  array([0,0,1]), 
+00000c10: 2370 7269 736d 6174 6963 206a 6f69 6e74  #prismatic joint
+00000c20: 2066 6f72 206c 6f63 616c 205a 2061 7869   for local Z axi
+00000c30: 730a 2020 2020 7d0a 0a23 6d61 7073 206a  s.    }..#maps j
+00000c40: 6f69 6e74 2074 7970 6520 746f 2028 636f  oint type to (co
+00000c50: 6e73 7472 6169 6e65 6429 2063 6f6f 7264  nstrained) coord
+00000c60: 696e 6174 6520 302e 2e32 3a20 7472 616e  inate 0..2: tran
+00000c70: 736c 6174 696f 6e2c 2033 2e2e 353a 2072  slation, 3..5: r
+00000c80: 6f74 6174 696f 6e0a 6469 6374 4a6f 696e  otation.dictJoin
+00000c90: 7454 7970 6532 636f 6f72 6469 6e61 7465  tType2coordinate
+00000ca0: 3644 203d 207b 0a20 2020 2027 5078 273a  6D = {.    'Px':
+00000cb0: 302c 2023 7265 766f 6c75 7465 206a 6f69  0, #revolute joi
+00000cc0: 6e74 2066 6f72 206c 6f63 616c 2058 2061  nt for local X a
+00000cd0: 7869 730a 2020 2020 2750 7927 3a31 2c20  xis.    'Py':1, 
+00000ce0: 2372 6576 6f6c 7574 6520 6a6f 696e 7420  #revolute joint 
+00000cf0: 666f 7220 6c6f 6361 6c20 5920 6178 6973  for local Y axis
+00000d00: 0a20 2020 2027 507a 273a 322c 2023 7265  .    'Pz':2, #re
+00000d10: 766f 6c75 7465 206a 6f69 6e74 2066 6f72  volute joint for
+00000d20: 206c 6f63 616c 205a 2061 7869 730a 2020   local Z axis.  
+00000d30: 2020 2752 7827 3a33 2c20 2370 7269 736d    'Rx':3, #prism
+00000d40: 6174 6963 206a 6f69 6e74 2066 6f72 206c  atic joint for l
+00000d50: 6f63 616c 2058 2061 7869 730a 2020 2020  ocal X axis.    
+00000d60: 2752 7927 3a34 2c20 2370 7269 736d 6174  'Ry':4, #prismat
+00000d70: 6963 206a 6f69 6e74 2066 6f72 206c 6f63  ic joint for loc
+00000d80: 616c 2059 2061 7869 730a 2020 2020 2752  al Y axis.    'R
+00000d90: 7a27 3a35 2c20 2370 7269 736d 6174 6963  z':5, #prismatic
+00000da0: 206a 6f69 6e74 2066 6f72 206c 6f63 616c   joint for local
+00000db0: 205a 2061 7869 730a 7d0a 0a23 526f 626f   Z axis.}..#Robo
+00000dc0: 744c 696e 6b20 6368 616e 6765 7320 3230  tLink changes 20
+00000dd0: 3231 2d30 382d 3136 3a0a 236c 6f63 616c  21-08-16:.#local
+00000de0: 6572 622e 4854 2d3e 6c6f 6361 6c65 7262  erb.HT->localerb
+00000df0: 2e48 5420 2864 6f65 7320 6e6f 7420 696e  .HT (does not in
+00000e00: 636c 7564 6520 726f 7461 7469 6f6e 293b  clude rotation);
+00000e10: 2074 6869 7320 6a6f 696e 7420 746f 2074   this joint to t
+00000e20: 6869 7320 6c69 6e6b 2065 7262 2e48 540a  his link erb.HT.
+00000e30: 2361 6464 2070 7265 6572 622e 4854 3a20  #add preerb.HT: 
+00000e40: 7072 6576 696f 7573 206c 696e 6b20 746f  previous link to
+00000e50: 2074 6869 7320 6a6f 696e 7420 6572 622e   this joint erb.
+00000e60: 4854 0a23 6469 6374 4a6f 696e 7454 7970  HT.#dictJointTyp
+00000e70: 6532 6572 622e 4854 5b6c 696e 6b2e 6a6f  e2erb.HT[link.jo
+00000e80: 696e 7454 7970 655d 2871 5b69 5d29 3a20  intType](q[i]): 
+00000e90: 6465 6669 6e65 7320 6a6f 696e 7420 6572  defines joint er
+00000ea0: 622e 4854 0a23 6c6f 6361 6c65 7262 2e48  b.HT.#localerb.H
+00000eb0: 5420 696e 204d 4253 206d 6f64 656c 696e  T in MBS modelin
+00000ec0: 6720 2869 6e65 7274 6961 2c20 6574 632e  g (inertia, etc.
+00000ed0: 2920 6973 206b 6570 7420 7361 6d65 2c20  ) is kept same, 
+00000ee0: 7768 696c 6520 6c6f 6361 6c65 7262 2e48  while localerb.H
+00000ef0: 5420 3d20 4944 3420 666f 7220 4d6f 6444  T = ID4 for ModD
+00000f00: 480a 2370 7265 6572 622e 4854 206d 7573  H.#preerb.HT mus
+00000f10: 7420 6265 2061 6464 6564 2066 6f72 206a  t be added for j
+00000f20: 6f69 6e74 2061 7865 7320 6465 6669 6e69  oint axes defini
+00000f30: 7469 6f6e 7320 616e 6420 666f 7220 6375  tions and for cu
+00000f40: 7272 656e 7448 540a 2369 6e65 7274 6961  rrentHT.#inertia
+00000f50: 2061 6e64 2043 4f4d 206e 6565 6420 746f   and COM need to
+00000f60: 2062 6520 636f 6e76 6572 7465 6420 6279   be converted by
+00000f70: 206c 6f63 616c 4854 206f 6620 5374 6444   localHT of StdD
+00000f80: 4820 696e 746f 204d 6f64 4448 2063 6f6e  H into ModDH con
+00000f90: 6669 6775 7261 7469 6f6e 2121 210a 0a23  figuration!!!..#
+00000fa0: 2a2a 636c 6173 733a 2063 6c61 7373 2074  **class: class t
+00000fb0: 6f20 6465 6669 6e65 2076 6973 7561 6c69  o define visuali
+00000fc0: 7a61 7469 6f6e 206f 6620 526f 626f 744c  zation of RobotL
+00000fd0: 696e 6b0a 636c 6173 7320 5652 6f62 6f74  ink.class VRobot
+00000fe0: 4c69 6e6b 3a0a 2020 2020 232a 2a63 6c61  Link:.    #**cla
+00000ff0: 7373 4675 6e63 7469 6f6e 3a20 696e 6974  ssFunction: init
+00001000: 6961 6c69 7a65 2072 6f62 6f74 206c 696e  ialize robot lin
+00001010: 6b20 7769 7468 2070 6172 616d 6574 6572  k with parameter
+00001020: 732c 2062 6569 6e67 2073 656c 662d 6578  s, being self-ex
+00001030: 706c 6169 6e69 6e67 0a20 2020 2023 2a2a  plaining.    #**
+00001040: 696e 7075 743a 0a20 2020 2023 2020 6a6f  input:.    #  jo
+00001050: 696e 7452 6164 6975 733a 2072 6164 6975  intRadius: radiu
+00001060: 7320 6f66 206a 6f69 6e74 2074 6f20 6472  s of joint to dr
+00001070: 6177 0a20 2020 2023 2020 6a6f 696e 7457  aw.    #  jointW
+00001080: 6964 7468 3a20 6c65 6e67 7468 206f 7220  idth: length or 
+00001090: 7769 6474 6820 6f66 206a 6f69 6e74 2028  width of joint (
+000010a0: 6465 7065 6e64 696e 6720 6f6e 2074 7970  depending on typ
+000010b0: 6520 6f66 206a 6f69 6e74 290a 2020 2020  e of joint).    
+000010c0: 2320 2073 686f 774d 4253 6a6f 696e 743a  #  showMBSjoint:
+000010d0: 2069 6620 4661 6c73 652c 206a 6f69 6e74   if False, joint
+000010e0: 2069 7320 6e6f 7420 6472 6177 6e0a 2020   is not drawn.  
+000010f0: 2020 2320 206c 696e 6b57 6964 7468 3a20    #  linkWidth: 
+00001100: 7769 6474 6820 6f66 206c 696e 6b20 666f  width of link fo
+00001110: 7220 6465 6661 756c 7420 6472 6177 696e  r default drawin
+00001120: 670a 2020 2020 2320 206c 696e 6b43 6f6c  g.    #  linkCol
+00001130: 6f72 3a20 636f 6c6f 7220 6f66 206c 696e  or: color of lin
+00001140: 6b20 666f 7220 6465 6661 756c 7420 6472  k for default dr
+00001150: 6177 696e 670a 2020 2020 2320 2073 686f  awing.    #  sho
+00001160: 7743 4f4d 3a20 6966 2054 7275 652c 2063  wCOM: if True, c
+00001170: 656e 7465 7220 6f66 206d 6173 7320 6973  enter of mass is
+00001180: 206d 6172 6b65 6420 7769 7468 2063 7562   marked with cub
+00001190: 650a 2020 2020 2320 2067 7261 7068 6963  e.    #  graphic
+000011a0: 7344 6174 613a 206c 6973 7420 6f66 2047  sData: list of G
+000011b0: 7261 7068 6963 7344 6174 6120 746f 2072  raphicsData to r
+000011c0: 6570 7265 7365 6e74 206c 696e 6b3b 2069  epresent link; i
+000011d0: 6620 6c69 7374 2069 7320 656d 7074 792c  f list is empty,
+000011e0: 206c 696e 6b20 6772 6170 6869 6373 2077   link graphics w
+000011f0: 696c 6c20 6265 2067 656e 6572 6174 6564  ill be generated
+00001200: 2066 726f 6d20 6c69 6e6b 2067 656f 6d65   from link geome
+00001210: 7472 7920 6461 7461 3b20 6f74 6865 7277  try data; otherw
+00001220: 6973 652c 2064 7261 7769 6e67 2077 696c  ise, drawing wil
+00001230: 6c20 6265 2074 616b 656e 2066 726f 6d20  l be taken from 
+00001240: 6772 6170 6869 6373 4461 7461 2c20 616e  graphicsData, an
+00001250: 6420 6f6e 6c79 2073 686f 774d 4253 6a6f  d only showMBSjo
+00001260: 696e 7420 616e 6420 7368 6f77 434f 4d20  int and showCOM 
+00001270: 666c 6167 7320 7769 6c6c 2061 6464 2061  flags will add a
+00001280: 6464 6974 696f 6e61 6c20 6772 6170 6869  dditional graphi
+00001290: 6373 0a20 2020 2064 6566 205f 5f69 6e69  cs.    def __ini
+000012a0: 745f 5f28 7365 6c66 2c20 6a6f 696e 7452  t__(self, jointR
+000012b0: 6164 6975 7320 3d20 302e 3036 2c20 6a6f  adius = 0.06, jo
+000012c0: 696e 7457 6964 7468 203d 2030 2e31 322c  intWidth = 0.12,
+000012d0: 206c 696e 6b57 6964 7468 203d 2030 2e31   linkWidth = 0.1
+000012e0: 2c20 7368 6f77 4d42 536a 6f69 6e74 203d  , showMBSjoint =
+000012f0: 2054 7275 652c 2073 686f 7743 4f4d 203d   True, showCOM =
+00001300: 2054 7275 652c 200a 2020 2020 2020 2020   True, .        
+00001310: 2020 2020 2020 2020 206c 696e 6b43 6f6c           linkCol
+00001320: 6f72 203d 205b 302e 342c 302e 342c 302e  or = [0.4,0.4,0.
+00001330: 342c 315d 2c20 6772 6170 6869 6373 4461  4,1], graphicsDa
+00001340: 7461 203d 205b 5d20 293a 0a20 2020 2020  ta = [] ):.     
+00001350: 2020 2073 656c 662e 6a6f 696e 7452 6164     self.jointRad
+00001360: 6975 7320 3d20 6a6f 696e 7452 6164 6975  ius = jointRadiu
+00001370: 730a 2020 2020 2020 2020 7365 6c66 2e6a  s.        self.j
+00001380: 6f69 6e74 5769 6474 6820 3d20 6a6f 696e  ointWidth = join
+00001390: 7457 6964 7468 200a 2020 2020 2020 2020  tWidth .        
+000013a0: 7365 6c66 2e73 686f 774d 4253 6a6f 696e  self.showMBSjoin
+000013b0: 7420 3d20 7368 6f77 4d42 536a 6f69 6e74  t = showMBSjoint
+000013c0: 0a20 2020 2020 2020 2073 656c 662e 6c69  .        self.li
+000013d0: 6e6b 5769 6474 6820 3d20 6c69 6e6b 5769  nkWidth = linkWi
+000013e0: 6474 6820 0a20 2020 2020 2020 2073 656c  dth .        sel
+000013f0: 662e 6c69 6e6b 436f 6c6f 7220 3d20 6c69  f.linkColor = li
+00001400: 6e6b 436f 6c6f 720a 2020 2020 2020 2020  nkColor.        
+00001410: 7365 6c66 2e73 686f 7743 4f4d 203d 2073  self.showCOM = s
+00001420: 686f 7743 4f4d 0a20 2020 2020 2020 2073  howCOM.        s
+00001430: 656c 662e 6772 6170 6869 6373 4461 7461  elf.graphicsData
+00001440: 203d 2067 7261 7068 6963 7344 6174 610a   = graphicsData.
+00001450: 0a20 2020 2064 6566 205f 5f73 7472 5f5f  .    def __str__
+00001460: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00001470: 7320 3d20 2720 206a 6f69 6e74 5261 6469  s = '  jointRadi
+00001480: 7573 203d 2027 202b 2073 7472 2873 656c  us = ' + str(sel
+00001490: 662e 6a6f 696e 7452 6164 6975 7329 0a20  f.jointRadius). 
+000014a0: 2020 2020 2020 2073 202b 3d20 275c 6e20         s += '\n 
+000014b0: 206a 6f69 6e74 5769 6474 6820 3d20 2720   jointWidth = ' 
+000014c0: 2b20 7374 7228 7365 6c66 2e6a 6f69 6e74  + str(self.joint
+000014d0: 5769 6474 6829 0a20 2020 2020 2020 2073  Width).        s
+000014e0: 202b 3d20 275c 6e20 2073 686f 774d 4253   += '\n  showMBS
+000014f0: 6a6f 696e 7420 3d20 2720 2b20 7374 7228  joint = ' + str(
+00001500: 7365 6c66 2e73 686f 774d 4253 6a6f 696e  self.showMBSjoin
+00001510: 7429 0a20 2020 2020 2020 2073 202b 3d20  t).        s += 
+00001520: 275c 6e20 206c 696e 6b57 6964 7468 203d  '\n  linkWidth =
+00001530: 2027 202b 2073 7472 2873 656c 662e 6c69   ' + str(self.li
+00001540: 6e6b 5769 6474 6829 0a20 2020 2020 2020  nkWidth).       
+00001550: 2073 202b 3d20 275c 6e20 206c 696e 6b43   s += '\n  linkC
+00001560: 6f6c 6f72 203d 2027 202b 2073 7472 2873  olor = ' + str(s
+00001570: 656c 662e 6c69 6e6b 436f 6c6f 7229 0a20  elf.linkColor). 
+00001580: 2020 2020 2020 2073 202b 3d20 275c 6e20         s += '\n 
+00001590: 2073 686f 7743 4f4d 203d 2027 202b 2073   showCOM = ' + s
+000015a0: 7472 2873 656c 662e 7368 6f77 434f 4d29  tr(self.showCOM)
+000015b0: 0a20 2020 2020 2020 2067 4461 7461 5374  .        gDataSt
+000015c0: 7220 3d20 2727 0a20 2020 2020 2020 2069  r = ''.        i
+000015d0: 6620 6c65 6e28 7365 6c66 2e67 7261 7068  f len(self.graph
+000015e0: 6963 7344 6174 6129 2021 3d20 303a 0a20  icsData) != 0:. 
+000015f0: 2020 2020 2020 2020 2020 2067 4461 7461             gData
+00001600: 5374 7220 3d20 272e 2e2e 270a 2020 2020  Str = '...'.    
+00001610: 2020 2020 7320 2b3d 2027 5c6e 2020 6772      s += '\n  gr
+00001620: 6170 6869 6373 4461 7461 203d 205b 2720  aphicsData = [' 
+00001630: 2b20 6744 6174 6153 7472 202b 2027 5d27  + gDataStr + ']'
+00001640: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
+00001650: 2020 2020 2020 7265 7475 726e 2073 0a20        return s. 
+00001660: 2020 2064 6566 205f 5f72 6570 725f 5f28     def __repr__(
+00001670: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00001680: 6574 7572 6e20 7374 7228 7365 6c66 290a  eturn str(self).
+00001690: 0a0a 232a 2a63 6c61 7373 3a20 636c 6173  ..#**class: clas
+000016a0: 7320 746f 2064 6566 696e 6520 6f6e 6520  s to define one 
+000016b0: 6c69 6e6b 206f 6620 6120 726f 626f 740a  link of a robot.
+000016c0: 636c 6173 7320 526f 626f 744c 696e 6b3a  class RobotLink:
+000016d0: 0a20 2020 2023 2a2a 636c 6173 7346 756e  .    #**classFun
+000016e0: 6374 696f 6e3a 2069 6e69 7469 616c 697a  ction: initializ
+000016f0: 6520 726f 626f 7420 6c69 6e6b 0a20 2020  e robot link.   
+00001700: 2023 2a2a 696e 7075 743a 0a20 2020 2023   #**input:.    #
+00001710: 2020 6d61 7373 3a20 6d61 7373 206f 6620    mass: mass of 
+00001720: 726f 626f 7420 6c69 6e6b 0a20 2020 2023  robot link.    #
+00001730: 2020 434f 4d3a 2063 656e 7465 7220 6f66    COM: center of
+00001740: 206d 6173 7320 696e 206c 696e 6b20 636f   mass in link co
+00001750: 6f72 6469 6e61 7465 2073 7973 7465 6d0a  ordinate system.
+00001760: 2020 2020 2320 2069 6e65 7274 6961 3a20      #  inertia: 
+00001770: 3378 3320 6d61 7472 6978 2028 6c69 7374  3x3 matrix (list
+00001780: 206f 6620 6c69 7374 7320 2f20 6e75 6d70   of lists / nump
+00001790: 7920 6172 7261 7929 2063 6f6e 7461 696e  y array) contain
+000017a0: 696e 6720 696e 6572 7469 6120 7465 6e73  ing inertia tens
+000017b0: 6f72 2069 6e20 6c69 6e6b 2063 6f6f 7264  or in link coord
+000017c0: 696e 6174 6573 2c20 7769 7468 2072 6573  inates, with res
+000017d0: 7065 6374 2074 6f20 6365 6e74 6572 206f  pect to center o
+000017e0: 6620 6d61 7373 0a20 2020 2023 2020 6c6f  f mass.    #  lo
+000017f0: 6361 6c48 543a 2034 7834 206d 6174 7269  calHT: 4x4 matri
+00001800: 7820 286c 6973 7420 6f66 206c 6973 7473  x (list of lists
+00001810: 202f 206e 756d 7079 2061 7272 6179 2920   / numpy array) 
+00001820: 636f 6e74 6169 6e69 6e67 2068 6f6d 6f67  containing homog
+00001830: 656e 656f 7573 2074 7261 6e73 666f 726d  eneous transform
+00001840: 6174 696f 6e20 6672 6f6d 206c 6f63 616c  ation from local
+00001850: 206a 6f69 6e74 2074 6f20 6c69 6e6b 2063   joint to link c
+00001860: 6f6f 7264 696e 6174 6573 3b20 6465 6661  oordinates; defa
+00001870: 756c 7420 3d20 6964 656e 7469 7479 3b20  ult = identity; 
+00001880: 6375 7272 656e 746c 792c 2074 6869 7320  currently, this 
+00001890: 7472 616e 7366 6f72 6d61 7469 6f6e 2069  transformation i
+000018a0: 7320 6e6f 7420 6176 6169 6c61 626c 6520  s not available 
+000018b0: 696e 204b 696e 656d 6174 6963 5472 6565  in KinematicTree
+000018c0: 2c20 7468 6572 6566 6f72 6520 7468 6520  , therefore the 
+000018d0: 6c69 6e6b 2069 6e65 7274 6961 2061 6e64  link inertia and
+000018e0: 2043 4f4d 206d 7573 7420 6265 2074 7261   COM must be tra
+000018f0: 6e73 666f 726d 6564 2061 6363 6f72 6469  nsformed accordi
+00001900: 6e67 6c79 0a20 2020 2023 2020 7072 6548  ngly.    #  preH
+00001910: 543a 2034 7834 206d 6174 7269 7820 286c  T: 4x4 matrix (l
+00001920: 6973 7420 6f66 206c 6973 7473 202f 206e  ist of lists / n
+00001930: 756d 7079 2061 7272 6179 2920 636f 6e74  umpy array) cont
+00001940: 6169 6e69 6e67 2068 6f6d 6f67 656e 656f  aining homogeneo
+00001950: 7573 2074 7261 6e73 666f 726d 6174 696f  us transformatio
+00001960: 6e20 6672 6f6d 2070 7265 7669 6f75 7320  n from previous 
+00001970: 6c69 6e6b 2074 6f20 7468 6973 206a 6f69  link to this joi
+00001980: 6e74 3b20 6465 6661 756c 7420 3d20 6964  nt; default = id
+00001990: 656e 7469 7479 0a20 2020 2023 2020 6a6f  entity.    #  jo
+000019a0: 696e 7454 7970 653a 2073 7472 696e 6720  intType: string 
+000019b0: 636f 6e74 6169 6e69 6e67 206a 6f69 6e74  containing joint
+000019c0: 2074 7970 652c 206f 7574 206f 663a 2027   type, out of: '
+000019d0: 5278 272c 2027 5279 272c 2027 527a 2720  Rx', 'Ry', 'Rz' 
+000019e0: 666f 7220 7265 766f 6c75 7465 206a 6f69  for revolute joi
+000019f0: 6e74 7320 616e 6420 2750 7827 2c20 2750  nts and 'Px', 'P
+00001a00: 7927 2c20 2750 7a27 2066 6f72 2070 7269  y', 'Pz' for pri
+00001a10: 736d 6174 6963 206a 6f69 6e74 7320 6172  smatic joints ar
+00001a20: 6f75 6e64 2f61 6c6f 6e67 2074 6865 2072  ound/along the r
+00001a30: 6573 7065 6369 7469 7665 206c 6f63 616c  especitive local
+00001a40: 2061 7865 730a 2020 2020 2320 2070 6172   axes.    #  par
+00001a50: 656e 743a 2066 6f72 2062 7569 6c64 696e  ent: for buildin
+00001a60: 6720 726f 626f 7473 2061 7320 6b69 6e65  g robots as kine
+00001a70: 6d61 7469 6320 7472 6565 3b20 7573 6520  matic tree; use 
+00001a80: 272d 3227 2074 6f20 6175 746f 6d61 7469  '-2' to automati
+00001a90: 6361 6c6c 7920 7365 7420 7061 7265 6e74  cally set parent
+00001aa0: 7320 666f 7220 7365 7269 616c 2072 6f62  s for serial rob
+00001ab0: 6f74 2028 6f6e 2066 6978 6564 2062 6173  ot (on fixed bas
+00001ac0: 6529 2c20 7573 6520 272d 3127 2066 6f72  e), use '-1' for
+00001ad0: 2067 726f 756e 642d 7061 7265 6e74 2061   ground-parent a
+00001ae0: 6e64 2061 6e79 206f 7468 6572 2030 2d62  nd any other 0-b
+00001af0: 6173 6564 2069 6e64 6578 2066 6f72 2063  ased index for c
+00001b00: 6f6e 6e65 6374 696f 6e20 746f 2070 6172  onnection to par
+00001b10: 656e 7420 6c69 6e6b 0a20 2020 2023 2020  ent link.    #  
+00001b20: 5044 636f 6e74 726f 6c3a 2074 7570 6c65  PDcontrol: tuple
+00001b30: 206f 6620 5020 616e 6420 4420 636f 6e74   of P and D cont
+00001b40: 726f 6c20 7661 6c75 6573 2c20 6465 6669  rol values, defi
+00001b50: 6e69 6e67 2070 6f73 6974 696f 6e20 2872  ning position (r
+00001b60: 6f74 6174 696f 6e29 2070 726f 706f 7274  otation) proport
+00001b70: 696f 6e61 6c20 7661 6c75 6520 5020 616e  ional value P an
+00001b80: 6420 7665 6c6f 6369 7469 7920 7072 6f70  d velocitiy prop
+00001b90: 6f72 7469 6f6e 616c 2076 616c 7565 2044  ortional value D
+00001ba0: 0a20 2020 2023 2020 7669 7375 616c 697a  .    #  visualiz
+00001bb0: 6174 696f 6e3a 2056 526f 626f 744c 696e  ation: VRobotLin
+00001bc0: 6b20 7374 7275 6374 7572 6520 636f 6e74  k structure cont
+00001bd0: 6169 6e69 6e67 206f 7074 696f 6e73 2066  aining options f
+00001be0: 6f72 2064 7261 7769 6e67 206f 6620 6c69  or drawing of li
+00001bf0: 6e6b 2061 6e64 206a 6f69 6e74 733b 2073  nk and joints; s
+00001c00: 6565 2063 6c61 7373 2056 526f 626f 744c  ee class VRobotL
+00001c10: 696e 6b0a 2020 2020 6465 6620 5f5f 696e  ink.    def __in
+00001c20: 6974 5f5f 2873 656c 662c 206d 6173 732c  it__(self, mass,
+00001c30: 2043 4f4d 2c20 696e 6572 7469 612c 206c   COM, inertia, l
+00001c40: 6f63 616c 4854 3d65 7262 2e48 5430 2829  ocalHT=erb.HT0()
+00001c50: 2c20 6a6f 696e 7454 7970 653d 2752 7a27  , jointType='Rz'
+00001c60: 2c20 7061 7265 6e74 3d2d 322c 2070 7265  , parent=-2, pre
+00001c70: 4854 3d65 7262 2e48 5430 2829 2c20 5044  HT=erb.HT0(), PD
+00001c80: 636f 6e74 726f 6c3d 284e 6f6e 652c 4e6f  control=(None,No
+00001c90: 6e65 292c 2076 6973 7561 6c69 7a61 7469  ne), visualizati
+00001ca0: 6f6e 3d56 526f 626f 744c 696e 6b28 2929  on=VRobotLink())
+00001cb0: 3a0a 2020 2020 2020 2020 7365 6c66 2e6d  :.        self.m
+00001cc0: 6173 7320 3d20 6d61 7373 0a20 2020 2020  ass = mass.     
+00001cd0: 2020 2073 656c 662e 434f 4d20 3d20 6e70     self.COM = np
+00001ce0: 2e61 7272 6179 2843 4f4d 290a 2020 2020  .array(COM).    
+00001cf0: 2020 2020 7365 6c66 2e69 6e65 7274 6961      self.inertia
+00001d00: 203d 206e 702e 6172 7261 7928 696e 6572   = np.array(iner
+00001d10: 7469 6129 0a20 2020 2020 2020 2073 656c  tia).        sel
+00001d20: 662e 6c6f 6361 6c48 5420 3d20 6e70 2e61  f.localHT = np.a
+00001d30: 7272 6179 286c 6f63 616c 4854 290a 2020  rray(localHT).  
+00001d40: 2020 2020 2020 7365 6c66 2e70 7265 4854        self.preHT
+00001d50: 203d 206e 702e 6172 7261 7928 7072 6548   = np.array(preH
+00001d60: 5429 0a20 2020 2020 2020 2073 656c 662e  T).        self.
+00001d70: 6a6f 696e 7454 7970 6520 3d20 6a6f 696e  jointType = join
+00001d80: 7454 7970 650a 2020 2020 2020 2020 7365  tType.        se
+00001d90: 6c66 2e70 6172 656e 7420 3d20 7061 7265  lf.parent = pare
+00001da0: 6e74 0a20 2020 2020 2020 2073 656c 662e  nt.        self.
+00001db0: 7669 7375 616c 697a 6174 696f 6e20 3d20  visualization = 
+00001dc0: 6465 6570 636f 7079 2876 6973 7561 6c69  deepcopy(visuali
+00001dd0: 7a61 7469 6f6e 290a 2020 2020 2020 2020  zation).        
+00001de0: 6966 2050 4463 6f6e 7472 6f6c 5b30 5d20  if PDcontrol[0] 
+00001df0: 213d 204e 6f6e 653a 0a20 2020 2020 2020  != None:.       
+00001e00: 2020 2020 2073 656c 662e 5044 636f 6e74       self.PDcont
+00001e10: 726f 6c20 3d20 5044 636f 6e74 726f 6c0a  rol = PDcontrol.
+00001e20: 0a20 2020 2023 2a2a 636c 6173 7346 756e  .    #**classFun
+00001e30: 6374 696f 6e3a 2073 6574 2050 4420 636f  ction: set PD co
+00001e40: 6e74 726f 6c20 7661 6c75 6573 2066 6f72  ntrol values for
+00001e50: 2064 7269 7665 206f 6620 6a6f 696e 7420   drive of joint 
+00001e60: 7265 6c61 7465 6420 746f 206c 696e 6b20  related to link 
+00001e70: 7573 696e 6720 706f 7369 7469 6f6e 2d70  using position-p
+00001e80: 726f 706f 7274 696f 6e61 6c20 7661 6c75  roportional valu
+00001e90: 6520 5020 616e 6420 6469 6666 6572 656e  e P and differen
+00001ea0: 7469 616c 2076 616c 7565 2028 7665 6c6f  tial value (velo
+00001eb0: 6369 7479 2070 726f 706f 7274 696f 6e61  city proportiona
+00001ec0: 6c29 2044 0a20 2020 2064 6566 2053 6574  l) D.    def Set
+00001ed0: 5044 636f 6e74 726f 6c28 7365 6c66 2c20  PDcontrol(self, 
+00001ee0: 5076 616c 7565 2c20 4476 616c 7565 293a  Pvalue, Dvalue):
+00001ef0: 0a20 2020 2020 2020 2073 656c 662e 5044  .        self.PD
+00001f00: 636f 6e74 726f 6c20 3d20 2850 7661 6c75  control = (Pvalu
+00001f10: 652c 2044 7661 6c75 6529 0a0a 2020 2020  e, Dvalue)..    
+00001f20: 232a 2a63 6c61 7373 4675 6e63 7469 6f6e  #**classFunction
+00001f30: 3a20 6368 6563 6b20 6966 2063 6f6e 7472  : check if contr
+00001f40: 6c20 6973 2061 7661 696c 6162 6c65 0a20  l is available. 
+00001f50: 2020 2064 6566 2048 6173 5044 636f 6e74     def HasPDcont
+00001f60: 726f 6c28 7365 6c66 293a 0a20 2020 2020  rol(self):.     
+00001f70: 2020 2072 6574 7572 6e20 6861 7361 7474     return hasatt
+00001f80: 7228 7365 6c66 2c20 2750 4463 6f6e 7472  r(self, 'PDcontr
+00001f90: 6f6c 2729 0a0a 2020 2020 232a 2a63 6c61  ol')..    #**cla
+00001fa0: 7373 4675 6e63 7469 6f6e 3a20 6765 7420  ssFunction: get 
+00001fb0: 5044 2063 6f6e 7472 6f6c 2076 616c 7565  PD control value
+00001fc0: 730a 2020 2020 6465 6620 4765 7450 4463  s.    def GetPDc
+00001fd0: 6f6e 7472 6f6c 2873 656c 6629 3a0a 2020  ontrol(self):.  
+00001fe0: 2020 2020 2020 6966 206e 6f74 2068 6173        if not has
+00001ff0: 6174 7472 2873 656c 662c 2027 5044 636f  attr(self, 'PDco
+00002000: 6e74 726f 6c27 293a 0a20 2020 2020 2020  ntrol'):.       
+00002010: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00002020: 4572 726f 7228 2752 6f62 6f74 4c69 6e6b  Error('RobotLink
+00002030: 3a20 5044 636f 6e74 726f 6c20 6973 206e  : PDcontrol is n
+00002040: 6f74 2064 6566 696e 6564 2066 6f72 206c  ot defined for l
+00002050: 696e 6b21 2055 7365 2053 6574 5044 636f  ink! Use SetPDco
+00002060: 6e74 726f 6c20 746f 2064 6566 696e 6520  ntrol to define 
+00002070: 7061 7261 6d65 7465 7273 2062 6566 6f72  parameters befor
+00002080: 6520 7573 696e 6727 290a 2020 2020 2020  e using').      
+00002090: 2020 7265 7475 726e 2073 656c 662e 5044    return self.PD
+000020a0: 636f 6e74 726f 6c0a 0a20 2020 2064 6566  control..    def
+000020b0: 205f 5f73 7472 5f5f 2873 656c 6629 3a0a   __str__(self):.
+000020c0: 2020 2020 2020 2020 7320 3d20 2720 206d          s = '  m
+000020d0: 6173 7320 3d20 2720 2b20 7374 7228 7365  ass = ' + str(se
+000020e0: 6c66 2e6d 6173 7329 0a20 2020 2020 2020  lf.mass).       
+000020f0: 2073 202b 3d20 275c 6e20 2043 4f4d 203d   s += '\n  COM =
+00002100: 2027 202b 2073 7472 2873 656c 662e 434f   ' + str(self.CO
+00002110: 4d29 0a20 2020 2020 2020 2073 202b 3d20  M).        s += 
+00002120: 275c 6e20 2069 6e65 7274 6961 203d 2027  '\n  inertia = '
+00002130: 202b 2073 7472 2873 656c 662e 696e 6572   + str(self.iner
+00002140: 7469 6129 0a20 2020 2020 2020 2073 202b  tia).        s +
+00002150: 3d20 275c 6e20 206c 6f63 616c 4854 203d  = '\n  localHT =
+00002160: 2027 202b 2073 7472 2873 656c 662e 6c6f   ' + str(self.lo
+00002170: 6361 6c48 5429 0a20 2020 2020 2020 2073  calHT).        s
+00002180: 202b 3d20 275c 6e20 2070 7265 4854 203d   += '\n  preHT =
+00002190: 2027 202b 2073 7472 2873 656c 662e 7072   ' + str(self.pr
+000021a0: 6548 5429 0a20 2020 2020 2020 2073 202b  eHT).        s +
+000021b0: 3d20 275c 6e20 206a 6f69 6e74 5479 7065  = '\n  jointType
+000021c0: 203d 2027 202b 2073 7472 2873 656c 662e   = ' + str(self.
+000021d0: 6a6f 696e 7454 7970 6529 0a20 2020 2020  jointType).     
+000021e0: 2020 2073 202b 3d20 275c 6e20 2070 6172     s += '\n  par
+000021f0: 656e 7420 3d20 2720 2b20 7374 7228 7365  ent = ' + str(se
+00002200: 6c66 2e70 6172 656e 7429 0a20 2020 2020  lf.parent).     
+00002210: 2020 2073 202b 3d20 275c 6e20 2076 6973     s += '\n  vis
+00002220: 7561 6c69 7a61 7469 6f6e 3a5c 6e27 202b  ualization:\n' +
+00002230: 2073 7472 2873 656c 662e 7669 7375 616c   str(self.visual
+00002240: 697a 6174 696f 6e29 0a20 2020 2020 2020  ization).       
+00002250: 2069 6620 7365 6c66 2e48 6173 5044 636f   if self.HasPDco
+00002260: 6e74 726f 6c28 293a 0a20 2020 2020 2020  ntrol():.       
+00002270: 2020 2020 2073 202b 3d20 275c 6e20 2050       s += '\n  P
+00002280: 4463 6f6e 7472 6f6c 203d 2027 202b 2073  Dcontrol = ' + s
+00002290: 7472 2873 656c 662e 5044 636f 6e74 726f  tr(self.PDcontro
+000022a0: 6c29 0a20 2020 2020 2020 2072 6574 7572  l).        retur
+000022b0: 6e20 730a 0a20 2020 2064 6566 205f 5f72  n s..    def __r
+000022c0: 6570 725f 5f28 7365 6c66 293a 0a20 2020  epr__(self):.   
+000022d0: 2020 2020 2072 6574 7572 6e20 7374 7228       return str(
+000022e0: 7365 6c66 290a 2020 2020 2020 2020 0a23  self).        .#
+000022f0: 2a2a 636c 6173 733a 2063 6c61 7373 2074  **class: class t
+00002300: 6f20 6465 6669 6e65 2076 6973 7561 6c69  o define visuali
+00002310: 7a61 7469 6f6e 206f 6620 526f 626f 7454  zation of RobotT
+00002320: 6f6f 6c0a 636c 6173 7320 5652 6f62 6f74  ool.class VRobot
+00002330: 546f 6f6c 3a0a 2020 2020 232a 2a63 6c61  Tool:.    #**cla
+00002340: 7373 4675 6e63 7469 6f6e 3a20 696e 6974  ssFunction: init
+00002350: 6961 6c69 7a65 2072 6f62 6f74 2074 6f6f  ialize robot too
+00002360: 6c20 7769 7468 2070 6172 616d 6574 6572  l with parameter
+00002370: 733b 2063 7572 7265 6e74 6c79 206f 6e6c  s; currently onl
+00002380: 7920 6772 6170 6869 6373 4461 7461 2c20  y graphicsData, 
+00002390: 7768 6963 6820 6973 2061 206c 6973 7420  which is a list 
+000023a0: 6f66 2047 7261 7068 6963 7344 6174 6120  of GraphicsData 
+000023b0: 7361 6d65 2061 7320 696e 206d 6273 204f  same as in mbs O
+000023c0: 626a 6563 7473 0a20 2020 2064 6566 205f  bjects.    def _
+000023d0: 5f69 6e69 745f 5f28 7365 6c66 2c20 6772  _init__(self, gr
+000023e0: 6170 6869 6373 4461 7461 3d5b 5d29 3a0a  aphicsData=[]):.
+000023f0: 2020 2020 2020 2020 7365 6c66 2e67 7261          self.gra
+00002400: 7068 6963 7344 6174 6120 3d20 636f 7079  phicsData = copy
+00002410: 2867 7261 7068 6963 7344 6174 6129 0a0a  (graphicsData)..
+00002420: 232a 2a63 6c61 7373 3a20 6465 6669 6e65  #**class: define
+00002430: 2074 6f6f 6c20 6f66 2072 6f62 6f74 3a20   tool of robot: 
+00002440: 636f 6e74 6169 6e69 6e67 2067 7261 7068  containing graph
+00002450: 6963 7320 616e 6420 4854 2028 6d61 7920  ics and HT (may 
+00002460: 6164 6420 6665 6174 7572 6573 2069 6e20  add features in 
+00002470: 6675 7475 7265 290a 636c 6173 7320 526f  future).class Ro
+00002480: 626f 7454 6f6f 6c3a 0a20 2020 2023 2a2a  botTool:.    #**
+00002490: 636c 6173 7346 756e 6374 696f 6e3a 2069  classFunction: i
+000024a0: 6e69 7469 616c 697a 6520 726f 626f 7420  nitialize robot 
+000024b0: 746f 6f6c 0a20 2020 2023 2a2a 696e 7075  tool.    #**inpu
+000024c0: 743a 0a20 2020 2023 2020 4854 3a20 3478  t:.    #  HT: 4x
+000024d0: 3420 6d61 7472 6978 2028 6c69 7374 206f  4 matrix (list o
+000024e0: 6620 6c69 7374 7320 2f20 6e75 6d70 7920  f lists / numpy 
+000024f0: 6172 7261 7929 2063 6f6e 7461 696e 696e  array) containin
+00002500: 6720 686f 6d6f 6765 6e65 6f75 7320 7472  g homogeneous tr
+00002510: 616e 7366 6f72 6d61 7469 6f6e 2074 6f20  ansformation to 
+00002520: 7472 616e 7366 6f72 6d20 6672 6f6d 206c  transform from l
+00002530: 6173 7420 6c69 6e6b 2074 6f20 746f 6f6c  ast link to tool
+00002540: 0a20 2020 2023 2020 6772 6170 6869 6373  .    #  graphics
+00002550: 4461 7461 3a20 6469 6374 696f 6e61 7279  Data: dictionary
+00002560: 2063 6f6e 7461 696e 696e 6720 6120 6c69   containing a li
+00002570: 7374 206f 6620 4772 6170 6869 6373 4461  st of GraphicsDa
+00002580: 7461 2c20 7361 6d65 2061 7320 696e 2065  ta, same as in e
+00002590: 7875 6479 6e20 4f62 6a65 6374 730a 2020  xudyn Objects.  
+000025a0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+000025b0: 656c 662c 2048 543d 6572 622e 4854 3028  elf, HT=erb.HT0(
+000025c0: 292c 2076 6973 7561 6c69 7a61 7469 6f6e  ), visualization
+000025d0: 3d56 526f 626f 7454 6f6f 6c28 2929 3a0a  =VRobotTool()):.
+000025e0: 2020 2020 2020 2020 7365 6c66 2e48 5420          self.HT 
+000025f0: 3d20 6e70 2e61 7272 6179 2848 5429 0a20  = np.array(HT). 
+00002600: 2020 2020 2020 2073 656c 662e 7669 7375         self.visu
+00002610: 616c 697a 6174 696f 6e20 3d20 7669 7375  alization = visu
+00002620: 616c 697a 6174 696f 6e0a 2020 2020 2020  alization.      
+00002630: 2020 0a20 2020 2064 6566 205f 5f73 7472    .    def __str
+00002640: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
+00002650: 2020 7320 3d20 2720 2048 5420 3d20 2720    s = '  HT = ' 
+00002660: 2b20 7374 7228 7365 6c66 2e48 5429 0a20  + str(self.HT). 
+00002670: 2020 2020 2020 2023 7320 2b3d 2027 5c6e         #s += '\n
+00002680: 7669 7375 616c 697a 6174 696f 6e20 3d20  visualization = 
+00002690: 2720 2b20 7374 7228 7365 6c66 2e76 6973  ' + str(self.vis
+000026a0: 7561 6c69 7a61 7469 6f6e 290a 2020 2020  ualization).    
+000026b0: 2020 2020 7265 7475 726e 2073 0a20 2020      return s.   
+000026c0: 2064 6566 205f 5f72 6570 725f 5f28 7365   def __repr__(se
+000026d0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+000026e0: 7572 6e20 7374 7228 7365 6c66 290a 0a23  urn str(self)..#
+000026f0: 2a2a 636c 6173 733a 2063 6c61 7373 2074  **class: class t
+00002700: 6f20 6465 6669 6e65 2076 6973 7561 6c69  o define visuali
+00002710: 7a61 7469 6f6e 206f 6620 526f 626f 7442  zation of RobotB
+00002720: 6173 650a 636c 6173 7320 5652 6f62 6f74  ase.class VRobot
+00002730: 4261 7365 3a0a 2020 2020 232a 2a63 6c61  Base:.    #**cla
+00002740: 7373 4675 6e63 7469 6f6e 3a20 696e 6974  ssFunction: init
+00002750: 6961 6c69 7a65 2072 6f62 6f74 2062 6173  ialize robot bas
+00002760: 6520 7769 7468 2070 6172 616d 6574 6572  e with parameter
+00002770: 733b 2063 7572 7265 6e74 6c79 206f 6e6c  s; currently onl
+00002780: 7920 6772 6170 6869 6373 4461 7461 2c20  y graphicsData, 
+00002790: 7768 6963 6820 6973 2061 206c 6973 7420  which is a list 
+000027a0: 6f66 2047 7261 7068 6963 7344 6174 6120  of GraphicsData 
+000027b0: 7361 6d65 2061 7320 696e 206d 6273 204f  same as in mbs O
+000027c0: 626a 6563 7473 0a20 2020 2064 6566 205f  bjects.    def _
+000027d0: 5f69 6e69 745f 5f28 7365 6c66 2c20 6772  _init__(self, gr
+000027e0: 6170 6869 6373 4461 7461 3d5b 5d29 3a0a  aphicsData=[]):.
+000027f0: 2020 2020 2020 2020 7365 6c66 2e67 7261          self.gra
+00002800: 7068 6963 7344 6174 6120 3d20 636f 7079  phicsData = copy
+00002810: 2867 7261 7068 6963 7344 6174 6129 0a0a  (graphicsData)..
+00002820: 2020 2020 0a23 2a2a 636c 6173 733a 2064      .#**class: d
+00002830: 6566 696e 6520 6261 7365 206f 6620 726f  efine base of ro
+00002840: 626f 743a 2063 6f6e 7461 696e 696e 6720  bot: containing 
+00002850: 6772 6170 6869 6373 2061 6e64 2048 5420  graphics and HT 
+00002860: 286d 6179 2061 6464 2066 6561 7475 7265  (may add feature
+00002870: 7320 696e 2066 7574 7572 6529 0a63 6c61  s in future).cla
+00002880: 7373 2052 6f62 6f74 4261 7365 3a0a 2020  ss RobotBase:.  
+00002890: 2020 232a 2a63 6c61 7373 4675 6e63 7469    #**classFuncti
+000028a0: 6f6e 3a20 696e 6974 6961 6c69 7a65 2072  on: initialize r
+000028b0: 6f62 6f74 2062 6173 650a 2020 2020 232a  obot base.    #*
+000028c0: 2a69 6e70 7574 3a0a 2020 2020 2320 2048  *input:.    #  H
+000028d0: 543a 2034 7834 206d 6174 7269 7820 286c  T: 4x4 matrix (l
+000028e0: 6973 7420 6f66 206c 6973 7473 202f 206e  ist of lists / n
+000028f0: 756d 7079 2061 7272 6179 2920 636f 6e74  umpy array) cont
+00002900: 6169 6e69 6e67 2068 6f6d 6f67 656e 656f  aining homogeneo
+00002910: 7573 2074 7261 6e73 666f 726d 6174 696f  us transformatio
+00002920: 6e20 746f 2074 7261 6e73 666f 726d 2066  n to transform f
+00002930: 726f 6d20 776f 726c 6420 636f 6f72 6469  rom world coordi
+00002940: 6e61 7465 7320 746f 2062 6173 6520 636f  nates to base co
+00002950: 6f72 6469 6e61 7465 7320 2863 6861 6e67  ordinates (chang
+00002960: 6573 206f 7269 656e 7461 7469 6f6e 2061  es orientation a
+00002970: 6e64 2070 6f73 6974 696f 6e20 6f66 2072  nd position of r
+00002980: 6f62 6f74 290a 2020 2020 2320 2067 7261  obot).    #  gra
+00002990: 7068 6963 7344 6174 613a 2064 6963 7469  phicsData: dicti
+000029a0: 6f6e 6172 7920 636f 6e74 6169 6e69 6e67  onary containing
+000029b0: 2061 206c 6973 7420 6f66 2047 7261 7068   a list of Graph
+000029c0: 6963 7344 6174 612c 2073 616d 6520 6173  icsData, same as
+000029d0: 2069 6e20 6578 7564 796e 204f 626a 6563   in exudyn Objec
+000029e0: 7473 0a20 2020 2064 6566 205f 5f69 6e69  ts.    def __ini
+000029f0: 745f 5f28 7365 6c66 2c20 4854 3d65 7262  t__(self, HT=erb
+00002a00: 2e48 5430 2829 2c20 7669 7375 616c 697a  .HT0(), visualiz
+00002a10: 6174 696f 6e3d 5652 6f62 6f74 4261 7365  ation=VRobotBase
+00002a20: 2829 293a 0a20 2020 2020 2020 2073 656c  ()):.        sel
+00002a30: 662e 4854 203d 206e 702e 6172 7261 7928  f.HT = np.array(
+00002a40: 4854 290a 2020 2020 2020 2020 7365 6c66  HT).        self
+00002a50: 2e76 6973 7561 6c69 7a61 7469 6f6e 203d  .visualization =
+00002a60: 2076 6973 7561 6c69 7a61 7469 6f6e 0a20   visualization. 
+00002a70: 2020 200a 2020 2020 6465 6620 5f5f 7374     .    def __st
+00002a80: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
+00002a90: 2020 2073 203d 2027 2020 4854 203d 2027     s = '  HT = '
+00002aa0: 202b 2073 7472 2873 656c 662e 4854 290a   + str(self.HT).
+00002ab0: 2020 2020 2020 2020 2373 202b 3d20 275c          #s += '\
+00002ac0: 6e76 6973 7561 6c69 7a61 7469 6f6e 203d  nvisualization =
+00002ad0: 2027 202b 2073 7472 2873 656c 662e 7669   ' + str(self.vi
+00002ae0: 7375 616c 697a 6174 696f 6e29 0a20 2020  sualization).   
+00002af0: 2020 2020 2072 6574 7572 6e20 730a 0a20       return s.. 
+00002b00: 2020 2064 6566 205f 5f72 6570 725f 5f28     def __repr__(
+00002b10: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00002b20: 6574 7572 6e20 7374 7228 7365 6c66 290a  eturn str(self).
+00002b30: 0a0a 6275 696c 6446 726f 6d44 6963 7469  ..buildFromDicti
+00002b40: 6f6e 6172 7957 6172 6e65 6420 3d20 4661  onaryWarned = Fa
+00002b50: 6c73 6520 2364 6f20 6e6f 7420 7573 6520  lse #do not use 
+00002b60: 7468 6973 2076 6172 6961 626c 652c 2069  this variable, i
+00002b70: 7420 6973 2066 6f72 2064 6570 7265 6361  t is for depreca
+00002b80: 7469 6f6e 2077 6172 6e69 6e67 7321 0a23  tion warnings!.#
+00002b90: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002ba0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002bb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002bc0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002bd0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002be0: 2b2b 2b2b 0a23 2b2b 2b20 2044 6566 696e  ++++.#+++  Defin
+00002bf0: 6520 726f 626f 7420 2b2b 2b2b 2b2b 2b2b  e robot ++++++++
+00002c00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002c10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002c20: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002c30: 2b2b 2b2b 2b2b 2b2b 2b2b 0a23 2b2b 2b2b  ++++++++++.#++++
+00002c40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002c50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002c60: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00002c70: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
 00002c80: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002c90: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002ca0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002cb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002cc0: 2b2b 2b2b 2b2b 2b2b 0d0a 232b 2b2b 2020  ++++++++..#+++  
-00002cd0: 4465 6669 6e65 2072 6f62 6f74 202b 2b2b  Define robot +++
-00002ce0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002cf0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002d00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002d10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d  +++++++++++++++.
-00002d20: 0a23 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  .#++++++++++++++
-00002d30: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002d40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002d50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002d60: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00002d70: 2b2b 2b2b 2b2b 0d0a 232a 2a63 6c61 7373  ++++++..#**class
-00002d80: 3a20 636c 6173 7320 746f 2064 6566 696e  : class to defin
-00002d90: 6520 6120 726f 626f 740d 0a63 6c61 7373  e a robot..class
-00002da0: 2052 6f62 6f74 3a0d 0a20 2020 2023 2a2a   Robot:..    #**
-00002db0: 636c 6173 7346 756e 6374 696f 6e3a 2069  classFunction: i
-00002dc0: 6e69 7469 616c 697a 6520 726f 626f 7420  nitialize robot 
-00002dd0: 636c 6173 730d 0a20 2020 2023 2a2a 696e  class..    #**in
-00002de0: 7075 743a 0d0a 2020 2020 2320 2062 6173  put:..    #  bas
-00002df0: 653a 2064 6566 696e 6974 696f 6e20 6f66  e: definition of
-00002e00: 2062 6173 6520 7573 696e 6720 526f 626f   base using Robo
-00002e10: 7442 6173 6528 2920 636c 6173 730d 0a20  tBase() class.. 
-00002e20: 2020 2023 2020 746f 6f6c 3a20 6465 6669     #  tool: defi
-00002e30: 6e69 7469 6f6e 206f 6620 746f 6f6c 2075  nition of tool u
-00002e40: 7369 6e67 2052 6f62 6f74 546f 6f6c 2829  sing RobotTool()
-00002e50: 2063 6c61 7373 0d0a 2020 2020 2320 2067   class..    #  g
-00002e60: 7261 7669 7479 3a20 6120 6c69 7374 206f  ravity: a list o
-00002e70: 7220 3344 206e 756d 7079 2061 7272 6179  r 3D numpy array
-00002e80: 2064 6566 696e 696e 6720 6772 6176 6974   defining gravit
-00002e90: 790d 0a20 2020 2023 2020 7265 6665 7265  y..    #  refere
-00002ea0: 6e63 6543 6f6e 6669 6775 7261 7469 6f6e  nceConfiguration
-00002eb0: 3a20 6120 6c69 7374 206f 6620 7363 616c  : a list of scal
-00002ec0: 6172 2071 7561 6e74 6974 6965 7320 6465  ar quantities de
-00002ed0: 6669 6e69 6e67 2074 6865 2070 6172 616d  fining the param
-00002ee0: 6574 6572 7320 666f 7220 7265 6665 7265  eters for refere
-00002ef0: 6e63 6520 636f 6e66 6967 7572 6174 696f  nce configuratio
-00002f00: 6e0d 0a20 2020 2064 6566 205f 5f69 6e69  n..    def __ini
-00002f10: 745f 5f28 7365 6c66 2c20 0d0a 2020 2020  t__(self, ..    
-00002f20: 2020 2020 2020 2020 2020 2020 2067 7261               gra
-00002f30: 7669 7479 3d5b 302c 302c 2d39 2e38 315d  vity=[0,0,-9.81]
-00002f40: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00002f50: 2020 2020 6261 7365 203d 2052 6f62 6f74      base = Robot
-00002f60: 4261 7365 2829 2c0d 0a20 2020 2020 2020  Base(),..       
-00002f70: 2020 2020 2020 2020 2020 746f 6f6c 203d            tool =
-00002f80: 2052 6f62 6f74 546f 6f6c 2829 2c0d 0a20   RobotTool(),.. 
-00002f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002fa0: 7265 6665 7265 6e63 6543 6f6e 6669 6775  referenceConfigu
-00002fb0: 7261 7469 6f6e 203d 205b 5d0d 0a20 2020  ration = []..   
-00002fc0: 2020 2020 2020 2020 2020 2020 2020 293a                ):
-00002fd0: 0d0a 2020 2020 2020 2020 7365 6c66 2e67  ..        self.g
-00002fe0: 7261 7669 7479 203d 206e 702e 6172 7261  ravity = np.arra
-00002ff0: 7928 6772 6176 6974 7929 0d0a 2020 2020  y(gravity)..    
-00003000: 2020 2020 7365 6c66 2e62 6173 6520 3d20      self.base = 
-00003010: 6261 7365 0d0a 2020 2020 2020 2020 7365  base..        se
-00003020: 6c66 2e74 6f6f 6c20 3d20 746f 6f6c 0d0a  lf.tool = tool..
-00003030: 2020 2020 2020 2020 7365 6c66 2e72 6566          self.ref
-00003040: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
-00003050: 696f 6e20 3d20 6e70 2e61 7272 6179 2872  ion = np.array(r
-00003060: 6566 6572 656e 6365 436f 6e66 6967 7572  eferenceConfigur
-00003070: 6174 696f 6e29 0d0a 2020 2020 2020 2020  ation)..        
-00003080: 7365 6c66 2e6c 696e 6b73 203d 205b 5d20  self.links = [] 
-00003090: 2369 6e69 7469 616c 697a 6520 6c69 7374  #initialize list
-000030a0: 206f 6620 6c69 6e6b 2064 6174 610d 0a20   of link data.. 
-000030b0: 2020 2020 2020 2073 656c 662e 6973 5365         self.isSe
-000030c0: 7269 616c 526f 626f 7420 3d20 5472 7565  rialRobot = True
-000030d0: 2023 7468 6973 2069 7320 7472 7565 2061   #this is true a
-000030e0: 7320 6c6f 6e67 2061 7320 7061 7265 6e74  s long as parent
-000030f0: 203d 206c 696e 6b20 696e 6465 7820 2d20   = link index - 
-00003100: 310d 0a0d 0a20 2020 2064 6566 205f 5f73  1....    def __s
-00003110: 7472 5f5f 2873 656c 6629 3a0d 0a20 2020  tr__(self):..   
-00003120: 2020 2020 2073 203d 2027 6772 6176 6974       s = 'gravit
-00003130: 7920 3d20 2720 2b20 7374 7228 7365 6c66  y = ' + str(self
-00003140: 2e67 7261 7669 7479 290d 0a20 2020 2020  .gravity)..     
-00003150: 2020 2073 202b 3d20 275c 6e72 6566 6572     s += '\nrefer
-00003160: 656e 6365 436f 6e66 6967 7572 6174 696f  enceConfiguratio
-00003170: 6e20 3d20 2720 2b20 7374 7228 7365 6c66  n = ' + str(self
-00003180: 2e72 6566 6572 656e 6365 436f 6e66 6967  .referenceConfig
-00003190: 7572 6174 696f 6e29 0d0a 2020 2020 2020  uration)..      
-000031a0: 2020 7320 2b3d 2027 5c6e 6261 7365 3a20    s += '\nbase: 
-000031b0: 5c6e 2720 2b20 7374 7228 7365 6c66 2e62  \n' + str(self.b
-000031c0: 6173 6529 0d0a 2020 2020 2020 2020 7320  ase)..        s 
-000031d0: 2b3d 2027 5c6e 746f 6f6c 3a20 5c6e 2720  += '\ntool: \n' 
-000031e0: 2b20 7374 7228 7365 6c66 2e74 6f6f 6c29  + str(self.tool)
-000031f0: 0d0a 2020 2020 2020 2020 7320 2b3d 2027  ..        s += '
-00003200: 5c6e 6c69 6e6b 733a 205c 6e27 202b 2073  \nlinks: \n' + s
-00003210: 7472 2873 656c 662e 6c69 6e6b 7329 0d0a  tr(self.links)..
-00003220: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00003230: 0d0a 2020 2020 0d0a 2020 2020 6465 6620  ..    ..    def 
-00003240: 5f5f 7265 7072 5f5f 2873 656c 6629 3a0d  __repr__(self):.
-00003250: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00003260: 7374 7228 7365 6c66 290d 0a20 2020 2020  str(self)..     
-00003270: 2020 200d 0a0d 0a20 2020 2023 2a2a 636c     ....    #**cl
-00003280: 6173 7346 756e 6374 696f 6e3a 2061 6464  assFunction: add
-00003290: 2061 206c 696e 6b20 746f 2073 6572 6961   a link to seria
-000032a0: 6c20 726f 626f 740d 0a20 2020 2064 6566  l robot..    def
-000032b0: 2041 6464 4c69 6e6b 2873 656c 662c 2072   AddLink(self, r
-000032c0: 6f62 6f74 4c69 6e6b 293a 0d0a 2020 2020  obotLink):..    
-000032d0: 2020 2020 6920 3d20 6c65 6e28 7365 6c66      i = len(self
-000032e0: 2e6c 696e 6b73 2920 2363 7572 7265 6e74  .links) #current
-000032f0: 2069 6e64 6578 0d0a 2020 2020 2020 2020   index..        
-00003300: 6966 206c 656e 2873 656c 662e 7265 6665  if len(self.refe
-00003310: 7265 6e63 6543 6f6e 6669 6775 7261 7469  renceConfigurati
-00003320: 6f6e 2920 3d3d 2069 3a20 2365 7874 656e  on) == i: #exten
-00003330: 6420 7265 6665 7265 6e63 6520 636f 6e66  d reference conf
-00003340: 6967 7572 6174 696f 6e2c 2069 6620 6e6f  iguration, if no
-00003350: 7420 7370 6563 6966 6965 6420 6279 2075  t specified by u
-00003360: 7365 7220 6475 7269 6e67 2069 6e69 7469  ser during initi
-00003370: 616c 697a 6174 696f 6e0d 0a20 2020 2020  alization..     
-00003380: 2020 2020 2020 2073 656c 662e 7265 6665         self.refe
-00003390: 7265 6e63 6543 6f6e 6669 6775 7261 7469  renceConfigurati
-000033a0: 6f6e 203d 206e 702e 6873 7461 636b 2828  on = np.hstack((
-000033b0: 7365 6c66 2e72 6566 6572 656e 6365 436f  self.referenceCo
-000033c0: 6e66 6967 7572 6174 696f 6e2c 5b30 5d29  nfiguration,[0])
-000033d0: 290d 0a0d 0a20 2020 2020 2020 2073 656c  )....        sel
-000033e0: 662e 6c69 6e6b 7320 2b3d 205b 6465 6570  f.links += [deep
-000033f0: 636f 7079 2872 6f62 6f74 4c69 6e6b 295d  copy(robotLink)]
-00003400: 0d0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-00003410: 662e 6c69 6e6b 735b 695d 2e70 6172 656e  f.links[i].paren
-00003420: 7420 3d3d 202d 323a 2023 696e 2074 6869  t == -2: #in thi
-00003430: 7320 6361 7365 2c20 6175 746f 6d61 7469  s case, automati
-00003440: 6361 6c6c 7920 7365 7420 7061 7265 6e74  cally set parent
-00003450: 7320 666f 7220 7365 7269 616c 2072 6f62  s for serial rob
-00003460: 6f74 2028 6368 6169 6e29 0d0a 2020 2020  ot (chain)..    
-00003470: 2020 2020 2020 2020 7365 6c66 2e6c 696e          self.lin
-00003480: 6b73 5b69 5d2e 7061 7265 6e74 203d 2069  ks[i].parent = i
-00003490: 2d31 0d0a 2020 2020 2020 2020 656c 6966  -1..        elif
-000034a0: 2073 656c 662e 6c69 6e6b 735b 695d 2e70   self.links[i].p
-000034b0: 6172 656e 7420 3e3d 2069 3a0d 0a20 2020  arent >= i:..   
-000034c0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000034d0: 616c 7565 4572 726f 7228 2752 6f62 6f74  alueError('Robot
-000034e0: 2e41 6464 4c69 6e6b 282e 2e2e 293a 206c  .AddLink(...): l
-000034f0: 696e 6b20 7061 7265 6e74 2069 6e64 6578  ink parent index
-00003500: 206d 7573 7420 6265 2061 6c77 6179 7320   must be always 
-00003510: 6c6f 7765 7220 7468 616e 206c 696e 6b20  lower than link 
-00003520: 696e 6465 7827 290d 0a0d 0a20 2020 2020  index')....     
-00003530: 2020 2069 6620 2073 656c 662e 6c69 6e6b     if  self.link
-00003540: 735b 695d 2e70 6172 656e 7420 213d 2069  s[i].parent != i
-00003550: 2d31 3a0d 0a20 2020 2020 2020 2020 2020  -1:..           
-00003560: 2073 656c 662e 6973 5365 7269 616c 526f   self.isSerialRo
-00003570: 626f 7420 3d20 4661 6c73 650d 0a20 2020  bot = False..   
-00003580: 2020 2020 200d 0a20 2020 2020 2020 2069       ..        i
-00003590: 6620 6e6f 7420 7365 6c66 2e69 7353 6572  f not self.isSer
-000035a0: 6961 6c52 6f62 6f74 2061 6e64 2028 6e70  ialRobot and (np
-000035b0: 2e6c 696e 616c 672e 6e6f 726d 2873 656c  .linalg.norm(sel
-000035c0: 662e 746f 6f6c 2e48 5420 2d20 6572 622e  f.tool.HT - erb.
-000035d0: 4854 3028 2929 203e 3d20 3165 2d31 350d  HT0()) >= 1e-15.
-000035e0: 0a20 2020 2020 2020 2020 2020 206f 7220  .            or 
-000035f0: 7365 6c66 2e74 6f6f 6c2e 7669 7375 616c  self.tool.visual
-00003600: 697a 6174 696f 6e2e 6772 6170 6869 6373  ization.graphics
-00003610: 4461 7461 2021 3d20 5b5d 293a 0d0a 2020  Data != []):..  
-00003620: 2020 2020 2020 2020 2020 6578 7564 796e            exudyn
-00003630: 2e50 7269 6e74 2827 5761 726e 696e 673a  .Print('Warning:
-00003640: 2063 6c61 7373 2052 6f62 6f74 3a20 746f   class Robot: to
-00003650: 6f6c 2064 6566 696e 6564 2069 6e20 6b69  ol defined in ki
-00003660: 6e65 6d61 7469 6320 7472 6565 3b20 6375  nematic tree; cu
-00003670: 7272 656e 746c 7920 746f 6f6c 2069 7320  rrently tool is 
-00003680: 6f6e 6c79 2061 6c6c 6f77 6564 2066 6f72  only allowed for
-00003690: 2073 6572 6961 6c20 726f 626f 7473 2729   serial robots')
-000036a0: 0d0a 0d0a 2020 2020 2020 2020 7265 7475  ....        retu
-000036b0: 726e 2069 2023 7265 7475 726e 2069 6e64  rn i #return ind
-000036c0: 6578 206f 6620 6c69 6e6b 0d0a 0d0a 2020  ex of link....  
-000036d0: 2020 232a 2a63 6c61 7373 4675 6e63 7469    #**classFuncti
-000036e0: 6f6e 3a20 7265 7475 726e 2054 7275 652c  on: return True,
-000036f0: 2069 6620 726f 626f 7420 6973 2061 2073   if robot is a s
-00003700: 6572 6961 6c20 726f 626f 740d 0a20 2020  erial robot..   
-00003710: 2064 6566 2049 7353 6572 6961 6c52 6f62   def IsSerialRob
-00003720: 6f74 2873 656c 6629 3a0d 0a20 2020 2020  ot(self):..     
-00003730: 2020 2072 6574 7572 6e20 7365 6c66 2e69     return self.i
-00003740: 7353 6572 6961 6c52 6f62 6f74 0d0a 0d0a  sSerialRobot....
-00003750: 2020 2020 232a 2a63 6c61 7373 4675 6e63      #**classFunc
-00003760: 7469 6f6e 3a20 7265 7475 726e 204c 696e  tion: return Lin
-00003770: 6b20 6f62 6a65 6374 206f 6620 6c69 6e6b  k object of link
-00003780: 2069 0d0a 2020 2020 6465 6620 4765 744c   i..    def GetL
-00003790: 696e 6b28 7365 6c66 2c20 6929 3a0d 0a20  ink(self, i):.. 
-000037a0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-000037b0: 6c66 2e6c 696e 6b73 5b69 5d0d 0a0d 0a20  lf.links[i].... 
-000037c0: 2020 2023 2a2a 636c 6173 7346 756e 6374     #**classFunct
-000037d0: 696f 6e3a 2054 7275 6520 6966 206c 696e  ion: True if lin
-000037e0: 6b20 6861 7320 7061 7265 6e74 2c20 4661  k has parent, Fa
-000037f0: 6c73 6520 6966 206e 6f74 0d0a 2020 2020  lse if not..    
-00003800: 6465 6620 4861 7350 6172 656e 7428 7365  def HasParent(se
-00003810: 6c66 2c20 6929 3a0d 0a20 2020 2020 2020  lf, i):..       
-00003820: 2072 6574 7572 6e20 7365 6c66 2e6c 696e   return self.lin
-00003830: 6b73 5b69 5d2e 7061 7265 6e74 203e 3d20  ks[i].parent >= 
-00003840: 300d 0a0d 0a20 2020 2023 2a2a 636c 6173  0....    #**clas
-00003850: 7346 756e 6374 696f 6e3a 2047 6574 2069  sFunction: Get i
-00003860: 6e64 6578 206f 6620 7061 7265 6e74 206c  ndex of parent l
-00003870: 696e 6b3b 2066 6f72 2073 6572 6961 6c20  ink; for serial 
-00003880: 726f 626f 7420 7468 6973 2069 7320 7369  robot this is si
-00003890: 6d70 6c65 2c20 6275 7420 666f 7220 6765  mple, but for ge
-000038a0: 6e65 7261 6c20 7472 6565 732c 2074 6865  neral trees, the
-000038b0: 7265 2069 7320 6120 696e 6465 7820 6c69  re is a index li
-000038c0: 7374 0d0a 2020 2020 6465 6620 4765 7450  st..    def GetP
-000038d0: 6172 656e 7449 6e64 6578 2873 656c 662c  arentIndex(self,
-000038e0: 2069 293a 0d0a 2020 2020 2020 2020 7265   i):..        re
-000038f0: 7475 726e 2073 656c 662e 6c69 6e6b 735b  turn self.links[
-00003900: 695d 2e70 6172 656e 740d 0a0d 0a20 2020  i].parent....   
-00003910: 200d 0a20 2020 2023 2a2a 636c 6173 7346   ..    #**classF
-00003920: 756e 6374 696f 6e3a 2072 6574 7572 6e20  unction: return 
-00003930: 6e75 6d62 6572 206f 6620 6c69 6e6b 730d  number of links.
-00003940: 0a20 2020 2064 6566 204e 756d 6265 724f  .    def NumberO
-00003950: 664c 696e 6b73 2873 656c 6629 3a0d 0a20  fLinks(self):.. 
-00003960: 2020 2020 2020 2072 6574 7572 6e20 6c65         return le
-00003970: 6e28 7365 6c66 2e6c 696e 6b73 290d 0a0d  n(self.links)...
-00003980: 0a20 2020 2023 2a2a 636c 6173 7346 756e  .    #**classFun
-00003990: 6374 696f 6e3a 2072 6574 7572 6e20 6261  ction: return ba
-000039a0: 7365 2061 7320 686f 6d6f 6765 6e65 6f75  se as homogeneou
-000039b0: 7320 7472 616e 7366 6f72 6d61 7469 6f6e  s transformation
-000039c0: 0d0a 2020 2020 6465 6620 4765 7442 6173  ..    def GetBas
-000039d0: 6548 5428 7365 6c66 293a 0d0a 2020 2020  eHT(self):..    
-000039e0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000039f0: 6261 7365 2e48 540d 0a0d 0a20 2020 2023  base.HT....    #
-00003a00: 2a2a 636c 6173 7346 756e 6374 696f 6e3a  **classFunction:
-00003a10: 2072 6574 7572 6e20 6261 7365 2061 7320   return base as 
-00003a20: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
-00003a30: 7366 6f72 6d61 7469 6f6e 0d0a 2020 2020  sformation..    
-00003a40: 6465 6620 4765 7454 6f6f 6c48 5428 7365  def GetToolHT(se
-00003a50: 6c66 293a 0d0a 2020 2020 2020 2020 7265  lf):..        re
-00003a60: 7475 726e 2073 656c 662e 746f 6f6c 2e48  turn self.tool.H
-00003a70: 540d 0a20 2020 200d 0a20 2020 2023 2a2a  T..    ..    #**
-00003a80: 636c 6173 7346 756e 6374 696f 6e3a 2063  classFunction: c
-00003a90: 6f6d 7075 7465 206c 6973 7420 6f66 2068  ompute list of h
-00003aa0: 6f6d 6f67 656e 656f 7573 2074 7261 6e73  omogeneous trans
-00003ab0: 666f 726d 6174 696f 6e73 2066 6f72 2065  formations for e
-00003ac0: 7665 7279 206c 696e 6b2c 2075 7369 6e67  very link, using
-00003ad0: 2063 7572 7265 6e74 206a 6f69 6e74 2063   current joint c
-00003ae0: 6f6f 7264 696e 6174 6573 2071 3b20 6c65  oordinates q; le
-00003af0: 6164 7320 746f 2064 6966 6665 7265 6e74  ads to different
-00003b00: 2072 6573 756c 7473 2066 6f72 2073 7461   results for sta
-00003b10: 6e64 6172 6420 616e 6420 6d6f 6469 6669  ndard and modifi
-00003b20: 6564 2044 4820 7061 7261 6d65 7465 7273  ed DH parameters
-00003b30: 2062 6563 6175 7365 206c 696e 6b20 636f   because link co
-00003b40: 6f72 6469 6e61 7465 7320 6172 6520 6469  ordinates are di
-00003b50: 6666 6572 656e 7421 0d0a 2020 2020 6465  fferent!..    de
-00003b60: 6620 4c69 6e6b 4854 2873 656c 662c 2071  f LinkHT(self, q
-00003b70: 293a 0d0a 2020 2020 2020 2020 4854 203d  ):..        HT =
-00003b80: 205b 5d0d 0a0d 0a20 2020 2020 2020 2023   []....        #
-00003b90: 2023 6f6e 6c79 2066 6f72 2073 6572 6961   #only for seria
-00003ba0: 6c20 726f 626f 7473 3a0d 0a20 2020 2020  l robots:..     
-00003bb0: 2020 2023 2054 6375 7272 656e 7420 3d20     # Tcurrent = 
-00003bc0: 7365 6c66 2e62 6173 652e 4854 0d0a 2020  self.base.HT..  
-00003bd0: 2020 2020 2020 2320 666f 7220 6920 696e        # for i in
-00003be0: 2072 616e 6765 286c 656e 2873 656c 662e   range(len(self.
-00003bf0: 6c69 6e6b 7329 293a 0d0a 2020 2020 2020  links)):..      
-00003c00: 2020 2320 2020 2020 6c69 6e6b 203d 2073    #     link = s
-00003c10: 656c 662e 6c69 6e6b 735b 695d 0d0a 0d0a  elf.links[i]....
-00003c20: 2020 2020 2020 2020 2320 2020 2020 2363          #     #c
-00003c30: 616c 6c20 6675 6e63 7469 6f6e 2074 6f20  all function to 
-00003c40: 636f 6d70 7574 6520 4854 2066 6f72 206a  compute HT for j
-00003c50: 6f69 6e74 2072 6f74 6174 696f 6e2f 7472  oint rotation/tr
-00003c60: 616e 736c 6174 696f 6e3a 0d0a 2020 2020  anslation:..    
-00003c70: 2020 2020 2320 2020 2020 5430 3120 3d20      #     T01 = 
-00003c80: 6c69 6e6b 2e70 7265 4854 2040 2064 6963  link.preHT @ dic
-00003c90: 744a 6f69 6e74 5479 7065 3248 545b 6c69  tJointType2HT[li
-00003ca0: 6e6b 2e6a 6f69 6e74 5479 7065 5d28 715b  nk.jointType](q[
-00003cb0: 695d 2920 4020 6c69 6e6b 2e6c 6f63 616c  i]) @ link.local
-00003cc0: 4854 0d0a 0d0a 2020 2020 2020 2020 2320  HT....        # 
-00003cd0: 2020 2020 5463 7572 7265 6e74 203d 2054      Tcurrent = T
-00003ce0: 6375 7272 656e 7420 4020 5430 310d 0a20  current @ T01.. 
-00003cf0: 2020 2020 2020 2023 2020 2020 2048 5420         #     HT 
-00003d00: 2b3d 205b 636f 7079 2854 6375 7272 656e  += [copy(Tcurren
-00003d10: 7429 5d0d 0a0d 0a0d 0a20 2020 2020 2020  t)]......       
-00003d20: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-00003d30: 6c65 6e28 7365 6c66 2e6c 696e 6b73 2929  len(self.links))
-00003d40: 3a0d 0a20 2020 2020 2020 2020 2020 206c  :..            l
-00003d50: 696e 6b20 3d20 7365 6c66 2e6c 696e 6b73  ink = self.links
-00003d60: 5b69 5d0d 0a0d 0a20 2020 2020 2020 2020  [i]....         
-00003d70: 2020 2054 3031 203d 206c 696e 6b2e 7072     T01 = link.pr
-00003d80: 6548 5420 4020 6469 6374 4a6f 696e 7454  eHT @ dictJointT
-00003d90: 7970 6532 4854 5b6c 696e 6b2e 6a6f 696e  ype2HT[link.join
-00003da0: 7454 7970 655d 2871 5b69 5d29 2040 206c  tType](q[i]) @ l
-00003db0: 696e 6b2e 6c6f 6361 6c48 540d 0a20 2020  ink.localHT..   
-00003dc0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00003dd0: 2e48 6173 5061 7265 6e74 2869 293a 0d0a  .HasParent(i):..
-00003de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003df0: 7049 6e64 6578 203d 2073 656c 662e 4765  pIndex = self.Ge
-00003e00: 7450 6172 656e 7449 6e64 6578 2869 290d  tParentIndex(i).
-00003e10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003e20: 2054 6375 7272 656e 7420 3d20 4854 5b70   Tcurrent = HT[p
-00003e30: 496e 6465 785d 2040 2054 3031 0d0a 2020  Index] @ T01..  
-00003e40: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-00003e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003e60: 2054 6375 7272 656e 7420 3d20 7365 6c66   Tcurrent = self
-00003e70: 2e62 6173 652e 4854 2040 2054 3031 0d0a  .base.HT @ T01..
-00003e80: 2020 2020 2020 2020 2020 2020 4854 202b              HT +
-00003e90: 3d20 5b63 6f70 7928 5463 7572 7265 6e74  = [copy(Tcurrent
-00003ea0: 295d 0d0a 2020 2020 2020 2020 0d0a 2020  )]..        ..  
-00003eb0: 2020 2020 2020 7265 7475 726e 2048 5420        return HT 
-00003ec0: 2020 200d 0a0d 0a20 2020 2023 2a2a 636c     ....    #**cl
-00003ed0: 6173 7346 756e 6374 696f 6e3a 2063 6f6d  assFunction: com
-00003ee0: 7075 7465 206c 6973 7420 6f66 2068 6f6d  pute list of hom
-00003ef0: 6f67 656e 656f 7573 2074 7261 6e73 666f  ogeneous transfo
-00003f00: 726d 6174 696f 6e73 2066 6f72 2065 7665  rmations for eve
-00003f10: 7279 206a 6f69 6e74 2028 6166 7465 7220  ry joint (after 
-00003f20: 726f 7461 7469 6f6e 292c 2075 7369 6e67  rotation), using
-00003f30: 2063 7572 7265 6e74 206a 6f69 6e74 2063   current joint c
-00003f40: 6f6f 7264 696e 6174 6573 2071 0d0a 2020  oordinates q..  
-00003f50: 2020 6465 6620 4a6f 696e 7448 5428 7365    def JointHT(se
-00003f60: 6c66 2c20 7129 3a0d 0a20 2020 2020 2020  lf, q):..       
-00003f70: 2048 5420 3d20 5b5d 0d0a 0d0a 2020 2020   HT = []....    
-00003f80: 2020 2020 2320 236f 6e6c 7920 666f 7220      # #only for 
-00003f90: 7365 7269 616c 2072 6f62 6f74 733a 0d0a  serial robots:..
-00003fa0: 2020 2020 2020 2020 2320 5463 7572 7265          # Tcurre
-00003fb0: 6e74 203d 2073 656c 662e 6261 7365 2e48  nt = self.base.H
-00003fc0: 540d 0a20 2020 2020 2020 2023 2066 6f72  T..        # for
-00003fd0: 2069 2069 6e20 7261 6e67 6528 6c65 6e28   i in range(len(
-00003fe0: 7365 6c66 2e6c 696e 6b73 2929 3a0d 0a20  self.links)):.. 
-00003ff0: 2020 2020 2020 2023 2020 2020 206c 696e         #     lin
-00004000: 6b20 3d20 7365 6c66 2e6c 696e 6b73 5b69  k = self.links[i
-00004010: 5d0d 0a0d 0a20 2020 2020 2020 2023 2020  ]....        #  
-00004020: 2020 2054 3031 203d 206c 696e 6b2e 7072     T01 = link.pr
-00004030: 6548 5420 4020 6469 6374 4a6f 696e 7454  eHT @ dictJointT
-00004040: 7970 6532 4854 5b6c 696e 6b2e 6a6f 696e  ype2HT[link.join
-00004050: 7454 7970 655d 2871 5b69 5d29 0d0a 2020  tType](q[i])..  
-00004060: 2020 2020 2020 2320 2020 2020 5463 7572        #     Tcur
-00004070: 7265 6e74 203d 2054 6375 7272 656e 7420  rent = Tcurrent 
-00004080: 4020 5430 310d 0a20 2020 2020 2020 2023  @ T01..        #
-00004090: 2020 2020 2048 5420 2b3d 205b 636f 7079       HT += [copy
-000040a0: 2854 6375 7272 656e 7429 5d0d 0a20 2020  (Tcurrent)]..   
-000040b0: 2020 2020 2020 2020 200d 0a20 2020 2020           ..     
-000040c0: 2020 2023 2020 2020 2054 6375 7272 656e     #     Tcurren
-000040d0: 7420 3d20 5463 7572 7265 6e74 2040 206c  t = Tcurrent @ l
-000040e0: 696e 6b2e 6c6f 6361 6c48 540d 0a0d 0a20  ink.localHT.... 
-000040f0: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
-00004100: 7261 6e67 6528 6c65 6e28 7365 6c66 2e6c  range(len(self.l
-00004110: 696e 6b73 2929 3a0d 0a20 2020 2020 2020  inks)):..       
-00004120: 2020 2020 206c 696e 6b20 3d20 7365 6c66       link = self
-00004130: 2e6c 696e 6b73 5b69 5d0d 0a0d 0a20 2020  .links[i]....   
-00004140: 2020 2020 2020 2020 2054 3031 203d 206c           T01 = l
-00004150: 696e 6b2e 7072 6548 5420 4020 6469 6374  ink.preHT @ dict
-00004160: 4a6f 696e 7454 7970 6532 4854 5b6c 696e  JointType2HT[lin
-00004170: 6b2e 6a6f 696e 7454 7970 655d 2871 5b69  k.jointType](q[i
-00004180: 5d29 0d0a 2020 2020 2020 2020 2020 2020  ])..            
-00004190: 6966 2073 656c 662e 4861 7350 6172 656e  if self.HasParen
-000041a0: 7428 6929 3a0d 0a20 2020 2020 2020 2020  t(i):..         
-000041b0: 2020 2020 2020 2070 496e 6465 7820 3d20         pIndex = 
-000041c0: 7365 6c66 2e47 6574 5061 7265 6e74 496e  self.GetParentIn
-000041d0: 6465 7828 6929 0d0a 2020 2020 2020 2020  dex(i)..        
-000041e0: 2020 2020 2020 2020 5463 7572 7265 6e74          Tcurrent
-000041f0: 203d 2048 545b 7049 6e64 6578 5d20 4020   = HT[pIndex] @ 
-00004200: 7365 6c66 2e6c 696e 6b73 5b70 496e 6465  self.links[pInde
-00004210: 785d 2e6c 6f63 616c 4854 2040 2054 3031  x].localHT @ T01
-00004220: 0d0a 2020 2020 2020 2020 2020 2020 656c  ..            el
-00004230: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00004240: 2020 2020 2054 6375 7272 656e 7420 3d20       Tcurrent = 
-00004250: 7365 6c66 2e62 6173 652e 4854 2040 2054  self.base.HT @ T
-00004260: 3031 0d0a 2020 2020 2020 2020 2020 2020  01..            
-00004270: 4854 202b 3d20 5b63 6f70 7928 5463 7572  HT += [copy(Tcur
-00004280: 7265 6e74 295d 0d0a 2020 2020 2020 2020  rent)]..        
-00004290: 7265 7475 726e 2048 540d 0a0d 0a20 2020  return HT....   
-000042a0: 2023 2a2a 636c 6173 7346 756e 6374 696f   #**classFunctio
-000042b0: 6e3a 2063 6f6d 7075 7465 206c 6973 7420  n: compute list 
-000042c0: 6f66 2020 686f 6d6f 6765 6e65 6f75 7320  of  homogeneous 
-000042d0: 7472 616e 7366 6f72 6d61 7469 6f6e 7320  transformations 
-000042e0: 4854 2066 726f 6d20 6261 7365 2074 6f20  HT from base to 
-000042f0: 6576 6572 7920 434f 4d20 7573 696e 6720  every COM using 
-00004300: 4854 206c 6973 7420 6672 6f6d 2052 6f62  HT list from Rob
-00004310: 6f74 2e4a 6f69 6e74 4854 282e 2e2e 290d  ot.JointHT(...).
-00004320: 0a20 2020 2064 6566 2043 4f4d 4854 2873  .    def COMHT(s
-00004330: 656c 662c 2048 5429 3a0d 0a20 2020 2020  elf, HT):..     
-00004340: 2020 2048 5443 4f4d 203d 205b 5d0d 0a20     HTCOM = [].. 
-00004350: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00004360: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-00004370: 6c65 6e28 7365 6c66 2e6c 696e 6b73 2929  len(self.links))
-00004380: 3a0d 0a20 2020 2020 2020 2020 2020 2048  :..            H
-00004390: 5443 4f4d 202b 3d20 5b48 545b 695d 2040  TCOM += [HT[i] @
-000043a0: 2073 656c 662e 6c69 6e6b 735b 695d 2e6c   self.links[i].l
-000043b0: 6f63 616c 4854 2040 2065 7262 2e48 5474  ocalHT @ erb.HTt
-000043c0: 7261 6e73 6c61 7465 2873 656c 662e 6c69  ranslate(self.li
-000043d0: 6e6b 735b 695d 2e43 4f4d 295d 0d0a 2020  nks[i].COM)]..  
-000043e0: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-000043f0: 7265 7475 726e 2048 5443 4f4d 0d0a 2020  return HTCOM..  
-00004400: 2020 0d0a 2020 2020 232a 2a63 6c61 7373    ..    #**class
-00004410: 4675 6e63 7469 6f6e 3a20 636f 6d70 7574  Function: comput
-00004420: 6520 6c69 7374 206f 6620 6a6f 696e 7420  e list of joint 
-00004430: 746f 7271 7565 7320 666f 7220 7365 7269  torques for seri
-00004440: 616c 2072 6f62 6f74 2064 7565 2074 6f20  al robot due to 
-00004450: 6772 6176 6974 7920 2867 7261 7669 7479  gravity (gravity
-00004460: 2061 6e64 206d 6173 7320 6173 2067 6976   and mass as giv
-00004470: 656e 2069 6e20 726f 626f 7429 2c20 7461  en in robot), ta
-00004480: 6b69 6e67 2048 5420 6672 6f6d 2052 6f62  king HT from Rob
-00004490: 6f74 2e4a 6f69 6e74 4854 2829 0d0a 2020  ot.JointHT()..  
-000044a0: 2020 6465 6620 5374 6174 6963 546f 7271    def StaticTorq
-000044b0: 7565 7328 7365 6c66 2c48 5429 3a0d 0a20  ues(self,HT):.. 
-000044c0: 2020 2020 2020 206a 6f69 6e74 546f 7271         jointTorq
-000044d0: 7565 7320 3d20 6e70 2e7a 6572 6f73 286e  ues = np.zeros(n
-000044e0: 702e 7369 7a65 2873 656c 662e 6c69 6e6b  p.size(self.link
-000044f0: 7329 290d 0a20 2020 200d 0a20 2020 2020  s))..    ..     
-00004500: 2020 2023 636f 6d70 7574 6520 4854 7320     #compute HTs 
-00004510: 666f 7220 434f 4d0d 0a20 2020 2020 2020  for COM..       
-00004520: 2048 5463 6f6d 3d73 656c 662e 434f 4d48   HTcom=self.COMH
-00004530: 5428 4854 290d 0a20 2020 2020 2020 200d  T(HT)..        .
-00004540: 0a20 2020 2020 2020 2023 7375 6d20 7570  .        #sum up
-00004550: 2074 6865 2074 6f72 7175 6573 206f 6620   the torques of 
-00004560: 616c 6c20 6772 6176 6974 7920 6c6f 6164  all gravity load
-00004570: 733a 0d0a 2020 2020 2020 2020 666f 7220  s:..        for 
-00004580: 6920 696e 2072 616e 6765 286c 656e 2848  i in range(len(H
-00004590: 5463 6f6d 2929 3a0d 0a20 2020 2020 2020  Tcom)):..       
-000045a0: 2020 2020 2070 203d 2065 7262 2e48 5432       p = erb.HT2
-000045b0: 7472 616e 736c 6174 696f 6e28 4854 636f  translation(HTco
-000045c0: 6d5b 695d 290d 0a20 2020 2020 2020 2020  m[i])..         
-000045d0: 2020 204a 636f 6d20 3d20 7365 6c66 2e4a     Jcom = self.J
-000045e0: 6163 6f62 6961 6e28 4854 5b30 3a69 2b31  acobian(HT[0:i+1
-000045f0: 5d2c 746f 6f6c 506f 7369 7469 6f6e 3d70  ],toolPosition=p
-00004600: 2c6d 6f64 653d 2774 7261 6e73 2729 0d0a  ,mode='trans')..
-00004610: 2020 2020 2020 2020 2020 2020 6647 203d              fG =
-00004620: 2073 656c 662e 6c69 6e6b 735b 695d 2e6d   self.links[i].m
-00004630: 6173 7320 2a20 7365 6c66 2e67 7261 7669  ass * self.gravi
-00004640: 7479 0d0a 2020 2020 2020 2020 2020 2020  ty..            
-00004650: 7461 7520 3d20 4a63 6f6d 2e54 2040 2066  tau = Jcom.T @ f
-00004660: 470d 0a20 2020 2020 2020 2020 2020 206a  G..            j
-00004670: 6f69 6e74 546f 7271 7565 735b 303a 692b  ointTorques[0:i+
-00004680: 315d 202b 3d20 7461 750d 0a20 2020 2020  1] += tau..     
-00004690: 2020 2072 6574 7572 6e20 6a6f 696e 7454     return jointT
-000046a0: 6f72 7175 6573 0d0a 2020 2020 0d0a 2020  orques..    ..  
-000046b0: 2020 0d0a 2020 2020 232a 2a63 6c61 7373    ..    #**class
-000046c0: 4675 6e63 7469 6f6e 3a20 636f 6d70 7574  Function: comput
-000046d0: 6520 6a61 636f 6269 616e 2066 6f72 2074  e jacobian for t
-000046e0: 7261 6e73 6c61 7469 6f6e 2061 6e64 2072  ranslation and r
-000046f0: 6f74 6174 696f 6e20 6174 2074 6f6f 6c50  otation at toolP
-00004700: 6f73 6974 696f 6e20 7573 696e 6720 6a6f  osition using jo
-00004710: 696e 7420 4854 3b20 7468 6973 2069 7320  int HT; this is 
-00004720: 7573 696e 6720 7468 6520 526f 626f 7420  using the Robot 
-00004730: 6675 6e63 7469 6f6e 732c 2062 7574 2069  functions, but i
-00004740: 7320 696e 6566 6669 6369 656e 7420 666f  s inefficient fo
-00004750: 7220 7369 6d75 6c61 7469 6f6e 2070 7572  r simulation pur
-00004760: 706f 7365 730d 0a20 2020 2023 2a2a 696e  poses..    #**in
-00004770: 7075 743a 0d0a 2020 2020 2320 2048 543a  put:..    #  HT:
-00004780: 206c 6973 7420 6f66 2068 6f6d 6f67 656e   list of homogen
-00004790: 656f 7573 2074 7261 6e73 666f 726d 6174  eous transformat
-000047a0: 696f 6e73 2070 6572 206a 6f69 6e74 202c  ions per joint ,
-000047b0: 2061 7320 636f 6d70 7574 6564 2062 7920   as computed by 
-000047c0: 526f 626f 742e 4a6f 696e 7448 5428 2e2e  Robot.JointHT(..
-000047d0: 2e29 0d0a 2020 2020 2320 2074 6f6f 6c50  .)..    #  toolP
-000047e0: 6f73 6974 696f 6e3a 2067 6c6f 6261 6c20  osition: global 
-000047f0: 706f 7369 7469 6f6e 2061 7420 7768 6963  position at whic
-00004800: 6820 7468 6520 6a61 636f 6269 616e 2069  h the jacobian i
-00004810: 7320 6576 616c 7561 7465 6420 2865 2e67  s evaluated (e.g
-00004820: 2e2c 2043 4f4d 293b 2069 6620 656d 7074  ., COM); if empt
-00004830: 7920 5b5d 2c20 6974 2075 7365 7320 7468  y [], it uses th
-00004840: 6520 6f72 6967 696e 206f 6620 7468 6520  e origin of the 
-00004850: 6c61 7374 206c 696e 6b0d 0a20 2020 2023  last link..    #
-00004860: 2020 6d6f 6465 3a20 2761 6c6c 272e 2e2e    mode: 'all'...
-00004870: 7472 616e 736c 6174 696f 6e20 616e 6420  translation and 
-00004880: 726f 7461 7469 6f6e 206a 6163 6f62 6961  rotation jacobia
-00004890: 6e2c 2027 7472 616e 7327 2e2e 2e6f 6e6c  n, 'trans'...onl
-000048a0: 7920 7472 616e 736c 6174 696f 6e20 7061  y translation pa
-000048b0: 7274 2c20 2772 6f74 273a 206f 6e6c 7920  rt, 'rot': only 
-000048c0: 726f 7461 7469 6f6e 2070 6172 740d 0a20  rotation part.. 
-000048d0: 2020 2023 2020 6c69 6e6b 496e 6465 783a     #  linkIndex:
-000048e0: 206c 696e 6b20 696e 6465 7820 666f 7220   link index for 
-000048f0: 7768 6963 6820 7468 6520 6a61 636f 6269  which the jacobi
-00004900: 616e 2069 7320 6576 616c 7561 7465 643b  an is evaluated;
-00004910: 2069 6620 6c69 6e6b 496e 6465 783d 3d4e   if linkIndex==N
-00004920: 6f6e 652c 2069 7420 7573 6573 2074 6865  one, it uses the
-00004930: 206c 6173 7420 6c69 6e6b 2070 726f 7669   last link provi
-00004940: 6465 6420 696e 2048 540d 0a20 2020 2023  ded in HT..    #
-00004950: 2a2a 6f75 7470 7574 3a20 7265 7475 726e  **output: return
-00004960: 7320 6a61 636f 6269 616e 2077 6974 6820  s jacobian with 
-00004970: 7472 616e 736c 6174 696f 6e20 616e 6420  translation and 
-00004980: 726f 7461 7469 6f6e 2070 6172 7473 2069  rotation parts i
-00004990: 6e20 726f 7773 2028 3320 6f72 2036 2920  n rows (3 or 6) 
-000049a0: 6163 636f 7264 696e 6720 746f 206d 6f64  according to mod
-000049b0: 652c 2061 6e64 206f 6e65 2063 6f6c 756d  e, and one colum
-000049c0: 6e20 7065 7220 4854 3b20 696e 2074 6865  n per HT; in the
-000049d0: 206b 696e 656d 6174 6963 2074 7265 6520   kinematic tree 
-000049e0: 7468 6520 636f 6c75 6d6e 7320 6e6f 7420  the columns not 
-000049f0: 7265 6c61 7465 6420 746f 206c 696e 6b49  related to linkI
-00004a00: 6e64 6578 2072 656d 6169 6e20 7a65 726f  ndex remain zero
-00004a10: 0d0a 2020 2020 6465 6620 4a61 636f 6269  ..    def Jacobi
-00004a20: 616e 2873 656c 662c 2048 542c 2074 6f6f  an(self, HT, too
-00004a30: 6c50 6f73 6974 696f 6e3d 5b5d 2c20 6d6f  lPosition=[], mo
-00004a40: 6465 3d27 616c 6c27 2c20 6c69 6e6b 496e  de='all', linkIn
-00004a50: 6465 783d 4e6f 6e65 293a 0d0a 2020 2020  dex=None):..    
-00004a60: 2020 2020 6e20 3d20 6c65 6e28 4854 290d      n = len(HT).
-00004a70: 0a20 2020 2020 2020 2069 6620 6e20 3e20  .        if n > 
-00004a80: 6c65 6e28 7365 6c66 2e6c 696e 6b73 293a  len(self.links):
-00004a90: 0d0a 2020 2020 2020 2020 2020 2020 7072  ..            pr
-00004aa0: 696e 7428 2245 5252 4f52 3a20 6e75 6d62  int("ERROR: numb
-00004ab0: 6572 206f 6620 686f 6d6f 6765 6e65 6f75  er of homogeneou
-00004ac0: 7320 7472 616e 7366 6f72 6d61 7469 6f6e  s transformation
-00004ad0: 7320 2848 5429 2067 7265 6174 6572 2074  s (HT) greater t
-00004ae0: 6861 6e20 6e75 6d62 6572 206f 6620 6c69  han number of li
-00004af0: 6e6b 7322 290d 0a0d 0a20 2020 2020 2020  nks")....       
-00004b00: 2023 6c69 6e6b 2069 6e64 6578 2069 7320   #link index is 
-00004b10: 7573 7561 6c6c 7920 7468 6520 6c61 7374  usually the last
-00004b20: 206c 696e 6b20 636f 6e74 6169 6e65 6420   link contained 
-00004b30: 696e 2048 5420 2861 6c6c 2073 7562 7365  in HT (all subse
-00004b40: 7175 656e 7420 636f 6c75 6d6e 7320 696e  quent columns in
-00004b50: 206a 6163 6f62 6961 6e20 776f 756c 6420   jacobian would 
-00004b60: 6265 2061 6e79 7761 7920 7a65 726f 293a  be anyway zero):
-00004b70: 0d0a 2020 2020 2020 2020 6966 206c 696e  ..        if lin
-00004b80: 6b49 6e64 6578 203d 3d20 4e6f 6e65 3a0d  kIndex == None:.
-00004b90: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
-00004ba0: 6b49 6e64 6578 203d 206e 2d31 0d0a 2020  kIndex = n-1..  
-00004bb0: 2020 0d0a 2020 2020 2020 2020 4a6f 6d65    ..        Jome
-00004bc0: 6761 203d 206e 702e 7a65 726f 7328 2833  ga = np.zeros((3
-00004bd0: 2c6e 2929 2372 6f74 6174 696f 6e20 7061  ,n))#rotation pa
-00004be0: 7274 206f 6620 6a61 636f 6269 616e 0d0a  rt of jacobian..
-00004bf0: 2020 2020 2020 2020 4a76 656c 203d 206e          Jvel = n
-00004c00: 702e 7a65 726f 7328 2833 2c6e 2929 2020  p.zeros((3,n))  
-00004c10: 2374 7261 6e73 6c61 7469 6f6e 2070 6172  #translation par
-00004c20: 7420 6f66 206a 6163 6f62 6961 6e0d 0a20  t of jacobian.. 
-00004c30: 2020 2020 2020 2023 4120 3d20 6572 622e         #A = erb.
-00004c40: 4854 3272 6f74 6174 696f 6e4d 6174 7269  HT2rotationMatri
-00004c50: 7828 7365 6c66 2e47 6574 4261 7365 4854  x(self.GetBaseHT
-00004c60: 2829 290d 0a20 2020 2020 2020 2023 7650  ())..        #vP
-00004c70: 7265 7669 6f75 7320 3d20 6572 622e 4854  revious = erb.HT
-00004c80: 3274 7261 6e73 6c61 7469 6f6e 2873 656c  2translation(sel
-00004c90: 662e 4765 7442 6173 6548 5428 2929 0d0a  f.GetBaseHT())..
-00004ca0: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-00004cb0: 2020 766e 203d 206c 6973 7428 746f 6f6c    vn = list(tool
-00004cc0: 506f 7369 7469 6f6e 290d 0a20 2020 2020  Position)..     
-00004cd0: 2020 2069 6620 6c65 6e28 766e 2920 3d3d     if len(vn) ==
-00004ce0: 2030 3a0d 0a20 2020 2020 2020 2020 2020   0:..           
-00004cf0: 2076 6e20 3d20 6572 622e 4854 3274 7261   vn = erb.HT2tra
-00004d00: 6e73 6c61 7469 6f6e 2848 545b 6c69 6e6b  nslation(HT[link
-00004d10: 496e 6465 785d 2040 2073 656c 662e 6c69  Index] @ self.li
-00004d20: 6e6b 735b 6c69 6e6b 496e 6465 785d 2e6c  nks[linkIndex].l
-00004d30: 6f63 616c 4854 2920 236c 6173 7420 6c69  ocalHT) #last li
-00004d40: 6e6b 2063 6f6f 7264 696e 6174 6573 0d0a  nk coordinates..
-00004d50: 0d0a 0d0a 2020 2020 2020 2020 2366 6f72  ....        #for
-00004d60: 2074 7265 652c 2077 6520 6d61 7920 6f6e   tree, we may on
-00004d70: 6c79 2063 6f6e 7369 6465 7220 6c69 6e6b  ly consider link
-00004d80: 7320 696e 2074 6865 2063 6861 696e 2066  s in the chain f
-00004d90: 726f 6d20 6c69 6e6b 2074 6f20 6261 7365  rom link to base
-00004da0: 210d 0a20 2020 2020 2020 2069 203d 206c  !..        i = l
-00004db0: 696e 6b49 6e64 6578 0d0a 2020 2020 2020  inkIndex..      
-00004dc0: 2020 656e 6452 6561 6368 6564 203d 2046    endReached = F
-00004dd0: 616c 7365 0d0a 2020 2020 2020 2020 7768  alse..        wh
-00004de0: 696c 6520 6e6f 7420 656e 6452 6561 6368  ile not endReach
-00004df0: 6564 3a0d 0a20 2020 2020 2020 2020 2020  ed:..           
-00004e00: 2023 6966 2069 203e 2030 3a0d 0a20 2020   #if i > 0:..   
-00004e10: 2020 2020 2020 2020 2041 203d 2065 7262           A = erb
-00004e20: 2e48 5432 726f 7461 7469 6f6e 4d61 7472  .HT2rotationMatr
-00004e30: 6978 2848 545b 695d 2920 2372 6f74 6174  ix(HT[i]) #rotat
-00004e40: 696f 6e20 6f66 206a 6f69 6e74 2069 0d0a  ion of joint i..
-00004e50: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00004e60: 6c6f 6361 6c41 7869 7320 3d20 6572 622e  localAxis = erb.
-00004e70: 4854 3272 6f74 6174 696f 6e4d 6174 7269  HT2rotationMatri
-00004e80: 7828 7365 6c66 2e6c 696e 6b73 5b69 5d2e  x(self.links[i].
-00004e90: 7072 6548 5429 2040 2064 6963 744a 6f69  preHT) @ dictJoi
-00004ea0: 6e74 5479 7065 3241 7869 735b 7365 6c66  ntType2Axis[self
-00004eb0: 2e6c 696e 6b73 5b69 5d2e 6a6f 696e 7454  .links[i].jointT
-00004ec0: 7970 655d 0d0a 2020 2020 2020 2020 2020  ype]..          
-00004ed0: 2020 6c6f 6361 6c41 7869 7320 3d20 6469    localAxis = di
-00004ee0: 6374 4a6f 696e 7454 7970 6532 4178 6973  ctJointType2Axis
-00004ef0: 5b73 656c 662e 6c69 6e6b 735b 695d 2e6a  [self.links[i].j
-00004f00: 6f69 6e74 5479 7065 5d0d 0a0d 0a20 2020  ointType]....   
-00004f10: 2020 2020 2020 2020 2061 7869 7320 3d20           axis = 
-00004f20: 4120 4020 6c6f 6361 6c41 7869 7320 2361  A @ localAxis #a
-00004f30: 7869 7320 696e 2067 6c6f 6261 6c20 636f  xis in global co
-00004f40: 6f72 6469 6e61 7465 730d 0a20 2020 2020  ordinates..     
-00004f50: 2020 2020 2020 2023 4f4c 4420 4448 2070         #OLD DH p
-00004f60: 6172 616d 6574 6572 2062 6173 6564 3a20  arameter based: 
-00004f70: 4a6f 6d65 6761 5b30 3a33 2c69 5d20 3d20  Jomega[0:3,i] = 
-00004f80: 726f 626f 745b 276a 6f69 6e74 5479 7065  robot['jointType
-00004f90: 275d 5b69 5d20 2a20 6178 6973 2023 6f6e  '][i] * axis #on
-00004fa0: 6c79 2063 6f6e 7369 6465 7265 642c 2069  ly considered, i
-00004fb0: 6620 7265 766f 6c75 7465 206a 6f69 6e74  f revolute joint
-00004fc0: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-00004fd0: 2073 656c 662e 6c69 6e6b 735b 695d 2e6a   self.links[i].j
-00004fe0: 6f69 6e74 5479 7065 5b30 5d20 3d3d 2027  ointType[0] == '
-00004ff0: 5227 3a0d 0a20 2020 2020 2020 2020 2020  R':..           
-00005000: 2020 2020 204a 6f6d 6567 615b 303a 332c       Jomega[0:3,
-00005010: 695d 203d 2061 7869 7320 236f 6e6c 7920  i] = axis #only 
-00005020: 636f 6e73 6964 6572 6564 2c20 6966 2072  considered, if r
-00005030: 6576 6f6c 7574 6520 6a6f 696e 740d 0a20  evolute joint.. 
-00005040: 2020 2020 2020 2020 2020 200d 0a20 2020             ..   
-00005050: 2020 2020 2020 2020 2023 7650 7265 7669           #vPrevi
-00005060: 6f75 7320 3d20 6572 622e 4854 3274 7261  ous = erb.HT2tra
-00005070: 6e73 6c61 7469 6f6e 2848 545b 695d 2040  nslation(HT[i] @
-00005080: 2073 656c 662e 6c69 6e6b 735b 695d 2e70   self.links[i].p
-00005090: 7265 4854 290d 0a20 2020 2020 2020 2020  reHT)..         
-000050a0: 2020 2076 5072 6576 696f 7573 203d 2065     vPrevious = e
-000050b0: 7262 2e48 5432 7472 616e 736c 6174 696f  rb.HT2translatio
-000050c0: 6e28 4854 5b69 5d29 0d0a 2020 2020 2020  n(HT[i])..      
-000050d0: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-000050e0: 2020 2020 2023 7265 766f 6c75 7465 206a       #revolute j
-000050f0: 6f69 6e74 3a0d 0a20 2020 2020 2020 2020  oint:..         
-00005100: 2020 2069 6620 7365 6c66 2e6c 696e 6b73     if self.links
-00005110: 5b69 5d2e 6a6f 696e 7454 7970 655b 305d  [i].jointType[0]
-00005120: 203d 3d20 2752 273a 2023 7265 766f 6c75   == 'R': #revolu
-00005130: 7465 206a 6f69 6e74 0d0a 2020 2020 2020  te joint..      
-00005140: 2020 2020 2020 2020 2020 4a76 656c 5b30            Jvel[0
-00005150: 3a33 2c69 5d20 2020 3d20 6572 622e 536b  :3,i]   = erb.Sk
-00005160: 6577 2861 7869 7329 2040 2028 766e 202d  ew(axis) @ (vn -
-00005170: 2076 5072 6576 696f 7573 2920 236f 6e6c   vPrevious) #onl
-00005180: 7920 636f 6e73 6964 6572 6564 2c20 6966  y considered, if
-00005190: 2072 6576 6f6c 7574 6520 6a6f 696e 740d   revolute joint.
-000051a0: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-000051b0: 6620 7365 6c66 2e6c 696e 6b73 5b69 5d2e  f self.links[i].
-000051c0: 6a6f 696e 7454 7970 655b 305d 203d 3d20  jointType[0] == 
-000051d0: 2750 273a 2023 7072 6973 6d61 7469 6320  'P': #prismatic 
-000051e0: 6a6f 696e 740d 0a20 2020 2020 2020 2020  joint..         
-000051f0: 2020 2020 2020 204a 7665 6c5b 303a 332c         Jvel[0:3,
-00005200: 695d 2020 203d 2061 7869 730d 0a20 2020  i]   = axis..   
-00005210: 2020 2020 2020 2020 2065 6c73 653a 0d0a           else:..
-00005220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005230: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00005240: 2827 526f 626f 742e 4a61 636f 6269 616e  ('Robot.Jacobian
-00005250: 282e 2e2e 293a 2069 6c6c 6567 616c 206a  (...): illegal j
-00005260: 6f69 6e74 5479 7065 2729 0d0a 2020 2020  ointType')..    
-00005270: 2020 2020 2020 2020 2020 2020 0d0a 2020              ..  
-00005280: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-00005290: 2073 656c 662e 4861 7350 6172 656e 7428   self.HasParent(
-000052a0: 6929 3a0d 0a20 2020 2020 2020 2020 2020  i):..           
-000052b0: 2020 2020 2065 6e64 5265 6163 6865 6420       endReached 
-000052c0: 3d20 5472 7565 0d0a 2020 2020 2020 2020  = True..        
-000052d0: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-000052e0: 2020 2020 2020 2020 2020 2069 203d 2073             i = s
-000052f0: 656c 662e 4765 7450 6172 656e 7449 6e64  elf.GetParentInd
-00005300: 6578 2869 290d 0a20 2020 2020 2020 200d  ex(i)..        .
-00005310: 0a20 2020 2020 2020 2069 6620 6d6f 6465  .        if mode
-00005320: 203d 3d20 2772 6f74 273a 0d0a 2020 2020   == 'rot':..    
-00005330: 2020 2020 2020 2020 4a20 3d20 4a6f 6d65          J = Jome
-00005340: 6761 0d0a 2020 2020 2020 2020 656c 6966  ga..        elif
-00005350: 206d 6f64 6520 3d3d 2027 7472 616e 7327   mode == 'trans'
-00005360: 3a0d 0a20 2020 2020 2020 2020 2020 204a  :..            J
-00005370: 203d 204a 7665 6c0d 0a20 2020 2020 2020   = Jvel..       
-00005380: 2065 6c69 6620 6d6f 6465 203d 3d20 2761   elif mode == 'a
-00005390: 6c6c 273a 0d0a 2020 2020 2020 2020 2020  ll':..          
-000053a0: 2020 4a20 3d20 6e70 2e7a 6572 6f73 2828    J = np.zeros((
-000053b0: 362c 6e29 290d 0a20 2020 2020 2020 2020  6,n))..         
-000053c0: 2020 204a 5b30 3a33 2c30 3a6e 5d20 3d20     J[0:3,0:n] = 
-000053d0: 4a76 656c 0d0a 2020 2020 2020 2020 2020  Jvel..          
-000053e0: 2020 4a5b 333a 362c 303a 6e5d 203d 204a    J[3:6,0:n] = J
-000053f0: 6f6d 6567 610d 0a20 2020 200d 0a20 2020  omega..    ..   
-00005400: 2020 2020 2072 6574 7572 6e20 4a0d 0a0d       return J...
-00005410: 0a0d 0a20 2020 2023 2525 2b2b 2b2b 2b2b  ...    #%%++++++
-00005420: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005430: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005440: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005450: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005460: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005470: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005480: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005490: 2b2b 0d0a 2020 2020 232a 2a63 6c61 7373  ++..    #**class
-000054a0: 4675 6e63 7469 6f6e 3a20 4164 6420 6120  Function: Add a 
-000054b0: 4f62 6a65 6374 4b69 6e65 6d61 7469 6354  ObjectKinematicT
-000054c0: 7265 6520 746f 2065 7869 7374 696e 6720  ree to existing 
-000054d0: 6d62 7320 6672 6f6d 2074 6865 2072 6f62  mbs from the rob
-000054e0: 6f74 2073 7472 7563 7475 7265 2069 6e73  ot structure ins
-000054f0: 6964 6520 7468 6973 2072 6f62 6f74 2063  ide this robot c
-00005500: 6c61 7373 3b0d 0a20 2020 2023 2020 2020  lass;..    #    
-00005510: 2020 2020 2020 2020 2020 2020 204a 6f69               Joi
-00005520: 6e74 7320 6465 6669 6e65 6420 6279 2074  nts defined by t
-00005530: 6865 206b 696e 656d 6174 6963 7320 6173  he kinematics as
-00005540: 2077 656c 6c20 6173 206c 696e 6b73 2028   well as links (
-00005550: 616e 6420 696e 6572 7469 6129 2061 7265  and inertia) are
-00005560: 2074 7261 6e73 6665 7272 6564 2074 6f20   transferred to 
-00005570: 7468 6520 6b69 6e65 6d61 7469 6320 7472  the kinematic tr
-00005580: 6565 206f 626a 6563 743b 0d0a 2020 2020  ee object;..    
-00005590: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-000055a0: 2020 4375 7272 656e 7420 696d 706c 656d    Current implem
-000055b0: 656e 7461 7469 6f6e 206f 6e6c 7920 776f  entation only wo
-000055c0: 726b 7320 666f 7220 7365 7269 616c 2072  rks for serial r
-000055d0: 6f62 6f74 733b 0d0a 2020 2020 2320 2020  obots;..    #   
-000055e0: 2020 2020 2020 2020 2020 2020 2020 436f                Co
-000055f0: 6e74 726f 6c20 6361 6e20 6265 2072 6561  ntrol can be rea
-00005600: 6c69 7a65 6420 7369 6d70 6c79 2062 7920  lized simply by 
-00005610: 6164 6469 6e67 2050 4463 6f6e 7472 6f6c  adding PDcontrol
-00005620: 2074 6f20 526f 626f 744c 696e 6b20 7374   to RobotLink st
-00005630: 7275 6374 7572 6573 2c20 7468 656e 206d  ructures, then m
-00005640: 6f64 6966 7969 6e67 206a 6f69 6e74 506f  odifying jointPo
-00005650: 7369 7469 6f6e 4f66 6673 6574 5665 6374  sitionOffsetVect
-00005660: 6f72 2061 6e64 206a 6f69 6e74 5665 6c6f  or and jointVelo
-00005670: 6369 7479 4f66 6673 6574 5665 6374 6f72  cityOffsetVector
-00005680: 2069 6e20 4f62 6a65 6374 4b69 6e65 6d61   in ObjectKinema
-00005690: 7469 6354 7265 653b 2066 6f72 6365 206f  ticTree; force o
-000056a0: 6666 7365 7473 2028 652e 672e 2c20 7374  ffsets (e.g., st
-000056b0: 6174 6963 206f 7220 6479 6e61 6d69 6320  atic or dynamic 
-000056c0: 746f 7271 7565 2063 6f6d 7065 6e73 6174  torque compensat
-000056d0: 696f 6e29 2063 616e 2062 6520 6164 6465  ion) can be adde
-000056e0: 6420 746f 204b 696e 656d 6174 6963 5472  d to KinematicTr
-000056f0: 6565 206a 6f69 6e74 466f 7263 6556 6563  ee jointForceVec
-00005700: 746f 723b 206d 6f72 6520 6765 6e65 7261  tor; more genera
-00005710: 6c20 636f 6e74 726f 6c20 6361 6e20 6265  l control can be
-00005720: 2061 6464 6564 2062 7920 7573 696e 6720   added by using 
-00005730: 4b69 6e65 6d61 7469 6354 7265 6520 666f  KinematicTree fo
-00005740: 7263 6555 7365 7246 756e 6374 696f 6e3b  rceUserFunction;
-00005750: 0d0a 2020 2020 2320 2020 2020 2020 2020  ..    #         
-00005760: 2020 2020 2020 2020 5468 6520 636f 6f72          The coor
-00005770: 6469 6e61 7465 7320 696e 204b 696e 656d  dinates in Kinem
-00005780: 6174 6963 5472 6565 2028 6173 2077 656c  aticTree (as wel
-00005790: 6c20 6173 206a 6f69 6e74 506f 7369 7469  l as jointPositi
-000057a0: 6f6e 4f66 6673 6574 5665 6374 6f72 2c20  onOffsetVector, 
-000057b0: 6574 632e 2920 6172 6520 736f 7274 6564  etc.) are sorted
-000057c0: 2069 6e20 7468 6520 6f72 6465 7220 6173   in the order as
-000057d0: 2074 6865 2052 6f62 6f74 4c69 6e6b 7320   the RobotLinks 
-000057e0: 6172 6520 6164 6465 6420 746f 2074 6865  are added to the
-000057f0: 2052 6f62 6f74 2063 6c61 7373 3b0d 0a20   Robot class;.. 
-00005800: 2020 2023 2020 2020 2020 2020 2020 2020     #            
-00005810: 2020 2020 204e 6f74 6520 7468 6174 2074       Note that t
-00005820: 6865 204f 626a 6563 744b 696e 656d 6174  he ObjectKinemat
-00005830: 6963 5472 6565 2069 7320 7374 696c 6c20  icTree is still 
-00005840: 756e 6465 7220 6465 7665 6c6f 706d 656e  under developmen
-00005850: 7420 616e 6420 696e 7465 7266 6163 6573  t and interfaces
-00005860: 206d 6179 2063 6861 6e67 652e 0d0a 2020   may change...  
-00005870: 2020 232a 2a69 6e70 7574 3a20 0d0a 2020    #**input: ..  
-00005880: 2020 2320 2020 6d62 733a 2074 6865 206d    #   mbs: the m
-00005890: 756c 7469 626f 6479 2073 7973 7465 6d2c  ultibody system,
-000058a0: 2077 6869 6368 2077 696c 6c20 6265 2065   which will be e
-000058b0: 7874 656e 6465 640d 0a20 2020 2023 2020  xtended..    #  
-000058c0: 206e 616d 653a 206f 626a 6563 7420 6e61   name: object na
-000058d0: 6d65 2069 6e20 4b69 6e65 6d61 7469 6354  me in KinematicT
-000058e0: 7265 653b 2074 7261 6e73 6665 7272 6564  ree; transferred
-000058f0: 2074 6f20 4b69 6e65 6d61 7469 6354 7265   to KinematicTre
-00005900: 652c 2064 6566 6175 6c74 203d 2027 270d  e, default = ''.
-00005910: 0a20 2020 2023 2020 2066 6f72 6365 5573  .    #   forceUs
-00005920: 6572 4675 6e63 7469 6f6e 3a20 6465 6669  erFunction: defi
-00005930: 6e65 7320 7468 6520 7573 6572 2066 756e  nes the user fun
-00005940: 6374 696f 6e20 666f 7220 636f 6d70 7574  ction for comput
-00005950: 6174 696f 6e20 6f66 206a 6f69 6e74 2066  ation of joint f
-00005960: 6f72 6365 7320 696e 204b 696e 656d 6174  orces in Kinemat
-00005970: 6963 5472 6565 3b20 7472 616e 7366 6572  icTree; transfer
-00005980: 7265 6420 746f 204b 696e 656d 6174 6963  red to Kinematic
-00005990: 5472 6565 2c20 6465 6661 756c 7420 3d20  Tree, default = 
-000059a0: 300d 0a20 2020 2023 2a2a 6f75 7470 7574  0..    #**output
-000059b0: 3a20 7468 6520 6675 6e63 7469 6f6e 2072  : the function r
-000059c0: 6574 7572 6e73 2061 2064 6963 7469 6f6e  eturns a diction
-000059d0: 6172 7920 636f 6e74 6169 6e69 6e67 2027  ary containing '
-000059e0: 6e6f 6465 4765 6e65 7269 6327 3a20 6765  nodeGeneric': ge
-000059f0: 6e65 7269 6320 4f44 4532 206e 6f64 6520  neric ODE2 node 
-00005a00: 6e75 6d62 6572 202c 276f 626a 6563 744b  number ,'objectK
-00005a10: 696e 656d 6174 6963 5472 6565 273a 2074  inematicTree': t
-00005a20: 6865 206b 696e 656d 6174 6963 2074 7265  he kinematic tre
-00005a30: 6520 6f62 6a65 6374 2c20 2762 6173 654f  e object, 'baseO
-00005a40: 626a 6563 7427 3a20 7468 6520 6261 7365  bject': the base
-00005a50: 206f 626a 6563 7420 6966 2063 7265 6174   object if creat
-00005a60: 6564 2c20 6f74 6865 7277 6973 6520 4e6f  ed, otherwise No
-00005a70: 6e65 3b20 6675 7274 6865 7220 7661 6c75  ne; further valu
-00005a80: 6573 2077 696c 6c20 6265 2061 6464 6564  es will be added
-00005a90: 2069 6e20 6675 7475 7265 0d0a 2020 2020   in future..    
-00005aa0: 6465 6620 4372 6561 7465 4b69 6e65 6d61  def CreateKinema
-00005ab0: 7469 6354 7265 6528 7365 6c66 2c20 6d62  ticTree(self, mb
-00005ac0: 732c 206e 616d 6520 3d20 2727 2c20 666f  s, name = '', fo
-00005ad0: 7263 6555 7365 7246 756e 6374 696f 6e20  rceUserFunction 
-00005ae0: 3d20 3029 3a0d 0a20 2020 2020 2020 2023  = 0):..        #
-00005af0: 6465 6620 4372 6561 7465 4b69 6e65 6d61  def CreateKinema
-00005b00: 7469 6354 7265 6528 7365 6c66 2c20 6d62  ticTree(self, mb
-00005b10: 732c 206a 6f69 6e74 5370 7269 6e67 4461  s, jointSpringDa
-00005b20: 6d70 6572 5573 6572 4675 6e63 7469 6f6e  mperUserFunction
-00005b30: 4c69 7374 3d5b 5d29 3a0d 0a0d 0a20 2020  List=[]):....   
-00005b40: 2020 2020 2023 6164 6420 6772 6170 6869       #add graphi
-00005b50: 6373 2066 6f72 2062 6173 653a 0d0a 2020  cs for base:..  
-00005b60: 2020 2020 2020 6261 7365 4f62 6a65 6374        baseObject
-00005b70: 203d 204e 6f6e 6520 2369 6620 6974 2064   = None #if it d
-00005b80: 6f65 7320 6e6f 7420 6578 6973 740d 0a20  oes not exist.. 
-00005b90: 2020 2020 2020 2062 6173 654f 6666 7365         baseOffse
-00005ba0: 7420 3d20 6572 622e 4854 3274 7261 6e73  t = erb.HT2trans
-00005bb0: 6c61 7469 6f6e 2873 656c 662e 6261 7365  lation(self.base
-00005bc0: 2e48 5429 0d0a 0d0a 2020 2020 2020 2020  .HT)....        
-00005bd0: 6966 2073 656c 662e 6261 7365 2e76 6973  if self.base.vis
-00005be0: 7561 6c69 7a61 7469 6f6e 2e67 7261 7068  ualization.graph
-00005bf0: 6963 7344 6174 6120 213d 205b 5d3a 0d0a  icsData != []:..
-00005c00: 2020 2020 2020 2020 2020 2020 2361 6464              #add
-00005c10: 2061 2067 726f 756e 6420 6f62 6a65 6374   a ground object
-00005c20: 2061 7420 6261 7365 2070 6f73 6974 696f   at base positio
-00005c30: 6e0d 0a20 2020 2020 2020 2020 2020 2067  n..            g
-00005c40: 7261 7068 6963 7344 6174 6142 6173 6520  raphicsDataBase 
-00005c50: 3d20 5b5d 0d0a 2020 2020 2020 2020 2020  = []..          
-00005c60: 2020 704f 6666 203d 2062 6173 654f 6666    pOff = baseOff
-00005c70: 7365 740d 0a20 2020 2020 2020 2020 2020  set..           
-00005c80: 2041 6f66 6620 3d20 6572 622e 4854 3272   Aoff = erb.HT2r
-00005c90: 6f74 6174 696f 6e4d 6174 7269 7828 7365  otationMatrix(se
-00005ca0: 6c66 2e62 6173 652e 4854 290d 0a20 2020  lf.base.HT)..   
-00005cb0: 2020 2020 2020 2020 2066 6f72 2064 6174           for dat
-00005cc0: 6120 696e 2073 656c 662e 6261 7365 2e76  a in self.base.v
-00005cd0: 6973 7561 6c69 7a61 7469 6f6e 2e67 7261  isualization.gra
-00005ce0: 7068 6963 7344 6174 613a 0d0a 2020 2020  phicsData:..    
-00005cf0: 2020 2020 2020 2020 2020 2020 6772 6170              grap
-00005d00: 6869 6373 4461 7461 4261 7365 202b 3d20  hicsDataBase += 
-00005d10: 5b65 6764 2e4d 6f76 6547 7261 7068 6963  [egd.MoveGraphic
-00005d20: 7344 6174 6128 6461 7461 2c20 5b30 2c30  sData(data, [0,0
-00005d30: 2c30 5d2c 2041 6f66 6629 5d20 236f 6e6c  ,0], Aoff)] #onl
-00005d40: 7920 726f 7461 7465 642c 2074 7261 6e73  y rotated, trans
-00005d50: 6c61 7469 6f6e 2069 7320 696e 2067 726f  lation is in gro
-00005d60: 756e 640d 0a0d 0a20 2020 2020 2020 2020  und....         
-00005d70: 2020 2062 6173 654f 626a 6563 7420 3d20     baseObject = 
-00005d80: 6d62 732e 4164 644f 626a 6563 7428 6569  mbs.AddObject(ei
-00005d90: 692e 4f62 6a65 6374 4772 6f75 6e64 2872  i.ObjectGround(r
-00005da0: 6566 6572 656e 6365 506f 7369 7469 6f6e  eferencePosition
-00005db0: 3d70 4f66 662c 200d 0a20 2020 2020 2020  =pOff, ..       
-00005dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005de0: 2020 2020 2020 2020 2020 2020 2076 6973               vis
-00005df0: 7561 6c69 7a61 7469 6f6e 3d65 6969 2e56  ualization=eii.V
-00005e00: 4f62 6a65 6374 4772 6f75 6e64 2867 7261  ObjectGround(gra
-00005e10: 7068 6963 7344 6174 613d 6772 6170 6869  phicsData=graphi
-00005e20: 6373 4461 7461 4261 7365 2929 290d 0a0d  csDataBase)))...
-00005e30: 0a20 2020 2020 2020 2023 2b2b 2b2b 2b2b  .        #++++++
-00005e40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00005e50: 2b0d 0a20 2020 2020 2020 2023 5463 7572  +..        #Tcur
-00005e60: 7265 6e74 203d 2073 656c 662e 4765 7442  rent = self.GetB
-00005e70: 6173 6548 5428 290d 0a20 2020 2020 2020  aseHT()..       
-00005e80: 2071 5265 6620 3d20 7365 6c66 2e72 6566   qRef = self.ref
-00005e90: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
-00005ea0: 696f 6e0d 0a20 2020 2020 2020 200d 0a20  ion..        .. 
-00005eb0: 2020 2020 2020 206e 4c69 6e6b 7320 3d20         nLinks = 
-00005ec0: 6c65 6e28 7365 6c66 2e6c 696e 6b73 290d  len(self.links).
-00005ed0: 0a20 2020 2020 2020 2067 7261 7068 6963  .        graphic
-00005ee0: 7344 6174 614c 6973 7420 3d20 5b5d 2020  sDataList = []  
-00005ef0: 2023 6c69 7374 206f 6620 6772 6170 6869   #list of graphi
-00005f00: 6373 4461 7461 2070 6572 206c 696e 6b0d  csData per link.
-00005f10: 0a20 2020 2020 2020 206a 6f69 6e74 5479  .        jointTy
-00005f20: 7065 734c 6973 7420 3d20 5b5d 2020 2020  pesList = []    
-00005f30: 2023 6578 7564 796e 206a 6f69 6e74 2074   #exudyn joint t
-00005f40: 7970 6573 0d0a 2020 2020 2020 2020 6c69  ypes..        li
-00005f50: 6e6b 5061 7265 6e74 7320 3d20 5b5d 0d0a  nkParents = []..
-00005f60: 0d0a 2020 2020 2020 2020 6a6f 696e 7454  ..        jointT
-00005f70: 7261 6e73 666f 726d 6174 696f 6e73 3d5b  ransformations=[
-00005f80: 5d0d 0a20 2020 2020 2020 206a 6f69 6e74  ]..        joint
-00005f90: 4f66 6673 6574 733d 5b5d 0d0a 2020 2020  Offsets=[]..    
-00005fa0: 2020 2020 6c69 6e6b 496e 6572 7469 6173      linkInertias
-00005fb0: 434f 4d3d 5b5d 200d 0a20 2020 2020 2020  COM=[] ..       
-00005fc0: 206c 696e 6b43 4f4d 733d 5b5d 0d0a 2020   linkCOMs=[]..  
-00005fd0: 2020 2020 2020 6c69 6e6b 4d61 7373 6573        linkMasses
-00005fe0: 3d5b 5d0d 0a0d 0a20 2020 2020 2020 2023  =[]....        #
-00005ff0: 6966 2050 4420 636f 6e74 726f 6c20 6578  if PD control ex
-00006000: 6973 7473 2c20 7468 6973 2076 6563 746f  ists, this vecto
-00006010: 7220 6973 206b 6570 742c 206f 7468 6572  r is kept, other
-00006020: 7769 7365 2065 7261 7365 643a 0d0a 2020  wise erased:..  
-00006030: 2020 2020 2020 6a6f 696e 7450 436f 6e74        jointPCont
-00006040: 726f 6c56 6563 746f 7220 3d20 5b30 5d2a  rolVector = [0]*
-00006050: 6e4c 696e 6b73 0d0a 2020 2020 2020 2020  nLinks..        
-00006060: 6a6f 696e 7444 436f 6e74 726f 6c56 6563  jointDControlVec
-00006070: 746f 7220 3d20 5b30 5d2a 6e4c 696e 6b73  tor = [0]*nLinks
-00006080: 0d0a 2020 2020 2020 2020 6a6f 696e 7450  ..        jointP
-00006090: 6f73 6974 696f 6e4f 6666 7365 7456 6563  ositionOffsetVec
-000060a0: 746f 7220 3d20 5b30 5d2a 6e4c 696e 6b73  tor = [0]*nLinks
-000060b0: 0d0a 2020 2020 2020 2020 6a6f 696e 7456  ..        jointV
-000060c0: 656c 6f63 6974 794f 6666 7365 7456 6563  elocityOffsetVec
-000060d0: 746f 7220 3d20 5b30 5d2a 6e4c 696e 6b73  tor = [0]*nLinks
-000060e0: 0d0a 2020 2020 2020 2020 6861 7350 4463  ..        hasPDc
-000060f0: 6f6e 7472 6f6c 203d 2046 616c 7365 2023  ontrol = False #
-00006100: 5472 7565 2c20 6966 2061 6e79 206c 696e  True, if any lin
-00006110: 6b20 6861 7320 636f 6e74 726f 6c0d 0a20  k has control.. 
-00006120: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00006130: 2023 6372 6561 7465 2072 6f62 6f74 2074   #create robot t
-00006140: 7265 653a 0d0a 2020 2020 2020 2020 666f  ree:..        fo
-00006150: 7220 6920 696e 2072 616e 6765 286e 4c69  r i in range(nLi
-00006160: 6e6b 7329 3a0d 0a20 2020 2020 2020 2020  nks):..         
-00006170: 2020 206c 696e 6b20 3d20 7365 6c66 2e6c     link = self.l
-00006180: 696e 6b73 5b69 5d0d 0a20 2020 2020 2020  inks[i]..       
-00006190: 2020 2020 206c 696e 6b50 6172 656e 7473       linkParents
-000061a0: 202b 3d20 5b73 656c 662e 4765 7450 6172   += [self.GetPar
-000061b0: 656e 7449 6e64 6578 2869 295d 0d0a 0d0a  entIndex(i)]....
-000061c0: 2020 2020 2020 2020 2020 2020 2320 6966              # if
-000061d0: 206e 702e 6c69 6e61 6c67 2e6e 6f72 6d28   np.linalg.norm(
-000061e0: 6c69 6e6b 2e6c 6f63 616c 4854 202d 2065  link.localHT - e
-000061f0: 7262 2e48 5430 2829 2920 3e3d 2031 652d  rb.HT0()) >= 1e-
-00006200: 3134 3a20 236e 6f77 2069 6d70 6c65 6d65  14: #now impleme
-00006210: 6e74 6564 0d0a 2020 2020 2020 2020 2020  nted..          
-00006220: 2020 2320 2020 2020 7261 6973 6520 5661    #     raise Va
-00006230: 6c75 6545 7272 6f72 2827 4372 6561 7465  lueError('Create
-00006240: 4b69 6e65 6d61 7469 6354 7265 653a 2063  KinematicTree: c
-00006250: 616e 206f 6e6c 7920 636f 6e76 6572 7420  an only convert 
-00006260: 726f 626f 7473 2077 6974 6820 6c6f 6361  robots with loca
-00006270: 6c48 5420 3d20 6964 656e 7469 7479 2729  lHT = identity')
-00006280: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-00006290: 206c 696e 6b2e 6a6f 696e 7454 7970 6520   link.jointType 
-000062a0: 6e6f 7420 696e 2064 6963 744a 6f69 6e74  not in dictJoint
-000062b0: 5479 7065 3241 7869 733a 0d0a 2020 2020  Type2Axis:..    
-000062c0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-000062d0: 6520 5661 6c75 6545 7272 6f72 2827 4372  e ValueError('Cr
-000062e0: 6561 7465 4b69 6e65 6d61 7469 6354 7265  eateKinematicTre
-000062f0: 653a 2066 6f75 6e64 2069 6e76 616c 6964  e: found invalid
-00006300: 206a 6f69 6e74 2074 7970 6520 696e 206c   joint type in l
-00006310: 696e 6b20 272b 7374 7228 6929 2b27 3a27  ink '+str(i)+':'
-00006320: 2b6c 696e 6b2e 6a6f 696e 7454 7970 6529  +link.jointType)
-00006330: 0d0a 0d0a 0d0a 2020 2020 2020 2020 2020  ......          
-00006340: 2020 6178 6973 203d 2064 6963 744a 6f69    axis = dictJoi
-00006350: 6e74 5479 7065 3241 7869 735b 6c69 6e6b  ntType2Axis[link
-00006360: 2e6a 6f69 6e74 5479 7065 5d0d 0a20 2020  .jointType]..   
-00006370: 2020 2020 2020 2020 200d 0a20 2020 2020           ..     
-00006380: 2020 2020 2020 2069 6620 6c69 6e6b 2e48         if link.H
-00006390: 6173 5044 636f 6e74 726f 6c28 293a 0d0a  asPDcontrol():..
-000063a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000063b0: 6a6f 696e 7450 436f 6e74 726f 6c56 6563  jointPControlVec
-000063c0: 746f 725b 695d 203d 206c 696e 6b2e 4765  tor[i] = link.Ge
-000063d0: 7450 4463 6f6e 7472 6f6c 2829 5b30 5d0d  tPDcontrol()[0].
-000063e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000063f0: 206a 6f69 6e74 4443 6f6e 7472 6f6c 5665   jointDControlVe
-00006400: 6374 6f72 5b69 5d20 3d20 6c69 6e6b 2e47  ctor[i] = link.G
-00006410: 6574 5044 636f 6e74 726f 6c28 295b 315d  etPDcontrol()[1]
-00006420: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006430: 2020 6861 7350 4463 6f6e 7472 6f6c 203d    hasPDcontrol =
-00006440: 2054 7275 650d 0a20 2020 2020 2020 2020   True..         
-00006450: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00006460: 2020 2020 2023 2063 6f6d 203d 206c 696e       # com = lin
-00006470: 6b2e 434f 4d0d 0a20 2020 2020 2020 2020  k.COM..         
-00006480: 2020 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b     #++++++++++++
-00006490: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000064a0: 2b2b 2b2b 2b2b 0d0a 2020 2020 2020 2020  ++++++..        
-000064b0: 2020 2020 6a6f 696e 7454 7970 6573 4c69      jointTypesLi
-000064c0: 7374 202b 3d20 5b64 6963 744a 6f69 6e74  st += [dictJoint
-000064d0: 5479 7065 5465 7874 3245 7875 6479 6e5b  TypeText2Exudyn[
-000064e0: 6c69 6e6b 2e6a 6f69 6e74 5479 7065 5d5d  link.jointType]]
-000064f0: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00006500: 6a6f 696e 7454 7261 6e73 666f 726d 6174  jointTransformat
-00006510: 696f 6e73 202b 3d20 5b65 7262 2e48 5432  ions += [erb.HT2
-00006520: 726f 7461 7469 6f6e 4d61 7472 6978 286c  rotationMatrix(l
-00006530: 696e 6b2e 7072 6548 5429 5d20 0d0a 2020  ink.preHT)] ..  
-00006540: 2020 2020 2020 2020 2020 2320 6a6f 696e            # join
-00006550: 744f 6666 7365 7473 202b 3d20 5b65 7262  tOffsets += [erb
-00006560: 2e48 5432 7472 616e 736c 6174 696f 6e28  .HT2translation(
-00006570: 6c69 6e6b 2e70 7265 4854 295d 0d0a 2020  link.preHT)]..  
-00006580: 2020 2020 2020 2020 2020 0d0a 2020 2020            ..    
-00006590: 2020 2020 2020 2020 2320 0d0a 2020 2020          # ..    
-000065a0: 2020 2020 2020 2020 7061 7265 6e74 4c69          parentLi
-000065b0: 6e6b 4c6f 6361 6c48 5420 3d20 6572 622e  nkLocalHT = erb.
-000065c0: 4854 3028 290d 0a20 2020 2020 2020 2020  HT0()..         
-000065d0: 2020 2069 6620 7365 6c66 2e48 6173 5061     if self.HasPa
-000065e0: 7265 6e74 2869 293a 0d0a 2020 2020 2020  rent(i):..      
-000065f0: 2020 2020 2020 2020 2020 7061 7265 6e74            parent
-00006600: 4c69 6e6b 4c6f 6361 6c48 5420 3d20 7365  LinkLocalHT = se
-00006610: 6c66 2e6c 696e 6b73 5b73 656c 662e 4765  lf.links[self.Ge
-00006620: 7450 6172 656e 7449 6e64 6578 2869 295d  tParentIndex(i)]
-00006630: 2e6c 6f63 616c 4854 0d0a 2020 2020 2020  .localHT..      
-00006640: 2020 2020 2020 6a6f 696e 7454 7261 6e73        jointTrans
-00006650: 666f 726d 6174 696f 6e73 202b 3d20 5b65  formations += [e
-00006660: 7262 2e48 5432 726f 7461 7469 6f6e 4d61  rb.HT2rotationMa
-00006670: 7472 6978 2870 6172 656e 744c 696e 6b4c  trix(parentLinkL
-00006680: 6f63 616c 4854 2040 206c 696e 6b2e 7072  ocalHT @ link.pr
-00006690: 6548 5429 5d20 0d0a 2020 2020 2020 2020  eHT)] ..        
-000066a0: 2020 2020 6a6f 696e 744f 6666 7365 7473      jointOffsets
-000066b0: 202b 3d20 5b65 7262 2e48 5432 7472 616e   += [erb.HT2tran
-000066c0: 736c 6174 696f 6e28 7061 7265 6e74 4c69  slation(parentLi
-000066d0: 6e6b 4c6f 6361 6c48 5420 4020 6c69 6e6b  nkLocalHT @ link
-000066e0: 2e70 7265 4854 295d 0d0a 0d0a 2020 2020  .preHT)]....    
-000066f0: 2020 2020 2020 2020 2369 6e65 7274 6961          #inertia
-00006700: 2069 7320 6465 6669 6e65 6420 696e 206c   is defined in l
-00006710: 696e 6b20 636f 6f72 6469 6e61 7465 733b  ink coordinates;
-00006720: 2062 7574 204b 696e 656d 6174 6963 5472   but KinematicTr
-00006730: 6565 206e 6565 6473 2069 6e65 7274 6961  ee needs inertia
-00006740: 2077 2e72 2e74 2e20 6a6f 696e 7420 636f   w.r.t. joint co
-00006750: 6f72 6469 6e61 7465 733a 0d0a 2020 2020  ordinates:..    
-00006760: 2020 2020 2020 2020 7262 6920 3d20 6572          rbi = er
-00006770: 622e 5269 6769 6442 6f64 7949 6e65 7274  b.RigidBodyInert
-00006780: 6961 2829 0d0a 2020 2020 2020 2020 2020  ia()..          
-00006790: 2020 7262 692e 5365 7457 6974 6843 4f4d    rbi.SetWithCOM
-000067a0: 696e 6572 7469 6128 6c69 6e6b 2e6d 6173  inertia(link.mas
-000067b0: 732c 206c 696e 6b2e 696e 6572 7469 612c  s, link.inertia,
-000067c0: 206c 696e 6b2e 434f 4d29 0d0a 2020 2020   link.COM)..    
-000067d0: 0d0a 2020 2020 2020 2020 2020 2020 7262  ..            rb
-000067e0: 6920 3d20 7262 692e 5472 616e 7366 6f72  i = rbi.Transfor
-000067f0: 6d65 6428 286c 696e 6b2e 6c6f 6361 6c48  med((link.localH
-00006800: 5429 2920 2369 6e65 7274 6961 2070 6172  T)) #inertia par
-00006810: 616d 6574 6572 7320 6e65 6564 2074 6f20  ameters need to 
-00006820: 6265 2074 7261 6e73 666f 726d 6564 2074  be transformed t
-00006830: 6f20 6a6f 696e 7420 6672 616d 650d 0a20  o joint frame.. 
-00006840: 2020 2020 2020 2020 2020 200d 0a20 2020             ..   
-00006850: 2020 2020 2020 2020 206c 696e 6b49 6e65           linkIne
-00006860: 7274 6961 7343 4f4d 202b 3d20 5b72 6269  rtiasCOM += [rbi
-00006870: 2e49 6e65 7274 6961 434f 4d28 295d 2023  .InertiaCOM()] #
-00006880: 4b69 6e65 6d61 7469 6354 7265 6520 6e65  KinematicTree ne
-00006890: 6564 7320 696e 6572 7469 6120 772e 722e  eds inertia w.r.
-000068a0: 742e 2043 4f4d 0d0a 2020 2020 2020 2020  t. COM..        
-000068b0: 2020 2020 6c69 6e6b 434f 4d73 202b 3d20      linkCOMs += 
-000068c0: 5b72 6269 2e43 4f4d 2829 5d20 0d0a 2020  [rbi.COM()] ..  
-000068d0: 2020 2020 2020 2020 2020 6c69 6e6b 4d61            linkMa
-000068e0: 7373 6573 202b 3d20 5b72 6269 2e4d 6173  sses += [rbi.Mas
-000068f0: 7328 295d 0d0a 2020 2020 2020 2020 2020  s()]..          
-00006900: 2020 2320 6c69 6e6b 496e 6572 7469 6173    # linkInertias
-00006910: 434f 4d20 2b3d 205b 6c69 6e6b 2e69 6e65  COM += [link.ine
-00006920: 7274 6961 5d20 2369 7320 616c 7265 6164  rtia] #is alread
-00006930: 7920 772e 722e 742e 2043 4f4d 0d0a 2020  y w.r.t. COM..  
-00006940: 2020 2020 2020 2020 2020 2320 6c69 6e6b            # link
-00006950: 434f 4d73 202b 3d20 5b6c 696e 6b2e 434f  COMs += [link.CO
-00006960: 4d5d 0d0a 2020 2020 2020 2020 2020 2020  M]..            
-00006970: 2320 6c69 6e6b 4d61 7373 6573 202b 3d20  # linkMasses += 
-00006980: 5b6c 696e 6b2e 6d61 7373 5d0d 0a0d 0a20  [link.mass].... 
-00006990: 2020 2020 2020 2020 2020 200d 0a20 2020             ..   
-000069a0: 2020 2020 2020 2020 2023 2b2b 2b2b 2b2b           #++++++
-000069b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000069c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0d0a 2020  ++++++++++++..  
-000069d0: 2020 2020 2020 2020 2020 2376 6973 7561            #visua
-000069e0: 6c69 7a61 7469 6f6e 3a0d 0a20 2020 2020  lization:..     
-000069f0: 2020 2020 2020 206c 696e 6b56 6973 7561         linkVisua
-00006a00: 6c69 7a61 7469 6f6e 203d 206c 696e 6b2e  lization = link.
-00006a10: 7669 7375 616c 697a 6174 696f 6e0d 0a20  visualization.. 
-00006a20: 2020 2020 2020 2020 2020 2073 686f 774d             showM
-00006a30: 4253 6a6f 696e 7420 3d20 6c69 6e6b 5669  BSjoint = linkVi
-00006a40: 7375 616c 697a 6174 696f 6e2e 7368 6f77  sualization.show
-00006a50: 4d42 536a 6f69 6e74 0d0a 2020 2020 2020  MBSjoint..      
-00006a60: 2020 2020 2020 7220 3d20 6c69 6e6b 5669        r = linkVi
-00006a70: 7375 616c 697a 6174 696f 6e2e 6a6f 696e  sualization.join
-00006a80: 7452 6164 6975 730d 0a20 2020 2020 2020  tRadius..       
-00006a90: 2020 2020 2077 4a20 3d20 6c69 6e6b 5669       wJ = linkVi
-00006aa0: 7375 616c 697a 6174 696f 6e2e 6a6f 696e  sualization.join
-00006ab0: 7457 6964 7468 0d0a 2020 2020 2020 2020  tWidth..        
-00006ac0: 2020 2020 774c 203d 206c 696e 6b56 6973      wL = linkVis
-00006ad0: 7561 6c69 7a61 7469 6f6e 2e6c 696e 6b57  ualization.linkW
-00006ae0: 6964 7468 0d0a 2020 2020 2020 2020 2020  idth..          
-00006af0: 2020 636f 6c6f 7220 3d20 6c69 6e6b 5669    color = linkVi
-00006b00: 7375 616c 697a 6174 696f 6e2e 6c69 6e6b  sualization.link
-00006b10: 436f 6c6f 720d 0a20 2020 2020 2020 2020  Color..         
-00006b20: 2020 200d 0a20 2020 2020 2020 2020 2020     ..           
-00006b30: 2067 7261 7068 6963 7344 6174 614c 696e   graphicsDataLin
-00006b40: 6b20 3d20 5b5d 0d0a 2020 2020 2020 2020  k = []..        
-00006b50: 2020 2020 2364 7261 7720 434f 4d3a 0d0a      #draw COM:..
-00006b60: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-00006b70: 696e 6b56 6973 7561 6c69 7a61 7469 6f6e  inkVisualization
-00006b80: 2e73 686f 7743 4f4d 3a0d 0a20 2020 2020  .showCOM:..     
-00006b90: 2020 2020 2020 2020 2020 2064 6420 3d20             dd = 
-00006ba0: 722a 302e 320d 0a20 2020 2020 2020 2020  r*0.2..         
-00006bb0: 2020 2020 2020 2063 6f6c 6f72 434f 4d20         colorCOM 
-00006bc0: 3d20 636f 7079 2863 6f6c 6f72 290d 0a20  = copy(color).. 
-00006bd0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00006be0: 6f6c 6f72 434f 4d5b 305d 202a 3d20 302e  olorCOM[0] *= 0.
-00006bf0: 3720 236d 616b 6520 434f 4d20 6120 6c69  7 #make COM a li
-00006c00: 7474 6c65 2064 6172 6b65 720d 0a20 2020  ttle darker..   
-00006c10: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-00006c20: 6f72 434f 4d5b 315d 202a 3d20 302e 370d  orCOM[1] *= 0.7.
-00006c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006c40: 2063 6f6c 6f72 434f 4d5b 325d 202a 3d20   colorCOM[2] *= 
-00006c50: 302e 370d 0a20 2020 2020 2020 2020 2020  0.7..           
-00006c60: 2020 2020 2067 7261 7068 6963 7344 6174       graphicsDat
-00006c70: 614c 696e 6b20 2b3d 205b 6567 642e 4772  aLink += [egd.Gr
-00006c80: 6170 6869 6373 4461 7461 4f72 7468 6f43  aphicsDataOrthoC
-00006c90: 7562 6550 6f69 6e74 2872 6269 2e43 4f4d  ubePoint(rbi.COM
-00006ca0: 2829 2c20 5b64 642c 6464 2c64 645d 2c20  (), [dd,dd,dd], 
-00006cb0: 636f 6c6f 7243 4f4d 295d 0d0a 0d0a 0d0a  colorCOM)]......
-00006cc0: 2020 2020 2020 2020 2020 2020 2364 7261              #dra
-00006cd0: 7720 6a6f 696e 7420 696e 2074 6869 7320  w joint in this 
-00006ce0: 6c69 6e6b 0d0a 2020 2020 2020 2020 2020  link..          
-00006cf0: 2020 6966 2073 686f 774d 4253 6a6f 696e    if showMBSjoin
-00006d00: 743a 0d0a 2020 2020 2020 2020 2020 2020  t:..            
-00006d10: 2020 2020 674a 6f69 6e74 203d 2065 6764      gJoint = egd
-00006d20: 2e47 7261 7068 6963 7344 6174 6143 796c  .GraphicsDataCyl
-00006d30: 696e 6465 7228 2d30 2e35 2a77 4a2a 6178  inder(-0.5*wJ*ax
-00006d40: 6973 2c20 302e 352a 774a 2a61 7869 732c  is, 0.5*wJ*axis,
-00006d50: 2072 6164 6975 733d 722c 2063 6f6c 6f72   radius=r, color
-00006d60: 3d65 6764 2e63 6f6c 6f72 3467 7265 7929  =egd.color4grey)
-00006d70: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006d80: 2020 6772 6170 6869 6373 4461 7461 4c69    graphicsDataLi
-00006d90: 6e6b 202b 3d20 5b67 4a6f 696e 745d 0d0a  nk += [gJoint]..
-00006da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006db0: 0d0a 2020 2020 2020 2020 2020 2020 2364  ..            #d
-00006dc0: 7261 7720 6c69 6e6b 2066 726f 6d20 7061  raw link from pa
-00006dd0: 7265 6e74 206c 696e 6b20 6f72 6967 696e  rent link origin
-00006de0: 2074 6f20 7468 6973 206c 696e 6b20 6f72   to this link or
-00006df0: 6967 696e 2c20 6465 6669 6e65 6420 6279  igin, defined by
-00006e00: 2070 7265 4854 206f 6620 7468 6973 206c   preHT of this l
-00006e10: 696e 6b0d 0a20 2020 2020 2020 2020 2020  ink..           
-00006e20: 2069 6620 7365 6c66 2e48 6173 5061 7265   if self.HasPare
-00006e30: 6e74 2869 293a 0d0a 2020 2020 2020 2020  nt(i):..        
-00006e40: 2020 2020 2020 2020 6950 6172 656e 7420          iParent 
-00006e50: 3d20 7365 6c66 2e47 6574 5061 7265 6e74  = self.GetParent
-00006e60: 496e 6465 7828 6929 0d0a 2020 2020 2020  Index(i)..      
-00006e70: 2020 2020 2020 2020 2020 2370 6172 656e            #paren
-00006e80: 744c 696e 6b20 3d20 7365 6c66 2e47 6574  tLink = self.Get
-00006e90: 4c69 6e6b 2869 5061 7265 6e74 290d 0a20  Link(iParent).. 
-00006ea0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-00006eb0: 5061 7265 6e74 203d 2065 7262 2e48 5432  Parent = erb.HT2
-00006ec0: 7472 616e 736c 6174 696f 6e28 7061 7265  translation(pare
-00006ed0: 6e74 4c69 6e6b 4c6f 6361 6c48 5440 6c69  ntLinkLocalHT@li
-00006ee0: 6e6b 2e70 7265 4854 290d 0a20 2020 2020  nk.preHT)..     
-00006ef0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-00006f00: 6e28 6c69 6e6b 5669 7375 616c 697a 6174  n(linkVisualizat
-00006f10: 696f 6e2e 6772 6170 6869 6373 4461 7461  ion.graphicsData
-00006f20: 2920 3d3d 2030 3a0d 0a20 2020 2020 2020  ) == 0:..       
-00006f30: 2020 2020 2020 2020 2020 2020 2067 4c69               gLi
-00006f40: 6e6b 203d 2065 6764 2e47 7261 7068 6963  nk = egd.Graphic
-00006f50: 7344 6174 6143 796c 696e 6465 7228 5b30  sDataCylinder([0
-00006f60: 2e2c 302e 2c30 2e5d 2c20 7650 6172 656e  .,0.,0.], vParen
-00006f70: 742c 2072 6164 6975 733d 302e 352a 774c  t, radius=0.5*wL
-00006f80: 2c20 636f 6c6f 723d 636f 6c6f 7229 0d0a  , color=color)..
-00006f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006fa0: 2020 2020 6772 6170 6869 6373 4461 7461      graphicsData
-00006fb0: 4c69 7374 5b69 5061 7265 6e74 5d20 2b3d  List[iParent] +=
-00006fc0: 205b 674c 696e 6b5d 0d0a 0d0a 2020 2020   [gLink]....    
-00006fd0: 2020 2020 2020 2020 6966 206c 656e 286c          if len(l
-00006fe0: 696e 6b56 6973 7561 6c69 7a61 7469 6f6e  inkVisualization
-00006ff0: 2e67 7261 7068 6963 7344 6174 6129 2021  .graphicsData) !
-00007000: 3d20 303a 0d0a 2020 2020 2020 2020 2020  = 0:..          
-00007010: 2020 2020 2020 6772 6170 6869 6373 4461        graphicsDa
-00007020: 7461 4c69 6e6b 202b 3d20 6c69 6e6b 5669  taLink += linkVi
-00007030: 7375 616c 697a 6174 696f 6e2e 6772 6170  sualization.grap
-00007040: 6869 6373 4461 7461 0d0a 0d0a 2020 2020  hicsData....    
-00007050: 2020 2020 2020 2020 2361 6464 2074 7261          #add tra
-00007060: 6e73 666f 726d 6564 2067 7261 7068 6963  nsformed graphic
-00007070: 7344 6174 6120 6f66 2074 6f6f 6c20 746f  sData of tool to
-00007080: 206c 696e 6b20 6772 6170 6869 6373 0d0a   link graphics..
-00007090: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-000070a0: 693d 3d6c 656e 2873 656c 662e 6c69 6e6b  i==len(self.link
-000070b0: 7329 2d31 2061 6e64 2023 746f 6f6c 0d0a  s)-1 and #tool..
+00002c90: 0a23 2a2a 636c 6173 733a 2063 6c61 7373  .#**class: class
+00002ca0: 2074 6f20 6465 6669 6e65 2061 2072 6f62   to define a rob
+00002cb0: 6f74 0a63 6c61 7373 2052 6f62 6f74 3a0a  ot.class Robot:.
+00002cc0: 2020 2020 232a 2a63 6c61 7373 4675 6e63      #**classFunc
+00002cd0: 7469 6f6e 3a20 696e 6974 6961 6c69 7a65  tion: initialize
+00002ce0: 2072 6f62 6f74 2063 6c61 7373 0a20 2020   robot class.   
+00002cf0: 2023 2a2a 696e 7075 743a 0a20 2020 2023   #**input:.    #
+00002d00: 2020 6261 7365 3a20 6465 6669 6e69 7469    base: definiti
+00002d10: 6f6e 206f 6620 6261 7365 2075 7369 6e67  on of base using
+00002d20: 2052 6f62 6f74 4261 7365 2829 2063 6c61   RobotBase() cla
+00002d30: 7373 0a20 2020 2023 2020 746f 6f6c 3a20  ss.    #  tool: 
+00002d40: 6465 6669 6e69 7469 6f6e 206f 6620 746f  definition of to
+00002d50: 6f6c 2075 7369 6e67 2052 6f62 6f74 546f  ol using RobotTo
+00002d60: 6f6c 2829 2063 6c61 7373 0a20 2020 2023  ol() class.    #
+00002d70: 2020 6772 6176 6974 793a 2061 206c 6973    gravity: a lis
+00002d80: 7420 6f72 2033 4420 6e75 6d70 7920 6172  t or 3D numpy ar
+00002d90: 7261 7920 6465 6669 6e69 6e67 2067 7261  ray defining gra
+00002da0: 7669 7479 0a20 2020 2023 2020 7265 6665  vity.    #  refe
+00002db0: 7265 6e63 6543 6f6e 6669 6775 7261 7469  renceConfigurati
+00002dc0: 6f6e 3a20 6120 6c69 7374 206f 6620 7363  on: a list of sc
+00002dd0: 616c 6172 2071 7561 6e74 6974 6965 7320  alar quantities 
+00002de0: 6465 6669 6e69 6e67 2074 6865 2070 6172  defining the par
+00002df0: 616d 6574 6572 7320 666f 7220 7265 6665  ameters for refe
+00002e00: 7265 6e63 6520 636f 6e66 6967 7572 6174  rence configurat
+00002e10: 696f 6e0a 2020 2020 6465 6620 5f5f 696e  ion.    def __in
+00002e20: 6974 5f5f 2873 656c 662c 200a 2020 2020  it__(self, .    
+00002e30: 2020 2020 2020 2020 2020 2020 2067 7261               gra
+00002e40: 7669 7479 3d5b 302c 302c 2d39 2e38 315d  vity=[0,0,-9.81]
+00002e50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00002e60: 2020 2062 6173 6520 3d20 526f 626f 7442     base = RobotB
+00002e70: 6173 6528 292c 0a20 2020 2020 2020 2020  ase(),.         
+00002e80: 2020 2020 2020 2020 746f 6f6c 203d 2052          tool = R
+00002e90: 6f62 6f74 546f 6f6c 2829 2c0a 2020 2020  obotTool(),.    
+00002ea0: 2020 2020 2020 2020 2020 2020 2072 6566               ref
+00002eb0: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
+00002ec0: 696f 6e20 3d20 5b5d 0a20 2020 2020 2020  ion = [].       
+00002ed0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+00002ee0: 2020 2020 2073 656c 662e 6772 6176 6974       self.gravit
+00002ef0: 7920 3d20 6e70 2e61 7272 6179 2867 7261  y = np.array(gra
+00002f00: 7669 7479 290a 2020 2020 2020 2020 7365  vity).        se
+00002f10: 6c66 2e62 6173 6520 3d20 6261 7365 0a20  lf.base = base. 
+00002f20: 2020 2020 2020 2073 656c 662e 746f 6f6c         self.tool
+00002f30: 203d 2074 6f6f 6c0a 2020 2020 2020 2020   = tool.        
+00002f40: 7365 6c66 2e72 6566 6572 656e 6365 436f  self.referenceCo
+00002f50: 6e66 6967 7572 6174 696f 6e20 3d20 6e70  nfiguration = np
+00002f60: 2e61 7272 6179 2872 6566 6572 656e 6365  .array(reference
+00002f70: 436f 6e66 6967 7572 6174 696f 6e29 0a20  Configuration). 
+00002f80: 2020 2020 2020 2073 656c 662e 6c69 6e6b         self.link
+00002f90: 7320 3d20 5b5d 2023 696e 6974 6961 6c69  s = [] #initiali
+00002fa0: 7a65 206c 6973 7420 6f66 206c 696e 6b20  ze list of link 
+00002fb0: 6461 7461 0a20 2020 2020 2020 2073 656c  data.        sel
+00002fc0: 662e 6973 5365 7269 616c 526f 626f 7420  f.isSerialRobot 
+00002fd0: 3d20 5472 7565 2023 7468 6973 2069 7320  = True #this is 
+00002fe0: 7472 7565 2061 7320 6c6f 6e67 2061 7320  true as long as 
+00002ff0: 7061 7265 6e74 203d 206c 696e 6b20 696e  parent = link in
+00003000: 6465 7820 2d20 310a 0a20 2020 2064 6566  dex - 1..    def
+00003010: 205f 5f73 7472 5f5f 2873 656c 6629 3a0a   __str__(self):.
+00003020: 2020 2020 2020 2020 7320 3d20 2767 7261          s = 'gra
+00003030: 7669 7479 203d 2027 202b 2073 7472 2873  vity = ' + str(s
+00003040: 656c 662e 6772 6176 6974 7929 0a20 2020  elf.gravity).   
+00003050: 2020 2020 2073 202b 3d20 275c 6e72 6566       s += '\nref
+00003060: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
+00003070: 696f 6e20 3d20 2720 2b20 7374 7228 7365  ion = ' + str(se
+00003080: 6c66 2e72 6566 6572 656e 6365 436f 6e66  lf.referenceConf
+00003090: 6967 7572 6174 696f 6e29 0a20 2020 2020  iguration).     
+000030a0: 2020 2073 202b 3d20 275c 6e62 6173 653a     s += '\nbase:
+000030b0: 205c 6e27 202b 2073 7472 2873 656c 662e   \n' + str(self.
+000030c0: 6261 7365 290a 2020 2020 2020 2020 7320  base).        s 
+000030d0: 2b3d 2027 5c6e 746f 6f6c 3a20 5c6e 2720  += '\ntool: \n' 
+000030e0: 2b20 7374 7228 7365 6c66 2e74 6f6f 6c29  + str(self.tool)
+000030f0: 0a20 2020 2020 2020 2073 202b 3d20 275c  .        s += '\
+00003100: 6e6c 696e 6b73 3a20 5c6e 2720 2b20 7374  nlinks: \n' + st
+00003110: 7228 7365 6c66 2e6c 696e 6b73 290a 2020  r(self.links).  
+00003120: 2020 2020 2020 7265 7475 726e 2073 0a20        return s. 
+00003130: 2020 200a 2020 2020 6465 6620 5f5f 7265     .    def __re
+00003140: 7072 5f5f 2873 656c 6629 3a0a 2020 2020  pr__(self):.    
+00003150: 2020 2020 7265 7475 726e 2073 7472 2873      return str(s
+00003160: 656c 6629 0a20 2020 2020 2020 200a 0a20  elf).        .. 
+00003170: 2020 2023 2a2a 636c 6173 7346 756e 6374     #**classFunct
+00003180: 696f 6e3a 2061 6464 2061 206c 696e 6b20  ion: add a link 
+00003190: 746f 2073 6572 6961 6c20 726f 626f 740a  to serial robot.
+000031a0: 2020 2020 6465 6620 4164 644c 696e 6b28      def AddLink(
+000031b0: 7365 6c66 2c20 726f 626f 744c 696e 6b29  self, robotLink)
+000031c0: 3a0a 2020 2020 2020 2020 6920 3d20 6c65  :.        i = le
+000031d0: 6e28 7365 6c66 2e6c 696e 6b73 2920 2363  n(self.links) #c
+000031e0: 7572 7265 6e74 2069 6e64 6578 0a20 2020  urrent index.   
+000031f0: 2020 2020 2069 6620 6c65 6e28 7365 6c66       if len(self
+00003200: 2e72 6566 6572 656e 6365 436f 6e66 6967  .referenceConfig
+00003210: 7572 6174 696f 6e29 203d 3d20 693a 2023  uration) == i: #
+00003220: 6578 7465 6e64 2072 6566 6572 656e 6365  extend reference
+00003230: 2063 6f6e 6669 6775 7261 7469 6f6e 2c20   configuration, 
+00003240: 6966 206e 6f74 2073 7065 6369 6669 6564  if not specified
+00003250: 2062 7920 7573 6572 2064 7572 696e 6720   by user during 
+00003260: 696e 6974 6961 6c69 7a61 7469 6f6e 0a20  initialization. 
+00003270: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00003280: 7265 6665 7265 6e63 6543 6f6e 6669 6775  referenceConfigu
+00003290: 7261 7469 6f6e 203d 206e 702e 6873 7461  ration = np.hsta
+000032a0: 636b 2828 7365 6c66 2e72 6566 6572 656e  ck((self.referen
+000032b0: 6365 436f 6e66 6967 7572 6174 696f 6e2c  ceConfiguration,
+000032c0: 5b30 5d29 290a 0a20 2020 2020 2020 2073  [0]))..        s
+000032d0: 656c 662e 6c69 6e6b 7320 2b3d 205b 6465  elf.links += [de
+000032e0: 6570 636f 7079 2872 6f62 6f74 4c69 6e6b  epcopy(robotLink
+000032f0: 295d 0a20 2020 2020 2020 2069 6620 7365  )].        if se
+00003300: 6c66 2e6c 696e 6b73 5b69 5d2e 7061 7265  lf.links[i].pare
+00003310: 6e74 203d 3d20 2d32 3a20 2369 6e20 7468  nt == -2: #in th
+00003320: 6973 2063 6173 652c 2061 7574 6f6d 6174  is case, automat
+00003330: 6963 616c 6c79 2073 6574 2070 6172 656e  ically set paren
+00003340: 7473 2066 6f72 2073 6572 6961 6c20 726f  ts for serial ro
+00003350: 626f 7420 2863 6861 696e 290a 2020 2020  bot (chain).    
+00003360: 2020 2020 2020 2020 7365 6c66 2e6c 696e          self.lin
+00003370: 6b73 5b69 5d2e 7061 7265 6e74 203d 2069  ks[i].parent = i
+00003380: 2d31 0a20 2020 2020 2020 2065 6c69 6620  -1.        elif 
+00003390: 7365 6c66 2e6c 696e 6b73 5b69 5d2e 7061  self.links[i].pa
+000033a0: 7265 6e74 203e 3d20 693a 0a20 2020 2020  rent >= i:.     
+000033b0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+000033c0: 7565 4572 726f 7228 2752 6f62 6f74 2e41  ueError('Robot.A
+000033d0: 6464 4c69 6e6b 282e 2e2e 293a 206c 696e  ddLink(...): lin
+000033e0: 6b20 7061 7265 6e74 2069 6e64 6578 206d  k parent index m
+000033f0: 7573 7420 6265 2061 6c77 6179 7320 6c6f  ust be always lo
+00003400: 7765 7220 7468 616e 206c 696e 6b20 696e  wer than link in
+00003410: 6465 7827 290a 0a20 2020 2020 2020 2069  dex')..        i
+00003420: 6620 2073 656c 662e 6c69 6e6b 735b 695d  f  self.links[i]
+00003430: 2e70 6172 656e 7420 213d 2069 2d31 3a0a  .parent != i-1:.
+00003440: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00003450: 2e69 7353 6572 6961 6c52 6f62 6f74 203d  .isSerialRobot =
+00003460: 2046 616c 7365 0a20 2020 2020 2020 200a   False.        .
+00003470: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+00003480: 656c 662e 6973 5365 7269 616c 526f 626f  elf.isSerialRobo
+00003490: 7420 616e 6420 286e 702e 6c69 6e61 6c67  t and (np.linalg
+000034a0: 2e6e 6f72 6d28 7365 6c66 2e74 6f6f 6c2e  .norm(self.tool.
+000034b0: 4854 202d 2065 7262 2e48 5430 2829 2920  HT - erb.HT0()) 
+000034c0: 3e3d 2031 652d 3135 0a20 2020 2020 2020  >= 1e-15.       
+000034d0: 2020 2020 206f 7220 7365 6c66 2e74 6f6f       or self.too
+000034e0: 6c2e 7669 7375 616c 697a 6174 696f 6e2e  l.visualization.
+000034f0: 6772 6170 6869 6373 4461 7461 2021 3d20  graphicsData != 
+00003500: 5b5d 293a 0a20 2020 2020 2020 2020 2020  []):.           
+00003510: 2065 7875 6479 6e2e 5072 696e 7428 2757   exudyn.Print('W
+00003520: 6172 6e69 6e67 3a20 636c 6173 7320 526f  arning: class Ro
+00003530: 626f 743a 2074 6f6f 6c20 6465 6669 6e65  bot: tool define
+00003540: 6420 696e 206b 696e 656d 6174 6963 2074  d in kinematic t
+00003550: 7265 653b 2063 7572 7265 6e74 6c79 2074  ree; currently t
+00003560: 6f6f 6c20 6973 206f 6e6c 7920 616c 6c6f  ool is only allo
+00003570: 7765 6420 666f 7220 7365 7269 616c 2072  wed for serial r
+00003580: 6f62 6f74 7327 290a 0a20 2020 2020 2020  obots')..       
+00003590: 2072 6574 7572 6e20 6920 2372 6574 7572   return i #retur
+000035a0: 6e20 696e 6465 7820 6f66 206c 696e 6b0a  n index of link.
+000035b0: 0a20 2020 2023 2a2a 636c 6173 7346 756e  .    #**classFun
+000035c0: 6374 696f 6e3a 2072 6574 7572 6e20 5472  ction: return Tr
+000035d0: 7565 2c20 6966 2072 6f62 6f74 2069 7320  ue, if robot is 
+000035e0: 6120 7365 7269 616c 2072 6f62 6f74 0a20  a serial robot. 
+000035f0: 2020 2064 6566 2049 7353 6572 6961 6c52     def IsSerialR
+00003600: 6f62 6f74 2873 656c 6629 3a0a 2020 2020  obot(self):.    
+00003610: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00003620: 6973 5365 7269 616c 526f 626f 740a 0a20  isSerialRobot.. 
+00003630: 2020 2023 2a2a 636c 6173 7346 756e 6374     #**classFunct
+00003640: 696f 6e3a 2072 6574 7572 6e20 4c69 6e6b  ion: return Link
+00003650: 206f 626a 6563 7420 6f66 206c 696e 6b20   object of link 
+00003660: 690a 2020 2020 6465 6620 4765 744c 696e  i.    def GetLin
+00003670: 6b28 7365 6c66 2c20 6929 3a0a 2020 2020  k(self, i):.    
+00003680: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00003690: 6c69 6e6b 735b 695d 0a0a 2020 2020 232a  links[i]..    #*
+000036a0: 2a63 6c61 7373 4675 6e63 7469 6f6e 3a20  *classFunction: 
+000036b0: 5472 7565 2069 6620 6c69 6e6b 2068 6173  True if link has
+000036c0: 2070 6172 656e 742c 2046 616c 7365 2069   parent, False i
+000036d0: 6620 6e6f 740a 2020 2020 6465 6620 4861  f not.    def Ha
+000036e0: 7350 6172 656e 7428 7365 6c66 2c20 6929  sParent(self, i)
+000036f0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00003700: 2073 656c 662e 6c69 6e6b 735b 695d 2e70   self.links[i].p
+00003710: 6172 656e 7420 3e3d 2030 0a0a 2020 2020  arent >= 0..    
+00003720: 232a 2a63 6c61 7373 4675 6e63 7469 6f6e  #**classFunction
+00003730: 3a20 4765 7420 696e 6465 7820 6f66 2070  : Get index of p
+00003740: 6172 656e 7420 6c69 6e6b 3b20 666f 7220  arent link; for 
+00003750: 7365 7269 616c 2072 6f62 6f74 2074 6869  serial robot thi
+00003760: 7320 6973 2073 696d 706c 652c 2062 7574  s is simple, but
+00003770: 2066 6f72 2067 656e 6572 616c 2074 7265   for general tre
+00003780: 6573 2c20 7468 6572 6520 6973 2061 2069  es, there is a i
+00003790: 6e64 6578 206c 6973 740a 2020 2020 6465  ndex list.    de
+000037a0: 6620 4765 7450 6172 656e 7449 6e64 6578  f GetParentIndex
+000037b0: 2873 656c 662c 2069 293a 0a20 2020 2020  (self, i):.     
+000037c0: 2020 2072 6574 7572 6e20 7365 6c66 2e6c     return self.l
+000037d0: 696e 6b73 5b69 5d2e 7061 7265 6e74 0a0a  inks[i].parent..
+000037e0: 2020 2020 0a20 2020 2023 2a2a 636c 6173      .    #**clas
+000037f0: 7346 756e 6374 696f 6e3a 2072 6574 7572  sFunction: retur
+00003800: 6e20 6e75 6d62 6572 206f 6620 6c69 6e6b  n number of link
+00003810: 730a 2020 2020 6465 6620 4e75 6d62 6572  s.    def Number
+00003820: 4f66 4c69 6e6b 7328 7365 6c66 293a 0a20  OfLinks(self):. 
+00003830: 2020 2020 2020 2072 6574 7572 6e20 6c65         return le
+00003840: 6e28 7365 6c66 2e6c 696e 6b73 290a 0a20  n(self.links).. 
+00003850: 2020 2023 2a2a 636c 6173 7346 756e 6374     #**classFunct
+00003860: 696f 6e3a 2072 6574 7572 6e20 6261 7365  ion: return base
+00003870: 2061 7320 686f 6d6f 6765 6e65 6f75 7320   as homogeneous 
+00003880: 7472 616e 7366 6f72 6d61 7469 6f6e 0a20  transformation. 
+00003890: 2020 2064 6566 2047 6574 4261 7365 4854     def GetBaseHT
+000038a0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000038b0: 7265 7475 726e 2073 656c 662e 6261 7365  return self.base
+000038c0: 2e48 540a 0a20 2020 2023 2a2a 636c 6173  .HT..    #**clas
+000038d0: 7346 756e 6374 696f 6e3a 2072 6574 7572  sFunction: retur
+000038e0: 6e20 6261 7365 2061 7320 686f 6d6f 6765  n base as homoge
+000038f0: 6e65 6f75 7320 7472 616e 7366 6f72 6d61  neous transforma
+00003900: 7469 6f6e 0a20 2020 2064 6566 2047 6574  tion.    def Get
+00003910: 546f 6f6c 4854 2873 656c 6629 3a0a 2020  ToolHT(self):.  
+00003920: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00003930: 662e 746f 6f6c 2e48 540a 2020 2020 0a20  f.tool.HT.    . 
+00003940: 2020 2023 2a2a 636c 6173 7346 756e 6374     #**classFunct
+00003950: 696f 6e3a 2063 6f6d 7075 7465 206c 6973  ion: compute lis
+00003960: 7420 6f66 2068 6f6d 6f67 656e 656f 7573  t of homogeneous
+00003970: 2074 7261 6e73 666f 726d 6174 696f 6e73   transformations
+00003980: 2066 6f72 2065 7665 7279 206c 696e 6b2c   for every link,
+00003990: 2075 7369 6e67 2063 7572 7265 6e74 206a   using current j
+000039a0: 6f69 6e74 2063 6f6f 7264 696e 6174 6573  oint coordinates
+000039b0: 2071 3b20 6c65 6164 7320 746f 2064 6966   q; leads to dif
+000039c0: 6665 7265 6e74 2072 6573 756c 7473 2066  ferent results f
+000039d0: 6f72 2073 7461 6e64 6172 6420 616e 6420  or standard and 
+000039e0: 6d6f 6469 6669 6564 2044 4820 7061 7261  modified DH para
+000039f0: 6d65 7465 7273 2062 6563 6175 7365 206c  meters because l
+00003a00: 696e 6b20 636f 6f72 6469 6e61 7465 7320  ink coordinates 
+00003a10: 6172 6520 6469 6666 6572 656e 7421 0a20  are different!. 
+00003a20: 2020 2064 6566 204c 696e 6b48 5428 7365     def LinkHT(se
+00003a30: 6c66 2c20 7129 3a0a 2020 2020 2020 2020  lf, q):.        
+00003a40: 4854 203d 205b 5d0a 0a20 2020 2020 2020  HT = []..       
+00003a50: 2023 2023 6f6e 6c79 2066 6f72 2073 6572   # #only for ser
+00003a60: 6961 6c20 726f 626f 7473 3a0a 2020 2020  ial robots:.    
+00003a70: 2020 2020 2320 5463 7572 7265 6e74 203d      # Tcurrent =
+00003a80: 2073 656c 662e 6261 7365 2e48 540a 2020   self.base.HT.  
+00003a90: 2020 2020 2020 2320 666f 7220 6920 696e        # for i in
+00003aa0: 2072 616e 6765 286c 656e 2873 656c 662e   range(len(self.
+00003ab0: 6c69 6e6b 7329 293a 0a20 2020 2020 2020  links)):.       
+00003ac0: 2023 2020 2020 206c 696e 6b20 3d20 7365   #     link = se
+00003ad0: 6c66 2e6c 696e 6b73 5b69 5d0a 0a20 2020  lf.links[i]..   
+00003ae0: 2020 2020 2023 2020 2020 2023 6361 6c6c       #     #call
+00003af0: 2066 756e 6374 696f 6e20 746f 2063 6f6d   function to com
+00003b00: 7075 7465 2048 5420 666f 7220 6a6f 696e  pute HT for join
+00003b10: 7420 726f 7461 7469 6f6e 2f74 7261 6e73  t rotation/trans
+00003b20: 6c61 7469 6f6e 3a0a 2020 2020 2020 2020  lation:.        
+00003b30: 2320 2020 2020 5430 3120 3d20 6c69 6e6b  #     T01 = link
+00003b40: 2e70 7265 4854 2040 2064 6963 744a 6f69  .preHT @ dictJoi
+00003b50: 6e74 5479 7065 3248 545b 6c69 6e6b 2e6a  ntType2HT[link.j
+00003b60: 6f69 6e74 5479 7065 5d28 715b 695d 2920  ointType](q[i]) 
+00003b70: 4020 6c69 6e6b 2e6c 6f63 616c 4854 0a0a  @ link.localHT..
+00003b80: 2020 2020 2020 2020 2320 2020 2020 5463          #     Tc
+00003b90: 7572 7265 6e74 203d 2054 6375 7272 656e  urrent = Tcurren
+00003ba0: 7420 4020 5430 310a 2020 2020 2020 2020  t @ T01.        
+00003bb0: 2320 2020 2020 4854 202b 3d20 5b63 6f70  #     HT += [cop
+00003bc0: 7928 5463 7572 7265 6e74 295d 0a0a 0a20  y(Tcurrent)]... 
+00003bd0: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+00003be0: 7261 6e67 6528 6c65 6e28 7365 6c66 2e6c  range(len(self.l
+00003bf0: 696e 6b73 2929 3a0a 2020 2020 2020 2020  inks)):.        
+00003c00: 2020 2020 6c69 6e6b 203d 2073 656c 662e      link = self.
+00003c10: 6c69 6e6b 735b 695d 0a0a 2020 2020 2020  links[i]..      
+00003c20: 2020 2020 2020 5430 3120 3d20 6c69 6e6b        T01 = link
+00003c30: 2e70 7265 4854 2040 2064 6963 744a 6f69  .preHT @ dictJoi
+00003c40: 6e74 5479 7065 3248 545b 6c69 6e6b 2e6a  ntType2HT[link.j
+00003c50: 6f69 6e74 5479 7065 5d28 715b 695d 2920  ointType](q[i]) 
+00003c60: 4020 6c69 6e6b 2e6c 6f63 616c 4854 0a20  @ link.localHT. 
+00003c70: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00003c80: 6c66 2e48 6173 5061 7265 6e74 2869 293a  lf.HasParent(i):
+00003c90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003ca0: 2070 496e 6465 7820 3d20 7365 6c66 2e47   pIndex = self.G
+00003cb0: 6574 5061 7265 6e74 496e 6465 7828 6929  etParentIndex(i)
+00003cc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003cd0: 2054 6375 7272 656e 7420 3d20 4854 5b70   Tcurrent = HT[p
+00003ce0: 496e 6465 785d 2040 2054 3031 0a20 2020  Index] @ T01.   
+00003cf0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00003d00: 2020 2020 2020 2020 2020 2020 2020 2054                 T
+00003d10: 6375 7272 656e 7420 3d20 7365 6c66 2e62  current = self.b
+00003d20: 6173 652e 4854 2040 2054 3031 0a20 2020  ase.HT @ T01.   
+00003d30: 2020 2020 2020 2020 2048 5420 2b3d 205b           HT += [
+00003d40: 636f 7079 2854 6375 7272 656e 7429 5d0a  copy(Tcurrent)].
+00003d50: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+00003d60: 2072 6574 7572 6e20 4854 2020 2020 0a0a   return HT    ..
+00003d70: 2020 2020 232a 2a63 6c61 7373 4675 6e63      #**classFunc
+00003d80: 7469 6f6e 3a20 636f 6d70 7574 6520 6c69  tion: compute li
+00003d90: 7374 206f 6620 686f 6d6f 6765 6e65 6f75  st of homogeneou
+00003da0: 7320 7472 616e 7366 6f72 6d61 7469 6f6e  s transformation
+00003db0: 7320 666f 7220 6576 6572 7920 6a6f 696e  s for every join
+00003dc0: 7420 2861 6674 6572 2072 6f74 6174 696f  t (after rotatio
+00003dd0: 6e29 2c20 7573 696e 6720 6375 7272 656e  n), using curren
+00003de0: 7420 6a6f 696e 7420 636f 6f72 6469 6e61  t joint coordina
+00003df0: 7465 7320 710a 2020 2020 6465 6620 4a6f  tes q.    def Jo
+00003e00: 696e 7448 5428 7365 6c66 2c20 7129 3a0a  intHT(self, q):.
+00003e10: 2020 2020 2020 2020 4854 203d 205b 5d0a          HT = [].
+00003e20: 0a20 2020 2020 2020 2023 2023 6f6e 6c79  .        # #only
+00003e30: 2066 6f72 2073 6572 6961 6c20 726f 626f   for serial robo
+00003e40: 7473 3a0a 2020 2020 2020 2020 2320 5463  ts:.        # Tc
+00003e50: 7572 7265 6e74 203d 2073 656c 662e 6261  urrent = self.ba
+00003e60: 7365 2e48 540a 2020 2020 2020 2020 2320  se.HT.        # 
+00003e70: 666f 7220 6920 696e 2072 616e 6765 286c  for i in range(l
+00003e80: 656e 2873 656c 662e 6c69 6e6b 7329 293a  en(self.links)):
+00003e90: 0a20 2020 2020 2020 2023 2020 2020 206c  .        #     l
+00003ea0: 696e 6b20 3d20 7365 6c66 2e6c 696e 6b73  ink = self.links
+00003eb0: 5b69 5d0a 0a20 2020 2020 2020 2023 2020  [i]..        #  
+00003ec0: 2020 2054 3031 203d 206c 696e 6b2e 7072     T01 = link.pr
+00003ed0: 6548 5420 4020 6469 6374 4a6f 696e 7454  eHT @ dictJointT
+00003ee0: 7970 6532 4854 5b6c 696e 6b2e 6a6f 696e  ype2HT[link.join
+00003ef0: 7454 7970 655d 2871 5b69 5d29 0a20 2020  tType](q[i]).   
+00003f00: 2020 2020 2023 2020 2020 2054 6375 7272       #     Tcurr
+00003f10: 656e 7420 3d20 5463 7572 7265 6e74 2040  ent = Tcurrent @
+00003f20: 2054 3031 0a20 2020 2020 2020 2023 2020   T01.        #  
+00003f30: 2020 2048 5420 2b3d 205b 636f 7079 2854     HT += [copy(T
+00003f40: 6375 7272 656e 7429 5d0a 2020 2020 2020  current)].      
+00003f50: 2020 2020 2020 0a20 2020 2020 2020 2023        .        #
+00003f60: 2020 2020 2054 6375 7272 656e 7420 3d20       Tcurrent = 
+00003f70: 5463 7572 7265 6e74 2040 206c 696e 6b2e  Tcurrent @ link.
+00003f80: 6c6f 6361 6c48 540a 0a20 2020 2020 2020  localHT..       
+00003f90: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
+00003fa0: 6c65 6e28 7365 6c66 2e6c 696e 6b73 2929  len(self.links))
+00003fb0: 3a0a 2020 2020 2020 2020 2020 2020 6c69  :.            li
+00003fc0: 6e6b 203d 2073 656c 662e 6c69 6e6b 735b  nk = self.links[
+00003fd0: 695d 0a0a 2020 2020 2020 2020 2020 2020  i]..            
+00003fe0: 5430 3120 3d20 6c69 6e6b 2e70 7265 4854  T01 = link.preHT
+00003ff0: 2040 2064 6963 744a 6f69 6e74 5479 7065   @ dictJointType
+00004000: 3248 545b 6c69 6e6b 2e6a 6f69 6e74 5479  2HT[link.jointTy
+00004010: 7065 5d28 715b 695d 290a 2020 2020 2020  pe](q[i]).      
+00004020: 2020 2020 2020 6966 2073 656c 662e 4861        if self.Ha
+00004030: 7350 6172 656e 7428 6929 3a0a 2020 2020  sParent(i):.    
+00004040: 2020 2020 2020 2020 2020 2020 7049 6e64              pInd
+00004050: 6578 203d 2073 656c 662e 4765 7450 6172  ex = self.GetPar
+00004060: 656e 7449 6e64 6578 2869 290a 2020 2020  entIndex(i).    
+00004070: 2020 2020 2020 2020 2020 2020 5463 7572              Tcur
+00004080: 7265 6e74 203d 2048 545b 7049 6e64 6578  rent = HT[pIndex
+00004090: 5d20 4020 7365 6c66 2e6c 696e 6b73 5b70  ] @ self.links[p
+000040a0: 496e 6465 785d 2e6c 6f63 616c 4854 2040  Index].localHT @
+000040b0: 2054 3031 0a20 2020 2020 2020 2020 2020   T01.           
+000040c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000040d0: 2020 2020 2020 2054 6375 7272 656e 7420         Tcurrent 
+000040e0: 3d20 7365 6c66 2e62 6173 652e 4854 2040  = self.base.HT @
+000040f0: 2054 3031 0a20 2020 2020 2020 2020 2020   T01.           
+00004100: 2048 5420 2b3d 205b 636f 7079 2854 6375   HT += [copy(Tcu
+00004110: 7272 656e 7429 5d0a 2020 2020 2020 2020  rrent)].        
+00004120: 7265 7475 726e 2048 540a 0a20 2020 2023  return HT..    #
+00004130: 2a2a 636c 6173 7346 756e 6374 696f 6e3a  **classFunction:
+00004140: 2063 6f6d 7075 7465 206c 6973 7420 6f66   compute list of
+00004150: 2020 686f 6d6f 6765 6e65 6f75 7320 7472    homogeneous tr
+00004160: 616e 7366 6f72 6d61 7469 6f6e 7320 4854  ansformations HT
+00004170: 2066 726f 6d20 6261 7365 2074 6f20 6576   from base to ev
+00004180: 6572 7920 434f 4d20 7573 696e 6720 4854  ery COM using HT
+00004190: 206c 6973 7420 6672 6f6d 2052 6f62 6f74   list from Robot
+000041a0: 2e4a 6f69 6e74 4854 282e 2e2e 290a 2020  .JointHT(...).  
+000041b0: 2020 6465 6620 434f 4d48 5428 7365 6c66    def COMHT(self
+000041c0: 2c20 4854 293a 0a20 2020 2020 2020 2048  , HT):.        H
+000041d0: 5443 4f4d 203d 205b 5d0a 2020 2020 2020  TCOM = [].      
+000041e0: 2020 0a20 2020 2020 2020 2066 6f72 2069    .        for i
+000041f0: 2069 6e20 7261 6e67 6528 6c65 6e28 7365   in range(len(se
+00004200: 6c66 2e6c 696e 6b73 2929 3a0a 2020 2020  lf.links)):.    
+00004210: 2020 2020 2020 2020 4854 434f 4d20 2b3d          HTCOM +=
+00004220: 205b 4854 5b69 5d20 4020 7365 6c66 2e6c   [HT[i] @ self.l
+00004230: 696e 6b73 5b69 5d2e 6c6f 6361 6c48 5420  inks[i].localHT 
+00004240: 4020 6572 622e 4854 7472 616e 736c 6174  @ erb.HTtranslat
+00004250: 6528 7365 6c66 2e6c 696e 6b73 5b69 5d2e  e(self.links[i].
+00004260: 434f 4d29 5d0a 2020 2020 2020 2020 0a20  COM)].        . 
+00004270: 2020 2020 2020 2072 6574 7572 6e20 4854         return HT
+00004280: 434f 4d0a 2020 2020 0a20 2020 2023 2a2a  COM.    .    #**
+00004290: 636c 6173 7346 756e 6374 696f 6e3a 2063  classFunction: c
+000042a0: 6f6d 7075 7465 206c 6973 7420 6f66 206a  ompute list of j
+000042b0: 6f69 6e74 2074 6f72 7175 6573 2066 6f72  oint torques for
+000042c0: 2073 6572 6961 6c20 726f 626f 7420 6475   serial robot du
+000042d0: 6520 746f 2067 7261 7669 7479 2028 6772  e to gravity (gr
+000042e0: 6176 6974 7920 616e 6420 6d61 7373 2061  avity and mass a
+000042f0: 7320 6769 7665 6e20 696e 2072 6f62 6f74  s given in robot
+00004300: 292c 2074 616b 696e 6720 4854 2066 726f  ), taking HT fro
+00004310: 6d20 526f 626f 742e 4a6f 696e 7448 5428  m Robot.JointHT(
+00004320: 290a 2020 2020 6465 6620 5374 6174 6963  ).    def Static
+00004330: 546f 7271 7565 7328 7365 6c66 2c48 5429  Torques(self,HT)
+00004340: 3a0a 2020 2020 2020 2020 6a6f 696e 7454  :.        jointT
+00004350: 6f72 7175 6573 203d 206e 702e 7a65 726f  orques = np.zero
+00004360: 7328 6e70 2e73 697a 6528 7365 6c66 2e6c  s(np.size(self.l
+00004370: 696e 6b73 2929 0a20 2020 200a 2020 2020  inks)).    .    
+00004380: 2020 2020 2363 6f6d 7075 7465 2048 5473      #compute HTs
+00004390: 2066 6f72 2043 4f4d 0a20 2020 2020 2020   for COM.       
+000043a0: 2048 5463 6f6d 3d73 656c 662e 434f 4d48   HTcom=self.COMH
+000043b0: 5428 4854 290a 2020 2020 2020 2020 0a20  T(HT).        . 
+000043c0: 2020 2020 2020 2023 7375 6d20 7570 2074         #sum up t
+000043d0: 6865 2074 6f72 7175 6573 206f 6620 616c  he torques of al
+000043e0: 6c20 6772 6176 6974 7920 6c6f 6164 733a  l gravity loads:
+000043f0: 0a20 2020 2020 2020 2066 6f72 2069 2069  .        for i i
+00004400: 6e20 7261 6e67 6528 6c65 6e28 4854 636f  n range(len(HTco
+00004410: 6d29 293a 0a20 2020 2020 2020 2020 2020  m)):.           
+00004420: 2070 203d 2065 7262 2e48 5432 7472 616e   p = erb.HT2tran
+00004430: 736c 6174 696f 6e28 4854 636f 6d5b 695d  slation(HTcom[i]
+00004440: 290a 2020 2020 2020 2020 2020 2020 4a63  ).            Jc
+00004450: 6f6d 203d 2073 656c 662e 4a61 636f 6269  om = self.Jacobi
+00004460: 616e 2848 545b 303a 692b 315d 2c74 6f6f  an(HT[0:i+1],too
+00004470: 6c50 6f73 6974 696f 6e3d 702c 6d6f 6465  lPosition=p,mode
+00004480: 3d27 7472 616e 7327 290a 2020 2020 2020  ='trans').      
+00004490: 2020 2020 2020 6647 203d 2073 656c 662e        fG = self.
+000044a0: 6c69 6e6b 735b 695d 2e6d 6173 7320 2a20  links[i].mass * 
+000044b0: 7365 6c66 2e67 7261 7669 7479 0a20 2020  self.gravity.   
+000044c0: 2020 2020 2020 2020 2074 6175 203d 204a           tau = J
+000044d0: 636f 6d2e 5420 4020 6647 0a20 2020 2020  com.T @ fG.     
+000044e0: 2020 2020 2020 206a 6f69 6e74 546f 7271         jointTorq
+000044f0: 7565 735b 303a 692b 315d 202b 3d20 7461  ues[0:i+1] += ta
+00004500: 750a 2020 2020 2020 2020 7265 7475 726e  u.        return
+00004510: 206a 6f69 6e74 546f 7271 7565 730a 2020   jointTorques.  
+00004520: 2020 0a20 2020 200a 2020 2020 232a 2a63    .    .    #**c
+00004530: 6c61 7373 4675 6e63 7469 6f6e 3a20 636f  lassFunction: co
+00004540: 6d70 7574 6520 6a61 636f 6269 616e 2066  mpute jacobian f
+00004550: 6f72 2074 7261 6e73 6c61 7469 6f6e 2061  or translation a
+00004560: 6e64 2072 6f74 6174 696f 6e20 6174 2074  nd rotation at t
+00004570: 6f6f 6c50 6f73 6974 696f 6e20 7573 696e  oolPosition usin
+00004580: 6720 6a6f 696e 7420 4854 3b20 7468 6973  g joint HT; this
+00004590: 2069 7320 7573 696e 6720 7468 6520 526f   is using the Ro
+000045a0: 626f 7420 6675 6e63 7469 6f6e 732c 2062  bot functions, b
+000045b0: 7574 2069 7320 696e 6566 6669 6369 656e  ut is inefficien
+000045c0: 7420 666f 7220 7369 6d75 6c61 7469 6f6e  t for simulation
+000045d0: 2070 7572 706f 7365 730a 2020 2020 232a   purposes.    #*
+000045e0: 2a69 6e70 7574 3a0a 2020 2020 2320 2048  *input:.    #  H
+000045f0: 543a 206c 6973 7420 6f66 2068 6f6d 6f67  T: list of homog
+00004600: 656e 656f 7573 2074 7261 6e73 666f 726d  eneous transform
+00004610: 6174 696f 6e73 2070 6572 206a 6f69 6e74  ations per joint
+00004620: 202c 2061 7320 636f 6d70 7574 6564 2062   , as computed b
+00004630: 7920 526f 626f 742e 4a6f 696e 7448 5428  y Robot.JointHT(
+00004640: 2e2e 2e29 0a20 2020 2023 2020 746f 6f6c  ...).    #  tool
+00004650: 506f 7369 7469 6f6e 3a20 676c 6f62 616c  Position: global
+00004660: 2070 6f73 6974 696f 6e20 6174 2077 6869   position at whi
+00004670: 6368 2074 6865 206a 6163 6f62 6961 6e20  ch the jacobian 
+00004680: 6973 2065 7661 6c75 6174 6564 2028 652e  is evaluated (e.
+00004690: 672e 2c20 434f 4d29 3b20 6966 2065 6d70  g., COM); if emp
+000046a0: 7479 205b 5d2c 2069 7420 7573 6573 2074  ty [], it uses t
+000046b0: 6865 206f 7269 6769 6e20 6f66 2074 6865  he origin of the
+000046c0: 206c 6173 7420 6c69 6e6b 0a20 2020 2023   last link.    #
+000046d0: 2020 6d6f 6465 3a20 2761 6c6c 272e 2e2e    mode: 'all'...
+000046e0: 7472 616e 736c 6174 696f 6e20 616e 6420  translation and 
+000046f0: 726f 7461 7469 6f6e 206a 6163 6f62 6961  rotation jacobia
+00004700: 6e2c 2027 7472 616e 7327 2e2e 2e6f 6e6c  n, 'trans'...onl
+00004710: 7920 7472 616e 736c 6174 696f 6e20 7061  y translation pa
+00004720: 7274 2c20 2772 6f74 273a 206f 6e6c 7920  rt, 'rot': only 
+00004730: 726f 7461 7469 6f6e 2070 6172 740a 2020  rotation part.  
+00004740: 2020 2320 206c 696e 6b49 6e64 6578 3a20    #  linkIndex: 
+00004750: 6c69 6e6b 2069 6e64 6578 2066 6f72 2077  link index for w
+00004760: 6869 6368 2074 6865 206a 6163 6f62 6961  hich the jacobia
+00004770: 6e20 6973 2065 7661 6c75 6174 6564 3b20  n is evaluated; 
+00004780: 6966 206c 696e 6b49 6e64 6578 3d3d 4e6f  if linkIndex==No
+00004790: 6e65 2c20 6974 2075 7365 7320 7468 6520  ne, it uses the 
+000047a0: 6c61 7374 206c 696e 6b20 7072 6f76 6964  last link provid
+000047b0: 6564 2069 6e20 4854 0a20 2020 2023 2a2a  ed in HT.    #**
+000047c0: 6f75 7470 7574 3a20 7265 7475 726e 7320  output: returns 
+000047d0: 6a61 636f 6269 616e 2077 6974 6820 7472  jacobian with tr
+000047e0: 616e 736c 6174 696f 6e20 616e 6420 726f  anslation and ro
+000047f0: 7461 7469 6f6e 2070 6172 7473 2069 6e20  tation parts in 
+00004800: 726f 7773 2028 3320 6f72 2036 2920 6163  rows (3 or 6) ac
+00004810: 636f 7264 696e 6720 746f 206d 6f64 652c  cording to mode,
+00004820: 2061 6e64 206f 6e65 2063 6f6c 756d 6e20   and one column 
+00004830: 7065 7220 4854 3b20 696e 2074 6865 206b  per HT; in the k
+00004840: 696e 656d 6174 6963 2074 7265 6520 7468  inematic tree th
+00004850: 6520 636f 6c75 6d6e 7320 6e6f 7420 7265  e columns not re
+00004860: 6c61 7465 6420 746f 206c 696e 6b49 6e64  lated to linkInd
+00004870: 6578 2072 656d 6169 6e20 7a65 726f 0a20  ex remain zero. 
+00004880: 2020 2064 6566 204a 6163 6f62 6961 6e28     def Jacobian(
+00004890: 7365 6c66 2c20 4854 2c20 746f 6f6c 506f  self, HT, toolPo
+000048a0: 7369 7469 6f6e 3d5b 5d2c 206d 6f64 653d  sition=[], mode=
+000048b0: 2761 6c6c 272c 206c 696e 6b49 6e64 6578  'all', linkIndex
+000048c0: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
+000048d0: 6e20 3d20 6c65 6e28 4854 290a 2020 2020  n = len(HT).    
+000048e0: 2020 2020 6966 206e 203e 206c 656e 2873      if n > len(s
+000048f0: 656c 662e 6c69 6e6b 7329 3a0a 2020 2020  elf.links):.    
+00004900: 2020 2020 2020 2020 7072 696e 7428 2245          print("E
+00004910: 5252 4f52 3a20 6e75 6d62 6572 206f 6620  RROR: number of 
+00004920: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
+00004930: 7366 6f72 6d61 7469 6f6e 7320 2848 5429  sformations (HT)
+00004940: 2067 7265 6174 6572 2074 6861 6e20 6e75   greater than nu
+00004950: 6d62 6572 206f 6620 6c69 6e6b 7322 290a  mber of links").
+00004960: 0a20 2020 2020 2020 2023 6c69 6e6b 2069  .        #link i
+00004970: 6e64 6578 2069 7320 7573 7561 6c6c 7920  ndex is usually 
+00004980: 7468 6520 6c61 7374 206c 696e 6b20 636f  the last link co
+00004990: 6e74 6169 6e65 6420 696e 2048 5420 2861  ntained in HT (a
+000049a0: 6c6c 2073 7562 7365 7175 656e 7420 636f  ll subsequent co
+000049b0: 6c75 6d6e 7320 696e 206a 6163 6f62 6961  lumns in jacobia
+000049c0: 6e20 776f 756c 6420 6265 2061 6e79 7761  n would be anywa
+000049d0: 7920 7a65 726f 293a 0a20 2020 2020 2020  y zero):.       
+000049e0: 2069 6620 6c69 6e6b 496e 6465 7820 3d3d   if linkIndex ==
+000049f0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00004a00: 2020 206c 696e 6b49 6e64 6578 203d 206e     linkIndex = n
+00004a10: 2d31 0a20 2020 200a 2020 2020 2020 2020  -1.    .        
+00004a20: 4a6f 6d65 6761 203d 206e 702e 7a65 726f  Jomega = np.zero
+00004a30: 7328 2833 2c6e 2929 2372 6f74 6174 696f  s((3,n))#rotatio
+00004a40: 6e20 7061 7274 206f 6620 6a61 636f 6269  n part of jacobi
+00004a50: 616e 0a20 2020 2020 2020 204a 7665 6c20  an.        Jvel 
+00004a60: 3d20 6e70 2e7a 6572 6f73 2828 332c 6e29  = np.zeros((3,n)
+00004a70: 2920 2023 7472 616e 736c 6174 696f 6e20  )  #translation 
+00004a80: 7061 7274 206f 6620 6a61 636f 6269 616e  part of jacobian
+00004a90: 0a20 2020 2020 2020 2023 4120 3d20 6572  .        #A = er
+00004aa0: 622e 4854 3272 6f74 6174 696f 6e4d 6174  b.HT2rotationMat
+00004ab0: 7269 7828 7365 6c66 2e47 6574 4261 7365  rix(self.GetBase
+00004ac0: 4854 2829 290a 2020 2020 2020 2020 2376  HT()).        #v
+00004ad0: 5072 6576 696f 7573 203d 2065 7262 2e48  Previous = erb.H
+00004ae0: 5432 7472 616e 736c 6174 696f 6e28 7365  T2translation(se
+00004af0: 6c66 2e47 6574 4261 7365 4854 2829 290a  lf.GetBaseHT()).
+00004b00: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+00004b10: 2076 6e20 3d20 6c69 7374 2874 6f6f 6c50   vn = list(toolP
+00004b20: 6f73 6974 696f 6e29 0a20 2020 2020 2020  osition).       
+00004b30: 2069 6620 6c65 6e28 766e 2920 3d3d 2030   if len(vn) == 0
+00004b40: 3a0a 2020 2020 2020 2020 2020 2020 766e  :.            vn
+00004b50: 203d 2065 7262 2e48 5432 7472 616e 736c   = erb.HT2transl
+00004b60: 6174 696f 6e28 4854 5b6c 696e 6b49 6e64  ation(HT[linkInd
+00004b70: 6578 5d20 4020 7365 6c66 2e6c 696e 6b73  ex] @ self.links
+00004b80: 5b6c 696e 6b49 6e64 6578 5d2e 6c6f 6361  [linkIndex].loca
+00004b90: 6c48 5429 2023 6c61 7374 206c 696e 6b20  lHT) #last link 
+00004ba0: 636f 6f72 6469 6e61 7465 730a 0a0a 2020  coordinates...  
+00004bb0: 2020 2020 2020 2366 6f72 2074 7265 652c        #for tree,
+00004bc0: 2077 6520 6d61 7920 6f6e 6c79 2063 6f6e   we may only con
+00004bd0: 7369 6465 7220 6c69 6e6b 7320 696e 2074  sider links in t
+00004be0: 6865 2063 6861 696e 2066 726f 6d20 6c69  he chain from li
+00004bf0: 6e6b 2074 6f20 6261 7365 210a 2020 2020  nk to base!.    
+00004c00: 2020 2020 6920 3d20 6c69 6e6b 496e 6465      i = linkInde
+00004c10: 780a 2020 2020 2020 2020 656e 6452 6561  x.        endRea
+00004c20: 6368 6564 203d 2046 616c 7365 0a20 2020  ched = False.   
+00004c30: 2020 2020 2077 6869 6c65 206e 6f74 2065       while not e
+00004c40: 6e64 5265 6163 6865 643a 0a20 2020 2020  ndReached:.     
+00004c50: 2020 2020 2020 2023 6966 2069 203e 2030         #if i > 0
+00004c60: 3a0a 2020 2020 2020 2020 2020 2020 4120  :.            A 
+00004c70: 3d20 6572 622e 4854 3272 6f74 6174 696f  = erb.HT2rotatio
+00004c80: 6e4d 6174 7269 7828 4854 5b69 5d29 2023  nMatrix(HT[i]) #
+00004c90: 726f 7461 7469 6f6e 206f 6620 6a6f 696e  rotation of join
+00004ca0: 7420 690a 0a20 2020 2020 2020 2020 2020  t i..           
+00004cb0: 2023 206c 6f63 616c 4178 6973 203d 2065   # localAxis = e
+00004cc0: 7262 2e48 5432 726f 7461 7469 6f6e 4d61  rb.HT2rotationMa
+00004cd0: 7472 6978 2873 656c 662e 6c69 6e6b 735b  trix(self.links[
+00004ce0: 695d 2e70 7265 4854 2920 4020 6469 6374  i].preHT) @ dict
+00004cf0: 4a6f 696e 7454 7970 6532 4178 6973 5b73  JointType2Axis[s
+00004d00: 656c 662e 6c69 6e6b 735b 695d 2e6a 6f69  elf.links[i].joi
+00004d10: 6e74 5479 7065 5d0a 2020 2020 2020 2020  ntType].        
+00004d20: 2020 2020 6c6f 6361 6c41 7869 7320 3d20      localAxis = 
+00004d30: 6469 6374 4a6f 696e 7454 7970 6532 4178  dictJointType2Ax
+00004d40: 6973 5b73 656c 662e 6c69 6e6b 735b 695d  is[self.links[i]
+00004d50: 2e6a 6f69 6e74 5479 7065 5d0a 0a20 2020  .jointType]..   
+00004d60: 2020 2020 2020 2020 2061 7869 7320 3d20           axis = 
+00004d70: 4120 4020 6c6f 6361 6c41 7869 7320 2361  A @ localAxis #a
+00004d80: 7869 7320 696e 2067 6c6f 6261 6c20 636f  xis in global co
+00004d90: 6f72 6469 6e61 7465 730a 2020 2020 2020  ordinates.      
+00004da0: 2020 2020 2020 234f 4c44 2044 4820 7061        #OLD DH pa
+00004db0: 7261 6d65 7465 7220 6261 7365 643a 204a  rameter based: J
+00004dc0: 6f6d 6567 615b 303a 332c 695d 203d 2072  omega[0:3,i] = r
+00004dd0: 6f62 6f74 5b27 6a6f 696e 7454 7970 6527  obot['jointType'
+00004de0: 5d5b 695d 202a 2061 7869 7320 236f 6e6c  ][i] * axis #onl
+00004df0: 7920 636f 6e73 6964 6572 6564 2c20 6966  y considered, if
+00004e00: 2072 6576 6f6c 7574 6520 6a6f 696e 740a   revolute joint.
+00004e10: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00004e20: 656c 662e 6c69 6e6b 735b 695d 2e6a 6f69  elf.links[i].joi
+00004e30: 6e74 5479 7065 5b30 5d20 3d3d 2027 5227  ntType[0] == 'R'
+00004e40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00004e50: 2020 4a6f 6d65 6761 5b30 3a33 2c69 5d20    Jomega[0:3,i] 
+00004e60: 3d20 6178 6973 2023 6f6e 6c79 2063 6f6e  = axis #only con
+00004e70: 7369 6465 7265 642c 2069 6620 7265 766f  sidered, if revo
+00004e80: 6c75 7465 206a 6f69 6e74 0a20 2020 2020  lute joint.     
+00004e90: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00004ea0: 2020 2020 2376 5072 6576 696f 7573 203d      #vPrevious =
+00004eb0: 2065 7262 2e48 5432 7472 616e 736c 6174   erb.HT2translat
+00004ec0: 696f 6e28 4854 5b69 5d20 4020 7365 6c66  ion(HT[i] @ self
+00004ed0: 2e6c 696e 6b73 5b69 5d2e 7072 6548 5429  .links[i].preHT)
+00004ee0: 0a20 2020 2020 2020 2020 2020 2076 5072  .            vPr
+00004ef0: 6576 696f 7573 203d 2065 7262 2e48 5432  evious = erb.HT2
+00004f00: 7472 616e 736c 6174 696f 6e28 4854 5b69  translation(HT[i
+00004f10: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+00004f20: 0a20 2020 2020 2020 2020 2020 2023 7265  .            #re
+00004f30: 766f 6c75 7465 206a 6f69 6e74 3a0a 2020  volute joint:.  
+00004f40: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+00004f50: 662e 6c69 6e6b 735b 695d 2e6a 6f69 6e74  f.links[i].joint
+00004f60: 5479 7065 5b30 5d20 3d3d 2027 5227 3a20  Type[0] == 'R': 
+00004f70: 2372 6576 6f6c 7574 6520 6a6f 696e 740a  #revolute joint.
+00004f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004f90: 4a76 656c 5b30 3a33 2c69 5d20 2020 3d20  Jvel[0:3,i]   = 
+00004fa0: 6572 622e 536b 6577 2861 7869 7329 2040  erb.Skew(axis) @
+00004fb0: 2028 766e 202d 2076 5072 6576 696f 7573   (vn - vPrevious
+00004fc0: 2920 236f 6e6c 7920 636f 6e73 6964 6572  ) #only consider
+00004fd0: 6564 2c20 6966 2072 6576 6f6c 7574 6520  ed, if revolute 
+00004fe0: 6a6f 696e 740a 2020 2020 2020 2020 2020  joint.          
+00004ff0: 2020 656c 6966 2073 656c 662e 6c69 6e6b    elif self.link
+00005000: 735b 695d 2e6a 6f69 6e74 5479 7065 5b30  s[i].jointType[0
+00005010: 5d20 3d3d 2027 5027 3a20 2370 7269 736d  ] == 'P': #prism
+00005020: 6174 6963 206a 6f69 6e74 0a20 2020 2020  atic joint.     
+00005030: 2020 2020 2020 2020 2020 204a 7665 6c5b             Jvel[
+00005040: 303a 332c 695d 2020 203d 2061 7869 730a  0:3,i]   = axis.
+00005050: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00005060: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005070: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00005080: 6f72 2827 526f 626f 742e 4a61 636f 6269  or('Robot.Jacobi
+00005090: 616e 282e 2e2e 293a 2069 6c6c 6567 616c  an(...): illegal
+000050a0: 206a 6f69 6e74 5479 7065 2729 0a20 2020   jointType').   
+000050b0: 2020 2020 2020 2020 2020 2020 200a 2020               .  
+000050c0: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+000050d0: 2073 656c 662e 4861 7350 6172 656e 7428   self.HasParent(
+000050e0: 6929 3a0a 2020 2020 2020 2020 2020 2020  i):.            
+000050f0: 2020 2020 656e 6452 6561 6368 6564 203d      endReached =
+00005100: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+00005110: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00005120: 2020 2020 2020 2020 6920 3d20 7365 6c66          i = self
+00005130: 2e47 6574 5061 7265 6e74 496e 6465 7828  .GetParentIndex(
+00005140: 6929 0a20 2020 2020 2020 200a 2020 2020  i).        .    
+00005150: 2020 2020 6966 206d 6f64 6520 3d3d 2027      if mode == '
+00005160: 726f 7427 3a0a 2020 2020 2020 2020 2020  rot':.          
+00005170: 2020 4a20 3d20 4a6f 6d65 6761 0a20 2020    J = Jomega.   
+00005180: 2020 2020 2065 6c69 6620 6d6f 6465 203d       elif mode =
+00005190: 3d20 2774 7261 6e73 273a 0a20 2020 2020  = 'trans':.     
+000051a0: 2020 2020 2020 204a 203d 204a 7665 6c0a         J = Jvel.
+000051b0: 2020 2020 2020 2020 656c 6966 206d 6f64          elif mod
+000051c0: 6520 3d3d 2027 616c 6c27 3a0a 2020 2020  e == 'all':.    
+000051d0: 2020 2020 2020 2020 4a20 3d20 6e70 2e7a          J = np.z
+000051e0: 6572 6f73 2828 362c 6e29 290a 2020 2020  eros((6,n)).    
+000051f0: 2020 2020 2020 2020 4a5b 303a 332c 303a          J[0:3,0:
+00005200: 6e5d 203d 204a 7665 6c0a 2020 2020 2020  n] = Jvel.      
+00005210: 2020 2020 2020 4a5b 333a 362c 303a 6e5d        J[3:6,0:n]
+00005220: 203d 204a 6f6d 6567 610a 2020 2020 0a20   = Jomega.    . 
+00005230: 2020 2020 2020 2072 6574 7572 6e20 4a0a         return J.
+00005240: 0a0a 2020 2020 2325 252b 2b2b 2b2b 2b2b  ..    #%%+++++++
+00005250: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00005260: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00005270: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00005280: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00005290: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000052a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000052b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000052c0: 2b0a 2020 2020 232a 2a63 6c61 7373 4675  +.    #**classFu
+000052d0: 6e63 7469 6f6e 3a20 4164 6420 6120 4f62  nction: Add a Ob
+000052e0: 6a65 6374 4b69 6e65 6d61 7469 6354 7265  jectKinematicTre
+000052f0: 6520 746f 2065 7869 7374 696e 6720 6d62  e to existing mb
+00005300: 7320 6672 6f6d 2074 6865 2072 6f62 6f74  s from the robot
+00005310: 2073 7472 7563 7475 7265 2069 6e73 6964   structure insid
+00005320: 6520 7468 6973 2072 6f62 6f74 2063 6c61  e this robot cla
+00005330: 7373 3b0a 2020 2020 2320 2020 2020 2020  ss;.    #       
+00005340: 2020 2020 2020 2020 2020 4a6f 696e 7473            Joints
+00005350: 2064 6566 696e 6564 2062 7920 7468 6520   defined by the 
+00005360: 6b69 6e65 6d61 7469 6373 2061 7320 7765  kinematics as we
+00005370: 6c6c 2061 7320 6c69 6e6b 7320 2861 6e64  ll as links (and
+00005380: 2069 6e65 7274 6961 2920 6172 6520 7472   inertia) are tr
+00005390: 616e 7366 6572 7265 6420 746f 2074 6865  ansferred to the
+000053a0: 206b 696e 656d 6174 6963 2074 7265 6520   kinematic tree 
+000053b0: 6f62 6a65 6374 3b0a 2020 2020 2320 2020  object;.    #   
+000053c0: 2020 2020 2020 2020 2020 2020 2020 4375                Cu
+000053d0: 7272 656e 7420 696d 706c 656d 656e 7461  rrent implementa
+000053e0: 7469 6f6e 206f 6e6c 7920 776f 726b 7320  tion only works 
+000053f0: 666f 7220 7365 7269 616c 2072 6f62 6f74  for serial robot
+00005400: 733b 0a20 2020 2023 2020 2020 2020 2020  s;.    #        
+00005410: 2020 2020 2020 2020 2043 6f6e 7472 6f6c           Control
+00005420: 2063 616e 2062 6520 7265 616c 697a 6564   can be realized
+00005430: 2073 696d 706c 7920 6279 2061 6464 696e   simply by addin
+00005440: 6720 5044 636f 6e74 726f 6c20 746f 2052  g PDcontrol to R
+00005450: 6f62 6f74 4c69 6e6b 2073 7472 7563 7475  obotLink structu
+00005460: 7265 732c 2074 6865 6e20 6d6f 6469 6679  res, then modify
+00005470: 696e 6720 6a6f 696e 7450 6f73 6974 696f  ing jointPositio
+00005480: 6e4f 6666 7365 7456 6563 746f 7220 616e  nOffsetVector an
+00005490: 6420 6a6f 696e 7456 656c 6f63 6974 794f  d jointVelocityO
+000054a0: 6666 7365 7456 6563 746f 7220 696e 204f  ffsetVector in O
+000054b0: 626a 6563 744b 696e 656d 6174 6963 5472  bjectKinematicTr
+000054c0: 6565 3b20 666f 7263 6520 6f66 6673 6574  ee; force offset
+000054d0: 7320 2865 2e67 2e2c 2073 7461 7469 6320  s (e.g., static 
+000054e0: 6f72 2064 796e 616d 6963 2074 6f72 7175  or dynamic torqu
+000054f0: 6520 636f 6d70 656e 7361 7469 6f6e 2920  e compensation) 
+00005500: 6361 6e20 6265 2061 6464 6564 2074 6f20  can be added to 
+00005510: 4b69 6e65 6d61 7469 6354 7265 6520 6a6f  KinematicTree jo
+00005520: 696e 7446 6f72 6365 5665 6374 6f72 3b20  intForceVector; 
+00005530: 6d6f 7265 2067 656e 6572 616c 2063 6f6e  more general con
+00005540: 7472 6f6c 2063 616e 2062 6520 6164 6465  trol can be adde
+00005550: 6420 6279 2075 7369 6e67 204b 696e 656d  d by using Kinem
+00005560: 6174 6963 5472 6565 2066 6f72 6365 5573  aticTree forceUs
+00005570: 6572 4675 6e63 7469 6f6e 3b0a 2020 2020  erFunction;.    
+00005580: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00005590: 2020 5468 6520 636f 6f72 6469 6e61 7465    The coordinate
+000055a0: 7320 696e 204b 696e 656d 6174 6963 5472  s in KinematicTr
+000055b0: 6565 2028 6173 2077 656c 6c20 6173 206a  ee (as well as j
+000055c0: 6f69 6e74 506f 7369 7469 6f6e 4f66 6673  ointPositionOffs
+000055d0: 6574 5665 6374 6f72 2c20 6574 632e 2920  etVector, etc.) 
+000055e0: 6172 6520 736f 7274 6564 2069 6e20 7468  are sorted in th
+000055f0: 6520 6f72 6465 7220 6173 2074 6865 2052  e order as the R
+00005600: 6f62 6f74 4c69 6e6b 7320 6172 6520 6164  obotLinks are ad
+00005610: 6465 6420 746f 2074 6865 2052 6f62 6f74  ded to the Robot
+00005620: 2063 6c61 7373 3b0a 2020 2020 2320 2020   class;.    #   
+00005630: 2020 2020 2020 2020 2020 2020 2020 4e6f                No
+00005640: 7465 2074 6861 7420 7468 6520 4f62 6a65  te that the Obje
+00005650: 6374 4b69 6e65 6d61 7469 6354 7265 6520  ctKinematicTree 
+00005660: 6973 2073 7469 6c6c 2075 6e64 6572 2064  is still under d
+00005670: 6576 656c 6f70 6d65 6e74 2061 6e64 2069  evelopment and i
+00005680: 6e74 6572 6661 6365 7320 6d61 7920 6368  nterfaces may ch
+00005690: 616e 6765 2e0a 2020 2020 232a 2a69 6e70  ange..    #**inp
+000056a0: 7574 3a20 0a20 2020 2023 2020 206d 6273  ut: .    #   mbs
+000056b0: 3a20 7468 6520 6d75 6c74 6962 6f64 7920  : the multibody 
+000056c0: 7379 7374 656d 2c20 7768 6963 6820 7769  system, which wi
+000056d0: 6c6c 2062 6520 6578 7465 6e64 6564 0a20  ll be extended. 
+000056e0: 2020 2023 2020 206e 616d 653a 206f 626a     #   name: obj
+000056f0: 6563 7420 6e61 6d65 2069 6e20 4b69 6e65  ect name in Kine
+00005700: 6d61 7469 6354 7265 653b 2074 7261 6e73  maticTree; trans
+00005710: 6665 7272 6564 2074 6f20 4b69 6e65 6d61  ferred to Kinema
+00005720: 7469 6354 7265 652c 2064 6566 6175 6c74  ticTree, default
+00005730: 203d 2027 270a 2020 2020 2320 2020 666f   = ''.    #   fo
+00005740: 7263 6555 7365 7246 756e 6374 696f 6e3a  rceUserFunction:
+00005750: 2064 6566 696e 6573 2074 6865 2075 7365   defines the use
+00005760: 7220 6675 6e63 7469 6f6e 2066 6f72 2063  r function for c
+00005770: 6f6d 7075 7461 7469 6f6e 206f 6620 6a6f  omputation of jo
+00005780: 696e 7420 666f 7263 6573 2069 6e20 4b69  int forces in Ki
+00005790: 6e65 6d61 7469 6354 7265 653b 2074 7261  nematicTree; tra
+000057a0: 6e73 6665 7272 6564 2074 6f20 4b69 6e65  nsferred to Kine
+000057b0: 6d61 7469 6354 7265 652c 2064 6566 6175  maticTree, defau
+000057c0: 6c74 203d 2030 0a20 2020 2023 2a2a 6f75  lt = 0.    #**ou
+000057d0: 7470 7574 3a20 7468 6520 6675 6e63 7469  tput: the functi
+000057e0: 6f6e 2072 6574 7572 6e73 2061 2064 6963  on returns a dic
+000057f0: 7469 6f6e 6172 7920 636f 6e74 6169 6e69  tionary containi
+00005800: 6e67 2027 6e6f 6465 4765 6e65 7269 6327  ng 'nodeGeneric'
+00005810: 3a20 6765 6e65 7269 6320 4f44 4532 206e  : generic ODE2 n
+00005820: 6f64 6520 6e75 6d62 6572 202c 276f 626a  ode number ,'obj
+00005830: 6563 744b 696e 656d 6174 6963 5472 6565  ectKinematicTree
+00005840: 273a 2074 6865 206b 696e 656d 6174 6963  ': the kinematic
+00005850: 2074 7265 6520 6f62 6a65 6374 2c20 2762   tree object, 'b
+00005860: 6173 654f 626a 6563 7427 3a20 7468 6520  aseObject': the 
+00005870: 6261 7365 206f 626a 6563 7420 6966 2063  base object if c
+00005880: 7265 6174 6564 2c20 6f74 6865 7277 6973  reated, otherwis
+00005890: 6520 4e6f 6e65 3b20 6675 7274 6865 7220  e None; further 
+000058a0: 7661 6c75 6573 2077 696c 6c20 6265 2061  values will be a
+000058b0: 6464 6564 2069 6e20 6675 7475 7265 0a20  dded in future. 
+000058c0: 2020 2064 6566 2043 7265 6174 654b 696e     def CreateKin
+000058d0: 656d 6174 6963 5472 6565 2873 656c 662c  ematicTree(self,
+000058e0: 206d 6273 2c20 6e61 6d65 203d 2027 272c   mbs, name = '',
+000058f0: 2066 6f72 6365 5573 6572 4675 6e63 7469   forceUserFuncti
+00005900: 6f6e 203d 2030 293a 0a20 2020 2020 2020  on = 0):.       
+00005910: 2023 6465 6620 4372 6561 7465 4b69 6e65   #def CreateKine
+00005920: 6d61 7469 6354 7265 6528 7365 6c66 2c20  maticTree(self, 
+00005930: 6d62 732c 206a 6f69 6e74 5370 7269 6e67  mbs, jointSpring
+00005940: 4461 6d70 6572 5573 6572 4675 6e63 7469  DamperUserFuncti
+00005950: 6f6e 4c69 7374 3d5b 5d29 3a0a 0a20 2020  onList=[]):..   
+00005960: 2020 2020 2023 6164 6420 6772 6170 6869       #add graphi
+00005970: 6373 2066 6f72 2062 6173 653a 0a20 2020  cs for base:.   
+00005980: 2020 2020 2062 6173 654f 626a 6563 7420       baseObject 
+00005990: 3d20 4e6f 6e65 2023 6966 2069 7420 646f  = None #if it do
+000059a0: 6573 206e 6f74 2065 7869 7374 0a20 2020  es not exist.   
+000059b0: 2020 2020 2062 6173 654f 6666 7365 7420       baseOffset 
+000059c0: 3d20 6572 622e 4854 3274 7261 6e73 6c61  = erb.HT2transla
+000059d0: 7469 6f6e 2873 656c 662e 6261 7365 2e48  tion(self.base.H
+000059e0: 5429 0a0a 2020 2020 2020 2020 6966 2073  T)..        if s
+000059f0: 656c 662e 6261 7365 2e76 6973 7561 6c69  elf.base.visuali
+00005a00: 7a61 7469 6f6e 2e67 7261 7068 6963 7344  zation.graphicsD
+00005a10: 6174 6120 213d 205b 5d3a 0a20 2020 2020  ata != []:.     
+00005a20: 2020 2020 2020 2023 6164 6420 6120 6772         #add a gr
+00005a30: 6f75 6e64 206f 626a 6563 7420 6174 2062  ound object at b
+00005a40: 6173 6520 706f 7369 7469 6f6e 0a20 2020  ase position.   
+00005a50: 2020 2020 2020 2020 2067 7261 7068 6963           graphic
+00005a60: 7344 6174 6142 6173 6520 3d20 5b5d 0a20  sDataBase = []. 
+00005a70: 2020 2020 2020 2020 2020 2070 4f66 6620             pOff 
+00005a80: 3d20 6261 7365 4f66 6673 6574 0a20 2020  = baseOffset.   
+00005a90: 2020 2020 2020 2020 2041 6f66 6620 3d20           Aoff = 
+00005aa0: 6572 622e 4854 3272 6f74 6174 696f 6e4d  erb.HT2rotationM
+00005ab0: 6174 7269 7828 7365 6c66 2e62 6173 652e  atrix(self.base.
+00005ac0: 4854 290a 2020 2020 2020 2020 2020 2020  HT).            
+00005ad0: 666f 7220 6461 7461 2069 6e20 7365 6c66  for data in self
+00005ae0: 2e62 6173 652e 7669 7375 616c 697a 6174  .base.visualizat
+00005af0: 696f 6e2e 6772 6170 6869 6373 4461 7461  ion.graphicsData
+00005b00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005b10: 2020 6772 6170 6869 6373 4461 7461 4261    graphicsDataBa
+00005b20: 7365 202b 3d20 5b65 6764 2e4d 6f76 6547  se += [egd.MoveG
+00005b30: 7261 7068 6963 7344 6174 6128 6461 7461  raphicsData(data
+00005b40: 2c20 5b30 2c30 2c30 5d2c 2041 6f66 6629  , [0,0,0], Aoff)
+00005b50: 5d20 236f 6e6c 7920 726f 7461 7465 642c  ] #only rotated,
+00005b60: 2074 7261 6e73 6c61 7469 6f6e 2069 7320   translation is 
+00005b70: 696e 2067 726f 756e 640a 0a20 2020 2020  in ground..     
+00005b80: 2020 2020 2020 2062 6173 654f 626a 6563         baseObjec
+00005b90: 7420 3d20 6d62 732e 4164 644f 626a 6563  t = mbs.AddObjec
+00005ba0: 7428 6569 692e 4f62 6a65 6374 4772 6f75  t(eii.ObjectGrou
+00005bb0: 6e64 2872 6566 6572 656e 6365 506f 7369  nd(referencePosi
+00005bc0: 7469 6f6e 3d70 4f66 662c 200a 2020 2020  tion=pOff, .    
+00005bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005c00: 7669 7375 616c 697a 6174 696f 6e3d 6569  visualization=ei
+00005c10: 692e 564f 626a 6563 7447 726f 756e 6428  i.VObjectGround(
+00005c20: 6772 6170 6869 6373 4461 7461 3d67 7261  graphicsData=gra
+00005c30: 7068 6963 7344 6174 6142 6173 6529 2929  phicsDataBase)))
+00005c40: 0a0a 2020 2020 2020 2020 232b 2b2b 2b2b  ..        #+++++
+00005c50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00005c60: 2b2b 0a20 2020 2020 2020 2023 5463 7572  ++.        #Tcur
+00005c70: 7265 6e74 203d 2073 656c 662e 4765 7442  rent = self.GetB
+00005c80: 6173 6548 5428 290a 2020 2020 2020 2020  aseHT().        
+00005c90: 7152 6566 203d 2073 656c 662e 7265 6665  qRef = self.refe
+00005ca0: 7265 6e63 6543 6f6e 6669 6775 7261 7469  renceConfigurati
+00005cb0: 6f6e 0a20 2020 2020 2020 200a 2020 2020  on.        .    
+00005cc0: 2020 2020 6e4c 696e 6b73 203d 206c 656e      nLinks = len
+00005cd0: 2873 656c 662e 6c69 6e6b 7329 0a20 2020  (self.links).   
+00005ce0: 2020 2020 2067 7261 7068 6963 7344 6174       graphicsDat
+00005cf0: 614c 6973 7420 3d20 5b5d 2020 2023 6c69  aList = []   #li
+00005d00: 7374 206f 6620 6772 6170 6869 6373 4461  st of graphicsDa
+00005d10: 7461 2070 6572 206c 696e 6b0a 2020 2020  ta per link.    
+00005d20: 2020 2020 6a6f 696e 7454 7970 6573 4c69      jointTypesLi
+00005d30: 7374 203d 205b 5d20 2020 2020 2365 7875  st = []     #exu
+00005d40: 6479 6e20 6a6f 696e 7420 7479 7065 730a  dyn joint types.
+00005d50: 2020 2020 2020 2020 6c69 6e6b 5061 7265          linkPare
+00005d60: 6e74 7320 3d20 5b5d 0a0a 2020 2020 2020  nts = []..      
+00005d70: 2020 6a6f 696e 7454 7261 6e73 666f 726d    jointTransform
+00005d80: 6174 696f 6e73 3d5b 5d0a 2020 2020 2020  ations=[].      
+00005d90: 2020 6a6f 696e 744f 6666 7365 7473 3d5b    jointOffsets=[
+00005da0: 5d0a 2020 2020 2020 2020 6c69 6e6b 496e  ].        linkIn
+00005db0: 6572 7469 6173 434f 4d3d 5b5d 200a 2020  ertiasCOM=[] .  
+00005dc0: 2020 2020 2020 6c69 6e6b 434f 4d73 3d5b        linkCOMs=[
+00005dd0: 5d0a 2020 2020 2020 2020 6c69 6e6b 4d61  ].        linkMa
+00005de0: 7373 6573 3d5b 5d0a 0a20 2020 2020 2020  sses=[]..       
+00005df0: 2023 6966 2050 4420 636f 6e74 726f 6c20   #if PD control 
+00005e00: 6578 6973 7473 2c20 7468 6973 2076 6563  exists, this vec
+00005e10: 746f 7220 6973 206b 6570 742c 206f 7468  tor is kept, oth
+00005e20: 6572 7769 7365 2065 7261 7365 643a 0a20  erwise erased:. 
+00005e30: 2020 2020 2020 206a 6f69 6e74 5043 6f6e         jointPCon
+00005e40: 7472 6f6c 5665 6374 6f72 203d 205b 305d  trolVector = [0]
+00005e50: 2a6e 4c69 6e6b 730a 2020 2020 2020 2020  *nLinks.        
+00005e60: 6a6f 696e 7444 436f 6e74 726f 6c56 6563  jointDControlVec
+00005e70: 746f 7220 3d20 5b30 5d2a 6e4c 696e 6b73  tor = [0]*nLinks
+00005e80: 0a20 2020 2020 2020 206a 6f69 6e74 506f  .        jointPo
+00005e90: 7369 7469 6f6e 4f66 6673 6574 5665 6374  sitionOffsetVect
+00005ea0: 6f72 203d 205b 305d 2a6e 4c69 6e6b 730a  or = [0]*nLinks.
+00005eb0: 2020 2020 2020 2020 6a6f 696e 7456 656c          jointVel
+00005ec0: 6f63 6974 794f 6666 7365 7456 6563 746f  ocityOffsetVecto
+00005ed0: 7220 3d20 5b30 5d2a 6e4c 696e 6b73 0a20  r = [0]*nLinks. 
+00005ee0: 2020 2020 2020 2068 6173 5044 636f 6e74         hasPDcont
+00005ef0: 726f 6c20 3d20 4661 6c73 6520 2354 7275  rol = False #Tru
+00005f00: 652c 2069 6620 616e 7920 6c69 6e6b 2068  e, if any link h
+00005f10: 6173 2063 6f6e 7472 6f6c 0a20 2020 2020  as control.     
+00005f20: 2020 200a 2020 2020 2020 2020 2363 7265     .        #cre
+00005f30: 6174 6520 726f 626f 7420 7472 6565 3a0a  ate robot tree:.
+00005f40: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
+00005f50: 2072 616e 6765 286e 4c69 6e6b 7329 3a0a   range(nLinks):.
+00005f60: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+00005f70: 203d 2073 656c 662e 6c69 6e6b 735b 695d   = self.links[i]
+00005f80: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
+00005f90: 6b50 6172 656e 7473 202b 3d20 5b73 656c  kParents += [sel
+00005fa0: 662e 4765 7450 6172 656e 7449 6e64 6578  f.GetParentIndex
+00005fb0: 2869 295d 0a0a 2020 2020 2020 2020 2020  (i)]..          
+00005fc0: 2020 2320 6966 206e 702e 6c69 6e61 6c67    # if np.linalg
+00005fd0: 2e6e 6f72 6d28 6c69 6e6b 2e6c 6f63 616c  .norm(link.local
+00005fe0: 4854 202d 2065 7262 2e48 5430 2829 2920  HT - erb.HT0()) 
+00005ff0: 3e3d 2031 652d 3134 3a20 236e 6f77 2069  >= 1e-14: #now i
+00006000: 6d70 6c65 6d65 6e74 6564 0a20 2020 2020  mplemented.     
+00006010: 2020 2020 2020 2023 2020 2020 2072 6169         #     rai
+00006020: 7365 2056 616c 7565 4572 726f 7228 2743  se ValueError('C
+00006030: 7265 6174 654b 696e 656d 6174 6963 5472  reateKinematicTr
+00006040: 6565 3a20 6361 6e20 6f6e 6c79 2063 6f6e  ee: can only con
+00006050: 7665 7274 2072 6f62 6f74 7320 7769 7468  vert robots with
+00006060: 206c 6f63 616c 4854 203d 2069 6465 6e74   localHT = ident
+00006070: 6974 7927 290a 2020 2020 2020 2020 2020  ity').          
+00006080: 2020 6966 206c 696e 6b2e 6a6f 696e 7454    if link.jointT
+00006090: 7970 6520 6e6f 7420 696e 2064 6963 744a  ype not in dictJ
+000060a0: 6f69 6e74 5479 7065 3241 7869 733a 0a20  ointType2Axis:. 
+000060b0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000060c0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+000060d0: 2743 7265 6174 654b 696e 656d 6174 6963  'CreateKinematic
+000060e0: 5472 6565 3a20 666f 756e 6420 696e 7661  Tree: found inva
+000060f0: 6c69 6420 6a6f 696e 7420 7479 7065 2069  lid joint type i
+00006100: 6e20 6c69 6e6b 2027 2b73 7472 2869 292b  n link '+str(i)+
+00006110: 273a 272b 6c69 6e6b 2e6a 6f69 6e74 5479  ':'+link.jointTy
+00006120: 7065 290a 0a0a 2020 2020 2020 2020 2020  pe)...          
+00006130: 2020 6178 6973 203d 2064 6963 744a 6f69    axis = dictJoi
+00006140: 6e74 5479 7065 3241 7869 735b 6c69 6e6b  ntType2Axis[link
+00006150: 2e6a 6f69 6e74 5479 7065 5d0a 2020 2020  .jointType].    
+00006160: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+00006170: 2020 2020 2069 6620 6c69 6e6b 2e48 6173       if link.Has
+00006180: 5044 636f 6e74 726f 6c28 293a 0a20 2020  PDcontrol():.   
+00006190: 2020 2020 2020 2020 2020 2020 206a 6f69               joi
+000061a0: 6e74 5043 6f6e 7472 6f6c 5665 6374 6f72  ntPControlVector
+000061b0: 5b69 5d20 3d20 6c69 6e6b 2e47 6574 5044  [i] = link.GetPD
+000061c0: 636f 6e74 726f 6c28 295b 305d 0a20 2020  control()[0].   
+000061d0: 2020 2020 2020 2020 2020 2020 206a 6f69               joi
+000061e0: 6e74 4443 6f6e 7472 6f6c 5665 6374 6f72  ntDControlVector
+000061f0: 5b69 5d20 3d20 6c69 6e6b 2e47 6574 5044  [i] = link.GetPD
+00006200: 636f 6e74 726f 6c28 295b 315d 0a20 2020  control()[1].   
+00006210: 2020 2020 2020 2020 2020 2020 2068 6173               has
+00006220: 5044 636f 6e74 726f 6c20 3d20 5472 7565  PDcontrol = True
+00006230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006240: 200a 2020 2020 2020 2020 2020 2020 2320   .            # 
+00006250: 636f 6d20 3d20 6c69 6e6b 2e43 4f4d 0a20  com = link.COM. 
+00006260: 2020 2020 2020 2020 2020 2023 2b2b 2b2b             #++++
+00006270: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00006280: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0a20  ++++++++++++++. 
+00006290: 2020 2020 2020 2020 2020 206a 6f69 6e74             joint
+000062a0: 5479 7065 734c 6973 7420 2b3d 205b 6469  TypesList += [di
+000062b0: 6374 4a6f 696e 7454 7970 6554 6578 7432  ctJointTypeText2
+000062c0: 4578 7564 796e 5b6c 696e 6b2e 6a6f 696e  Exudyn[link.join
+000062d0: 7454 7970 655d 5d0a 2020 2020 2020 2020  tType]].        
+000062e0: 2020 2020 2320 6a6f 696e 7454 7261 6e73      # jointTrans
+000062f0: 666f 726d 6174 696f 6e73 202b 3d20 5b65  formations += [e
+00006300: 7262 2e48 5432 726f 7461 7469 6f6e 4d61  rb.HT2rotationMa
+00006310: 7472 6978 286c 696e 6b2e 7072 6548 5429  trix(link.preHT)
+00006320: 5d20 0a20 2020 2020 2020 2020 2020 2023  ] .            #
+00006330: 206a 6f69 6e74 4f66 6673 6574 7320 2b3d   jointOffsets +=
+00006340: 205b 6572 622e 4854 3274 7261 6e73 6c61   [erb.HT2transla
+00006350: 7469 6f6e 286c 696e 6b2e 7072 6548 5429  tion(link.preHT)
+00006360: 5d0a 2020 2020 2020 2020 2020 2020 0a20  ].            . 
+00006370: 2020 2020 2020 2020 2020 2023 200a 2020             # .  
+00006380: 2020 2020 2020 2020 2020 7061 7265 6e74            parent
+00006390: 4c69 6e6b 4c6f 6361 6c48 5420 3d20 6572  LinkLocalHT = er
+000063a0: 622e 4854 3028 290a 2020 2020 2020 2020  b.HT0().        
+000063b0: 2020 2020 6966 2073 656c 662e 4861 7350      if self.HasP
+000063c0: 6172 656e 7428 6929 3a0a 2020 2020 2020  arent(i):.      
+000063d0: 2020 2020 2020 2020 2020 7061 7265 6e74            parent
+000063e0: 4c69 6e6b 4c6f 6361 6c48 5420 3d20 7365  LinkLocalHT = se
+000063f0: 6c66 2e6c 696e 6b73 5b73 656c 662e 4765  lf.links[self.Ge
+00006400: 7450 6172 656e 7449 6e64 6578 2869 295d  tParentIndex(i)]
+00006410: 2e6c 6f63 616c 4854 0a20 2020 2020 2020  .localHT.       
+00006420: 2020 2020 206a 6f69 6e74 5472 616e 7366       jointTransf
+00006430: 6f72 6d61 7469 6f6e 7320 2b3d 205b 6572  ormations += [er
+00006440: 622e 4854 3272 6f74 6174 696f 6e4d 6174  b.HT2rotationMat
+00006450: 7269 7828 7061 7265 6e74 4c69 6e6b 4c6f  rix(parentLinkLo
+00006460: 6361 6c48 5420 4020 6c69 6e6b 2e70 7265  calHT @ link.pre
+00006470: 4854 295d 200a 2020 2020 2020 2020 2020  HT)] .          
+00006480: 2020 6a6f 696e 744f 6666 7365 7473 202b    jointOffsets +
+00006490: 3d20 5b65 7262 2e48 5432 7472 616e 736c  = [erb.HT2transl
+000064a0: 6174 696f 6e28 7061 7265 6e74 4c69 6e6b  ation(parentLink
+000064b0: 4c6f 6361 6c48 5420 4020 6c69 6e6b 2e70  LocalHT @ link.p
+000064c0: 7265 4854 295d 0a0a 2020 2020 2020 2020  reHT)]..        
+000064d0: 2020 2020 2369 6e65 7274 6961 2069 7320      #inertia is 
+000064e0: 6465 6669 6e65 6420 696e 206c 696e 6b20  defined in link 
+000064f0: 636f 6f72 6469 6e61 7465 733b 2062 7574  coordinates; but
+00006500: 204b 696e 656d 6174 6963 5472 6565 206e   KinematicTree n
+00006510: 6565 6473 2069 6e65 7274 6961 2077 2e72  eeds inertia w.r
+00006520: 2e74 2e20 6a6f 696e 7420 636f 6f72 6469  .t. joint coordi
+00006530: 6e61 7465 733a 0a20 2020 2020 2020 2020  nates:.         
+00006540: 2020 2072 6269 203d 2065 7262 2e52 6967     rbi = erb.Rig
+00006550: 6964 426f 6479 496e 6572 7469 6128 290a  idBodyInertia().
+00006560: 2020 2020 2020 2020 2020 2020 7262 692e              rbi.
+00006570: 5365 7457 6974 6843 4f4d 696e 6572 7469  SetWithCOMinerti
+00006580: 6128 6c69 6e6b 2e6d 6173 732c 206c 696e  a(link.mass, lin
+00006590: 6b2e 696e 6572 7469 612c 206c 696e 6b2e  k.inertia, link.
+000065a0: 434f 4d29 0a20 2020 200a 2020 2020 2020  COM).    .      
+000065b0: 2020 2020 2020 7262 6920 3d20 7262 692e        rbi = rbi.
+000065c0: 5472 616e 7366 6f72 6d65 6428 286c 696e  Transformed((lin
+000065d0: 6b2e 6c6f 6361 6c48 5429 2920 2369 6e65  k.localHT)) #ine
+000065e0: 7274 6961 2070 6172 616d 6574 6572 7320  rtia parameters 
+000065f0: 6e65 6564 2074 6f20 6265 2074 7261 6e73  need to be trans
+00006600: 666f 726d 6564 2074 6f20 6a6f 696e 7420  formed to joint 
+00006610: 6672 616d 650a 2020 2020 2020 2020 2020  frame.          
+00006620: 2020 0a20 2020 2020 2020 2020 2020 206c    .            l
+00006630: 696e 6b49 6e65 7274 6961 7343 4f4d 202b  inkInertiasCOM +
+00006640: 3d20 5b72 6269 2e49 6e65 7274 6961 434f  = [rbi.InertiaCO
+00006650: 4d28 295d 2023 4b69 6e65 6d61 7469 6354  M()] #KinematicT
+00006660: 7265 6520 6e65 6564 7320 696e 6572 7469  ree needs inerti
+00006670: 6120 772e 722e 742e 2043 4f4d 0a20 2020  a w.r.t. COM.   
+00006680: 2020 2020 2020 2020 206c 696e 6b43 4f4d           linkCOM
+00006690: 7320 2b3d 205b 7262 692e 434f 4d28 295d  s += [rbi.COM()]
+000066a0: 200a 2020 2020 2020 2020 2020 2020 6c69   .            li
+000066b0: 6e6b 4d61 7373 6573 202b 3d20 5b72 6269  nkMasses += [rbi
+000066c0: 2e4d 6173 7328 295d 0a20 2020 2020 2020  .Mass()].       
+000066d0: 2020 2020 2023 206c 696e 6b49 6e65 7274       # linkInert
+000066e0: 6961 7343 4f4d 202b 3d20 5b6c 696e 6b2e  iasCOM += [link.
+000066f0: 696e 6572 7469 615d 2023 6973 2061 6c72  inertia] #is alr
+00006700: 6561 6479 2077 2e72 2e74 2e20 434f 4d0a  eady w.r.t. COM.
+00006710: 2020 2020 2020 2020 2020 2020 2320 6c69              # li
+00006720: 6e6b 434f 4d73 202b 3d20 5b6c 696e 6b2e  nkCOMs += [link.
+00006730: 434f 4d5d 0a20 2020 2020 2020 2020 2020  COM].           
+00006740: 2023 206c 696e 6b4d 6173 7365 7320 2b3d   # linkMasses +=
+00006750: 205b 6c69 6e6b 2e6d 6173 735d 0a0a 2020   [link.mass]..  
+00006760: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
+00006770: 2020 2020 2020 2023 2b2b 2b2b 2b2b 2b2b         #++++++++
+00006780: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00006790: 2b2b 2b2b 2b2b 2b2b 2b2b 0a20 2020 2020  ++++++++++.     
+000067a0: 2020 2020 2020 2023 7669 7375 616c 697a         #visualiz
+000067b0: 6174 696f 6e3a 0a20 2020 2020 2020 2020  ation:.         
+000067c0: 2020 206c 696e 6b56 6973 7561 6c69 7a61     linkVisualiza
+000067d0: 7469 6f6e 203d 206c 696e 6b2e 7669 7375  tion = link.visu
+000067e0: 616c 697a 6174 696f 6e0a 2020 2020 2020  alization.      
+000067f0: 2020 2020 2020 7368 6f77 4d42 536a 6f69        showMBSjoi
+00006800: 6e74 203d 206c 696e 6b56 6973 7561 6c69  nt = linkVisuali
+00006810: 7a61 7469 6f6e 2e73 686f 774d 4253 6a6f  zation.showMBSjo
+00006820: 696e 740a 2020 2020 2020 2020 2020 2020  int.            
+00006830: 7220 3d20 6c69 6e6b 5669 7375 616c 697a  r = linkVisualiz
+00006840: 6174 696f 6e2e 6a6f 696e 7452 6164 6975  ation.jointRadiu
+00006850: 730a 2020 2020 2020 2020 2020 2020 774a  s.            wJ
+00006860: 203d 206c 696e 6b56 6973 7561 6c69 7a61   = linkVisualiza
+00006870: 7469 6f6e 2e6a 6f69 6e74 5769 6474 680a  tion.jointWidth.
+00006880: 2020 2020 2020 2020 2020 2020 774c 203d              wL =
+00006890: 206c 696e 6b56 6973 7561 6c69 7a61 7469   linkVisualizati
+000068a0: 6f6e 2e6c 696e 6b57 6964 7468 0a20 2020  on.linkWidth.   
+000068b0: 2020 2020 2020 2020 2063 6f6c 6f72 203d           color =
+000068c0: 206c 696e 6b56 6973 7561 6c69 7a61 7469   linkVisualizati
+000068d0: 6f6e 2e6c 696e 6b43 6f6c 6f72 0a20 2020  on.linkColor.   
+000068e0: 2020 2020 2020 2020 200a 2020 2020 2020           .      
+000068f0: 2020 2020 2020 6772 6170 6869 6373 4461        graphicsDa
+00006900: 7461 4c69 6e6b 203d 205b 5d0a 2020 2020  taLink = [].    
+00006910: 2020 2020 2020 2020 2364 7261 7720 434f          #draw CO
+00006920: 4d3a 0a20 2020 2020 2020 2020 2020 2069  M:.            i
+00006930: 6620 6c69 6e6b 5669 7375 616c 697a 6174  f linkVisualizat
+00006940: 696f 6e2e 7368 6f77 434f 4d3a 0a20 2020  ion.showCOM:.   
+00006950: 2020 2020 2020 2020 2020 2020 2064 6420               dd 
+00006960: 3d20 722a 302e 320a 2020 2020 2020 2020  = r*0.2.        
+00006970: 2020 2020 2020 2020 636f 6c6f 7243 4f4d          colorCOM
+00006980: 203d 2063 6f70 7928 636f 6c6f 7229 0a20   = copy(color). 
+00006990: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000069a0: 6f6c 6f72 434f 4d5b 305d 202a 3d20 302e  olorCOM[0] *= 0.
+000069b0: 3720 236d 616b 6520 434f 4d20 6120 6c69  7 #make COM a li
+000069c0: 7474 6c65 2064 6172 6b65 720a 2020 2020  ttle darker.    
+000069d0: 2020 2020 2020 2020 2020 2020 636f 6c6f              colo
+000069e0: 7243 4f4d 5b31 5d20 2a3d 2030 2e37 0a20  rCOM[1] *= 0.7. 
+000069f0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00006a00: 6f6c 6f72 434f 4d5b 325d 202a 3d20 302e  olorCOM[2] *= 0.
+00006a10: 370a 2020 2020 2020 2020 2020 2020 2020  7.              
+00006a20: 2020 6772 6170 6869 6373 4461 7461 4c69    graphicsDataLi
+00006a30: 6e6b 202b 3d20 5b65 6764 2e47 7261 7068  nk += [egd.Graph
+00006a40: 6963 7344 6174 614f 7274 686f 4375 6265  icsDataOrthoCube
+00006a50: 506f 696e 7428 7262 692e 434f 4d28 292c  Point(rbi.COM(),
+00006a60: 205b 6464 2c64 642c 6464 5d2c 2063 6f6c   [dd,dd,dd], col
+00006a70: 6f72 434f 4d29 5d0a 0a0a 2020 2020 2020  orCOM)]...      
+00006a80: 2020 2020 2020 2364 7261 7720 6a6f 696e        #draw join
+00006a90: 7420 696e 2074 6869 7320 6c69 6e6b 0a20  t in this link. 
+00006aa0: 2020 2020 2020 2020 2020 2069 6620 7368             if sh
+00006ab0: 6f77 4d42 536a 6f69 6e74 3a0a 2020 2020  owMBSjoint:.    
+00006ac0: 2020 2020 2020 2020 2020 2020 674a 6f69              gJoi
+00006ad0: 6e74 203d 2065 6764 2e47 7261 7068 6963  nt = egd.Graphic
+00006ae0: 7344 6174 6143 796c 696e 6465 7228 2d30  sDataCylinder(-0
+00006af0: 2e35 2a77 4a2a 6178 6973 2c20 302e 352a  .5*wJ*axis, 0.5*
+00006b00: 774a 2a61 7869 732c 2072 6164 6975 733d  wJ*axis, radius=
+00006b10: 722c 2063 6f6c 6f72 3d65 6764 2e63 6f6c  r, color=egd.col
+00006b20: 6f72 3467 7265 7929 0a20 2020 2020 2020  or4grey).       
+00006b30: 2020 2020 2020 2020 2067 7261 7068 6963           graphic
+00006b40: 7344 6174 614c 696e 6b20 2b3d 205b 674a  sDataLink += [gJ
+00006b50: 6f69 6e74 5d0a 2020 2020 2020 2020 2020  oint].          
+00006b60: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+00006b70: 2020 2023 6472 6177 206c 696e 6b20 6672     #draw link fr
+00006b80: 6f6d 2070 6172 656e 7420 6c69 6e6b 206f  om parent link o
+00006b90: 7269 6769 6e20 746f 2074 6869 7320 6c69  rigin to this li
+00006ba0: 6e6b 206f 7269 6769 6e2c 2064 6566 696e  nk origin, defin
+00006bb0: 6564 2062 7920 7072 6548 5420 6f66 2074  ed by preHT of t
+00006bc0: 6869 7320 6c69 6e6b 0a20 2020 2020 2020  his link.       
+00006bd0: 2020 2020 2069 6620 7365 6c66 2e48 6173       if self.Has
+00006be0: 5061 7265 6e74 2869 293a 0a20 2020 2020  Parent(i):.     
+00006bf0: 2020 2020 2020 2020 2020 2069 5061 7265             iPare
+00006c00: 6e74 203d 2073 656c 662e 4765 7450 6172  nt = self.GetPar
+00006c10: 656e 7449 6e64 6578 2869 290a 2020 2020  entIndex(i).    
+00006c20: 2020 2020 2020 2020 2020 2020 2370 6172              #par
+00006c30: 656e 744c 696e 6b20 3d20 7365 6c66 2e47  entLink = self.G
+00006c40: 6574 4c69 6e6b 2869 5061 7265 6e74 290a  etLink(iParent).
+00006c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006c60: 7650 6172 656e 7420 3d20 6572 622e 4854  vParent = erb.HT
+00006c70: 3274 7261 6e73 6c61 7469 6f6e 2870 6172  2translation(par
+00006c80: 656e 744c 696e 6b4c 6f63 616c 4854 406c  entLinkLocalHT@l
+00006c90: 696e 6b2e 7072 6548 5429 0a20 2020 2020  ink.preHT).     
+00006ca0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+00006cb0: 6e28 6c69 6e6b 5669 7375 616c 697a 6174  n(linkVisualizat
+00006cc0: 696f 6e2e 6772 6170 6869 6373 4461 7461  ion.graphicsData
+00006cd0: 2920 3d3d 2030 3a0a 2020 2020 2020 2020  ) == 0:.        
+00006ce0: 2020 2020 2020 2020 2020 2020 674c 696e              gLin
+00006cf0: 6b20 3d20 6567 642e 4772 6170 6869 6373  k = egd.Graphics
+00006d00: 4461 7461 4379 6c69 6e64 6572 285b 302e  DataCylinder([0.
+00006d10: 2c30 2e2c 302e 5d2c 2076 5061 7265 6e74  ,0.,0.], vParent
+00006d20: 2c20 7261 6469 7573 3d30 2e35 2a77 4c2c  , radius=0.5*wL,
+00006d30: 2063 6f6c 6f72 3d63 6f6c 6f72 290a 2020   color=color).  
+00006d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d50: 2020 6772 6170 6869 6373 4461 7461 4c69    graphicsDataLi
+00006d60: 7374 5b69 5061 7265 6e74 5d20 2b3d 205b  st[iParent] += [
+00006d70: 674c 696e 6b5d 0a0a 2020 2020 2020 2020  gLink]..        
+00006d80: 2020 2020 6966 206c 656e 286c 696e 6b56      if len(linkV
+00006d90: 6973 7561 6c69 7a61 7469 6f6e 2e67 7261  isualization.gra
+00006da0: 7068 6963 7344 6174 6129 2021 3d20 303a  phicsData) != 0:
+00006db0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006dc0: 2067 7261 7068 6963 7344 6174 614c 696e   graphicsDataLin
+00006dd0: 6b20 2b3d 206c 696e 6b56 6973 7561 6c69  k += linkVisuali
+00006de0: 7a61 7469 6f6e 2e67 7261 7068 6963 7344  zation.graphicsD
+00006df0: 6174 610a 0a20 2020 2020 2020 2020 2020  ata..           
+00006e00: 2023 6164 6420 7472 616e 7366 6f72 6d65   #add transforme
+00006e10: 6420 6772 6170 6869 6373 4461 7461 206f  d graphicsData o
+00006e20: 6620 746f 6f6c 2074 6f20 6c69 6e6b 2067  f tool to link g
+00006e30: 7261 7068 6963 730a 2020 2020 2020 2020  raphics.        
+00006e40: 2020 2020 6966 2028 693d 3d6c 656e 2873      if (i==len(s
+00006e50: 656c 662e 6c69 6e6b 7329 2d31 2061 6e64  elf.links)-1 and
+00006e60: 2023 746f 6f6c 0a20 2020 2020 2020 2020   #tool.         
+00006e70: 2020 2020 2020 2073 656c 662e 746f 6f6c         self.tool
+00006e80: 2e76 6973 7561 6c69 7a61 7469 6f6e 2e67  .visualization.g
+00006e90: 7261 7068 6963 7344 6174 6120 213d 205b  raphicsData != [
+00006ea0: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+00006eb0: 2020 2020 704f 6666 203d 2065 7262 2e48      pOff = erb.H
+00006ec0: 5432 7472 616e 736c 6174 696f 6e28 7365  T2translation(se
+00006ed0: 6c66 2e74 6f6f 6c2e 4854 290a 2020 2020  lf.tool.HT).    
+00006ee0: 2020 2020 2020 2020 2020 2020 416f 6666              Aoff
+00006ef0: 203d 2065 7262 2e48 5432 726f 7461 7469   = erb.HT2rotati
+00006f00: 6f6e 4d61 7472 6978 2873 656c 662e 746f  onMatrix(self.to
+00006f10: 6f6c 2e48 5429 0a20 2020 2020 2020 2020  ol.HT).         
+00006f20: 2020 2020 2020 2066 6f72 2064 6174 6120         for data 
+00006f30: 696e 2073 656c 662e 746f 6f6c 2e76 6973  in self.tool.vis
+00006f40: 7561 6c69 7a61 7469 6f6e 2e67 7261 7068  ualization.graph
+00006f50: 6963 7344 6174 613a 0a20 2020 2020 2020  icsData:.       
+00006f60: 2020 2020 2020 2020 2020 2020 2067 7261               gra
+00006f70: 7068 6963 7344 6174 614c 696e 6b20 2b3d  phicsDataLink +=
+00006f80: 205b 6567 642e 4d6f 7665 4772 6170 6869   [egd.MoveGraphi
+00006f90: 6373 4461 7461 2864 6174 612c 2070 4f66  csData(data, pOf
+00006fa0: 662c 2041 6f66 6629 5d20 0a0a 2020 2020  f, Aoff)] ..    
+00006fb0: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
+00006fc0: 4461 7461 4c69 7374 202b 3d20 5b67 7261  DataList += [gra
+00006fd0: 7068 6963 7344 6174 614c 696e 6b5d 0a20  phicsDataLink]. 
+00006fe0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00006ff0: 2363 7265 6174 6520 6e6f 6465 2066 6f72  #create node for
+00007000: 2075 6e6b 6e6f 776e 7320 6f66 204b 696e   unknowns of Kin
+00007010: 656d 6174 6963 5472 6565 0a20 2020 2020  ematicTree.     
+00007020: 2020 206e 4765 6e65 7269 6320 3d20 6d62     nGeneric = mb
+00007030: 732e 4164 644e 6f64 6528 6569 692e 4e6f  s.AddNode(eii.No
+00007040: 6465 4765 6e65 7269 634f 4445 3228 7265  deGenericODE2(re
+00007050: 6665 7265 6e63 6543 6f6f 7264 696e 6174  ferenceCoordinat
+00007060: 6573 3d71 5265 662c 0a20 2020 2020 2020  es=qRef,.       
+00007070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007090: 2020 2020 2020 2020 696e 6974 6961 6c43          initialC
+000070a0: 6f6f 7264 696e 6174 6573 3d5b 302e 5d2a  oordinates=[0.]*
+000070b0: 6e4c 696e 6b73 2c0a 2020 2020 2020 2020  nLinks,.        
 000070c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000070d0: 7365 6c66 2e74 6f6f 6c2e 7669 7375 616c  self.tool.visual
-000070e0: 697a 6174 696f 6e2e 6772 6170 6869 6373  ization.graphics
-000070f0: 4461 7461 2021 3d20 5b5d 293a 0d0a 2020  Data != []):..  
-00007100: 2020 2020 2020 2020 2020 2020 2020 704f                pO
-00007110: 6666 203d 2065 7262 2e48 5432 7472 616e  ff = erb.HT2tran
-00007120: 736c 6174 696f 6e28 7365 6c66 2e74 6f6f  slation(self.too
-00007130: 6c2e 4854 290d 0a20 2020 2020 2020 2020  l.HT)..         
-00007140: 2020 2020 2020 2041 6f66 6620 3d20 6572         Aoff = er
-00007150: 622e 4854 3272 6f74 6174 696f 6e4d 6174  b.HT2rotationMat
-00007160: 7269 7828 7365 6c66 2e74 6f6f 6c2e 4854  rix(self.tool.HT
-00007170: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00007180: 2020 2066 6f72 2064 6174 6120 696e 2073     for data in s
-00007190: 656c 662e 746f 6f6c 2e76 6973 7561 6c69  elf.tool.visuali
-000071a0: 7a61 7469 6f6e 2e67 7261 7068 6963 7344  zation.graphicsD
-000071b0: 6174 613a 0d0a 2020 2020 2020 2020 2020  ata:..          
-000071c0: 2020 2020 2020 2020 2020 6772 6170 6869            graphi
-000071d0: 6373 4461 7461 4c69 6e6b 202b 3d20 5b65  csDataLink += [e
-000071e0: 6764 2e4d 6f76 6547 7261 7068 6963 7344  gd.MoveGraphicsD
-000071f0: 6174 6128 6461 7461 2c20 704f 6666 2c20  ata(data, pOff, 
-00007200: 416f 6666 295d 200d 0a0d 0a20 2020 2020  Aoff)] ....     
-00007210: 2020 2020 2020 2067 7261 7068 6963 7344         graphicsD
-00007220: 6174 614c 6973 7420 2b3d 205b 6772 6170  ataList += [grap
-00007230: 6869 6373 4461 7461 4c69 6e6b 5d0d 0a20  hicsDataLink].. 
-00007240: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00007250: 2023 6372 6561 7465 206e 6f64 6520 666f   #create node fo
-00007260: 7220 756e 6b6e 6f77 6e73 206f 6620 4b69  r unknowns of Ki
-00007270: 6e65 6d61 7469 6354 7265 650d 0a20 2020  nematicTree..   
-00007280: 2020 2020 206e 4765 6e65 7269 6320 3d20       nGeneric = 
-00007290: 6d62 732e 4164 644e 6f64 6528 6569 692e  mbs.AddNode(eii.
-000072a0: 4e6f 6465 4765 6e65 7269 634f 4445 3228  NodeGenericODE2(
-000072b0: 7265 6665 7265 6e63 6543 6f6f 7264 696e  referenceCoordin
-000072c0: 6174 6573 3d71 5265 662c 0d0a 2020 2020  ates=qRef,..    
-000072d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000072e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000072f0: 2020 2020 2020 2020 2020 2069 6e69 7469             initi
-00007300: 616c 436f 6f72 6469 6e61 7465 733d 5b30  alCoordinates=[0
-00007310: 2e5d 2a6e 4c69 6e6b 732c 0d0a 2020 2020  .]*nLinks,..    
-00007320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007340: 2020 2020 2020 2020 2020 2069 6e69 7469             initi
-00007350: 616c 436f 6f72 6469 6e61 7465 735f 743d  alCoordinates_t=
-00007360: 5b30 2e5d 2a6e 4c69 6e6b 732c 0d0a 2020  [0.]*nLinks,..  
-00007370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000070d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000070e0: 2020 2020 2020 2069 6e69 7469 616c 436f         initialCo
+000070f0: 6f72 6469 6e61 7465 735f 743d 5b30 2e5d  ordinates_t=[0.]
+00007100: 2a6e 4c69 6e6b 732c 0a20 2020 2020 2020  *nLinks,.       
+00007110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007130: 2020 2020 2020 2020 6e75 6d62 6572 4f66          numberOf
+00007140: 4f44 4532 436f 6f72 6469 6e61 7465 733d  ODE2Coordinates=
+00007150: 6e4c 696e 6b73 2929 0a0a 2020 2020 2020  nLinks))..      
+00007160: 2020 6966 206e 6f74 2068 6173 5044 636f    if not hasPDco
+00007170: 6e74 726f 6c3a 2023 7573 6520 656d 7074  ntrol: #use empt
+00007180: 7920 6c69 7374 732c 206d 616b 6573 206d  y lists, makes m
+00007190: 6f64 656c 206d 6f72 6520 6566 6669 6369  odel more effici
+000071a0: 656e 740a 2020 2020 2020 2020 2020 2020  ent.            
+000071b0: 6a6f 696e 7450 436f 6e74 726f 6c56 6563  jointPControlVec
+000071c0: 746f 7220 3d20 5b5d 0a20 2020 2020 2020  tor = [].       
+000071d0: 2020 2020 206a 6f69 6e74 4443 6f6e 7472       jointDContr
+000071e0: 6f6c 5665 6374 6f72 203d 205b 5d0a 2020  olVector = [].  
+000071f0: 2020 2020 2020 2020 2020 6a6f 696e 7450            jointP
+00007200: 6f73 6974 696f 6e4f 6666 7365 7456 6563  ositionOffsetVec
+00007210: 746f 7220 3d20 5b5d 2023 7369 7a65 206d  tor = [] #size m
+00007220: 7573 7420 6167 7265 6520 7769 7468 206a  ust agree with j
+00007230: 6f69 6e74 5043 6f6e 7472 6f6c 5665 6374  ointPControlVect
+00007240: 6f72 0a20 2020 2020 2020 2020 2020 206a  or.            j
+00007250: 6f69 6e74 5665 6c6f 6369 7479 4f66 6673  ointVelocityOffs
+00007260: 6574 5665 6374 6f72 203d 205b 5d20 2373  etVector = [] #s
+00007270: 697a 6520 6d75 7374 2061 6772 6565 2077  ize must agree w
+00007280: 6974 6820 6a6f 696e 7444 436f 6e74 726f  ith jointDContro
+00007290: 6c56 6563 746f 720a 0a20 2020 2020 2020  lVector..       
+000072a0: 206a 6f69 6e74 466f 7263 6556 6563 746f   jointForceVecto
+000072b0: 7220 3d20 5b5d 2023 5b30 5d2a 6e4c 696e  r = [] #[0]*nLin
+000072c0: 6b73 2023 6e6f 7420 7573 6564 2072 6967  ks #not used rig
+000072d0: 6874 206e 6f77 0a0a 0a20 2020 2020 2020  ht now...       
+000072e0: 2023 6372 6561 7465 204b 696e 656d 6174   #create Kinemat
+000072f0: 6963 5472 6565 0a20 2020 2020 2020 206f  icTree.        o
+00007300: 4b54 203d 206d 6273 2e41 6464 4f62 6a65  KT = mbs.AddObje
+00007310: 6374 2865 6969 2e4f 626a 6563 744b 696e  ct(eii.ObjectKin
+00007320: 656d 6174 6963 5472 6565 286e 6f64 654e  ematicTree(nodeN
+00007330: 756d 6265 723d 6e47 656e 6572 6963 2c20  umber=nGeneric, 
+00007340: 6a6f 696e 7454 7970 6573 3d6a 6f69 6e74  jointTypes=joint
+00007350: 5479 7065 734c 6973 742c 206c 696e 6b50  TypesList, linkP
+00007360: 6172 656e 7473 3d6c 696e 6b50 6172 656e  arents=linkParen
+00007370: 7473 2c0a 2020 2020 2020 2020 2020 2020  ts,.            
 00007380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007390: 2020 2020 2020 2020 2020 2020 206e 756d               num
-000073a0: 6265 724f 664f 4445 3243 6f6f 7264 696e  berOfODE2Coordin
-000073b0: 6174 6573 3d6e 4c69 6e6b 7329 290d 0a0d  ates=nLinks))...
-000073c0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-000073d0: 6861 7350 4463 6f6e 7472 6f6c 3a20 2375  hasPDcontrol: #u
-000073e0: 7365 2065 6d70 7479 206c 6973 7473 2c20  se empty lists, 
-000073f0: 6d61 6b65 7320 6d6f 6465 6c20 6d6f 7265  makes model more
-00007400: 2065 6666 6963 6965 6e74 0d0a 2020 2020   efficient..    
-00007410: 2020 2020 2020 2020 6a6f 696e 7450 436f          jointPCo
-00007420: 6e74 726f 6c56 6563 746f 7220 3d20 5b5d  ntrolVector = []
-00007430: 0d0a 2020 2020 2020 2020 2020 2020 6a6f  ..            jo
-00007440: 696e 7444 436f 6e74 726f 6c56 6563 746f  intDControlVecto
-00007450: 7220 3d20 5b5d 0d0a 2020 2020 2020 2020  r = []..        
-00007460: 2020 2020 6a6f 696e 7450 6f73 6974 696f      jointPositio
-00007470: 6e4f 6666 7365 7456 6563 746f 7220 3d20  nOffsetVector = 
-00007480: 5b5d 2023 7369 7a65 206d 7573 7420 6167  [] #size must ag
-00007490: 7265 6520 7769 7468 206a 6f69 6e74 5043  ree with jointPC
-000074a0: 6f6e 7472 6f6c 5665 6374 6f72 0d0a 2020  ontrolVector..  
-000074b0: 2020 2020 2020 2020 2020 6a6f 696e 7456            jointV
-000074c0: 656c 6f63 6974 794f 6666 7365 7456 6563  elocityOffsetVec
-000074d0: 746f 7220 3d20 5b5d 2023 7369 7a65 206d  tor = [] #size m
-000074e0: 7573 7420 6167 7265 6520 7769 7468 206a  ust agree with j
-000074f0: 6f69 6e74 4443 6f6e 7472 6f6c 5665 6374  ointDControlVect
-00007500: 6f72 0d0a 0d0a 2020 2020 2020 2020 6a6f  or....        jo
-00007510: 696e 7446 6f72 6365 5665 6374 6f72 203d  intForceVector =
-00007520: 205b 5d20 235b 305d 2a6e 4c69 6e6b 7320   [] #[0]*nLinks 
-00007530: 236e 6f74 2075 7365 6420 7269 6768 7420  #not used right 
-00007540: 6e6f 770d 0a0d 0a0d 0a20 2020 2020 2020  now......       
-00007550: 2023 6372 6561 7465 204b 696e 656d 6174   #create Kinemat
-00007560: 6963 5472 6565 0d0a 2020 2020 2020 2020  icTree..        
-00007570: 6f4b 5420 3d20 6d62 732e 4164 644f 626a  oKT = mbs.AddObj
-00007580: 6563 7428 6569 692e 4f62 6a65 6374 4b69  ect(eii.ObjectKi
-00007590: 6e65 6d61 7469 6354 7265 6528 6e6f 6465  nematicTree(node
-000075a0: 4e75 6d62 6572 3d6e 4765 6e65 7269 632c  Number=nGeneric,
-000075b0: 206a 6f69 6e74 5479 7065 733d 6a6f 696e   jointTypes=join
-000075c0: 7454 7970 6573 4c69 7374 2c20 6c69 6e6b  tTypesList, link
-000075d0: 5061 7265 6e74 733d 6c69 6e6b 5061 7265  Parents=linkPare
-000075e0: 6e74 732c 0d0a 2020 2020 2020 2020 2020  nts,..          
-000075f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007610: 6a6f 696e 7454 7261 6e73 666f 726d 6174  jointTransformat
-00007620: 696f 6e73 3d65 7875 6479 6e2e 4d61 7472  ions=exudyn.Matr
-00007630: 6978 3344 4c69 7374 286a 6f69 6e74 5472  ix3DList(jointTr
-00007640: 616e 7366 6f72 6d61 7469 6f6e 7329 2c20  ansformations), 
-00007650: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00007390: 2020 2020 2020 2020 2020 2020 2020 6a6f                jo
+000073a0: 696e 7454 7261 6e73 666f 726d 6174 696f  intTransformatio
+000073b0: 6e73 3d65 7875 6479 6e2e 4d61 7472 6978  ns=exudyn.Matrix
+000073c0: 3344 4c69 7374 286a 6f69 6e74 5472 616e  3DList(jointTran
+000073d0: 7366 6f72 6d61 7469 6f6e 7329 2c20 0a20  sformations), . 
+000073e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000073f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007400: 2020 2020 2020 2020 206a 6f69 6e74 4f66           jointOf
+00007410: 6673 6574 733d 6578 7564 796e 2e56 6563  fsets=exudyn.Vec
+00007420: 746f 7233 444c 6973 7428 6a6f 696e 744f  tor3DList(jointO
+00007430: 6666 7365 7473 292c 200a 2020 2020 2020  ffsets), .      
+00007440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007460: 2020 2020 6c69 6e6b 496e 6572 7469 6173      linkInertias
+00007470: 434f 4d3d 6578 7564 796e 2e4d 6174 7269  COM=exudyn.Matri
+00007480: 7833 444c 6973 7428 6c69 6e6b 496e 6572  x3DList(linkIner
+00007490: 7469 6173 434f 4d29 2c20 0a20 2020 2020  tiasCOM), .     
+000074a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000074b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000074c0: 2020 2020 206c 696e 6b43 4f4d 733d 6578       linkCOMs=ex
+000074d0: 7564 796e 2e56 6563 746f 7233 444c 6973  udyn.Vector3DLis
+000074e0: 7428 6c69 6e6b 434f 4d73 292c 206c 696e  t(linkCOMs), lin
+000074f0: 6b4d 6173 7365 733d 6c69 6e6b 4d61 7373  kMasses=linkMass
+00007500: 6573 2c20 0a20 2020 2020 2020 2020 2020  es, .           
+00007510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007520: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00007530: 6173 654f 6666 7365 7420 3d20 6261 7365  aseOffset = base
+00007540: 4f66 6673 6574 2c20 6772 6176 6974 793d  Offset, gravity=
+00007550: 7365 6c66 2e67 7261 7669 7479 2c20 0a20  self.gravity, . 
+00007560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007580: 2020 2020 2020 2020 206a 6f69 6e74 466f           jointFo
+00007590: 7263 6556 6563 746f 723d 6a6f 696e 7446  rceVector=jointF
+000075a0: 6f72 6365 5665 6374 6f72 2c20 666f 7263  orceVector, forc
+000075b0: 6555 7365 7246 756e 6374 696f 6e3d 666f  eUserFunction=fo
+000075c0: 7263 6555 7365 7246 756e 6374 696f 6e2c  rceUserFunction,
+000075d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000075e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000075f0: 2020 2020 2020 2020 2020 206a 6f69 6e74             joint
+00007600: 506f 7369 7469 6f6e 4f66 6673 6574 5665  PositionOffsetVe
+00007610: 6374 6f72 203d 206a 6f69 6e74 506f 7369  ctor = jointPosi
+00007620: 7469 6f6e 4f66 6673 6574 5665 6374 6f72  tionOffsetVector
+00007630: 2c20 6a6f 696e 7450 436f 6e74 726f 6c56  , jointPControlV
+00007640: 6563 746f 7220 3d20 6a6f 696e 7450 436f  ector = jointPCo
+00007650: 6e74 726f 6c56 6563 746f 722c 0a20 2020  ntrolVector,.   
 00007660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007670: 2020 2020 2020 2020 2020 2020 6a6f 696e              join
-00007680: 744f 6666 7365 7473 3d65 7875 6479 6e2e  tOffsets=exudyn.
-00007690: 5665 6374 6f72 3344 4c69 7374 286a 6f69  Vector3DList(joi
-000076a0: 6e74 4f66 6673 6574 7329 2c20 0d0a 2020  ntOffsets), ..  
-000076b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000076c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000076d0: 2020 2020 2020 2020 6c69 6e6b 496e 6572          linkIner
-000076e0: 7469 6173 434f 4d3d 6578 7564 796e 2e4d  tiasCOM=exudyn.M
-000076f0: 6174 7269 7833 444c 6973 7428 6c69 6e6b  atrix3DList(link
-00007700: 496e 6572 7469 6173 434f 4d29 2c20 0d0a  InertiasCOM), ..
-00007710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007730: 2020 2020 2020 2020 2020 6c69 6e6b 434f            linkCO
-00007740: 4d73 3d65 7875 6479 6e2e 5665 6374 6f72  Ms=exudyn.Vector
-00007750: 3344 4c69 7374 286c 696e 6b43 4f4d 7329  3DList(linkCOMs)
-00007760: 2c20 6c69 6e6b 4d61 7373 6573 3d6c 696e  , linkMasses=lin
-00007770: 6b4d 6173 7365 732c 200d 0a20 2020 2020  kMasses, ..     
-00007780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000077a0: 2020 2020 2062 6173 654f 6666 7365 7420       baseOffset 
-000077b0: 3d20 6261 7365 4f66 6673 6574 2c20 6772  = baseOffset, gr
-000077c0: 6176 6974 793d 7365 6c66 2e67 7261 7669  avity=self.gravi
-000077d0: 7479 2c20 0d0a 2020 2020 2020 2020 2020  ty, ..          
-000077e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000077f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007800: 6a6f 696e 7446 6f72 6365 5665 6374 6f72  jointForceVector
-00007810: 3d6a 6f69 6e74 466f 7263 6556 6563 746f  =jointForceVecto
-00007820: 722c 2066 6f72 6365 5573 6572 4675 6e63  r, forceUserFunc
-00007830: 7469 6f6e 3d66 6f72 6365 5573 6572 4675  tion=forceUserFu
-00007840: 6e63 7469 6f6e 2c0d 0a20 2020 2020 2020  nction,..       
-00007850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007870: 2020 206a 6f69 6e74 506f 7369 7469 6f6e     jointPosition
-00007880: 4f66 6673 6574 5665 6374 6f72 203d 206a  OffsetVector = j
-00007890: 6f69 6e74 506f 7369 7469 6f6e 4f66 6673  ointPositionOffs
-000078a0: 6574 5665 6374 6f72 2c20 6a6f 696e 7450  etVector, jointP
-000078b0: 436f 6e74 726f 6c56 6563 746f 7220 3d20  ControlVector = 
-000078c0: 6a6f 696e 7450 436f 6e74 726f 6c56 6563  jointPControlVec
-000078d0: 746f 722c 0d0a 2020 2020 2020 2020 2020  tor,..          
-000078e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000078f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007900: 6a6f 696e 7456 656c 6f63 6974 794f 6666  jointVelocityOff
-00007910: 7365 7456 6563 746f 7220 3d20 6a6f 696e  setVector = join
-00007920: 7456 656c 6f63 6974 794f 6666 7365 7456  tVelocityOffsetV
-00007930: 6563 746f 722c 206a 6f69 6e74 4443 6f6e  ector, jointDCon
-00007940: 7472 6f6c 5665 6374 6f72 203d 206a 6f69  trolVector = joi
-00007950: 6e74 4443 6f6e 7472 6f6c 5665 6374 6f72  ntDControlVector
-00007960: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00007970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007980: 2020 2020 2020 2020 2020 2020 2076 6973               vis
-00007990: 7561 6c69 7a61 7469 6f6e 3d65 6969 2e56  ualization=eii.V
-000079a0: 4f62 6a65 6374 4b69 6e65 6d61 7469 6354  ObjectKinematicT
-000079b0: 7265 6528 6772 6170 6869 6373 4461 7461  ree(graphicsData
-000079c0: 4c69 7374 203d 2067 7261 7068 6963 7344  List = graphicsD
-000079d0: 6174 614c 6973 7429 2929 0d0a 0d0a 2020  ataList)))....  
-000079e0: 2020 2020 2020 2372 6574 7572 6e20 736f        #return so
-000079f0: 6d65 206e 6565 6465 6420 7661 7269 6162  me needed variab
-00007a00: 6c65 7320 666f 7220 6675 7274 6865 7220  les for further 
-00007a10: 7573 6520 2020 2020 2020 200d 0a20 2020  use        ..   
-00007a20: 2020 2020 2064 203d 207b 276e 6f64 6547       d = {'nodeG
-00007a30: 656e 6572 6963 273a 206e 4765 6e65 7269  eneric': nGeneri
-00007a40: 632c 2027 6f62 6a65 6374 4b69 6e65 6d61  c, 'objectKinema
-00007a50: 7469 6354 7265 6527 3a20 6f4b 542c 2027  ticTree': oKT, '
-00007a60: 6261 7365 4f62 6a65 6374 273a 2062 6173  baseObject': bas
-00007a70: 654f 626a 6563 742c 0d0a 2020 2020 2020  eObject,..      
-00007a80: 2020 2020 2020 207d 0d0a 2020 2020 2020         }..      
-00007a90: 2020 7265 7475 726e 2064 0d0a 0d0a 2020    return d....  
-00007aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007ab0: 2020 2020 0d0a 0d0a 2020 2020 2325 252b      ....    #%%+
-00007ac0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007ad0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007ae0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007af0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007b00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007b10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007b20: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00007b30: 2b2b 2b2b 2b2b 2b0d 0a20 2020 2023 2a2a  +++++++..    #**
-00007b40: 636c 6173 7346 756e 6374 696f 6e3a 2041  classFunction: A
-00007b50: 6464 2069 7465 6d73 2074 6f20 6578 6973  dd items to exis
-00007b60: 7469 6e67 206d 6273 2066 726f 6d20 7468  ting mbs from th
-00007b70: 6520 726f 626f 7420 7374 7275 6374 7572  e robot structur
-00007b80: 6520 696e 7369 6465 2074 6869 7320 726f  e inside this ro
-00007b90: 626f 7420 636c 6173 733b 2072 6f62 6f74  bot class; robot
-00007ba0: 2069 7320 6174 7461 6368 6564 2074 6f20   is attached to 
-00007bb0: 6261 7365 4d61 726b 6572 2028 6361 6e20  baseMarker (can 
-00007bc0: 6265 2067 726f 756e 6420 6f62 6a65 6374  be ground object
-00007bd0: 206f 7220 6d6f 7669 6e67 2f64 6566 6f72   or moving/defor
-00007be0: 6d61 626c 6520 626f 6479 293b 0d0a 2020  mable body);..  
-00007bf0: 2020 2320 2020 2020 2020 2020 2020 2020    #             
-00007c00: 2020 2020 5468 6520 2873 6572 6961 6c29      The (serial)
-00007c10: 2072 6f62 6f74 2069 7320 6275 696c 7420   robot is built 
-00007c20: 6173 2072 6967 6964 2062 6f64 6965 7320  as rigid bodies 
-00007c30: 2863 6f6e 7461 696e 696e 6720 7269 6769  (containing rigi
-00007c40: 6420 626f 6479 206e 6f64 6573 292c 2077  d body nodes), w
-00007c50: 6865 7265 2062 6f64 6965 7320 7265 7072  here bodies repr
-00007c60: 6573 656e 7420 7468 6520 6c69 6e6b 7320  esent the links 
-00007c70: 7768 6963 6820 6172 6520 636f 6e6e 6563  which are connec
-00007c80: 7465 6420 6279 206a 6f69 6e74 733b 200d  ted by joints; .
-00007c90: 0a20 2020 2023 2020 2020 2020 2020 2020  .    #          
-00007ca0: 2020 2020 2020 2041 6464 206f 7074 696f         Add optio
-00007cb0: 6e61 6c20 6a6f 696e 7453 7072 696e 6744  nal jointSpringD
-00007cc0: 616d 7065 7255 7365 7246 756e 6374 696f  amperUserFunctio
-00007cd0: 6e4c 6973 7420 666f 7220 696e 6469 7669  nList for indivi
-00007ce0: 6475 616c 2063 6f6e 7472 6f6c 206f 6620  dual control of 
-00007cf0: 6a6f 696e 7473 3b20 6f74 6865 7277 6973  joints; otherwis
-00007d00: 6520 7573 6520 5044 636f 6e74 726f 6c20  e use PDcontrol 
-00007d10: 696e 2052 6f62 6f74 4c69 6e6b 2073 7472  in RobotLink str
-00007d20: 7563 7475 7265 3b20 6164 6469 7469 6f6e  ucture; addition
-00007d30: 616c 206a 6f69 6e74 2074 6f72 7175 6573  al joint torques
-00007d40: 2f66 6f72 6365 7320 6361 6e20 6265 2061  /forces can be a
-00007d50: 6464 6564 2076 6961 2073 7072 696e 6720  dded via spring 
-00007d60: 6461 6d70 6572 2c20 7573 696e 6720 6d62  damper, using mb
-00007d70: 732e 5365 744f 626a 6563 7450 6172 616d  s.SetObjectParam
-00007d80: 6574 6572 282e 2e2e 2920 6675 6e63 7469  eter(...) functi
-00007d90: 6f6e 3b0d 0a20 2020 2023 2020 2020 2020  on;..    #      
-00007da0: 2020 2020 2020 2020 2020 2053 6565 2073             See s
-00007db0: 6576 6572 616c 2050 7974 686f 6e20 6578  everal Python ex
-00007dc0: 616d 706c 6573 2c20 652e 672e 2c20 5c74  amples, e.g., \t
-00007dd0: 6578 7474 747b 7365 7269 616c 526f 626f  exttt{serialRobo
-00007de0: 7454 6573 7454 5344 2e70 797d 2c20 696e  tTestTSD.py}, in
-00007df0: 2045 7861 6d70 6c65 7320 6f72 2054 6573   Examples or Tes
-00007e00: 744d 6f64 656c 733b 0d0a 2020 2020 2320  tModels;..    # 
-00007e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007e20: 466f 7220 6d6f 7265 2065 6666 6963 6965  For more efficie
-00007e30: 6e74 206d 6f64 656c 732c 2075 7365 2043  nt models, use C
-00007e40: 7265 6174 654b 696e 656d 6174 6963 5472  reateKinematicTr
-00007e50: 6565 282e 2e2e 2920 6675 6e63 7469 6f6e  ee(...) function
-00007e60: 210d 0a20 2020 2023 2a2a 696e 7075 743a  !..    #**input:
-00007e70: 200d 0a20 2020 2023 2020 206d 6273 3a20   ..    #   mbs: 
-00007e80: 7468 6520 6d75 6c74 6962 6f64 7920 7379  the multibody sy
-00007e90: 7374 656d 2c20 7768 6963 6820 7769 6c6c  stem, which will
-00007ea0: 2062 6520 6578 7465 6e64 6564 0d0a 2020   be extended..  
-00007eb0: 2020 2320 2020 6261 7365 4d61 726b 6572    #   baseMarker
-00007ec0: 3a20 6120 7269 6769 6420 626f 6479 206d  : a rigid body m
-00007ed0: 6172 6b65 722c 2061 7420 7768 6963 6820  arker, at which 
-00007ee0: 7468 6520 726f 626f 7420 7769 6c6c 2062  the robot will b
-00007ef0: 6520 706c 6163 6564 2028 7573 7561 6c6c  e placed (usuall
-00007f00: 7920 6772 6f75 6e64 293b 206e 6f74 6520  y ground); note 
-00007f10: 7468 6174 2074 6865 206c 6f63 616c 2063  that the local c
-00007f20: 6f6f 7264 696e 6174 6520 7379 7374 656d  oordinate system
-00007f30: 206f 6620 7468 6520 6261 7365 206d 7573   of the base mus
-00007f40: 7420 6265 2069 6e20 6163 636f 7264 616e  t be in accordan
-00007f50: 6365 2077 6974 6820 7468 6520 4448 2d70  ce with the DH-p
-00007f60: 6172 616d 6574 6572 732c 2069 2e65 2e2c  arameters, i.e.,
-00007f70: 2074 6865 207a 2d61 7869 7320 6d75 7374   the z-axis must
-00007f80: 2062 6520 7468 6520 6669 7273 7420 726f   be the first ro
-00007f90: 7461 7469 6f6e 2061 7869 732e 2046 6f72  tation axis. For
-00007fa0: 2063 6f72 7265 6374 696f 6e20 6f66 2074   correction of t
-00007fb0: 6865 2062 6173 6520 636f 6f72 6469 6e61  he base coordina
-00007fc0: 7465 2073 7973 7465 6d2c 2075 7365 2072  te system, use r
-00007fd0: 6f74 6174 696f 6e4d 6172 6b65 7242 6173  otationMarkerBas
-00007fe0: 650d 0a20 2020 2023 2020 206a 6f69 6e74  e..    #   joint
-00007ff0: 5370 7269 6e67 4461 6d70 6572 5573 6572  SpringDamperUser
-00008000: 4675 6e63 7469 6f6e 4c69 7374 3a20 4e4f  FunctionList: NO
-00008010: 5420 494d 504c 454d 454e 5445 4420 7965  T IMPLEMENTED ye
-00008020: 743a 206a 6f69 6e74 5370 7269 6e67 4461  t: jointSpringDa
-00008030: 6d70 6572 5573 6572 4675 6e63 7469 6f6e  mperUserFunction
-00008040: 4c69 7374 6120 6c69 7374 206f 6620 7573  Lista list of us
-00008050: 6572 2066 756e 6374 696f 6e73 2066 6f72  er functions for
-00008060: 2061 6374 7561 7469 6f6e 206f 6620 6a6f   actuation of jo
-00008070: 696e 7473 2077 6974 6820 6d6f 7265 2065  ints with more e
-00008080: 6666 6963 6965 6e74 2073 7072 696e 672d  fficient spring-
-00008090: 6461 6d70 6572 2062 6173 6564 2063 6f6e  damper based con
-000080a0: 6e65 6374 6f72 2028 7370 7269 6e67 2d64  nector (spring-d
-000080b0: 616d 7065 7220 6469 7265 6374 6c79 2065  amper directly e
-000080c0: 6d75 6c61 7465 7320 5044 2d63 6f6e 7472  mulates PD-contr
-000080d0: 6f6c 6c65 7229 3b20 7573 6573 2074 6f72  oller); uses tor
-000080e0: 7369 6f6e 616c 2073 7072 696e 6720 6461  sional spring da
-000080f0: 6d70 6572 2066 6f72 2072 6576 6f6c 7574  mper for revolut
-00008100: 6520 6a6f 696e 7473 2061 6e64 206c 696e  e joints and lin
-00008110: 6561 7220 7370 7269 6e67 2064 616d 7065  ear spring dampe
-00008120: 7220 666f 7220 7072 6973 6d61 7469 6320  r for prismatic 
-00008130: 6a6f 696e 7473 3b20 6361 6e20 6265 2065  joints; can be e
-00008140: 6d70 7479 206c 6973 7420 286e 6f20 7370  mpty list (no sp
-00008150: 7269 6e67 2064 616d 7065 7273 293b 2069  ring dampers); i
-00008160: 6620 656e 7472 7920 6f66 206c 6973 7420  f entry of list 
-00008170: 6973 2030 2c20 6e6f 2075 7365 7220 6675  is 0, no user fu
-00008180: 6e63 7469 6f6e 2069 7320 6372 6561 7465  nction is create
-00008190: 642c 206a 7573 7420 7075 7265 2073 7072  d, just pure spr
-000081a0: 696e 6720 6461 6d70 6572 3b20 7061 7261  ing damper; para
-000081b0: 6d65 7465 7273 2061 7265 2074 616b 656e  meters are taken
-000081c0: 2066 726f 6d20 526f 626f 744c 696e 6b20   from RobotLink 
-000081d0: 5044 636f 6e74 726f 6c20 7374 7275 6374  PDcontrol struct
-000081e0: 7572 652c 2077 6869 6368 204d 5553 5420  ure, which MUST 
-000081f0: 6265 2064 6566 696e 6564 2075 7369 6e67  be defined using
-00008200: 2053 6574 5044 636f 6e74 726f 6c28 2e2e   SetPDcontrol(..
-00008210: 2e29 2069 6e20 526f 626f 744c 696e 6b0d  .) in RobotLink.
-00008220: 0a20 2020 2023 2020 206a 6f69 6e74 4c6f  .    #   jointLo
-00008230: 6164 5573 6572 4675 6e63 7469 6f6e 4c69  adUserFunctionLi
-00008240: 7374 3a20 4445 5052 4543 4154 4544 3a20  st: DEPRECATED: 
-00008250: 6120 6c69 7374 206f 6620 7573 6572 2066  a list of user f
-00008260: 756e 6374 696f 6e73 2066 6f72 2061 6374  unctions for act
-00008270: 7561 7469 6f6e 206f 6620 6a6f 696e 7473  uation of joints
-00008280: 2061 6363 6f72 6469 6e67 2074 6f20 6120   according to a 
-00008290: 4c6f 6164 546f 7271 7565 5665 6374 6f72  LoadTorqueVector
-000082a0: 2075 7365 7246 756e 6374 696f 6e2c 2073   userFunction, s
-000082b0: 6565 2073 6572 6961 6c52 6f62 6f74 5465  ee serialRobotTe
-000082c0: 7374 2e70 7920 6173 2061 6e20 6578 616d  st.py as an exam
-000082d0: 706c 653b 2063 616e 2062 6520 656d 7074  ple; can be empt
-000082e0: 7920 6c69 7374 0d0a 2020 2020 2320 2020  y list..    #   
-000082f0: 6372 6561 7465 4a6f 696e 7454 6f72 7175  createJointTorqu
-00008300: 654c 6f61 6473 3a20 4445 5052 4543 4154  eLoads: DEPRECAT
-00008310: 4544 3a20 6966 2054 7275 652c 2069 6e64  ED: if True, ind
-00008320: 6570 656e 6465 6e74 6c79 206f 6620 6a6f  ependently of jo
-00008330: 696e 744c 6f61 6455 7365 7246 756e 6374  intLoadUserFunct
-00008340: 696f 6e4c 6973 742c 206a 6f69 6e74 206c  ionList, joint l
-00008350: 6f61 6473 2061 7265 2063 7265 6174 6564  oads are created
-00008360: 3b20 7468 6520 6c6f 6164 206e 756d 6265  ; the load numbe
-00008370: 7273 2061 7265 2073 746f 7265 6420 696e  rs are stored in
-00008380: 206c 6973 7473 206a 6f69 6e74 546f 7271   lists jointTorq
-00008390: 7565 304c 6973 742f 206a 6f69 6e74 546f  ue0List/ jointTo
-000083a0: 7271 7565 314c 6973 743b 2074 6865 206c  rque1List; the l
-000083b0: 6f61 6473 2063 6f6e 7461 696e 207a 6572  oads contain zer
-000083c0: 6f20 746f 7271 7565 7320 616e 6420 6e65  o torques and ne
-000083d0: 6564 2074 6f20 6265 2075 7064 6174 6564  ed to be updated
-000083e0: 2069 6e20 6576 6572 7920 636f 6d70 7574   in every comput
-000083f0: 6174 696f 6e20 7374 6570 2c20 652e 672e  ation step, e.g.
-00008400: 2c20 7573 696e 6720 6120 7072 6553 7465  , using a preSte
-00008410: 7055 7365 7246 756e 6374 696f 6e3b 2075  pUserFunction; u
-00008420: 6e69 7454 6f72 7175 6530 4c69 7374 2f20  nitTorque0List/ 
-00008430: 756e 6974 546f 7271 7565 314c 6973 7420  unitTorque1List 
-00008440: 636f 6e74 6169 6e20 7468 6520 756e 6974  contain the unit
-00008450: 2074 6f72 7175 6520 7665 6374 6f72 2066   torque vector f
-00008460: 6f72 2074 6865 2061 6363 6f72 6469 6e67  or the according
-00008470: 2062 6f64 7928 6c69 6e6b 2920 7768 6963   body(link) whic
-00008480: 6820 6e65 6564 7320 746f 2062 6520 6170  h needs to be ap
-00008490: 706c 6965 6420 6f6e 2062 6f74 6820 626f  plied on both bo
-000084a0: 6469 6573 2061 7474 6163 6865 6420 746f  dies attached to
-000084b0: 2074 6865 206a 6f69 6e74 0d0a 2020 2020   the joint..    
-000084c0: 2320 2020 726f 7461 7469 6f6e 4d61 726b  #   rotationMark
-000084d0: 6572 4261 7365 3a20 6164 6420 6120 6e75  erBase: add a nu
-000084e0: 6d70 7920 3378 3320 6d61 7472 6978 2066  mpy 3x3 matrix f
-000084f0: 6f72 2072 6f74 6174 696f 6e20 6f66 2074  or rotation of t
-00008500: 6865 2062 6173 652c 2069 6e20 6f72 6465  he base, in orde
-00008510: 7220 7468 6174 2074 6865 2072 6f62 6f74  r that the robot
-00008520: 2063 616e 2062 6520 6174 7461 6368 6564   can be attached
-00008530: 2074 6f20 616e 7920 726f 7461 7465 6420   to any rotated 
-00008540: 6261 7365 206d 6172 6b65 723b 2074 6865  base marker; the
-00008550: 2072 6f74 6174 696f 6e4d 6172 6b65 7242   rotationMarkerB
-00008560: 6173 6520 6973 2061 6363 6f72 6469 6e67  ase is according
-00008570: 2074 6f20 7468 6520 6465 6669 6e69 7469   to the definiti
-00008580: 6f6e 2069 6e20 4765 6e65 7269 634a 6f69  on in GenericJoi
-00008590: 6e74 3b20 6e6f 7465 2c20 7468 6174 2066  nt; note, that f
-000085a0: 6f72 206d 6f76 696e 6720 6261 7365 2c20  or moving base, 
-000085b0: 7468 6520 7374 6174 6963 2063 6f6d 7065  the static compe
-000085c0: 6e73 6174 696f 6e20 646f 6573 206e 6f74  nsation does not
-000085d0: 2077 6f72 6b20 2862 6173 6520 726f 7461   work (base rota
-000085e0: 7469 6f6e 206d 7573 7420 6265 2075 7064  tion must be upd
-000085f0: 6174 6564 290d 0a20 2020 2023 2020 2072  ated)..    #   r
-00008600: 6967 6964 426f 6479 4e6f 6465 5479 7065  igidBodyNodeType
-00008610: 3a20 7370 6563 6966 7920 6e6f 6465 2074  : specify node t
-00008620: 7970 6520 6f66 2072 6967 6964 2062 6f64  ype of rigid bod
-00008630: 7920 6e6f 6465 2c20 652e 672e 2c20 6578  y node, e.g., ex
-00008640: 7564 796e 2e4e 6f64 6554 7970 652e 526f  udyn.NodeType.Ro
-00008650: 7461 7469 6f6e 4575 6c65 7250 6172 616d  tationEulerParam
-00008660: 6574 6572 732c 2065 7463 2e0d 0a20 2020  eters, etc...   
-00008670: 2023 2a2a 6f75 7470 7574 3a20 7468 6520   #**output: the 
-00008680: 6675 6e63 7469 6f6e 2072 6574 7572 6e73  function returns
-00008690: 2061 2064 6963 7469 6f6e 6172 7920 636f   a dictionary co
-000086a0: 6e74 6169 6e69 6e67 2070 6572 206c 696e  ntaining per lin
-000086b0: 6b20 6e6f 6465 7320 616e 6420 6f62 6a65  k nodes and obje
-000086c0: 6374 2028 626f 6479 2920 6e75 6d62 6572  ct (body) number
-000086d0: 732c 2027 6e6f 6465 4c69 7374 272c 2027  s, 'nodeList', '
-000086e0: 626f 6479 4c69 7374 272c 2074 6865 206f  bodyList', the o
-000086f0: 626a 6563 7420 6e75 6d62 6572 7320 666f  bject numbers fo
-00008700: 7220 6a6f 696e 7473 2c20 276a 6f69 6e74  r joints, 'joint
-00008710: 4c69 7374 272c 206c 6973 7420 6f66 206c  List', list of l
-00008720: 6f61 6420 6e75 6d62 6572 7320 666f 7220  oad numbers for 
-00008730: 6a6f 696e 7420 746f 7271 7565 7320 286a  joint torques (j
-00008740: 6f69 6e74 546f 7271 7565 304c 6973 742c  ointTorque0List,
-00008750: 206a 6f69 6e74 546f 7271 7565 314c 6973   jointTorque1Lis
-00008760: 7429 3b20 756e 6974 2074 6f72 7175 6520  t); unit torque 
-00008770: 7665 6374 6f72 7320 696e 206c 6f63 616c  vectors in local
-00008780: 2063 6f6f 7264 696e 6174 6573 206f 6620   coordinates of 
-00008790: 7468 6520 626f 6469 6573 2074 6f20 7768  the bodies to wh
-000087a0: 6963 6820 7468 6520 746f 7271 7565 7320  ich the torques 
-000087b0: 6172 6520 6170 706c 6965 6420 2875 6e69  are applied (uni
-000087c0: 7454 6f72 7175 6530 4c69 7374 2c20 756e  tTorque0List, un
-000087d0: 6974 546f 7271 7565 314c 6973 7429 3b20  itTorque1List); 
-000087e0: 7370 7269 6e67 4461 6d70 6572 4c69 7374  springDamperList
-000087f0: 2063 6f6e 7461 696e 7320 7468 6520 7370   contains the sp
-00008800: 7269 6e67 2064 616d 7065 7273 2069 6620  ring dampers if 
-00008810: 6465 6669 6e65 6420 6279 2050 4463 6f6e  defined by PDcon
-00008820: 7472 6f6c 206f 6620 6c69 6e6b 730d 0a20  trol of links.. 
-00008830: 2020 2064 6566 2043 7265 6174 6552 6564     def CreateRed
-00008840: 756e 6461 6e74 436f 6f72 6469 6e61 7465  undantCoordinate
-00008850: 4d42 5328 7365 6c66 2c20 6d62 732c 2062  MBS(self, mbs, b
-00008860: 6173 654d 6172 6b65 722c 206a 6f69 6e74  aseMarker, joint
-00008870: 5370 7269 6e67 4461 6d70 6572 5573 6572  SpringDamperUser
-00008880: 4675 6e63 7469 6f6e 4c69 7374 3d20 5b5d  FunctionList= []
-00008890: 2c20 0d0a 2020 2020 2020 2020 2020 2020  , ..            
-000088a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000088b0: 2020 2020 2020 2020 206a 6f69 6e74 4c6f           jointLo
-000088c0: 6164 5573 6572 4675 6e63 7469 6f6e 4c69  adUserFunctionLi
-000088d0: 7374 3d5b 5d2c 200d 0a20 2020 2020 2020  st=[], ..       
-000088e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000088f0: 2020 2020 2020 2020 2020 2020 2020 6372                cr
-00008900: 6561 7465 4a6f 696e 7454 6f72 7175 654c  eateJointTorqueL
-00008910: 6f61 6473 3d54 7275 652c 2072 6f74 6174  oads=True, rotat
-00008920: 696f 6e4d 6172 6b65 7242 6173 653d 4e6f  ionMarkerBase=No
-00008930: 6e65 2c0d 0a20 2020 2020 2020 2020 2020  ne,..           
-00008940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008950: 2020 2020 2020 2020 2020 7269 6769 6442            rigidB
-00008960: 6f64 794e 6f64 6554 7970 653d 6578 7564  odyNodeType=exud
-00008970: 796e 2e4e 6f64 6554 7970 652e 526f 7461  yn.NodeType.Rota
-00008980: 7469 6f6e 4575 6c65 7250 6172 616d 6574  tionEulerParamet
-00008990: 6572 7329 3a20 0d0a 2020 2020 2020 2020  ers): ..        
-000089a0: 2362 7569 6c64 2072 6f62 6f74 206d 6f64  #build robot mod
-000089b0: 656c 3a0d 0a20 2020 2020 2020 206e 6f64  el:..        nod
-000089c0: 654c 6973 7420 3d20 5b5d 2020 2020 2020  eList = []      
-000089d0: 2020 2020 2023 6e6f 6465 206e 756d 6265       #node numbe
-000089e0: 7220 6f72 2072 6967 6964 206e 6f64 6520  r or rigid node 
-000089f0: 666f 7220 6c69 6e6b 0d0a 2020 2020 2020  for link..      
-00008a00: 2020 626f 6479 4c69 7374 203d 205b 5d20    bodyList = [] 
-00008a10: 2020 2020 2020 2020 2020 2362 6f64 7920            #body 
-00008a20: 6e75 6d62 6572 206f 7220 7269 6769 6420  number or rigid 
-00008a30: 626f 6479 2066 6f72 206c 696e 6b0d 0a20  body for link.. 
-00008a40: 2020 2020 2020 206a 6f69 6e74 4c69 7374         jointList
-00008a50: 203d 205b 5d20 2020 2020 2020 2020 2023   = []          #
-00008a60: 6a6f 696e 7420 7768 6963 6820 6c69 6e6b  joint which link
-00008a70: 7320 746f 2070 7265 7669 6f75 7320 6c69  s to previous li
-00008a80: 6e6b 206f 7220 6261 7365 0d0a 2020 2020  nk or base..    
-00008a90: 2020 2020 6d61 726b 6572 4c69 7374 3020      markerList0 
-00008aa0: 3d20 5b5d 2020 2020 2020 2020 2363 6f6e  = []        #con
-00008ab0: 7461 696e 7320 6e20 6d61 726b 6572 206e  tains n marker n
-00008ac0: 756d 6265 7273 2070 6572 206c 696e 6b20  umbers per link 
-00008ad0: 283d 626f 6479 2920 7768 6963 6820 636f  (=body) which co
-00008ae0: 6e6e 6563 7420 746f 2070 7265 7669 6f75  nnect to previou
-00008af0: 732f 6c65 6674 206c 696e 6b0d 0a20 2020  s/left link..   
-00008b00: 2020 2020 206d 6172 6b65 724c 6973 7431       markerList1
-00008b10: 203d 205b 5d20 2020 2020 2020 2023 636f   = []        #co
-00008b20: 6e74 6169 6e73 206e 206d 6172 6b65 7220  ntains n marker 
-00008b30: 6e75 6d62 6572 7320 7065 7220 6c69 6e6b  numbers per link
-00008b40: 2028 3d62 6f64 7929 2077 6869 6368 2063   (=body) which c
-00008b50: 6f6e 6e65 6374 2074 6f20 6e65 7874 2f72  onnect to next/r
-00008b60: 6967 6874 206c 696e 6b0d 0a20 2020 2020  ight link..     
-00008b70: 2020 206a 6f69 6e74 546f 7271 7565 304c     jointTorque0L
-00008b80: 6973 7420 3d20 5b5d 2020 2023 6c6f 6164  ist = []   #load
-00008b90: 206e 756d 6265 7220 6f66 206a 6f69 6e74   number of joint
-00008ba0: 2074 6f72 7175 6520 6174 2070 7265 7669   torque at previ
-00008bb0: 6f75 732f 6c65 6674 206c 696e 6b20 286e  ous/left link (n
-00008bc0: 6567 6174 6976 6529 3b20 0d0a 2020 2020  egative); ..    
-00008bd0: 2020 2020 6a6f 696e 7454 6f72 7175 6531      jointTorque1
-00008be0: 4c69 7374 203d 205b 5d20 2020 236c 6f61  List = []   #loa
-00008bf0: 6420 6e75 6d62 6572 206f 6620 6a6f 696e  d number of join
-00008c00: 7420 746f 7271 7565 2061 7420 6e65 7874  t torque at next
-00008c10: 2f72 6967 6874 206c 696e 6b20 2870 6f73  /right link (pos
-00008c20: 6974 6976 6529 0d0a 2020 2020 2020 2020  itive)..        
-00008c30: 756e 6974 546f 7271 7565 304c 6973 7420  unitTorque0List 
-00008c40: 3d20 5b5d 2020 2020 2363 6f6e 7461 696e  = []    #contain
-00008c50: 7320 756e 6974 2074 6f72 7175 6530 2028  s unit torque0 (
-00008c60: 7072 6576 696f 7573 2f6c 6566 7420 6c69  previous/left li
-00008c70: 6e6b 2920 666f 7220 6a6f 696e 7420 692c  nk) for joint i,
-00008c80: 2073 686f 756c 6420 6265 206d 756c 7469   should be multi
-00008c90: 706c 6965 6420 7769 7468 2061 6363 6f72  plied with accor
-00008ca0: 6469 6e67 2066 6163 746f 7220 746f 2072  ding factor to r
-00008cb0: 6570 7265 7365 6e74 206a 6f69 6e74 2074  epresent joint t
-00008cc0: 6f72 7175 650d 0a20 2020 2020 2020 2075  orque..        u
-00008cd0: 6e69 7454 6f72 7175 6531 4c69 7374 203d  nitTorque1List =
-00008ce0: 205b 5d20 2020 2023 636f 6e74 6169 6e73   []    #contains
-00008cf0: 2075 6e69 7420 746f 7271 7565 3120 286e   unit torque1 (n
-00008d00: 6578 742f 7269 6768 7420 6c69 6e6b 2920  ext/right link) 
-00008d10: 666f 7220 6a6f 696e 7420 692c 2073 686f  for joint i, sho
-00008d20: 756c 6420 6265 206d 756c 7469 706c 6965  uld be multiplie
-00008d30: 6420 7769 7468 2061 6363 6f72 6469 6e67  d with according
-00008d40: 2066 6163 746f 7220 746f 2072 6570 7265   factor to repre
-00008d50: 7365 6e74 206a 6f69 6e74 2074 6f72 7175  sent joint torqu
-00008d60: 650d 0a20 2020 2020 2020 2073 7072 696e  e..        sprin
-00008d70: 6744 616d 7065 724c 6973 7420 3d20 5b5d  gDamperList = []
-00008d80: 2020 2023 636f 6e74 6169 6e73 2074 6f72     #contains tor
-00008d90: 7369 6f6e 616c 206f 7220 6c69 6e65 6172  sional or linear
-00008da0: 2073 7072 696e 6720 6461 6d70 6572 7320   spring dampers 
-00008db0: 666f 7220 636f 6e74 726f 6c20 6f66 206a  for control of j
-00008dc0: 6f69 6e74 2061 7865 730d 0a20 2020 2020  oint axes..     
-00008dd0: 2020 200d 0a20 2020 2020 2020 2048 546c     ..        HTl
-00008de0: 6973 7420 3d20 5b5d 2023 6c69 7374 206f  ist = [] #list o
-00008df0: 6620 686f 6d6f 6765 6e65 6f75 7320 7472  f homogeneous tr
-00008e00: 616e 7366 6f72 6d61 7469 6f6e 7320 666f  ansformations fo
-00008e10: 7220 6c69 6e6b 7320 7374 6f72 6564 2028  r links stored (
-00008e20: 666f 7220 7061 7265 6e74 206c 696e 6b20  for parent link 
-00008e30: 7265 6c61 7469 6f6e 2069 6e20 7472 6565  relation in tree
-00008e40: 290d 0a0d 0a20 2020 2020 2020 2023 6465  )....        #de
-00008e50: 6c65 7465 3a20 6c61 7374 4d61 726b 6572  lete: lastMarker
-00008e60: 203d 2062 6173 654d 6172 6b65 720d 0a20   = baseMarker.. 
-00008e70: 2020 2020 2020 206c 6173 744d 6172 6b65         lastMarke
-00008e80: 7252 6f74 6174 696f 6e20 3d20 6e70 2e69  rRotation = np.i
-00008e90: 6465 6e74 6974 7928 3329 2023 6261 7365  dentity(3) #base
-00008ea0: 2072 6f74 6174 696f 6e20 696e 636c 7564   rotation includ
-00008eb0: 6564 2069 6e20 6d61 726b 6572 0d0a 2020  ed in marker..  
-00008ec0: 2020 2020 2020 6966 2072 6f74 6174 696f        if rotatio
-00008ed0: 6e4d 6172 6b65 7242 6173 6520 213d 204e  nMarkerBase != N
-00008ee0: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-00008ef0: 2020 6c61 7374 4d61 726b 6572 526f 7461    lastMarkerRota
-00008f00: 7469 6f6e 203d 2072 6f74 6174 696f 6e4d  tion = rotationM
-00008f10: 6172 6b65 7242 6173 650d 0a20 2020 2020  arkerBase..     
-00008f20: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00008f30: 2071 5265 6620 3d20 7365 6c66 2e72 6566   qRef = self.ref
-00008f40: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
-00008f50: 696f 6e0d 0a20 2020 2020 2020 200d 0a20  ion..        .. 
-00008f60: 2020 2020 2020 2062 6173 654f 626a 6563         baseObjec
-00008f70: 7420 3d20 2d31 2023 6966 2069 7420 646f  t = -1 #if it do
-00008f80: 6573 206e 6f74 2065 7869 7374 0d0a 2020  es not exist..  
-00008f90: 2020 2020 2020 6966 2073 656c 662e 6261        if self.ba
-00008fa0: 7365 2e76 6973 7561 6c69 7a61 7469 6f6e  se.visualization
-00008fb0: 2e67 7261 7068 6963 7344 6174 6120 213d  .graphicsData !=
-00008fc0: 205b 5d3a 0d0a 2020 2020 2020 2020 2020   []:..          
-00008fd0: 2020 2361 6464 2061 2067 726f 756e 6420    #add a ground 
-00008fe0: 6f62 6a65 6374 2061 7420 6261 7365 2070  object at base p
-00008ff0: 6f73 6974 696f 6e0d 0a20 2020 2020 2020  osition..       
-00009000: 2020 2020 2067 7261 7068 6963 7344 6174       graphicsDat
-00009010: 6142 6173 6520 3d20 5b5d 0d0a 2020 2020  aBase = []..    
-00009020: 2020 2020 2020 2020 704f 6666 203d 2065          pOff = e
-00009030: 7262 2e48 5432 7472 616e 736c 6174 696f  rb.HT2translatio
-00009040: 6e28 7365 6c66 2e62 6173 652e 4854 290d  n(self.base.HT).
-00009050: 0a20 2020 2020 2020 2020 2020 2041 6f66  .            Aof
-00009060: 6620 3d20 6572 622e 4854 3272 6f74 6174  f = erb.HT2rotat
-00009070: 696f 6e4d 6174 7269 7828 7365 6c66 2e62  ionMatrix(self.b
-00009080: 6173 652e 4854 290d 0a20 2020 2020 2020  ase.HT)..       
-00009090: 2020 2020 2066 6f72 2064 6174 6120 696e       for data in
-000090a0: 2073 656c 662e 6261 7365 2e76 6973 7561   self.base.visua
-000090b0: 6c69 7a61 7469 6f6e 2e67 7261 7068 6963  lization.graphic
-000090c0: 7344 6174 613a 0d0a 2020 2020 2020 2020  sData:..        
-000090d0: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
-000090e0: 4461 7461 4261 7365 202b 3d20 5b65 6764  DataBase += [egd
-000090f0: 2e4d 6f76 6547 7261 7068 6963 7344 6174  .MoveGraphicsDat
-00009100: 6128 6461 7461 2c20 5b30 2c30 2c30 5d2c  a(data, [0,0,0],
-00009110: 2041 6f66 6629 5d20 236f 6e6c 7920 726f   Aoff)] #only ro
-00009120: 7461 7465 642c 2074 7261 6e73 6c61 7469  tated, translati
-00009130: 6f6e 2069 7320 696e 2067 726f 756e 640d  on is in ground.
-00009140: 0a0d 0a20 2020 2020 2020 2020 2020 2062  ...            b
-00009150: 6173 654f 626a 6563 7420 3d20 6d62 732e  aseObject = mbs.
-00009160: 4164 644f 626a 6563 7428 6569 692e 4f62  AddObject(eii.Ob
-00009170: 6a65 6374 4772 6f75 6e64 2872 6566 6572  jectGround(refer
-00009180: 656e 6365 506f 7369 7469 6f6e 3d70 4f66  encePosition=pOf
-00009190: 662c 200d 0a20 2020 2020 2020 2020 2020  f, ..           
-000091a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000091b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000091c0: 2020 2020 2020 2020 2076 6973 7561 6c69           visuali
-000091d0: 7a61 7469 6f6e 3d65 6969 2e56 4f62 6a65  zation=eii.VObje
-000091e0: 6374 4772 6f75 6e64 2867 7261 7068 6963  ctGround(graphic
-000091f0: 7344 6174 613d 6772 6170 6869 6373 4461  sData=graphicsDa
-00009200: 7461 4261 7365 2929 290d 0a0d 0a20 2020  taBase)))....   
-00009210: 2020 2020 2023 6372 6561 7465 206c 6973       #create lis
-00009220: 7420 6f66 2069 6e64 6963 6573 2074 6f20  t of indices to 
-00009230: 6e65 7874 206c 696e 6b73 0d0a 2020 2020  next links..    
-00009240: 2020 2020 6e65 7874 4c69 6e6b 7320 3d20      nextLinks = 
-00009250: 5b4e 6f6e 655d 2a73 656c 662e 4e75 6d62  [None]*self.Numb
-00009260: 6572 4f66 4c69 6e6b 7328 290d 0a20 2020  erOfLinks()..   
-00009270: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
-00009280: 6e67 6528 7365 6c66 2e4e 756d 6265 724f  nge(self.NumberO
-00009290: 664c 696e 6b73 2829 293a 0d0a 2020 2020  fLinks()):..    
-000092a0: 2020 2020 2020 2020 6e65 7874 4c69 6e6b          nextLink
-000092b0: 735b 695d 203d 205b 5d0d 0a20 2020 2020  s[i] = []..     
-000092c0: 2020 2020 2020 206c 696e 6b20 3d20 7365         link = se
-000092d0: 6c66 2e6c 696e 6b73 5b69 5d0d 0a20 2020  lf.links[i]..   
-000092e0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-000092f0: 2e47 6574 5061 7265 6e74 496e 6465 7828  .GetParentIndex(
-00009300: 6929 2021 3d20 2d31 3a0d 0a20 2020 2020  i) != -1:..     
-00009310: 2020 2020 2020 2020 2020 6e65 7874 4c69            nextLi
-00009320: 6e6b 735b 7365 6c66 2e47 6574 5061 7265  nks[self.GetPare
-00009330: 6e74 496e 6465 7828 6929 5d20 2b3d 205b  ntIndex(i)] += [
-00009340: 695d 0d0a 2020 2020 2020 2020 2020 2020  i]..            
-00009350: 2020 2020 0d0a 2020 2020 2020 2020 2363      ..        #c
-00009360: 7265 6174 6520 726f 626f 7420 6e6f 6465  reate robot node
-00009370: 7320 616e 6420 626f 6469 6573 3a0d 0a20  s and bodies:.. 
-00009380: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
-00009390: 7261 6e67 6528 6c65 6e28 7365 6c66 2e6c  range(len(self.l
-000093a0: 696e 6b73 2929 3a0d 0a20 2020 2020 2020  inks)):..       
-000093b0: 2020 2020 206c 696e 6b20 3d20 7365 6c66       link = self
-000093c0: 2e6c 696e 6b73 5b69 5d0d 0a20 2020 2020  .links[i]..     
-000093d0: 2020 2020 2020 2069 6620 6c69 6e6b 2e6a         if link.j
-000093e0: 6f69 6e74 5479 7065 206e 6f74 2069 6e20  ointType not in 
-000093f0: 6469 6374 4a6f 696e 7454 7970 6532 4178  dictJointType2Ax
-00009400: 6973 3a0d 0a20 2020 2020 2020 2020 2020  is:..           
-00009410: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00009420: 4572 726f 7228 2743 7265 6174 6552 6564  Error('CreateRed
-00009430: 756e 6461 6e74 436f 6f72 6469 6e61 7465  undantCoordinate
-00009440: 4d42 533a 2066 6f75 6e64 2069 6e76 616c  MBS: found inval
-00009450: 6964 206a 6f69 6e74 2074 7970 6520 696e  id joint type in
-00009460: 206c 696e 6b20 272b 7374 7228 6929 2b27   link '+str(i)+'
-00009470: 3a27 2b6c 696e 6b2e 6a6f 696e 7454 7970  :'+link.jointTyp
-00009480: 6529 0d0a 2020 2020 2020 2020 0d0a 2020  e)..        ..  
-00009490: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-000094a0: 2020 2020 2320 5430 3120 3d20 4448 3248      # T01 = DH2H
-000094b0: 5428 4448 7061 7261 6d29 2023 7472 616e  T(DHparam) #tran
-000094c0: 7366 6f72 6d61 7469 6f6e 2066 726f 6d20  sformation from 
-000094d0: 6c61 7374 206c 696e 6b20 746f 2074 6869  last link to thi
-000094e0: 7320 6c69 6e6b 3b20 6974 2064 6566 696e  s link; it defin
-000094f0: 6573 2074 6865 206f 7269 656e 7461 7469  es the orientati
-00009500: 6f6e 206f 6620 7468 6520 626f 6479 0d0a  on of the body..
-00009510: 2020 2020 2020 2020 2020 2020 5430 3120              T01 
-00009520: 3d20 6c69 6e6b 2e70 7265 4854 2040 2064  = link.preHT @ d
-00009530: 6963 744a 6f69 6e74 5479 7065 3248 545b  ictJointType2HT[
-00009540: 6c69 6e6b 2e6a 6f69 6e74 5479 7065 5d28  link.jointType](
-00009550: 7152 6566 5b69 5d29 2040 206c 696e 6b2e  qRef[i]) @ link.
-00009560: 6c6f 6361 6c48 5420 236e 6577 2062 6f64  localHT #new bod
-00009570: 6965 7320 6172 6520 706c 6163 6564 2061  ies are placed a
-00009580: 7420 6f72 6967 696e 206f 6620 6c69 6e6b  t origin of link
-00009590: 2066 7261 6d65 0d0a 2020 2020 2020 2020   frame..        
-000095a0: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
-000095b0: 4861 7350 6172 656e 7428 6929 3a0d 0a20  HasParent(i):.. 
-000095c0: 2020 2020 2020 2020 2020 2020 2020 2054                 T
-000095d0: 6375 7272 656e 7420 3d20 7365 6c66 2e47  current = self.G
-000095e0: 6574 4261 7365 4854 2829 0d0a 2020 2020  etBaseHT()..    
-000095f0: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00009600: 2020 2020 2020 2020 2020 2020 2020 2054                 T
-00009610: 6375 7272 656e 7420 3d20 4854 6c69 7374  current = HTlist
-00009620: 5b73 656c 662e 4765 7450 6172 656e 7449  [self.GetParentI
-00009630: 6e64 6578 2869 295d 0d0a 0d0a 2020 2020  ndex(i)]....    
-00009640: 2020 2020 2020 2020 5463 7572 7265 6e74          Tcurrent
-00009650: 203d 2054 6375 7272 656e 7420 4020 5430   = Tcurrent @ T0
-00009660: 310d 0a20 2020 2020 2020 2020 2020 2048  1..            H
-00009670: 546c 6973 7420 2b3d 205b 636f 7079 2854  Tlist += [copy(T
-00009680: 6375 7272 656e 7429 5d0d 0a0d 0a20 2020  current)]....   
-00009690: 2020 2020 2020 2020 2023 2b2b 2b2b 2b2b           #++++++
-000096a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000096b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000096c0: 2b2b 2b2b 2b2b 2b2b 0d0a 2020 2020 2020  ++++++++..      
-000096d0: 2020 0d0a 2020 2020 2020 2020 2020 2020    ..            
-000096e0: 6c6f 6361 6c48 5469 6e76 203d 2065 7262  localHTinv = erb
-000096f0: 2e49 6e76 6572 7365 4854 286c 696e 6b2e  .InverseHT(link.
-00009700: 6c6f 6361 6c48 5429 0d0a 2020 2020 2020  localHT)..      
-00009710: 2020 2020 2020 4174 6869 7354 203d 2065        AthisT = e
-00009720: 7262 2e48 5432 726f 7461 7469 6f6e 4d61  rb.HT2rotationMa
-00009730: 7472 6978 286c 6f63 616c 4854 696e 7629  trix(localHTinv)
-00009740: 2023 7472 616e 7366 6f72 6d73 2062 6163   #transforms bac
-00009750: 6b20 746f 206a 6f69 6e74 300d 0a20 2020  k to joint0..   
-00009760: 2020 2020 2020 2020 2070 5468 6973 203d           pThis =
-00009770: 2020 6572 622e 4854 3274 7261 6e73 6c61    erb.HT2transla
-00009780: 7469 6f6e 286c 6f63 616c 4854 696e 7629  tion(localHTinv)
-00009790: 2023 4174 6869 7354 2040 206e 702e 6172   #AthisT @ np.ar
-000097a0: 7261 7928 5b2d 612c 302c 2d64 5d29 2023  ray([-a,0,-d]) #
-000097b0: 6e65 6564 6564 2066 6f72 206d 6172 6b65  needed for marke
-000097c0: 7220 6f66 206e 6578 7420 6c69 6e6b 0d0a  r of next link..
-000097d0: 2020 2020 2020 2020 2020 2020 0d0a 2020              ..  
-000097e0: 2020 2020 2020 2020 2020 2363 6f6d 7075            #compu
-000097f0: 7465 2061 7869 7320 6f66 2070 7265 7669  te axis of previ
-00009800: 6f75 7320 6c69 6e6b 2c20 666f 7220 7374  ous link, for st
-00009810: 6420 4448 2c20 7468 6973 2069 7320 7472  d DH, this is tr
-00009820: 616e 7366 6f72 6d65 6420 6261 636b 2074  ansformed back t
-00009830: 6f20 7072 6576 696f 7573 206a 6f69 6e74  o previous joint
-00009840: 0d0a 2020 2020 2020 2020 2020 2020 6a6f  ..            jo
-00009850: 696e 7441 7869 7320 3d20 6469 6374 4a6f  intAxis = dictJo
-00009860: 696e 7454 7970 6532 4178 6973 5b6c 696e  intType2Axis[lin
-00009870: 6b2e 6a6f 696e 7454 7970 655d 0d0a 2020  k.jointType]..  
-00009880: 2020 2020 2020 2020 2020 6178 6973 3020            axis0 
-00009890: 3d20 4174 6869 7354 2040 206a 6f69 6e74  = AthisT @ joint
-000098a0: 4178 6973 2023 666f 7220 6472 6177 696e  Axis #for drawin
-000098b0: 670d 0a20 2020 2020 2020 2020 2020 2023  g..            #
-000098c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000098d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000098e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0d0a  ++++++++++++++..
-000098f0: 2020 2020 2020 2020 2020 2020 0d0a 2020              ..  
-00009900: 2020 2020 2020 2020 2020 0d0a 2020 2020            ..    
-00009910: 2020 2020 2020 2020 2372 6967 6964 2062          #rigid b
-00009920: 6f64 7920 7061 7261 6d65 7465 7273 3a0d  ody parameters:.
-00009930: 0a20 2020 2020 2020 2020 2020 2063 6f6d  .            com
-00009940: 203d 206c 696e 6b2e 434f 4d20 2369 7320   = link.COM #is 
-00009950: 6465 6669 6e65 6420 7769 7468 696e 206c  defined within l
-00009960: 696e 6b3d 3d62 6f64 7920 6672 616d 650d  ink==body frame.
-00009970: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-00009980: 2020 2020 2020 2069 6e65 7274 6961 4c69         inertiaLi
-00009990: 6e6b 203d 2065 7262 2e52 6967 6964 426f  nk = erb.RigidBo
-000099a0: 6479 496e 6572 7469 6128 6d61 7373 3d6c  dyInertia(mass=l
-000099b0: 696e 6b2e 6d61 7373 2c20 696e 6572 7469  ink.mass, inerti
-000099c0: 6154 656e 736f 723d 6c69 6e6b 2e69 6e65  aTensor=link.ine
-000099d0: 7274 6961 290d 0a20 2020 2020 2020 2020  rtia)..         
-000099e0: 2020 2069 6e65 7274 6961 4c69 6e6b 203d     inertiaLink =
-000099f0: 2069 6e65 7274 6961 4c69 6e6b 2e54 7261   inertiaLink.Tra
-00009a00: 6e73 6c61 7465 6428 636f 6d29 2023 6e65  nslated(com) #ne
-00009a10: 6564 7320 746f 2062 6520 7265 636f 6d70  eds to be recomp
-00009a20: 7574 6564 2c20 6265 6361 7573 6520 696e  uted, because in
-00009a30: 6572 7469 6120 696e 2052 6f62 6f74 2069  ertia in Robot i
-00009a40: 7320 772e 722e 742e 2043 4f4d 2c20 6275  s w.r.t. COM, bu
-00009a50: 7420 4f62 6a65 6374 5269 6769 6442 6f64  t ObjectRigidBod
-00009a60: 7920 6e65 6564 7320 696e 6572 7469 6120  y needs inertia 
-00009a70: 666f 7220 7265 6665 7265 6e63 6520 706f  for reference po
-00009a80: 696e 740d 0a20 2020 2020 2020 2020 2020  int..           
-00009a90: 200d 0a20 2020 2020 2020 2020 2020 2023   ..            #
-00009aa0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00009ab0: 2b2b 2b2b 2b2b 2b2b 0d0a 2020 2020 2020  ++++++++..      
-00009ac0: 2020 2020 2020 2363 6f6d 7075 7465 2061        #compute a
-00009ad0: 7869 7331 2072 656c 6174 6564 2074 6f20  xis1 related to 
-00009ae0: 6e65 7874 206c 696e 6b20 2866 6f72 2073  next link (for s
-00009af0: 7464 2044 482c 2074 6869 7320 6973 206c  td DH, this is l
-00009b00: 6f63 616c 207a 2d61 7869 7320 696e 206c  ocal z-axis in l
-00009b10: 696e 6b20 636f 6f72 6469 6e61 7465 7329  ink coordinates)
-00009b20: 0d0a 2020 2020 2020 2020 2020 2020 6772  ..            gr
-00009b30: 6170 6869 6373 4c69 7374 203d 205b 5d0d  aphicsList = [].
-00009b40: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00009b50: 206e 6578 744c 696e 6b49 6e64 6578 2069   nextLinkIndex i
-00009b60: 6e20 6e65 7874 4c69 6e6b 735b 695d 3a0d  n nextLinks[i]:.
-00009b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009b80: 2023 2069 6620 6920 3d3d 206c 656e 2873   # if i == len(s
-00009b90: 656c 662e 6c69 6e6b 7329 2d31 3a0d 0a20  elf.links)-1:.. 
-00009ba0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00009bb0: 2020 2020 2070 4e65 7874 203d 206e 702e       pNext = np.
-00009bc0: 6172 7261 7928 5b30 2c30 2c30 2e5d 2920  array([0,0,0.]) 
-00009bd0: 2375 7365 206c 6f63 616c 2070 6f73 6974  #use local posit
-00009be0: 696f 6e20 666f 7220 6669 6e61 6c20 6c69  ion for final li
-00009bf0: 6e6b 0d0a 2020 2020 2020 2020 2020 2020  nk..            
-00009c00: 2020 2020 2320 2020 2020 6178 6973 4e65      #     axisNe
-00009c10: 7874 3d6e 702e 6172 7261 7928 5b30 2c30  xt=np.array([0,0
-00009c20: 2c30 5d29 2023 6e6f 2061 7869 7320 746f  ,0]) #no axis to
-00009c30: 2064 7261 7720 666f 7220 6c61 7374 206c   draw for last l
-00009c40: 696e 6b0d 0a20 2020 2020 2020 2020 2020  ink..           
-00009c50: 2020 2020 206e 6578 744c 696e 6b20 3d20       nextLink = 
-00009c60: 7365 6c66 2e6c 696e 6b73 5b6e 6578 744c  self.links[nextL
-00009c70: 696e 6b49 6e64 6578 5d0d 0a20 2020 2020  inkIndex]..     
-00009c80: 2020 2020 2020 2020 2020 2070 4e65 7874             pNext
-00009c90: 203d 2065 7262 2e48 5432 7472 616e 736c   = erb.HT2transl
-00009ca0: 6174 696f 6e28 6e65 7874 4c69 6e6b 2e70  ation(nextLink.p
-00009cb0: 7265 4854 2920 2374 6869 7320 6465 6669  reHT) #this defi
-00009cc0: 6e65 7320 7468 6520 706f 7369 7469 6f6e  nes the position
-00009cd0: 2066 6f72 2074 6865 206c 6f63 616c 206f   for the local o
-00009ce0: 6620 7468 6520 6178 6973 2066 6f72 206e  f the axis for n
-00009cf0: 6578 7420 6c69 6e6b 0d0a 2020 2020 2020  ext link..      
-00009d00: 2020 2020 2020 2020 2020 6178 6973 4e65            axisNe
-00009d10: 7874 203d 2065 7262 2e48 5432 726f 7461  xt = erb.HT2rota
-00009d20: 7469 6f6e 4d61 7472 6978 286e 6578 744c  tionMatrix(nextL
-00009d30: 696e 6b2e 7072 6548 5429 2040 2064 6963  ink.preHT) @ dic
-00009d40: 744a 6f69 6e74 5479 7065 3241 7869 735b  tJointType2Axis[
-00009d50: 6e65 7874 4c69 6e6b 2e6a 6f69 6e74 5479  nextLink.jointTy
-00009d60: 7065 5d20 0d0a 0d0a 2020 2020 2020 2020  pe] ....        
-00009d70: 2020 2020 2020 2020 6966 206c 656e 286c          if len(l
-00009d80: 696e 6b2e 7669 7375 616c 697a 6174 696f  ink.visualizatio
-00009d90: 6e2e 6772 6170 6869 6373 4461 7461 2920  n.graphicsData) 
-00009da0: 3d3d 2030 3a0d 0a20 2020 2020 2020 2020  == 0:..         
-00009db0: 2020 2020 2020 2020 2020 2067 7261 7068             graph
-00009dc0: 6963 734c 6973 7420 2b3d 2073 656c 662e  icsList += self.
-00009dd0: 4765 744c 696e 6b47 7261 7068 6963 7344  GetLinkGraphicsD
-00009de0: 6174 6128 692c 2070 5468 6973 2c20 704e  ata(i, pThis, pN
-00009df0: 6578 742c 2061 7869 7330 2c20 6178 6973  ext, axis0, axis
-00009e00: 4e65 7874 2c20 6c69 6e6b 2e76 6973 7561  Next, link.visua
-00009e10: 6c69 7a61 7469 6f6e 290d 0a0d 0a20 2020  lization)....   
-00009e20: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-00009e30: 6c69 6e6b 2e76 6973 7561 6c69 7a61 7469  link.visualizati
-00009e40: 6f6e 2e67 7261 7068 6963 7344 6174 6129  on.graphicsData)
-00009e50: 2021 3d20 303a 0d0a 2020 2020 2020 2020   != 0:..        
-00009e60: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
-00009e70: 4c69 7374 202b 3d20 6c69 6e6b 2e76 6973  List += link.vis
-00009e80: 7561 6c69 7a61 7469 6f6e 2e67 7261 7068  ualization.graph
-00009e90: 6963 7344 6174 610d 0a0d 0a20 2020 2020  icsData....     
-00009ea0: 2020 2020 2020 2023 6164 6420 7472 616e         #add tran
-00009eb0: 7366 6f72 6d65 6420 6772 6170 6869 6373  sformed graphics
-00009ec0: 4461 7461 206f 6620 746f 6f6c 2074 6f20  Data of tool to 
-00009ed0: 6c69 6e6b 2067 7261 7068 6963 730d 0a20  link graphics.. 
-00009ee0: 2020 2020 2020 2020 2020 2069 6620 2869             if (i
-00009ef0: 3d3d 6c65 6e28 7365 6c66 2e6c 696e 6b73  ==len(self.links
-00009f00: 292d 3120 616e 6420 2374 6f6f 6c0d 0a20  )-1 and #tool.. 
-00009f10: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00009f20: 656c 662e 746f 6f6c 2e76 6973 7561 6c69  elf.tool.visuali
-00009f30: 7a61 7469 6f6e 2e67 7261 7068 6963 7344  zation.graphicsD
-00009f40: 6174 6120 213d 205b 5d29 3a0d 0a20 2020  ata != []):..   
-00009f50: 2020 2020 2020 2020 2020 2020 2070 4f66               pOf
-00009f60: 6620 3d20 6572 622e 4854 3274 7261 6e73  f = erb.HT2trans
-00009f70: 6c61 7469 6f6e 2873 656c 662e 746f 6f6c  lation(self.tool
-00009f80: 2e48 5429 0d0a 2020 2020 2020 2020 2020  .HT)..          
-00009f90: 2020 2020 2020 416f 6666 203d 2065 7262        Aoff = erb
-00009fa0: 2e48 5432 726f 7461 7469 6f6e 4d61 7472  .HT2rotationMatr
-00009fb0: 6978 2873 656c 662e 746f 6f6c 2e48 5429  ix(self.tool.HT)
-00009fc0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009fd0: 2020 666f 7220 6461 7461 2069 6e20 7365    for data in se
-00009fe0: 6c66 2e74 6f6f 6c2e 7669 7375 616c 697a  lf.tool.visualiz
-00009ff0: 6174 696f 6e2e 6772 6170 6869 6373 4461  ation.graphicsDa
-0000a000: 7461 3a0d 0a20 2020 2020 2020 2020 2020  ta:..           
-0000a010: 2020 2020 2020 2020 2067 7261 7068 6963           graphic
-0000a020: 734c 6973 7420 2b3d 205b 6567 642e 4d6f  sList += [egd.Mo
-0000a030: 7665 4772 6170 6869 6373 4461 7461 2864  veGraphicsData(d
-0000a040: 6174 612c 2070 4f66 662c 2041 6f66 6629  ata, pOff, Aoff)
-0000a050: 5d20 0d0a 0d0a 2020 2020 2020 2020 2020  ] ....          
-0000a060: 2020 0d0a 2020 2020 2020 2020 2020 2020    ..            
-0000a070: 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  #+++++++++++++++
-0000a080: 2b2b 2b2b 2b2b 2b2b 2b0d 0a20 2020 2020  +++++++++..     
-0000a090: 2020 2020 2020 2023 6e6f 7720 6164 6420         #now add 
-0000a0a0: 626f 6479 2066 6f72 206c 696e 6b3a 0d0a  body for link:..
-0000a0b0: 2020 2020 2020 2020 2020 2020 5b6e 4c69              [nLi
-0000a0c0: 6e6b 2c62 4c69 6e6b 5d3d 6572 622e 4164  nk,bLink]=erb.Ad
-0000a0d0: 6452 6967 6964 426f 6479 286d 6169 6e53  dRigidBody(mainS
-0000a0e0: 7973 203d 206d 6273 2c20 696e 6572 7469  ys = mbs, inerti
-0000a0f0: 613d 696e 6572 7469 614c 696e 6b2c 200d  a=inertiaLink, .
-0000a100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a120: 206e 6f64 6554 7970 653d 7269 6769 6442   nodeType=rigidB
-0000a130: 6f64 794e 6f64 6554 7970 652c 2023 274e  odyNodeType, #'N
-0000a140: 6f64 6554 7970 652e 526f 7461 7469 6f6e  odeType.Rotation
-0000a150: 4575 6c65 7250 6172 616d 6574 6572 7327  EulerParameters'
-0000a160: 2c20 0d0a 2020 2020 2020 2020 2020 2020  , ..            
-0000a170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a180: 2020 2020 706f 7369 7469 6f6e 3d65 7262      position=erb
-0000a190: 2e48 5432 7472 616e 736c 6174 696f 6e28  .HT2translation(
-0000a1a0: 5463 7572 7265 6e74 292c 200d 0a20 2020  Tcurrent), ..   
-0000a1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1c0: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
-0000a1d0: 6174 696f 6e4d 6174 7269 7820 3d20 6572  ationMatrix = er
-0000a1e0: 622e 4854 3272 6f74 6174 696f 6e4d 6174  b.HT2rotationMat
-0000a1f0: 7269 7828 5463 7572 7265 6e74 292c 0d0a  rix(Tcurrent),..
-0000a200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a220: 6772 6176 6974 793d 7365 6c66 2e67 7261  gravity=self.gra
-0000a230: 7669 7479 2c20 0d0a 2020 2020 2020 2020  vity, ..        
-0000a240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a250: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
-0000a260: 4461 7461 4c69 7374 3d67 7261 7068 6963  DataList=graphic
-0000a270: 734c 6973 7429 0d0a 2020 2020 2020 2020  sList)..        
-0000a280: 2020 2020 6e6f 6465 4c69 7374 2b3d 5b6e      nodeList+=[n
-0000a290: 4c69 6e6b 5d0d 0a20 2020 2020 2020 2020  Link]..         
-0000a2a0: 2020 2062 6f64 794c 6973 742b 3d5b 624c     bodyList+=[bL
-0000a2b0: 696e 6b5d 0d0a 2020 2020 2020 2020 2020  ink]..          
-0000a2c0: 2020 2370 7269 6e74 286d 6273 2e47 6574    #print(mbs.Get
-0000a2d0: 4f62 6a65 6374 2862 4c69 6e6b 2929 0d0a  Object(bLink))..
-0000a2e0: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-0000a2f0: 2020 2020 2020 232b 2b2b 2b2b 2b2b 2b2b        #+++++++++
-0000a300: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d  +++++++++++++++.
-0000a310: 0a20 2020 2020 2020 2020 2020 2023 6164  .            #ad
-0000a320: 6420 6d61 726b 6572 7320 616e 6420 6a6f  d markers and jo
-0000a330: 696e 7473 0d0a 2020 2020 2020 2020 2020  ints..          
-0000a340: 2020 6d4c 696e 6b31 203d 206d 6273 2e41    mLink1 = mbs.A
-0000a350: 6464 4d61 726b 6572 2865 6969 2e4d 6172  ddMarker(eii.Mar
-0000a360: 6b65 7242 6f64 7952 6967 6964 2862 6f64  kerBodyRigid(bod
-0000a370: 794e 756d 6265 723d 624c 696e 6b2c 206c  yNumber=bLink, l
-0000a380: 6f63 616c 506f 7369 7469 6f6e 3d70 5468  ocalPosition=pTh
-0000a390: 6973 2929 0d0a 2020 2020 2020 2020 2020  is))..          
-0000a3a0: 2020 2320 6d61 726b 6572 506f 7369 7469    # markerPositi
-0000a3b0: 6f6e 4c69 6e6b 316e 6578 7420 3d20 5b30  onLink1next = [0
-0000a3c0: 2c30 2c30 5d20 236e 6f74 2075 7365 6420  ,0,0] #not used 
-0000a3d0: 696e 206c 6173 7420 6c69 6e6b 210d 0a20  in last link!.. 
-0000a3e0: 2020 2020 2020 2020 2020 2023 2069 6620             # if 
-0000a3f0: 6920 3c20 6c65 6e28 7365 6c66 2e6c 696e  i < len(self.lin
-0000a400: 6b73 292d 313a 0d0a 2020 2020 2020 2020  ks)-1:..        
-0000a410: 2020 2020 2320 2020 2020 6d61 726b 6572      #     marker
-0000a420: 506f 7369 7469 6f6e 4c69 6e6b 316e 6578  PositionLink1nex
-0000a430: 7420 3d20 6572 622e 4854 3274 7261 6e73  t = erb.HT2trans
-0000a440: 6c61 7469 6f6e 2873 656c 662e 6c69 6e6b  lation(self.link
-0000a450: 735b 692b 315d 2e70 7265 4854 2920 2374  s[i+1].preHT) #t
-0000a460: 6869 7320 6973 2064 6566 696e 6564 2069  his is defined i
-0000a470: 6e20 7468 6520 6e65 7874 206c 696e 6b21  n the next link!
-0000a480: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000a490: 6d6c 696e 6b31 6e65 7874 203d 206d 6273  mlink1next = mbs
-0000a4a0: 2e41 6464 4d61 726b 6572 2865 6969 2e4d  .AddMarker(eii.M
-0000a4b0: 6172 6b65 7242 6f64 7952 6967 6964 2862  arkerBodyRigid(b
-0000a4c0: 6f64 794e 756d 6265 723d 624c 696e 6b2c  odyNumber=bLink,
-0000a4d0: 200d 0a20 2020 2020 2020 2020 2020 2023   ..            #
-0000a4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a500: 2020 2020 2020 2020 2020 2020 6c6f 6361              loca
-0000a510: 6c50 6f73 6974 696f 6e3d 6d61 726b 6572  lPosition=marker
-0000a520: 506f 7369 7469 6f6e 4c69 6e6b 316e 6578  PositionLink1nex
-0000a530: 7429 290d 0a0d 0a20 2020 2020 2020 2020  t))....         
-0000a540: 2020 2069 6620 6920 3d3d 2030 3a0d 0a20     if i == 0:.. 
-0000a550: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000a560: 6173 744d 6172 6b65 7252 6f74 6174 696f  astMarkerRotatio
-0000a570: 6e20 3d20 6572 622e 4854 3272 6f74 6174  n = erb.HT2rotat
-0000a580: 696f 6e4d 6174 7269 7828 6c69 6e6b 2e70  ionMatrix(link.p
-0000a590: 7265 4854 2940 6c61 7374 4d61 726b 6572  reHT)@lastMarker
-0000a5a0: 526f 7461 7469 6f6e 2023 6973 2072 6f74  Rotation #is rot
-0000a5b0: 6174 696f 6e4d 6172 6b65 7242 6173 650d  ationMarkerBase.
-0000a5c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a5d0: 206d 4c69 6e6b 304c 6173 7442 6f64 7920   mLink0LastBody 
-0000a5e0: 3d20 6261 7365 4d61 726b 6572 0d0a 2020  = baseMarker..  
-0000a5f0: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-0000a600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a610: 206c 6173 744d 6172 6b65 7252 6f74 6174   lastMarkerRotat
-0000a620: 696f 6e20 3d20 6572 622e 4854 3272 6f74  ion = erb.HT2rot
-0000a630: 6174 696f 6e4d 6174 7269 7828 6c69 6e6b  ationMatrix(link
-0000a640: 2e70 7265 4854 290d 0a20 2020 2020 2020  .preHT)..       
-0000a650: 2020 2020 2020 2020 206d 6172 6b65 7230           marker0
-0000a660: 506f 7369 7469 6f6e 203d 2065 7262 2e48  Position = erb.H
-0000a670: 5432 7472 616e 736c 6174 696f 6e28 6c69  T2translation(li
-0000a680: 6e6b 2e70 7265 4854 2920 2374 6869 7320  nk.preHT) #this 
-0000a690: 6973 2064 6566 696e 6564 2069 6e20 7468  is defined in th
-0000a6a0: 6520 7061 7265 6e74 206c 696e 6b21 0d0a  e parent link!..
-0000a6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6c0: 7061 7265 6e74 426f 6479 203d 2062 6f64  parentBody = bod
-0000a6d0: 794c 6973 745b 7365 6c66 2e47 6574 5061  yList[self.GetPa
-0000a6e0: 7265 6e74 496e 6465 7828 6929 5d0d 0a20  rentIndex(i)].. 
-0000a6f0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-0000a700: 4c69 6e6b 304c 6173 7442 6f64 7920 3d20  Link0LastBody = 
-0000a710: 6d62 732e 4164 644d 6172 6b65 7228 6569  mbs.AddMarker(ei
-0000a720: 692e 4d61 726b 6572 426f 6479 5269 6769  i.MarkerBodyRigi
-0000a730: 6428 626f 6479 4e75 6d62 6572 3d70 6172  d(bodyNumber=par
-0000a740: 656e 7442 6f64 792c 200d 0a20 2020 2020  entBody, ..     
+00007670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007680: 2020 2020 2020 206a 6f69 6e74 5665 6c6f         jointVelo
+00007690: 6369 7479 4f66 6673 6574 5665 6374 6f72  cityOffsetVector
+000076a0: 203d 206a 6f69 6e74 5665 6c6f 6369 7479   = jointVelocity
+000076b0: 4f66 6673 6574 5665 6374 6f72 2c20 6a6f  OffsetVector, jo
+000076c0: 696e 7444 436f 6e74 726f 6c56 6563 746f  intDControlVecto
+000076d0: 7220 3d20 6a6f 696e 7444 436f 6e74 726f  r = jointDContro
+000076e0: 6c56 6563 746f 722c 0a20 2020 2020 2020  lVector,.       
+000076f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007710: 2020 2076 6973 7561 6c69 7a61 7469 6f6e     visualization
+00007720: 3d65 6969 2e56 4f62 6a65 6374 4b69 6e65  =eii.VObjectKine
+00007730: 6d61 7469 6354 7265 6528 6772 6170 6869  maticTree(graphi
+00007740: 6373 4461 7461 4c69 7374 203d 2067 7261  csDataList = gra
+00007750: 7068 6963 7344 6174 614c 6973 7429 2929  phicsDataList)))
+00007760: 0a0a 2020 2020 2020 2020 2372 6574 7572  ..        #retur
+00007770: 6e20 736f 6d65 206e 6565 6465 6420 7661  n some needed va
+00007780: 7269 6162 6c65 7320 666f 7220 6675 7274  riables for furt
+00007790: 6865 7220 7573 6520 2020 2020 2020 200a  her use        .
+000077a0: 2020 2020 2020 2020 6420 3d20 7b27 6e6f          d = {'no
+000077b0: 6465 4765 6e65 7269 6327 3a20 6e47 656e  deGeneric': nGen
+000077c0: 6572 6963 2c20 276f 626a 6563 744b 696e  eric, 'objectKin
+000077d0: 656d 6174 6963 5472 6565 273a 206f 4b54  ematicTree': oKT
+000077e0: 2c20 2762 6173 654f 626a 6563 7427 3a20  , 'baseObject': 
+000077f0: 6261 7365 4f62 6a65 6374 2c0a 2020 2020  baseObject,.    
+00007800: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00007810: 2020 2072 6574 7572 6e20 640a 0a20 2020     return d..   
+00007820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007830: 2020 200a 0a20 2020 2023 2525 2b2b 2b2b     ..    #%%++++
+00007840: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00007850: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00007860: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00007870: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00007880: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00007890: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000078a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000078b0: 2b2b 2b2b 0a20 2020 2023 2a2a 636c 6173  ++++.    #**clas
+000078c0: 7346 756e 6374 696f 6e3a 2041 6464 2069  sFunction: Add i
+000078d0: 7465 6d73 2074 6f20 6578 6973 7469 6e67  tems to existing
+000078e0: 206d 6273 2066 726f 6d20 7468 6520 726f   mbs from the ro
+000078f0: 626f 7420 7374 7275 6374 7572 6520 696e  bot structure in
+00007900: 7369 6465 2074 6869 7320 726f 626f 7420  side this robot 
+00007910: 636c 6173 733b 2072 6f62 6f74 2069 7320  class; robot is 
+00007920: 6174 7461 6368 6564 2074 6f20 6261 7365  attached to base
+00007930: 4d61 726b 6572 2028 6361 6e20 6265 2067  Marker (can be g
+00007940: 726f 756e 6420 6f62 6a65 6374 206f 7220  round object or 
+00007950: 6d6f 7669 6e67 2f64 6566 6f72 6d61 626c  moving/deformabl
+00007960: 6520 626f 6479 293b 0a20 2020 2023 2020  e body);.    #  
+00007970: 2020 2020 2020 2020 2020 2020 2020 2054                 T
+00007980: 6865 2028 7365 7269 616c 2920 726f 626f  he (serial) robo
+00007990: 7420 6973 2062 7569 6c74 2061 7320 7269  t is built as ri
+000079a0: 6769 6420 626f 6469 6573 2028 636f 6e74  gid bodies (cont
+000079b0: 6169 6e69 6e67 2072 6967 6964 2062 6f64  aining rigid bod
+000079c0: 7920 6e6f 6465 7329 2c20 7768 6572 6520  y nodes), where 
+000079d0: 626f 6469 6573 2072 6570 7265 7365 6e74  bodies represent
+000079e0: 2074 6865 206c 696e 6b73 2077 6869 6368   the links which
+000079f0: 2061 7265 2063 6f6e 6e65 6374 6564 2062   are connected b
+00007a00: 7920 6a6f 696e 7473 3b20 0a20 2020 2023  y joints; .    #
+00007a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007a20: 2041 6464 206f 7074 696f 6e61 6c20 6a6f   Add optional jo
+00007a30: 696e 7453 7072 696e 6744 616d 7065 7255  intSpringDamperU
+00007a40: 7365 7246 756e 6374 696f 6e4c 6973 7420  serFunctionList 
+00007a50: 666f 7220 696e 6469 7669 6475 616c 2063  for individual c
+00007a60: 6f6e 7472 6f6c 206f 6620 6a6f 696e 7473  ontrol of joints
+00007a70: 3b20 6f74 6865 7277 6973 6520 7573 6520  ; otherwise use 
+00007a80: 5044 636f 6e74 726f 6c20 696e 2052 6f62  PDcontrol in Rob
+00007a90: 6f74 4c69 6e6b 2073 7472 7563 7475 7265  otLink structure
+00007aa0: 3b20 6164 6469 7469 6f6e 616c 206a 6f69  ; additional joi
+00007ab0: 6e74 2074 6f72 7175 6573 2f66 6f72 6365  nt torques/force
+00007ac0: 7320 6361 6e20 6265 2061 6464 6564 2076  s can be added v
+00007ad0: 6961 2073 7072 696e 6720 6461 6d70 6572  ia spring damper
+00007ae0: 2c20 7573 696e 6720 6d62 732e 5365 744f  , using mbs.SetO
+00007af0: 626a 6563 7450 6172 616d 6574 6572 282e  bjectParameter(.
+00007b00: 2e2e 2920 6675 6e63 7469 6f6e 3b0a 2020  ..) function;.  
+00007b10: 2020 2320 2020 2020 2020 2020 2020 2020    #             
+00007b20: 2020 2020 5365 6520 7365 7665 7261 6c20      See several 
+00007b30: 5079 7468 6f6e 2065 7861 6d70 6c65 732c  Python examples,
+00007b40: 2065 2e67 2e2c 205c 7465 7874 7474 7b73   e.g., \texttt{s
+00007b50: 6572 6961 6c52 6f62 6f74 5465 7374 5453  erialRobotTestTS
+00007b60: 442e 7079 7d2c 2069 6e20 4578 616d 706c  D.py}, in Exampl
+00007b70: 6573 206f 7220 5465 7374 4d6f 6465 6c73  es or TestModels
+00007b80: 3b0a 2020 2020 2320 2020 2020 2020 2020  ;.    #         
+00007b90: 2020 2020 2020 2020 466f 7220 6d6f 7265          For more
+00007ba0: 2065 6666 6963 6965 6e74 206d 6f64 656c   efficient model
+00007bb0: 732c 2075 7365 2043 7265 6174 654b 696e  s, use CreateKin
+00007bc0: 656d 6174 6963 5472 6565 282e 2e2e 2920  ematicTree(...) 
+00007bd0: 6675 6e63 7469 6f6e 210a 2020 2020 232a  function!.    #*
+00007be0: 2a69 6e70 7574 3a20 0a20 2020 2023 2020  *input: .    #  
+00007bf0: 206d 6273 3a20 7468 6520 6d75 6c74 6962   mbs: the multib
+00007c00: 6f64 7920 7379 7374 656d 2c20 7768 6963  ody system, whic
+00007c10: 6820 7769 6c6c 2062 6520 6578 7465 6e64  h will be extend
+00007c20: 6564 0a20 2020 2023 2020 2062 6173 654d  ed.    #   baseM
+00007c30: 6172 6b65 723a 2061 2072 6967 6964 2062  arker: a rigid b
+00007c40: 6f64 7920 6d61 726b 6572 2c20 6174 2077  ody marker, at w
+00007c50: 6869 6368 2074 6865 2072 6f62 6f74 2077  hich the robot w
+00007c60: 696c 6c20 6265 2070 6c61 6365 6420 2875  ill be placed (u
+00007c70: 7375 616c 6c79 2067 726f 756e 6429 3b20  sually ground); 
+00007c80: 6e6f 7465 2074 6861 7420 7468 6520 6c6f  note that the lo
+00007c90: 6361 6c20 636f 6f72 6469 6e61 7465 2073  cal coordinate s
+00007ca0: 7973 7465 6d20 6f66 2074 6865 2062 6173  ystem of the bas
+00007cb0: 6520 6d75 7374 2062 6520 696e 2061 6363  e must be in acc
+00007cc0: 6f72 6461 6e63 6520 7769 7468 2074 6865  ordance with the
+00007cd0: 2044 482d 7061 7261 6d65 7465 7273 2c20   DH-parameters, 
+00007ce0: 692e 652e 2c20 7468 6520 7a2d 6178 6973  i.e., the z-axis
+00007cf0: 206d 7573 7420 6265 2074 6865 2066 6972   must be the fir
+00007d00: 7374 2072 6f74 6174 696f 6e20 6178 6973  st rotation axis
+00007d10: 2e20 466f 7220 636f 7272 6563 7469 6f6e  . For correction
+00007d20: 206f 6620 7468 6520 6261 7365 2063 6f6f   of the base coo
+00007d30: 7264 696e 6174 6520 7379 7374 656d 2c20  rdinate system, 
+00007d40: 7573 6520 726f 7461 7469 6f6e 4d61 726b  use rotationMark
+00007d50: 6572 4261 7365 0a20 2020 2023 2020 206a  erBase.    #   j
+00007d60: 6f69 6e74 5370 7269 6e67 4461 6d70 6572  ointSpringDamper
+00007d70: 5573 6572 4675 6e63 7469 6f6e 4c69 7374  UserFunctionList
+00007d80: 3a20 4e4f 5420 494d 504c 454d 454e 5445  : NOT IMPLEMENTE
+00007d90: 4420 7965 743a 206a 6f69 6e74 5370 7269  D yet: jointSpri
+00007da0: 6e67 4461 6d70 6572 5573 6572 4675 6e63  ngDamperUserFunc
+00007db0: 7469 6f6e 4c69 7374 6120 6c69 7374 206f  tionLista list o
+00007dc0: 6620 7573 6572 2066 756e 6374 696f 6e73  f user functions
+00007dd0: 2066 6f72 2061 6374 7561 7469 6f6e 206f   for actuation o
+00007de0: 6620 6a6f 696e 7473 2077 6974 6820 6d6f  f joints with mo
+00007df0: 7265 2065 6666 6963 6965 6e74 2073 7072  re efficient spr
+00007e00: 696e 672d 6461 6d70 6572 2062 6173 6564  ing-damper based
+00007e10: 2063 6f6e 6e65 6374 6f72 2028 7370 7269   connector (spri
+00007e20: 6e67 2d64 616d 7065 7220 6469 7265 6374  ng-damper direct
+00007e30: 6c79 2065 6d75 6c61 7465 7320 5044 2d63  ly emulates PD-c
+00007e40: 6f6e 7472 6f6c 6c65 7229 3b20 7573 6573  ontroller); uses
+00007e50: 2074 6f72 7369 6f6e 616c 2073 7072 696e   torsional sprin
+00007e60: 6720 6461 6d70 6572 2066 6f72 2072 6576  g damper for rev
+00007e70: 6f6c 7574 6520 6a6f 696e 7473 2061 6e64  olute joints and
+00007e80: 206c 696e 6561 7220 7370 7269 6e67 2064   linear spring d
+00007e90: 616d 7065 7220 666f 7220 7072 6973 6d61  amper for prisma
+00007ea0: 7469 6320 6a6f 696e 7473 3b20 6361 6e20  tic joints; can 
+00007eb0: 6265 2065 6d70 7479 206c 6973 7420 286e  be empty list (n
+00007ec0: 6f20 7370 7269 6e67 2064 616d 7065 7273  o spring dampers
+00007ed0: 293b 2069 6620 656e 7472 7920 6f66 206c  ); if entry of l
+00007ee0: 6973 7420 6973 2030 2c20 6e6f 2075 7365  ist is 0, no use
+00007ef0: 7220 6675 6e63 7469 6f6e 2069 7320 6372  r function is cr
+00007f00: 6561 7465 642c 206a 7573 7420 7075 7265  eated, just pure
+00007f10: 2073 7072 696e 6720 6461 6d70 6572 3b20   spring damper; 
+00007f20: 7061 7261 6d65 7465 7273 2061 7265 2074  parameters are t
+00007f30: 616b 656e 2066 726f 6d20 526f 626f 744c  aken from RobotL
+00007f40: 696e 6b20 5044 636f 6e74 726f 6c20 7374  ink PDcontrol st
+00007f50: 7275 6374 7572 652c 2077 6869 6368 204d  ructure, which M
+00007f60: 5553 5420 6265 2064 6566 696e 6564 2075  UST be defined u
+00007f70: 7369 6e67 2053 6574 5044 636f 6e74 726f  sing SetPDcontro
+00007f80: 6c28 2e2e 2e29 2069 6e20 526f 626f 744c  l(...) in RobotL
+00007f90: 696e 6b0a 2020 2020 2320 2020 6a6f 696e  ink.    #   join
+00007fa0: 744c 6f61 6455 7365 7246 756e 6374 696f  tLoadUserFunctio
+00007fb0: 6e4c 6973 743a 2044 4550 5245 4341 5445  nList: DEPRECATE
+00007fc0: 443a 2061 206c 6973 7420 6f66 2075 7365  D: a list of use
+00007fd0: 7220 6675 6e63 7469 6f6e 7320 666f 7220  r functions for 
+00007fe0: 6163 7475 6174 696f 6e20 6f66 206a 6f69  actuation of joi
+00007ff0: 6e74 7320 6163 636f 7264 696e 6720 746f  nts according to
+00008000: 2061 204c 6f61 6454 6f72 7175 6556 6563   a LoadTorqueVec
+00008010: 746f 7220 7573 6572 4675 6e63 7469 6f6e  tor userFunction
+00008020: 2c20 7365 6520 7365 7269 616c 526f 626f  , see serialRobo
+00008030: 7454 6573 742e 7079 2061 7320 616e 2065  tTest.py as an e
+00008040: 7861 6d70 6c65 3b20 6361 6e20 6265 2065  xample; can be e
+00008050: 6d70 7479 206c 6973 740a 2020 2020 2320  mpty list.    # 
+00008060: 2020 6372 6561 7465 4a6f 696e 7454 6f72    createJointTor
+00008070: 7175 654c 6f61 6473 3a20 4445 5052 4543  queLoads: DEPREC
+00008080: 4154 4544 3a20 6966 2054 7275 652c 2069  ATED: if True, i
+00008090: 6e64 6570 656e 6465 6e74 6c79 206f 6620  ndependently of 
+000080a0: 6a6f 696e 744c 6f61 6455 7365 7246 756e  jointLoadUserFun
+000080b0: 6374 696f 6e4c 6973 742c 206a 6f69 6e74  ctionList, joint
+000080c0: 206c 6f61 6473 2061 7265 2063 7265 6174   loads are creat
+000080d0: 6564 3b20 7468 6520 6c6f 6164 206e 756d  ed; the load num
+000080e0: 6265 7273 2061 7265 2073 746f 7265 6420  bers are stored 
+000080f0: 696e 206c 6973 7473 206a 6f69 6e74 546f  in lists jointTo
+00008100: 7271 7565 304c 6973 742f 206a 6f69 6e74  rque0List/ joint
+00008110: 546f 7271 7565 314c 6973 743b 2074 6865  Torque1List; the
+00008120: 206c 6f61 6473 2063 6f6e 7461 696e 207a   loads contain z
+00008130: 6572 6f20 746f 7271 7565 7320 616e 6420  ero torques and 
+00008140: 6e65 6564 2074 6f20 6265 2075 7064 6174  need to be updat
+00008150: 6564 2069 6e20 6576 6572 7920 636f 6d70  ed in every comp
+00008160: 7574 6174 696f 6e20 7374 6570 2c20 652e  utation step, e.
+00008170: 672e 2c20 7573 696e 6720 6120 7072 6553  g., using a preS
+00008180: 7465 7055 7365 7246 756e 6374 696f 6e3b  tepUserFunction;
+00008190: 2075 6e69 7454 6f72 7175 6530 4c69 7374   unitTorque0List
+000081a0: 2f20 756e 6974 546f 7271 7565 314c 6973  / unitTorque1Lis
+000081b0: 7420 636f 6e74 6169 6e20 7468 6520 756e  t contain the un
+000081c0: 6974 2074 6f72 7175 6520 7665 6374 6f72  it torque vector
+000081d0: 2066 6f72 2074 6865 2061 6363 6f72 6469   for the accordi
+000081e0: 6e67 2062 6f64 7928 6c69 6e6b 2920 7768  ng body(link) wh
+000081f0: 6963 6820 6e65 6564 7320 746f 2062 6520  ich needs to be 
+00008200: 6170 706c 6965 6420 6f6e 2062 6f74 6820  applied on both 
+00008210: 626f 6469 6573 2061 7474 6163 6865 6420  bodies attached 
+00008220: 746f 2074 6865 206a 6f69 6e74 0a20 2020  to the joint.   
+00008230: 2023 2020 2072 6f74 6174 696f 6e4d 6172   #   rotationMar
+00008240: 6b65 7242 6173 653a 2061 6464 2061 206e  kerBase: add a n
+00008250: 756d 7079 2033 7833 206d 6174 7269 7820  umpy 3x3 matrix 
+00008260: 666f 7220 726f 7461 7469 6f6e 206f 6620  for rotation of 
+00008270: 7468 6520 6261 7365 2c20 696e 206f 7264  the base, in ord
+00008280: 6572 2074 6861 7420 7468 6520 726f 626f  er that the robo
+00008290: 7420 6361 6e20 6265 2061 7474 6163 6865  t can be attache
+000082a0: 6420 746f 2061 6e79 2072 6f74 6174 6564  d to any rotated
+000082b0: 2062 6173 6520 6d61 726b 6572 3b20 7468   base marker; th
+000082c0: 6520 726f 7461 7469 6f6e 4d61 726b 6572  e rotationMarker
+000082d0: 4261 7365 2069 7320 6163 636f 7264 696e  Base is accordin
+000082e0: 6720 746f 2074 6865 2064 6566 696e 6974  g to the definit
+000082f0: 696f 6e20 696e 2047 656e 6572 6963 4a6f  ion in GenericJo
+00008300: 696e 743b 206e 6f74 652c 2074 6861 7420  int; note, that 
+00008310: 666f 7220 6d6f 7669 6e67 2062 6173 652c  for moving base,
+00008320: 2074 6865 2073 7461 7469 6320 636f 6d70   the static comp
+00008330: 656e 7361 7469 6f6e 2064 6f65 7320 6e6f  ensation does no
+00008340: 7420 776f 726b 2028 6261 7365 2072 6f74  t work (base rot
+00008350: 6174 696f 6e20 6d75 7374 2062 6520 7570  ation must be up
+00008360: 6461 7465 6429 0a20 2020 2023 2020 2072  dated).    #   r
+00008370: 6967 6964 426f 6479 4e6f 6465 5479 7065  igidBodyNodeType
+00008380: 3a20 7370 6563 6966 7920 6e6f 6465 2074  : specify node t
+00008390: 7970 6520 6f66 2072 6967 6964 2062 6f64  ype of rigid bod
+000083a0: 7920 6e6f 6465 2c20 652e 672e 2c20 6578  y node, e.g., ex
+000083b0: 7564 796e 2e4e 6f64 6554 7970 652e 526f  udyn.NodeType.Ro
+000083c0: 7461 7469 6f6e 4575 6c65 7250 6172 616d  tationEulerParam
+000083d0: 6574 6572 732c 2065 7463 2e0a 2020 2020  eters, etc..    
+000083e0: 232a 2a6f 7574 7075 743a 2074 6865 2066  #**output: the f
+000083f0: 756e 6374 696f 6e20 7265 7475 726e 7320  unction returns 
+00008400: 6120 6469 6374 696f 6e61 7279 2063 6f6e  a dictionary con
+00008410: 7461 696e 696e 6720 7065 7220 6c69 6e6b  taining per link
+00008420: 206e 6f64 6573 2061 6e64 206f 626a 6563   nodes and objec
+00008430: 7420 2862 6f64 7929 206e 756d 6265 7273  t (body) numbers
+00008440: 2c20 276e 6f64 654c 6973 7427 2c20 2762  , 'nodeList', 'b
+00008450: 6f64 794c 6973 7427 2c20 7468 6520 6f62  odyList', the ob
+00008460: 6a65 6374 206e 756d 6265 7273 2066 6f72  ject numbers for
+00008470: 206a 6f69 6e74 732c 2027 6a6f 696e 744c   joints, 'jointL
+00008480: 6973 7427 2c20 6c69 7374 206f 6620 6c6f  ist', list of lo
+00008490: 6164 206e 756d 6265 7273 2066 6f72 206a  ad numbers for j
+000084a0: 6f69 6e74 2074 6f72 7175 6573 2028 6a6f  oint torques (jo
+000084b0: 696e 7454 6f72 7175 6530 4c69 7374 2c20  intTorque0List, 
+000084c0: 6a6f 696e 7454 6f72 7175 6531 4c69 7374  jointTorque1List
+000084d0: 293b 2075 6e69 7420 746f 7271 7565 2076  ); unit torque v
+000084e0: 6563 746f 7273 2069 6e20 6c6f 6361 6c20  ectors in local 
+000084f0: 636f 6f72 6469 6e61 7465 7320 6f66 2074  coordinates of t
+00008500: 6865 2062 6f64 6965 7320 746f 2077 6869  he bodies to whi
+00008510: 6368 2074 6865 2074 6f72 7175 6573 2061  ch the torques a
+00008520: 7265 2061 7070 6c69 6564 2028 756e 6974  re applied (unit
+00008530: 546f 7271 7565 304c 6973 742c 2075 6e69  Torque0List, uni
+00008540: 7454 6f72 7175 6531 4c69 7374 293b 2073  tTorque1List); s
+00008550: 7072 696e 6744 616d 7065 724c 6973 7420  pringDamperList 
+00008560: 636f 6e74 6169 6e73 2074 6865 2073 7072  contains the spr
+00008570: 696e 6720 6461 6d70 6572 7320 6966 2064  ing dampers if d
+00008580: 6566 696e 6564 2062 7920 5044 636f 6e74  efined by PDcont
+00008590: 726f 6c20 6f66 206c 696e 6b73 0a20 2020  rol of links.   
+000085a0: 2064 6566 2043 7265 6174 6552 6564 756e   def CreateRedun
+000085b0: 6461 6e74 436f 6f72 6469 6e61 7465 4d42  dantCoordinateMB
+000085c0: 5328 7365 6c66 2c20 6d62 732c 2062 6173  S(self, mbs, bas
+000085d0: 654d 6172 6b65 722c 206a 6f69 6e74 5370  eMarker, jointSp
+000085e0: 7269 6e67 4461 6d70 6572 5573 6572 4675  ringDamperUserFu
+000085f0: 6e63 7469 6f6e 4c69 7374 3d20 5b5d 2c20  nctionList= [], 
+00008600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008620: 2020 2020 2020 6a6f 696e 744c 6f61 6455        jointLoadU
+00008630: 7365 7246 756e 6374 696f 6e4c 6973 743d  serFunctionList=
+00008640: 5b5d 2c20 0a20 2020 2020 2020 2020 2020  [], .           
+00008650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008660: 2020 2020 2020 2020 2020 6372 6561 7465            create
+00008670: 4a6f 696e 7454 6f72 7175 654c 6f61 6473  JointTorqueLoads
+00008680: 3d54 7275 652c 2072 6f74 6174 696f 6e4d  =True, rotationM
+00008690: 6172 6b65 7242 6173 653d 4e6f 6e65 2c0a  arkerBase=None,.
+000086a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000086b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000086c0: 2020 2020 2072 6967 6964 426f 6479 4e6f       rigidBodyNo
+000086d0: 6465 5479 7065 3d65 7875 6479 6e2e 4e6f  deType=exudyn.No
+000086e0: 6465 5479 7065 2e52 6f74 6174 696f 6e45  deType.RotationE
+000086f0: 756c 6572 5061 7261 6d65 7465 7273 293a  ulerParameters):
+00008700: 200a 2020 2020 2020 2020 2362 7569 6c64   .        #build
+00008710: 2072 6f62 6f74 206d 6f64 656c 3a0a 2020   robot model:.  
+00008720: 2020 2020 2020 6e6f 6465 4c69 7374 203d        nodeList =
+00008730: 205b 5d20 2020 2020 2020 2020 2020 236e   []           #n
+00008740: 6f64 6520 6e75 6d62 6572 206f 7220 7269  ode number or ri
+00008750: 6769 6420 6e6f 6465 2066 6f72 206c 696e  gid node for lin
+00008760: 6b0a 2020 2020 2020 2020 626f 6479 4c69  k.        bodyLi
+00008770: 7374 203d 205b 5d20 2020 2020 2020 2020  st = []         
+00008780: 2020 2362 6f64 7920 6e75 6d62 6572 206f    #body number o
+00008790: 7220 7269 6769 6420 626f 6479 2066 6f72  r rigid body for
+000087a0: 206c 696e 6b0a 2020 2020 2020 2020 6a6f   link.        jo
+000087b0: 696e 744c 6973 7420 3d20 5b5d 2020 2020  intList = []    
+000087c0: 2020 2020 2020 236a 6f69 6e74 2077 6869        #joint whi
+000087d0: 6368 206c 696e 6b73 2074 6f20 7072 6576  ch links to prev
+000087e0: 696f 7573 206c 696e 6b20 6f72 2062 6173  ious link or bas
+000087f0: 650a 2020 2020 2020 2020 6d61 726b 6572  e.        marker
+00008800: 4c69 7374 3020 3d20 5b5d 2020 2020 2020  List0 = []      
+00008810: 2020 2363 6f6e 7461 696e 7320 6e20 6d61    #contains n ma
+00008820: 726b 6572 206e 756d 6265 7273 2070 6572  rker numbers per
+00008830: 206c 696e 6b20 283d 626f 6479 2920 7768   link (=body) wh
+00008840: 6963 6820 636f 6e6e 6563 7420 746f 2070  ich connect to p
+00008850: 7265 7669 6f75 732f 6c65 6674 206c 696e  revious/left lin
+00008860: 6b0a 2020 2020 2020 2020 6d61 726b 6572  k.        marker
+00008870: 4c69 7374 3120 3d20 5b5d 2020 2020 2020  List1 = []      
+00008880: 2020 2363 6f6e 7461 696e 7320 6e20 6d61    #contains n ma
+00008890: 726b 6572 206e 756d 6265 7273 2070 6572  rker numbers per
+000088a0: 206c 696e 6b20 283d 626f 6479 2920 7768   link (=body) wh
+000088b0: 6963 6820 636f 6e6e 6563 7420 746f 206e  ich connect to n
+000088c0: 6578 742f 7269 6768 7420 6c69 6e6b 0a20  ext/right link. 
+000088d0: 2020 2020 2020 206a 6f69 6e74 546f 7271         jointTorq
+000088e0: 7565 304c 6973 7420 3d20 5b5d 2020 2023  ue0List = []   #
+000088f0: 6c6f 6164 206e 756d 6265 7220 6f66 206a  load number of j
+00008900: 6f69 6e74 2074 6f72 7175 6520 6174 2070  oint torque at p
+00008910: 7265 7669 6f75 732f 6c65 6674 206c 696e  revious/left lin
+00008920: 6b20 286e 6567 6174 6976 6529 3b20 0a20  k (negative); . 
+00008930: 2020 2020 2020 206a 6f69 6e74 546f 7271         jointTorq
+00008940: 7565 314c 6973 7420 3d20 5b5d 2020 2023  ue1List = []   #
+00008950: 6c6f 6164 206e 756d 6265 7220 6f66 206a  load number of j
+00008960: 6f69 6e74 2074 6f72 7175 6520 6174 206e  oint torque at n
+00008970: 6578 742f 7269 6768 7420 6c69 6e6b 2028  ext/right link (
+00008980: 706f 7369 7469 7665 290a 2020 2020 2020  positive).      
+00008990: 2020 756e 6974 546f 7271 7565 304c 6973    unitTorque0Lis
+000089a0: 7420 3d20 5b5d 2020 2020 2363 6f6e 7461  t = []    #conta
+000089b0: 696e 7320 756e 6974 2074 6f72 7175 6530  ins unit torque0
+000089c0: 2028 7072 6576 696f 7573 2f6c 6566 7420   (previous/left 
+000089d0: 6c69 6e6b 2920 666f 7220 6a6f 696e 7420  link) for joint 
+000089e0: 692c 2073 686f 756c 6420 6265 206d 756c  i, should be mul
+000089f0: 7469 706c 6965 6420 7769 7468 2061 6363  tiplied with acc
+00008a00: 6f72 6469 6e67 2066 6163 746f 7220 746f  ording factor to
+00008a10: 2072 6570 7265 7365 6e74 206a 6f69 6e74   represent joint
+00008a20: 2074 6f72 7175 650a 2020 2020 2020 2020   torque.        
+00008a30: 756e 6974 546f 7271 7565 314c 6973 7420  unitTorque1List 
+00008a40: 3d20 5b5d 2020 2020 2363 6f6e 7461 696e  = []    #contain
+00008a50: 7320 756e 6974 2074 6f72 7175 6531 2028  s unit torque1 (
+00008a60: 6e65 7874 2f72 6967 6874 206c 696e 6b29  next/right link)
+00008a70: 2066 6f72 206a 6f69 6e74 2069 2c20 7368   for joint i, sh
+00008a80: 6f75 6c64 2062 6520 6d75 6c74 6970 6c69  ould be multipli
+00008a90: 6564 2077 6974 6820 6163 636f 7264 696e  ed with accordin
+00008aa0: 6720 6661 6374 6f72 2074 6f20 7265 7072  g factor to repr
+00008ab0: 6573 656e 7420 6a6f 696e 7420 746f 7271  esent joint torq
+00008ac0: 7565 0a20 2020 2020 2020 2073 7072 696e  ue.        sprin
+00008ad0: 6744 616d 7065 724c 6973 7420 3d20 5b5d  gDamperList = []
+00008ae0: 2020 2023 636f 6e74 6169 6e73 2074 6f72     #contains tor
+00008af0: 7369 6f6e 616c 206f 7220 6c69 6e65 6172  sional or linear
+00008b00: 2073 7072 696e 6720 6461 6d70 6572 7320   spring dampers 
+00008b10: 666f 7220 636f 6e74 726f 6c20 6f66 206a  for control of j
+00008b20: 6f69 6e74 2061 7865 730a 2020 2020 2020  oint axes.      
+00008b30: 2020 0a20 2020 2020 2020 2048 546c 6973    .        HTlis
+00008b40: 7420 3d20 5b5d 2023 6c69 7374 206f 6620  t = [] #list of 
+00008b50: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
+00008b60: 7366 6f72 6d61 7469 6f6e 7320 666f 7220  sformations for 
+00008b70: 6c69 6e6b 7320 7374 6f72 6564 2028 666f  links stored (fo
+00008b80: 7220 7061 7265 6e74 206c 696e 6b20 7265  r parent link re
+00008b90: 6c61 7469 6f6e 2069 6e20 7472 6565 290a  lation in tree).
+00008ba0: 0a20 2020 2020 2020 2023 6465 6c65 7465  .        #delete
+00008bb0: 3a20 6c61 7374 4d61 726b 6572 203d 2062  : lastMarker = b
+00008bc0: 6173 654d 6172 6b65 720a 2020 2020 2020  aseMarker.      
+00008bd0: 2020 6c61 7374 4d61 726b 6572 526f 7461    lastMarkerRota
+00008be0: 7469 6f6e 203d 206e 702e 6964 656e 7469  tion = np.identi
+00008bf0: 7479 2833 2920 2362 6173 6520 726f 7461  ty(3) #base rota
+00008c00: 7469 6f6e 2069 6e63 6c75 6465 6420 696e  tion included in
+00008c10: 206d 6172 6b65 720a 2020 2020 2020 2020   marker.        
+00008c20: 6966 2072 6f74 6174 696f 6e4d 6172 6b65  if rotationMarke
+00008c30: 7242 6173 6520 213d 204e 6f6e 653a 0a20  rBase != None:. 
+00008c40: 2020 2020 2020 2020 2020 206c 6173 744d             lastM
+00008c50: 6172 6b65 7252 6f74 6174 696f 6e20 3d20  arkerRotation = 
+00008c60: 726f 7461 7469 6f6e 4d61 726b 6572 4261  rotationMarkerBa
+00008c70: 7365 0a20 2020 2020 2020 2020 2020 200a  se.            .
+00008c80: 2020 2020 2020 2020 7152 6566 203d 2073          qRef = s
+00008c90: 656c 662e 7265 6665 7265 6e63 6543 6f6e  elf.referenceCon
+00008ca0: 6669 6775 7261 7469 6f6e 0a20 2020 2020  figuration.     
+00008cb0: 2020 200a 2020 2020 2020 2020 6261 7365     .        base
+00008cc0: 4f62 6a65 6374 203d 202d 3120 2369 6620  Object = -1 #if 
+00008cd0: 6974 2064 6f65 7320 6e6f 7420 6578 6973  it does not exis
+00008ce0: 740a 2020 2020 2020 2020 6966 2073 656c  t.        if sel
+00008cf0: 662e 6261 7365 2e76 6973 7561 6c69 7a61  f.base.visualiza
+00008d00: 7469 6f6e 2e67 7261 7068 6963 7344 6174  tion.graphicsDat
+00008d10: 6120 213d 205b 5d3a 0a20 2020 2020 2020  a != []:.       
+00008d20: 2020 2020 2023 6164 6420 6120 6772 6f75       #add a grou
+00008d30: 6e64 206f 626a 6563 7420 6174 2062 6173  nd object at bas
+00008d40: 6520 706f 7369 7469 6f6e 0a20 2020 2020  e position.     
+00008d50: 2020 2020 2020 2067 7261 7068 6963 7344         graphicsD
+00008d60: 6174 6142 6173 6520 3d20 5b5d 0a20 2020  ataBase = [].   
+00008d70: 2020 2020 2020 2020 2070 4f66 6620 3d20           pOff = 
+00008d80: 6572 622e 4854 3274 7261 6e73 6c61 7469  erb.HT2translati
+00008d90: 6f6e 2873 656c 662e 6261 7365 2e48 5429  on(self.base.HT)
+00008da0: 0a20 2020 2020 2020 2020 2020 2041 6f66  .            Aof
+00008db0: 6620 3d20 6572 622e 4854 3272 6f74 6174  f = erb.HT2rotat
+00008dc0: 696f 6e4d 6174 7269 7828 7365 6c66 2e62  ionMatrix(self.b
+00008dd0: 6173 652e 4854 290a 2020 2020 2020 2020  ase.HT).        
+00008de0: 2020 2020 666f 7220 6461 7461 2069 6e20      for data in 
+00008df0: 7365 6c66 2e62 6173 652e 7669 7375 616c  self.base.visual
+00008e00: 697a 6174 696f 6e2e 6772 6170 6869 6373  ization.graphics
+00008e10: 4461 7461 3a0a 2020 2020 2020 2020 2020  Data:.          
+00008e20: 2020 2020 2020 6772 6170 6869 6373 4461        graphicsDa
+00008e30: 7461 4261 7365 202b 3d20 5b65 6764 2e4d  taBase += [egd.M
+00008e40: 6f76 6547 7261 7068 6963 7344 6174 6128  oveGraphicsData(
+00008e50: 6461 7461 2c20 5b30 2c30 2c30 5d2c 2041  data, [0,0,0], A
+00008e60: 6f66 6629 5d20 236f 6e6c 7920 726f 7461  off)] #only rota
+00008e70: 7465 642c 2074 7261 6e73 6c61 7469 6f6e  ted, translation
+00008e80: 2069 7320 696e 2067 726f 756e 640a 0a20   is in ground.. 
+00008e90: 2020 2020 2020 2020 2020 2062 6173 654f             baseO
+00008ea0: 626a 6563 7420 3d20 6d62 732e 4164 644f  bject = mbs.AddO
+00008eb0: 626a 6563 7428 6569 692e 4f62 6a65 6374  bject(eii.Object
+00008ec0: 4772 6f75 6e64 2872 6566 6572 656e 6365  Ground(reference
+00008ed0: 506f 7369 7469 6f6e 3d70 4f66 662c 200a  Position=pOff, .
+00008ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f10: 2020 2020 7669 7375 616c 697a 6174 696f      visualizatio
+00008f20: 6e3d 6569 692e 564f 626a 6563 7447 726f  n=eii.VObjectGro
+00008f30: 756e 6428 6772 6170 6869 6373 4461 7461  und(graphicsData
+00008f40: 3d67 7261 7068 6963 7344 6174 6142 6173  =graphicsDataBas
+00008f50: 6529 2929 0a0a 2020 2020 2020 2020 2363  e)))..        #c
+00008f60: 7265 6174 6520 6c69 7374 206f 6620 696e  reate list of in
+00008f70: 6469 6365 7320 746f 206e 6578 7420 6c69  dices to next li
+00008f80: 6e6b 730a 2020 2020 2020 2020 6e65 7874  nks.        next
+00008f90: 4c69 6e6b 7320 3d20 5b4e 6f6e 655d 2a73  Links = [None]*s
+00008fa0: 656c 662e 4e75 6d62 6572 4f66 4c69 6e6b  elf.NumberOfLink
+00008fb0: 7328 290a 2020 2020 2020 2020 666f 7220  s().        for 
+00008fc0: 6920 696e 2072 616e 6765 2873 656c 662e  i in range(self.
+00008fd0: 4e75 6d62 6572 4f66 4c69 6e6b 7328 2929  NumberOfLinks())
+00008fe0: 3a0a 2020 2020 2020 2020 2020 2020 6e65  :.            ne
+00008ff0: 7874 4c69 6e6b 735b 695d 203d 205b 5d0a  xtLinks[i] = [].
+00009000: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+00009010: 203d 2073 656c 662e 6c69 6e6b 735b 695d   = self.links[i]
+00009020: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00009030: 7365 6c66 2e47 6574 5061 7265 6e74 496e  self.GetParentIn
+00009040: 6465 7828 6929 2021 3d20 2d31 3a0a 2020  dex(i) != -1:.  
+00009050: 2020 2020 2020 2020 2020 2020 206e 6578               nex
+00009060: 744c 696e 6b73 5b73 656c 662e 4765 7450  tLinks[self.GetP
+00009070: 6172 656e 7449 6e64 6578 2869 295d 202b  arentIndex(i)] +
+00009080: 3d20 5b69 5d0a 2020 2020 2020 2020 2020  = [i].          
+00009090: 2020 2020 2020 0a20 2020 2020 2020 2023        .        #
+000090a0: 6372 6561 7465 2072 6f62 6f74 206e 6f64  create robot nod
+000090b0: 6573 2061 6e64 2062 6f64 6965 733a 0a20  es and bodies:. 
+000090c0: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+000090d0: 7261 6e67 6528 6c65 6e28 7365 6c66 2e6c  range(len(self.l
+000090e0: 696e 6b73 2929 3a0a 2020 2020 2020 2020  inks)):.        
+000090f0: 2020 2020 6c69 6e6b 203d 2073 656c 662e      link = self.
+00009100: 6c69 6e6b 735b 695d 0a20 2020 2020 2020  links[i].       
+00009110: 2020 2020 2069 6620 6c69 6e6b 2e6a 6f69       if link.joi
+00009120: 6e74 5479 7065 206e 6f74 2069 6e20 6469  ntType not in di
+00009130: 6374 4a6f 696e 7454 7970 6532 4178 6973  ctJointType2Axis
+00009140: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00009150: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00009160: 6f72 2827 4372 6561 7465 5265 6475 6e64  or('CreateRedund
+00009170: 616e 7443 6f6f 7264 696e 6174 654d 4253  antCoordinateMBS
+00009180: 3a20 666f 756e 6420 696e 7661 6c69 6420  : found invalid 
+00009190: 6a6f 696e 7420 7479 7065 2069 6e20 6c69  joint type in li
+000091a0: 6e6b 2027 2b73 7472 2869 292b 273a 272b  nk '+str(i)+':'+
+000091b0: 6c69 6e6b 2e6a 6f69 6e74 5479 7065 290a  link.jointType).
+000091c0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+000091d0: 200a 2020 2020 2020 2020 2020 2020 2320   .            # 
+000091e0: 5430 3120 3d20 4448 3248 5428 4448 7061  T01 = DH2HT(DHpa
+000091f0: 7261 6d29 2023 7472 616e 7366 6f72 6d61  ram) #transforma
+00009200: 7469 6f6e 2066 726f 6d20 6c61 7374 206c  tion from last l
+00009210: 696e 6b20 746f 2074 6869 7320 6c69 6e6b  ink to this link
+00009220: 3b20 6974 2064 6566 696e 6573 2074 6865  ; it defines the
+00009230: 206f 7269 656e 7461 7469 6f6e 206f 6620   orientation of 
+00009240: 7468 6520 626f 6479 0a20 2020 2020 2020  the body.       
+00009250: 2020 2020 2054 3031 203d 206c 696e 6b2e       T01 = link.
+00009260: 7072 6548 5420 4020 6469 6374 4a6f 696e  preHT @ dictJoin
+00009270: 7454 7970 6532 4854 5b6c 696e 6b2e 6a6f  tType2HT[link.jo
+00009280: 696e 7454 7970 655d 2871 5265 665b 695d  intType](qRef[i]
+00009290: 2920 4020 6c69 6e6b 2e6c 6f63 616c 4854  ) @ link.localHT
+000092a0: 2023 6e65 7720 626f 6469 6573 2061 7265   #new bodies are
+000092b0: 2070 6c61 6365 6420 6174 206f 7269 6769   placed at origi
+000092c0: 6e20 6f66 206c 696e 6b20 6672 616d 650a  n of link frame.
+000092d0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+000092e0: 6f74 2073 656c 662e 4861 7350 6172 656e  ot self.HasParen
+000092f0: 7428 6929 3a0a 2020 2020 2020 2020 2020  t(i):.          
+00009300: 2020 2020 2020 5463 7572 7265 6e74 203d        Tcurrent =
+00009310: 2073 656c 662e 4765 7442 6173 6548 5428   self.GetBaseHT(
+00009320: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+00009330: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00009340: 2020 2020 5463 7572 7265 6e74 203d 2048      Tcurrent = H
+00009350: 546c 6973 745b 7365 6c66 2e47 6574 5061  Tlist[self.GetPa
+00009360: 7265 6e74 496e 6465 7828 6929 5d0a 0a20  rentIndex(i)].. 
+00009370: 2020 2020 2020 2020 2020 2054 6375 7272             Tcurr
+00009380: 656e 7420 3d20 5463 7572 7265 6e74 2040  ent = Tcurrent @
+00009390: 2054 3031 0a20 2020 2020 2020 2020 2020   T01.           
+000093a0: 2048 546c 6973 7420 2b3d 205b 636f 7079   HTlist += [copy
+000093b0: 2854 6375 7272 656e 7429 5d0a 0a20 2020  (Tcurrent)]..   
+000093c0: 2020 2020 2020 2020 2023 2b2b 2b2b 2b2b           #++++++
+000093d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000093e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000093f0: 2b2b 2b2b 2b2b 2b2b 0a20 2020 2020 2020  ++++++++.       
+00009400: 200a 2020 2020 2020 2020 2020 2020 6c6f   .            lo
+00009410: 6361 6c48 5469 6e76 203d 2065 7262 2e49  calHTinv = erb.I
+00009420: 6e76 6572 7365 4854 286c 696e 6b2e 6c6f  nverseHT(link.lo
+00009430: 6361 6c48 5429 0a20 2020 2020 2020 2020  calHT).         
+00009440: 2020 2041 7468 6973 5420 3d20 6572 622e     AthisT = erb.
+00009450: 4854 3272 6f74 6174 696f 6e4d 6174 7269  HT2rotationMatri
+00009460: 7828 6c6f 6361 6c48 5469 6e76 2920 2374  x(localHTinv) #t
+00009470: 7261 6e73 666f 726d 7320 6261 636b 2074  ransforms back t
+00009480: 6f20 6a6f 696e 7430 0a20 2020 2020 2020  o joint0.       
+00009490: 2020 2020 2070 5468 6973 203d 2020 6572       pThis =  er
+000094a0: 622e 4854 3274 7261 6e73 6c61 7469 6f6e  b.HT2translation
+000094b0: 286c 6f63 616c 4854 696e 7629 2023 4174  (localHTinv) #At
+000094c0: 6869 7354 2040 206e 702e 6172 7261 7928  hisT @ np.array(
+000094d0: 5b2d 612c 302c 2d64 5d29 2023 6e65 6564  [-a,0,-d]) #need
+000094e0: 6564 2066 6f72 206d 6172 6b65 7220 6f66  ed for marker of
+000094f0: 206e 6578 7420 6c69 6e6b 0a20 2020 2020   next link.     
+00009500: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00009510: 2020 2020 2363 6f6d 7075 7465 2061 7869      #compute axi
+00009520: 7320 6f66 2070 7265 7669 6f75 7320 6c69  s of previous li
+00009530: 6e6b 2c20 666f 7220 7374 6420 4448 2c20  nk, for std DH, 
+00009540: 7468 6973 2069 7320 7472 616e 7366 6f72  this is transfor
+00009550: 6d65 6420 6261 636b 2074 6f20 7072 6576  med back to prev
+00009560: 696f 7573 206a 6f69 6e74 0a20 2020 2020  ious joint.     
+00009570: 2020 2020 2020 206a 6f69 6e74 4178 6973         jointAxis
+00009580: 203d 2064 6963 744a 6f69 6e74 5479 7065   = dictJointType
+00009590: 3241 7869 735b 6c69 6e6b 2e6a 6f69 6e74  2Axis[link.joint
+000095a0: 5479 7065 5d0a 2020 2020 2020 2020 2020  Type].          
+000095b0: 2020 6178 6973 3020 3d20 4174 6869 7354    axis0 = AthisT
+000095c0: 2040 206a 6f69 6e74 4178 6973 2023 666f   @ jointAxis #fo
+000095d0: 7220 6472 6177 696e 670a 2020 2020 2020  r drawing.      
+000095e0: 2020 2020 2020 232b 2b2b 2b2b 2b2b 2b2b        #+++++++++
+000095f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00009600: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00009610: 2b2b 2b2b 2b0a 2020 2020 2020 2020 2020  +++++.          
+00009620: 2020 0a20 2020 2020 2020 2020 2020 200a    .            .
+00009630: 2020 2020 2020 2020 2020 2020 2372 6967              #rig
+00009640: 6964 2062 6f64 7920 7061 7261 6d65 7465  id body paramete
+00009650: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
+00009660: 636f 6d20 3d20 6c69 6e6b 2e43 4f4d 2023  com = link.COM #
+00009670: 6973 2064 6566 696e 6564 2077 6974 6869  is defined withi
+00009680: 6e20 6c69 6e6b 3d3d 626f 6479 2066 7261  n link==body fra
+00009690: 6d65 0a20 2020 2020 2020 200a 2020 2020  me.        .    
+000096a0: 2020 2020 2020 2020 696e 6572 7469 614c          inertiaL
+000096b0: 696e 6b20 3d20 6572 622e 5269 6769 6442  ink = erb.RigidB
+000096c0: 6f64 7949 6e65 7274 6961 286d 6173 733d  odyInertia(mass=
+000096d0: 6c69 6e6b 2e6d 6173 732c 2069 6e65 7274  link.mass, inert
+000096e0: 6961 5465 6e73 6f72 3d6c 696e 6b2e 696e  iaTensor=link.in
+000096f0: 6572 7469 6129 0a20 2020 2020 2020 2020  ertia).         
+00009700: 2020 2069 6e65 7274 6961 4c69 6e6b 203d     inertiaLink =
+00009710: 2069 6e65 7274 6961 4c69 6e6b 2e54 7261   inertiaLink.Tra
+00009720: 6e73 6c61 7465 6428 636f 6d29 2023 6e65  nslated(com) #ne
+00009730: 6564 7320 746f 2062 6520 7265 636f 6d70  eds to be recomp
+00009740: 7574 6564 2c20 6265 6361 7573 6520 696e  uted, because in
+00009750: 6572 7469 6120 696e 2052 6f62 6f74 2069  ertia in Robot i
+00009760: 7320 772e 722e 742e 2043 4f4d 2c20 6275  s w.r.t. COM, bu
+00009770: 7420 4f62 6a65 6374 5269 6769 6442 6f64  t ObjectRigidBod
+00009780: 7920 6e65 6564 7320 696e 6572 7469 6120  y needs inertia 
+00009790: 666f 7220 7265 6665 7265 6e63 6520 706f  for reference po
+000097a0: 696e 740a 2020 2020 2020 2020 2020 2020  int.            
+000097b0: 0a20 2020 2020 2020 2020 2020 2023 2b2b  .            #++
+000097c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000097d0: 2b2b 2b2b 2b2b 0a20 2020 2020 2020 2020  ++++++.         
+000097e0: 2020 2023 636f 6d70 7574 6520 6178 6973     #compute axis
+000097f0: 3120 7265 6c61 7465 6420 746f 206e 6578  1 related to nex
+00009800: 7420 6c69 6e6b 2028 666f 7220 7374 6420  t link (for std 
+00009810: 4448 2c20 7468 6973 2069 7320 6c6f 6361  DH, this is loca
+00009820: 6c20 7a2d 6178 6973 2069 6e20 6c69 6e6b  l z-axis in link
+00009830: 2063 6f6f 7264 696e 6174 6573 290a 2020   coordinates).  
+00009840: 2020 2020 2020 2020 2020 6772 6170 6869            graphi
+00009850: 6373 4c69 7374 203d 205b 5d0a 2020 2020  csList = [].    
+00009860: 2020 2020 2020 2020 666f 7220 6e65 7874          for next
+00009870: 4c69 6e6b 496e 6465 7820 696e 206e 6578  LinkIndex in nex
+00009880: 744c 696e 6b73 5b69 5d3a 0a20 2020 2020  tLinks[i]:.     
+00009890: 2020 2020 2020 2020 2020 2023 2069 6620             # if 
+000098a0: 6920 3d3d 206c 656e 2873 656c 662e 6c69  i == len(self.li
+000098b0: 6e6b 7329 2d31 3a0a 2020 2020 2020 2020  nks)-1:.        
+000098c0: 2020 2020 2020 2020 2320 2020 2020 704e          #     pN
+000098d0: 6578 7420 3d20 6e70 2e61 7272 6179 285b  ext = np.array([
+000098e0: 302c 302c 302e 5d29 2023 7573 6520 6c6f  0,0,0.]) #use lo
+000098f0: 6361 6c20 706f 7369 7469 6f6e 2066 6f72  cal position for
+00009900: 2066 696e 616c 206c 696e 6b0a 2020 2020   final link.    
+00009910: 2020 2020 2020 2020 2020 2020 2320 2020              #   
+00009920: 2020 6178 6973 4e65 7874 3d6e 702e 6172    axisNext=np.ar
+00009930: 7261 7928 5b30 2c30 2c30 5d29 2023 6e6f  ray([0,0,0]) #no
+00009940: 2061 7869 7320 746f 2064 7261 7720 666f   axis to draw fo
+00009950: 7220 6c61 7374 206c 696e 6b0a 2020 2020  r last link.    
+00009960: 2020 2020 2020 2020 2020 2020 6e65 7874              next
+00009970: 4c69 6e6b 203d 2073 656c 662e 6c69 6e6b  Link = self.link
+00009980: 735b 6e65 7874 4c69 6e6b 496e 6465 785d  s[nextLinkIndex]
+00009990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000099a0: 2070 4e65 7874 203d 2065 7262 2e48 5432   pNext = erb.HT2
+000099b0: 7472 616e 736c 6174 696f 6e28 6e65 7874  translation(next
+000099c0: 4c69 6e6b 2e70 7265 4854 2920 2374 6869  Link.preHT) #thi
+000099d0: 7320 6465 6669 6e65 7320 7468 6520 706f  s defines the po
+000099e0: 7369 7469 6f6e 2066 6f72 2074 6865 206c  sition for the l
+000099f0: 6f63 616c 206f 6620 7468 6520 6178 6973  ocal of the axis
+00009a00: 2066 6f72 206e 6578 7420 6c69 6e6b 0a20   for next link. 
+00009a10: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00009a20: 7869 734e 6578 7420 3d20 6572 622e 4854  xisNext = erb.HT
+00009a30: 3272 6f74 6174 696f 6e4d 6174 7269 7828  2rotationMatrix(
+00009a40: 6e65 7874 4c69 6e6b 2e70 7265 4854 2920  nextLink.preHT) 
+00009a50: 4020 6469 6374 4a6f 696e 7454 7970 6532  @ dictJointType2
+00009a60: 4178 6973 5b6e 6578 744c 696e 6b2e 6a6f  Axis[nextLink.jo
+00009a70: 696e 7454 7970 655d 200a 0a20 2020 2020  intType] ..     
+00009a80: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+00009a90: 6e28 6c69 6e6b 2e76 6973 7561 6c69 7a61  n(link.visualiza
+00009aa0: 7469 6f6e 2e67 7261 7068 6963 7344 6174  tion.graphicsDat
+00009ab0: 6129 203d 3d20 303a 0a20 2020 2020 2020  a) == 0:.       
+00009ac0: 2020 2020 2020 2020 2020 2020 2067 7261               gra
+00009ad0: 7068 6963 734c 6973 7420 2b3d 2073 656c  phicsList += sel
+00009ae0: 662e 4765 744c 696e 6b47 7261 7068 6963  f.GetLinkGraphic
+00009af0: 7344 6174 6128 692c 2070 5468 6973 2c20  sData(i, pThis, 
+00009b00: 704e 6578 742c 2061 7869 7330 2c20 6178  pNext, axis0, ax
+00009b10: 6973 4e65 7874 2c20 6c69 6e6b 2e76 6973  isNext, link.vis
+00009b20: 7561 6c69 7a61 7469 6f6e 290a 0a20 2020  ualization)..   
+00009b30: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+00009b40: 6c69 6e6b 2e76 6973 7561 6c69 7a61 7469  link.visualizati
+00009b50: 6f6e 2e67 7261 7068 6963 7344 6174 6129  on.graphicsData)
+00009b60: 2021 3d20 303a 0a20 2020 2020 2020 2020   != 0:.         
+00009b70: 2020 2020 2020 2067 7261 7068 6963 734c         graphicsL
+00009b80: 6973 7420 2b3d 206c 696e 6b2e 7669 7375  ist += link.visu
+00009b90: 616c 697a 6174 696f 6e2e 6772 6170 6869  alization.graphi
+00009ba0: 6373 4461 7461 0a0a 2020 2020 2020 2020  csData..        
+00009bb0: 2020 2020 2361 6464 2074 7261 6e73 666f      #add transfo
+00009bc0: 726d 6564 2067 7261 7068 6963 7344 6174  rmed graphicsDat
+00009bd0: 6120 6f66 2074 6f6f 6c20 746f 206c 696e  a of tool to lin
+00009be0: 6b20 6772 6170 6869 6373 0a20 2020 2020  k graphics.     
+00009bf0: 2020 2020 2020 2069 6620 2869 3d3d 6c65         if (i==le
+00009c00: 6e28 7365 6c66 2e6c 696e 6b73 292d 3120  n(self.links)-1 
+00009c10: 616e 6420 2374 6f6f 6c0a 2020 2020 2020  and #tool.      
+00009c20: 2020 2020 2020 2020 2020 7365 6c66 2e74            self.t
+00009c30: 6f6f 6c2e 7669 7375 616c 697a 6174 696f  ool.visualizatio
+00009c40: 6e2e 6772 6170 6869 6373 4461 7461 2021  n.graphicsData !
+00009c50: 3d20 5b5d 293a 0a20 2020 2020 2020 2020  = []):.         
+00009c60: 2020 2020 2020 2070 4f66 6620 3d20 6572         pOff = er
+00009c70: 622e 4854 3274 7261 6e73 6c61 7469 6f6e  b.HT2translation
+00009c80: 2873 656c 662e 746f 6f6c 2e48 5429 0a20  (self.tool.HT). 
+00009c90: 2020 2020 2020 2020 2020 2020 2020 2041                 A
+00009ca0: 6f66 6620 3d20 6572 622e 4854 3272 6f74  off = erb.HT2rot
+00009cb0: 6174 696f 6e4d 6174 7269 7828 7365 6c66  ationMatrix(self
+00009cc0: 2e74 6f6f 6c2e 4854 290a 2020 2020 2020  .tool.HT).      
+00009cd0: 2020 2020 2020 2020 2020 666f 7220 6461            for da
+00009ce0: 7461 2069 6e20 7365 6c66 2e74 6f6f 6c2e  ta in self.tool.
+00009cf0: 7669 7375 616c 697a 6174 696f 6e2e 6772  visualization.gr
+00009d00: 6170 6869 6373 4461 7461 3a0a 2020 2020  aphicsData:.    
+00009d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d20: 6772 6170 6869 6373 4c69 7374 202b 3d20  graphicsList += 
+00009d30: 5b65 6764 2e4d 6f76 6547 7261 7068 6963  [egd.MoveGraphic
+00009d40: 7344 6174 6128 6461 7461 2c20 704f 6666  sData(data, pOff
+00009d50: 2c20 416f 6666 295d 200a 0a20 2020 2020  , Aoff)] ..     
+00009d60: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00009d70: 2020 2020 232b 2b2b 2b2b 2b2b 2b2b 2b2b      #+++++++++++
+00009d80: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0a 2020  +++++++++++++.  
+00009d90: 2020 2020 2020 2020 2020 236e 6f77 2061            #now a
+00009da0: 6464 2062 6f64 7920 666f 7220 6c69 6e6b  dd body for link
+00009db0: 3a0a 2020 2020 2020 2020 2020 2020 5b6e  :.            [n
+00009dc0: 4c69 6e6b 2c62 4c69 6e6b 5d3d 6572 622e  Link,bLink]=erb.
+00009dd0: 4164 6452 6967 6964 426f 6479 286d 6169  AddRigidBody(mai
+00009de0: 6e53 7973 203d 206d 6273 2c20 696e 6572  nSys = mbs, iner
+00009df0: 7469 613d 696e 6572 7469 614c 696e 6b2c  tia=inertiaLink,
+00009e00: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+00009e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e20: 2020 6e6f 6465 5479 7065 3d72 6967 6964    nodeType=rigid
+00009e30: 426f 6479 4e6f 6465 5479 7065 2c20 2327  BodyNodeType, #'
+00009e40: 4e6f 6465 5479 7065 2e52 6f74 6174 696f  NodeType.Rotatio
+00009e50: 6e45 756c 6572 5061 7261 6d65 7465 7273  nEulerParameters
+00009e60: 272c 200a 2020 2020 2020 2020 2020 2020  ', .            
+00009e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e80: 2020 2020 706f 7369 7469 6f6e 3d65 7262      position=erb
+00009e90: 2e48 5432 7472 616e 736c 6174 696f 6e28  .HT2translation(
+00009ea0: 5463 7572 7265 6e74 292c 200a 2020 2020  Tcurrent), .    
+00009eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ec0: 2020 2020 2020 2020 2020 2020 726f 7461              rota
+00009ed0: 7469 6f6e 4d61 7472 6978 203d 2065 7262  tionMatrix = erb
+00009ee0: 2e48 5432 726f 7461 7469 6f6e 4d61 7472  .HT2rotationMatr
+00009ef0: 6978 2854 6375 7272 656e 7429 2c0a 2020  ix(Tcurrent),.  
+00009f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f10: 2020 2020 2020 2020 2020 2020 2020 6772                gr
+00009f20: 6176 6974 793d 7365 6c66 2e67 7261 7669  avity=self.gravi
+00009f30: 7479 2c20 0a20 2020 2020 2020 2020 2020  ty, .           
+00009f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f50: 2020 2020 2067 7261 7068 6963 7344 6174       graphicsDat
+00009f60: 614c 6973 743d 6772 6170 6869 6373 4c69  aList=graphicsLi
+00009f70: 7374 290a 2020 2020 2020 2020 2020 2020  st).            
+00009f80: 6e6f 6465 4c69 7374 2b3d 5b6e 4c69 6e6b  nodeList+=[nLink
+00009f90: 5d0a 2020 2020 2020 2020 2020 2020 626f  ].            bo
+00009fa0: 6479 4c69 7374 2b3d 5b62 4c69 6e6b 5d0a  dyList+=[bLink].
+00009fb0: 2020 2020 2020 2020 2020 2020 2370 7269              #pri
+00009fc0: 6e74 286d 6273 2e47 6574 4f62 6a65 6374  nt(mbs.GetObject
+00009fd0: 2862 4c69 6e6b 2929 0a20 2020 2020 2020  (bLink)).       
+00009fe0: 200a 2020 2020 2020 2020 2020 2020 232b   .            #+
+00009ff0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000a000: 2b2b 2b2b 2b2b 2b0a 2020 2020 2020 2020  +++++++.        
+0000a010: 2020 2020 2361 6464 206d 6172 6b65 7273      #add markers
+0000a020: 2061 6e64 206a 6f69 6e74 730a 2020 2020   and joints.    
+0000a030: 2020 2020 2020 2020 6d4c 696e 6b31 203d          mLink1 =
+0000a040: 206d 6273 2e41 6464 4d61 726b 6572 2865   mbs.AddMarker(e
+0000a050: 6969 2e4d 6172 6b65 7242 6f64 7952 6967  ii.MarkerBodyRig
+0000a060: 6964 2862 6f64 794e 756d 6265 723d 624c  id(bodyNumber=bL
+0000a070: 696e 6b2c 206c 6f63 616c 506f 7369 7469  ink, localPositi
+0000a080: 6f6e 3d70 5468 6973 2929 0a20 2020 2020  on=pThis)).     
+0000a090: 2020 2020 2020 2023 206d 6172 6b65 7250         # markerP
+0000a0a0: 6f73 6974 696f 6e4c 696e 6b31 6e65 7874  ositionLink1next
+0000a0b0: 203d 205b 302c 302c 305d 2023 6e6f 7420   = [0,0,0] #not 
+0000a0c0: 7573 6564 2069 6e20 6c61 7374 206c 696e  used in last lin
+0000a0d0: 6b21 0a20 2020 2020 2020 2020 2020 2023  k!.            #
+0000a0e0: 2069 6620 6920 3c20 6c65 6e28 7365 6c66   if i < len(self
+0000a0f0: 2e6c 696e 6b73 292d 313a 0a20 2020 2020  .links)-1:.     
+0000a100: 2020 2020 2020 2023 2020 2020 206d 6172         #     mar
+0000a110: 6b65 7250 6f73 6974 696f 6e4c 696e 6b31  kerPositionLink1
+0000a120: 6e65 7874 203d 2065 7262 2e48 5432 7472  next = erb.HT2tr
+0000a130: 616e 736c 6174 696f 6e28 7365 6c66 2e6c  anslation(self.l
+0000a140: 696e 6b73 5b69 2b31 5d2e 7072 6548 5429  inks[i+1].preHT)
+0000a150: 2023 7468 6973 2069 7320 6465 6669 6e65   #this is define
+0000a160: 6420 696e 2074 6865 206e 6578 7420 6c69  d in the next li
+0000a170: 6e6b 210a 2020 2020 2020 2020 2020 2020  nk!.            
+0000a180: 2320 6d6c 696e 6b31 6e65 7874 203d 206d  # mlink1next = m
+0000a190: 6273 2e41 6464 4d61 726b 6572 2865 6969  bs.AddMarker(eii
+0000a1a0: 2e4d 6172 6b65 7242 6f64 7952 6967 6964  .MarkerBodyRigid
+0000a1b0: 2862 6f64 794e 756d 6265 723d 624c 696e  (bodyNumber=bLin
+0000a1c0: 6b2c 200a 2020 2020 2020 2020 2020 2020  k, .            
+0000a1d0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+0000a1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1f0: 2020 2020 2020 2020 2020 2020 206c 6f63               loc
+0000a200: 616c 506f 7369 7469 6f6e 3d6d 6172 6b65  alPosition=marke
+0000a210: 7250 6f73 6974 696f 6e4c 696e 6b31 6e65  rPositionLink1ne
+0000a220: 7874 2929 0a0a 2020 2020 2020 2020 2020  xt))..          
+0000a230: 2020 6966 2069 203d 3d20 303a 0a20 2020    if i == 0:.   
+0000a240: 2020 2020 2020 2020 2020 2020 206c 6173               las
+0000a250: 744d 6172 6b65 7252 6f74 6174 696f 6e20  tMarkerRotation 
+0000a260: 3d20 6572 622e 4854 3272 6f74 6174 696f  = erb.HT2rotatio
+0000a270: 6e4d 6174 7269 7828 6c69 6e6b 2e70 7265  nMatrix(link.pre
+0000a280: 4854 2940 6c61 7374 4d61 726b 6572 526f  HT)@lastMarkerRo
+0000a290: 7461 7469 6f6e 2023 6973 2072 6f74 6174  tation #is rotat
+0000a2a0: 696f 6e4d 6172 6b65 7242 6173 650a 2020  ionMarkerBase.  
+0000a2b0: 2020 2020 2020 2020 2020 2020 2020 6d4c                mL
+0000a2c0: 696e 6b30 4c61 7374 426f 6479 203d 2062  ink0LastBody = b
+0000a2d0: 6173 654d 6172 6b65 720a 2020 2020 2020  aseMarker.      
+0000a2e0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000a2f0: 2020 2020 2020 2020 2020 2020 6c61 7374              last
+0000a300: 4d61 726b 6572 526f 7461 7469 6f6e 203d  MarkerRotation =
+0000a310: 2065 7262 2e48 5432 726f 7461 7469 6f6e   erb.HT2rotation
+0000a320: 4d61 7472 6978 286c 696e 6b2e 7072 6548  Matrix(link.preH
+0000a330: 5429 0a20 2020 2020 2020 2020 2020 2020  T).             
+0000a340: 2020 206d 6172 6b65 7230 506f 7369 7469     marker0Positi
+0000a350: 6f6e 203d 2065 7262 2e48 5432 7472 616e  on = erb.HT2tran
+0000a360: 736c 6174 696f 6e28 6c69 6e6b 2e70 7265  slation(link.pre
+0000a370: 4854 2920 2374 6869 7320 6973 2064 6566  HT) #this is def
+0000a380: 696e 6564 2069 6e20 7468 6520 7061 7265  ined in the pare
+0000a390: 6e74 206c 696e 6b21 0a20 2020 2020 2020  nt link!.       
+0000a3a0: 2020 2020 2020 2020 2070 6172 656e 7442           parentB
+0000a3b0: 6f64 7920 3d20 626f 6479 4c69 7374 5b73  ody = bodyList[s
+0000a3c0: 656c 662e 4765 7450 6172 656e 7449 6e64  elf.GetParentInd
+0000a3d0: 6578 2869 295d 0a20 2020 2020 2020 2020  ex(i)].         
+0000a3e0: 2020 2020 2020 206d 4c69 6e6b 304c 6173         mLink0Las
+0000a3f0: 7442 6f64 7920 3d20 6d62 732e 4164 644d  tBody = mbs.AddM
+0000a400: 6172 6b65 7228 6569 692e 4d61 726b 6572  arker(eii.Marker
+0000a410: 426f 6479 5269 6769 6428 626f 6479 4e75  BodyRigid(bodyNu
+0000a420: 6d62 6572 3d70 6172 656e 7442 6f64 792c  mber=parentBody,
+0000a430: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+0000a440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a470: 206c 6f63 616c 506f 7369 7469 6f6e 3d6d   localPosition=m
+0000a480: 6172 6b65 7230 506f 7369 7469 6f6e 2929  arker0Position))
+0000a490: 0a0a 2020 2020 2020 2020 2020 2020 6d61  ..            ma
+0000a4a0: 726b 6572 4c69 7374 302b 3d5b 6d4c 696e  rkerList0+=[mLin
+0000a4b0: 6b30 4c61 7374 426f 6479 5d0a 2020 2020  k0LastBody].    
+0000a4c0: 2020 2020 2020 2020 6d61 726b 6572 4c69          markerLi
+0000a4d0: 7374 312b 3d5b 6d4c 696e 6b31 5d0a 0a20  st1+=[mLink1].. 
+0000a4e0: 2020 2020 2020 2020 2020 2063 6f6e 7374             const
+0000a4f0: 7261 696e 6564 4178 6573 203d 205b 312c  rainedAxes = [1,
+0000a500: 312c 312c 312c 312c 315d 2023 616c 6c20  1,1,1,1,1] #all 
+0000a510: 6178 6573 2063 6f6e 7374 7261 696e 6564  axes constrained
+0000a520: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
+0000a530: 7374 7261 696e 6564 4178 6573 5b64 6963  strainedAxes[dic
+0000a540: 744a 6f69 6e74 5479 7065 3263 6f6f 7264  tJointType2coord
+0000a550: 696e 6174 6536 445b 6c69 6e6b 2e6a 6f69  inate6D[link.joi
+0000a560: 6e74 5479 7065 5d5d 203d 2030 2023 7468  ntType]] = 0 #th
+0000a570: 6973 2069 7320 7468 6520 6672 6565 2061  is is the free a
+0000a580: 7869 730a 0a20 2020 2020 2020 2020 2020  xis..           
+0000a590: 2072 203d 206c 696e 6b2e 7669 7375 616c   r = link.visual
+0000a5a0: 697a 6174 696f 6e2e 6a6f 696e 7452 6164  ization.jointRad
+0000a5b0: 6975 730a 2020 2020 2020 2020 2020 2020  ius.            
+0000a5c0: 774a 203d 206c 696e 6b2e 7669 7375 616c  wJ = link.visual
+0000a5d0: 697a 6174 696f 6e2e 6a6f 696e 7457 6964  ization.jointWid
+0000a5e0: 7468 0a20 2020 2020 2020 2020 2020 2073  th.            s
+0000a5f0: 686f 774d 4253 6a6f 696e 7420 3d20 6c69  howMBSjoint = li
+0000a600: 6e6b 2e76 6973 7561 6c69 7a61 7469 6f6e  nk.visualization
+0000a610: 2e73 686f 774d 4253 6a6f 696e 740a 0a20  .showMBSjoint.. 
+0000a620: 2020 2020 2020 2020 2020 206c 6f61 6453             loadS
+0000a630: 697a 6520 3d20 310a 2020 2020 2020 2020  ize = 1.        
+0000a640: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
+0000a650: 206d 6172 6b65 7230 203d 206d 4c69 6e6b   marker0 = mLink
+0000a660: 304c 6173 7442 6f64 790a 2020 2020 2020  0LastBody.      
+0000a670: 2020 2020 2020 6d61 726b 6572 3120 3d20        marker1 = 
+0000a680: 6d4c 696e 6b31 0a20 2020 2020 2020 2020  mLink1.         
+0000a690: 2020 2072 6f74 6174 696f 6e4d 6172 6b65     rotationMarke
+0000a6a0: 7230 203d 206c 6173 744d 6172 6b65 7252  r0 = lastMarkerR
+0000a6b0: 6f74 6174 696f 6e0a 2020 2020 2020 2020  otation.        
+0000a6c0: 2020 2020 726f 7461 7469 6f6e 4d61 726b      rotationMark
+0000a6d0: 6572 3120 3d20 4174 6869 7354 0a0a 2020  er1 = AthisT..  
+0000a6e0: 2020 2020 2020 2020 2020 6a6f 696e 744c            jointL
+0000a6f0: 696e 6b20 3d20 6d62 732e 4164 644f 626a  ink = mbs.AddObj
+0000a700: 6563 7428 6569 692e 4765 6e65 7269 634a  ect(eii.GenericJ
+0000a710: 6f69 6e74 286d 6172 6b65 724e 756d 6265  oint(markerNumbe
+0000a720: 7273 3d5b 6d61 726b 6572 302c 206d 6172  rs=[marker0, mar
+0000a730: 6b65 7231 5d2c 0a20 2020 2020 2020 2020  ker1],.         
+0000a740: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a780: 2020 2020 2020 2020 2020 6c6f 6361 6c50            localP
-0000a790: 6f73 6974 696f 6e3d 6d61 726b 6572 3050  osition=marker0P
-0000a7a0: 6f73 6974 696f 6e29 290d 0a0d 0a20 2020  osition))....   
-0000a7b0: 2020 2020 2020 2020 206d 6172 6b65 724c           markerL
-0000a7c0: 6973 7430 2b3d 5b6d 4c69 6e6b 304c 6173  ist0+=[mLink0Las
-0000a7d0: 7442 6f64 795d 0d0a 2020 2020 2020 2020  tBody]..        
-0000a7e0: 2020 2020 6d61 726b 6572 4c69 7374 312b      markerList1+
-0000a7f0: 3d5b 6d4c 696e 6b31 5d0d 0a0d 0a20 2020  =[mLink1]....   
-0000a800: 2020 2020 2020 2020 2063 6f6e 7374 7261           constra
-0000a810: 696e 6564 4178 6573 203d 205b 312c 312c  inedAxes = [1,1,
-0000a820: 312c 312c 312c 315d 2023 616c 6c20 6178  1,1,1,1] #all ax
-0000a830: 6573 2063 6f6e 7374 7261 696e 6564 0d0a  es constrained..
-0000a840: 2020 2020 2020 2020 2020 2020 636f 6e73              cons
-0000a850: 7472 6169 6e65 6441 7865 735b 6469 6374  trainedAxes[dict
-0000a860: 4a6f 696e 7454 7970 6532 636f 6f72 6469  JointType2coordi
-0000a870: 6e61 7465 3644 5b6c 696e 6b2e 6a6f 696e  nate6D[link.join
-0000a880: 7454 7970 655d 5d20 3d20 3020 2374 6869  tType]] = 0 #thi
-0000a890: 7320 6973 2074 6865 2066 7265 6520 6178  s is the free ax
-0000a8a0: 6973 0d0a 0d0a 2020 2020 2020 2020 2020  is....          
-0000a8b0: 2020 7220 3d20 6c69 6e6b 2e76 6973 7561    r = link.visua
-0000a8c0: 6c69 7a61 7469 6f6e 2e6a 6f69 6e74 5261  lization.jointRa
-0000a8d0: 6469 7573 0d0a 2020 2020 2020 2020 2020  dius..          
-0000a8e0: 2020 774a 203d 206c 696e 6b2e 7669 7375    wJ = link.visu
-0000a8f0: 616c 697a 6174 696f 6e2e 6a6f 696e 7457  alization.jointW
-0000a900: 6964 7468 0d0a 2020 2020 2020 2020 2020  idth..          
-0000a910: 2020 7368 6f77 4d42 536a 6f69 6e74 203d    showMBSjoint =
-0000a920: 206c 696e 6b2e 7669 7375 616c 697a 6174   link.visualizat
-0000a930: 696f 6e2e 7368 6f77 4d42 536a 6f69 6e74  ion.showMBSjoint
-0000a940: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
-0000a950: 6c6f 6164 5369 7a65 203d 2031 0d0a 2020  loadSize = 1..  
-0000a960: 2020 2020 2020 2020 2020 0d0a 2020 2020            ..    
-0000a970: 2020 2020 2020 2020 6d61 726b 6572 3020          marker0 
-0000a980: 3d20 6d4c 696e 6b30 4c61 7374 426f 6479  = mLink0LastBody
-0000a990: 0d0a 2020 2020 2020 2020 2020 2020 6d61  ..            ma
-0000a9a0: 726b 6572 3120 3d20 6d4c 696e 6b31 0d0a  rker1 = mLink1..
-0000a9b0: 2020 2020 2020 2020 2020 2020 726f 7461              rota
-0000a9c0: 7469 6f6e 4d61 726b 6572 3020 3d20 6c61  tionMarker0 = la
-0000a9d0: 7374 4d61 726b 6572 526f 7461 7469 6f6e  stMarkerRotation
-0000a9e0: 0d0a 2020 2020 2020 2020 2020 2020 726f  ..            ro
-0000a9f0: 7461 7469 6f6e 4d61 726b 6572 3120 3d20  tationMarker1 = 
-0000aa00: 4174 6869 7354 0d0a 0d0a 2020 2020 2020  AthisT....      
-0000aa10: 2020 2020 2020 6a6f 696e 744c 696e 6b20        jointLink 
-0000aa20: 3d20 6d62 732e 4164 644f 626a 6563 7428  = mbs.AddObject(
-0000aa30: 6569 692e 4765 6e65 7269 634a 6f69 6e74  eii.GenericJoint
-0000aa40: 286d 6172 6b65 724e 756d 6265 7273 3d5b  (markerNumbers=[
-0000aa50: 6d61 726b 6572 302c 206d 6172 6b65 7231  marker0, marker1
-0000aa60: 5d2c 0d0a 2020 2020 2020 2020 2020 2020  ],..            
-0000aa70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa90: 2020 2020 2020 2020 636f 6e73 7472 6169          constrai
-0000aaa0: 6e65 6441 7865 733d 636f 6e73 7472 6169  nedAxes=constrai
-0000aab0: 6e65 6441 7865 732c 0d0a 2020 2020 2020  nedAxes,..      
-0000aac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aae0: 2020 2020 2020 2020 2020 2020 2020 726f                ro
-0000aaf0: 7461 7469 6f6e 4d61 726b 6572 303d 726f  tationMarker0=ro
-0000ab00: 7461 7469 6f6e 4d61 726b 6572 302c 0d0a  tationMarker0,..
-0000ab10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab40: 2020 2020 726f 7461 7469 6f6e 4d61 726b      rotationMark
-0000ab50: 6572 313d 726f 7461 7469 6f6e 4d61 726b  er1=rotationMark
-0000ab60: 6572 312c 0d0a 2020 2020 2020 2020 2020  er1,..          
-0000ab70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab90: 2020 2020 2020 2020 2020 7669 7375 616c            visual
-0000aba0: 697a 6174 696f 6e3d 6569 692e 564f 626a  ization=eii.VObj
-0000abb0: 6563 744a 6f69 6e74 4765 6e65 7269 6328  ectJointGeneric(
-0000abc0: 7368 6f77 3d73 686f 774d 4253 6a6f 696e  show=showMBSjoin
-0000abd0: 742c 2061 7865 7352 6164 6975 7320 3d20  t, axesRadius = 
-0000abe0: 722a 302e 3235 2c20 0d0a 2020 2020 2020  r*0.25, ..      
-0000abf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac20: 2020 2020 2020 2020 2020 2020 6178 6573              axes
-0000ac30: 4c65 6e67 7468 3d77 4a2a 312e 312c 2063  Length=wJ*1.1, c
-0000ac40: 6f6c 6f72 3d65 6764 2e63 6f6c 6f72 3467  olor=egd.color4g
-0000ac50: 7265 7929 2929 0d0a 0d0a 2020 2020 2020  rey)))....      
-0000ac60: 2020 2020 2020 6a6f 696e 744c 6973 742b        jointList+
-0000ac70: 3d5b 6a6f 696e 744c 696e 6b5d 0d0a 2020  =[jointLink]..  
-0000ac80: 2020 2020 2020 2020 2020 6f62 6a65 6374            object
-0000ac90: 5344 203d 204e 6f6e 6520 2369 6620 6e6f  SD = None #if no
-0000aca0: 7420 6164 6465 640d 0a0d 0a20 2020 2020  t added....     
-0000acb0: 2020 2020 2020 2069 6620 6c69 6e6b 2e6a         if link.j
-0000acc0: 6f69 6e74 5479 7065 5b30 5d20 3d3d 2027  ointType[0] == '
-0000acd0: 5227 3a0d 0a20 2020 2020 2020 2020 2020  R':..           
-0000ace0: 2020 2020 2023 6c6f 6164 206f 6e20 7072       #load on pr
-0000acf0: 6576 696f 7573 2062 6f64 792c 206e 6567  evious body, neg
-0000ad00: 6174 6976 6520 7369 676e 0d0a 2020 2020  ative sign..    
-0000ad10: 2020 2020 2020 2020 2020 2020 746f 7271              torq
-0000ad20: 7565 3020 3d20 726f 7461 7469 6f6e 4d61  ue0 = rotationMa
-0000ad30: 726b 6572 3020 4020 282d 6c6f 6164 5369  rker0 @ (-loadSi
-0000ad40: 7a65 2a6a 6f69 6e74 4178 6973 2920 236e  ze*jointAxis) #n
-0000ad50: 702e 6172 7261 7928 5b30 2c30 2c20 2d6c  p.array([0,0, -l
-0000ad60: 6f61 6453 697a 655d 290d 0a20 2020 2020  oadSize])..     
-0000ad70: 2020 2020 2020 2020 2020 2074 6f72 7175             torqu
-0000ad80: 6531 203d 2072 6f74 6174 696f 6e4d 6172  e1 = rotationMar
-0000ad90: 6b65 7231 2040 2028 6c6f 6164 5369 7a65  ker1 @ (loadSize
-0000ada0: 2a6a 6f69 6e74 4178 6973 2920 2372 6f74  *jointAxis) #rot
-0000adb0: 6174 6564 206e 6567 6174 6976 6520 746f  ated negative to
-0000adc0: 7271 7565 2076 6563 746f 7220 666f 7220  rque vector for 
-0000add0: 6375 7272 656e 7420 6c69 6e6b 2c20 6974  current link, it
-0000ade0: 2069 7320 6e6f 7420 7468 6520 7a2d 6178   is not the z-ax
-0000adf0: 6973 0d0a 2020 2020 2020 2020 2020 2020  is..            
-0000ae00: 2020 2020 756e 6974 546f 7271 7565 304c      unitTorque0L
-0000ae10: 6973 7420 2b3d 205b 746f 7271 7565 305d  ist += [torque0]
-0000ae20: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ae30: 2020 756e 6974 546f 7271 7565 314c 6973    unitTorque1Lis
-0000ae40: 7420 2b3d 205b 746f 7271 7565 315d 0d0a  t += [torque1]..
-0000ae50: 2020 2020 0d0a 2020 2020 2020 2020 2020      ..          
-0000ae60: 2020 2020 2020 6966 2069 203c 206c 656e        if i < len
-0000ae70: 286a 6f69 6e74 4c6f 6164 5573 6572 4675  (jointLoadUserFu
-0000ae80: 6e63 7469 6f6e 4c69 7374 293a 0d0a 2020  nctionList):..  
+0000a760: 2020 2020 2020 2020 2020 2063 6f6e 7374             const
+0000a770: 7261 696e 6564 4178 6573 3d63 6f6e 7374  rainedAxes=const
+0000a780: 7261 696e 6564 4178 6573 2c0a 2020 2020  rainedAxes,.    
+0000a790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7c0: 726f 7461 7469 6f6e 4d61 726b 6572 303d  rotationMarker0=
+0000a7d0: 726f 7461 7469 6f6e 4d61 726b 6572 302c  rotationMarker0,
+0000a7e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a810: 2020 2020 2072 6f74 6174 696f 6e4d 6172       rotationMar
+0000a820: 6b65 7231 3d72 6f74 6174 696f 6e4d 6172  ker1=rotationMar
+0000a830: 6b65 7231 2c0a 2020 2020 2020 2020 2020  ker1,.          
+0000a840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a860: 2020 2020 2020 2020 2020 7669 7375 616c            visual
+0000a870: 697a 6174 696f 6e3d 6569 692e 564f 626a  ization=eii.VObj
+0000a880: 6563 744a 6f69 6e74 4765 6e65 7269 6328  ectJointGeneric(
+0000a890: 7368 6f77 3d73 686f 774d 4253 6a6f 696e  show=showMBSjoin
+0000a8a0: 742c 2061 7865 7352 6164 6975 7320 3d20  t, axesRadius = 
+0000a8b0: 722a 302e 3235 2c20 0a20 2020 2020 2020  r*0.25, .       
+0000a8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8f0: 2020 2020 2020 2020 2020 2061 7865 734c             axesL
+0000a900: 656e 6774 683d 774a 2a31 2e31 2c20 636f  ength=wJ*1.1, co
+0000a910: 6c6f 723d 6567 642e 636f 6c6f 7234 6772  lor=egd.color4gr
+0000a920: 6579 2929 290a 0a20 2020 2020 2020 2020  ey)))..         
+0000a930: 2020 206a 6f69 6e74 4c69 7374 2b3d 5b6a     jointList+=[j
+0000a940: 6f69 6e74 4c69 6e6b 5d0a 2020 2020 2020  ointLink].      
+0000a950: 2020 2020 2020 6f62 6a65 6374 5344 203d        objectSD =
+0000a960: 204e 6f6e 6520 2369 6620 6e6f 7420 6164   None #if not ad
+0000a970: 6465 640a 0a20 2020 2020 2020 2020 2020  ded..           
+0000a980: 2069 6620 6c69 6e6b 2e6a 6f69 6e74 5479   if link.jointTy
+0000a990: 7065 5b30 5d20 3d3d 2027 5227 3a0a 2020  pe[0] == 'R':.  
+0000a9a0: 2020 2020 2020 2020 2020 2020 2020 236c                #l
+0000a9b0: 6f61 6420 6f6e 2070 7265 7669 6f75 7320  oad on previous 
+0000a9c0: 626f 6479 2c20 6e65 6761 7469 7665 2073  body, negative s
+0000a9d0: 6967 6e0a 2020 2020 2020 2020 2020 2020  ign.            
+0000a9e0: 2020 2020 746f 7271 7565 3020 3d20 726f      torque0 = ro
+0000a9f0: 7461 7469 6f6e 4d61 726b 6572 3020 4020  tationMarker0 @ 
+0000aa00: 282d 6c6f 6164 5369 7a65 2a6a 6f69 6e74  (-loadSize*joint
+0000aa10: 4178 6973 2920 236e 702e 6172 7261 7928  Axis) #np.array(
+0000aa20: 5b30 2c30 2c20 2d6c 6f61 6453 697a 655d  [0,0, -loadSize]
+0000aa30: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000aa40: 2020 746f 7271 7565 3120 3d20 726f 7461    torque1 = rota
+0000aa50: 7469 6f6e 4d61 726b 6572 3120 4020 286c  tionMarker1 @ (l
+0000aa60: 6f61 6453 697a 652a 6a6f 696e 7441 7869  oadSize*jointAxi
+0000aa70: 7329 2023 726f 7461 7465 6420 6e65 6761  s) #rotated nega
+0000aa80: 7469 7665 2074 6f72 7175 6520 7665 6374  tive torque vect
+0000aa90: 6f72 2066 6f72 2063 7572 7265 6e74 206c  or for current l
+0000aaa0: 696e 6b2c 2069 7420 6973 206e 6f74 2074  ink, it is not t
+0000aab0: 6865 207a 2d61 7869 730a 2020 2020 2020  he z-axis.      
+0000aac0: 2020 2020 2020 2020 2020 756e 6974 546f            unitTo
+0000aad0: 7271 7565 304c 6973 7420 2b3d 205b 746f  rque0List += [to
+0000aae0: 7271 7565 305d 0a20 2020 2020 2020 2020  rque0].         
+0000aaf0: 2020 2020 2020 2075 6e69 7454 6f72 7175         unitTorqu
+0000ab00: 6531 4c69 7374 202b 3d20 5b74 6f72 7175  e1List += [torqu
+0000ab10: 6531 5d0a 2020 2020 0a20 2020 2020 2020  e1].    .       
+0000ab20: 2020 2020 2020 2020 2069 6620 6920 3c20           if i < 
+0000ab30: 6c65 6e28 6a6f 696e 744c 6f61 6455 7365  len(jointLoadUse
+0000ab40: 7246 756e 6374 696f 6e4c 6973 7429 3a0a  rFunctionList):.
+0000ab50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab60: 2020 2020 6c6f 6164 3020 3d20 6d62 732e      load0 = mbs.
+0000ab70: 4164 644c 6f61 6428 6569 692e 4c6f 6164  AddLoad(eii.Load
+0000ab80: 546f 7271 7565 5665 6374 6f72 286d 6172  TorqueVector(mar
+0000ab90: 6b65 724e 756d 6265 723d 6d61 726b 6572  kerNumber=marker
+0000aba0: 302c 206c 6f61 6456 6563 746f 723d 746f  0, loadVector=to
+0000abb0: 7271 7565 302c 0a20 2020 2020 2020 2020  rque0,.         
+0000abc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abf0: 2020 2020 2020 2020 2020 2062 6f64 7946             bodyF
+0000ac00: 6978 6564 3d54 7275 652c 206c 6f61 6456  ixed=True, loadV
+0000ac10: 6563 746f 7255 7365 7246 756e 6374 696f  ectorUserFunctio
+0000ac20: 6e3d 6a6f 696e 744c 6f61 6455 7365 7246  n=jointLoadUserF
+0000ac30: 756e 6374 696f 6e4c 6973 745b 695d 2929  unctionList[i]))
+0000ac40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ac50: 2020 2020 206c 6f61 6431 203d 206d 6273       load1 = mbs
+0000ac60: 2e41 6464 4c6f 6164 2865 6969 2e4c 6f61  .AddLoad(eii.Loa
+0000ac70: 6454 6f72 7175 6556 6563 746f 7228 6d61  dTorqueVector(ma
+0000ac80: 726b 6572 4e75 6d62 6572 3d6d 6172 6b65  rkerNumber=marke
+0000ac90: 7231 2c20 6c6f 6164 5665 6374 6f72 3d74  r1, loadVector=t
+0000aca0: 6f72 7175 6531 2c20 0a20 2020 2020 2020  orque1, .       
+0000acb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ace0: 2020 2020 2020 2020 2020 2020 2062 6f64               bod
+0000acf0: 7946 6978 6564 3d54 7275 652c 206c 6f61  yFixed=True, loa
+0000ad00: 6456 6563 746f 7255 7365 7246 756e 6374  dVectorUserFunct
+0000ad10: 696f 6e3d 6a6f 696e 744c 6f61 6455 7365  ion=jointLoadUse
+0000ad20: 7246 756e 6374 696f 6e4c 6973 745b 695d  rFunctionList[i]
+0000ad30: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+0000ad40: 2020 2020 2020 206a 6f69 6e74 546f 7271         jointTorq
+0000ad50: 7565 304c 6973 7420 2b3d 205b 6c6f 6164  ue0List += [load
+0000ad60: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
+0000ad70: 2020 2020 2020 206a 6f69 6e74 546f 7271         jointTorq
+0000ad80: 7565 314c 6973 7420 2b3d 205b 6c6f 6164  ue1List += [load
+0000ad90: 315d 0a20 2020 2020 2020 2020 2020 2020  1].             
+0000ada0: 2020 2065 6c69 6620 6372 6561 7465 4a6f     elif createJo
+0000adb0: 696e 7454 6f72 7175 654c 6f61 6473 3a20  intTorqueLoads: 
+0000adc0: 236c 6f61 6473 2074 6865 6e20 6d75 7374  #loads then must
+0000add0: 2062 6520 7570 6461 7465 6420 696e 2c20   be updated in, 
+0000ade0: 652e 672e 2c20 6d62 732e 5365 7450 7265  e.g., mbs.SetPre
+0000adf0: 5374 6570 5573 6572 4675 6e63 7469 6f6e  StepUserFunction
+0000ae00: 282e 2e2e 290a 2020 2020 2020 2020 2020  (...).          
+0000ae10: 2020 2020 2020 2020 2020 6c6f 6164 3020            load0 
+0000ae20: 3d20 6d62 732e 4164 644c 6f61 6428 6569  = mbs.AddLoad(ei
+0000ae30: 692e 4c6f 6164 546f 7271 7565 5665 6374  i.LoadTorqueVect
+0000ae40: 6f72 286d 6172 6b65 724e 756d 6265 723d  or(markerNumber=
+0000ae50: 6d61 726b 6572 302c 206c 6f61 6456 6563  marker0, loadVec
+0000ae60: 746f 723d 5b30 2c30 2c30 5d2c 200a 2020  tor=[0,0,0], .  
+0000ae70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000ae90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aea0: 2020 6c6f 6164 3020 3d20 6d62 732e 4164    load0 = mbs.Ad
-0000aeb0: 644c 6f61 6428 6569 692e 4c6f 6164 546f  dLoad(eii.LoadTo
-0000aec0: 7271 7565 5665 6374 6f72 286d 6172 6b65  rqueVector(marke
-0000aed0: 724e 756d 6265 723d 6d61 726b 6572 302c  rNumber=marker0,
-0000aee0: 206c 6f61 6456 6563 746f 723d 746f 7271   loadVector=torq
-0000aef0: 7565 302c 0d0a 2020 2020 2020 2020 2020  ue0,..          
-0000af00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af30: 2020 2020 2020 2020 2020 626f 6479 4669            bodyFi
-0000af40: 7865 643d 5472 7565 2c20 6c6f 6164 5665  xed=True, loadVe
-0000af50: 6374 6f72 5573 6572 4675 6e63 7469 6f6e  ctorUserFunction
-0000af60: 3d6a 6f69 6e74 4c6f 6164 5573 6572 4675  =jointLoadUserFu
-0000af70: 6e63 7469 6f6e 4c69 7374 5b69 5d29 290d  nctionList[i])).
-0000af80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000af90: 2020 2020 206c 6f61 6431 203d 206d 6273       load1 = mbs
-0000afa0: 2e41 6464 4c6f 6164 2865 6969 2e4c 6f61  .AddLoad(eii.Loa
-0000afb0: 6454 6f72 7175 6556 6563 746f 7228 6d61  dTorqueVector(ma
-0000afc0: 726b 6572 4e75 6d62 6572 3d6d 6172 6b65  rkerNumber=marke
-0000afd0: 7231 2c20 6c6f 6164 5665 6374 6f72 3d74  r1, loadVector=t
-0000afe0: 6f72 7175 6531 2c20 0d0a 2020 2020 2020  orque1, ..      
-0000aff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b020: 2020 2020 2020 2020 2020 2020 2020 626f                bo
-0000b030: 6479 4669 7865 643d 5472 7565 2c20 6c6f  dyFixed=True, lo
-0000b040: 6164 5665 6374 6f72 5573 6572 4675 6e63  adVectorUserFunc
-0000b050: 7469 6f6e 3d6a 6f69 6e74 4c6f 6164 5573  tion=jointLoadUs
-0000b060: 6572 4675 6e63 7469 6f6e 4c69 7374 5b69  erFunctionList[i
-0000b070: 5d29 290d 0a20 2020 2020 2020 2020 2020  ]))..           
-0000b080: 2020 2020 2020 2020 206a 6f69 6e74 546f           jointTo
-0000b090: 7271 7565 304c 6973 7420 2b3d 205b 6c6f  rque0List += [lo
-0000b0a0: 6164 305d 0d0a 2020 2020 2020 2020 2020  ad0]..          
-0000b0b0: 2020 2020 2020 2020 2020 6a6f 696e 7454            jointT
-0000b0c0: 6f72 7175 6531 4c69 7374 202b 3d20 5b6c  orque1List += [l
-0000b0d0: 6f61 6431 5d0d 0a20 2020 2020 2020 2020  oad1]..         
-0000b0e0: 2020 2020 2020 2065 6c69 6620 6372 6561         elif crea
-0000b0f0: 7465 4a6f 696e 7454 6f72 7175 654c 6f61  teJointTorqueLoa
-0000b100: 6473 3a20 236c 6f61 6473 2074 6865 6e20  ds: #loads then 
-0000b110: 6d75 7374 2062 6520 7570 6461 7465 6420  must be updated 
-0000b120: 696e 2c20 652e 672e 2c20 6d62 732e 5365  in, e.g., mbs.Se
-0000b130: 7450 7265 5374 6570 5573 6572 4675 6e63  tPreStepUserFunc
-0000b140: 7469 6f6e 282e 2e2e 290d 0a20 2020 2020  tion(...)..     
-0000b150: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000b160: 6f61 6430 203d 206d 6273 2e41 6464 4c6f  oad0 = mbs.AddLo
-0000b170: 6164 2865 6969 2e4c 6f61 6454 6f72 7175  ad(eii.LoadTorqu
-0000b180: 6556 6563 746f 7228 6d61 726b 6572 4e75  eVector(markerNu
-0000b190: 6d62 6572 3d6d 6172 6b65 7230 2c20 6c6f  mber=marker0, lo
-0000b1a0: 6164 5665 6374 6f72 3d5b 302c 302c 305d  adVector=[0,0,0]
-0000b1b0: 2c20 0d0a 2020 2020 2020 2020 2020 2020  , ..            
-0000b1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1f0: 2020 2020 2020 2020 626f 6479 4669 7865          bodyFixe
-0000b200: 643d 5472 7565 2929 0d0a 2020 2020 2020  d=True))..      
-0000b210: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
-0000b220: 6164 3120 3d20 6d62 732e 4164 644c 6f61  ad1 = mbs.AddLoa
-0000b230: 6428 6569 692e 4c6f 6164 546f 7271 7565  d(eii.LoadTorque
-0000b240: 5665 6374 6f72 286d 6172 6b65 724e 756d  Vector(markerNum
-0000b250: 6265 723d 6d61 726b 6572 312c 206c 6f61  ber=marker1, loa
-0000b260: 6456 6563 746f 723d 5b30 2c30 2c30 5d2c  dVector=[0,0,0],
-0000b270: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aeb0: 2020 626f 6479 4669 7865 643d 5472 7565    bodyFixed=True
+0000aec0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+0000aed0: 2020 2020 2020 206c 6f61 6431 203d 206d         load1 = m
+0000aee0: 6273 2e41 6464 4c6f 6164 2865 6969 2e4c  bs.AddLoad(eii.L
+0000aef0: 6f61 6454 6f72 7175 6556 6563 746f 7228  oadTorqueVector(
+0000af00: 6d61 726b 6572 4e75 6d62 6572 3d6d 6172  markerNumber=mar
+0000af10: 6b65 7231 2c20 6c6f 6164 5665 6374 6f72  ker1, loadVector
+0000af20: 3d5b 302c 302c 305d 2c0a 2020 2020 2020  =[0,0,0],.      
+0000af30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af60: 2020 2020 2020 2020 2020 2020 2020 626f                bo
+0000af70: 6479 4669 7865 643d 5472 7565 2929 0a20  dyFixed=True)). 
+0000af80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af90: 2020 206a 6f69 6e74 546f 7271 7565 304c     jointTorque0L
+0000afa0: 6973 7420 2b3d 205b 6c6f 6164 305d 0a20  ist += [load0]. 
+0000afb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afc0: 2020 206a 6f69 6e74 546f 7271 7565 314c     jointTorque1L
+0000afd0: 6973 7420 2b3d 205b 6c6f 6164 315d 0a20  ist += [load1]. 
+0000afe0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000aff0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000b000: 2020 2020 2020 2020 206a 6f69 6e74 546f           jointTo
+0000b010: 7271 7565 304c 6973 7420 2b3d 205b 4e6f  rque0List += [No
+0000b020: 6e65 5d0a 2020 2020 2020 2020 2020 2020  ne].            
+0000b030: 2020 2020 2020 2020 6a6f 696e 7454 6f72          jointTor
+0000b040: 7175 6531 4c69 7374 202b 3d20 5b4e 6f6e  que1List += [Non
+0000b050: 655d 0a20 2020 2020 2020 2020 2020 2020  e].             
+0000b060: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+0000b070: 2020 2020 6966 2069 203c 206c 656e 286a      if i < len(j
+0000b080: 6f69 6e74 5370 7269 6e67 4461 6d70 6572  ointSpringDamper
+0000b090: 5573 6572 4675 6e63 7469 6f6e 4c69 7374  UserFunctionList
+0000b0a0: 2920 6f72 206c 696e 6b2e 4861 7350 4463  ) or link.HasPDc
+0000b0b0: 6f6e 7472 6f6c 2829 3a0a 2020 2020 2020  ontrol():.      
+0000b0c0: 2020 2020 2020 2020 2020 2020 2020 5044                PD
+0000b0d0: 636f 6e74 726f 6c20 3d20 6c69 6e6b 2e47  control = link.G
+0000b0e0: 6574 5044 636f 6e74 726f 6c28 290a 2020  etPDcontrol().  
+0000b0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b100: 2020 2367 656e 6572 6963 206e 6f64 6520    #generic node 
+0000b110: 666f 7220 696e 6669 6e69 7465 2072 6576  for infinite rev
+0000b120: 6f6c 7574 696f 6e73 3a0a 2020 2020 2020  olutions:.      
+0000b130: 2020 2020 2020 2020 2020 2020 2020 6e47                nG
+0000b140: 656e 6572 6963 3d6d 6273 2e41 6464 4e6f  eneric=mbs.AddNo
+0000b150: 6465 2865 6969 2e4e 6f64 6547 656e 6572  de(eii.NodeGener
+0000b160: 6963 4461 7461 2869 6e69 7469 616c 436f  icData(initialCo
+0000b170: 6f72 6469 6e61 7465 733d 5b30 5d2c 200a  ordinates=[0], .
+0000b180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1b0: 2020 2020 2020 2020 206e 756d 6265 724f           numberO
+0000b1c0: 6644 6174 6143 6f6f 7264 696e 6174 6573  fDataCoordinates
+0000b1d0: 3d31 2929 2023 666f 7220 696e 6669 6e69  =1)) #for infini
+0000b1e0: 7465 2072 6f74 6174 696f 6e73 0a20 2020  te rotations.   
+0000b1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b200: 2023 746f 7273 696f 6e61 6c20 7370 7269   #torsional spri
+0000b210: 6e67 2d64 616d 7065 7220 616c 6c6f 7773  ng-damper allows
+0000b220: 2063 6f6e 7472 6f6c 206f 6620 726f 7461   control of rota
+0000b230: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+0000b240: 2020 2020 2020 2020 206f 626a 6563 7453           objectS
+0000b250: 4420 3d20 6d62 732e 4164 644f 626a 6563  D = mbs.AddObjec
+0000b260: 7428 6569 692e 546f 7273 696f 6e61 6c53  t(eii.TorsionalS
+0000b270: 7072 696e 6744 616d 7065 7228 6d61 726b  pringDamper(mark
+0000b280: 6572 4e75 6d62 6572 733d 5b6d 6172 6b65  erNumbers=[marke
+0000b290: 7230 2c20 6d61 726b 6572 315d 2c0a 2020  r0, marker1],.  
 0000b2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2b0: 2020 2020 2020 626f 6479 4669 7865 643d        bodyFixed=
-0000b2c0: 5472 7565 2929 0d0a 2020 2020 2020 2020  True))..        
-0000b2d0: 2020 2020 2020 2020 2020 2020 6a6f 696e              join
-0000b2e0: 7454 6f72 7175 6530 4c69 7374 202b 3d20  tTorque0List += 
-0000b2f0: 5b6c 6f61 6430 5d0d 0a20 2020 2020 2020  [load0]..       
-0000b300: 2020 2020 2020 2020 2020 2020 206a 6f69               joi
-0000b310: 6e74 546f 7271 7565 314c 6973 7420 2b3d  ntTorque1List +=
-0000b320: 205b 6c6f 6164 315d 0d0a 2020 2020 2020   [load1]..      
-0000b330: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-0000b340: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b350: 2020 2020 206a 6f69 6e74 546f 7271 7565       jointTorque
-0000b360: 304c 6973 7420 2b3d 205b 4e6f 6e65 5d0d  0List += [None].
-0000b370: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b380: 2020 2020 206a 6f69 6e74 546f 7271 7565       jointTorque
-0000b390: 314c 6973 7420 2b3d 205b 4e6f 6e65 5d0d  1List += [None].
-0000b3a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b3b0: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
-0000b3c0: 2020 2069 6620 6920 3c20 6c65 6e28 6a6f     if i < len(jo
-0000b3d0: 696e 7453 7072 696e 6744 616d 7065 7255  intSpringDamperU
-0000b3e0: 7365 7246 756e 6374 696f 6e4c 6973 7429  serFunctionList)
-0000b3f0: 206f 7220 6c69 6e6b 2e48 6173 5044 636f   or link.HasPDco
-0000b400: 6e74 726f 6c28 293a 0d0a 2020 2020 2020  ntrol():..      
-0000b410: 2020 2020 2020 2020 2020 2020 2020 5044                PD
-0000b420: 636f 6e74 726f 6c20 3d20 6c69 6e6b 2e47  control = link.G
-0000b430: 6574 5044 636f 6e74 726f 6c28 290d 0a20  etPDcontrol().. 
+0000b2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2d0: 2020 2020 2020 6e6f 6465 4e75 6d62 6572        nodeNumber
+0000b2e0: 3d6e 4765 6e65 7269 632c 0a20 2020 2020  =nGeneric,.     
+0000b2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b320: 2020 2072 6f74 6174 696f 6e4d 6172 6b65     rotationMarke
+0000b330: 7230 3d72 6f74 6174 696f 6e4d 6172 6b65  r0=rotationMarke
+0000b340: 7230 2c0a 2020 2020 2020 2020 2020 2020  r0,.            
+0000b350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b370: 2020 2020 2020 2020 2020 2020 726f 7461              rota
+0000b380: 7469 6f6e 4d61 726b 6572 313d 726f 7461  tionMarker1=rota
+0000b390: 7469 6f6e 4d61 726b 6572 312c 2020 2020  tionMarker1,    
+0000b3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b3c0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0000b3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b400: 2073 7469 6666 6e65 7373 3d50 4463 6f6e   stiffness=PDcon
+0000b410: 7472 6f6c 5b30 5d2c 0a20 2020 2020 2020  trol[0],.       
+0000b420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b430: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b450: 2020 2023 6765 6e65 7269 6320 6e6f 6465     #generic node
-0000b460: 2066 6f72 2069 6e66 696e 6974 6520 7265   for infinite re
-0000b470: 766f 6c75 7469 6f6e 733a 0d0a 2020 2020  volutions:..    
+0000b450: 2064 616d 7069 6e67 3d50 4463 6f6e 7472   damping=PDcontr
+0000b460: 6f6c 5b31 5d2c 0a20 2020 2020 2020 2020  ol[1],.         
+0000b470: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b490: 6e47 656e 6572 6963 3d6d 6273 2e41 6464  nGeneric=mbs.Add
-0000b4a0: 4e6f 6465 2865 6969 2e4e 6f64 6547 656e  Node(eii.NodeGen
-0000b4b0: 6572 6963 4461 7461 2869 6e69 7469 616c  ericData(initial
-0000b4c0: 436f 6f72 6469 6e61 7465 733d 5b30 5d2c  Coordinates=[0],
-0000b4d0: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
+0000b490: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+0000b4a0: 6973 7561 6c69 7a61 7469 6f6e 3d65 6969  isualization=eii
+0000b4b0: 2e56 546f 7273 696f 6e61 6c53 7072 696e  .VTorsionalSprin
+0000b4c0: 6744 616d 7065 7228 7368 6f77 3d46 616c  gDamper(show=Fal
+0000b4d0: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
 0000b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b500: 2020 2020 2020 2020 2020 2020 6e75 6d62              numb
-0000b510: 6572 4f66 4461 7461 436f 6f72 6469 6e61  erOfDataCoordina
-0000b520: 7465 733d 3129 2920 2366 6f72 2069 6e66  tes=1)) #for inf
-0000b530: 696e 6974 6520 726f 7461 7469 6f6e 730d  inite rotations.
-0000b540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b550: 2020 2020 2023 746f 7273 696f 6e61 6c20       #torsional 
-0000b560: 7370 7269 6e67 2d64 616d 7065 7220 616c  spring-damper al
-0000b570: 6c6f 7773 2063 6f6e 7472 6f6c 206f 6620  lows control of 
-0000b580: 726f 7461 7469 6f6e 0d0a 2020 2020 2020  rotation..      
-0000b590: 2020 2020 2020 2020 2020 2020 2020 6f62                ob
-0000b5a0: 6a65 6374 5344 203d 206d 6273 2e41 6464  jectSD = mbs.Add
-0000b5b0: 4f62 6a65 6374 2865 6969 2e54 6f72 7369  Object(eii.Torsi
-0000b5c0: 6f6e 616c 5370 7269 6e67 4461 6d70 6572  onalSpringDamper
-0000b5d0: 286d 6172 6b65 724e 756d 6265 7273 3d5b  (markerNumbers=[
-0000b5e0: 6d61 726b 6572 302c 206d 6172 6b65 7231  marker0, marker1
-0000b5f0: 5d2c 0d0a 2020 2020 2020 2020 2020 2020  ],..            
-0000b600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b620: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
-0000b630: 4e75 6d62 6572 3d6e 4765 6e65 7269 632c  Number=nGeneric,
-0000b640: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b670: 2020 2020 2020 2020 2020 726f 7461 7469            rotati
-0000b680: 6f6e 4d61 726b 6572 303d 726f 7461 7469  onMarker0=rotati
-0000b690: 6f6e 4d61 726b 6572 302c 0d0a 2020 2020  onMarker0,..    
-0000b6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6d0: 2020 2020 726f 7461 7469 6f6e 4d61 726b      rotationMark
-0000b6e0: 6572 313d 726f 7461 7469 6f6e 4d61 726b  er1=rotationMark
-0000b6f0: 6572 312c 2020 2020 2020 2020 2020 2020  er1,            
-0000b700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b500: 2020 2020 2020 2020 2020 2020 2929 0a20              )). 
+0000b510: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000b520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b530: 2069 6620 2863 7265 6174 654a 6f69 6e74   if (createJoint
+0000b540: 546f 7271 7565 4c6f 6164 7329 3a0a 2020  TorqueLoads):.  
+0000b550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b560: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+0000b570: 6f72 2827 4372 6561 7465 5265 6475 6e64  or('CreateRedund
+0000b580: 616e 7443 6f6f 7264 696e 6174 654d 4253  antCoordinateMBS
+0000b590: 3a20 6372 6561 7465 4a6f 696e 7454 6f72  : createJointTor
+0000b5a0: 7175 654c 6f61 6473 206f 6e6c 7920 7661  queLoads only va
+0000b5b0: 6c69 6420 666f 7220 5265 766f 6c75 7465  lid for Revolute
+0000b5c0: 206a 6f69 6e74 2729 0a0a 2020 2020 2020   joint')..      
+0000b5d0: 2020 2020 2020 2020 2020 6966 2069 203c            if i <
+0000b5e0: 206c 656e 286a 6f69 6e74 5370 7269 6e67   len(jointSpring
+0000b5f0: 4461 6d70 6572 5573 6572 4675 6e63 7469  DamperUserFuncti
+0000b600: 6f6e 4c69 7374 2920 6f72 206c 696e 6b2e  onList) or link.
+0000b610: 4861 7350 4463 6f6e 7472 6f6c 2829 3a0a  HasPDcontrol():.
+0000b620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b630: 2020 2020 5044 636f 6e74 726f 6c20 3d20      PDcontrol = 
+0000b640: 6c69 6e6b 2e47 6574 5044 636f 6e74 726f  link.GetPDcontro
+0000b650: 6c28 290a 2020 2020 2020 2020 2020 2020  l().            
+0000b660: 2020 2020 2020 2020 236c 696e 6561 7220          #linear 
+0000b670: 7370 7269 6e67 2d64 616d 7065 7220 616c  spring-damper al
+0000b680: 6c6f 7773 2063 6f6e 7472 6f6c 2069 6e20  lows control in 
+0000b690: 7472 616e 736c 6174 696f 6e61 6c20 6469  translational di
+0000b6a0: 7265 6374 696f 6e0a 2020 2020 2020 2020  rection.        
+0000b6b0: 2020 2020 2020 2020 2020 2020 6f62 6a65              obje
+0000b6c0: 6374 5344 203d 206d 6273 2e41 6464 4f62  ctSD = mbs.AddOb
+0000b6d0: 6a65 6374 2865 6969 2e4c 696e 6561 7253  ject(eii.LinearS
+0000b6e0: 7072 696e 6744 616d 7065 7228 6d61 726b  pringDamper(mark
+0000b6f0: 6572 4e75 6d62 6572 733d 5b6d 6172 6b65  erNumbers=[marke
+0000b700: 7230 2c20 6d61 726b 6572 315d 2c0a 2020  r0, marker1],.  
 0000b710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b720: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000b720: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b750: 2020 2020 2020 2020 2020 7374 6966 666e            stiffn
-0000b760: 6573 733d 5044 636f 6e74 726f 6c5b 305d  ess=PDcontrol[0]
-0000b770: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
+0000b740: 2020 2020 2020 2020 2020 2020 2020 6178                ax
+0000b750: 6973 4d61 726b 6572 3020 3d20 6a6f 696e  isMarker0 = join
+0000b760: 7441 7869 732c 0a20 2020 2020 2020 2020  tAxis,.         
+0000b770: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b780: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b7a0: 2020 2020 2020 2020 2020 2064 616d 7069             dampi
-0000b7b0: 6e67 3d50 4463 6f6e 7472 6f6c 5b31 5d2c  ng=PDcontrol[1],
-0000b7c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000b7a0: 2020 2020 2020 2073 7469 6666 6e65 7373         stiffness
+0000b7b0: 3d50 4463 6f6e 7472 6f6c 5b30 5d2c 0a20  =PDcontrol[0],. 
+0000b7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b7f0: 2020 2020 2020 2020 2020 7669 7375 616c            visual
-0000b800: 697a 6174 696f 6e3d 6569 692e 5654 6f72  ization=eii.VTor
-0000b810: 7369 6f6e 616c 5370 7269 6e67 4461 6d70  sionalSpringDamp
-0000b820: 6572 2873 686f 773d 4661 6c73 6529 0d0a  er(show=False)..
+0000b7f0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000b800: 616d 7069 6e67 3d50 4463 6f6e 7472 6f6c  amping=PDcontrol
+0000b810: 5b31 5d2c 0a20 2020 2020 2020 2020 2020  [1],.           
+0000b820: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b830: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b860: 2020 2020 2020 2020 2929 0d0a 2020 2020          ))..    
-0000b870: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-0000b880: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000b890: 6620 2863 7265 6174 654a 6f69 6e74 546f  f (createJointTo
-0000b8a0: 7271 7565 4c6f 6164 7329 3a0d 0a20 2020  rqueLoads):..   
+0000b850: 2020 2020 2076 6973 7561 6c69 7a61 7469       visualizati
+0000b860: 6f6e 3d65 6969 2e56 4c69 6e65 6172 5370  on=eii.VLinearSp
+0000b870: 7269 6e67 4461 6d70 6572 2873 686f 773d  ringDamper(show=
+0000b880: 4661 6c73 6529 0a20 2020 2020 2020 2020  False).         
+0000b890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8c0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000b8d0: 7228 2743 7265 6174 6552 6564 756e 6461  r('CreateRedunda
-0000b8e0: 6e74 436f 6f72 6469 6e61 7465 4d42 533a  ntCoordinateMBS:
-0000b8f0: 2063 7265 6174 654a 6f69 6e74 546f 7271   createJointTorq
-0000b900: 7565 4c6f 6164 7320 6f6e 6c79 2076 616c  ueLoads only val
-0000b910: 6964 2066 6f72 2052 6576 6f6c 7574 6520  id for Revolute 
-0000b920: 6a6f 696e 7427 290d 0a0d 0a20 2020 2020  joint')....     
-0000b930: 2020 2020 2020 2020 2020 2069 6620 6920             if i 
-0000b940: 3c20 6c65 6e28 6a6f 696e 7453 7072 696e  < len(jointSprin
-0000b950: 6744 616d 7065 7255 7365 7246 756e 6374  gDamperUserFunct
-0000b960: 696f 6e4c 6973 7429 206f 7220 6c69 6e6b  ionList) or link
-0000b970: 2e48 6173 5044 636f 6e74 726f 6c28 293a  .HasPDcontrol():
-0000b980: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b990: 2020 2020 2020 5044 636f 6e74 726f 6c20        PDcontrol 
-0000b9a0: 3d20 6c69 6e6b 2e47 6574 5044 636f 6e74  = link.GetPDcont
-0000b9b0: 726f 6c28 290d 0a20 2020 2020 2020 2020  rol()..         
-0000b9c0: 2020 2020 2020 2020 2020 2023 6c69 6e65             #line
-0000b9d0: 6172 2073 7072 696e 672d 6461 6d70 6572  ar spring-damper
-0000b9e0: 2061 6c6c 6f77 7320 636f 6e74 726f 6c20   allows control 
-0000b9f0: 696e 2074 7261 6e73 6c61 7469 6f6e 616c  in translational
-0000ba00: 2064 6972 6563 7469 6f6e 0d0a 2020 2020   direction..    
-0000ba10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba20: 6f62 6a65 6374 5344 203d 206d 6273 2e41  objectSD = mbs.A
-0000ba30: 6464 4f62 6a65 6374 2865 6969 2e4c 696e  ddObject(eii.Lin
-0000ba40: 6561 7253 7072 696e 6744 616d 7065 7228  earSpringDamper(
-0000ba50: 6d61 726b 6572 4e75 6d62 6572 733d 5b6d  markerNumbers=[m
-0000ba60: 6172 6b65 7230 2c20 6d61 726b 6572 315d  arker0, marker1]
-0000ba70: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000ba80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000baa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bab0: 2020 2061 7869 734d 6172 6b65 7230 203d     axisMarker0 =
-0000bac0: 206a 6f69 6e74 4178 6973 2c0d 0a20 2020   jointAxis,..   
-0000bad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000baf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb00: 2020 2020 2020 2020 2020 2020 2073 7469               sti
-0000bb10: 6666 6e65 7373 3d50 4463 6f6e 7472 6f6c  ffness=PDcontrol
-0000bb20: 5b30 5d2c 0d0a 2020 2020 2020 2020 2020  [0],..          
-0000bb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb60: 2020 2020 2020 6461 6d70 696e 673d 5044        damping=PD
-0000bb70: 636f 6e74 726f 6c5b 315d 2c0d 0a20 2020  control[1],..   
-0000bb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bbb0: 2020 2020 2020 2020 2020 2020 2076 6973               vis
-0000bbc0: 7561 6c69 7a61 7469 6f6e 3d65 6969 2e56  ualization=eii.V
-0000bbd0: 4c69 6e65 6172 5370 7269 6e67 4461 6d70  LinearSpringDamp
-0000bbe0: 6572 2873 686f 773d 4661 6c73 6529 0d0a  er(show=False)..
-0000bbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc30: 2929 0d0a 2020 2020 2020 2020 2020 2020  ))..            
-0000bc40: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-0000bc50: 2020 2020 2020 7370 7269 6e67 4461 6d70        springDamp
-0000bc60: 6572 4c69 7374 202b 3d20 5b6f 626a 6563  erList += [objec
-0000bc70: 7453 445d 0d0a 2020 2020 2020 2020 2020  tSD]..          
-0000bc80: 2020 0d0a 2020 2020 2020 2020 2020 2020    ..            
-0000bc90: 236d 6172 6b65 724c 6973 7430 202b 3d20  #markerList0 += 
-0000bca0: 5b6d 6c69 6e6b 316e 6578 745d 0d0a 2020  [mlink1next]..  
-0000bcb0: 2020 2020 2020 2020 2020 2320 6966 2069            # if i
-0000bcc0: 203c 206c 656e 2873 656c 662e 6c69 6e6b   < len(self.link
-0000bcd0: 7329 2d31 3a20 236e 6f74 2073 7569 7461  s)-1: #not suita
-0000bce0: 626c 6520 666f 7220 6b69 6e65 6d61 7469  ble for kinemati
-0000bcf0: 6354 7265 650d 0a20 2020 2020 2020 2020  cTree..         
-0000bd00: 2020 2023 2020 2020 206c 6173 744d 6172     #     lastMar
-0000bd10: 6b65 7252 6f74 6174 696f 6e20 3d20 6572  kerRotation = er
-0000bd20: 622e 4854 3272 6f74 6174 696f 6e4d 6174  b.HT2rotationMat
-0000bd30: 7269 7828 7365 6c66 2e6c 696e 6b73 5b69  rix(self.links[i
-0000bd40: 2b31 5d2e 7072 6548 5429 2023 6e65 6564  +1].preHT) #need
-0000bd50: 6564 2066 6f72 206d 6f64 6966 6965 6420  ed for modified 
-0000bd60: 4448 2070 6172 616d 6574 6572 730d 0a20  DH parameters.. 
-0000bd70: 2020 2020 2020 2020 2020 200d 0a20 2020             ..   
-0000bd80: 2020 2020 2020 2020 2023 656e 6420 6c6f           #end lo
-0000bd90: 6f70 206f 7665 7220 6c69 6e6b 730d 0a20  op over links.. 
-0000bda0: 2020 2020 2020 2020 2020 2023 2b2b 2b2b             #++++
-0000bdb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000bdc0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000bdd0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000bde0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000bdf0: 2b2b 2b2b 0d0a 0d0a 2020 2020 2020 2020  ++++....        
-0000be00: 2372 6574 7572 6e20 736f 6d65 206e 6565  #return some nee
-0000be10: 6465 6420 7661 7269 6162 6c65 7320 666f  ded variables fo
-0000be20: 7220 6675 7274 6865 7220 7573 6520 2020  r further use   
-0000be30: 2020 2020 200d 0a20 2020 2020 2020 2064       ..        d
-0000be40: 203d 207b 276e 6f64 654c 6973 7427 3a20   = {'nodeList': 
-0000be50: 6e6f 6465 4c69 7374 2c27 626f 6479 4c69  nodeList,'bodyLi
-0000be60: 7374 273a 2062 6f64 794c 6973 742c 276a  st': bodyList,'j
-0000be70: 6f69 6e74 4c69 7374 273a 206a 6f69 6e74  ointList': joint
-0000be80: 4c69 7374 2c0d 0a20 2020 2020 2020 2020  List,..         
-0000be90: 2020 2020 276d 6172 6b65 724c 6973 7430      'markerList0
-0000bea0: 273a 206d 6172 6b65 724c 6973 7430 2c0d  ': markerList0,.
-0000beb0: 0a20 2020 2020 2020 2020 2020 2020 276d  .             'm
-0000bec0: 6172 6b65 724c 6973 7431 273a 206d 6172  arkerList1': mar
-0000bed0: 6b65 724c 6973 7431 2c0d 0a20 2020 2020  kerList1,..     
-0000bee0: 2020 2020 2020 2020 2773 7072 696e 6744          'springD
-0000bef0: 616d 7065 724c 6973 7427 3a20 7370 7269  amperList': spri
-0000bf00: 6e67 4461 6d70 6572 4c69 7374 2c0d 0a20  ngDamperList,.. 
-0000bf10: 2020 2020 2020 2020 2020 2020 276a 6f69              'joi
-0000bf20: 6e74 546f 7271 7565 304c 6973 7427 3a20  ntTorque0List': 
-0000bf30: 6a6f 696e 7454 6f72 7175 6530 4c69 7374  jointTorque0List
-0000bf40: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000bf50: 276a 6f69 6e74 546f 7271 7565 314c 6973  'jointTorque1Lis
-0000bf60: 7427 3a20 6a6f 696e 7454 6f72 7175 6531  t': jointTorque1
-0000bf70: 4c69 7374 2c0d 0a20 2020 2020 2020 2020  List,..         
-0000bf80: 2020 2020 2775 6e69 7454 6f72 7175 6530      'unitTorque0
-0000bf90: 4c69 7374 273a 2075 6e69 7454 6f72 7175  List': unitTorqu
-0000bfa0: 6530 4c69 7374 2c0d 0a20 2020 2020 2020  e0List,..       
-0000bfb0: 2020 2020 2020 2775 6e69 7454 6f72 7175        'unitTorqu
-0000bfc0: 6531 4c69 7374 273a 2075 6e69 7454 6f72  e1List': unitTor
-0000bfd0: 7175 6531 4c69 7374 2c0d 0a20 2020 2020  que1List,..     
-0000bfe0: 2020 2020 2020 2020 2762 6173 654f 626a          'baseObj
-0000bff0: 6563 7427 3a62 6173 654f 626a 6563 747d  ect':baseObject}
-0000c000: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0000c010: 2064 0d0a 2020 2020 0d0a 2020 2020 2020   d..    ..      
-0000c020: 2020 0d0a 2020 2020 0d0a 0d0a 2020 2020    ..    ....    
-0000c030: 2325 252b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  #%%+++++++++++++
-0000c040: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000c050: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000c060: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000c070: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000c080: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000c090: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000c0a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d 0a0d 0a20  +++++++++++.... 
-0000c0b0: 2020 2023 2a2a 636c 6173 7346 756e 6374     #**classFunct
-0000c0c0: 696f 6e3a 2065 7870 6f72 7420 6b69 6e65  ion: export kine
-0000c0d0: 6d61 7469 6354 7265 650d 0a20 2020 2064  maticTree..    d
-0000c0e0: 6566 2047 6574 4b69 6e65 6d61 7469 6354  ef GetKinematicT
-0000c0f0: 7265 6536 3628 7365 6c66 293a 0d0a 2020  ree66(self):..  
-0000c100: 2020 2020 2020 6672 6f6d 2065 7875 6479        from exudy
-0000c110: 6e2e 6b69 6e65 6d61 7469 6354 7265 6520  n.kinematicTree 
-0000c120: 696d 706f 7274 204b 696e 656d 6174 6963  import Kinematic
-0000c130: 5472 6565 3636 2c20 496e 6572 7469 6132  Tree66, Inertia2
-0000c140: 5436 360d 0a20 2020 2020 2020 200d 0a20  T66..        .. 
-0000c150: 2020 2020 2020 206a 6f69 6e74 5479 7065         jointType
-0000c160: 7320 3d20 5b5d 0d0a 2020 2020 2020 2020  s = []..        
-0000c170: 7472 616e 7366 6f72 6d61 7469 6f6e 7320  transformations 
-0000c180: 3d20 5b5d 0d0a 2020 2020 2020 2020 696e  = []..        in
-0000c190: 6572 7469 6173 203d 205b 5d0d 0a20 2020  ertias = []..   
-0000c1a0: 2020 2020 206e 203d 206c 656e 2873 656c       n = len(sel
-0000c1b0: 662e 6c69 6e6b 7329 0d0a 2020 2020 2020  f.links)..      
-0000c1c0: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-0000c1d0: 286e 293a 0d0a 2020 2020 2020 2020 2020  (n):..          
-0000c1e0: 2020 6c69 6e6b 203d 2073 656c 662e 6c69    link = self.li
-0000c1f0: 6e6b 735b 695d 0d0a 2020 2020 2020 2020  nks[i]..        
-0000c200: 2020 2020 6a6f 696e 7454 7970 6573 202b      jointTypes +
-0000c210: 3d20 5b6c 696e 6b2e 6a6f 696e 7454 7970  = [link.jointTyp
-0000c220: 655d 0d0a 2020 2020 2020 2020 2020 2020  e]..            
-0000c230: 0d0a 2020 2020 2020 2020 2020 2020 7072  ..            pr
-0000c240: 6548 5420 3d20 6c69 6e6b 2e70 7265 4854  eHT = link.preHT
-0000c250: 0d0a 2020 2020 2020 2020 2020 2020 416d  ..            Am
-0000c260: 6174 203d 2065 7262 2e48 5432 726f 7461  at = erb.HT2rota
-0000c270: 7469 6f6e 4d61 7472 6978 2870 7265 4854  tionMatrix(preHT
-0000c280: 2920 0d0a 2020 2020 2020 2020 2020 2020  ) ..            
-0000c290: 7656 6563 203d 2065 7262 2e48 5432 7472  vVec = erb.HT2tr
-0000c2a0: 616e 736c 6174 696f 6e28 7072 6548 5429  anslation(preHT)
-0000c2b0: 0d0a 2020 2020 2020 2020 2020 2020 583d  ..            X=
-0000c2c0: 6572 622e 526f 7461 7469 6f6e 5472 616e  erb.RotationTran
-0000c2d0: 736c 6174 696f 6e32 5436 3649 6e76 6572  slation2T66Inver
-0000c2e0: 7365 2841 3d41 6d61 742c 2076 3d76 5665  se(A=Amat, v=vVe
-0000c2f0: 6329 0d0a 2020 2020 2020 2020 2020 2020  c)..            
-0000c300: 6966 206e 702e 6c69 6e61 6c67 2e6e 6f72  if np.linalg.nor
-0000c310: 6d28 6c69 6e6b 2e6c 6f63 616c 4854 202d  m(link.localHT -
-0000c320: 2065 7262 2e48 5430 2829 2920 3e20 3165   erb.HT0()) > 1e
-0000c330: 2d31 353a 0d0a 2020 2020 2020 2020 2020  -15:..          
-0000c340: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-0000c350: 6545 7272 6f72 2827 4765 744b 696e 656d  eError('GetKinem
-0000c360: 6174 6963 5472 6565 3636 2829 3a20 6e6f  aticTree66(): no
-0000c370: 7420 696d 706c 656d 656e 7465 6420 666f  t implemented fo
-0000c380: 7220 6c69 6e6b 7320 7769 7468 206c 6f63  r links with loc
-0000c390: 616c 4854 2021 3d20 4854 3028 2927 290d  alHT != HT0()').
-0000c3a0: 0a20 2020 2020 2020 2020 2020 200d 0a20  .            .. 
-0000c3b0: 2020 2020 2020 2020 2020 2074 7261 6e73             trans
-0000c3c0: 666f 726d 6174 696f 6e73 202b 3d20 5b58  formations += [X
-0000c3d0: 5d20 2364 6566 696e 6573 2074 7261 6e73  ] #defines trans
-0000c3e0: 666f 726d 6174 696f 6e20 746f 206a 6f69  formation to joi
-0000c3f0: 6e74 2069 6e20 7061 7265 6e74 206c 696e  nt in parent lin
-0000c400: 6b0d 0a20 2020 2020 2020 2020 2020 204a  k..            J
-0000c410: 203d 2065 7262 2e52 6967 6964 426f 6479   = erb.RigidBody
-0000c420: 496e 6572 7469 6128 6d61 7373 3d6c 696e  Inertia(mass=lin
-0000c430: 6b2e 6d61 7373 2c20 696e 6572 7469 6154  k.mass, inertiaT
-0000c440: 656e 736f 723d 6c69 6e6b 2e69 6e65 7274  ensor=link.inert
-0000c450: 6961 2920 236c 696e 6b2e 696e 6572 7469  ia) #link.inerti
-0000c460: 6120 6172 6f75 6e64 2043 4f4d 0d0a 2020  a around COM..  
-0000c470: 2020 2020 2020 2020 2020 4a20 3d20 4a2e            J = J.
-0000c480: 5472 616e 736c 6174 6564 286c 696e 6b2e  Translated(link.
-0000c490: 434f 4d29 0d0a 2020 2020 2020 2020 2020  COM)..          
-0000c4a0: 2020 696e 6572 7469 6173 202b 3d20 5b49    inertias += [I
-0000c4b0: 6e65 7274 6961 3254 3636 284a 295d 0d0a  nertia2T66(J)]..
-0000c4c0: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-0000c4d0: 2020 4b54 3d4b 696e 656d 6174 6963 5472    KT=KinematicTr
-0000c4e0: 6565 3636 286c 6973 744f 664a 6f69 6e74  ee66(listOfJoint
-0000c4f0: 5479 7065 733d 6a6f 696e 7454 7970 6573  Types=jointTypes
-0000c500: 2c20 0d0a 2020 2020 2020 2020 2020 2020  , ..            
-0000c510: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000c520: 6973 744f 6654 7261 6e73 666f 726d 6174  istOfTransformat
-0000c530: 696f 6e73 3d74 7261 6e73 666f 726d 6174  ions=transformat
-0000c540: 696f 6e73 2c20 0d0a 2020 2020 2020 2020  ions, ..        
-0000c550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c560: 2020 206c 6973 744f 6649 6e65 7274 6961     listOfInertia
-0000c570: 733d 696e 6572 7469 6173 2c20 0d0a 2020  s=inertias, ..  
-0000c580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c590: 2020 2020 2020 2020 2067 7261 7669 7479           gravity
-0000c5a0: 3d73 656c 662e 6772 6176 6974 7929 0d0a  =self.gravity)..
-0000c5b0: 2020 2020 2020 2020 7265 7475 726e 204b          return K
-0000c5c0: 540d 0a20 2020 200d 0a20 2020 2023 2a2a  T..    ..    #**
-0000c5d0: 636c 6173 7346 756e 6374 696f 6e3a 2063  classFunction: c
-0000c5e0: 7265 6174 6520 6c69 6e6b 2047 7261 7068  reate link Graph
-0000c5f0: 6963 7344 6174 6120 286c 6973 7429 2066  icsData (list) f
-0000c600: 6f72 206c 696e 6b20 693b 2069 6e74 6572  or link i; inter
-0000c610: 6e61 6c6c 7920 7573 6564 2069 6e20 4372  nally used in Cr
-0000c620: 6561 7465 5265 6475 6e64 616e 7443 6f6f  eateRedundantCoo
-0000c630: 7264 696e 6174 654d 4253 282e 2e2e 293b  rdinateMBS(...);
-0000c640: 206c 696e 6b56 6973 7561 6c69 7a61 7469   linkVisualizati
-0000c650: 6f6e 2063 6f6e 7461 696e 7320 7669 7375  on contains visu
-0000c660: 616c 697a 6174 696f 6e20 6469 6374 206f  alization dict o
-0000c670: 6620 6c69 6e6b 0d0a 2020 2020 6465 6620  f link..    def 
-0000c680: 4765 744c 696e 6b47 7261 7068 6963 7344  GetLinkGraphicsD
-0000c690: 6174 6128 7365 6c66 2c20 692c 2070 302c  ata(self, i, p0,
-0000c6a0: 2070 312c 2061 7869 7330 2c20 6178 6973   p1, axis0, axis
-0000c6b0: 312c 206c 696e 6b56 6973 7561 6c69 7a61  1, linkVisualiza
-0000c6c0: 7469 6f6e 293a 0d0a 2020 2020 2020 2020  tion):..        
-0000c6d0: 0d0a 2020 2020 2020 2020 636f 6d20 3d20  ..        com = 
-0000c6e0: 7365 6c66 2e6c 696e 6b73 5b69 5d2e 434f  self.links[i].CO
-0000c6f0: 4d0d 0a20 2020 2020 2020 2067 7261 7068  M..        graph
-0000c700: 6963 734c 6973 7420 3d20 5b5d 0d0a 0d0a  icsList = []....
-0000c710: 2020 2020 2020 2020 7220 3d20 6c69 6e6b          r = link
-0000c720: 5669 7375 616c 697a 6174 696f 6e2e 6a6f  Visualization.jo
-0000c730: 696e 7452 6164 6975 730d 0a20 2020 2020  intRadius..     
-0000c740: 2020 2077 4a20 3d20 6c69 6e6b 5669 7375     wJ = linkVisu
-0000c750: 616c 697a 6174 696f 6e2e 6a6f 696e 7457  alization.jointW
-0000c760: 6964 7468 0d0a 2020 2020 2020 2020 774c  idth..        wL
-0000c770: 203d 206c 696e 6b56 6973 7561 6c69 7a61   = linkVisualiza
-0000c780: 7469 6f6e 2e6c 696e 6b57 6964 7468 0d0a  tion.linkWidth..
-0000c790: 2020 2020 2020 2020 636f 6c6f 7220 3d20          color = 
-0000c7a0: 6c69 6e6b 5669 7375 616c 697a 6174 696f  linkVisualizatio
-0000c7b0: 6e2e 6c69 6e6b 436f 6c6f 720d 0a0d 0a20  n.linkColor.... 
-0000c7c0: 2020 2020 2020 2023 6472 6177 2043 4f4d         #draw COM
-0000c7d0: 3a0d 0a20 2020 2020 2020 2069 6620 6c69  :..        if li
-0000c7e0: 6e6b 5669 7375 616c 697a 6174 696f 6e2e  nkVisualization.
-0000c7f0: 7368 6f77 434f 4d3a 0d0a 2020 2020 2020  showCOM:..      
-0000c800: 2020 2020 2020 6464 203d 2072 2a30 2e32        dd = r*0.2
-0000c810: 0d0a 2020 2020 2020 2020 2020 2020 636f  ..            co
-0000c820: 6c6f 7243 4f4d 203d 2063 6f70 7928 636f  lorCOM = copy(co
-0000c830: 6c6f 7229 0d0a 2020 2020 2020 2020 2020  lor)..          
-0000c840: 2020 636f 6c6f 7243 4f4d 5b30 5d20 2a3d    colorCOM[0] *=
-0000c850: 2030 2e38 2023 6d61 6b65 2043 4f4d 2061   0.8 #make COM a
-0000c860: 206c 6974 746c 6520 6461 726b 6572 0d0a   little darker..
-0000c870: 2020 2020 2020 2020 2020 2020 636f 6c6f              colo
-0000c880: 7243 4f4d 5b31 5d20 2a3d 2030 2e38 0d0a  rCOM[1] *= 0.8..
-0000c890: 2020 2020 2020 2020 2020 2020 636f 6c6f              colo
-0000c8a0: 7243 4f4d 5b32 5d20 2a3d 2030 2e38 0d0a  rCOM[2] *= 0.8..
-0000c8b0: 2020 2020 2020 2020 2020 2020 6772 6170              grap
-0000c8c0: 6869 6373 4c69 7374 202b 3d20 5b65 6764  hicsList += [egd
-0000c8d0: 2e47 7261 7068 6963 7344 6174 614f 7274  .GraphicsDataOrt
-0000c8e0: 686f 4375 6265 506f 696e 7428 636f 6d2c  hoCubePoint(com,
-0000c8f0: 205b 6464 2c64 642c 6464 5d2c 2063 6f6c   [dd,dd,dd], col
-0000c900: 6f72 434f 4d29 5d0d 0a0d 0a20 2020 2020  orCOM)]....     
-0000c910: 2020 2023 6472 6177 206c 696e 6b3a 0d0a     #draw link:..
-0000c920: 2020 2020 2020 2020 6966 2072 2021 3d20          if r != 
-0000c930: 303a 0d0a 2020 2020 2020 2020 2020 2020  0:..            
-0000c940: 6830 203d 2030 2e35 2a77 4a20 2020 2368  h0 = 0.5*wJ   #h
-0000c950: 6569 6768 7420 6f66 2068 616c 6620 6178  eight of half ax
-0000c960: 6973 2c20 6669 7273 7420 6a6f 696e 740d  is, first joint.
-0000c970: 0a20 2020 2020 2020 2020 2020 2068 3120  .            h1 
-0000c980: 3d20 302e 352a 774a 2020 2023 6865 6967  = 0.5*wJ   #heig
-0000c990: 6874 206f 6620 6861 6c66 2061 7869 732c  ht of half axis,
-0000c9a0: 2073 6563 6f6e 6420 6a6f 696e 740d 0a0d   second joint...
-0000c9b0: 0a20 2020 2020 2020 2020 2020 2023 6669  .            #fi
-0000c9c0: 7273 7420 6379 6c69 6e64 6572 2073 686f  rst cylinder sho
-0000c9d0: 756c 6420 6265 2064 7261 776e 2061 7420  uld be drawn at 
-0000c9e0: 6261 7365 3a0d 0a20 2020 2020 2020 2020  base:..         
-0000c9f0: 2020 2023 2069 6620 6920 3d3d 2030 3a20     # if i == 0: 
-0000ca00: 2364 7261 7720 6675 6c6c 2063 796c 696e  #draw full cylin
-0000ca10: 6465 7220 666f 7220 6669 7273 7420 6a6f  der for first jo
-0000ca20: 696e 740d 0a20 2020 2020 2020 2020 2020  int..           
-0000ca30: 2023 2020 2020 2068 3020 3d20 774a 0d0a   #     h0 = wJ..
-0000ca40: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-0000ca50: 2069 2021 3d20 303a 0d0a 2020 2020 2020   i != 0:..      
-0000ca60: 2020 2020 2020 2020 2020 6772 6170 6869            graphi
-0000ca70: 6373 4c69 7374 202b 3d20 5b65 6764 2e47  csList += [egd.G
-0000ca80: 7261 7068 6963 7344 6174 6143 796c 696e  raphicsDataCylin
-0000ca90: 6465 7228 7041 7869 733d 7030 2c20 7641  der(pAxis=p0, vA
-0000caa0: 7869 733d 2d68 302a 6e70 2e61 7272 6179  xis=-h0*np.array
-0000cab0: 2861 7869 7330 292c 200d 0a20 2020 2020  (axis0), ..     
-0000cac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000caf0: 2072 6164 6975 733d 722c 2063 6f6c 6f72   radius=r, color
-0000cb00: 3d63 6f6c 6f72 295d 0d0a 2020 2020 2020  =color)]..      
-0000cb10: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-0000cb20: 2020 2020 6772 6170 6869 6373 4c69 7374      graphicsList
-0000cb30: 202b 3d20 5b65 6764 2e47 7261 7068 6963   += [egd.Graphic
-0000cb40: 7344 6174 6143 796c 696e 6465 7228 7041  sDataCylinder(pA
-0000cb50: 7869 733d 7031 2c20 7641 7869 733d 2068  xis=p1, vAxis= h
-0000cb60: 312a 6e70 2e61 7272 6179 2861 7869 7331  1*np.array(axis1
-0000cb70: 292c 200d 0a20 2020 2020 2020 2020 2020  ), ..           
-0000cb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cba0: 2020 2020 2020 2020 2020 2072 6164 6975             radiu
-0000cbb0: 733d 722c 2063 6f6c 6f72 3d63 6f6c 6f72  s=r, color=color
-0000cbc0: 295d 0d0a 0d0a 2020 2020 2020 2020 2020  )]....          
-0000cbd0: 2020 2364 7261 7720 626f 6479 2061 7320    #draw body as 
-0000cbe0: 6379 6c69 6e64 6572 3a0d 0a20 2020 2020  cylinder:..     
-0000cbf0: 2020 2020 2020 2069 6620 6562 752e 4e6f         if ebu.No
-0000cc00: 726d 4c32 2865 6275 2e56 5375 6228 7031  rmL2(ebu.VSub(p1
-0000cc10: 2c70 3029 2920 3e20 3165 2d31 353a 0d0a  ,p0)) > 1e-15:..
-0000cc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc30: 6772 6170 6869 6373 4c69 7374 202b 3d20  graphicsList += 
-0000cc40: 5b65 6764 2e47 7261 7068 6963 7344 6174  [egd.GraphicsDat
-0000cc50: 6143 796c 696e 6465 7228 7041 7869 733d  aCylinder(pAxis=
-0000cc60: 7031 2c20 7641 7869 733d 6562 752e 5653  p1, vAxis=ebu.VS
-0000cc70: 7562 2870 302c 7031 292c 200d 0a20 2020  ub(p0,p1), ..   
-0000cc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ccb0: 2020 2072 6164 6975 733d 302e 352a 774c     radius=0.5*wL
-0000ccc0: 2c20 636f 6c6f 723d 636f 6c6f 7229 5d0d  , color=color)].
-0000ccd0: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-0000cce0: 2020 2072 6574 7572 6e20 6772 6170 6869     return graphi
-0000ccf0: 6373 4c69 7374 0d0a 0d0a 2020 2020 0d0a  csList....    ..
-0000cd00: 2020 2020 232a 2a63 6c61 7373 4675 6e63      #**classFunc
-0000cd10: 7469 6f6e 3a20 6275 696c 6420 726f 626f  tion: build robo
-0000cd20: 7420 7374 7275 6374 7265 2066 726f 6d20  t structre from 
-0000cd30: 6469 6374 696f 6e61 7279 3b20 7468 6973  dictionary; this
-0000cd40: 2069 7320 6120 4445 5052 4543 4154 4544   is a DEPRECATED
-0000cd50: 2066 756e 6374 696f 6e2c 2077 6869 6368   function, which
-0000cd60: 2069 7320 7573 6564 2069 6e20 6f6c 6465   is used in olde
-0000cd70: 7220 6d6f 6465 6c73 3b20 444f 204e 4f54  r models; DO NOT
-0000cd80: 2055 5345 0d0a 2020 2020 6465 6620 4275   USE..    def Bu
-0000cd90: 696c 6446 726f 6d44 6963 7469 6f6e 6172  ildFromDictionar
-0000cda0: 7928 7365 6c66 2c20 726f 626f 7444 6963  y(self, robotDic
-0000cdb0: 7429 3a0d 0a20 2020 2020 2020 2067 6c6f  t):..        glo
-0000cdc0: 6261 6c20 6275 696c 6446 726f 6d44 6963  bal buildFromDic
-0000cdd0: 7469 6f6e 6172 7957 6172 6e65 640d 0a20  tionaryWarned.. 
-0000cde0: 2020 2020 2020 2069 6620 6e6f 7420 6275         if not bu
-0000cdf0: 696c 6446 726f 6d44 6963 7469 6f6e 6172  ildFromDictionar
-0000ce00: 7957 6172 6e65 643a 0d0a 2020 2020 2020  yWarned:..      
-0000ce10: 2020 2020 2020 6275 696c 6446 726f 6d44        buildFromD
-0000ce20: 6963 7469 6f6e 6172 7957 6172 6e65 6420  ictionaryWarned 
-0000ce30: 3d20 5472 7565 0d0a 2020 2020 2020 2020  = True..        
-0000ce40: 2020 2020 7072 696e 7428 2257 4152 4e49      print("WARNI
-0000ce50: 4e47 3a20 6675 6e63 7469 6f6e 2042 7569  NG: function Bui
-0000ce60: 6c64 4672 6f6d 4469 6374 696f 6e61 7279  ldFromDictionary
-0000ce70: 2069 6e20 636c 6173 7320 526f 626f 7420   in class Robot 
-0000ce80: 6973 2044 4550 5245 4341 5445 443b 2044  is DEPRECATED; D
-0000ce90: 4f20 4e4f 5420 5553 4522 290d 0a0d 0a20  O NOT USE").... 
-0000cea0: 2020 2020 2020 2069 6620 2762 6173 6527         if 'base'
-0000ceb0: 2069 6e20 726f 626f 7444 6963 743a 0d0a   in robotDict:..
-0000cec0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000ced0: 2e62 6173 652e 4854 203d 206e 702e 6172  .base.HT = np.ar
-0000cee0: 7261 7928 726f 626f 7444 6963 745b 2762  ray(robotDict['b
-0000cef0: 6173 6527 5d5b 2748 5427 5d29 0d0a 2020  ase']['HT'])..  
-0000cf00: 2020 2020 2020 6966 2027 746f 6f6c 2720        if 'tool' 
-0000cf10: 696e 2072 6f62 6f74 4469 6374 3a0d 0a20  in robotDict:.. 
-0000cf20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000cf30: 746f 6f6c 2e48 5420 3d20 6e70 2e61 7272  tool.HT = np.arr
-0000cf40: 6179 2872 6f62 6f74 4469 6374 5b27 746f  ay(robotDict['to
-0000cf50: 6f6c 275d 5b27 4854 275d 290d 0a20 2020  ol']['HT'])..   
-0000cf60: 2020 2020 2069 6620 2767 7261 7669 7479       if 'gravity
-0000cf70: 2720 696e 2072 6f62 6f74 4469 6374 3a0d  ' in robotDict:.
-0000cf80: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000cf90: 662e 6772 6176 6974 7920 3d20 6e70 2e61  f.gravity = np.a
-0000cfa0: 7272 6179 2872 6f62 6f74 4469 6374 5b27  rray(robotDict['
-0000cfb0: 6772 6176 6974 7927 5d29 0d0a 2020 2020  gravity'])..    
-0000cfc0: 2020 2020 6966 2027 7265 6665 7265 6e63      if 'referenc
-0000cfd0: 6543 6f6e 6669 6775 7261 7469 6f6e 2720  eConfiguration' 
-0000cfe0: 696e 2072 6f62 6f74 4469 6374 3a0d 0a20  in robotDict:.. 
-0000cff0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000d000: 7265 6665 7265 6e63 6543 6f6e 6669 6775  referenceConfigu
-0000d010: 7261 7469 6f6e 203d 206e 702e 6172 7261  ration = np.arra
-0000d020: 7928 726f 626f 7444 6963 745b 2772 6566  y(robotDict['ref
-0000d030: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
-0000d040: 696f 6e27 5d29 0d0a 2020 2020 2020 2020  ion'])..        
-0000d050: 0d0a 2020 2020 2020 2020 7761 726e 6564  ..        warned
-0000d060: 4d6f 6444 4820 3d20 4661 6c73 650d 0a20  ModDH = False.. 
-0000d070: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
-0000d080: 7261 6e67 6528 6c65 6e28 726f 626f 7444  range(len(robotD
-0000d090: 6963 745b 276c 696e 6b73 275d 2929 3a0d  ict['links'])):.
-0000d0a0: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
-0000d0b0: 6b20 3d20 726f 626f 7444 6963 745b 276c  k = robotDict['l
-0000d0c0: 696e 6b73 275d 5b69 5d0d 0a20 2020 2020  inks'][i]..     
-0000d0d0: 2020 2020 2020 2023 2071 5265 6620 3d20         # qRef = 
-0000d0e0: 300d 0a20 2020 2020 2020 2020 2020 2023  0..            #
-0000d0f0: 2069 6620 6c65 6e28 726f 626f 7444 6963   if len(robotDic
-0000d100: 745b 2772 6566 6572 656e 6365 436f 6e66  t['referenceConf
-0000d110: 6967 7572 6174 696f 6e27 5d29 203e 2069  iguration']) > i
-0000d120: 3a0d 0a20 2020 2020 2020 2020 2020 2023  :..            #
-0000d130: 2020 2020 2071 5265 6620 3d20 726f 626f       qRef = robo
-0000d140: 7444 6963 745b 2772 6566 6572 656e 6365  tDict['reference
-0000d150: 436f 6e66 6967 7572 6174 696f 6e27 5d5b  Configuration'][
-0000d160: 695d 0d0a 2020 2020 2020 2020 2020 2020  i]..            
-0000d170: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-0000d180: 2027 7374 6444 4827 2069 6e20 6c69 6e6b   'stdDH' in link
-0000d190: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000d1a0: 2020 206c 6f63 616c 4854 203d 2053 7464     localHT = Std
-0000d1b0: 4448 3248 5428 6c69 6e6b 5b27 7374 6444  DH2HT(link['stdD
-0000d1c0: 4827 5d29 2023 7573 696e 6720 7468 6574  H']) #using thet
-0000d1d0: 613d 300d 0a20 2020 2020 2020 2020 2020  a=0..           
-0000d1e0: 2023 6d6f 6469 6669 6564 2044 4820 7061   #modified DH pa
-0000d1f0: 7261 6d65 7465 7273 2061 7265 2072 652d  rameters are re-
-0000d200: 696e 7465 7270 7265 7465 6420 6173 2073  interpreted as s
-0000d210: 7461 6e64 6172 6420 4448 2070 6172 616d  tandard DH param
-0000d220: 6574 6572 732c 2077 6869 6368 2064 6f65  eters, which doe
-0000d230: 7320 6e6f 7420 616c 7761 7973 2077 6f72  s not always wor
-0000d240: 6b20 2f20 6e65 6564 7320 6164 6469 7469  k / needs additi
-0000d250: 6f6e 616c 2061 646a 7573 746d 656e 7473  onal adjustments
-0000d260: 210d 0a20 2020 2020 2020 2020 2020 2065  !..            e
-0000d270: 6c69 6620 276d 6f64 4448 6372 6169 6727  lif 'modDHcraig'
-0000d280: 2069 6e20 6c69 6e6b 3a20 2361 6363 6f72   in link: #accor
-0000d290: 6469 6e67 2074 6f20 4372 6169 6720 2831  ding to Craig (1
-0000d2a0: 3938 3629 2061 6e64 206d 6f64 6966 6965  986) and modifie
-0000d2b0: 6420 4448 2070 6172 616d 6574 6572 7320  d DH parameters 
-0000d2c0: 696e 2043 6f72 6b65 2773 2074 6f6f 6c62  in Corke's toolb
-0000d2d0: 6f78 2028 3230 3137 290d 0a20 2020 2020  ox (2017)..     
-0000d2e0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-0000d2f0: 7420 7761 726e 6564 4d6f 6444 483a 0d0a  t warnedModDH:..
-0000d300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d310: 2020 2020 7761 726e 6564 4d6f 6444 4820      warnedModDH 
-0000d320: 3d20 5472 7565 0d0a 2020 2020 2020 2020  = True..        
-0000d330: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000d340: 7428 2757 4152 4e49 4e47 3a20 4275 696c  t('WARNING: Buil
-0000d350: 6446 726f 6d44 6963 7469 6f6e 6172 7920  dFromDictionary 
-0000d360: 756e 7465 7374 6564 2066 6f72 206d 6f64  untested for mod
-0000d370: 4448 3b20 6d69 7373 696e 6720 7472 616e  DH; missing tran
-0000d380: 7366 6f72 6d61 7469 6f6e 2066 6f72 2069  sformation for i
-0000d390: 6e65 7274 6961 2061 6e64 2043 4f4d 3f27  nertia and COM?'
-0000d3a0: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000d3b0: 2020 205b 7468 6574 612c 2064 2c20 612c     [theta, d, a,
-0000d3c0: 2061 6c70 6861 5d20 3d20 6c69 6e6b 5b27   alpha] = link['
-0000d3d0: 6d6f 6444 4863 7261 6967 275d 0d0a 2020  modDHcraig']..  
-0000d3e0: 2020 2020 2020 2020 2020 2020 2020 6131                a1
-0000d3f0: 203d 2030 2023 6966 206e 6f20 7375 6363   = 0 #if no succ
-0000d400: 6565 6469 6e67 206c 696e 6b20 666f 6c6c  eeding link foll
-0000d410: 6f77 730d 0a20 2020 2020 2020 2020 2020  ows..           
-0000d420: 2020 2020 2061 6c70 6861 3120 3d20 300d       alpha1 = 0.
-0000d430: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d440: 2069 6620 6920 3c20 6c65 6e28 726f 626f   if i < len(robo
-0000d450: 7444 6963 745b 276c 696e 6b73 275d 292d  tDict['links'])-
-0000d460: 313a 2023 7468 6572 6520 6578 6973 7473  1: #there exists
-0000d470: 2061 206e 6578 7420 6c69 6e6b 2c20 7768   a next link, wh
-0000d480: 6963 6820 7765 2075 7365 2061 7320 6164  ich we use as ad
-0000d490: 6469 7469 6f6e 616c 2073 7461 6e64 6172  ditional standar
-0000d4a0: 6420 4448 2d70 6172 616d 6574 6572 7320  d DH-parameters 
-0000d4b0: 666f 7220 7468 6973 206c 696e 6b0d 0a20  for this link.. 
-0000d4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d4d0: 2020 205b 7468 6574 6131 2c20 6431 2c20     [theta1, d1, 
-0000d4e0: 6131 2c20 616c 7068 6131 5d20 3d20 6c69  a1, alpha1] = li
-0000d4f0: 6e6b 5b27 6d6f 6444 4863 7261 6967 275d  nk['modDHcraig']
-0000d500: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000d510: 2020 6966 2069 203d 3d20 303a 2023 7075    if i == 0: #pu
-0000d520: 7420 6669 7273 7420 7477 6f20 4448 2070  t first two DH p
-0000d530: 6172 616d 6574 6572 7320 746f 2062 6173  arameters to bas
-0000d540: 650d 0a20 2020 2020 2020 2020 2020 2020  e..             
-0000d550: 2020 2020 2020 2073 656c 662e 6261 7365         self.base
-0000d560: 2e48 5420 3d20 7365 6c66 2e62 6173 652e  .HT = self.base.
-0000d570: 4854 2040 2065 7262 2e48 5472 6f74 6174  HT @ erb.HTrotat
-0000d580: 6558 2861 6c70 6861 2920 4020 6572 622e  eX(alpha) @ erb.
-0000d590: 4854 7472 616e 736c 6174 6528 5b61 2c30  HTtranslate([a,0
-0000d5a0: 2c30 5d29 200d 0a20 2020 2020 2020 2020  ,0]) ..         
-0000d5b0: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-0000d5c0: 2020 2020 2020 2020 2023 6c6f 6361 6c20           #local 
-0000d5d0: 4854 2072 652d 696e 7465 7270 7265 7465  HT re-interprete
-0000d5e0: 6420 6173 2073 7461 6e64 6172 6420 4448  d as standard DH
-0000d5f0: 2d70 6172 616d 6574 6572 732c 2061 7320  -parameters, as 
-0000d600: 7375 6767 6573 7465 6420 6279 2043 6f72  suggested by Cor
-0000d610: 6b65 2032 3031 372c 2070 6167 6520 3231  ke 2017, page 21
-0000d620: 393a 0d0a 2020 2020 2020 2020 2020 2020  9:..            
-0000d630: 2020 2020 6c6f 6361 6c48 5420 3d20 6572      localHT = er
-0000d640: 622e 4854 726f 7461 7465 5a28 7468 6574  b.HTrotateZ(thet
-0000d650: 6129 2040 2065 7262 2e48 5474 7261 6e73  a) @ erb.HTtrans
-0000d660: 6c61 7465 285b 302c 302c 645d 2920 4020  late([0,0,d]) @ 
-0000d670: 6572 622e 4854 7472 616e 736c 6174 6528  erb.HTtranslate(
-0000d680: 5b61 312c 302c 305d 2920 4020 6572 622e  [a1,0,0]) @ erb.
-0000d690: 4854 726f 7461 7465 5828 616c 7068 6131  HTrotateX(alpha1
-0000d6a0: 290d 0a20 2020 2020 2020 2020 2020 2065  )..            e
-0000d6b0: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-0000d6c0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-0000d6d0: 6545 7272 6f72 2827 4275 696c 6446 726f  eError('BuildFro
-0000d6e0: 6d44 6963 7469 6f6e 6172 7920 696e 2063  mDictionary in c
-0000d6f0: 6c61 7373 2052 6f62 6f74 3a20 6f6e 6c79  lass Robot: only
-0000d700: 2073 7570 706f 7274 7320 6c69 6e6b 7320   supports links 
-0000d710: 7769 7468 2073 7464 4448 2070 6172 616d  with stdDH param
-0000d720: 6574 6572 7327 290d 0a0d 0a20 2020 2020  eters')....     
-0000d730: 2020 2020 2020 2072 6f62 6f74 4c69 6e6b         robotLink
-0000d740: 203d 2052 6f62 6f74 4c69 6e6b 286d 6173   = RobotLink(mas
-0000d750: 733d 6c69 6e6b 5b27 6d61 7373 275d 2c20  s=link['mass'], 
-0000d760: 434f 4d3d 6c69 6e6b 5b27 434f 4d27 5d2c  COM=link['COM'],
-0000d770: 2069 6e65 7274 6961 3d6c 696e 6b5b 2769   inertia=link['i
-0000d780: 6e65 7274 6961 275d 2c20 6c6f 6361 6c48  nertia'], localH
-0000d790: 543d 6c6f 6361 6c48 5429 0d0a 2020 2020  T=localHT)..    
-0000d7a0: 2020 2020 2020 2020 7365 6c66 2e41 6464          self.Add
-0000d7b0: 4c69 6e6b 2872 6f62 6f74 4c69 6e6b 290d  Link(robotLink).
-0000d7c0: 0a0d 0a20 2020 2020 2020 200d 0a0d 0a23  ...        ....#
-0000d7d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d7e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d7f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d800: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d810: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d820: 2b2b 2b2b 0d0a 232b 2b2b 2020 4448 2d50  ++++..#+++  DH-P
-0000d830: 4152 414d 4554 4552 5320 202b 2b2b 2b2b  ARAMETERS  +++++
-0000d840: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d850: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d860: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d870: 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d 0a23 2b2b  +++++++++++..#++
-0000d880: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d890: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d8a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d8b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d8c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000d8d0: 2b2b 0d0a 0d0a 232a 2a66 756e 6374 696f  ++....#**functio
-0000d8e0: 6e3a 2063 6f6d 7075 7465 2068 6f6d 6f67  n: compute homog
-0000d8f0: 656e 656f 7573 2074 7261 6e73 666f 726d  eneous transform
-0000d900: 6174 696f 6e20 6d61 7472 6978 2048 5420  ation matrix HT 
-0000d910: 6672 6f6d 2073 7461 6e64 6172 6420 4448  from standard DH
-0000d920: 7061 7261 6d65 7465 7273 3d5b 7468 6574  parameters=[thet
-0000d930: 612c 2064 2c20 612c 2061 6c70 6861 5d0d  a, d, a, alpha].
-0000d940: 0a64 6566 2053 7464 4448 3248 5428 4448  .def StdDH2HT(DH
-0000d950: 7061 7261 6d65 7465 7273 293a 0d0a 2320  parameters):..# 
-0000d960: 2020 205b 7468 6574 612c 2064 2c20 612c     [theta, d, a,
-0000d970: 2061 6c70 6861 5d20 3d20 4448 7061 7261   alpha] = DHpara
-0000d980: 6d65 7465 7273 0d0a 2320 2020 2072 6574  meters..#    ret
-0000d990: 7572 6e20 6572 622e 4854 726f 7461 7465  urn erb.HTrotate
-0000d9a0: 5a28 7468 6574 6129 2040 2065 7262 2e48  Z(theta) @ erb.H
-0000d9b0: 5474 7261 6e73 6c61 7465 285b 302c 302c  Ttranslate([0,0,
-0000d9c0: 645d 2920 4020 6572 622e 4854 7472 616e  d]) @ erb.HTtran
-0000d9d0: 736c 6174 6528 5b61 2c30 2c30 5d29 2040  slate([a,0,0]) @
-0000d9e0: 2065 7262 2e48 5472 6f74 6174 6558 2861   erb.HTrotateX(a
-0000d9f0: 6c70 6861 290d 0a20 2020 2023 6f70 7469  lpha)..    #opti
-0000da00: 6d69 7a65 6420 7665 7273 696f 6e3a 0d0a  mized version:..
-0000da10: 2020 2020 5b74 6865 7461 2c20 642c 2061      [theta, d, a
-0000da20: 2c20 616c 7068 615d 203d 2044 4870 6172  , alpha] = DHpar
-0000da30: 616d 6574 6572 730d 0a20 2020 2063 7420  ameters..    ct 
-0000da40: 3d20 6e70 2e63 6f73 2874 6865 7461 290d  = np.cos(theta).
-0000da50: 0a20 2020 2073 7420 3d20 6e70 2e73 696e  .    st = np.sin
-0000da60: 2874 6865 7461 290d 0a20 2020 2063 6120  (theta)..    ca 
-0000da70: 3d20 6e70 2e63 6f73 2861 6c70 6861 290d  = np.cos(alpha).
-0000da80: 0a20 2020 2073 6120 3d20 6e70 2e73 696e  .    sa = np.sin
-0000da90: 2861 6c70 6861 290d 0a20 2020 2072 6574  (alpha)..    ret
-0000daa0: 7572 6e20 6e70 2e61 7272 6179 285b 5b63  urn np.array([[c
-0000dab0: 742c 2d73 742a 6361 2c20 7374 2a73 612c  t,-st*ca, st*sa,
-0000dac0: 2061 2a63 745d 2c0d 0a20 2020 2020 2020   a*ct],..       
-0000dad0: 2020 2020 2020 2020 2020 2020 2020 5b73                [s
-0000dae0: 742c 2063 742a 6361 2c2d 6374 2a73 612c  t, ct*ca,-ct*sa,
-0000daf0: 2061 2a73 745d 2c0d 0a20 2020 2020 2020   a*st],..       
-0000db00: 2020 2020 2020 2020 2020 2020 2020 5b20                [ 
-0000db10: 302c 2073 6120 2020 2c20 6361 2020 202c  0, sa   , ca   ,
-0000db20: 2064 2020 205d 2c0d 0a20 2020 2020 2020   d   ],..       
-0000db30: 2020 2020 2020 2020 2020 2020 2020 5b20                [ 
-0000db40: 302c 2030 2020 2020 2c20 3020 2020 202c  0, 0    , 0    ,
-0000db50: 2031 2020 205d 5d29 0d0a 0d0a 235c 6d66   1   ]])....#\mf
-0000db60: 6f75 727b 5c63 6f73 205c 7468 6574 615f  our{\cos \theta_
-0000db70: 6a20 262d 5c73 696e 205c 7468 6574 615f  j &-\sin \theta_
-0000db80: 6a20 5c63 6f73 205c 616c 7068 615f 6a20  j \cos \alpha_j 
-0000db90: 2620 5c73 696e 205c 7468 6574 615f 6a20  & \sin \theta_j 
-0000dba0: 5c73 696e 205c 616c 7068 615f 6a20 2620  \sin \alpha_j & 
-0000dbb0: 615f 6a20 5c63 6f73 205c 7468 6574 615f  a_j \cos \theta_
-0000dbc0: 6a7d 0d0a 2320 2020 2020 2020 2020 2020  j}..#           
-0000dbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dbf0: 2020 2020 2020 2020 2020 2020 207b 5c73               {\s
-0000dc00: 696e 205c 7468 6574 615f 6a20 2620 5c63  in \theta_j & \c
-0000dc10: 6f73 205c 7468 6574 615f 6a20 5c63 6f73  os \theta_j \cos
-0000dc20: 205c 616c 7068 615f 6a20 262d 5c63 6f73   \alpha_j &-\cos
-0000dc30: 205c 7468 6574 615f 6a20 5c73 696e 205c   \theta_j \sin \
-0000dc40: 616c 7068 615f 6a20 2620 615f 6a20 5c73  alpha_j & a_j \s
-0000dc50: 696e 205c 7468 6574 615f 6a7d 0d0a 2320  in \theta_j}..# 
-0000dc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc90: 2020 2020 2020 207b 3020 2020 2020 2020         {0       
-0000dca0: 2020 2020 2020 2620 5c73 696e 205c 616c        & \sin \al
-0000dcb0: 7068 615f 6a20 2020 2020 2020 2020 2020  pha_j           
-0000dcc0: 2020 2020 2620 5c63 6f73 205c 616c 7068      & \cos \alph
-0000dcd0: 615f 6a20 2020 2020 2020 2020 2020 2020  a_j             
-0000dce0: 2020 2620 645f 6a20 7d0d 0a23 2020 2020    & d_j }..#    
-0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd20: 2020 2020 7b30 2026 2030 2026 2030 2026      {0 & 0 & 0 &
-0000dd30: 2031 7d0d 0a23 5465 7374 2028 636f 6d70   1}..#Test (comp
-0000dd40: 6172 6564 2077 6974 6820 526f 626f 7463  ared with Robotc
-0000dd50: 732c 2056 6973 696f 6e20 616e 6420 436f  s, Vision and Co
-0000dd60: 6e74 726f 6c20 626f 6f6b 206f 6620 502e  ntrol book of P.
-0000dd70: 2043 6f72 6b65 3a0d 0a23 7072 696e 7428   Corke:..#print(
-0000dd80: 2273 7464 2e20 4448 203d 5c6e 222c 2044  "std. DH =\n", D
-0000dd90: 4832 4854 285b 302e 352c 2030 2e31 2c20  H2HT([0.5, 0.1, 
-0000dda0: 302e 322c 206e 702e 7069 2f32 5d29 2e72  0.2, np.pi/2]).r
-0000ddb0: 6f75 6e64 2834 2929 0d0a 0d0a 232a 2a66  ound(4))....#**f
-0000ddc0: 756e 6374 696f 6e3a 2063 6f6d 7075 7465  unction: compute
-0000ddd0: 2070 7265 2d20 616e 6420 706f 7374 2d20   pre- and post- 
-0000dde0: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
-0000ddf0: 7366 6f72 6d61 7469 6f6e 206d 6174 7269  sformation matri
-0000de00: 6365 7320 6672 6f6d 206d 6f64 6966 6965  ces from modifie
-0000de10: 6420 4465 6e61 7669 742d 4861 7274 656e  d Denavit-Harten
-0000de20: 6265 7267 2044 4870 6172 616d 6574 6572  berg DHparameter
-0000de30: 733d 5b61 6c70 6861 2c20 642c 2074 6865  s=[alpha, d, the
-0000de40: 7461 2c20 725d 3b20 7265 7475 726e 7320  ta, r]; returns 
-0000de50: 5b48 5470 7265 2c20 4854 706f 7374 5d3b  [HTpre, HTpost];
-0000de60: 2048 5470 7265 2069 7320 7472 616e 7366   HTpre is transf
-0000de70: 6f72 6d61 7469 6f6e 2062 6566 6f72 6520  ormation before 
-0000de80: 6178 6973 2072 6f74 6174 696f 6e2c 2048  axis rotation, H
-0000de90: 5470 6f73 7420 696e 636c 7564 6573 2061  Tpost includes a
-0000dea0: 7869 7320 726f 7461 7469 6f6e 2061 6e64  xis rotation and
-0000deb0: 2065 7665 7279 7468 696e 6720 6865 7265   everything here
-0000dec0: 6166 7465 723b 206d 6f64 6966 6965 6420  after; modified 
-0000ded0: 4448 2d50 6172 616d 6574 6572 7320 6163  DH-Parameters ac
-0000dee0: 636f 7264 696e 6720 746f 204b 6861 6c69  cording to Khali
-0000def0: 6c20 616e 6420 4b6c 6569 6e66 696e 6765  l and Kleinfinge
-0000df00: 722c 2031 3938 360d 0a64 6566 204d 6f64  r, 1986..def Mod
-0000df10: 4448 4b4b 3248 5428 4448 7061 7261 6d65  DHKK2HT(DHparame
-0000df20: 7465 7273 293a 0d0a 2020 2020 5b61 6c70  ters):..    [alp
-0000df30: 6861 2c20 642c 2074 6865 7461 2c20 725d  ha, d, theta, r]
-0000df40: 203d 2044 4870 6172 616d 6574 6572 730d   = DHparameters.
-0000df50: 0a20 2020 2072 6574 7572 6e20 5b65 7262  .    return [erb
-0000df60: 2e48 5472 6f74 6174 6558 2861 6c70 6861  .HTrotateX(alpha
-0000df70: 2920 4020 6572 622e 4854 7472 616e 736c  ) @ erb.HTtransl
-0000df80: 6174 6528 5b64 2c30 2c30 5d29 202c 2065  ate([d,0,0]) , e
-0000df90: 7262 2e48 5472 6f74 6174 655a 2874 6865  rb.HTrotateZ(the
-0000dfa0: 7461 2920 4020 6572 622e 4854 7472 616e  ta) @ erb.HTtran
-0000dfb0: 736c 6174 6528 5b30 2c30 2c72 5d29 205d  slate([0,0,r]) ]
-0000dfc0: 200d 0a0d 0a23 2b2b 2b2b 2b2b 2b2b 2b2b   ....#++++++++++
-0000dfd0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000dfe0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000dff0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e000: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e010: 2b2b 2b2b 2b2b 2b2b 2b2b 0d0a 232b 2b2b  ++++++++++..#+++
-0000e020: 0d0a 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ..#+++++++++++++
-0000e030: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e040: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e050: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e060: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e070: 2b2b 2b2b 2b2b 2b0d 0a23 2a2a 6675 6e63  +++++++..#**func
-0000e080: 7469 6f6e 3a20 5468 6973 2066 756e 6374  tion: This funct
-0000e090: 696f 6e20 7072 6f6a 6563 7473 2061 6e20  ion projects an 
-0000e0a0: 616e 676c 6520 696e 2074 6865 2072 616e  angle in the ran
-0000e0b0: 6765 2024 5b2d 6d69 6e5f 7b66 6c6f 6174  ge $[-min_{float
-0000e0c0: 7d2c 202b 6d61 785f 7b66 6c6f 6174 7d5d  }, +max_{float}]
-0000e0d0: 2420 666f 2074 6865 2072 616e 6765 2024  $ fo the range $
-0000e0e0: 5b2d 5c70 692c 202b 5c70 695d 240d 0a23  [-\pi, +\pi]$..#
-0000e0f0: 2a2a 696e 7075 743a 0d0a 2320 2071 303a  **input:..#  q0:
-0000e100: 2041 6e20 616e 676c 6520 6569 7468 6572   An angle either
-0000e110: 2061 7320 7363 616c 6172 2c20 6c69 7374   as scalar, list
-0000e120: 206f 7220 6172 7261 790d 0a23 2a2a 6f75   or array..#**ou
-0000e130: 7470 7574 3a0d 0a23 2020 7150 726f 6a3a  tput:..#  qProj:
-0000e140: 2054 6865 2061 6e67 6c65 2070 726f 6a65   The angle proje
-0000e150: 6374 6564 2069 6e74 6f20 7468 6520 7261  cted into the ra
-0000e160: 6e67 6520 245b 2d5c 7069 2074 6f20 5c70  nge $[-\pi to \p
-0000e170: 695d 240d 0a23 2a2a 6175 7468 6f72 3a20  i]$..#**author: 
-0000e180: 5065 7465 7220 4d61 6e7a 6c0d 0a64 6566  Peter Manzl..def
-0000e190: 2070 726f 6a65 6374 416e 676c 6554 6f50   projectAngleToP
-0000e1a0: 4d50 6928 7130 293a 200d 0a20 2020 2069  MPi(q0): ..    i
-0000e1b0: 6620 7479 7065 2871 3029 203d 3d20 6c69  f type(q0) == li
-0000e1c0: 7374 3a20 0d0a 2020 2020 2020 2020 7130  st: ..        q0
-0000e1d0: 203d 206e 702e 6172 7261 7928 7130 2920   = np.array(q0) 
-0000e1e0: 2320 6361 7374 2074 6f20 6172 7261 7920  # cast to array 
-0000e1f0: 666f 7220 6d6f 6475 6c6f 2074 6f20 776f  for modulo to wo
-0000e200: 726b 0d0a 2020 2020 7131 203d 2020 7130  rk..    q1 =  q0
-0000e210: 2025 2028 322a 6e70 2e70 6929 2023 2069   % (2*np.pi) # i
-0000e220: 6e20 7261 6e67 6520 3020 746f 2032 2a6e  n range 0 to 2*n
-0000e230: 702e 7069 0d0a 2020 2020 7150 726f 6a20  p.pi..    qProj 
-0000e240: 3d20 7131 202d 2032 2a6e 702e 7069 2a28  = q1 - 2*np.pi*(
-0000e250: 7131 203e 206e 702e 7069 290d 0a20 2020  q1 > np.pi)..   
-0000e260: 2072 6574 7572 6e20 7150 726f 6a0d 0a0d   return qProj...
-0000e270: 0a0d 0a23 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ...#++++++++++++
-0000e280: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e290: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e2a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e2b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e2c0: 2b2b 2b2b 2b2b 2b2b 0d0a 232b 2b2b 0d0a  ++++++++..#+++..
-0000e2d0: 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  #+++++++++++++++
-0000e2e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e2f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e300: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e310: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000e320: 2b2b 2b2b 2b0d 0a23 2a2a 636c 6173 733a  +++++..#**class:
-0000e330: 2054 6869 7320 636c 6173 7320 6361 6e20   This class can 
-0000e340: 6265 2075 7365 6420 746f 2073 6f6c 7665  be used to solve
-0000e350: 2074 6865 2069 6e76 6572 7365 206b 696e   the inverse kin
-0000e360: 656d 6174 6963 7320 7072 6f62 6c65 6d20  ematics problem 
-0000e370: 7573 696e 6720 6120 6d75 6c74 6962 6f64  using a multibod
-0000e380: 7920 7379 7374 656d 200d 0a23 2020 2020  y system ..#    
-0000e390: 2020 2020 2020 2020 6279 2073 6f6c 7669          by solvi
-0000e3a0: 6e67 2074 6865 2073 7461 7469 6320 7072  ng the static pr
-0000e3b0: 6f62 6c65 6d20 6f66 2061 2073 6572 6961  oblem of a seria
-0000e3c0: 6c20 726f 626f 740d 0a23 2a2a 6175 7468  l robot..#**auth
-0000e3d0: 6f72 3a20 5065 7465 7220 4d61 6e7a 6c2c  or: Peter Manzl,
-0000e3e0: 204a 6f68 616e 6e65 7320 4765 7273 746d   Johannes Gerstm
-0000e3f0: 6179 720d 0a23 2a2a 6e6f 7465 733a 2073  ayr..#**notes: s
-0000e400: 7469 6c6c 2075 6e64 6572 2064 6576 656c  till under devel
-0000e410: 6f70 6d65 6e74 3b20 6572 726f 7273 2069  opment; errors i
-0000e420: 6e20 6f72 6965 6e74 6174 696f 6e73 206f  n orientations o
-0000e430: 6620 736f 6c75 7469 6f6e 206d 6179 206f  f solution may o
-0000e440: 6363 7572 652e 2070 726f 7669 6564 6573  ccure. proviedes
-0000e450: 206d 7465 686f 6473 2074 6f20 6361 6c63   mtehods to calc
-0000e460: 756c 6174 6520 696e 7665 7273 6520 4b69  ulate inverse Ki
-0000e470: 6e65 6d61 7469 6373 200d 0a63 6c61 7373  nematics ..class
-0000e480: 2049 6e76 6572 7365 4b69 6e65 6d61 7469   InverseKinemati
-0000e490: 6373 4e75 6d65 7269 6361 6c28 293a 200d  csNumerical(): .
-0000e4a0: 0a20 2020 2023 2069 6e69 7469 616c 697a  .    # initializ
-0000e4b0: 6520 7379 7374 656d 0d0a 2020 2020 232a  e system..    #*
-0000e4c0: 2a63 6c61 7373 4675 6e63 7469 6f6e 3a20  *classFunction: 
-0000e4d0: 696e 6974 6961 6c69 7a65 2052 6967 6964  initialize Rigid
-0000e4e0: 426f 6479 496e 6572 7469 6120 7769 7468  BodyInertia with
-0000e4f0: 2073 6361 6c61 7220 6d61 7373 2c20 3378   scalar mass, 3x
-0000e500: 3320 696e 6572 7469 6154 656e 736f 7220  3 inertiaTensor 
-0000e510: 2877 2e72 2e74 2e20 7265 6665 7265 6e63  (w.r.t. referenc
-0000e520: 6520 706f 696e 7421 2121 2920 616e 6420  e point!!!) and 
-0000e530: 6365 6e74 6572 206f 6620 6d61 7373 2063  center of mass c
-0000e540: 6f6d 0d0a 2020 2020 232a 2a69 6e70 7574  om..    #**input
-0000e550: 3a0d 0a20 2020 2023 2020 726f 626f 743a  :..    #  robot:
-0000e560: 2072 6f62 6f74 2063 6c61 7373 0d0a 2020   robot class..  
-0000e570: 2020 2320 206a 6f69 6e74 5374 6966 666e    #  jointStiffn
-0000e580: 6573 733a 2074 6865 2073 7469 6666 6e65  ess: the stiffne
-0000e590: 7373 2075 7365 6420 666f 7220 7468 6520  ss used for the 
-0000e5a0: 726f 626f 7427 7320 6d6f 6465 6c20 6a6f  robot's model jo
-0000e5b0: 696e 7473 0d0a 2020 2020 2320 2075 7365  ints..    #  use
-0000e5c0: 5265 6e64 6572 6572 3a20 7768 656e 2073  Renderer: when s
-0000e5d0: 6f6c 7669 6e67 2074 6865 2069 6e76 6572  olving the inver
-0000e5e0: 7365 206b 696e 656d 6174 6963 7320 7468  se kinematics th
-0000e5f0: 6520 7265 6e64 6572 6572 2069 7320 7573  e renderer is us
-0000e600: 6564 2074 6f20 7368 6f77 2074 6865 2073  ed to show the s
-0000e610: 7461 7274 696e 672f 656e 6420 0d0a 2020  tarting/end ..  
-0000e620: 2020 2320 2020 2020 2020 2020 2020 2020    #             
-0000e630: 2020 636f 6e66 6967 7572 6174 696f 6e20    configuration 
-0000e640: 6f66 2074 6865 2072 6f62 6f74 2075 7369  of the robot usi
-0000e650: 6e67 2074 6865 2067 7261 7068 6963 7320  ng the graphics 
-0000e660: 6f62 6a65 6374 7320 6465 6669 6e64 6564  objects definded
-0000e670: 2069 6e20 7468 6520 726f 626f 7420 6f62   in the robot ob
-0000e680: 6a65 6374 0d0a 2020 2020 232a 2a61 7574  ject..    #**aut
-0000e690: 686f 723a 2050 6574 6572 204d 616e 7a6c  hor: Peter Manzl
-0000e6a0: 0d0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-0000e6b0: 5f5f 2873 656c 662c 2072 6f62 6f74 2c20  __(self, robot, 
-0000e6c0: 6a6f 696e 7453 7469 6666 6e65 7373 203d  jointStiffness =
-0000e6d0: 2031 6530 2c20 7573 6552 656e 6465 7265   1e0, useRendere
-0000e6e0: 723d 4661 6c73 652c 2066 6c61 6744 6562  r=False, flagDeb
-0000e6f0: 7567 3d46 616c 7365 2c20 0d0a 2020 2020  ug=False, ..    
-0000e700: 2020 2020 2020 2020 2020 2020 2075 7365               use
-0000e710: 416c 7465 726e 6174 6976 6543 6f6e 7374  AlternativeConst
-0000e720: 7261 696e 7473 3d46 616c 7365 293a 200d  raints=False): .
-0000e730: 0a20 2020 2020 2020 2073 656c 662e 5343  .        self.SC
-0000e740: 203d 2065 7875 6479 6e2e 5379 7374 656d   = exudyn.System
-0000e750: 436f 6e74 6169 6e65 7228 290d 0a20 2020  Container()..   
-0000e760: 2020 2020 2073 656c 662e 6d62 7349 4b20       self.mbsIK 
-0000e770: 3d20 7365 6c66 2e53 432e 4164 6453 7973  = self.SC.AddSys
-0000e780: 7465 6d28 290d 0a20 2020 2020 2020 2073  tem()..        s
-0000e790: 656c 662e 726f 626f 7420 3d20 726f 626f  elf.robot = robo
-0000e7a0: 740d 0a20 2020 2020 2020 2073 656c 662e  t..        self.
-0000e7b0: 6e4c 696e 6b73 203d 206c 656e 2873 656c  nLinks = len(sel
-0000e7c0: 662e 726f 626f 742e 6c69 6e6b 7329 0d0a  f.robot.links)..
-0000e7d0: 2020 2020 2020 2020 7365 6c66 2e75 7365          self.use
-0000e7e0: 5265 6e64 6572 6572 203d 2075 7365 5265  Renderer = useRe
-0000e7f0: 6e64 6572 6572 0d0a 2020 2020 2020 2020  nderer..        
-0000e800: 7365 6c66 2e66 6c61 6744 6562 7567 203d  self.flagDebug =
-0000e810: 2066 6c61 6744 6562 7567 0d0a 2020 2020   flagDebug..    
-0000e820: 2020 2020 7365 6c66 2e65 7073 526f 7461      self.epsRota
-0000e830: 7469 6f6e 4d61 7472 6978 203d 2031 652d  tionMatrix = 1e-
-0000e840: 3134 0d0a 2020 2020 2020 2020 7365 6c66  14..        self
-0000e850: 2e65 7073 536f 6c75 7469 6f6e 203d 2031  .epsSolution = 1
-0000e860: 652d 3134 0d0a 2020 2020 2020 2020 7365  e-14..        se
-0000e870: 6c66 2e75 7365 416c 7465 726e 6174 6976  lf.useAlternativ
-0000e880: 6543 6f6e 7374 7261 696e 7473 203d 2075  eConstraints = u
-0000e890: 7365 416c 7465 726e 6174 6976 6543 6f6e  seAlternativeCon
-0000e8a0: 7374 7261 696e 7473 0d0a 2020 2020 2020  straints..      
-0000e8b0: 2020 0d0a 2020 2020 2020 2020 7365 6c66    ..        self
-0000e8c0: 2e6f 4772 6f75 6e64 203d 2073 656c 662e  .oGround = self.
-0000e8d0: 6d62 7349 4b2e 4164 644f 626a 6563 7428  mbsIK.AddObject(
-0000e8e0: 6569 692e 4f62 6a65 6374 4772 6f75 6e64  eii.ObjectGround
-0000e8f0: 2872 6566 6572 656e 6365 506f 7369 7469  (referencePositi
-0000e900: 6f6e 3d65 7262 2e48 5432 7472 616e 736c  on=erb.HT2transl
-0000e910: 6174 696f 6e28 726f 626f 742e 4765 7442  ation(robot.GetB
-0000e920: 6173 6548 5428 2929 2c20 0d0a 2020 2020  aseHT()), ..    
-0000e930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e950: 2020 2020 2020 2020 2020 2376 6973 7561            #visua
-0000e960: 6c69 7a61 7469 6f6e 3d56 4f62 6a65 6374  lization=VObject
-0000e970: 4772 6f75 6e64 2867 7261 7068 6963 7344  Ground(graphicsD
-0000e980: 6174 613d 6772 6170 6869 6373 4261 7365  ata=graphicsBase
-0000e990: 4c69 7374 290d 0a20 2020 2020 2020 2020  List)..         
-0000e9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9c0: 2020 2020 2020 2020 2029 290d 0a20 2020           ))..   
-0000e9d0: 2020 2020 200d 0a20 2020 2020 2020 2073       ..        s
-0000e9e0: 656c 662e 6261 7365 4d61 726b 6572 203d  elf.baseMarker =
-0000e9f0: 2073 656c 662e 6d62 7349 4b2e 4164 644d   self.mbsIK.AddM
-0000ea00: 6172 6b65 7228 6569 692e 4d61 726b 6572  arker(eii.Marker
-0000ea10: 426f 6479 5269 6769 6428 626f 6479 4e75  BodyRigid(bodyNu
-0000ea20: 6d62 6572 3d73 656c 662e 6f47 726f 756e  mber=self.oGroun
-0000ea30: 642c 206c 6f63 616c 506f 7369 7469 6f6e  d, localPosition
-0000ea40: 3d5b 302c 302c 305d 2929 0d0a 2020 2020  =[0,0,0]))..    
-0000ea50: 2020 2020 7365 6c66 2e6d 4772 6f75 6e64      self.mGround
-0000ea60: 4545 203d 2073 656c 662e 6d62 7349 4b2e  EE = self.mbsIK.
-0000ea70: 4164 644d 6172 6b65 7228 6569 692e 4d61  AddMarker(eii.Ma
-0000ea80: 726b 6572 426f 6479 5269 6769 6428 626f  rkerBodyRigid(bo
-0000ea90: 6479 4e75 6d62 6572 3d73 656c 662e 6f47  dyNumber=self.oG
-0000eaa0: 726f 756e 642c 206c 6f63 616c 506f 7369  round, localPosi
-0000eab0: 7469 6f6e 3d5b 302c 302c 305d 2929 0d0a  tion=[0,0,0]))..
-0000eac0: 2020 2020 2020 2020 7365 6c66 2e54 6f6f          self.Too
-0000ead0: 6c48 5420 3d20 726f 626f 742e 746f 6f6c  lHT = robot.tool
-0000eae0: 2e48 540d 0a20 2020 2020 2020 200d 0a20  .HT..        .. 
-0000eaf0: 2020 2020 2020 2069 6620 6561 752e 4973         if eau.Is
-0000eb00: 5661 6c69 6452 6561 6c49 6e74 286a 6f69  ValidRealInt(joi
-0000eb10: 6e74 5374 6966 666e 6573 7329 3a20 2320  ntStiffness): # 
-0000eb20: 6275 696c 6420 6c69 7374 2066 726f 6d20  build list from 
-0000eb30: 7265 616c 0d0a 2020 2020 2020 2020 2020  real..          
-0000eb40: 2020 6a6f 696e 7453 7469 6666 6e65 7373    jointStiffness
-0000eb50: 203d 205b 6a6f 696e 7453 7469 6666 6e65   = [jointStiffne
-0000eb60: 7373 5d20 2a20 7365 6c66 2e6e 4c69 6e6b  ss] * self.nLink
-0000eb70: 7320 0d0a 2020 2020 2020 2020 0d0a 2020  s ..        ..  
-0000eb80: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-0000eb90: 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  #+++++++++++++++
-0000eba0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000ebb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000ebc0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000ebd0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-0000ebe0: 2b2b 2b2b 2b0d 0a20 2020 2020 2020 2023  +++++..        #
-0000ebf0: 2062 7569 6c64 206b 696e 656d 7469 6320   build kinemtic 
-0000ec00: 7472 6565 206d 6f64 656c 206f 6620 7468  tree model of th
-0000ec10: 6520 726f 626f 740d 0a20 2020 2020 2020  e robot..       
-0000ec20: 2073 656c 662e 726f 626f 742e 6772 6176   self.robot.grav
-0000ec30: 6974 7920 3d20 5b30 2c30 2c30 5d20 2020  ity = [0,0,0]   
-0000ec40: 2023 206e 6f20 6772 6176 6974 7920 6e65   # no gravity ne
-0000ec50: 6564 6564 0d0a 2020 2020 2020 2020 2320  eded..        # 
-0000ec60: 7365 6c66 2e4b 696e 656d 6174 6963 5472  self.KinematicTr
-0000ec70: 6565 203d 2073 656c 662e 726f 626f 742e  ee = self.robot.
-0000ec80: 4765 744b 696e 656d 6174 6963 5472 6565  GetKinematicTree
-0000ec90: 3636 2829 2023 206e 6f74 2077 6f72 6b69  66() # not worki
-0000eca0: 6e67 2066 6f72 206c 6f63 616c 4854 2028  ng for localHT (
-0000ecb0: 7374 6444 4821 290d 0a20 2020 2020 2020  stdDH!)..       
-0000ecc0: 206c 6973 744f 6c64 436f 6e74 726f 6c20   listOldControl 
-0000ecd0: 3d20 5b4e 6f6e 655d 2a73 656c 662e 6e4c  = [None]*self.nL
-0000ece0: 696e 6b73 2023 7374 6f72 6520 7072 6576  inks #store prev
-0000ecf0: 696f 7573 2050 4463 6f6e 7472 6f6c 0d0a  ious PDcontrol..
-0000ed00: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
-0000ed10: 2072 616e 6765 2873 656c 662e 6e4c 696e   range(self.nLin
-0000ed20: 6b73 293a 2020 2020 200d 0a20 2020 2020  ks):     ..     
-0000ed30: 2020 2020 2020 206c 6973 744f 6c64 436f         listOldCo
-0000ed40: 6e74 726f 6c5b 695d 203d 2073 656c 662e  ntrol[i] = self.
-0000ed50: 726f 626f 742e 6c69 6e6b 735b 695d 2e50  robot.links[i].P
-0000ed60: 4463 6f6e 7472 6f6c 200d 0a20 2020 2020  Dcontrol ..     
-0000ed70: 2020 2020 2020 2073 656c 662e 726f 626f         self.robo
-0000ed80: 742e 6c69 6e6b 735b 695d 2e50 4463 6f6e  t.links[i].PDcon
-0000ed90: 7472 6f6c 203d 2028 6a6f 696e 7453 7469  trol = (jointSti
-0000eda0: 6666 6e65 7373 5b69 5d2c 3029 0d0a 0d0a  ffness[i],0)....
-0000edb0: 2020 2020 2020 2020 7365 6c66 2e72 6f62          self.rob
-0000edc0: 6f74 4469 6374 203d 2073 656c 662e 726f  otDict = self.ro
-0000edd0: 626f 742e 4372 6561 7465 4b69 6e65 6d61  bot.CreateKinema
-0000ede0: 7469 6354 7265 6528 7365 6c66 2e6d 6273  ticTree(self.mbs
-0000edf0: 494b 290d 0a20 2020 2020 2020 200d 0a20  IK)..        .. 
-0000ee00: 2020 2020 2020 2073 656c 662e 6d54 6f6f         self.mToo
-0000ee10: 6c20 3d20 7365 6c66 2e6d 6273 494b 2e41  l = self.mbsIK.A
-0000ee20: 6464 4d61 726b 6572 2865 6969 2e4d 6172  ddMarker(eii.Mar
-0000ee30: 6b65 724b 696e 656d 6174 6963 5472 6565  kerKinematicTree
-0000ee40: 5269 6769 6428 6f62 6a65 6374 4e75 6d62  Rigid(objectNumb
-0000ee50: 6572 3d73 656c 662e 726f 626f 7444 6963  er=self.robotDic
-0000ee60: 745b 276f 626a 6563 744b 696e 656d 6174  t['objectKinemat
-0000ee70: 6963 5472 6565 275d 2c20 6c69 6e6b 4e75  icTree'], linkNu
-0000ee80: 6d62 6572 3d73 656c 662e 6e4c 696e 6b73  mber=self.nLinks
-0000ee90: 2d31 2c20 0d0a 2020 2020 2020 2020 2020  -1, ..          
-0000eea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eeb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eee0: 206c 6f63 616c 506f 7369 7469 6f6e 3d65   localPosition=e
-0000eef0: 7262 2e48 5432 7472 616e 736c 6174 696f  rb.HT2translatio
-0000ef00: 6e28 7365 6c66 2e72 6f62 6f74 2e74 6f6f  n(self.robot.too
-0000ef10: 6c2e 4854 2929 290d 0a20 2020 2020 2020  l.HT)))..       
-0000ef20: 200d 0a20 2020 2020 2020 2073 656c 662e   ..        self.
-0000ef30: 7354 6f6f 6c54 7261 6e73 203d 2073 656c  sToolTrans = sel
-0000ef40: 662e 6d62 7349 4b2e 4164 6453 656e 736f  f.mbsIK.AddSenso
-0000ef50: 7228 6569 692e 5365 6e73 6f72 4d61 726b  r(eii.SensorMark
-0000ef60: 6572 286d 6172 6b65 724e 756d 6265 723d  er(markerNumber=
-0000ef70: 7365 6c66 2e6d 546f 6f6c 2c20 0d0a 2020  self.mTool, ..  
-0000ef80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ef90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000efa0: 2020 2020 2020 2020 2020 2020 6f75 7470              outp
-0000efb0: 7574 5661 7269 6162 6c65 5479 7065 3d65  utVariableType=e
-0000efc0: 7875 6479 6e2e 4f75 7470 7574 5661 7269  xudyn.OutputVari
-0000efd0: 6162 6c65 5479 7065 2e50 6f73 6974 696f  ableType.Positio
-0000efe0: 6e2c 2073 746f 7265 496e 7465 726e 616c  n, storeInternal
-0000eff0: 3d46 616c 7365 2929 0d0a 2020 2020 2020  =False))..      
-0000f000: 2020 0d0a 2020 2020 2020 2020 7365 6c66    ..        self
-0000f010: 2e73 546f 6f6c 526f 7420 3d20 7365 6c66  .sToolRot = self
-0000f020: 2e6d 6273 494b 2e41 6464 5365 6e73 6f72  .mbsIK.AddSensor
-0000f030: 2865 6969 2e53 656e 736f 724d 6172 6b65  (eii.SensorMarke
-0000f040: 7228 6d61 726b 6572 4e75 6d62 6572 3d73  r(markerNumber=s
-0000f050: 656c 662e 6d54 6f6f 6c2c 200d 0a20 2020  elf.mTool, ..   
-0000f060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f080: 2020 2020 2020 2020 206f 7574 7075 7456           outputV
-0000f090: 6172 6961 626c 6554 7970 653d 6578 7564  ariableType=exud
-0000f0a0: 796e 2e4f 7574 7075 7456 6172 6961 626c  yn.OutputVariabl
-0000f0b0: 6554 7970 652e 526f 7461 7469 6f6e 4d61  eType.RotationMa
-0000f0c0: 7472 6978 2c20 7374 6f72 6549 6e74 6572  trix, storeInter
-0000f0d0: 6e61 6c3d 4661 6c73 6529 290d 0a0d 0a20  nal=False)).... 
-0000f0e0: 2020 200d 0a20 2020 2020 2020 2069 6620     ..        if 
-0000f0f0: 313a 2023 200d 0a20 2020 2020 2020 2020  1: # ..         
-0000f100: 2020 2073 656c 662e 636f 6e73 7472 6169     self.constrai
-0000f110: 6e74 546f 6f6c 3d20 7365 6c66 2e6d 6273  ntTool= self.mbs
-0000f120: 494b 2e41 6464 4f62 6a65 6374 2865 6969  IK.AddObject(eii
-0000f130: 2e47 656e 6572 6963 4a6f 696e 7428 6d61  .GenericJoint(ma
-0000f140: 726b 6572 4e75 6d62 6572 733d 5b73 656c  rkerNumbers=[sel
-0000f150: 662e 6d47 726f 756e 6445 4520 2c20 7365  f.mGroundEE , se
-0000f160: 6c66 2e6d 546f 6f6c 5d2c 0d0a 2020 2020  lf.mTool],..    
-0000f170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f190: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000f1a0: 6f74 6174 696f 6e4d 6172 6b65 7231 3d65  otationMarker1=e
-0000f1b0: 7262 2e48 5432 726f 7461 7469 6f6e 4d61  rb.HT2rotationMa
-0000f1c0: 7472 6978 2873 656c 662e 726f 626f 742e  trix(self.robot.
-0000f1d0: 746f 6f6c 2e48 5429 2c20 0d0a 2020 2020  tool.HT), ..    
-0000f1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f200: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000f210: 6c74 6572 6e61 7469 7665 436f 6e73 7472  lternativeConstr
-0000f220: 6169 6e74 7320 3d20 7365 6c66 2e75 7365  aints = self.use
-0000f230: 416c 7465 726e 6174 6976 6543 6f6e 7374  AlternativeConst
-0000f240: 7261 696e 7473 2929 0d0a 0d0a 2020 2020  raints))....    
-0000f250: 2020 2020 656c 7365 3a20 0d0a 2020 2020      else: ..    
-0000f260: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
-0000f270: 7374 7261 696e 7454 6f6f 6c3d 2073 656c  straintTool= sel
-0000f280: 662e 6d62 7349 4b2e 4164 644f 626a 6563  f.mbsIK.AddObjec
-0000f290: 7428 6569 692e 5269 6769 6442 6f64 7953  t(eii.RigidBodyS
-0000f2a0: 7072 696e 6744 616d 7065 7228 6d61 726b  pringDamper(mark
-0000f2b0: 6572 4e75 6d62 6572 733d 5b73 656c 662e  erNumbers=[self.
-0000f2c0: 6d47 726f 756e 6445 4520 2c20 7365 6c66  mGroundEE , self
-0000f2d0: 2e6d 546f 6f6c 5d2c 200d 0a20 2020 2020  .mTool], ..     
-0000f2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f310: 2020 2020 2020 2020 2073 7469 6666 6e65           stiffne
-0000f320: 7373 3d6e 702e 6579 6528 3629 2a31 6538  ss=np.eye(6)*1e8
-0000f330: 202c 2064 616d 7069 6e67 203d 206e 702e   , damping = np.
-0000f340: 6579 6528 3629 2a31 6533 2c20 0d0a 2020  eye(6)*1e3, ..  
-0000f350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f380: 2020 2020 2020 2020 2020 2020 726f 7461              rota
-0000f390: 7469 6f6e 4d61 726b 6572 313d 6572 622e  tionMarker1=erb.
-0000f3a0: 4854 3272 6f74 6174 696f 6e4d 6174 7269  HT2rotationMatri
-0000f3b0: 7828 7365 6c66 2e72 6f62 6f74 2e74 6f6f  x(self.robot.too
-0000f3c0: 6c2e 4854 2929 2920 0d0a 0d0a 2020 2020  l.HT))) ....    
-0000f3d0: 2020 2020 2372 6573 746f 7265 2050 4463      #restore PDc
-0000f3e0: 6f6e 7472 6f6c 2066 6f72 2072 6f62 6f74  ontrol for robot
-0000f3f0: 2120 2020 2020 2020 200d 0a20 2020 2020  !        ..     
-0000f400: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
-0000f410: 6528 7365 6c66 2e6e 4c69 6e6b 7329 3a20  e(self.nLinks): 
-0000f420: 2020 2020 0d0a 2020 2020 2020 2020 2020      ..          
-0000f430: 2020 7365 6c66 2e72 6f62 6f74 2e6c 696e    self.robot.lin
-0000f440: 6b73 5b69 5d2e 5044 636f 6e74 726f 6c20  ks[i].PDcontrol 
-0000f450: 3d20 6c69 7374 4f6c 6443 6f6e 7472 6f6c  = listOldControl
-0000f460: 5b69 5d0d 0a20 2020 2020 2020 200d 0a20  [i]..        .. 
-0000f470: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-0000f480: 2023 2073 6574 2073 696d 756c 6174 696f   # set simulatio
-0000f490: 6e20 7365 7474 696e 6773 2066 6f72 2073  n settings for s
-0000f4a0: 7461 7469 6320 736f 6c76 6572 200d 0a20  tatic solver .. 
-0000f4b0: 2020 2020 2020 2073 656c 662e 7369 6d75         self.simu
-0000f4c0: 6c61 7469 6f6e 5365 7474 696e 6773 203d  lationSettings =
-0000f4d0: 2065 7875 6479 6e2e 5369 6d75 6c61 7469   exudyn.Simulati
-0000f4e0: 6f6e 5365 7474 696e 6773 2829 0d0a 2020  onSettings()..  
-0000f4f0: 2020 2020 2020 7365 6c66 2e73 696d 756c        self.simul
-0000f500: 6174 696f 6e53 6574 7469 6e67 732e 736f  ationSettings.so
-0000f510: 6c75 7469 6f6e 5365 7474 696e 6773 2e77  lutionSettings.w
-0000f520: 7269 7465 536f 6c75 7469 6f6e 546f 4669  riteSolutionToFi
-0000f530: 6c65 203d 2046 616c 7365 0d0a 2020 2020  le = False..    
-0000f540: 2020 2020 7365 6c66 2e73 696d 756c 6174      self.simulat
-0000f550: 696f 6e53 6574 7469 6e67 732e 736f 6c75  ionSettings.solu
-0000f560: 7469 6f6e 5365 7474 696e 6773 2e62 696e  tionSettings.bin
-0000f570: 6172 7953 6f6c 7574 696f 6e46 696c 6520  arySolutionFile 
-0000f580: 3d20 4661 6c73 650d 0a20 2020 2020 2020  = False..       
-0000f590: 2073 656c 662e 7369 6d75 6c61 7469 6f6e   self.simulation
-0000f5a0: 5365 7474 696e 6773 2e6c 696e 6561 7253  Settings.linearS
-0000f5b0: 6f6c 7665 7253 6574 7469 6e67 732e 6967  olverSettings.ig
-0000f5c0: 6e6f 7265 5369 6e67 756c 6172 4a61 636f  noreSingularJaco
-0000f5d0: 6269 616e 203d 2054 7275 650d 0a20 2020  bian = True..   
-0000f5e0: 2020 2020 2073 656c 662e 7369 6d75 6c61       self.simula
-0000f5f0: 7469 6f6e 5365 7474 696e 6773 2e64 6973  tionSettings.dis
-0000f600: 706c 6179 436f 6d70 7574 6174 696f 6e54  playComputationT
-0000f610: 696d 6520 3d20 4661 6c73 650d 0a20 2020  ime = False..   
-0000f620: 2020 2020 2073 656c 662e 7369 6d75 6c61       self.simula
-0000f630: 7469 6f6e 5365 7474 696e 6773 2e64 6973  tionSettings.dis
-0000f640: 706c 6179 5374 6174 6973 7469 6373 203d  playStatistics =
-0000f650: 2046 616c 7365 0d0a 2020 2020 2020 2020   False..        
-0000f660: 0d0a 2020 2020 2020 2020 7365 6c66 2e73  ..        self.s
-0000f670: 696d 756c 6174 696f 6e53 6574 7469 6e67  imulationSetting
-0000f680: 732e 7374 6174 6963 536f 6c76 6572 2e6e  s.staticSolver.n
-0000f690: 6577 746f 6e2e 6d61 7849 7465 7261 7469  ewton.maxIterati
-0000f6a0: 6f6e 7320 3d20 3530 2023 6f72 6967 696e  ons = 50 #origin
-0000f6b0: 616c 3a20 3530 300d 0a20 2020 2020 2020  al: 500..       
-0000f6c0: 2073 656c 662e 7369 6d75 6c61 7469 6f6e   self.simulation
-0000f6d0: 5365 7474 696e 6773 2e73 7461 7469 6353  Settings.staticS
-0000f6e0: 6f6c 7665 722e 6164 6170 7469 7665 5374  olver.adaptiveSt
-0000f6f0: 6570 203d 2054 7275 650d 0a20 2020 2020  ep = True..     
-0000f700: 2020 2073 656c 662e 7369 6d75 6c61 7469     self.simulati
-0000f710: 6f6e 5365 7474 696e 6773 2e73 7461 7469  onSettings.stati
-0000f720: 6353 6f6c 7665 722e 7665 7262 6f73 654d  cSolver.verboseM
-0000f730: 6f64 6520 3d20 300d 0a20 2020 2020 2020  ode = 0..       
-0000f740: 2073 656c 662e 7369 6d75 6c61 7469 6f6e   self.simulation
-0000f750: 5365 7474 696e 6773 2e64 6973 706c 6179  Settings.display
-0000f760: 476c 6f62 616c 5469 6d65 7273 203d 2030  GlobalTimers = 0
-0000f770: 0d0a 2020 2020 2020 2020 2373 656c 662e  ..        #self.
-0000f780: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-0000f790: 6773 2e73 7461 7469 6353 6f6c 7665 722e  gs.staticSolver.
-0000f7a0: 7374 6162 696c 697a 6572 4f44 4532 7465  stabilizerODE2te
-0000f7b0: 726d 203d 2031 652d 310d 0a20 2020 2020  rm = 1e-1..     
-0000f7c0: 2020 2073 656c 662e 7374 6174 6963 536f     self.staticSo
-0000f7d0: 6c76 6572 203d 2065 7875 6479 6e2e 4d61  lver = exudyn.Ma
-0000f7e0: 696e 536f 6c76 6572 5374 6174 6963 2829  inSolverStatic()
-0000f7f0: 0d0a 2020 2020 2020 2020 2320 7370 6172  ..        # spar
-0000f800: 7365 2073 6f6c 7665 7220 7365 7474 696e  se solver settin
-0000f810: 6773 2061 7265 2066 6173 7465 7220 666f  gs are faster fo
-0000f820: 7220 7265 6475 6e64 616e 7420 6d62 730d  r redundant mbs.
-0000f830: 0a20 2020 2020 2020 2073 656c 662e 6d62  .        self.mb
-0000f840: 7349 4b2e 4173 7365 6d62 6c65 2829 2020  sIK.Assemble()  
-0000f850: 200d 0a20 2020 2020 2020 2073 656c 662e   ..        self.
-0000f860: 7379 7353 7461 7465 4c69 7374 203d 2073  sysStateList = s
-0000f870: 656c 662e 6d62 7349 4b2e 7379 7374 656d  elf.mbsIK.system
-0000f880: 4461 7461 2e47 6574 5379 7374 656d 5374  Data.GetSystemSt
-0000f890: 6174 6528 290d 0a0d 0a20 2020 2064 6566  ate()....    def
-0000f8a0: 205f 5f64 6566 5f5f 2873 656c 6629 3a0d   __def__(self):.
-0000f8b0: 0a20 2020 2020 2020 2073 656c 662e 7374  .        self.st
-0000f8c0: 6174 6963 536f 6c76 6572 2e46 696e 616c  aticSolver.Final
-0000f8d0: 697a 6553 6f6c 7665 7228 7365 6c66 2e6d  izeSolver(self.m
-0000f8e0: 6273 494b 2c20 7365 6c66 2e73 696d 756c  bsIK, self.simul
-0000f8f0: 6174 696f 6e53 6574 7469 6e67 7329 0d0a  ationSettings)..
-0000f900: 2020 2020 2020 2020 0d0a 2020 2020 2320          ..    # 
-0000f910: 6465 6275 6767 696e 6720 6865 6c70 6572  debugging helper
-0000f920: 2066 756e 6374 696f 6e20 0d0a 2020 2020   function ..    
-0000f930: 6465 6620 6372 6561 7465 5665 6374 6f72  def createVector
-0000f940: 2870 302c 2070 3031 293a 200d 0a20 2020  (p0, p01): ..   
-0000f950: 2020 2020 2078 203d 205b 7030 5b30 5d2c       x = [p0[0],
-0000f960: 2070 305b 305d 202b 2070 3031 5b30 5d5d   p0[0] + p01[0]]
-0000f970: 0d0a 2020 2020 2020 2020 7920 3d20 5b70  ..        y = [p
-0000f980: 305b 315d 2c20 7030 5b31 5d20 2b20 7030  0[1], p0[1] + p0
-0000f990: 315b 315d 5d0d 0a20 2020 2020 2020 207a  1[1]]..        z
-0000f9a0: 203d 205b 7030 5b32 5d2c 2070 305b 325d   = [p0[2], p0[2]
-0000f9b0: 202b 2070 3031 5b32 5d5d 0d0a 2020 2020   + p01[2]]..    
-0000f9c0: 2020 2020 7265 7475 726e 2078 2c20 792c      return x, y,
-0000f9d0: 207a 0d0a 0d0a 0d0a 2020 2020 232a 2a63   z......    #**c
-0000f9e0: 6c61 7373 4675 6e63 7469 6f6e 3a20 5574  lassFunction: Ut
-0000f9f0: 696c 6974 7920 6675 6e63 7469 6f6e 2074  ility function t
-0000fa00: 6f20 6765 7420 6375 7272 656e 7420 486f  o get current Ho
-0000fa10: 6d6f 6765 6e65 6f75 7320 7472 616e 7366  mogeneous transf
-0000fa20: 6f72 6d61 7469 6f6e 206f 6620 7468 6520  ormation of the 
-0000fa30: 726f 626f 7420 746f 2063 6865 636b 2069  robot to check i
-0000fa40: 6e76 6572 7365 204b 696e 656d 6174 6963  nverse Kinematic
-0000fa50: 7320 736f 6c75 7469 6f6e 0d0a 2020 2020  s solution..    
-0000fa60: 2320 2a2a 206f 7574 7075 743a 200d 0a20  # ** output: .. 
-0000fa70: 2020 2023 2020 2054 3a20 3478 3420 686f     #   T: 4x4 ho
-0000fa80: 6d6f 6765 6e65 6f75 7320 5472 616e 7366  mogeneous Transf
-0000fa90: 6f72 6d61 7469 6f6e 206d 6174 7269 7820  ormation matrix 
-0000faa0: 6f66 2074 6865 2063 7572 7265 6e74 2054  of the current T
-0000fab0: 4350 2070 6f73 650d 0a20 2020 2064 6566  CP pose..    def
-0000fac0: 2047 6574 4375 7272 656e 7452 6f62 6f74   GetCurrentRobot
-0000fad0: 4854 2873 656c 6629 3a20 0d0a 2020 2020  HT(self): ..    
-0000fae0: 2020 2020 2320 7365 6c66 2e72 6f62 6f74      # self.robot
-0000faf0: 2e4a 6f69 6e74 4854 2871 295b 2d31 5d20  .JointHT(q)[-1] 
-0000fb00: 2040 2073 656c 662e 726f 626f 742e 746f   @ self.robot.to
-0000fb10: 6f6c 2e48 5420 2320 7072 6f76 6965 6465  ol.HT # proviede
-0000fb20: 7320 7361 6d65 2066 756e 6374 696f 6e61  s same functiona
-0000fb30: 6c69 7479 2061 7320 7265 6164 696e 6720  lity as reading 
-0000fb40: 7365 6e73 6f72 732e 2e2e 0d0a 2020 2020  sensors.....    
-0000fb50: 2020 2020 706f 7346 4b69 6e65 203d 2073      posFKine = s
-0000fb60: 656c 662e 6d62 7349 4b2e 4765 7453 656e  elf.mbsIK.GetSen
-0000fb70: 736f 7256 616c 7565 7328 7365 6c66 2e73  sorValues(self.s
-0000fb80: 546f 6f6c 5472 616e 7329 200d 0a20 2020  ToolTrans) ..   
-0000fb90: 2020 2020 2052 6f74 466b 696e 6520 3d20       RotFkine = 
-0000fba0: 7365 6c66 2e6d 6273 494b 2e47 6574 5365  self.mbsIK.GetSe
-0000fbb0: 6e73 6f72 5661 6c75 6573 2873 656c 662e  nsorValues(self.
-0000fbc0: 7354 6f6f 6c52 6f74 292e 7265 7368 6170  sToolRot).reshap
-0000fbd0: 6528 2833 2c33 2929 0d0a 2020 2020 2020  e((3,3))..      
-0000fbe0: 2020 5420 3d20 6572 622e 486f 6d6f 6765    T = erb.Homoge
-0000fbf0: 6e65 6f75 7354 7261 6e73 666f 726d 6174  neousTransformat
-0000fc00: 696f 6e28 526f 7446 6b69 6e65 2c20 706f  ion(RotFkine, po
-0000fc10: 7346 4b69 6e65 2920 2320 676c 6f62 616c  sFKine) # global
-0000fc20: 2048 540d 0a20 2020 2020 2020 2072 6574   HT..        ret
-0000fc30: 7572 6e20 540d 0a0d 0a20 2020 2023 2a2a  urn T....    #**
-0000fc40: 636c 6173 7346 756e 6374 696f 6e3a 200d  classFunction: .
-0000fc50: 0a20 2020 2023 2a2a 696e 7075 743a 0d0a  .    #**input:..
-0000fc60: 2020 2020 2320 2054 313a 2034 7834 2068      #  T1: 4x4 h
-0000fc70: 6f6d 6f67 656e 656f 7573 2074 7261 6e73  omogeneous trans
-0000fc80: 666f 726d 6174 696f 6e20 6d61 7472 6978  formation matrix
-0000fc90: 2072 6570 7265 7365 6e74 696e 6720 7468   representing th
-0000fca0: 6520 6669 7273 7420 506f 7365 0d0a 2020  e first Pose..  
-0000fcb0: 2020 2320 2054 323a 2034 7834 2068 6f6d    #  T2: 4x4 hom
-0000fcc0: 6f67 656e 656f 7573 2074 7261 6e73 666f  ogeneous transfo
-0000fcd0: 726d 6174 696f 6e20 6d61 7472 6978 2072  rmation matrix r
-0000fce0: 6570 7265 7365 6e74 696e 6720 7468 6520  epresenting the 
-0000fcf0: 7365 636f 6e64 2050 6f73 650d 0a20 2020  second Pose..   
-0000fd00: 2023 2020 726f 7453 7465 703a 2074 6865   #  rotStep: the
-0000fd10: 206d 6178 2e20 7369 7a65 206f 6620 7374   max. size of st
-0000fd20: 6570 7320 746f 2074 616b 6520 666f 7220  eps to take for 
-0000fd30: 7468 6520 6f72 6965 6e74 6174 696f 6e0d  the orientation.
-0000fd40: 0a20 2020 2023 2020 6d69 6e53 7465 7073  .    #  minSteps
-0000fd50: 3a20 6d69 6e69 6d75 6d20 6e75 6d62 6572  : minimum number
-0000fd60: 206f 6620 7375 6273 7465 7073 2074 6f20   of substeps to 
-0000fd70: 696e 7465 7270 6f6c 6174 650d 0a20 2020  interpolate..   
-0000fd80: 2023 2a2a 6f75 7470 7574 3a20 0d0a 2020   #**output: ..  
-0000fd90: 2020 2320 543a 2061 204c 6973 7420 6f66    # T: a List of
-0000fda0: 2068 6f6d 6f67 656e 656f 7573 2054 7261   homogeneous Tra
-0000fdb0: 6e73 666f 726d 6174 696f 6e73 2066 6f72  nsformations for
-0000fdc0: 2065 6163 6820 7374 6570 2062 6574 7765   each step betwe
-0000fdd0: 656e 0d0a 2020 2020 232a 2a61 7574 686f  en..    #**autho
-0000fde0: 723a 2050 6574 6572 204d 616e 7a6c 0d0a  r: Peter Manzl..
-0000fdf0: 2020 2020 232a 2a6e 6f74 6573 3a20 7374      #**notes: st
-0000fe00: 696c 6c20 756e 6465 7220 6465 7665 6c6f  ill under develo
-0000fe10: 706d 656e 743b 2069 6e74 6572 706f 6c61  pment; interpola
-0000fe20: 7469 6f6e 206d 6179 2062 6520 6368 616e  tion may be chan
-0000fe30: 6765 6420 746f 2075 7369 6e67 206c 6f67  ged to using log
-0000fe40: 5345 330d 0a20 2020 2064 6566 2049 6e74  SE3..    def Int
-0000fe50: 6572 706f 6c61 7465 4854 7328 7365 6c66  erpolateHTs(self
-0000fe60: 2c20 5431 2c20 5432 2c20 726f 7453 7465  , T1, T2, rotSte
-0000fe70: 703d 6e70 2e70 692f 3136 2c20 6d69 6e53  p=np.pi/16, minS
-0000fe80: 7465 7073 203d 2031 293a 200d 0a20 2020  teps = 1): ..   
-0000fe90: 2020 2020 2052 312c 2074 3120 3d20 5431       R1, t1 = T1
-0000fea0: 5b3a 332c 3a33 5d2c 2065 7262 2e48 5432  [:3,:3], erb.HT2
-0000feb0: 7472 616e 736c 6174 696f 6e28 5431 290d  translation(T1).
-0000fec0: 0a20 2020 2020 2020 2052 322c 2074 3220  .        R2, t2 
-0000fed0: 3d20 5432 5b3a 332c 3a33 5d2c 2065 7262  = T2[:3,:3], erb
-0000fee0: 2e48 5432 7472 616e 736c 6174 696f 6e28  .HT2translation(
-0000fef0: 5432 290d 0a20 2020 2020 2020 2074 3132  T2)..        t12
-0000ff00: 203d 2074 3220 2d20 7431 0d0a 2020 2020   = t2 - t1..    
-0000ff10: 2020 2020 5231 3220 3d20 6e70 2e74 7261      R12 = np.tra
-0000ff20: 6e73 706f 7365 2852 3129 2040 2052 320d  nspose(R1) @ R2.
-0000ff30: 0a20 2020 2020 2020 2072 6f74 3132 203d  .        rot12 =
-0000ff40: 2065 7262 2e52 6f74 6174 696f 6e4d 6174   erb.RotationMat
-0000ff50: 7269 7832 526f 7461 7469 6f6e 5665 6374  rix2RotationVect
-0000ff60: 6f72 2852 3132 290d 0a20 2020 2020 2020  or(R12)..       
-0000ff70: 2072 6f74 416e 6720 3d20 6e70 2e6c 696e   rotAng = np.lin
-0000ff80: 616c 672e 6e6f 726d 2872 6f74 3132 2c20  alg.norm(rot12, 
-0000ff90: 3229 2023 2072 6f74 6174 696f 6e20 7665  2) # rotation ve
-0000ffa0: 6374 6f72 2069 7320 616e 676c 6520 2a20  ctor is angle * 
-0000ffb0: 6e6f 726d 616c 697a 6564 2072 6f74 6174  normalized rotat
-0000ffc0: 696f 6e20 6178 6973 200d 0a0d 0a20 2020  ion axis ....   
-0000ffd0: 2020 2020 2023 4445 4c45 5445 2c20 6e6f       #DELETE, no
-0000ffe0: 7420 6e65 6564 6564 2061 6e79 206d 6f72  t needed any mor
-0000fff0: 6520 6475 6520 746f 2069 6d70 726f 7665  e due to improve
-00010000: 6420 526f 7461 7469 6f6e 4d61 7472 6978  d RotationMatrix
-00010010: 3252 6f74 6174 696f 6e56 6563 746f 7220  2RotationVector 
-00010020: 200d 0a20 2020 2020 2020 2023 2069 6620   ..        # if 
-00010030: 7468 6973 2069 7320 7468 6520 6361 7365  this is the case
-00010040: 2c20 7468 656e 2074 776f 2061 7865 7320  , then two axes 
-00010050: 6172 6520 666c 6970 7065 643b 200d 0a20  are flipped; .. 
-00010060: 2020 2020 2020 2023 2074 6869 7320 6361         # this ca
-00010070: 6e20 6861 7070 656e 2069 6e20 7468 6520  n happen in the 
-00010080: 6765 6e65 7269 6320 6a6f 696e 7420 7769  generic joint wi
-00010090: 7468 2074 6865 2073 7461 7469 6320 736f  th the static so
-000100a0: 6c76 6572 2061 6e64 2063 6f72 7265 7370  lver and corresp
-000100b0: 6f6e 6420 0d0a 2020 2020 2020 2020 2320  ond ..        # 
-000100c0: 746f 2061 2031 3830 c2b0 2072 6f74 6174  to a 180.. rotat
-000100d0: 696f 6e20 6172 6f75 6e64 2074 6865 2061  ion around the a
-000100e0: 7869 7320 7769 7468 2065 6e74 7279 2031  xis with entry 1
-000100f0: 2069 6e20 7468 6520 726f 7461 7469 6f6e   in the rotation
-00010100: 206d 6174 7269 780d 0a20 2020 2020 2020   matrix..       
-00010110: 2023 2069 6620 6162 7328 6e70 2e74 7261   # if abs(np.tra
-00010120: 6365 2852 3132 2920 2b20 3129 203c 3d20  ce(R12) + 1) <= 
-00010130: 7365 6c66 2e65 7073 526f 7461 7469 6f6e  self.epsRotation
-00010140: 4d61 7472 6978 3a20 0d0a 2020 2020 2020  Matrix: ..      
-00010150: 2020 2320 2020 2020 5231 3220 3d20 6e70    #     R12 = np
-00010160: 2e72 6f75 6e64 2852 3132 2c20 3132 290d  .round(R12, 12).
-00010170: 0a20 2020 2020 2020 2023 2020 2020 2066  .        #     f
-00010180: 6f72 2069 2069 6e20 7261 6e67 6528 3329  or i in range(3)
-00010190: 3a20 0d0a 2020 2020 2020 2020 2320 2020  : ..        #   
-000101a0: 2020 2020 2020 6966 2061 6273 2852 3132        if abs(R12
-000101b0: 5b69 2c69 5d2d 3129 203c 3d20 7365 6c66  [i,i]-1) <= self
-000101c0: 2e65 7073 526f 7461 7469 6f6e 4d61 7472  .epsRotationMatr
-000101d0: 6978 3a20 726f 7431 325b 695d 203d 2031  ix: rot12[i] = 1
-000101e0: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
-000101f0: 726f 7431 3220 2a3d 206e 702e 7069 0d0a  rot12 *= np.pi..
-00010200: 2020 2020 2020 2020 2320 2020 2020 726f          #     ro
-00010210: 7441 6e67 203d 206e 702e 7069 0d0a 0d0a  tAng = np.pi....
-00010220: 2020 2020 2020 2020 6e20 3d20 6d69 6e28          n = min(
-00010230: 6d69 6e53 7465 7073 2c20 312b 696e 7428  minSteps, 1+int(
-00010240: 726f 7441 6e67 2f72 6f74 5374 6570 2929  rotAng/rotStep))
-00010250: 2023 206e 756d 6265 7220 6f66 2073 7465   # number of ste
-00010260: 7073 0d0a 2020 2020 2020 2020 5420 3d20  ps..        T = 
-00010270: 5b5d 0d0a 2020 2020 2020 2020 666f 7220  []..        for 
-00010280: 6920 696e 2072 616e 6765 286e 293a 200d  i in range(n): .
-00010290: 0a20 2020 2020 2020 2020 2020 2072 6f74  .            rot
-000102a0: 6920 3d20 726f 7431 322a 2869 2b31 292f  i = rot12*(i+1)/
-000102b0: 6e0d 0a20 2020 2020 2020 2020 2020 2052  n..            R
-000102c0: 6920 3d20 5231 2040 2065 7262 2e52 6f74  i = R1 @ erb.Rot
-000102d0: 6174 696f 6e56 6563 746f 7232 526f 7461  ationVector2Rota
-000102e0: 7469 6f6e 4d61 7472 6978 2872 6f74 6929  tionMatrix(roti)
-000102f0: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00010300: 5269 203d 2052 6920 2f6e 702e 6c69 6e61  Ri = Ri /np.lina
-00010310: 6c67 2e64 6574 2852 6929 2023 2061 766f  lg.det(Ri) # avo
-00010320: 6964 0d0a 2020 2020 2020 2020 2020 2020  id..            
-00010330: 7469 203d 2074 3120 2b20 2874 322d 7431  ti = t1 + (t2-t1
-00010340: 292a 2869 2b31 292f 6e20 0d0a 2020 2020  )*(i+1)/n ..    
-00010350: 2020 2020 2020 2020 5469 203d 2065 7262          Ti = erb
-00010360: 2e48 6f6d 6f67 656e 656f 7573 5472 616e  .HomogeneousTran
-00010370: 7366 6f72 6d61 7469 6f6e 2852 692c 2074  sformation(Ri, t
-00010380: 6929 2020 2020 0d0a 2020 2020 2020 2020  i)    ..        
-00010390: 2020 2020 5420 2b3d 205b 5469 5d0d 0a20      T += [Ti].. 
-000103a0: 2020 2020 2020 2054 202b 3d20 5b54 325d         T += [T2]
-000103b0: 2023 2074 6f20 7361 7469 7366 7920 7468   # to satisfy th
-000103c0: 6520 626f 756e 6472 7920 636f 6e64 6974  e boundry condit
-000103d0: 696f 6e0d 0a20 2020 2020 2020 2072 6574  ion..        ret
-000103e0: 7572 6e20 540d 0a20 2020 200d 0a20 2020  urn T..    ..   
-000103f0: 2023 2a2a 636c 6173 7346 756e 6374 696f   #**classFunctio
-00010400: 6e3a 2054 6869 7320 4d65 7468 6f64 2063  n: This Method c
-00010410: 616e 2062 6520 7573 6564 2074 6f20 736f  an be used to so
-00010420: 6c76 6520 7468 6520 696e 7665 7273 6520  lve the inverse 
-00010430: 6b69 6e65 6d61 7469 6373 2070 726f 626c  kinematics probl
-00010440: 656d 2062 7920 736f 6c76 696e 6720 0d0a  em by solving ..
-00010450: 2020 2020 2320 2020 2020 2020 2020 2020      #           
-00010460: 2074 6865 2073 7461 7469 6320 7072 6f62   the static prob
-00010470: 6c65 6d20 6f66 2061 2073 6572 6961 6c20  lem of a serial 
-00010480: 726f 626f 7420 7573 696e 6720 7374 6570  robot using step
-00010490: 7320 746f 2069 6e74 6572 706f 6c61 7465  s to interpolate
-000104a0: 2062 6574 7765 656e 2073 7461 7274 2061   between start a
-000104b0: 6e64 2065 6e64 2070 6f73 6974 696f 6e20  nd end position 
-000104c0: 636c 6f73 6520 746f 2074 6865 2066 756e  close to the fun
-000104d0: 6374 696f 6e20 536f 6c76 652e 200d 0a20  ction Solve. .. 
-000104e0: 2020 2023 2020 2020 2020 2020 2020 2020     #            
-000104f0: 5468 6973 2068 656c 7073 2074 6865 2066  This helps the f
-00010500: 756e 6374 696f 6e20 536f 6c76 6528 2920  unction Solve() 
-00010510: 746f 2066 696e 6420 7468 6520 636f 7272  to find the corr
-00010520: 6563 7420 736f 6c75 7469 6f6e 732e 200d  ect solutions. .
-00010530: 0a20 2020 2023 2a2a 696e 7075 743a 0d0a  .    #**input:..
-00010540: 2020 2020 2320 2054 3a20 7468 6520 3478      #  T: the 4x
-00010550: 3420 686f 6d6f 6765 6e65 6f75 7320 7472  4 homogeneous tr
-00010560: 616e 7366 6f72 6d61 7469 6f6e 206d 6174  ansformation mat
-00010570: 7269 7820 7265 7072 6573 656e 7469 6e67  rix representing
-00010580: 2074 6865 2064 6573 6972 6564 2070 6f73   the desired pos
-00010590: 6974 696f 6e20 616e 6420 6f72 6965 6e74  ition and orient
-000105a0: 6174 696f 6e20 6f66 2074 6865 2045 6e64  ation of the End
-000105b0: 6566 6665 6374 6f72 0d0a 2020 2020 2320  effector..    # 
-000105c0: 2071 303a 2054 6865 2063 6f6e 6669 6775   q0: The configu
-000105d0: 7261 7469 6f6e 2028 6a6f 696e 7420 616e  ration (joint an
-000105e0: 676c 6573 2f70 6f73 6974 696f 6e73 2920  gles/positions) 
-000105f0: 6f66 2074 6865 2072 6f62 6f74 2066 726f  of the robot fro
-00010600: 6d20 7768 6963 6820 7468 6520 6e75 6d65  m which the nume
-00010610: 7269 6361 6c20 6d65 7468 6f64 7320 7374  rical methods st
-00010620: 6172 7420 736f 2063 616c 6375 6c61 7465  art so calculate
-00010630: 2074 6865 2073 6f6c 7574 696f 6e3b 2071   the solution; q
-00010640: 303d 4e6f 6e65 2069 6e64 6963 6174 6573  0=None indicates
-00010650: 2074 6861 7420 7468 6520 7374 6f72 6564   that the stored
-00010660: 2073 6f6c 7574 696f 6e20 2866 726f 6d20   solution (from 
-00010670: 6d6f 6465 6c20 6f72 2070 7265 7669 6f75  model or previou
-00010680: 7320 736f 6c75 7469 6f6e 2920 7368 616c  s solution) shal
-00010690: 6c20 6265 2075 7365 6420 666f 7220 696e  l be used for in
-000106a0: 6974 6961 6c69 7a61 7469 6f6e 0d0a 2020  itialization..  
-000106b0: 2020 232a 2a6f 7574 7075 743a 205b 712c    #**output: [q,
-000106c0: 2073 7563 6365 7373 5d3b 2071 3a20 5468   success]; q: Th
-000106d0: 6520 736f 6c75 7469 6f6e 2066 6f72 2074  e solution for t
-000106e0: 6865 206a 6f69 6e74 2061 6e67 6c65 7320  he joint angles 
-000106f0: 696e 2077 6869 6368 2074 6865 2072 6f62  in which the rob
-00010700: 6f74 2773 2074 6f6f 6c20 6365 6e74 6572  ot's tool center
-00010710: 2070 6f69 6e74 2028 5443 5029 2072 6561   point (TCP) rea
-00010720: 6368 6573 2074 6865 2064 6573 6972 6564  ches the desired
-00010730: 2068 6f6d 6f67 656e 656f 7573 2074 7261   homogeneous tra
-00010740: 6e73 666f 726d 6174 696f 6e20 6d61 7472  nsformation matr
-00010750: 6978 2054 3b20 7375 6363 6573 733d 4661  ix T; success=Fa
-00010760: 6c73 6520 696e 6469 6361 7465 7320 7468  lse indicates th
-00010770: 6174 2061 6c6c 2074 7269 616c 7320 666f  at all trials fo
-00010780: 7220 696e 7665 7273 6520 6b69 6e65 6d61  r inverse kinema
-00010790: 7469 6373 2066 6169 6c65 642c 206c 6561  tics failed, lea
-000107a0: 6469 6e67 2074 6f20 713d 4e6f 6e65 0d0a  ding to q=None..
-000107b0: 2020 2020 2320 7375 6363 6573 733a 2066      # success: f
-000107c0: 6c61 6720 746f 2069 6e64 6963 6174 6520  lag to indicate 
-000107d0: 6966 206d 6574 686f 6420 7761 7320 7375  if method was su
-000107e0: 6363 6573 7366 756c 0d0a 2020 2020 232a  ccessful..    #*
-000107f0: 2a61 7574 686f 723a 2050 6574 6572 204d  *author: Peter M
-00010800: 616e 7a6c 2c20 4a6f 6861 6e6e 6573 2047  anzl, Johannes G
-00010810: 6572 7374 6d61 7972 0d0a 2020 2020 232a  erstmayr..    #*
-00010820: 2a6e 6f74 6573 3a20 7374 696c 6c20 756e  *notes: still un
-00010830: 6465 7220 6465 7665 6c6f 706d 656e 743b  der development;
-00010840: 2065 7272 6f72 7320 696e 206f 7269 656e   errors in orien
-00010850: 7461 7469 6f6e 7320 6f66 2073 6f6c 7574  tations of solut
-00010860: 696f 6e20 6d61 7920 6f63 6375 7265 2e20  ion may occure. 
-00010870: 776f 726b 7320 7369 6d69 6c61 7220 746f  works similar to
-00010880: 2069 6b69 6e65 5c5f 4c4d 2066 756e 6374   ikine\_LM funct
-00010890: 696f 6e20 6f66 2074 6865 2072 6f62 6f74  ion of the robot
-000108a0: 6963 7320 746f 6f6c 626f 7820 6672 6f6d  ics toolbox from
-000108b0: 2070 6574 6572 2063 6f72 6b65 0d0a 2020   peter corke..  
-000108c0: 2020 6465 6620 536f 6c76 6553 6166 6528    def SolveSafe(
-000108d0: 7365 6c66 2c20 542c 2071 3020 3d20 4e6f  self, T, q0 = No
-000108e0: 6e65 293a 0d0a 2020 2020 2020 2020 5430  ne):..        T0
-000108f0: 203d 2073 656c 662e 4765 7443 7572 7265   = self.GetCurre
-00010900: 6e74 526f 626f 7448 5428 290d 0a20 2020  ntRobotHT()..   
-00010910: 2020 2020 2054 496e 7465 7270 203d 2073       TInterp = s
-00010920: 656c 662e 496e 7465 7270 6f6c 6174 6548  elf.InterpolateH
-00010930: 5473 2854 302c 2054 2c20 726f 7453 7465  Ts(T0, T, rotSte
-00010940: 703d 6e70 2e70 692f 3329 2023 206e 6f20  p=np.pi/3) # no 
-00010950: 7374 6570 7320 696e 2062 6574 7765 656e  steps in between
-00010960: 206e 6565 6465 6421 0d0a 2020 2020 2020   needed!..      
-00010970: 2020 7120 3d20 7130 0d0a 2020 2020 2020    q = q0..      
-00010980: 2020 666f 7220 5469 2069 6e20 5449 6e74    for Ti in TInt
-00010990: 6572 703a 0d0a 2020 2020 2020 2020 2020  erp:..          
-000109a0: 2020 5b71 2c20 7375 6363 6573 735d 203d    [q, success] =
-000109b0: 2073 656c 662e 536f 6c76 6528 5469 2c20   self.Solve(Ti, 
-000109c0: 7129 0d0a 2020 2020 2020 2020 2020 2020  q)..            
-000109d0: 6966 206e 6f74 2073 7563 6365 7373 3a20  if not success: 
-000109e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000109f0: 2020 6966 2073 656c 662e 666c 6167 4465    if self.flagDe
-00010a00: 6275 673a 200d 0a20 2020 2020 2020 2020  bug: ..         
-00010a10: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00010a20: 2827 5741 524e 494e 473a 2049 6e76 6572  ('WARNING: Inver
-00010a30: 7365 4b69 6e65 6d61 7469 6373 3a20 536f  seKinematics: So
-00010a40: 6c76 6553 6166 6520 6661 696c 6564 2074  lveSafe failed t
-00010a50: 6f20 736f 6c76 6527 290d 0a20 2020 2020  o solve')..     
-00010a60: 2020 2020 2020 2020 2020 2062 7265 616b             break
-00010a70: 0d0a 0d0a 2020 2020 2020 2020 6966 2073  ....        if s
-00010a80: 7563 6365 7373 3a0d 0a20 2020 2020 2020  uccess:..       
-00010a90: 2020 2020 2054 536f 6c20 3d20 7365 6c66       TSol = self
-00010aa0: 2e47 6574 4375 7272 656e 7452 6f62 6f74  .GetCurrentRobot
-00010ab0: 4854 2829 2023 2074 6865 2066 6f72 7761  HT() # the forwa
-00010ac0: 7264 206b 696e 656d 6174 6963 7320 6166  rd kinematics af
-00010ad0: 7465 7220 736f 6c76 696e 670d 0a20 2020  ter solving..   
-00010ae0: 2020 2020 2065 6c73 653a 0d0a 2020 2020       else:..    
-00010af0: 2020 2020 2020 2020 5453 6f6c 203d 2054          TSol = T
-00010b00: 300d 0a20 2020 200d 0a20 2020 2020 2020  0..    ..       
-00010b10: 2069 6620 2828 5453 6f6c 2d54 2920 3e3d   if ((TSol-T) >=
-00010b20: 2073 656c 662e 6570 7353 6f6c 7574 696f   self.epsSolutio
-00010b30: 6e29 2e61 6e79 2829 3a20 232a 4a47 3a20  n).any(): #*JG: 
-00010b40: 3165 2d31 323b 2074 7279 206f 6e63 6520  1e-12; try once 
-00010b50: 6167 6169 6e20 7769 7468 2065 7665 6e20  again with even 
-00010b60: 6669 6e65 7220 6469 7363 7265 7469 7a61  finer discretiza
-00010b70: 7469 6f6e 202e 2e2e 0d0a 2020 2020 2020  tion .....      
-00010b80: 2020 2020 2020 6966 2073 656c 662e 666c        if self.fl
-00010b90: 6167 4465 6275 673a 0d0a 2020 2020 2020  agDebug:..      
-00010ba0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-00010bb0: 2757 4152 4e49 4e47 3a20 496e 7665 7273  'WARNING: Invers
-00010bc0: 654b 696e 656d 6174 6963 733a 2053 6f6c  eKinematics: Sol
-00010bd0: 7665 5361 6665 2072 6566 696e 6527 290d  veSafe refine').
-00010be0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010bf0: 2069 6620 7375 6363 6573 733a 0d0a 2020   if success:..  
-00010c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010c10: 2020 7072 696e 7428 2720 6174 2065 7272    print(' at err
-00010c20: 203d 205c 6e27 2c20 286e 702e 726f 756e   = \n', (np.roun
-00010c30: 6428 2854 536f 6c2d 5429 2c20 3130 2929  d((TSol-T), 10))
-00010c40: 2029 2023 2072 6f75 6e64 2066 6f72 2062   ) # round for b
-00010c50: 6574 7465 7220 7265 6164 6162 696c 6974  etter readabilit
-00010c60: 790d 0a0d 0a20 2020 2020 2020 2020 2020  y....           
-00010c70: 2054 496e 7465 7270 203d 2073 656c 662e   TInterp = self.
-00010c80: 496e 7465 7270 6f6c 6174 6548 5473 2854  InterpolateHTs(T
-00010c90: 302c 2054 2c20 726f 7453 7465 7020 3d20  0, T, rotStep = 
-00010ca0: 6e70 2e70 692f 3230 2c20 6d69 6e53 7465  np.pi/20, minSte
-00010cb0: 7073 3d34 2920 232a 4a47 3a32 3032 332d  ps=4) #*JG:2023-
-00010cc0: 3033 2d32 393a 2063 6861 6e67 6564 2066  03-29: changed f
-00010cd0: 726f 6d20 5453 6f6c 2074 6f20 5430 0d0a  rom TSol to T0..
-00010ce0: 2020 2020 2020 2020 2020 2020 7120 3d20              q = 
-00010cf0: 7130 0d0a 2020 2020 2020 2020 2020 2020  q0..            
-00010d00: 666f 7220 5469 2069 6e20 5449 6e74 6572  for Ti in TInter
-00010d10: 703a 0d0a 2020 2020 2020 2020 2020 2020  p:..            
-00010d20: 2020 2020 5b71 2c20 7375 6363 6573 735d      [q, success]
-00010d30: 203d 2073 656c 662e 536f 6c76 6528 5469   = self.Solve(Ti
-00010d40: 2c20 7129 0d0a 2020 2020 2020 2020 2020  , q)..          
-00010d50: 2020 2020 2020 6966 206e 6f74 2073 7563        if not suc
-00010d60: 6365 7373 3a20 0d0a 2020 2020 2020 2020  cess: ..        
-00010d70: 2020 2020 2020 2020 2020 2020 6272 6561              brea
-00010d80: 6b0d 0a0d 0a20 2020 2020 2020 2020 2020  k....           
-00010d90: 2069 6620 7375 6363 6573 733a 0d0a 2020   if success:..  
-00010da0: 2020 2020 2020 2020 2020 2020 2020 5453                TS
-00010db0: 6f6c 203d 2073 656c 662e 4765 7443 7572  ol = self.GetCur
-00010dc0: 7265 6e74 526f 626f 7448 5428 290d 0a20  rentRobotHT().. 
-00010dd0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00010de0: 6620 286e 702e 6162 7328 5453 6f6c 2d54  f (np.abs(TSol-T
-00010df0: 2920 3e3d 2031 652d 3829 2e61 6e79 2829  ) >= 1e-8).any()
-00010e00: 3a20 0d0a 2020 2020 2020 2020 2020 2020  : ..            
-00010e10: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00010e20: 666c 6167 4465 6275 673a 200d 0a20 2020  flagDebug: ..   
-00010e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e40: 2020 2020 2070 7269 6e74 2827 5741 524e       print('WARN
-00010e50: 494e 473a 2049 6e76 6572 7365 4b69 6e65  ING: InverseKine
-00010e60: 6d61 7469 6373 3a20 536f 6c76 6553 6166  matics: SolveSaf
-00010e70: 6520 7265 6669 6e65 6d65 6e74 2066 6169  e refinement fai
-00010e80: 6c65 643a 2065 7272 203d 2027 2c20 286e  led: err = ', (n
-00010e90: 702e 726f 756e 6428 2854 536f 6c2d 5429  p.round((TSol-T)
-00010ea0: 2c20 3130 2929 2920 2320 726f 756e 6420  , 10))) # round 
-00010eb0: 666f 7220 6265 7474 6572 2072 6561 6461  for better reada
-00010ec0: 6269 6c69 7479 0d0a 2020 2020 2020 2020  bility..        
-00010ed0: 2020 2020 2020 2020 2020 2020 7375 6363              succ
-00010ee0: 6573 7320 3d20 4661 6c73 650d 0a0d 0a20  ess = False.... 
-00010ef0: 2020 2020 2020 2069 6620 6e6f 7420 7375         if not su
-00010f00: 6363 6573 733a 0d0a 2020 2020 2020 2020  ccess:..        
-00010f10: 2020 2020 7120 3d20 4e6f 6e65 0d0a 0d0a      q = None....
-00010f20: 2020 2020 2020 2020 7265 7475 726e 205b          return [
-00010f30: 712c 2073 7563 6365 7373 5d0d 0a20 2020  q, success]..   
-00010f40: 200d 0a20 2020 2023 2a2a 636c 6173 7346   ..    #**classF
-00010f50: 756e 6374 696f 6e3a 2054 6869 7320 4d65  unction: This Me
-00010f60: 7468 6f64 2063 616e 2062 6520 7573 6564  thod can be used
-00010f70: 2074 6f20 736f 6c76 6520 7468 6520 696e   to solve the in
-00010f80: 7665 7273 6520 6b69 6e65 6d61 7469 6373  verse kinematics
-00010f90: 2070 726f 626c 656d 2062 7920 736f 6c76   problem by solv
-00010fa0: 696e 6720 0d0a 2020 2020 2320 2020 2020  ing ..    #     
-00010fb0: 2020 2020 2020 2074 6865 2073 7461 7469         the stati
-00010fc0: 6320 7072 6f62 6c65 6d20 6f66 2061 2073  c problem of a s
-00010fd0: 6572 6961 6c20 726f 626f 7420 7573 696e  erial robot usin
-00010fe0: 6720 7374 6570 7320 746f 2069 6e74 6572  g steps to inter
-00010ff0: 706f 6c61 7465 2062 6574 7765 656e 2073  polate between s
-00011000: 7461 7274 2061 6e64 2065 6e64 2070 6f73  tart and end pos
-00011010: 6974 696f 6e20 636c 6f73 6520 746f 2074  ition close to t
-00011020: 6865 2066 756e 6374 696f 6e20 536f 6c76  he function Solv
-00011030: 652e 200d 0a20 2020 2023 2020 2020 2020  e. ..    #      
-00011040: 2020 2020 2054 2068 6973 2068 656c 7073       T his helps
-00011050: 2074 6865 2066 7563 6e74 696f 6e20 536f   the fucntion So
-00011060: 6c76 6520 746f 2066 696e 6420 7468 6520  lve to find the 
-00011070: 636f 7272 6563 7420 736f 6c75 7469 6f6e  correct solution
-00011080: 732e 200d 0a20 2020 2023 2a2a 696e 7075  s. ..    #**inpu
-00011090: 743a 0d0a 2020 2020 2320 2054 3a20 7468  t:..    #  T: th
-000110a0: 6520 3478 3420 686f 6d6f 6765 6e65 6f75  e 4x4 homogeneou
-000110b0: 7320 7472 616e 7366 6f72 6d61 7469 6f6e  s transformation
-000110c0: 206d 6174 7269 7820 7265 7072 6573 656e   matrix represen
-000110d0: 7469 6e67 2074 6865 2064 6573 6972 6564  ting the desired
-000110e0: 2070 6f73 6974 696f 6e20 616e 6420 6f72   position and or
-000110f0: 6965 6e74 6174 696f 6e20 6f66 2074 6865  ientation of the
-00011100: 2045 6e64 6566 6665 6374 6f72 0d0a 2020   Endeffector..  
-00011110: 2020 2320 2071 303a 2054 6865 2063 6f6e    #  q0: The con
-00011120: 6669 6775 7261 7469 6f6e 2028 6a6f 696e  figuration (join
-00011130: 7420 616e 676c 6573 2f70 6f73 6974 696f  t angles/positio
-00011140: 6e73 2920 6f66 2074 6865 2072 6f62 6f74  ns) of the robot
-00011150: 2066 726f 6d20 7768 6963 6820 7468 6520   from which the 
-00011160: 6e75 6d65 7269 6361 6c20 6d65 7468 6f64  numerical method
-00011170: 7320 7374 6172 7420 736f 2063 616c 6375  s start so calcu
-00011180: 6c61 7465 2074 6865 2073 6f6c 7574 696f  late the solutio
-00011190: 6e3b 2071 303d 4e6f 6e65 2069 6e64 6963  n; q0=None indic
-000111a0: 6174 6573 2074 6861 7420 7468 6520 7374  ates that the st
-000111b0: 6f72 6564 2073 6f6c 7574 696f 6e20 2866  ored solution (f
-000111c0: 726f 6d20 6d6f 6465 6c20 6f72 2070 7265  rom model or pre
-000111d0: 7669 6f75 7320 736f 6c75 7469 6f6e 2920  vious solution) 
-000111e0: 7368 616c 6c20 6265 2075 7365 6420 666f  shall be used fo
-000111f0: 7220 696e 6974 6961 6c69 7a61 7469 6f6e  r initialization
-00011200: 0d0a 2020 2020 232a 2a6f 7574 7075 743a  ..    #**output:
-00011210: 205b 712c 2073 7563 6365 7373 5d3b 2071   [q, success]; q
-00011220: 3a20 5468 6520 736f 6c75 7469 6f6e 2066  : The solution f
-00011230: 6f72 2074 6865 206a 6f69 6e74 2061 6e67  or the joint ang
-00011240: 6c65 7320 696e 2077 6869 6368 2074 6865  les in which the
-00011250: 2072 6f62 6f74 2773 2074 6f6f 6c20 6365   robot's tool ce
-00011260: 6e74 6572 2070 6f69 6e74 2028 5443 5029  nter point (TCP)
-00011270: 2072 6561 6368 6573 2074 6865 2064 6573   reaches the des
-00011280: 6972 6564 2068 6f6d 6f67 656e 656f 7573  ired homogeneous
-00011290: 2074 7261 6e73 666f 726d 6174 696f 6e20   transformation 
-000112a0: 6d61 7472 6978 2054 3b20 7375 6363 6573  matrix T; succes
-000112b0: 733d 4661 6c73 6520 696e 6469 6361 7465  s=False indicate
-000112c0: 7320 7468 6174 2061 6c6c 2074 7269 616c  s that all trial
-000112d0: 7320 666f 7220 696e 7665 7273 6520 6b69  s for inverse ki
-000112e0: 6e65 6d61 7469 6373 2066 6169 6c65 642c  nematics failed,
-000112f0: 206c 6561 6469 6e67 2074 6f20 713d 4e6f   leading to q=No
-00011300: 6e65 0d0a 2020 2020 232a 2a61 7574 686f  ne..    #**autho
-00011310: 723a 2050 6574 6572 204d 616e 7a6c 2c20  r: Peter Manzl, 
-00011320: 4a6f 6861 6e6e 6573 2047 6572 7374 6d61  Johannes Gerstma
-00011330: 7972 0d0a 2020 2020 232a 2a6e 6f74 6573  yr..    #**notes
-00011340: 3a20 7374 696c 6c20 756e 6465 7220 6465  : still under de
-00011350: 7665 6c6f 706d 656e 743b 2065 7272 6f72  velopment; error
-00011360: 7320 696e 206f 7269 656e 7461 7469 6f6e  s in orientation
-00011370: 7320 6f66 2073 6f6c 7574 696f 6e20 6d61  s of solution ma
-00011380: 7920 6f63 6375 7265 2e20 776f 726b 7320  y occure. works 
-00011390: 7369 6d69 6c61 7220 746f 2069 6b69 6e65  similar to ikine
-000113a0: 5c5f 4c4d 2066 756e 6374 696f 6e20 6f66  \_LM function of
-000113b0: 2074 6865 2072 6f62 6f74 6963 7320 746f   the robotics to
-000113c0: 6f6c 626f 7820 6672 6f6d 2070 6574 6572  olbox from peter
-000113d0: 2063 6f72 6b65 0d0a 2020 2020 6465 6620   corke..    def 
-000113e0: 536f 6c76 6528 7365 6c66 2c20 542c 2071  Solve(self, T, q
-000113f0: 3020 3d20 4e6f 6e65 293a 200d 0a20 2020  0 = None): ..   
-00011400: 2020 2020 2023 2063 6865 636b 2074 7970       # check typ
-00011410: 6520 6f66 2054 200d 0a20 2020 2020 2020  e of T ..       
-00011420: 2054 203d 206e 702e 6172 7261 7928 5429   T = np.array(T)
-00011430: 0d0a 2020 2020 2020 2020 6966 2054 2e73  ..        if T.s
-00011440: 6861 7065 2021 3d20 2834 2c34 2920 6f72  hape != (4,4) or
-00011450: 2072 6f75 6e64 286e 702e 6c69 6e61 6c67   round(np.linalg
-00011460: 2e64 6574 2854 5b30 3a33 2c20 303a 335d  .det(T[0:3, 0:3]
-00011470: 292c 3130 2920 213d 2031 2e30 3a20 2023  ),10) != 1.0:  #
-00011480: 2063 6865 636b 2069 6620 6973 2068 6f6d   check if is hom
-00011490: 6f67 656e 656f 7573 2054 460d 0a20 2020  ogeneous TF..   
-000114a0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000114b0: 616c 7565 4572 726f 7228 2769 6e76 6572  alueError('inver
-000114c0: 7365 204b 696e 656d 6174 6963 7320 6f6e  se Kinematics on
-000114d0: 6c79 2070 6f73 7369 626c 6520 666f 7220  ly possible for 
-000114e0: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
-000114f0: 7366 6f72 6d61 7469 6f6e 732c 2072 6570  sformations, rep
-00011500: 7265 7365 6e74 6564 2062 7920 6120 3478  resented by a 4x
-00011510: 3420 6172 7261 7920 7769 7468 2073 7472  4 array with str
-00011520: 7563 7475 7265 206f 6620 5b5b 522c 2074  ucture of [[R, t
-00011530: 5d2c 205b 302c 302c 302c 315d 5d2e 2729  ], [0,0,0,1]].')
-00011540: 0d0a 2020 2020 2020 2020 7120 3d20 4e6f  ..        q = No
-00011550: 6e65 0d0a 2020 2020 2020 2020 6966 206e  ne..        if n
-00011560: 6f74 2868 6173 6174 7472 2871 302c 2027  ot(hasattr(q0, '
-00011570: 5f5f 6974 6572 5f5f 2729 2920 616e 6420  __iter__')) and 
-00011580: 7130 203d 3d20 4e6f 6e65 3a20 2372 6570  q0 == None: #rep
-00011590: 6c61 6365 2077 6974 683a 2071 3020 6973  lace with: q0 is
-000115a0: 204e 6f6e 650d 0a20 2020 2020 2020 2020   None..         
-000115b0: 2020 2071 3020 3d20 7365 6c66 2e6d 6273     q0 = self.mbs
-000115c0: 494b 2e73 7973 7465 6d44 6174 612e 4765  IK.systemData.Ge
-000115d0: 744f 4445 3243 6f6f 7264 696e 6174 6573  tODE2Coordinates
-000115e0: 2829 2023 202b 2028 6e70 2e72 616e 646f  () # + (np.rando
-000115f0: 6d2e 7261 6e64 6f6d 2873 656c 662e 6e4c  m.random(self.nL
-00011600: 696e 6b73 292d 302e 3529 2a30 2e31 2023  inks)-0.5)*0.1 #
-00011610: 205b 305d 2a73 656c 662e 6e4c 696e 6b73   [0]*self.nLinks
-00011620: 0d0a 2020 2020 2020 2020 0d0a 2020 2020  ..        ..    
-00011630: 2020 2020 2361 6c77 6179 7320 7365 7420      #always set 
-00011640: 7130 2061 7320 7a65 726f 2d63 6f6e 6669  q0 as zero-confi
-00011650: 6775 7261 7469 6f6e 2066 6f72 2073 7072  guration for spr
-00011660: 696e 6773 210d 0a20 2020 2020 2020 2071  ings!..        q
-00011670: 3020 3d20 7072 6f6a 6563 7441 6e67 6c65  0 = projectAngle
-00011680: 546f 504d 5069 2871 3029 200d 0a20 2020  ToPMPi(q0) ..   
-00011690: 2020 2020 2073 656c 662e 6d62 7349 4b2e       self.mbsIK.
-000116a0: 5365 744f 626a 6563 7450 6172 616d 6574  SetObjectParamet
-000116b0: 6572 2873 656c 662e 726f 626f 7444 6963  er(self.robotDic
-000116c0: 745b 276f 626a 6563 744b 696e 656d 6174  t['objectKinemat
-000116d0: 6963 5472 6565 275d 2c20 276a 6f69 6e74  icTree'], 'joint
-000116e0: 506f 7369 7469 6f6e 4f66 6673 6574 5665  PositionOffsetVe
-000116f0: 6374 6f72 272c 2071 3029 0d0a 0d0a 2020  ctor', q0)....  
-00011700: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00011710: 7365 6c66 2e6d 6273 494b 2e73 7973 7465  self.mbsIK.syste
-00011720: 6d44 6174 612e 5365 744f 4445 3243 6f6f  mData.SetODE2Coo
-00011730: 7264 696e 6174 6573 2863 6f6f 7264 696e  rdinates(coordin
-00011740: 6174 6573 3d71 302c 2063 6f6e 6669 6775  ates=q0, configu
-00011750: 7261 7469 6f6e 3d65 7875 6479 6e2e 436f  ration=exudyn.Co
-00011760: 6e66 6967 7572 6174 696f 6e54 7970 652e  nfigurationType.
-00011770: 496e 6974 6961 6c29 0d0a 2020 2020 2020  Initial)..      
-00011780: 2020 5220 3d20 6572 622e 4854 3272 6f74    R = erb.HT2rot
-00011790: 6174 696f 6e4d 6174 7269 7828 5429 0d0a  ationMatrix(T)..
-000117a0: 2020 2020 2020 2020 7472 616e 7320 3d20          trans = 
-000117b0: 2865 7262 2e48 5432 7472 616e 736c 6174  (erb.HT2translat
-000117c0: 696f 6e28 5429 290d 0a20 2020 2020 2020  ion(T))..       
-000117d0: 200d 0a20 2020 2020 2020 2023 2073 6574   ..        # set
-000117e0: 2074 6865 2070 6f73 6974 696f 6e20 6f66   the position of
-000117f0: 2074 6865 2047 726f 756e 6420 746f 206d   the Ground to m
-00011800: 6174 6368 2074 6865 2064 6573 6972 6564  atch the desired
-00011810: 2045 4520 706f 7369 7469 6f6e 2028 696e   EE position (in
-00011820: 2067 6c6f 6261 6c20 2267 726f 756e 6422   global "ground"
-00011830: 2073 7974 656d 290d 0a20 2020 2020 2020   sytem)..       
-00011840: 2073 656c 662e 6d62 7349 4b2e 5365 744d   self.mbsIK.SetM
-00011850: 6172 6b65 7250 6172 616d 6574 6572 2873  arkerParameter(s
-00011860: 656c 662e 6d47 726f 756e 6445 452c 2027  elf.mGroundEE, '
-00011870: 6c6f 6361 6c50 6f73 6974 696f 6e27 2c20  localPosition', 
-00011880: 7472 616e 7329 0d0a 2020 2020 2020 2020  trans)..        
-00011890: 2320 7365 7420 7468 6520 6465 7369 7265  # set the desire
-000118a0: 6420 726f 7461 7469 6f6e 200d 0a20 2020  d rotation ..   
-000118b0: 2020 2020 2073 656c 662e 6d62 7349 4b2e       self.mbsIK.
-000118c0: 5365 744f 626a 6563 7450 6172 616d 6574  SetObjectParamet
-000118d0: 6572 2873 656c 662e 636f 6e73 7472 6169  er(self.constrai
-000118e0: 6e74 546f 6f6c 2c20 2772 6f74 6174 696f  ntTool, 'rotatio
-000118f0: 6e4d 6172 6b65 7230 272c 2052 290d 0a20  nMarker0', R).. 
-00011900: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00011910: 2074 7279 3a20 0d0a 2020 2020 2020 2020   try: ..        
-00011920: 2020 2020 6966 2073 656c 662e 7573 6552      if self.useR
-00011930: 656e 6465 7265 723a 200d 0a20 2020 2020  enderer: ..     
-00011940: 2020 2020 2020 2020 2020 2065 7875 6479             exudy
-00011950: 6e2e 5374 6172 7452 656e 6465 7265 7228  n.StartRenderer(
-00011960: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00011970: 2020 2073 656c 662e 6d62 7349 4b2e 5761     self.mbsIK.Wa
-00011980: 6974 466f 7255 7365 7254 6f43 6f6e 7469  itForUserToConti
-00011990: 6e75 6528 2920 2373 746f 7020 6265 666f  nue() #stop befo
-000119a0: 7265 2073 696d 756c 6174 696e 670d 0a0d  re simulating...
-000119b0: 0a20 2020 2020 2020 2020 2020 2073 7563  .            suc
-000119c0: 6365 7373 203d 2073 656c 662e 7374 6174  cess = self.stat
-000119d0: 6963 536f 6c76 6572 2e53 6f6c 7665 5379  icSolver.SolveSy
-000119e0: 7374 656d 2873 656c 662e 6d62 7349 4b2c  stem(self.mbsIK,
-000119f0: 2073 656c 662e 7369 6d75 6c61 7469 6f6e   self.simulation
-00011a00: 5365 7474 696e 6773 290d 0a20 2020 2020  Settings)..     
-00011a10: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00011a20: 2020 2020 2071 203d 2073 656c 662e 6d62       q = self.mb
-00011a30: 7349 4b2e 7379 7374 656d 4461 7461 2e47  sIK.systemData.G
-00011a40: 6574 4f44 4532 436f 6f72 6469 6e61 7465  etODE2Coordinate
-00011a50: 7328 290d 0a20 2020 2020 2020 2020 2020  s()..           
-00011a60: 2071 203d 2070 726f 6a65 6374 416e 676c   q = projectAngl
-00011a70: 6554 6f50 4d50 6928 7129 2023 2073 6f6c  eToPMPi(q) # sol
-00011a80: 7574 696f 6e20 6f66 2074 6865 2069 6e76  ution of the inv
-00011a90: 6572 7365 206b 696e 656d 6174 6963 7320  erse kinematics 
-00011aa0: 7072 6f62 6c65 6d20 7072 6f6a 6563 7465  problem projecte
-00011ab0: 6420 696e 746f 202d 7069 2f70 6920 7261  d into -pi/pi ra
-00011ac0: 6e67 650d 0a20 2020 2020 2020 2020 2020  nge..           
-00011ad0: 2073 656c 662e 6d62 7349 4b2e 7379 7374   self.mbsIK.syst
-00011ae0: 656d 4461 7461 2e53 6574 4f44 4532 436f  emData.SetODE2Co
-00011af0: 6f72 6469 6e61 7465 7328 636f 6f72 6469  ordinates(coordi
-00011b00: 6e61 7465 733d 712c 2063 6f6e 6669 6775  nates=q, configu
-00011b10: 7261 7469 6f6e 3d65 7875 6479 6e2e 436f  ration=exudyn.Co
-00011b20: 6e66 6967 7572 6174 696f 6e54 7970 652e  nfigurationType.
-00011b30: 496e 6974 6961 6c29 0d0a 2020 2020 2020  Initial)..      
-00011b40: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00011b50: 6578 6365 7074 3a0d 0a20 2020 2020 2020  except:..       
-00011b60: 2020 2020 2069 6620 7365 6c66 2e66 6c61       if self.fla
-00011b70: 6744 6562 7567 3a20 0d0a 2020 2020 2020  gDebug: ..      
-00011b80: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-00011b90: 2757 4152 4e49 4e47 3a20 496e 7665 7273  'WARNING: Invers
-00011ba0: 654b 696e 656d 6174 6963 733a 2053 6f6c  eKinematics: Sol
-00011bb0: 7665 3a20 7374 6174 6963 2073 6f6c 7665  ve: static solve
-00011bc0: 7220 6661 696c 6564 2729 0d0a 2020 2020  r failed')..    
-00011bd0: 2020 2020 2020 2020 5b71 2c20 7375 6363          [q, succ
-00011be0: 6573 735d 203d 204e 6f6e 652c 2046 616c  ess] = None, Fal
-00011bf0: 7365 0d0a 2020 2020 2020 2020 2020 2020  se..            
-00011c00: 0d0a 2020 2020 2020 2020 6966 2073 7563  ..        if suc
-00011c10: 6365 7373 3a0d 0a20 2020 2020 2020 2020  cess:..         
-00011c20: 2020 2023 2072 6561 6420 6f75 7470 7574     # read output
-00011c30: 2066 726f 6d20 7365 6e73 6f72 7320 746f   from sensors to
-00011c40: 2063 6865 636b 2069 6620 7468 6520 736f   check if the so
-00011c50: 6c75 7469 6f6e 206f 6620 7468 6520 696e  lution of the in
-00011c60: 7665 7273 6520 4b69 6e65 6d61 7469 6373  verse Kinematics
-00011c70: 2077 6173 2063 6f72 7265 6374 0d0a 2020   was correct..  
-00011c80: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
-00011c90: 4b69 6e65 536f 6c76 6564 203d 2073 656c  KineSolved = sel
-00011ca0: 662e 4765 7443 7572 7265 6e74 526f 626f  f.GetCurrentRobo
-00011cb0: 7448 5428 290d 0a20 2020 2020 2020 2020  tHT()..         
-00011cc0: 2020 2069 6620 286e 702e 6162 7328 7365     if (np.abs(se
-00011cd0: 6c66 2e66 4b69 6e65 536f 6c76 6564 202d  lf.fKineSolved -
-00011ce0: 2054 2920 3c3d 2073 656c 662e 6570 7353   T) <= self.epsS
-00011cf0: 6f6c 7574 696f 6e29 2e61 6c6c 2829 3a20  olution).all(): 
-00011d00: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011d10: 2020 7375 6363 6573 7320 3d20 5472 7565    success = True
-00011d20: 0d0a 2020 2020 2020 2020 2020 2020 656c  ..            el
-00011d30: 7365 3a20 0d0a 2020 2020 2020 2020 2020  se: ..          
-00011d40: 2020 2020 2020 7375 6363 6573 7320 3d20        success = 
-00011d50: 4661 6c73 650d 0a20 2020 2020 2020 2020  False..         
-00011d60: 2020 2020 2020 2023 2066 6f72 7761 7264         # forward
-00011d70: 7320 6b69 6e65 6d61 7469 6373 2064 6576  s kinematics dev
-00011d80: 6961 7465 7320 6672 6f6d 2064 6573 6972  iates from desir
-00011d90: 6564 2048 543b 2068 6170 7065 6e73 2077  ed HT; happens w
-00011da0: 6865 6e20 6465 7369 7265 6420 5443 5020  hen desired TCP 
-00011db0: 6973 206f 7574 7369 6465 206f 6620 7468  is outside of th
-00011dc0: 6520 726f 626f 7427 7320 776f 726b 696e  e robot's workin
-00011dd0: 6720 7370 6163 650d 0a20 2020 2020 2020  g space..       
-00011de0: 2020 2020 2020 2020 2023 206f 7220 7768           # or wh
-00011df0: 656e 2074 6865 206f 7269 656e 7461 7469  en the orientati
-00011e00: 6f6e 2069 7320 6e6f 7420 7365 7420 636f  on is not set co
-00011e10: 7272 6563 746c 793b 2063 616e 2068 6170  rrectly; can hap
-00011e20: 7065 6e20 6265 6361 7573 6520 6f66 2063  pen because of c
-00011e30: 7572 7265 6e74 2069 6d70 6c65 6d65 6e74  urrent implement
-00011e40: 6174 696f 6e20 6f66 2067 656e 6572 6963  ation of generic
-00011e50: 206a 6f69 6e74 200d 0a20 2020 2020 2020   joint ..       
-00011e60: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00011e70: 2e66 6c61 6744 6562 7567 3a20 0d0a 2020  .flagDebug: ..  
-00011e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011e90: 2020 7072 696e 7428 275c 6e27 2a31 290d    print('\n'*1).
-00011ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011eb0: 2020 2020 2070 7269 6e74 2827 5741 524e       print('WARN
-00011ec0: 494e 473a 2049 6e76 6572 7365 4b69 6e65  ING: InverseKine
-00011ed0: 6d61 7469 6373 3a20 736f 6c75 7469 6f6e  matics: solution
-00011ee0: 2069 6e63 6f72 7265 6374 3a27 2920 0d0a   incorrect:') ..
-00011ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011f00: 2020 2020 7031 203d 2065 7262 2e48 5432      p1 = erb.HT2
-00011f10: 7472 616e 736c 6174 696f 6e28 7365 6c66  translation(self
-00011f20: 2e66 4b69 6e65 536f 6c76 6564 290d 0a20  .fKineSolved).. 
-00011f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011f40: 2020 2070 3220 3d20 6572 622e 4854 3274     p2 = erb.HT2t
-00011f50: 7261 6e73 6c61 7469 6f6e 2854 290d 0a20  ranslation(T).. 
-00011f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011f70: 2020 2070 7269 6e74 2827 706f 7320 6572     print('pos er
-00011f80: 726f 723a 2027 2c20 6e70 2e72 6f75 6e64  ror: ', np.round
-00011f90: 2870 312d 7032 2c20 3137 2929 2023 2069  (p1-p2, 17)) # i
-00011fa0: 6620 5446 2069 7320 696e 2074 6865 2077  f TF is in the w
-00011fb0: 6f72 6b73 7061 6365 2074 6865 6e20 7468  orkspace then th
-00011fc0: 6520 706f 7369 7469 6f6e 2077 6f72 6b73  e position works
-00011fd0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011fe0: 2020 2020 2020 2320 726f 7461 7469 6f6e        # rotation
-00011ff0: 206d 6179 2073 7469 6c6c 2062 6520 7772   may still be wr
-00012000: 6f6e 670d 0a20 2020 2020 2020 2020 2020  ong..           
-00012010: 2020 2020 2020 2020 2052 3120 3d20 7365           R1 = se
-00012020: 6c66 2e66 4b69 6e65 536f 6c76 6564 5b30  lf.fKineSolved[0
-00012030: 3a33 2c30 3a33 5d0d 0a20 2020 2020 2020  :3,0:3]..       
-00012040: 2020 2020 2020 2020 2020 2020 2052 3220               R2 
-00012050: 3d20 545b 303a 332c 303a 335d 0d0a 2020  = T[0:3,0:3]..  
-00012060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012070: 2020 726f 7431 203d 2065 7262 2e52 6f74    rot1 = erb.Rot
-00012080: 6174 696f 6e4d 6174 7269 7832 526f 7458  ationMatrix2RotX
-00012090: 595a 2852 3129 0d0a 2020 2020 2020 2020  YZ(R1)..        
-000120a0: 2020 2020 2020 2020 2020 2020 726f 7432              rot2
-000120b0: 203d 2065 7262 2e52 6f74 6174 696f 6e4d   = erb.RotationM
-000120c0: 6174 7269 7832 526f 7458 595a 2852 3229  atrix2RotXYZ(R2)
-000120d0: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
-000120e0: 2020 2020 2020 2070 7269 6e74 2827 726f         print('ro
-000120f0: 7431 203d 207b 7d2c 2072 6f74 3220 3d20  t1 = {}, rot2 = 
-00012100: 7b7d 272e 666f 726d 6174 2872 6f74 312c  {}'.format(rot1,
-00012110: 2072 6f74 3229 290d 0a20 2020 2020 2020   rot2))..       
-00012120: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00012130: 6e74 2827 5231 3a5c 6e7b 7d2c 205c 6e52  nt('R1:\n{}, \nR
-00012140: 323a 5c6e 7b7d 272e 666f 726d 6174 2852  2:\n{}'.format(R
-00012150: 312c 2052 3229 290d 0a20 2020 2020 2020  1, R2))..       
-00012160: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00012170: 6e74 2827 5c6e 272a 3129 0d0a 2020 2020  nt('\n'*1)..    
-00012180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012190: 2320 7261 6973 6520 5661 6c75 6545 7272  # raise ValueErr
-000121a0: 6f72 2827 6e6f 2076 616c 6964 2073 6f6c  or('no valid sol
-000121b0: 7574 696f 6e20 666f 756e 6420 666f 7220  ution found for 
-000121c0: 696e 7665 7273 6520 6b69 6e65 6d61 7469  inverse kinemati
-000121d0: 6373 2729 0d0a 2020 2020 2020 2020 656c  cs')..        el
-000121e0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-000121f0: 2071 203d 204e 6f6e 650d 0a0d 0a20 2020   q = None....   
-00012200: 2020 2020 2069 6620 7365 6c66 2e75 7365       if self.use
-00012210: 5265 6e64 6572 6572 3a20 2020 200d 0a20  Renderer:    .. 
-00012220: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00012230: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
-00012240: 6773 2e73 6f6c 7574 696f 6e53 6574 7469  gs.solutionSetti
-00012250: 6e67 732e 736f 6c75 7469 6f6e 496e 666f  ngs.solutionInfo
-00012260: 726d 6174 696f 6e20 3d20 2773 7563 6365  rmation = 'succe
-00012270: 7373 203d 207b 7d5c 6e71 3d7b 7d27 2e66  ss = {}\nq={}'.f
-00012280: 6f72 6d61 7428 7375 6363 6573 732c 206e  ormat(success, n
-00012290: 702e 726f 756e 6428 712c 2033 2929 0d0a  p.round(q, 3))..
-000122a0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-000122b0: 2e53 432e 5761 6974 466f 7252 656e 6465  .SC.WaitForRende
-000122c0: 7245 6e67 696e 6553 746f 7046 6c61 6728  rEngineStopFlag(
-000122d0: 2920 2320 7374 6f70 2062 6566 6f72 6520  ) # stop before 
-000122e0: 636c 6f73 696e 670d 0a20 2020 2020 2020  closing..       
-000122f0: 2020 2020 2065 7875 6479 6e2e 5374 6f70       exudyn.Stop
-00012300: 5265 6e64 6572 6572 2829 2023 2063 6c6f  Renderer() # clo
-00012310: 7365 2072 656e 6465 7269 6e67 2077 696e  se rendering win
-00012320: 646f 7721 200d 0a0d 0a20 2020 2020 2020  dow! ....       
-00012330: 2072 6574 7572 6e20 5b71 2c20 7375 6363   return [q, succ
-00012340: 6573 735d 0d0a 0d0a 0d0a 0d0a 0d0a 2320  ess]..........# 
-00012350: 2323 2064 656c 6574 6520 6576 6572 7974  ## delete everyt
-00012360: 6869 6e67 2061 6674 6572 2074 6861 7420  hing after that 
-00012370: 0d0a 2320 4d4f 5449 4f4e 2050 4c41 4e4e  ..# MOTION PLANN
-00012380: 494e 4720 616e 6420 5452 414a 4543 544f  ING and TRAJECTO
-00012390: 5249 4553 2070 7265 7365 7276 6564 2069  RIES preserved i
-000123a0: 6e20 4578 7065 7269 6d65 6e74 616c 2f6d  n Experimental/m
-000123b0: 6f74 696f 6e50 6c61 6e6e 696e 6754 6573  otionPlanningTes
-000123c0: 742e 7079 0d0a 2320 232b 2b2b 2b2b 2b2b  t.py..# #+++++++
-000123d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000123e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000123f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00012400: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00012410: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d 0a23  +++++++++++++..#
-00012420: 2023 2b2b 2b20 204d 4f54 494f 4e20 504c   #+++  MOTION PL
-00012430: 414e 4e49 4e47 2061 6e64 2054 5241 4a45  ANNING and TRAJE
-00012440: 4354 4f52 4945 5320 202b 2b2b 2b2b 2b2b  CTORIES  +++++++
-00012450: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00012460: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00012470: 2b2b 2b2b 2b2b 0d0a 2320 232b 2b2b 2b2b  ++++++..# #+++++
-00012480: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00012490: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000124a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000124b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000124c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d  +++++++++++++++.
-000124d0: 0a23 2023 2a2a 6675 6e63 7469 6f6e 3a20  .# #**function: 
-000124e0: 436f 6d70 7574 6520 7061 7261 6d65 7465  Compute paramete
-000124f0: 7273 2066 6f72 206f 7074 696d 616c 2074  rs for optimal t
-00012500: 7261 6a65 6374 6f72 7920 7573 696e 6720  rajectory using 
-00012510: 6769 7665 6e20 6475 7261 7469 6f6e 2061  given duration a
-00012520: 6e64 2064 6973 7461 6e63 650d 0a23 2023  nd distance..# #
-00012530: 2a2a 6e6f 7465 733a 2044 4550 5245 4341  **notes: DEPRECA
-00012540: 5445 442c 2044 4f20 4e4f 5420 5553 4520  TED, DO NOT USE 
-00012550: 2d20 6d6f 7665 6420 746f 2072 6f62 6f74  - moved to robot
-00012560: 6963 732e 6d6f 7469 6f6e 0d0a 2320 232a  ics.motion..# #*
-00012570: 2a69 6e70 7574 3a20 6475 7261 7469 6f6e  *input: duration
-00012580: 2069 6e20 7365 636f 6e64 7320 616e 6420   in seconds and 
-00012590: 6469 7374 616e 6365 2069 6e20 6d65 7465  distance in mete
-000125a0: 7273 206f 7220 7261 6469 616e 730d 0a23  rs or radians..#
-000125b0: 2023 2a2a 6f75 7470 7574 3a20 7265 7475   #**output: retu
-000125c0: 726e 7320 5b76 4d61 782c 2061 6363 4d61  rns [vMax, accMa
-000125d0: 785d 2077 6974 6820 6d61 7869 6d75 6d20  x] with maximum 
-000125e0: 7665 6c6f 6369 7479 2061 6e64 206d 6178  velocity and max
-000125f0: 696d 756d 2061 6363 656c 6572 6174 696f  imum acceleratio
-00012600: 6e20 746f 2061 6368 6965 7665 2067 6976  n to achieve giv
-00012610: 656e 2074 7261 6a65 6374 6f72 790d 0a23  en trajectory..#
-00012620: 2064 6566 2043 6f6e 7374 616e 7441 6363   def ConstantAcc
-00012630: 656c 6572 6174 696f 6e50 6172 616d 6574  elerationParamet
-00012640: 6572 7328 6475 7261 7469 6f6e 2c20 6469  ers(duration, di
-00012650: 7374 616e 6365 293a 0d0a 2320 2020 2020  stance):..#     
-00012660: 6163 634d 6178 203d 2034 2a64 6973 7461  accMax = 4*dista
-00012670: 6e63 652f 6475 7261 7469 6f6e 2a2a 320d  nce/duration**2.
-00012680: 0a23 2020 2020 2076 4d61 7820 3d20 2861  .#     vMax = (a
-00012690: 6363 4d61 7820 2a20 6469 7374 616e 6365  ccMax * distance
-000126a0: 292a 2a30 2e35 0d0a 2320 2020 2020 7265  )**0.5..#     re
-000126b0: 7475 726e 205b 764d 6178 2c20 6163 634d  turn [vMax, accM
-000126c0: 6178 5d0d 0a0d 0a23 2023 2a2a 6675 6e63  ax]....# #**func
-000126d0: 7469 6f6e 3a20 436f 6d70 7574 6520 616e  tion: Compute an
-000126e0: 676c 6520 2f20 6469 7370 6c61 6365 6d65  gle / displaceme
-000126f0: 6e74 2073 2c20 7665 6c6f 6369 7479 2076  nt s, velocity v
-00012700: 2061 6e64 2061 6363 656c 6572 6174 696f   and acceleratio
-00012710: 6e20 610d 0a23 2023 2a2a 696e 7075 743a  n a..# #**input:
-00012720: 200d 0a23 2023 2020 743a 2063 7572 7265   ..# #  t: curre
-00012730: 6e74 2074 696d 6520 746f 2063 6f6d 7075  nt time to compu
-00012740: 7465 2076 616c 7565 730d 0a23 2023 2020  te values..# #  
-00012750: 7453 7461 7274 3a20 7374 6172 7420 7469  tStart: start ti
-00012760: 6d65 206f 6620 7072 6f66 696c 650d 0a23  me of profile..#
-00012770: 2023 2020 7353 7461 7274 3a20 7374 6172   #  sStart: star
-00012780: 7420 6f66 6673 6574 206f 6620 7061 7468  t offset of path
-00012790: 0d0a 2320 2320 2064 7572 6174 696f 6e3a  ..# #  duration:
-000127a0: 2064 7572 6174 696f 6e20 6f66 2070 726f   duration of pro
-000127b0: 6669 6c65 0d0a 2320 2320 2064 6973 7461  file..# #  dista
-000127c0: 6e63 653a 2074 6f74 616c 2064 6973 7461  nce: total dista
-000127d0: 6e63 6520 286f 6620 7061 7468 2920 6f66  nce (of path) of
-000127e0: 2070 726f 6669 6c65 0d0a 2320 232a 2a6e   profile..# #**n
-000127f0: 6f74 6573 3a20 4445 5052 4543 4154 4544  otes: DEPRECATED
-00012800: 2c20 444f 204e 4f54 2055 5345 202d 206d  , DO NOT USE - m
-00012810: 6f76 6564 2074 6f20 726f 626f 7469 6373  oved to robotics
-00012820: 2e6d 6f74 696f 6e0d 0a23 2023 2a2a 6f75  .motion..# #**ou
-00012830: 7470 7574 3a20 5b73 2c20 762c 2061 5d20  tput: [s, v, a] 
-00012840: 7769 7468 2070 6174 6820 732c 2076 656c  with path s, vel
-00012850: 6f63 6974 7920 7620 616e 6420 6163 6365  ocity v and acce
-00012860: 6c65 7261 7469 6f6e 2061 2066 6f72 2063  leration a for c
-00012870: 6f6e 7374 616e 7420 6163 6365 6c65 7261  onstant accelera
-00012880: 7469 6f6e 2070 726f 6669 6c65 3b20 6265  tion profile; be
-00012890: 666f 7265 2074 5374 6172 742c 2073 6f6c  fore tStart, sol
-000128a0: 7574 696f 6e20 6973 205b 302c 302c 305d  ution is [0,0,0]
-000128b0: 2077 6869 6c65 2061 6674 6572 2064 7572   while after dur
-000128c0: 6174 696f 6e2c 2073 6f6c 7574 696f 6e20  ation, solution 
-000128d0: 6973 205b 7353 7461 7274 2b64 6973 7461  is [sStart+dista
-000128e0: 6e63 652c 2030 2c20 305d 0d0a 2320 6465  nce, 0, 0]..# de
-000128f0: 6620 436f 6e73 7461 6e74 4163 6365 6c65  f ConstantAccele
-00012900: 7261 7469 6f6e 5072 6f66 696c 6528 742c  rationProfile(t,
-00012910: 2074 5374 6172 742c 2073 5374 6172 742c   tStart, sStart,
-00012920: 2064 7572 6174 696f 6e2c 2064 6973 7461   duration, dista
-00012930: 6e63 6529 3a0d 0a23 2020 2020 205b 764d  nce):..#     [vM
-00012940: 6178 2c20 6163 634d 6178 5d20 3d20 436f  ax, accMax] = Co
-00012950: 6e73 7461 6e74 4163 6365 6c65 7261 7469  nstantAccelerati
-00012960: 6f6e 5061 7261 6d65 7465 7273 2864 7572  onParameters(dur
-00012970: 6174 696f 6e2c 2064 6973 7461 6e63 6529  ation, distance)
-00012980: 0d0a 2020 2020 0d0a 2320 2020 2020 7320  ..    ..#     s 
-00012990: 3d20 7353 7461 7274 0d0a 2320 2020 2020  = sStart..#     
-000129a0: 7620 3d20 300d 0a23 2020 2020 2061 203d  v = 0..#     a =
-000129b0: 2030 0d0a 2020 2020 0d0a 2320 2020 2020   0..    ..#     
-000129c0: 7820 3d20 742d 7453 7461 7274 0d0a 2320  x = t-tStart..# 
-000129d0: 2020 2020 6966 2078 203c 2030 3a0d 0a23      if x < 0:..#
-000129e0: 2020 2020 2020 2020 2073 3d30 0d0a 2320           s=0..# 
-000129f0: 2020 2020 656c 6966 2078 203c 2030 2e35      elif x < 0.5
-00012a00: 2a64 7572 6174 696f 6e3a 0d0a 2320 2020  *duration:..#   
-00012a10: 2020 2020 2020 7320 3d20 7353 7461 7274        s = sStart
-00012a20: 202b 2030 2e35 2a61 6363 4d61 782a 782a   + 0.5*accMax*x*
-00012a30: 2a32 0d0a 2320 2020 2020 2020 2020 7620  *2..#         v 
-00012a40: 3d20 782a 6163 634d 6178 0d0a 2320 2020  = x*accMax..#   
-00012a50: 2020 2020 2020 6120 3d20 6163 634d 6178        a = accMax
-00012a60: 0d0a 2320 2020 2020 656c 6966 2078 203c  ..#     elif x <
-00012a70: 2064 7572 6174 696f 6e3a 0d0a 2320 2020   duration:..#   
-00012a80: 2020 2020 2020 7320 3d20 7353 7461 7274        s = sStart
-00012a90: 202b 2064 6973 7461 6e63 6520 2d20 302e   + distance - 0.
-00012aa0: 352a 6163 634d 6178 202a 2028 6475 7261  5*accMax * (dura
-00012ab0: 7469 6f6e 2d78 292a 2a32 0d0a 2320 2020  tion-x)**2..#   
-00012ac0: 2020 2020 2020 7620 3d20 2864 7572 6174        v = (durat
-00012ad0: 696f 6e20 2d20 7829 2a61 6363 4d61 780d  ion - x)*accMax.
-00012ae0: 0a23 2020 2020 2020 2020 2061 203d 202d  .#         a = -
-00012af0: 6163 634d 6178 0d0a 2320 2020 2020 656c  accMax..#     el
-00012b00: 7365 3a0d 0a23 2020 2020 2020 2020 2073  se:..#         s
-00012b10: 203d 2073 5374 6172 7420 2b20 6469 7374   = sStart + dist
-00012b20: 616e 6365 0d0a 2020 2020 0d0a 2320 2020  ance..    ..#   
-00012b30: 2020 7265 7475 726e 205b 732c 2076 2c20    return [s, v, 
-00012b40: 615d 0d0a 0d0a 2320 6d6f 7469 6f6e 496e  a]....# motionIn
-00012b50: 7465 7270 6f6c 6174 6f72 5761 726e 6564  terpolatorWarned
-00012b60: 203d 2046 616c 7365 0d0a 2320 232a 2a66   = False..# #**f
-00012b70: 756e 6374 696f 6e3a 2043 6f6d 7075 7465  unction: Compute
-00012b80: 206a 6f69 6e74 2076 616c 7565 2c20 7665   joint value, ve
-00012b90: 6c6f 6369 7479 2061 6e64 2061 6363 656c  locity and accel
-00012ba0: 6572 6174 696f 6e20 666f 7220 6769 7665  eration for give
-00012bb0: 6e20 726f 626f 7454 7261 6a65 6374 6f72  n robotTrajector
-00012bc0: 795b 2750 5450 275d 206f 6620 706f 696e  y['PTP'] of poin
-00012bd0: 742d 746f 2d70 6f69 6e74 2074 7970 652c  t-to-point type,
-00012be0: 2065 7661 6c75 6174 6564 2066 6f72 2063   evaluated for c
-00012bf0: 7572 7265 6e74 2074 696d 6520 7420 616e  urrent time t an
-00012c00: 6420 6a6f 696e 7420 6e75 6d62 6572 0d0a  d joint number..
-00012c10: 2320 232a 2a69 6e70 7574 3a0d 0a23 2023  # #**input:..# #
-00012c20: 2020 743a 2074 696d 6520 746f 2065 7661    t: time to eva
-00012c30: 6c75 6174 6520 7472 616a 6563 746f 7279  luate trajectory
-00012c40: 0d0a 2320 2320 2072 6f62 6f74 5472 616a  ..# #  robotTraj
-00012c50: 6563 746f 7279 3a20 6469 6374 696f 6e61  ectory: dictiona
-00012c60: 7279 2074 6f20 6465 7363 7269 6265 2074  ry to describe t
-00012c70: 7261 6a65 6374 6f72 793b 2069 6e20 5054  rajectory; in PT
-00012c80: 5020 6361 7365 2c20 6569 7468 6572 2075  P case, either u
-00012c90: 7365 2027 7469 6d65 2720 706f 696e 7473  se 'time' points
-00012ca0: 2c20 6f72 2027 7469 6d65 2720 616e 6420  , or 'time' and 
-00012cb0: 2764 7572 6174 696f 6e27 2c20 6f72 2027  'duration', or '
-00012cc0: 7469 6d65 2720 616e 6420 276d 6178 5665  time' and 'maxVe
-00012cd0: 6c6f 6369 7479 2720 616e 6420 276d 6178  locity' and 'max
-00012ce0: 4163 6365 6c65 7261 7469 6f6e 7327 2069  Accelerations' i
-00012cf0: 6e20 616c 6c20 636f 6e73 6563 7574 6976  n all consecutiv
-00012d00: 6520 706f 696e 7473 3b20 276d 6178 5665  e points; 'maxVe
-00012d10: 6c6f 6369 7469 6573 2720 616e 6420 276d  locities' and 'm
-00012d20: 6178 4163 6365 6c65 7261 7469 6f6e 7327  axAccelerations'
-00012d30: 206d 7573 7420 6265 2070 6f73 6974 6976   must be positiv
-00012d40: 6520 6e6f 6e7a 6572 6f20 7661 6c75 6573  e nonzero values
-00012d50: 2074 6861 7420 6c69 6d69 7420 7665 6c6f   that limit velo
-00012d60: 6369 7469 6573 2061 6e64 2061 6363 656c  cities and accel
-00012d70: 6572 6174 696f 6e73 3b20 0d0a 2320 2320  erations; ..# # 
-00012d80: 206a 6f69 6e74 3a20 6a6f 696e 7420 6e75   joint: joint nu
-00012d90: 6d62 6572 2066 6f72 2077 6869 6368 2074  mber for which t
-00012da0: 6865 2074 7261 6a65 6374 6f72 7920 7368  he trajectory sh
-00012db0: 616c 6c20 6265 2065 7661 6c75 6174 6564  all be evaluated
-00012dc0: 0d0a 2320 232a 2a6f 7574 7075 743a 2066  ..# #**output: f
-00012dd0: 6f72 2063 7572 7265 6e74 2074 696d 6520  or current time 
-00012de0: 7420 6974 2072 6574 7572 6e73 205b 732c  t it returns [s,
-00012df0: 2076 2c20 615d 2077 6974 6820 7061 7468   v, a] with path
-00012e00: 2073 2c20 7665 6c6f 6369 7479 2076 2061   s, velocity v a
-00012e10: 6e64 2061 6363 656c 6572 6174 696f 6e20  nd acceleration 
-00012e20: 6120 666f 7220 6375 7272 656e 7420 6163  a for current ac
-00012e30: 6365 6c65 7261 7469 6f6e 2070 726f 6669  celeration profi
-00012e40: 6c65 3b20 6f75 7473 6964 6520 6f66 2070  le; outside of p
-00012e50: 726f 6669 6c65 2c20 6974 2072 6574 7572  rofile, it retur
-00012e60: 6e73 205b 302c 302c 305d 2021 0d0a 2320  ns [0,0,0] !..# 
-00012e70: 232a 2a6e 6f74 6573 3a20 4445 5052 4543  #**notes: DEPREC
-00012e80: 4154 4544 2c20 444f 204e 4f54 2055 5345  ATED, DO NOT USE
-00012e90: 202d 206d 6f76 6564 2074 6f20 726f 626f   - moved to robo
-00012ea0: 7469 6373 2e6d 6f74 696f 6e0d 0a23 2023  tics.motion..# #
-00012eb0: 2a2a 6578 616d 706c 653a 0d0a 2320 2320  **example:..# # 
-00012ec0: 7130 203d 205b 302c 302c 302c 302c 302c  q0 = [0,0,0,0,0,
-00012ed0: 305d 2023 696e 6974 6961 6c20 636f 6e66  0] #initial conf
-00012ee0: 6967 7572 6174 696f 6e0d 0a23 2023 2071  iguration..# # q
-00012ef0: 3120 3d20 5b38 2c35 2c32 2c30 2c32 2c31  1 = [8,5,2,0,2,1
-00012f00: 5d20 236f 7468 6572 2063 6f6e 6669 6775  ] #other configu
-00012f10: 7261 7469 6f6e 0d0a 2320 2320 5054 5020  ration..# # PTP 
-00012f20: 3d5b 5d0d 0a23 2023 2050 5450 2b3d 5b7b  =[]..# # PTP+=[{
-00012f30: 2771 273a 7130 2c20 0d0a 2320 2320 2020  'q':q0, ..# #   
-00012f40: 2020 2020 2027 7469 6d65 273a 307d 5d0d       'time':0}].
-00012f50: 0a23 2023 2050 5450 2b3d 5b7b 2771 273a  .# # PTP+=[{'q':
-00012f60: 7131 2c0d 0a23 2023 2020 2020 2020 2020  q1,..# #        
-00012f70: 2774 696d 6527 3a30 2e35 7d5d 0d0a 2320  'time':0.5}]..# 
-00012f80: 2320 5054 502b 3d5b 7b27 7127 3a71 312c  # PTP+=[{'q':q1,
-00012f90: 200d 0a23 2023 2020 2020 2020 2020 2774   ..# #        't
-00012fa0: 696d 6527 3a31 6536 7d5d 2023 666f 7265  ime':1e6}] #fore
-00012fb0: 7665 720d 0a23 2023 2052 543d 7b27 5054  ver..# # RT={'PT
-00012fc0: 5027 3a50 5450 7d0d 0a23 2023 205b 752c  P':PTP}..# # [u,
-00012fd0: 762c 615d 203d 204d 6f74 696f 6e49 6e74  v,a] = MotionInt
-00012fe0: 6572 706f 6c61 746f 7228 743d 302e 352c  erpolator(t=0.5,
-00012ff0: 2072 6f62 6f74 5472 616a 6563 746f 7279   robotTrajectory
-00013000: 3d52 542c 206a 6f69 6e74 3d31 290d 0a23  =RT, joint=1)..#
-00013010: 2064 6566 204d 6f74 696f 6e49 6e74 6572   def MotionInter
-00013020: 706f 6c61 746f 7228 742c 2072 6f62 6f74  polator(t, robot
-00013030: 5472 616a 6563 746f 7279 2c20 6a6f 696e  Trajectory, join
-00013040: 7429 3a0d 0a23 2020 2020 2067 6c6f 6261  t):..#     globa
-00013050: 6c20 6d6f 7469 6f6e 496e 7465 7270 6f6c  l motionInterpol
-00013060: 6174 6f72 5761 726e 6564 0d0a 2320 2020  atorWarned..#   
-00013070: 2020 6966 206e 6f74 206d 6f74 696f 6e49    if not motionI
-00013080: 6e74 6572 706f 6c61 746f 7257 6172 6e65  nterpolatorWarne
-00013090: 643a 0d0a 2320 2020 2020 2020 2020 6d6f  d:..#         mo
-000130a0: 7469 6f6e 496e 7465 7270 6f6c 6174 6f72  tionInterpolator
-000130b0: 5761 726e 6564 203d 2054 7275 650d 0a23  Warned = True..#
-000130c0: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-000130d0: 4d6f 7469 6f6e 496e 7465 7270 6f6c 6174  MotionInterpolat
-000130e0: 6f72 3a20 6465 7072 6563 6174 6564 202d  or: deprecated -
-000130f0: 2075 7365 2054 7261 6a65 6374 6f72 7920   use Trajectory 
-00013100: 636c 6173 7320 6672 6f6d 2072 6f62 6f74  class from robot
-00013110: 6963 732e 7472 616a 6563 746f 7279 2069  ics.trajectory i
-00013120: 6e73 7465 6164 2729 0d0a 2320 2020 2020  nstead')..#     
-00013130: 6e20 3d20 6c65 6e28 726f 626f 7454 7261  n = len(robotTra
-00013140: 6a65 6374 6f72 795b 2750 5450 275d 290d  jectory['PTP']).
-00013150: 0a23 2020 2020 2069 6620 6e20 3c20 323a  .#     if n < 2:
-00013160: 0d0a 2320 2020 2020 2020 2020 7072 696e  ..#         prin
-00013170: 7428 2245 5252 4f52 2069 6e20 4d6f 7469  t("ERROR in Moti
-00013180: 6f6e 496e 7465 7270 6f6c 6174 6f72 3a20  onInterpolator: 
-00013190: 7472 616a 6563 746f 7279 206d 7573 7420  trajectory must 
-000131a0: 6861 7665 2061 7420 6c65 6173 7420 3220  have at least 2 
-000131b0: 706f 696e 7473 2122 290d 0a20 2020 200d  points!")..    .
-000131c0: 0a23 2020 2020 2069 203d 2030 0d0a 2320  .#     i = 0..# 
-000131d0: 2020 2020 7768 696c 6520 2869 203c 206e      while (i < n
-000131e0: 2920 616e 6420 2874 203e 3d20 726f 626f  ) and (t >= robo
-000131f0: 7454 7261 6a65 6374 6f72 795b 2750 5450  tTrajectory['PTP
-00013200: 275d 5b69 5d5b 2774 696d 6527 5d29 3a0d  '][i]['time']):.
-00013210: 0a23 2020 2020 2020 2020 2069 202b 3d20  .#         i += 
-00013220: 310d 0a0d 0a23 2020 2020 2069 6620 2869  1....#     if (i
-00013230: 3d3d 3029 206f 7220 2869 3d3d 6e29 3a0d  ==0) or (i==n):.
-00013240: 0a23 2020 2020 2020 2020 2072 6574 7572  .#         retur
-00013250: 6e20 5b30 2c30 2c30 5d20 236f 7574 7369  n [0,0,0] #outsi
-00013260: 6465 206f 6620 7472 616a 6563 746f 7279  de of trajectory
-00013270: 0d0a 2020 2020 0d0a 2320 2020 2020 2369  ..    ..#     #i
-00013280: 206d 7573 7420 6265 203e 2030 2061 6e64   must be > 0 and
-00013290: 203c 206e 206e 6f77 210d 0a23 2020 2020   < n now!..#    
-000132a0: 2071 3020 3d20 726f 626f 7454 7261 6a65   q0 = robotTraje
-000132b0: 6374 6f72 795b 2750 5450 275d 5b69 2d31  ctory['PTP'][i-1
-000132c0: 5d20 236d 7573 7420 616c 7761 7973 2065  ] #must always e
-000132d0: 7869 7374 0d0a 2320 2020 2020 7131 203d  xist..#     q1 =
-000132e0: 2072 6f62 6f74 5472 616a 6563 746f 7279   robotTrajectory
-000132f0: 5b27 5054 5027 5d5b 695d 2023 6d75 7374  ['PTP'][i] #must
-00013300: 2061 6c77 6179 7320 6578 6973 740d 0a20   always exist.. 
-00013310: 2020 200d 0a23 2020 2020 2072 6574 7572     ..#     retur
-00013320: 6e20 436f 6e73 7461 6e74 4163 6365 6c65  n ConstantAccele
-00013330: 7261 7469 6f6e 5072 6f66 696c 6528 742c  rationProfile(t,
-00013340: 2071 305b 2774 696d 6527 5d2c 2071 305b   q0['time'], q0[
-00013350: 2771 275d 5b6a 6f69 6e74 5d2c 200d 0a23  'q'][joint], ..#
-00013360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013380: 2020 2020 2020 2020 7131 5b27 7469 6d65          q1['time
-00013390: 275d 202d 2071 305b 2774 696d 6527 5d2c  '] - q0['time'],
-000133a0: 200d 0a23 2020 2020 2020 2020 2020 2020   ..#            
-000133b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000133c0: 2020 2020 2020 2020 2020 2020 7131 5b27              q1['
-000133d0: 7127 5d5b 6a6f 696e 745d 202d 2071 305b  q'][joint] - q0[
-000133e0: 2771 275d 5b6a 6f69 6e74 5d29 0d0a 0d0a  'q'][joint])....
-000133f0: 0d0a 0d0a 0d0a 0d0a 0d0a 0d0a 0d0a 0d0a  ................
-00013400: 2320 7365 7269 616c 526f 626f 7432 4d42  # serialRobot2MB
-00013410: 5377 6172 6e65 643d 4661 6c73 650d 0a23  Swarned=False..#
-00013420: 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b   #++++++++++++++
-00013430: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013440: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013450: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013460: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013470: 2b2b 2b2b 2b2b 0d0a 2320 232b 2b2b 2020  ++++++..# #+++  
-00013480: 6372 6561 7465 2061 2053 4552 4941 4c20  create a SERIAL 
-00013490: 524f 424f 5420 6672 6f6d 2044 482d 7061  ROBOT from DH-pa
-000134a0: 7261 6d65 7465 7273 2069 6e20 7468 6520  rameters in the 
-000134b0: 6d62 7320 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  mbs ++++++++++++
-000134c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d  +++++++++++++++.
-000134d0: 0a23 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  .# #++++++++++++
-000134e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-000134f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013500: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013510: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00013520: 2b2b 2b2b 2b2b 2b2b 0d0a 2320 232a 2a66  ++++++++..# #**f
-00013530: 756e 6374 696f 6e3a 2044 4550 5245 4341  unction: DEPRECA
-00013540: 5445 4420 6675 6e63 7469 6f6e 2c20 7573  TED function, us
-00013550: 6520 526f 626f 742e 4372 6561 7465 5265  e Robot.CreateRe
-00013560: 6475 6e64 616e 7443 6f6f 7264 696e 6174  dundantCoordinat
-00013570: 654d 4253 282e 2e2e 293b 2061 6464 2069  eMBS(...); add i
-00013580: 7465 6d73 2074 6f20 6578 6973 7469 6e67  tems to existing
-00013590: 206d 6273 2066 726f 6d20 7468 6520 726f   mbs from the ro
-000135a0: 626f 7420 7374 7275 6374 7572 652c 2061  bot structure, a
-000135b0: 2062 6173 654d 6172 6b65 7220 2863 616e   baseMarker (can
-000135c0: 2062 6520 6772 6f75 6e64 206f 626a 6563   be ground objec
-000135d0: 7420 6f72 2062 6f64 7929 0d0a 2320 2320  t or body)..# # 
-000135e0: 2020 2020 2020 2020 2020 2061 6e64 2074             and t
-000135f0: 6865 2075 7365 7220 6675 6e63 7469 6f6e  he user function
-00013600: 206c 6973 7420 666f 7220 7468 6520 6a6f   list for the jo
-00013610: 696e 7473 3b20 7468 6572 6520 6172 6520  ints; there are 
-00013620: 6f70 7469 6f6e 7320 7468 6174 2063 616e  options that can
-00013630: 2062 6520 7061 7373 6564 2061 7320 6172   be passed as ar
-00013640: 6773 202f 206b 7761 7267 732c 2077 6869  gs / kwargs, whi
-00013650: 6368 2063 616e 2063 6f6e 7461 696e 7320  ch can contains 
-00013660: 6f70 7469 6f6e 7320 6173 2064 6573 6372  options as descr
-00013670: 6962 6564 2062 656c 6f77 2e20 466f 7220  ibed below. For 
-00013680: 6465 7461 696c 732c 2073 6565 2074 6865  details, see the
-00013690: 2070 7974 686f 6e20 6669 6c65 2061 6e64   python file and
-000136a0: 205c 7465 7874 7474 7b73 6572 6961 6c52   \texttt{serialR
-000136b0: 6f62 6f74 5465 7374 2e70 797d 2069 6e20  obotTest.py} in 
-000136c0: 5465 7374 4d6f 6465 6c73 0d0a 2320 232a  TestModels..# #*
-000136d0: 2a69 6e70 7574 3a20 0d0a 2320 2320 2020  *input: ..# #   
-000136e0: 6d62 733a 2074 6865 206d 756c 7469 626f  mbs: the multibo
-000136f0: 6479 2073 7973 7465 6d2c 2077 6869 6368  dy system, which
-00013700: 2077 696c 6c20 6265 2065 7874 656e 6465   will be extende
-00013710: 640d 0a23 2023 2020 2072 6f62 6f74 3a20  d..# #   robot: 
-00013720: 7468 6520 726f 626f 7420 6d6f 6465 6c20  the robot model 
-00013730: 6173 2064 6963 7469 6f6e 6172 792c 2064  as dictionary, d
-00013740: 6573 6372 6962 6564 2069 6e20 6675 6e63  escribed in func
-00013750: 7469 6f6e 2043 6f6d 7075 7465 4a6f 696e  tion ComputeJoin
-00013760: 7448 540d 0a23 2023 2020 206a 6f69 6e74  tHT..# #   joint
-00013770: 4c6f 6164 5573 6572 4675 6e63 7469 6f6e  LoadUserFunction
-00013780: 4c69 7374 3a20 6120 6c69 7374 206f 6620  List: a list of 
-00013790: 7573 6572 2066 756e 6374 696f 6e73 2066  user functions f
-000137a0: 6f72 2061 6374 7561 7469 6f6e 206f 6620  or actuation of 
-000137b0: 6a6f 696e 7473 2061 6363 6f72 6469 6e67  joints according
-000137c0: 2074 6f20 6120 4c6f 6164 546f 7271 7565   to a LoadTorque
-000137d0: 5665 6374 6f72 2075 7365 7246 756e 6374  Vector userFunct
-000137e0: 696f 6e2c 2073 6565 2073 6572 6961 6c52  ion, see serialR
-000137f0: 6f62 6f74 5465 7374 2e70 7920 6173 2061  obotTest.py as a
-00013800: 6e20 6578 616d 706c 653b 2063 616e 2062  n example; can b
-00013810: 6520 656d 7074 7920 6c69 7374 0d0a 2320  e empty list..# 
-00013820: 2320 2020 6261 7365 4d61 726b 6572 3a20  #   baseMarker: 
-00013830: 6120 7269 6769 6420 626f 6479 206d 6172  a rigid body mar
-00013840: 6b65 722c 2061 7420 7768 6963 6820 7468  ker, at which th
-00013850: 6520 726f 626f 7420 7769 6c6c 2062 6520  e robot will be 
-00013860: 706c 6163 6564 2028 7573 7561 6c6c 7920  placed (usually 
-00013870: 6772 6f75 6e64 293b 206e 6f74 6520 7468  ground); note th
-00013880: 6174 2074 6865 206c 6f63 616c 2063 6f6f  at the local coo
-00013890: 7264 696e 6174 6520 7379 7374 656d 206f  rdinate system o
-000138a0: 6620 7468 6520 6261 7365 206d 7573 7420  f the base must 
-000138b0: 6265 2069 6e20 6163 636f 7264 616e 6365  be in accordance
-000138c0: 2077 6974 6820 7468 6520 4448 2d70 6172   with the DH-par
-000138d0: 616d 6574 6572 732c 2069 2e65 2e2c 2074  ameters, i.e., t
-000138e0: 6865 207a 2d61 7869 7320 6d75 7374 2062  he z-axis must b
-000138f0: 6520 7468 6520 6669 7273 7420 726f 7461  e the first rota
-00013900: 7469 6f6e 2061 7869 732e 2046 6f72 2063  tion axis. For c
-00013910: 6f72 7265 6374 696f 6e20 6f66 2074 6865  orrection of the
-00013920: 2062 6173 6520 636f 6f72 6469 6e61 7465   base coordinate
-00013930: 2073 7973 7465 6d2c 2075 7365 2072 6f74   system, use rot
-00013940: 6174 696f 6e4d 6172 6b65 7242 6173 650d  ationMarkerBase.
-00013950: 0a23 2023 2020 2072 6f74 6174 696f 6e4d  .# #   rotationM
-00013960: 6172 6b65 7242 6173 653a 2075 7365 6420  arkerBase: used 
-00013970: 696e 2047 656e 6572 6963 206a 6f69 6e74  in Generic joint
-00013980: 2062 6574 7765 656e 2066 6972 7374 206a   between first j
-00013990: 6f69 6e74 2061 6e64 2062 6173 653b 206e  oint and base; n
-000139a0: 6f74 652c 2074 6861 7420 666f 7220 6d6f  ote, that for mo
-000139b0: 7669 6e67 2062 6173 652c 2074 6865 2073  ving base, the s
-000139c0: 7461 7469 6320 636f 6d70 656e 7361 7469  tatic compensati
-000139d0: 6f6e 2064 6f65 7320 6e6f 7420 776f 726b  on does not work
-000139e0: 2028 6261 7365 2072 6f74 6174 696f 6e20   (base rotation 
-000139f0: 6d75 7374 2062 6520 7570 6461 7465 6429  must be updated)
-00013a00: 0d0a 2320 2320 2020 7368 6f77 434f 4d3a  ..# #   showCOM:
-00013a10: 2061 2073 6361 6c61 7220 642c 2077 6869   a scalar d, whi
-00013a20: 6368 2069 6620 6e6f 6e7a 6572 6f20 6974  ch if nonzero it
-00013a30: 2063 6175 7365 7320 746f 2064 7261 7720   causes to draw 
-00013a40: 7468 6520 6365 6e74 6572 206f 6620 6d61  the center of ma
-00013a50: 7373 2028 434f 4d29 2061 7320 7265 6374  ss (COM) as rect
-00013a60: 616e 6775 6c61 7220 626c 6f63 6b20 7769  angular block wi
-00013a70: 7468 2073 697a 6520 5b64 2c64 2c64 5d0d  th size [d,d,d].
-00013a80: 0a23 2023 2020 2062 6f64 7941 6c70 6861  .# #   bodyAlpha
-00013a90: 3a20 6120 666c 6f61 7420 7661 6c75 6520  : a float value 
-00013aa0: 696e 2072 616e 6765 205b 302e 2e31 5d2c  in range [0..1],
-00013ab0: 2061 6464 7320 7472 616e 7370 6172 656e   adds transparen
-00013ac0: 6379 2074 6f20 6c69 6e6b 7320 6966 2076  cy to links if v
-00013ad0: 616c 7565 203c 2031 0d0a 2320 2320 2020  alue < 1..# #   
-00013ae0: 746f 6f6c 4772 6170 6869 6373 5369 7a65  toolGraphicsSize
-00013af0: 3a20 6c69 7374 206f 6620 3320 666c 6f61  : list of 3 floa
-00013b00: 7473 205b 7378 2c73 792c 737a 5d2c 2067  ts [sx,sy,sz], g
-00013b10: 6976 696e 6720 7468 6520 7369 7a65 206f  iving the size o
-00013b20: 6620 7468 6520 746f 6f6c 2066 6f72 2067  f the tool for g
-00013b30: 7261 7068 6963 7320 7265 7072 6573 656e  raphics represen
-00013b40: 7461 7469 6f6e 3b20 7365 7420 7378 3d30  tation; set sx=0
-00013b50: 2074 6f20 6469 7361 626c 6520 746f 6f6c   to disable tool
-00013b60: 2064 7261 7769 6e67 206f 7220 646f 206e   drawing or do n
-00013b70: 6f74 2070 726f 7669 6465 2074 6869 7320  ot provide this 
-00013b80: 6f70 7469 6f6e 616c 2076 6172 6961 626c  optional variabl
-00013b90: 650d 0a23 2023 2020 2064 7261 774c 696e  e..# #   drawLin
-00013ba0: 6b53 697a 653a 2064 7261 7720 7061 7261  kSize: draw para
-00013bb0: 6d65 7465 7273 2066 6f72 206c 696e 6b73  meters for links
-00013bc0: 2061 7320 6c69 7374 206f 6620 3320 666c   as list of 3 fl
-00013bd0: 6f61 7473 205b 722c 772c 305d 2c20 723d  oats [r,w,0], r=
-00013be0: 7261 6469 7573 206f 6620 6a6f 696e 742c  radius of joint,
-00013bf0: 2077 3d72 6164 6975 7320 6f66 206c 696e   w=radius of lin
-00013c00: 6b2c 2073 6574 2072 3d30 2074 6f20 6469  k, set r=0 to di
-00013c10: 7361 626c 6520 6c69 6e6b 2064 7261 7769  sable link drawi
-00013c20: 6e67 0d0a 2320 2320 2020 726f 7461 7469  ng..# #   rotati
-00013c30: 6f6e 4d61 726b 6572 4261 7365 3a20 6164  onMarkerBase: ad
-00013c40: 6420 6120 6e75 6d70 7920 3378 3320 6d61  d a numpy 3x3 ma
-00013c50: 7472 6978 2066 6f72 2072 6f74 6174 696f  trix for rotatio
-00013c60: 6e20 6f66 2074 6865 2062 6173 652c 2069  n of the base, i
-00013c70: 6e20 6f72 6465 7220 7468 6174 2074 6865  n order that the
-00013c80: 2072 6f62 6f74 2063 616e 2062 6520 6174   robot can be at
-00013c90: 7461 6368 6564 2074 6f20 616e 7920 726f  tached to any ro
-00013ca0: 7461 7465 6420 6261 7365 206d 6172 6b65  tated base marke
-00013cb0: 723b 2074 6865 2072 6f74 6174 696f 6e4d  r; the rotationM
-00013cc0: 6172 6b65 7242 6173 6520 6973 2061 6363  arkerBase is acc
-00013cd0: 6f72 6469 6e67 2074 6f20 7468 6520 6465  ording to the de
-00013ce0: 6669 6e69 7469 6f6e 2069 6e20 4765 6e65  finition in Gene
-00013cf0: 7269 634a 6f69 6e74 0d0a 2320 232a 2a6f  ricJoint..# #**o
-00013d00: 7574 7075 743a 2074 6865 2066 756e 6374  utput: the funct
-00013d10: 696f 6e20 7265 7475 726e 7320 6120 6469  ion returns a di
-00013d20: 6374 696f 6e61 7279 2063 6f6e 7461 696e  ctionary contain
-00013d30: 696e 6720 696e 666f 726d 6174 696f 6e20  ing information 
-00013d40: 6f6e 206e 6f64 6573 2c20 626f 6469 6573  on nodes, bodies
-00013d50: 2c20 6a6f 696e 7473 2c20 6d61 726b 6572  , joints, marker
-00013d60: 732c 2074 6f72 7175 6573 2c20 666f 7220  s, torques, for 
-00013d70: 6576 6572 7920 6a6f 696e 740d 0a23 2064  every joint..# d
-00013d80: 6566 2053 6572 6961 6c52 6f62 6f74 324d  ef SerialRobot2M
-00013d90: 4253 286d 6273 2c20 726f 626f 742c 206a  BS(mbs, robot, j
-00013da0: 6f69 6e74 4c6f 6164 5573 6572 4675 6e63  ointLoadUserFunc
-00013db0: 7469 6f6e 4c69 7374 2c20 6261 7365 4d61  tionList, baseMa
-00013dc0: 726b 6572 2c20 2a61 7267 732c 202a 2a6b  rker, *args, **k
-00013dd0: 7761 7267 7329 3a0d 0a23 2020 2020 2067  wargs):..#     g
-00013de0: 6c6f 6261 6c20 7365 7269 616c 526f 626f  lobal serialRobo
-00013df0: 7432 4d42 5377 6172 6e65 640d 0a23 2020  t2MBSwarned..#  
-00013e00: 2020 2069 6620 6e6f 7420 7365 7269 616c     if not serial
-00013e10: 526f 626f 7432 4d42 5377 6172 6e65 643a  Robot2MBSwarned:
-00013e20: 0d0a 2320 2020 2020 2020 2020 7365 7269  ..#         seri
-00013e30: 616c 526f 626f 7432 4d42 5377 6172 6e65  alRobot2MBSwarne
-00013e40: 6420 3d20 5472 7565 0d0a 2320 2020 2020  d = True..#     
-00013e50: 2020 2020 7072 696e 7428 2766 756e 6374      print('funct
-00013e60: 696f 6e20 5365 7269 616c 526f 626f 7432  ion SerialRobot2
-00013e70: 4d42 5328 2e2e 2e29 2069 7320 6465 7072  MBS(...) is depr
-00013e80: 6563 6174 6564 2c20 7573 6520 526f 626f  ecated, use Robo
-00013e90: 742e 4372 6561 7465 5265 6475 6e64 616e  t.CreateRedundan
-00013ea0: 7443 6f6f 7264 696e 6174 654d 4253 282e  tCoordinateMBS(.
-00013eb0: 2e2e 2920 6f66 2063 6c61 7373 2052 6f62  ..) of class Rob
-00013ec0: 6f74 2069 6e73 7465 6164 2729 0d0a 2320  ot instead')..# 
-00013ed0: 2020 2020 2362 7569 6c64 2072 6f62 6f74      #build robot
-00013ee0: 206d 6f64 656c 3a0d 0a23 2020 2020 206e   model:..#     n
-00013ef0: 6f64 654c 6973 7420 3d20 5b5d 2020 2020  odeList = []    
-00013f00: 2020 2020 2020 2023 6e6f 6465 206e 756d         #node num
-00013f10: 6265 7220 6f72 2072 6967 6964 206e 6f64  ber or rigid nod
-00013f20: 6520 666f 7220 6c69 6e6b 0d0a 2320 2020  e for link..#   
-00013f30: 2020 626f 6479 4c69 7374 203d 205b 5d20    bodyList = [] 
-00013f40: 2020 2020 2020 2020 2020 2362 6f64 7920            #body 
-00013f50: 6e75 6d62 6572 206f 7220 7269 6769 6420  number or rigid 
-00013f60: 626f 6479 2066 6f72 206c 696e 6b0d 0a23  body for link..#
-00013f70: 2020 2020 206a 6f69 6e74 4c69 7374 203d       jointList =
-00013f80: 205b 5d20 2020 2020 2020 2020 2023 6a6f   []          #jo
-00013f90: 696e 7420 7768 6963 6820 6c69 6e6b 7320  int which links 
-00013fa0: 746f 2070 7265 7669 6f75 7320 6c69 6e6b  to previous link
-00013fb0: 206f 7220 6261 7365 0d0a 2320 2020 2020   or base..#     
-00013fc0: 6d61 726b 6572 4c69 7374 3020 3d20 5b5d  markerList0 = []
-00013fd0: 2023 636f 6e74 6169 6e73 206e 206d 6172   #contains n mar
-00013fe0: 6b65 7220 6e75 6d62 6572 7320 7065 7220  ker numbers per 
-00013ff0: 6c69 6e6b 2077 6869 6368 2063 6f6e 6e65  link which conne
-00014000: 6374 2074 6f20 7072 6576 696f 7573 2062  ct to previous b
-00014010: 6f64 790d 0a23 2020 2020 206d 6172 6b65  ody..#     marke
-00014020: 724c 6973 7431 203d 205b 5d20 2363 6f6e  rList1 = [] #con
-00014030: 7461 696e 7320 6e20 6d61 726b 6572 206e  tains n marker n
-00014040: 756d 6265 7273 2070 6572 206c 696e 6b20  umbers per link 
-00014050: 7768 6963 6820 636f 6e6e 6563 7420 746f  which connect to
-00014060: 206e 6578 7420 626f 6479 0d0a 2320 2020   next body..#   
-00014070: 2020 6a6f 696e 7454 6f72 7175 6530 4c69    jointTorque0Li
-00014080: 7374 203d 205b 5d20 2023 6c6f 6164 206e  st = []  #load n
-00014090: 756d 6265 7220 6f66 206a 6f69 6e74 2074  umber of joint t
-000140a0: 6f72 7175 6520 6174 2070 7265 7669 6f75  orque at previou
-000140b0: 7320 6c69 6e6b 2028 6e65 6761 7469 7665  s link (negative
-000140c0: 290d 0a23 2020 2020 206a 6f69 6e74 546f  )..#     jointTo
-000140d0: 7271 7565 314c 6973 7420 3d20 5b5d 2020  rque1List = []  
-000140e0: 236c 6f61 6420 6e75 6d62 6572 206f 6620  #load number of 
-000140f0: 6a6f 696e 7420 746f 7271 7565 2061 7420  joint torque at 
-00014100: 6e65 7874 206c 696e 6b20 2870 6f73 6974  next link (posit
-00014110: 6976 6529 0d0a 2020 2020 0d0a 2320 2020  ive)..    ..#   
-00014120: 2020 5463 7572 7265 6e74 203d 2072 6f62    Tcurrent = rob
-00014130: 6f74 5b27 6261 7365 275d 5b27 4854 275d  ot['base']['HT']
-00014140: 0d0a 2020 2020 0d0a 2320 2020 2020 6c61  ..    ..#     la
-00014150: 7374 4d61 726b 6572 203d 2062 6173 654d  stMarker = baseM
-00014160: 6172 6b65 720d 0a20 2020 200d 0a23 2020  arker..    ..#  
-00014170: 2020 2062 6f64 7941 6c70 6861 203d 2031     bodyAlpha = 1
-00014180: 2023 6465 6661 756c 7420 7661 6c75 653b   #default value;
-00014190: 206e 6f20 7472 616e 7370 6172 656e 6379   no transparency
-000141a0: 0d0a 2320 2020 2020 6966 2027 626f 6479  ..#     if 'body
-000141b0: 416c 7068 6127 2069 6e20 6b77 6172 6773  Alpha' in kwargs
-000141c0: 3a0d 0a23 2020 2020 2020 2020 2062 6f64  :..#         bod
-000141d0: 7941 6c70 6861 203d 206b 7761 7267 735b  yAlpha = kwargs[
-000141e0: 2762 6f64 7941 6c70 6861 275d 0d0a 0d0a  'bodyAlpha']....
-000141f0: 0d0a 2320 2020 2020 746f 6f6c 5369 7a65  ..#     toolSize
-00014200: 203d 205b 302e 3035 2c30 2e30 322c 302e   = [0.05,0.02,0.
-00014210: 3036 5d20 2364 6566 6175 6c74 2076 616c  06] #default val
-00014220: 7565 730d 0a23 2020 2020 2069 6620 2774  ues..#     if 't
-00014230: 6f6f 6c47 7261 7068 6963 7353 697a 6527  oolGraphicsSize'
-00014240: 2069 6e20 6b77 6172 6773 3a0d 0a23 2020   in kwargs:..#  
-00014250: 2020 2020 2020 2074 6f6f 6c53 697a 6520         toolSize 
-00014260: 3d20 6b77 6172 6773 5b27 746f 6f6c 4772  = kwargs['toolGr
-00014270: 6170 6869 6373 5369 7a65 275d 0d0a 0d0a  aphicsSize']....
-00014280: 2020 2020 2020 2020 0d0a 2320 2020 2020          ..#     
-00014290: 6472 6177 4c69 6e6b 5369 7a65 3d5b 302e  drawLinkSize=[0.
-000142a0: 3036 2c30 2e30 355d 2023 6465 6661 756c  06,0.05] #defaul
-000142b0: 7420 7661 6c75 6573 0d0a 2320 2020 2020  t values..#     
-000142c0: 6966 2027 6472 6177 4c69 6e6b 5369 7a65  if 'drawLinkSize
-000142d0: 2720 696e 206b 7761 7267 733a 0d0a 2320  ' in kwargs:..# 
-000142e0: 2020 2020 2020 2020 6472 6177 4c69 6e6b          drawLink
-000142f0: 5369 7a65 203d 206b 7761 7267 735b 2764  Size = kwargs['d
-00014300: 7261 774c 696e 6b53 697a 6527 5d0d 0a0d  rawLinkSize']...
-00014310: 0a23 2020 2020 2023 6372 6561 7465 2072  .#     #create r
-00014320: 6f62 6f74 206e 6f64 6573 2061 6e64 2062  obot nodes and b
-00014330: 6f64 6965 733a 0d0a 2320 2020 2020 666f  odies:..#     fo
-00014340: 7220 6920 696e 2072 616e 6765 286c 656e  r i in range(len
-00014350: 2872 6f62 6f74 5b27 6c69 6e6b 7327 5d29  (robot['links'])
-00014360: 293a 0d0a 2320 2020 2020 2020 2020 6c69  ):..#         li
-00014370: 6e6b 203d 2072 6f62 6f74 5b27 6c69 6e6b  nk = robot['link
-00014380: 7327 5d5b 695d 0d0a 2020 2020 0d0a 2320  s'][i]..    ..# 
-00014390: 2020 2020 2020 2020 4448 7061 7261 6d20          DHparam 
-000143a0: 3d20 6e70 2e7a 6572 6f73 2834 290d 0a23  = np.zeros(4)..#
-000143b0: 2020 2020 2020 2020 2044 4870 6172 616d           DHparam
-000143c0: 5b30 3a34 5d20 3d20 6c69 6e6b 5b27 7374  [0:4] = link['st
-000143d0: 6444 4827 5d5b 303a 345d 2023 636f 7079  dDH'][0:4] #copy
-000143e0: 2063 6f6e 7465 6e74 210d 0a23 2020 2020   content!..#    
-000143f0: 2020 2020 2069 6620 726f 626f 745b 276a       if robot['j
-00014400: 6f69 6e74 5479 7065 275d 5b69 5d20 3d3d  ointType'][i] ==
-00014410: 2031 3a20 2331 3d3d 7265 766f 6c75 7465   1: #1==revolute
-00014420: 2c20 303d 3d70 7269 736d 6174 6963 0d0a  , 0==prismatic..
-00014430: 2320 2020 2020 2020 2020 2020 2020 4448  #             DH
-00014440: 7061 7261 6d5b 305d 203d 2072 6f62 6f74  param[0] = robot
-00014450: 5b27 7265 6665 7265 6e63 6543 6f6e 6669  ['referenceConfi
-00014460: 6775 7261 7469 6f6e 275d 5b69 5d20 2361  guration'][i] #a
-00014470: 6464 2072 6566 6572 656e 6365 2061 6e67  dd reference ang
-00014480: 6c65 0d0a 2320 2020 2020 2020 2020 656c  le..#         el
-00014490: 7365 3a0d 0a23 2020 2020 2020 2020 2020  se:..#          
-000144a0: 2020 2044 4870 6172 616d 5b31 5d20 3d20     DHparam[1] = 
-000144b0: 726f 626f 745b 2772 6566 6572 656e 6365  robot['reference
-000144c0: 436f 6e66 6967 7572 6174 696f 6e27 5d5b  Configuration'][
-000144d0: 695d 2023 6164 6420 7265 6665 7265 6e63  i] #add referenc
-000144e0: 6520 6469 7370 6c61 6365 6d65 6e74 0d0a  e displacement..
-000144f0: 2020 2020 2020 2020 2020 2020 0d0a 2320              ..# 
-00014500: 2020 2020 2020 2020 5430 3120 3d20 5374          T01 = St
-00014510: 6444 4832 4854 2844 4870 6172 616d 2920  dDH2HT(DHparam) 
-00014520: 2374 7261 6e73 666f 726d 6174 696f 6e20  #transformation 
-00014530: 6672 6f6d 206c 6173 7420 6c69 6e6b 2074  from last link t
-00014540: 6f20 7468 6973 206c 696e 6b3b 2069 7420  o this link; it 
-00014550: 6465 6669 6e65 7320 7468 6520 6f72 6965  defines the orie
-00014560: 6e74 6174 696f 6e20 6f66 2074 6865 2062  ntation of the b
-00014570: 6f64 790d 0a20 2020 200d 0a23 2020 2020  ody..    ..#    
-00014580: 2020 2020 2054 6375 7272 656e 7420 3d20       Tcurrent = 
-00014590: 5463 7572 7265 6e74 2040 2054 3031 0d0a  Tcurrent @ T01..
-000145a0: 2020 2020 2020 2020 0d0a 2320 2020 2020          ..#     
-000145b0: 2020 2020 2374 6865 206e 6578 7420 2864      #the next (d
-000145c0: 6973 7461 6c29 206a 6f69 6e74 2028 6a6f  istal) joint (jo
-000145d0: 696e 7431 2920 6973 2061 6c69 676e 6564  int1) is aligned
-000145e0: 2077 6974 6820 7468 6520 7a2d 6178 6973   with the z-axis
-000145f0: 206f 6620 7468 6520 626f 6479 2773 2066   of the body's f
-00014600: 7261 6d65 3a0d 0a23 2020 2020 2020 2020  rame:..#        
-00014610: 2070 3120 3d20 6e70 2e61 7272 6179 285b   p1 = np.array([
-00014620: 302c 302c 302e 5d29 0d0a 2320 2020 2020  0,0,0.])..#     
-00014630: 2020 2020 6178 6973 3120 3d20 6e70 2e61      axis1 = np.a
-00014640: 7272 6179 285b 302c 302c 312e 5d29 0d0a  rray([0,0,1.])..
-00014650: 2020 2020 0d0a 2320 2020 2020 2020 2020      ..#         
-00014660: 2374 6865 2070 7265 7669 6f75 7320 6a6f  #the previous jo
-00014670: 696e 7420 286a 6f69 6e74 3029 2061 7869  int (joint0) axi
-00014680: 7320 6973 2072 6f74 6174 6564 2062 6163  s is rotated bac
-00014690: 6b20 7769 7468 2061 6c70 6861 2061 6e64  k with alpha and
-000146a0: 2074 7261 6e73 6c61 7465 6420 616c 6f6e   translated alon
-000146b0: 6720 2d78 2077 6974 6820 610d 0a23 2020  g -x with a..#  
-000146c0: 2020 2020 2020 2064 203d 206c 696e 6b5b         d = link[
-000146d0: 2773 7464 4448 275d 5b31 5d0d 0a23 2020  'stdDH'][1]..#  
-000146e0: 2020 2020 2020 2061 203d 206c 696e 6b5b         a = link[
-000146f0: 2773 7464 4448 275d 5b32 5d0d 0a23 2020  'stdDH'][2]..#  
-00014700: 2020 2020 2020 2061 6c70 6861 203d 206c         alpha = l
-00014710: 696e 6b5b 2773 7464 4448 275d 5b33 5d0d  ink['stdDH'][3].
-00014720: 0a23 2020 2020 2020 2020 2041 3054 203d  .#         A0T =
-00014730: 2065 7262 2e52 6f74 6174 696f 6e4d 6174   erb.RotationMat
-00014740: 7269 7858 282d 616c 7068 6129 2023 726f  rixX(-alpha) #ro
-00014750: 7461 7469 6f6e 206d 6174 7269 7820 7472  tation matrix tr
-00014760: 616e 7366 6f72 6d73 2062 6163 6b20 746f  ansforms back to
-00014770: 206a 6f69 6e74 300d 0a23 2020 2020 2020   joint0..#      
-00014780: 2020 2070 3020 3d20 4130 5420 4020 6e70     p0 = A0T @ np
-00014790: 2e61 7272 6179 285b 2d61 2c30 2c2d 645d  .array([-a,0,-d]
-000147a0: 290d 0a23 2020 2020 2020 2020 2061 7869  )..#         axi
-000147b0: 7330 203d 2041 3054 2040 206e 702e 6172  s0 = A0T @ np.ar
-000147c0: 7261 7928 5b30 2c30 2c31 2e5d 290d 0a20  ray([0,0,1.]).. 
-000147d0: 2020 2020 2020 200d 0a23 2020 2020 2020         ..#      
-000147e0: 2020 2023 7269 6769 6420 626f 6479 2070     #rigid body p
-000147f0: 6172 616d 6574 6572 733a 0d0a 2320 2020  arameters:..#   
-00014800: 2020 2020 2020 636f 6d20 3d20 6c69 6e6b        com = link
-00014810: 5b27 434f 4d27 5d0d 0a23 2020 2020 2020  ['COM']..#      
-00014820: 2020 2023 2063 6f6d 3420 3d20 6e70 2e61     # com4 = np.a
-00014830: 7272 6179 2863 6f6d 2b5b 315d 290d 0a20  rray(com+[1]).. 
-00014840: 2020 200d 0a23 2020 2020 2020 2020 2069     ..#         i
-00014850: 6e65 7274 6961 4c69 6e6b 203d 2065 7262  nertiaLink = erb
-00014860: 2e52 6967 6964 426f 6479 496e 6572 7469  .RigidBodyInerti
-00014870: 6128 6d61 7373 3d6c 696e 6b5b 276d 6173  a(mass=link['mas
-00014880: 7327 5d2c 200d 0a23 2020 2020 2020 2020  s'], ..#        
-00014890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000148a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000148b0: 696e 6572 7469 6154 656e 736f 723d 6c69  inertiaTensor=li
-000148c0: 6e6b 5b27 696e 6572 7469 6127 5d29 0d0a  nk['inertia'])..
-000148d0: 2320 2020 2020 2020 2020 696e 6572 7469  #         inerti
-000148e0: 614c 696e 6b20 3d20 696e 6572 7469 614c  aLink = inertiaL
-000148f0: 696e 6b2e 5472 616e 736c 6174 6564 2863  ink.Translated(c
-00014900: 6f6d 2923 6e65 6564 7320 746f 2062 6520  om)#needs to be 
-00014910: 7265 636f 6d70 7574 6564 2c20 6265 6361  recomputed, beca
-00014920: 7573 6520 696e 6572 7469 6120 6973 2077  use inertia is w
-00014930: 2e72 2e74 2e20 434f 4d0d 0a20 2020 2020  .r.t. COM..     
-00014940: 2020 200d 0a23 2020 2020 2020 2020 2063     ..#         c
-00014950: 6f6c 6f72 203d 206c 6973 7428 6e70 2e61  olor = list(np.a
-00014960: 7272 6179 2865 6764 2e63 6f6c 6f72 346c  rray(egd.color4l
-00014970: 6973 745b 695d 2929 0d0a 2320 2020 2020  ist[i]))..#     
-00014980: 2020 2020 636f 6c6f 725b 335d 203d 2062      color[3] = b
-00014990: 6f64 7941 6c70 6861 2023 7472 616e 7370  odyAlpha #transp
-000149a0: 6172 656e 6379 206f 6620 626f 6469 6573  arency of bodies
-000149b0: 0d0a 2320 2020 2020 2020 2020 6772 6170  ..#         grap
-000149c0: 6869 6373 4c69 7374 203d 205b 5d0d 0a0d  hicsList = []...
-000149d0: 0a23 2020 2020 2020 2020 2023 6472 6177  .#         #draw
-000149e0: 2043 4f4d 3a0d 0a23 2020 2020 2020 2020   COM:..#        
-000149f0: 2069 6620 2773 686f 7743 4f4d 2720 696e   if 'showCOM' in
-00014a00: 2061 7267 733a 0d0a 2320 2020 2020 2020   args:..#       
-00014a10: 2020 2020 2020 6464 3d61 7267 735b 2773        dd=args['s
-00014a20: 686f 7743 4f4d 275d 0d0a 2320 2020 2020  howCOM']..#     
-00014a30: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
-00014a40: 4c69 7374 202b 3d20 5b65 6764 2e47 7261  List += [egd.Gra
-00014a50: 7068 6963 7344 6174 614f 7274 686f 4375  phicsDataOrthoCu
-00014a60: 6265 506f 696e 7428 636f 6d2c 205b 6464  bePoint(com, [dd
-00014a70: 2c64 642c 6464 5d2c 2065 6764 2e63 6f6c  ,dd,dd], egd.col
-00014a80: 6f72 346c 6973 745b 695d 295d 0d0a 0d0a  or4list[i])]....
-00014a90: 2320 2020 2020 2020 2020 2364 7261 7720  #         #draw 
-00014aa0: 6c69 6e6b 733a 0d0a 2320 2020 2020 2020  links:..#       
-00014ab0: 2020 7220 3d20 6472 6177 4c69 6e6b 5369    r = drawLinkSi
-00014ac0: 7a65 5b30 5d0d 0a23 2020 2020 2020 2020  ze[0]..#        
-00014ad0: 2077 203d 2064 7261 774c 696e 6b53 697a   w = drawLinkSiz
-00014ae0: 655b 315d 0d0a 2320 2020 2020 2020 2020  e[1]..#         
-00014af0: 6966 2072 2021 3d20 303a 0d0a 2320 2020  if r != 0:..#   
-00014b00: 2020 2020 2020 2020 2020 6830 203d 2077            h0 = w
-00014b10: 2020 2023 6865 6967 6874 206f 6620 6861     #height of ha
-00014b20: 6c66 2061 7869 732c 2066 6972 7374 206a  lf axis, first j
-00014b30: 6f69 6e74 0d0a 2320 2020 2020 2020 2020  oint..#         
-00014b40: 2020 2020 6831 203d 2077 2020 2023 6865      h1 = w   #he
-00014b50: 6967 6874 206f 6620 6861 6c66 2061 7869  ight of half axi
-00014b60: 732c 2073 6563 6f6e 6420 6a6f 696e 740d  s, second joint.
-00014b70: 0a20 2020 2020 2020 2020 2020 200d 0a23  .            ..#
-00014b80: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00014b90: 6920 3d3d 2030 3a20 2364 7261 7720 6675  i == 0: #draw fu
-00014ba0: 6c6c 2063 796c 696e 6465 7220 666f 7220  ll cylinder for 
-00014bb0: 6669 7273 7420 6a6f 696e 740d 0a23 2020  first joint..#  
-00014bc0: 2020 2020 2020 2020 2020 2020 2020 2068                 h
-00014bd0: 3020 3d20 772a 320d 0a20 2020 2020 2020  0 = w*2..       
-00014be0: 2020 2020 200d 0a23 2020 2020 2020 2020       ..#        
-00014bf0: 2020 2020 2067 7261 7068 6963 734c 6973       graphicsLis
-00014c00: 7420 2b3d 205b 6567 642e 4772 6170 6869  t += [egd.Graphi
-00014c10: 6373 4461 7461 4379 6c69 6e64 6572 2870  csDataCylinder(p
-00014c20: 4178 6973 3d70 302c 2076 4178 6973 3d2d  Axis=p0, vAxis=-
-00014c30: 6830 2a61 7869 7330 2c20 0d0a 2320 2020  h0*axis0, ..#   
-00014c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c60: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00014c70: 6164 6975 733d 722c 2063 6f6c 6f72 3d63  adius=r, color=c
-00014c80: 6f6c 6f72 295d 0d0a 2320 2020 2020 2020  olor)]..#       
-00014c90: 2020 2020 2020 6772 6170 6869 6373 4c69        graphicsLi
-00014ca0: 7374 202b 3d20 5b65 6764 2e47 7261 7068  st += [egd.Graph
-00014cb0: 6963 7344 6174 6143 796c 696e 6465 7228  icsDataCylinder(
-00014cc0: 7041 7869 733d 7031 2c20 7641 7869 733d  pAxis=p1, vAxis=
-00014cd0: 2068 312a 6178 6973 312c 200d 0a23 2020   h1*axis1, ..#  
-00014ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b8c0: 2020 2020 2020 2029 290a 2020 2020 2020         )).      
+0000b8d0: 2020 2020 2020 2020 2020 2020 2020 0a20                . 
+0000b8e0: 2020 2020 2020 2020 2020 2073 7072 696e             sprin
+0000b8f0: 6744 616d 7065 724c 6973 7420 2b3d 205b  gDamperList += [
+0000b900: 6f62 6a65 6374 5344 5d0a 2020 2020 2020  objectSD].      
+0000b910: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+0000b920: 2020 2023 6d61 726b 6572 4c69 7374 3020     #markerList0 
+0000b930: 2b3d 205b 6d6c 696e 6b31 6e65 7874 5d0a  += [mlink1next].
+0000b940: 2020 2020 2020 2020 2020 2020 2320 6966              # if
+0000b950: 2069 203c 206c 656e 2873 656c 662e 6c69   i < len(self.li
+0000b960: 6e6b 7329 2d31 3a20 236e 6f74 2073 7569  nks)-1: #not sui
+0000b970: 7461 626c 6520 666f 7220 6b69 6e65 6d61  table for kinema
+0000b980: 7469 6354 7265 650a 2020 2020 2020 2020  ticTree.        
+0000b990: 2020 2020 2320 2020 2020 6c61 7374 4d61      #     lastMa
+0000b9a0: 726b 6572 526f 7461 7469 6f6e 203d 2065  rkerRotation = e
+0000b9b0: 7262 2e48 5432 726f 7461 7469 6f6e 4d61  rb.HT2rotationMa
+0000b9c0: 7472 6978 2873 656c 662e 6c69 6e6b 735b  trix(self.links[
+0000b9d0: 692b 315d 2e70 7265 4854 2920 236e 6565  i+1].preHT) #nee
+0000b9e0: 6465 6420 666f 7220 6d6f 6469 6669 6564  ded for modified
+0000b9f0: 2044 4820 7061 7261 6d65 7465 7273 0a20   DH parameters. 
+0000ba00: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+0000ba10: 2020 2020 2020 2020 2365 6e64 206c 6f6f          #end loo
+0000ba20: 7020 6f76 6572 206c 696e 6b73 0a20 2020  p over links.   
+0000ba30: 2020 2020 2020 2020 2023 2b2b 2b2b 2b2b           #++++++
+0000ba40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000ba50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000ba60: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000ba70: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000ba80: 2b2b 0a0a 2020 2020 2020 2020 2372 6574  ++..        #ret
+0000ba90: 7572 6e20 736f 6d65 206e 6565 6465 6420  urn some needed 
+0000baa0: 7661 7269 6162 6c65 7320 666f 7220 6675  variables for fu
+0000bab0: 7274 6865 7220 7573 6520 2020 2020 2020  rther use       
+0000bac0: 200a 2020 2020 2020 2020 6420 3d20 7b27   .        d = {'
+0000bad0: 6e6f 6465 4c69 7374 273a 206e 6f64 654c  nodeList': nodeL
+0000bae0: 6973 742c 2762 6f64 794c 6973 7427 3a20  ist,'bodyList': 
+0000baf0: 626f 6479 4c69 7374 2c27 6a6f 696e 744c  bodyList,'jointL
+0000bb00: 6973 7427 3a20 6a6f 696e 744c 6973 742c  ist': jointList,
+0000bb10: 0a20 2020 2020 2020 2020 2020 2020 276d  .             'm
+0000bb20: 6172 6b65 724c 6973 7430 273a 206d 6172  arkerList0': mar
+0000bb30: 6b65 724c 6973 7430 2c0a 2020 2020 2020  kerList0,.      
+0000bb40: 2020 2020 2020 2027 6d61 726b 6572 4c69         'markerLi
+0000bb50: 7374 3127 3a20 6d61 726b 6572 4c69 7374  st1': markerList
+0000bb60: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
+0000bb70: 2773 7072 696e 6744 616d 7065 724c 6973  'springDamperLis
+0000bb80: 7427 3a20 7370 7269 6e67 4461 6d70 6572  t': springDamper
+0000bb90: 4c69 7374 2c0a 2020 2020 2020 2020 2020  List,.          
+0000bba0: 2020 2027 6a6f 696e 7454 6f72 7175 6530     'jointTorque0
+0000bbb0: 4c69 7374 273a 206a 6f69 6e74 546f 7271  List': jointTorq
+0000bbc0: 7565 304c 6973 742c 0a20 2020 2020 2020  ue0List,.       
+0000bbd0: 2020 2020 2020 276a 6f69 6e74 546f 7271        'jointTorq
+0000bbe0: 7565 314c 6973 7427 3a20 6a6f 696e 7454  ue1List': jointT
+0000bbf0: 6f72 7175 6531 4c69 7374 2c0a 2020 2020  orque1List,.    
+0000bc00: 2020 2020 2020 2020 2027 756e 6974 546f           'unitTo
+0000bc10: 7271 7565 304c 6973 7427 3a20 756e 6974  rque0List': unit
+0000bc20: 546f 7271 7565 304c 6973 742c 0a20 2020  Torque0List,.   
+0000bc30: 2020 2020 2020 2020 2020 2775 6e69 7454            'unitT
+0000bc40: 6f72 7175 6531 4c69 7374 273a 2075 6e69  orque1List': uni
+0000bc50: 7454 6f72 7175 6531 4c69 7374 2c0a 2020  tTorque1List,.  
+0000bc60: 2020 2020 2020 2020 2020 2027 6261 7365             'base
+0000bc70: 4f62 6a65 6374 273a 6261 7365 4f62 6a65  Object':baseObje
+0000bc80: 6374 7d0a 2020 2020 2020 2020 7265 7475  ct}.        retu
+0000bc90: 726e 2064 0a20 2020 200a 2020 2020 2020  rn d.    .      
+0000bca0: 2020 0a20 2020 200a 0a20 2020 2023 2525    .    ..    #%%
+0000bcb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bcc0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bcd0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bce0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bcf0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bd00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bd10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000bd20: 2b2b 2b2b 2b2b 2b2b 0a0a 2020 2020 232a  ++++++++..    #*
+0000bd30: 2a63 6c61 7373 4675 6e63 7469 6f6e 3a20  *classFunction: 
+0000bd40: 6578 706f 7274 206b 696e 656d 6174 6963  export kinematic
+0000bd50: 5472 6565 0a20 2020 2064 6566 2047 6574  Tree.    def Get
+0000bd60: 4b69 6e65 6d61 7469 6354 7265 6536 3628  KinematicTree66(
+0000bd70: 7365 6c66 293a 0a20 2020 2020 2020 2066  self):.        f
+0000bd80: 726f 6d20 6578 7564 796e 2e6b 696e 656d  rom exudyn.kinem
+0000bd90: 6174 6963 5472 6565 2069 6d70 6f72 7420  aticTree import 
+0000bda0: 4b69 6e65 6d61 7469 6354 7265 6536 362c  KinematicTree66,
+0000bdb0: 2049 6e65 7274 6961 3254 3636 0a20 2020   Inertia2T66.   
+0000bdc0: 2020 2020 200a 2020 2020 2020 2020 6a6f       .        jo
+0000bdd0: 696e 7454 7970 6573 203d 205b 5d0a 2020  intTypes = [].  
+0000bde0: 2020 2020 2020 7472 616e 7366 6f72 6d61        transforma
+0000bdf0: 7469 6f6e 7320 3d20 5b5d 0a20 2020 2020  tions = [].     
+0000be00: 2020 2069 6e65 7274 6961 7320 3d20 5b5d     inertias = []
+0000be10: 0a20 2020 2020 2020 206e 203d 206c 656e  .        n = len
+0000be20: 2873 656c 662e 6c69 6e6b 7329 0a20 2020  (self.links).   
+0000be30: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
+0000be40: 6e67 6528 6e29 3a0a 2020 2020 2020 2020  nge(n):.        
+0000be50: 2020 2020 6c69 6e6b 203d 2073 656c 662e      link = self.
+0000be60: 6c69 6e6b 735b 695d 0a20 2020 2020 2020  links[i].       
+0000be70: 2020 2020 206a 6f69 6e74 5479 7065 7320       jointTypes 
+0000be80: 2b3d 205b 6c69 6e6b 2e6a 6f69 6e74 5479  += [link.jointTy
+0000be90: 7065 5d0a 2020 2020 2020 2020 2020 2020  pe].            
+0000bea0: 0a20 2020 2020 2020 2020 2020 2070 7265  .            pre
+0000beb0: 4854 203d 206c 696e 6b2e 7072 6548 540a  HT = link.preHT.
+0000bec0: 2020 2020 2020 2020 2020 2020 416d 6174              Amat
+0000bed0: 203d 2065 7262 2e48 5432 726f 7461 7469   = erb.HT2rotati
+0000bee0: 6f6e 4d61 7472 6978 2870 7265 4854 2920  onMatrix(preHT) 
+0000bef0: 0a20 2020 2020 2020 2020 2020 2076 5665  .            vVe
+0000bf00: 6320 3d20 6572 622e 4854 3274 7261 6e73  c = erb.HT2trans
+0000bf10: 6c61 7469 6f6e 2870 7265 4854 290a 2020  lation(preHT).  
+0000bf20: 2020 2020 2020 2020 2020 583d 6572 622e            X=erb.
+0000bf30: 526f 7461 7469 6f6e 5472 616e 736c 6174  RotationTranslat
+0000bf40: 696f 6e32 5436 3649 6e76 6572 7365 2841  ion2T66Inverse(A
+0000bf50: 3d41 6d61 742c 2076 3d76 5665 6329 0a20  =Amat, v=vVec). 
+0000bf60: 2020 2020 2020 2020 2020 2069 6620 6e70             if np
+0000bf70: 2e6c 696e 616c 672e 6e6f 726d 286c 696e  .linalg.norm(lin
+0000bf80: 6b2e 6c6f 6361 6c48 5420 2d20 6572 622e  k.localHT - erb.
+0000bf90: 4854 3028 2929 203e 2031 652d 3135 3a0a  HT0()) > 1e-15:.
+0000bfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfb0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0000bfc0: 2827 4765 744b 696e 656d 6174 6963 5472  ('GetKinematicTr
+0000bfd0: 6565 3636 2829 3a20 6e6f 7420 696d 706c  ee66(): not impl
+0000bfe0: 656d 656e 7465 6420 666f 7220 6c69 6e6b  emented for link
+0000bff0: 7320 7769 7468 206c 6f63 616c 4854 2021  s with localHT !
+0000c000: 3d20 4854 3028 2927 290a 2020 2020 2020  = HT0()').      
+0000c010: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+0000c020: 2020 2074 7261 6e73 666f 726d 6174 696f     transformatio
+0000c030: 6e73 202b 3d20 5b58 5d20 2364 6566 696e  ns += [X] #defin
+0000c040: 6573 2074 7261 6e73 666f 726d 6174 696f  es transformatio
+0000c050: 6e20 746f 206a 6f69 6e74 2069 6e20 7061  n to joint in pa
+0000c060: 7265 6e74 206c 696e 6b0a 2020 2020 2020  rent link.      
+0000c070: 2020 2020 2020 4a20 3d20 6572 622e 5269        J = erb.Ri
+0000c080: 6769 6442 6f64 7949 6e65 7274 6961 286d  gidBodyInertia(m
+0000c090: 6173 733d 6c69 6e6b 2e6d 6173 732c 2069  ass=link.mass, i
+0000c0a0: 6e65 7274 6961 5465 6e73 6f72 3d6c 696e  nertiaTensor=lin
+0000c0b0: 6b2e 696e 6572 7469 6129 2023 6c69 6e6b  k.inertia) #link
+0000c0c0: 2e69 6e65 7274 6961 2061 726f 756e 6420  .inertia around 
+0000c0d0: 434f 4d0a 2020 2020 2020 2020 2020 2020  COM.            
+0000c0e0: 4a20 3d20 4a2e 5472 616e 736c 6174 6564  J = J.Translated
+0000c0f0: 286c 696e 6b2e 434f 4d29 0a20 2020 2020  (link.COM).     
+0000c100: 2020 2020 2020 2069 6e65 7274 6961 7320         inertias 
+0000c110: 2b3d 205b 496e 6572 7469 6132 5436 3628  += [Inertia2T66(
+0000c120: 4a29 5d0a 2020 2020 2020 2020 0a20 2020  J)].        .   
+0000c130: 2020 2020 204b 543d 4b69 6e65 6d61 7469       KT=Kinemati
+0000c140: 6354 7265 6536 3628 6c69 7374 4f66 4a6f  cTree66(listOfJo
+0000c150: 696e 7454 7970 6573 3d6a 6f69 6e74 5479  intTypes=jointTy
+0000c160: 7065 732c 200a 2020 2020 2020 2020 2020  pes, .          
+0000c170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c180: 206c 6973 744f 6654 7261 6e73 666f 726d   listOfTransform
+0000c190: 6174 696f 6e73 3d74 7261 6e73 666f 726d  ations=transform
+0000c1a0: 6174 696f 6e73 2c20 0a20 2020 2020 2020  ations, .       
+0000c1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1c0: 2020 2020 6c69 7374 4f66 496e 6572 7469      listOfInerti
+0000c1d0: 6173 3d69 6e65 7274 6961 732c 200a 2020  as=inertias, .  
+0000c1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1f0: 2020 2020 2020 2020 2067 7261 7669 7479           gravity
+0000c200: 3d73 656c 662e 6772 6176 6974 7929 0a20  =self.gravity). 
+0000c210: 2020 2020 2020 2072 6574 7572 6e20 4b54         return KT
+0000c220: 0a20 2020 200a 2020 2020 232a 2a63 6c61  .    .    #**cla
+0000c230: 7373 4675 6e63 7469 6f6e 3a20 6372 6561  ssFunction: crea
+0000c240: 7465 206c 696e 6b20 4772 6170 6869 6373  te link Graphics
+0000c250: 4461 7461 2028 6c69 7374 2920 666f 7220  Data (list) for 
+0000c260: 6c69 6e6b 2069 3b20 696e 7465 726e 616c  link i; internal
+0000c270: 6c79 2075 7365 6420 696e 2043 7265 6174  ly used in Creat
+0000c280: 6552 6564 756e 6461 6e74 436f 6f72 6469  eRedundantCoordi
+0000c290: 6e61 7465 4d42 5328 2e2e 2e29 3b20 6c69  nateMBS(...); li
+0000c2a0: 6e6b 5669 7375 616c 697a 6174 696f 6e20  nkVisualization 
+0000c2b0: 636f 6e74 6169 6e73 2076 6973 7561 6c69  contains visuali
+0000c2c0: 7a61 7469 6f6e 2064 6963 7420 6f66 206c  zation dict of l
+0000c2d0: 696e 6b0a 2020 2020 6465 6620 4765 744c  ink.    def GetL
+0000c2e0: 696e 6b47 7261 7068 6963 7344 6174 6128  inkGraphicsData(
+0000c2f0: 7365 6c66 2c20 692c 2070 302c 2070 312c  self, i, p0, p1,
+0000c300: 2061 7869 7330 2c20 6178 6973 312c 206c   axis0, axis1, l
+0000c310: 696e 6b56 6973 7561 6c69 7a61 7469 6f6e  inkVisualization
+0000c320: 293a 0a20 2020 2020 2020 200a 2020 2020  ):.        .    
+0000c330: 2020 2020 636f 6d20 3d20 7365 6c66 2e6c      com = self.l
+0000c340: 696e 6b73 5b69 5d2e 434f 4d0a 2020 2020  inks[i].COM.    
+0000c350: 2020 2020 6772 6170 6869 6373 4c69 7374      graphicsList
+0000c360: 203d 205b 5d0a 0a20 2020 2020 2020 2072   = []..        r
+0000c370: 203d 206c 696e 6b56 6973 7561 6c69 7a61   = linkVisualiza
+0000c380: 7469 6f6e 2e6a 6f69 6e74 5261 6469 7573  tion.jointRadius
+0000c390: 0a20 2020 2020 2020 2077 4a20 3d20 6c69  .        wJ = li
+0000c3a0: 6e6b 5669 7375 616c 697a 6174 696f 6e2e  nkVisualization.
+0000c3b0: 6a6f 696e 7457 6964 7468 0a20 2020 2020  jointWidth.     
+0000c3c0: 2020 2077 4c20 3d20 6c69 6e6b 5669 7375     wL = linkVisu
+0000c3d0: 616c 697a 6174 696f 6e2e 6c69 6e6b 5769  alization.linkWi
+0000c3e0: 6474 680a 2020 2020 2020 2020 636f 6c6f  dth.        colo
+0000c3f0: 7220 3d20 6c69 6e6b 5669 7375 616c 697a  r = linkVisualiz
+0000c400: 6174 696f 6e2e 6c69 6e6b 436f 6c6f 720a  ation.linkColor.
+0000c410: 0a20 2020 2020 2020 2023 6472 6177 2043  .        #draw C
+0000c420: 4f4d 3a0a 2020 2020 2020 2020 6966 206c  OM:.        if l
+0000c430: 696e 6b56 6973 7561 6c69 7a61 7469 6f6e  inkVisualization
+0000c440: 2e73 686f 7743 4f4d 3a0a 2020 2020 2020  .showCOM:.      
+0000c450: 2020 2020 2020 6464 203d 2072 2a30 2e32        dd = r*0.2
+0000c460: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
+0000c470: 6f72 434f 4d20 3d20 636f 7079 2863 6f6c  orCOM = copy(col
+0000c480: 6f72 290a 2020 2020 2020 2020 2020 2020  or).            
+0000c490: 636f 6c6f 7243 4f4d 5b30 5d20 2a3d 2030  colorCOM[0] *= 0
+0000c4a0: 2e38 2023 6d61 6b65 2043 4f4d 2061 206c  .8 #make COM a l
+0000c4b0: 6974 746c 6520 6461 726b 6572 0a20 2020  ittle darker.   
+0000c4c0: 2020 2020 2020 2020 2063 6f6c 6f72 434f           colorCO
+0000c4d0: 4d5b 315d 202a 3d20 302e 380a 2020 2020  M[1] *= 0.8.    
+0000c4e0: 2020 2020 2020 2020 636f 6c6f 7243 4f4d          colorCOM
+0000c4f0: 5b32 5d20 2a3d 2030 2e38 0a20 2020 2020  [2] *= 0.8.     
+0000c500: 2020 2020 2020 2067 7261 7068 6963 734c         graphicsL
+0000c510: 6973 7420 2b3d 205b 6567 642e 4772 6170  ist += [egd.Grap
+0000c520: 6869 6373 4461 7461 4f72 7468 6f43 7562  hicsDataOrthoCub
+0000c530: 6550 6f69 6e74 2863 6f6d 2c20 5b64 642c  ePoint(com, [dd,
+0000c540: 6464 2c64 645d 2c20 636f 6c6f 7243 4f4d  dd,dd], colorCOM
+0000c550: 295d 0a0a 2020 2020 2020 2020 2364 7261  )]..        #dra
+0000c560: 7720 6c69 6e6b 3a0a 2020 2020 2020 2020  w link:.        
+0000c570: 6966 2072 2021 3d20 303a 0a20 2020 2020  if r != 0:.     
+0000c580: 2020 2020 2020 2068 3020 3d20 302e 352a         h0 = 0.5*
+0000c590: 774a 2020 2023 6865 6967 6874 206f 6620  wJ   #height of 
+0000c5a0: 6861 6c66 2061 7869 732c 2066 6972 7374  half axis, first
+0000c5b0: 206a 6f69 6e74 0a20 2020 2020 2020 2020   joint.         
+0000c5c0: 2020 2068 3120 3d20 302e 352a 774a 2020     h1 = 0.5*wJ  
+0000c5d0: 2023 6865 6967 6874 206f 6620 6861 6c66   #height of half
+0000c5e0: 2061 7869 732c 2073 6563 6f6e 6420 6a6f   axis, second jo
+0000c5f0: 696e 740a 0a20 2020 2020 2020 2020 2020  int..           
+0000c600: 2023 6669 7273 7420 6379 6c69 6e64 6572   #first cylinder
+0000c610: 2073 686f 756c 6420 6265 2064 7261 776e   should be drawn
+0000c620: 2061 7420 6261 7365 3a0a 2020 2020 2020   at base:.      
+0000c630: 2020 2020 2020 2320 6966 2069 203d 3d20        # if i == 
+0000c640: 303a 2023 6472 6177 2066 756c 6c20 6379  0: #draw full cy
+0000c650: 6c69 6e64 6572 2066 6f72 2066 6972 7374  linder for first
+0000c660: 206a 6f69 6e74 0a20 2020 2020 2020 2020   joint.         
+0000c670: 2020 2023 2020 2020 2068 3020 3d20 774a     #     h0 = wJ
+0000c680: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
+0000c690: 2069 2021 3d20 303a 0a20 2020 2020 2020   i != 0:.       
+0000c6a0: 2020 2020 2020 2020 2067 7261 7068 6963           graphic
+0000c6b0: 734c 6973 7420 2b3d 205b 6567 642e 4772  sList += [egd.Gr
+0000c6c0: 6170 6869 6373 4461 7461 4379 6c69 6e64  aphicsDataCylind
+0000c6d0: 6572 2870 4178 6973 3d70 302c 2076 4178  er(pAxis=p0, vAx
+0000c6e0: 6973 3d2d 6830 2a6e 702e 6172 7261 7928  is=-h0*np.array(
+0000c6f0: 6178 6973 3029 2c20 0a20 2020 2020 2020  axis0), .       
+0000c700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c720: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000c730: 6164 6975 733d 722c 2063 6f6c 6f72 3d63  adius=r, color=c
+0000c740: 6f6c 6f72 295d 0a20 2020 2020 2020 2020  olor)].         
+0000c750: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+0000c760: 6772 6170 6869 6373 4c69 7374 202b 3d20  graphicsList += 
+0000c770: 5b65 6764 2e47 7261 7068 6963 7344 6174  [egd.GraphicsDat
+0000c780: 6143 796c 696e 6465 7228 7041 7869 733d  aCylinder(pAxis=
+0000c790: 7031 2c20 7641 7869 733d 2068 312a 6e70  p1, vAxis= h1*np
+0000c7a0: 2e61 7272 6179 2861 7869 7331 292c 200a  .array(axis1), .
+0000c7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7e0: 2020 2020 2020 7261 6469 7573 3d72 2c20        radius=r, 
+0000c7f0: 636f 6c6f 723d 636f 6c6f 7229 5d0a 0a20  color=color)].. 
+0000c800: 2020 2020 2020 2020 2020 2023 6472 6177             #draw
+0000c810: 2062 6f64 7920 6173 2063 796c 696e 6465   body as cylinde
+0000c820: 723a 0a20 2020 2020 2020 2020 2020 2069  r:.            i
+0000c830: 6620 6562 752e 4e6f 726d 4c32 2865 6275  f ebu.NormL2(ebu
+0000c840: 2e56 5375 6228 7031 2c70 3029 2920 3e20  .VSub(p1,p0)) > 
+0000c850: 3165 2d31 353a 0a20 2020 2020 2020 2020  1e-15:.         
+0000c860: 2020 2020 2020 2067 7261 7068 6963 734c         graphicsL
+0000c870: 6973 7420 2b3d 205b 6567 642e 4772 6170  ist += [egd.Grap
+0000c880: 6869 6373 4461 7461 4379 6c69 6e64 6572  hicsDataCylinder
+0000c890: 2870 4178 6973 3d70 312c 2076 4178 6973  (pAxis=p1, vAxis
+0000c8a0: 3d65 6275 2e56 5375 6228 7030 2c70 3129  =ebu.VSub(p0,p1)
+0000c8b0: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
+0000c8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8e0: 2020 2020 2020 2020 2072 6164 6975 733d           radius=
+0000c8f0: 302e 352a 774c 2c20 636f 6c6f 723d 636f  0.5*wL, color=co
+0000c900: 6c6f 7229 5d0a 2020 2020 2020 2020 0a20  lor)].        . 
+0000c910: 2020 2020 2020 2072 6574 7572 6e20 6772         return gr
+0000c920: 6170 6869 6373 4c69 7374 0a0a 2020 2020  aphicsList..    
+0000c930: 0a20 2020 2023 2a2a 636c 6173 7346 756e  .    #**classFun
+0000c940: 6374 696f 6e3a 2062 7569 6c64 2072 6f62  ction: build rob
+0000c950: 6f74 2073 7472 7563 7472 6520 6672 6f6d  ot structre from
+0000c960: 2064 6963 7469 6f6e 6172 793b 2074 6869   dictionary; thi
+0000c970: 7320 6973 2061 2044 4550 5245 4341 5445  s is a DEPRECATE
+0000c980: 4420 6675 6e63 7469 6f6e 2c20 7768 6963  D function, whic
+0000c990: 6820 6973 2075 7365 6420 696e 206f 6c64  h is used in old
+0000c9a0: 6572 206d 6f64 656c 733b 2044 4f20 4e4f  er models; DO NO
+0000c9b0: 5420 5553 450a 2020 2020 6465 6620 4275  T USE.    def Bu
+0000c9c0: 696c 6446 726f 6d44 6963 7469 6f6e 6172  ildFromDictionar
+0000c9d0: 7928 7365 6c66 2c20 726f 626f 7444 6963  y(self, robotDic
+0000c9e0: 7429 3a0a 2020 2020 2020 2020 676c 6f62  t):.        glob
+0000c9f0: 616c 2062 7569 6c64 4672 6f6d 4469 6374  al buildFromDict
+0000ca00: 696f 6e61 7279 5761 726e 6564 0a20 2020  ionaryWarned.   
+0000ca10: 2020 2020 2069 6620 6e6f 7420 6275 696c       if not buil
+0000ca20: 6446 726f 6d44 6963 7469 6f6e 6172 7957  dFromDictionaryW
+0000ca30: 6172 6e65 643a 0a20 2020 2020 2020 2020  arned:.         
+0000ca40: 2020 2062 7569 6c64 4672 6f6d 4469 6374     buildFromDict
+0000ca50: 696f 6e61 7279 5761 726e 6564 203d 2054  ionaryWarned = T
+0000ca60: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
+0000ca70: 7072 696e 7428 2257 4152 4e49 4e47 3a20  print("WARNING: 
+0000ca80: 6675 6e63 7469 6f6e 2042 7569 6c64 4672  function BuildFr
+0000ca90: 6f6d 4469 6374 696f 6e61 7279 2069 6e20  omDictionary in 
+0000caa0: 636c 6173 7320 526f 626f 7420 6973 2044  class Robot is D
+0000cab0: 4550 5245 4341 5445 443b 2044 4f20 4e4f  EPRECATED; DO NO
+0000cac0: 5420 5553 4522 290a 0a20 2020 2020 2020  T USE")..       
+0000cad0: 2069 6620 2762 6173 6527 2069 6e20 726f   if 'base' in ro
+0000cae0: 626f 7444 6963 743a 0a20 2020 2020 2020  botDict:.       
+0000caf0: 2020 2020 2073 656c 662e 6261 7365 2e48       self.base.H
+0000cb00: 5420 3d20 6e70 2e61 7272 6179 2872 6f62  T = np.array(rob
+0000cb10: 6f74 4469 6374 5b27 6261 7365 275d 5b27  otDict['base']['
+0000cb20: 4854 275d 290a 2020 2020 2020 2020 6966  HT']).        if
+0000cb30: 2027 746f 6f6c 2720 696e 2072 6f62 6f74   'tool' in robot
+0000cb40: 4469 6374 3a0a 2020 2020 2020 2020 2020  Dict:.          
+0000cb50: 2020 7365 6c66 2e74 6f6f 6c2e 4854 203d    self.tool.HT =
+0000cb60: 206e 702e 6172 7261 7928 726f 626f 7444   np.array(robotD
+0000cb70: 6963 745b 2774 6f6f 6c27 5d5b 2748 5427  ict['tool']['HT'
+0000cb80: 5d29 0a20 2020 2020 2020 2069 6620 2767  ]).        if 'g
+0000cb90: 7261 7669 7479 2720 696e 2072 6f62 6f74  ravity' in robot
+0000cba0: 4469 6374 3a0a 2020 2020 2020 2020 2020  Dict:.          
+0000cbb0: 2020 7365 6c66 2e67 7261 7669 7479 203d    self.gravity =
+0000cbc0: 206e 702e 6172 7261 7928 726f 626f 7444   np.array(robotD
+0000cbd0: 6963 745b 2767 7261 7669 7479 275d 290a  ict['gravity']).
+0000cbe0: 2020 2020 2020 2020 6966 2027 7265 6665          if 'refe
+0000cbf0: 7265 6e63 6543 6f6e 6669 6775 7261 7469  renceConfigurati
+0000cc00: 6f6e 2720 696e 2072 6f62 6f74 4469 6374  on' in robotDict
+0000cc10: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000cc20: 6c66 2e72 6566 6572 656e 6365 436f 6e66  lf.referenceConf
+0000cc30: 6967 7572 6174 696f 6e20 3d20 6e70 2e61  iguration = np.a
+0000cc40: 7272 6179 2872 6f62 6f74 4469 6374 5b27  rray(robotDict['
+0000cc50: 7265 6665 7265 6e63 6543 6f6e 6669 6775  referenceConfigu
+0000cc60: 7261 7469 6f6e 275d 290a 2020 2020 2020  ration']).      
+0000cc70: 2020 0a20 2020 2020 2020 2077 6172 6e65    .        warne
+0000cc80: 644d 6f64 4448 203d 2046 616c 7365 0a20  dModDH = False. 
+0000cc90: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+0000cca0: 7261 6e67 6528 6c65 6e28 726f 626f 7444  range(len(robotD
+0000ccb0: 6963 745b 276c 696e 6b73 275d 2929 3a0a  ict['links'])):.
+0000ccc0: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+0000ccd0: 203d 2072 6f62 6f74 4469 6374 5b27 6c69   = robotDict['li
+0000cce0: 6e6b 7327 5d5b 695d 0a20 2020 2020 2020  nks'][i].       
+0000ccf0: 2020 2020 2023 2071 5265 6620 3d20 300a       # qRef = 0.
+0000cd00: 2020 2020 2020 2020 2020 2020 2320 6966              # if
+0000cd10: 206c 656e 2872 6f62 6f74 4469 6374 5b27   len(robotDict['
+0000cd20: 7265 6665 7265 6e63 6543 6f6e 6669 6775  referenceConfigu
+0000cd30: 7261 7469 6f6e 275d 2920 3e20 693a 0a20  ration']) > i:. 
+0000cd40: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+0000cd50: 2071 5265 6620 3d20 726f 626f 7444 6963   qRef = robotDic
+0000cd60: 745b 2772 6566 6572 656e 6365 436f 6e66  t['referenceConf
+0000cd70: 6967 7572 6174 696f 6e27 5d5b 695d 0a20  iguration'][i]. 
+0000cd80: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+0000cd90: 2020 2020 2020 2020 6966 2027 7374 6444          if 'stdD
+0000cda0: 4827 2069 6e20 6c69 6e6b 3a0a 2020 2020  H' in link:.    
+0000cdb0: 2020 2020 2020 2020 2020 2020 6c6f 6361              loca
+0000cdc0: 6c48 5420 3d20 5374 6444 4832 4854 286c  lHT = StdDH2HT(l
+0000cdd0: 696e 6b5b 2773 7464 4448 275d 2920 2375  ink['stdDH']) #u
+0000cde0: 7369 6e67 2074 6865 7461 3d30 0a20 2020  sing theta=0.   
+0000cdf0: 2020 2020 2020 2020 2023 6d6f 6469 6669           #modifi
+0000ce00: 6564 2044 4820 7061 7261 6d65 7465 7273  ed DH parameters
+0000ce10: 2061 7265 2072 652d 696e 7465 7270 7265   are re-interpre
+0000ce20: 7465 6420 6173 2073 7461 6e64 6172 6420  ted as standard 
+0000ce30: 4448 2070 6172 616d 6574 6572 732c 2077  DH parameters, w
+0000ce40: 6869 6368 2064 6f65 7320 6e6f 7420 616c  hich does not al
+0000ce50: 7761 7973 2077 6f72 6b20 2f20 6e65 6564  ways work / need
+0000ce60: 7320 6164 6469 7469 6f6e 616c 2061 646a  s additional adj
+0000ce70: 7573 746d 656e 7473 210a 2020 2020 2020  ustments!.      
+0000ce80: 2020 2020 2020 656c 6966 2027 6d6f 6444        elif 'modD
+0000ce90: 4863 7261 6967 2720 696e 206c 696e 6b3a  Hcraig' in link:
+0000cea0: 2023 6163 636f 7264 696e 6720 746f 2043   #according to C
+0000ceb0: 7261 6967 2028 3139 3836 2920 616e 6420  raig (1986) and 
+0000cec0: 6d6f 6469 6669 6564 2044 4820 7061 7261  modified DH para
+0000ced0: 6d65 7465 7273 2069 6e20 436f 726b 6527  meters in Corke'
+0000cee0: 7320 746f 6f6c 626f 7820 2832 3031 3729  s toolbox (2017)
+0000cef0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cf00: 2069 6620 6e6f 7420 7761 726e 6564 4d6f   if not warnedMo
+0000cf10: 6444 483a 0a20 2020 2020 2020 2020 2020  dDH:.           
+0000cf20: 2020 2020 2020 2020 2077 6172 6e65 644d           warnedM
+0000cf30: 6f64 4448 203d 2054 7275 650a 2020 2020  odDH = True.    
+0000cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf50: 7072 696e 7428 2757 4152 4e49 4e47 3a20  print('WARNING: 
+0000cf60: 4275 696c 6446 726f 6d44 6963 7469 6f6e  BuildFromDiction
+0000cf70: 6172 7920 756e 7465 7374 6564 2066 6f72  ary untested for
+0000cf80: 206d 6f64 4448 3b20 6d69 7373 696e 6720   modDH; missing 
+0000cf90: 7472 616e 7366 6f72 6d61 7469 6f6e 2066  transformation f
+0000cfa0: 6f72 2069 6e65 7274 6961 2061 6e64 2043  or inertia and C
+0000cfb0: 4f4d 3f27 290a 2020 2020 2020 2020 2020  OM?').          
+0000cfc0: 2020 2020 2020 5b74 6865 7461 2c20 642c        [theta, d,
+0000cfd0: 2061 2c20 616c 7068 615d 203d 206c 696e   a, alpha] = lin
+0000cfe0: 6b5b 276d 6f64 4448 6372 6169 6727 5d0a  k['modDHcraig'].
+0000cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d000: 6131 203d 2030 2023 6966 206e 6f20 7375  a1 = 0 #if no su
+0000d010: 6363 6565 6469 6e67 206c 696e 6b20 666f  cceeding link fo
+0000d020: 6c6c 6f77 730a 2020 2020 2020 2020 2020  llows.          
+0000d030: 2020 2020 2020 616c 7068 6131 203d 2030        alpha1 = 0
+0000d040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d050: 2069 6620 6920 3c20 6c65 6e28 726f 626f   if i < len(robo
+0000d060: 7444 6963 745b 276c 696e 6b73 275d 292d  tDict['links'])-
+0000d070: 313a 2023 7468 6572 6520 6578 6973 7473  1: #there exists
+0000d080: 2061 206e 6578 7420 6c69 6e6b 2c20 7768   a next link, wh
+0000d090: 6963 6820 7765 2075 7365 2061 7320 6164  ich we use as ad
+0000d0a0: 6469 7469 6f6e 616c 2073 7461 6e64 6172  ditional standar
+0000d0b0: 6420 4448 2d70 6172 616d 6574 6572 7320  d DH-parameters 
+0000d0c0: 666f 7220 7468 6973 206c 696e 6b0a 2020  for this link.  
+0000d0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0e0: 2020 5b74 6865 7461 312c 2064 312c 2061    [theta1, d1, a
+0000d0f0: 312c 2061 6c70 6861 315d 203d 206c 696e  1, alpha1] = lin
+0000d100: 6b5b 276d 6f64 4448 6372 6169 6727 5d0a  k['modDHcraig'].
+0000d110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d120: 6966 2069 203d 3d20 303a 2023 7075 7420  if i == 0: #put 
+0000d130: 6669 7273 7420 7477 6f20 4448 2070 6172  first two DH par
+0000d140: 616d 6574 6572 7320 746f 2062 6173 650a  ameters to base.
+0000d150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d160: 2020 2020 7365 6c66 2e62 6173 652e 4854      self.base.HT
+0000d170: 203d 2073 656c 662e 6261 7365 2e48 5420   = self.base.HT 
+0000d180: 4020 6572 622e 4854 726f 7461 7465 5828  @ erb.HTrotateX(
+0000d190: 616c 7068 6129 2040 2065 7262 2e48 5474  alpha) @ erb.HTt
+0000d1a0: 7261 6e73 6c61 7465 285b 612c 302c 305d  ranslate([a,0,0]
+0000d1b0: 2920 0a20 2020 2020 2020 2020 2020 2020  ) .             
+0000d1c0: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+0000d1d0: 2020 2020 236c 6f63 616c 2048 5420 7265      #local HT re
+0000d1e0: 2d69 6e74 6572 7072 6574 6564 2061 7320  -interpreted as 
+0000d1f0: 7374 616e 6461 7264 2044 482d 7061 7261  standard DH-para
+0000d200: 6d65 7465 7273 2c20 6173 2073 7567 6765  meters, as sugge
+0000d210: 7374 6564 2062 7920 436f 726b 6520 3230  sted by Corke 20
+0000d220: 3137 2c20 7061 6765 2032 3139 3a0a 2020  17, page 219:.  
+0000d230: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+0000d240: 6361 6c48 5420 3d20 6572 622e 4854 726f  calHT = erb.HTro
+0000d250: 7461 7465 5a28 7468 6574 6129 2040 2065  tateZ(theta) @ e
+0000d260: 7262 2e48 5474 7261 6e73 6c61 7465 285b  rb.HTtranslate([
+0000d270: 302c 302c 645d 2920 4020 6572 622e 4854  0,0,d]) @ erb.HT
+0000d280: 7472 616e 736c 6174 6528 5b61 312c 302c  translate([a1,0,
+0000d290: 305d 2920 4020 6572 622e 4854 726f 7461  0]) @ erb.HTrota
+0000d2a0: 7465 5828 616c 7068 6131 290a 2020 2020  teX(alpha1).    
+0000d2b0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000d2c0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+0000d2d0: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+0000d2e0: 4275 696c 6446 726f 6d44 6963 7469 6f6e  BuildFromDiction
+0000d2f0: 6172 7920 696e 2063 6c61 7373 2052 6f62  ary in class Rob
+0000d300: 6f74 3a20 6f6e 6c79 2073 7570 706f 7274  ot: only support
+0000d310: 7320 6c69 6e6b 7320 7769 7468 2073 7464  s links with std
+0000d320: 4448 2070 6172 616d 6574 6572 7327 290a  DH parameters').
+0000d330: 0a20 2020 2020 2020 2020 2020 2072 6f62  .            rob
+0000d340: 6f74 4c69 6e6b 203d 2052 6f62 6f74 4c69  otLink = RobotLi
+0000d350: 6e6b 286d 6173 733d 6c69 6e6b 5b27 6d61  nk(mass=link['ma
+0000d360: 7373 275d 2c20 434f 4d3d 6c69 6e6b 5b27  ss'], COM=link['
+0000d370: 434f 4d27 5d2c 2069 6e65 7274 6961 3d6c  COM'], inertia=l
+0000d380: 696e 6b5b 2769 6e65 7274 6961 275d 2c20  ink['inertia'], 
+0000d390: 6c6f 6361 6c48 543d 6c6f 6361 6c48 5429  localHT=localHT)
+0000d3a0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000d3b0: 662e 4164 644c 696e 6b28 726f 626f 744c  f.AddLink(robotL
+0000d3c0: 696e 6b29 0a0a 2020 2020 2020 2020 0a0a  ink)..        ..
+0000d3d0: 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  #+++++++++++++++
+0000d3e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d3f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d400: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d410: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d420: 2b2b 2b2b 2b0a 232b 2b2b 2020 4448 2d50  +++++.#+++  DH-P
+0000d430: 4152 414d 4554 4552 5320 202b 2b2b 2b2b  ARAMETERS  +++++
+0000d440: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d450: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d460: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d470: 2b2b 2b2b 2b2b 2b2b 2b2b 2b0a 232b 2b2b  +++++++++++.#+++
+0000d480: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d490: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d4a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d4b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d4c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000d4d0: 2b0a 0a23 2a2a 6675 6e63 7469 6f6e 3a20  +..#**function: 
+0000d4e0: 636f 6d70 7574 6520 686f 6d6f 6765 6e65  compute homogene
+0000d4f0: 6f75 7320 7472 616e 7366 6f72 6d61 7469  ous transformati
+0000d500: 6f6e 206d 6174 7269 7820 4854 2066 726f  on matrix HT fro
+0000d510: 6d20 7374 616e 6461 7264 2044 4870 6172  m standard DHpar
+0000d520: 616d 6574 6572 733d 5b74 6865 7461 2c20  ameters=[theta, 
+0000d530: 642c 2061 2c20 616c 7068 615d 0a64 6566  d, a, alpha].def
+0000d540: 2053 7464 4448 3248 5428 4448 7061 7261   StdDH2HT(DHpara
+0000d550: 6d65 7465 7273 293a 0a23 2020 2020 5b74  meters):.#    [t
+0000d560: 6865 7461 2c20 642c 2061 2c20 616c 7068  heta, d, a, alph
+0000d570: 615d 203d 2044 4870 6172 616d 6574 6572  a] = DHparameter
+0000d580: 730a 2320 2020 2072 6574 7572 6e20 6572  s.#    return er
+0000d590: 622e 4854 726f 7461 7465 5a28 7468 6574  b.HTrotateZ(thet
+0000d5a0: 6129 2040 2065 7262 2e48 5474 7261 6e73  a) @ erb.HTtrans
+0000d5b0: 6c61 7465 285b 302c 302c 645d 2920 4020  late([0,0,d]) @ 
+0000d5c0: 6572 622e 4854 7472 616e 736c 6174 6528  erb.HTtranslate(
+0000d5d0: 5b61 2c30 2c30 5d29 2040 2065 7262 2e48  [a,0,0]) @ erb.H
+0000d5e0: 5472 6f74 6174 6558 2861 6c70 6861 290a  TrotateX(alpha).
+0000d5f0: 2020 2020 236f 7074 696d 697a 6564 2076      #optimized v
+0000d600: 6572 7369 6f6e 3a0a 2020 2020 5b74 6865  ersion:.    [the
+0000d610: 7461 2c20 642c 2061 2c20 616c 7068 615d  ta, d, a, alpha]
+0000d620: 203d 2044 4870 6172 616d 6574 6572 730a   = DHparameters.
+0000d630: 2020 2020 6374 203d 206e 702e 636f 7328      ct = np.cos(
+0000d640: 7468 6574 6129 0a20 2020 2073 7420 3d20  theta).    st = 
+0000d650: 6e70 2e73 696e 2874 6865 7461 290a 2020  np.sin(theta).  
+0000d660: 2020 6361 203d 206e 702e 636f 7328 616c    ca = np.cos(al
+0000d670: 7068 6129 0a20 2020 2073 6120 3d20 6e70  pha).    sa = np
+0000d680: 2e73 696e 2861 6c70 6861 290a 2020 2020  .sin(alpha).    
+0000d690: 7265 7475 726e 206e 702e 6172 7261 7928  return np.array(
+0000d6a0: 5b5b 6374 2c2d 7374 2a63 612c 2073 742a  [[ct,-st*ca, st*
+0000d6b0: 7361 2c20 612a 6374 5d2c 0a20 2020 2020  sa, a*ct],.     
+0000d6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6d0: 5b73 742c 2063 742a 6361 2c2d 6374 2a73  [st, ct*ca,-ct*s
+0000d6e0: 612c 2061 2a73 745d 2c0a 2020 2020 2020  a, a*st],.      
+0000d6f0: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+0000d700: 2030 2c20 7361 2020 202c 2063 6120 2020   0, sa   , ca   
+0000d710: 2c20 6420 2020 5d2c 0a20 2020 2020 2020  , d   ],.       
+0000d720: 2020 2020 2020 2020 2020 2020 2020 5b20                [ 
+0000d730: 302c 2030 2020 2020 2c20 3020 2020 202c  0, 0    , 0    ,
+0000d740: 2031 2020 205d 5d29 0a0a 235c 6d66 6f75   1   ]])..#\mfou
+0000d750: 727b 5c63 6f73 205c 7468 6574 615f 6a20  r{\cos \theta_j 
+0000d760: 262d 5c73 696e 205c 7468 6574 615f 6a20  &-\sin \theta_j 
+0000d770: 5c63 6f73 205c 616c 7068 615f 6a20 2620  \cos \alpha_j & 
+0000d780: 5c73 696e 205c 7468 6574 615f 6a20 5c73  \sin \theta_j \s
+0000d790: 696e 205c 616c 7068 615f 6a20 2620 615f  in \alpha_j & a_
+0000d7a0: 6a20 5c63 6f73 205c 7468 6574 615f 6a7d  j \cos \theta_j}
+0000d7b0: 0a23 2020 2020 2020 2020 2020 2020 2020  .#              
+0000d7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7e0: 2020 2020 2020 2020 2020 7b5c 7369 6e20            {\sin 
+0000d7f0: 5c74 6865 7461 5f6a 2026 205c 636f 7320  \theta_j & \cos 
+0000d800: 5c74 6865 7461 5f6a 205c 636f 7320 5c61  \theta_j \cos \a
+0000d810: 6c70 6861 5f6a 2026 2d5c 636f 7320 5c74  lpha_j &-\cos \t
+0000d820: 6865 7461 5f6a 205c 7369 6e20 5c61 6c70  heta_j \sin \alp
+0000d830: 6861 5f6a 2026 2061 5f6a 205c 7369 6e20  ha_j & a_j \sin 
+0000d840: 5c74 6865 7461 5f6a 7d0a 2320 2020 2020  \theta_j}.#     
+0000d850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d880: 2020 207b 3020 2020 2020 2020 2020 2020     {0           
+0000d890: 2020 2620 5c73 696e 205c 616c 7068 615f    & \sin \alpha_
+0000d8a0: 6a20 2020 2020 2020 2020 2020 2020 2020  j               
+0000d8b0: 2620 5c63 6f73 205c 616c 7068 615f 6a20  & \cos \alpha_j 
+0000d8c0: 2020 2020 2020 2020 2020 2020 2020 2620                & 
+0000d8d0: 645f 6a20 7d0a 2320 2020 2020 2020 2020  d_j }.#         
+0000d8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d900: 2020 2020 2020 2020 2020 2020 2020 207b                 {
+0000d910: 3020 2620 3020 2620 3020 2620 317d 0a23  0 & 0 & 0 & 1}.#
+0000d920: 5465 7374 2028 636f 6d70 6172 6564 2077  Test (compared w
+0000d930: 6974 6820 526f 626f 7463 732c 2056 6973  ith Robotcs, Vis
+0000d940: 696f 6e20 616e 6420 436f 6e74 726f 6c20  ion and Control 
+0000d950: 626f 6f6b 206f 6620 502e 2043 6f72 6b65  book of P. Corke
+0000d960: 3a0a 2370 7269 6e74 2822 7374 642e 2044  :.#print("std. D
+0000d970: 4820 3d5c 6e22 2c20 4448 3248 5428 5b30  H =\n", DH2HT([0
+0000d980: 2e35 2c20 302e 312c 2030 2e32 2c20 6e70  .5, 0.1, 0.2, np
+0000d990: 2e70 692f 325d 292e 726f 756e 6428 3429  .pi/2]).round(4)
+0000d9a0: 290a 0a23 2a2a 6675 6e63 7469 6f6e 3a20  )..#**function: 
+0000d9b0: 636f 6d70 7574 6520 7072 652d 2061 6e64  compute pre- and
+0000d9c0: 2070 6f73 742d 2068 6f6d 6f67 656e 656f   post- homogeneo
+0000d9d0: 7573 2074 7261 6e73 666f 726d 6174 696f  us transformatio
+0000d9e0: 6e20 6d61 7472 6963 6573 2066 726f 6d20  n matrices from 
+0000d9f0: 6d6f 6469 6669 6564 2044 656e 6176 6974  modified Denavit
+0000da00: 2d48 6172 7465 6e62 6572 6720 4448 7061  -Hartenberg DHpa
+0000da10: 7261 6d65 7465 7273 3d5b 616c 7068 612c  rameters=[alpha,
+0000da20: 2064 2c20 7468 6574 612c 2072 5d3b 2072   d, theta, r]; r
+0000da30: 6574 7572 6e73 205b 4854 7072 652c 2048  eturns [HTpre, H
+0000da40: 5470 6f73 745d 3b20 4854 7072 6520 6973  Tpost]; HTpre is
+0000da50: 2074 7261 6e73 666f 726d 6174 696f 6e20   transformation 
+0000da60: 6265 666f 7265 2061 7869 7320 726f 7461  before axis rota
+0000da70: 7469 6f6e 2c20 4854 706f 7374 2069 6e63  tion, HTpost inc
+0000da80: 6c75 6465 7320 6178 6973 2072 6f74 6174  ludes axis rotat
+0000da90: 696f 6e20 616e 6420 6576 6572 7974 6869  ion and everythi
+0000daa0: 6e67 2068 6572 6561 6674 6572 3b20 6d6f  ng hereafter; mo
+0000dab0: 6469 6669 6564 2044 482d 5061 7261 6d65  dified DH-Parame
+0000dac0: 7465 7273 2061 6363 6f72 6469 6e67 2074  ters according t
+0000dad0: 6f20 4b68 616c 696c 2061 6e64 204b 6c65  o Khalil and Kle
+0000dae0: 696e 6669 6e67 6572 2c20 3139 3836 0a64  infinger, 1986.d
+0000daf0: 6566 204d 6f64 4448 4b4b 3248 5428 4448  ef ModDHKK2HT(DH
+0000db00: 7061 7261 6d65 7465 7273 293a 0a20 2020  parameters):.   
+0000db10: 205b 616c 7068 612c 2064 2c20 7468 6574   [alpha, d, thet
+0000db20: 612c 2072 5d20 3d20 4448 7061 7261 6d65  a, r] = DHparame
+0000db30: 7465 7273 0a20 2020 2072 6574 7572 6e20  ters.    return 
+0000db40: 5b65 7262 2e48 5472 6f74 6174 6558 2861  [erb.HTrotateX(a
+0000db50: 6c70 6861 2920 4020 6572 622e 4854 7472  lpha) @ erb.HTtr
+0000db60: 616e 736c 6174 6528 5b64 2c30 2c30 5d29  anslate([d,0,0])
+0000db70: 202c 2065 7262 2e48 5472 6f74 6174 655a   , erb.HTrotateZ
+0000db80: 2874 6865 7461 2920 4020 6572 622e 4854  (theta) @ erb.HT
+0000db90: 7472 616e 736c 6174 6528 5b30 2c30 2c72  translate([0,0,r
+0000dba0: 5d29 205d 200a 0a23 2b2b 2b2b 2b2b 2b2b  ]) ] ..#++++++++
+0000dbb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dbc0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dbd0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dbe0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dbf0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0a23 2b2b  ++++++++++++.#++
+0000dc00: 2b0a 232b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  +.#+++++++++++++
+0000dc10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dc20: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dc30: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dc40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dc50: 2b2b 2b2b 2b2b 2b0a 232a 2a66 756e 6374  +++++++.#**funct
+0000dc60: 696f 6e3a 2054 6869 7320 6675 6e63 7469  ion: This functi
+0000dc70: 6f6e 2070 726f 6a65 6374 7320 616e 2061  on projects an a
+0000dc80: 6e67 6c65 2069 6e20 7468 6520 7261 6e67  ngle in the rang
+0000dc90: 6520 245b 2d6d 696e 5f7b 666c 6f61 747d  e $[-min_{float}
+0000dca0: 2c20 2b6d 6178 5f7b 666c 6f61 747d 5d24  , +max_{float}]$
+0000dcb0: 2066 6f20 7468 6520 7261 6e67 6520 245b   fo the range $[
+0000dcc0: 2d5c 7069 2c20 2b5c 7069 5d24 0a23 2a2a  -\pi, +\pi]$.#**
+0000dcd0: 696e 7075 743a 0a23 2020 7130 3a20 416e  input:.#  q0: An
+0000dce0: 2061 6e67 6c65 2065 6974 6865 7220 6173   angle either as
+0000dcf0: 2073 6361 6c61 722c 206c 6973 7420 6f72   scalar, list or
+0000dd00: 2061 7272 6179 0a23 2a2a 6f75 7470 7574   array.#**output
+0000dd10: 3a0a 2320 2071 5072 6f6a 3a20 5468 6520  :.#  qProj: The 
+0000dd20: 616e 676c 6520 7072 6f6a 6563 7465 6420  angle projected 
+0000dd30: 696e 746f 2074 6865 2072 616e 6765 2024  into the range $
+0000dd40: 5b2d 5c70 6920 746f 205c 7069 5d24 0a23  [-\pi to \pi]$.#
+0000dd50: 2a2a 6175 7468 6f72 3a20 5065 7465 7220  **author: Peter 
+0000dd60: 4d61 6e7a 6c0a 6465 6620 7072 6f6a 6563  Manzl.def projec
+0000dd70: 7441 6e67 6c65 546f 504d 5069 2871 3029  tAngleToPMPi(q0)
+0000dd80: 3a20 0a20 2020 2069 6620 7479 7065 2871  : .    if type(q
+0000dd90: 3029 203d 3d20 6c69 7374 3a20 0a20 2020  0) == list: .   
+0000dda0: 2020 2020 2071 3020 3d20 6e70 2e61 7272       q0 = np.arr
+0000ddb0: 6179 2871 3029 2023 2063 6173 7420 746f  ay(q0) # cast to
+0000ddc0: 2061 7272 6179 2066 6f72 206d 6f64 756c   array for modul
+0000ddd0: 6f20 746f 2077 6f72 6b0a 2020 2020 7131  o to work.    q1
+0000dde0: 203d 2020 7130 2025 2028 322a 6e70 2e70   =  q0 % (2*np.p
+0000ddf0: 6929 2023 2069 6e20 7261 6e67 6520 3020  i) # in range 0 
+0000de00: 746f 2032 2a6e 702e 7069 0a20 2020 2071  to 2*np.pi.    q
+0000de10: 5072 6f6a 203d 2071 3120 2d20 322a 6e70  Proj = q1 - 2*np
+0000de20: 2e70 692a 2871 3120 3e20 6e70 2e70 6929  .pi*(q1 > np.pi)
+0000de30: 0a20 2020 2072 6574 7572 6e20 7150 726f  .    return qPro
+0000de40: 6a0a 0a0a 232b 2b2b 2b2b 2b2b 2b2b 2b2b  j...#+++++++++++
+0000de50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000de60: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000de70: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000de80: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000de90: 2b2b 2b2b 2b2b 2b2b 2b0a 232b 2b2b 0a23  +++++++++.#+++.#
+0000dea0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000deb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dec0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000ded0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000dee0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000def0: 2b2b 2b2b 0a23 2a2a 636c 6173 733a 2054  ++++.#**class: T
+0000df00: 6869 7320 636c 6173 7320 6361 6e20 6265  his class can be
+0000df10: 2075 7365 6420 746f 2073 6f6c 7665 2074   used to solve t
+0000df20: 6865 2069 6e76 6572 7365 206b 696e 656d  he inverse kinem
+0000df30: 6174 6963 7320 7072 6f62 6c65 6d20 7573  atics problem us
+0000df40: 696e 6720 6120 6d75 6c74 6962 6f64 7920  ing a multibody 
+0000df50: 7379 7374 656d 200a 2320 2020 2020 2020  system .#       
+0000df60: 2020 2020 2062 7920 736f 6c76 696e 6720       by solving 
+0000df70: 7468 6520 7374 6174 6963 2070 726f 626c  the static probl
+0000df80: 656d 206f 6620 6120 7365 7269 616c 2072  em of a serial r
+0000df90: 6f62 6f74 0a23 2a2a 6175 7468 6f72 3a20  obot.#**author: 
+0000dfa0: 5065 7465 7220 4d61 6e7a 6c2c 204a 6f68  Peter Manzl, Joh
+0000dfb0: 616e 6e65 7320 4765 7273 746d 6179 720a  annes Gerstmayr.
+0000dfc0: 232a 2a6e 6f74 6573 3a20 7374 696c 6c20  #**notes: still 
+0000dfd0: 756e 6465 7220 6465 7665 6c6f 706d 656e  under developmen
+0000dfe0: 743b 2065 7272 6f72 7320 696e 206f 7269  t; errors in ori
+0000dff0: 656e 7461 7469 6f6e 7320 6f66 2073 6f6c  entations of sol
+0000e000: 7574 696f 6e20 6d61 7920 6f63 6375 7265  ution may occure
+0000e010: 2e20 7072 6f76 6965 6465 7320 6d74 6568  . proviedes mteh
+0000e020: 6f64 7320 746f 2063 616c 6375 6c61 7465  ods to calculate
+0000e030: 2069 6e76 6572 7365 204b 696e 656d 6174   inverse Kinemat
+0000e040: 6963 7320 0a63 6c61 7373 2049 6e76 6572  ics .class Inver
+0000e050: 7365 4b69 6e65 6d61 7469 6373 4e75 6d65  seKinematicsNume
+0000e060: 7269 6361 6c28 293a 200a 2020 2020 2320  rical(): .    # 
+0000e070: 696e 6974 6961 6c69 7a65 2073 7973 7465  initialize syste
+0000e080: 6d0a 2020 2020 232a 2a63 6c61 7373 4675  m.    #**classFu
+0000e090: 6e63 7469 6f6e 3a20 696e 6974 6961 6c69  nction: initiali
+0000e0a0: 7a65 2052 6967 6964 426f 6479 496e 6572  ze RigidBodyIner
+0000e0b0: 7469 6120 7769 7468 2073 6361 6c61 7220  tia with scalar 
+0000e0c0: 6d61 7373 2c20 3378 3320 696e 6572 7469  mass, 3x3 inerti
+0000e0d0: 6154 656e 736f 7220 2877 2e72 2e74 2e20  aTensor (w.r.t. 
+0000e0e0: 7265 6665 7265 6e63 6520 706f 696e 7421  reference point!
+0000e0f0: 2121 2920 616e 6420 6365 6e74 6572 206f  !!) and center o
+0000e100: 6620 6d61 7373 2063 6f6d 0a20 2020 2023  f mass com.    #
+0000e110: 2a2a 696e 7075 743a 0a20 2020 2023 2020  **input:.    #  
+0000e120: 726f 626f 743a 2072 6f62 6f74 2063 6c61  robot: robot cla
+0000e130: 7373 0a20 2020 2023 2020 6a6f 696e 7453  ss.    #  jointS
+0000e140: 7469 6666 6e65 7373 3a20 7468 6520 7374  tiffness: the st
+0000e150: 6966 666e 6573 7320 7573 6564 2066 6f72  iffness used for
+0000e160: 2074 6865 2072 6f62 6f74 2773 206d 6f64   the robot's mod
+0000e170: 656c 206a 6f69 6e74 730a 2020 2020 2320  el joints.    # 
+0000e180: 2075 7365 5265 6e64 6572 6572 3a20 7768   useRenderer: wh
+0000e190: 656e 2073 6f6c 7669 6e67 2074 6865 2069  en solving the i
+0000e1a0: 6e76 6572 7365 206b 696e 656d 6174 6963  nverse kinematic
+0000e1b0: 7320 7468 6520 7265 6e64 6572 6572 2069  s the renderer i
+0000e1c0: 7320 7573 6564 2074 6f20 7368 6f77 2074  s used to show t
+0000e1d0: 6865 2073 7461 7274 696e 672f 656e 6420  he starting/end 
+0000e1e0: 0a20 2020 2023 2020 2020 2020 2020 2020  .    #          
+0000e1f0: 2020 2020 2063 6f6e 6669 6775 7261 7469       configurati
+0000e200: 6f6e 206f 6620 7468 6520 726f 626f 7420  on of the robot 
+0000e210: 7573 696e 6720 7468 6520 6772 6170 6869  using the graphi
+0000e220: 6373 206f 626a 6563 7473 2064 6566 696e  cs objects defin
+0000e230: 6465 6420 696e 2074 6865 2072 6f62 6f74  ded in the robot
+0000e240: 206f 626a 6563 740a 2020 2020 232a 2a61   object.    #**a
+0000e250: 7574 686f 723a 2050 6574 6572 204d 616e  uthor: Peter Man
+0000e260: 7a6c 0a20 2020 2064 6566 205f 5f69 6e69  zl.    def __ini
+0000e270: 745f 5f28 7365 6c66 2c20 726f 626f 742c  t__(self, robot,
+0000e280: 206a 6f69 6e74 5374 6966 666e 6573 7320   jointStiffness 
+0000e290: 3d20 3165 302c 2075 7365 5265 6e64 6572  = 1e0, useRender
+0000e2a0: 6572 3d46 616c 7365 2c20 666c 6167 4465  er=False, flagDe
+0000e2b0: 6275 673d 4661 6c73 652c 200a 2020 2020  bug=False, .    
+0000e2c0: 2020 2020 2020 2020 2020 2020 2075 7365               use
+0000e2d0: 416c 7465 726e 6174 6976 6543 6f6e 7374  AlternativeConst
+0000e2e0: 7261 696e 7473 3d46 616c 7365 293a 200a  raints=False): .
+0000e2f0: 2020 2020 2020 2020 7365 6c66 2e53 4320          self.SC 
+0000e300: 3d20 6578 7564 796e 2e53 7973 7465 6d43  = exudyn.SystemC
+0000e310: 6f6e 7461 696e 6572 2829 0a20 2020 2020  ontainer().     
+0000e320: 2020 2073 656c 662e 6d62 7349 4b20 3d20     self.mbsIK = 
+0000e330: 7365 6c66 2e53 432e 4164 6453 7973 7465  self.SC.AddSyste
+0000e340: 6d28 290a 2020 2020 2020 2020 7365 6c66  m().        self
+0000e350: 2e72 6f62 6f74 203d 2072 6f62 6f74 0a20  .robot = robot. 
+0000e360: 2020 2020 2020 2073 656c 662e 6e4c 696e         self.nLin
+0000e370: 6b73 203d 206c 656e 2873 656c 662e 726f  ks = len(self.ro
+0000e380: 626f 742e 6c69 6e6b 7329 0a20 2020 2020  bot.links).     
+0000e390: 2020 2073 656c 662e 7573 6552 656e 6465     self.useRende
+0000e3a0: 7265 7220 3d20 7573 6552 656e 6465 7265  rer = useRendere
+0000e3b0: 720a 2020 2020 2020 2020 7365 6c66 2e66  r.        self.f
+0000e3c0: 6c61 6744 6562 7567 203d 2066 6c61 6744  lagDebug = flagD
+0000e3d0: 6562 7567 0a20 2020 2020 2020 2073 656c  ebug.        sel
+0000e3e0: 662e 6570 7352 6f74 6174 696f 6e4d 6174  f.epsRotationMat
+0000e3f0: 7269 7820 3d20 3165 2d31 340a 2020 2020  rix = 1e-14.    
+0000e400: 2020 2020 7365 6c66 2e65 7073 536f 6c75      self.epsSolu
+0000e410: 7469 6f6e 203d 2031 652d 3134 0a20 2020  tion = 1e-14.   
+0000e420: 2020 2020 2073 656c 662e 7573 6541 6c74       self.useAlt
+0000e430: 6572 6e61 7469 7665 436f 6e73 7472 6169  ernativeConstrai
+0000e440: 6e74 7320 3d20 7573 6541 6c74 6572 6e61  nts = useAlterna
+0000e450: 7469 7665 436f 6e73 7472 6169 6e74 730a  tiveConstraints.
+0000e460: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0000e470: 2073 656c 662e 6f47 726f 756e 6420 3d20   self.oGround = 
+0000e480: 7365 6c66 2e6d 6273 494b 2e41 6464 4f62  self.mbsIK.AddOb
+0000e490: 6a65 6374 2865 6969 2e4f 626a 6563 7447  ject(eii.ObjectG
+0000e4a0: 726f 756e 6428 7265 6665 7265 6e63 6550  round(referenceP
+0000e4b0: 6f73 6974 696f 6e3d 6572 622e 4854 3274  osition=erb.HT2t
+0000e4c0: 7261 6e73 6c61 7469 6f6e 2872 6f62 6f74  ranslation(robot
+0000e4d0: 2e47 6574 4261 7365 4854 2829 292c 200a  .GetBaseHT()), .
+0000e4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e500: 2020 2020 2020 2020 2020 2020 2020 2376                #v
+0000e510: 6973 7561 6c69 7a61 7469 6f6e 3d56 4f62  isualization=VOb
+0000e520: 6a65 6374 4772 6f75 6e64 2867 7261 7068  jectGround(graph
+0000e530: 6963 7344 6174 613d 6772 6170 6869 6373  icsData=graphics
+0000e540: 4261 7365 4c69 7374 290a 2020 2020 2020  BaseList).      
+0000e550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e570: 2020 2020 2020 2020 2020 2020 2929 0a20              )). 
+0000e580: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0000e590: 7365 6c66 2e62 6173 654d 6172 6b65 7220  self.baseMarker 
+0000e5a0: 3d20 7365 6c66 2e6d 6273 494b 2e41 6464  = self.mbsIK.Add
+0000e5b0: 4d61 726b 6572 2865 6969 2e4d 6172 6b65  Marker(eii.Marke
+0000e5c0: 7242 6f64 7952 6967 6964 2862 6f64 794e  rBodyRigid(bodyN
+0000e5d0: 756d 6265 723d 7365 6c66 2e6f 4772 6f75  umber=self.oGrou
+0000e5e0: 6e64 2c20 6c6f 6361 6c50 6f73 6974 696f  nd, localPositio
+0000e5f0: 6e3d 5b30 2c30 2c30 5d29 290a 2020 2020  n=[0,0,0])).    
+0000e600: 2020 2020 7365 6c66 2e6d 4772 6f75 6e64      self.mGround
+0000e610: 4545 203d 2073 656c 662e 6d62 7349 4b2e  EE = self.mbsIK.
+0000e620: 4164 644d 6172 6b65 7228 6569 692e 4d61  AddMarker(eii.Ma
+0000e630: 726b 6572 426f 6479 5269 6769 6428 626f  rkerBodyRigid(bo
+0000e640: 6479 4e75 6d62 6572 3d73 656c 662e 6f47  dyNumber=self.oG
+0000e650: 726f 756e 642c 206c 6f63 616c 506f 7369  round, localPosi
+0000e660: 7469 6f6e 3d5b 302c 302c 305d 2929 0a20  tion=[0,0,0])). 
+0000e670: 2020 2020 2020 2073 656c 662e 546f 6f6c         self.Tool
+0000e680: 4854 203d 2072 6f62 6f74 2e74 6f6f 6c2e  HT = robot.tool.
+0000e690: 4854 0a20 2020 2020 2020 200a 2020 2020  HT.        .    
+0000e6a0: 2020 2020 6966 2065 6175 2e49 7356 616c      if eau.IsVal
+0000e6b0: 6964 5265 616c 496e 7428 6a6f 696e 7453  idRealInt(jointS
+0000e6c0: 7469 6666 6e65 7373 293a 2023 2062 7569  tiffness): # bui
+0000e6d0: 6c64 206c 6973 7420 6672 6f6d 2072 6561  ld list from rea
+0000e6e0: 6c0a 2020 2020 2020 2020 2020 2020 6a6f  l.            jo
+0000e6f0: 696e 7453 7469 6666 6e65 7373 203d 205b  intStiffness = [
+0000e700: 6a6f 696e 7453 7469 6666 6e65 7373 5d20  jointStiffness] 
+0000e710: 2a20 7365 6c66 2e6e 4c69 6e6b 7320 0a20  * self.nLinks . 
+0000e720: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0000e730: 0a20 2020 2020 2020 2023 2b2b 2b2b 2b2b  .        #++++++
+0000e740: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000e750: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000e760: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000e770: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+0000e780: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0a20  ++++++++++++++. 
+0000e790: 2020 2020 2020 2023 2062 7569 6c64 206b         # build k
+0000e7a0: 696e 656d 7469 6320 7472 6565 206d 6f64  inemtic tree mod
+0000e7b0: 656c 206f 6620 7468 6520 726f 626f 740a  el of the robot.
+0000e7c0: 2020 2020 2020 2020 7365 6c66 2e72 6f62          self.rob
+0000e7d0: 6f74 2e67 7261 7669 7479 203d 205b 302c  ot.gravity = [0,
+0000e7e0: 302c 305d 2020 2020 2320 6e6f 2067 7261  0,0]    # no gra
+0000e7f0: 7669 7479 206e 6565 6465 640a 2020 2020  vity needed.    
+0000e800: 2020 2020 2320 7365 6c66 2e4b 696e 656d      # self.Kinem
+0000e810: 6174 6963 5472 6565 203d 2073 656c 662e  aticTree = self.
+0000e820: 726f 626f 742e 4765 744b 696e 656d 6174  robot.GetKinemat
+0000e830: 6963 5472 6565 3636 2829 2023 206e 6f74  icTree66() # not
+0000e840: 2077 6f72 6b69 6e67 2066 6f72 206c 6f63   working for loc
+0000e850: 616c 4854 2028 7374 6444 4821 290a 2020  alHT (stdDH!).  
+0000e860: 2020 2020 2020 6c69 7374 4f6c 6443 6f6e        listOldCon
+0000e870: 7472 6f6c 203d 205b 4e6f 6e65 5d2a 7365  trol = [None]*se
+0000e880: 6c66 2e6e 4c69 6e6b 7320 2373 746f 7265  lf.nLinks #store
+0000e890: 2070 7265 7669 6f75 7320 5044 636f 6e74   previous PDcont
+0000e8a0: 726f 6c0a 2020 2020 2020 2020 666f 7220  rol.        for 
+0000e8b0: 6920 696e 2072 616e 6765 2873 656c 662e  i in range(self.
+0000e8c0: 6e4c 696e 6b73 293a 2020 2020 200a 2020  nLinks):     .  
+0000e8d0: 2020 2020 2020 2020 2020 6c69 7374 4f6c            listOl
+0000e8e0: 6443 6f6e 7472 6f6c 5b69 5d20 3d20 7365  dControl[i] = se
+0000e8f0: 6c66 2e72 6f62 6f74 2e6c 696e 6b73 5b69  lf.robot.links[i
+0000e900: 5d2e 5044 636f 6e74 726f 6c20 0a20 2020  ].PDcontrol .   
+0000e910: 2020 2020 2020 2020 2073 656c 662e 726f           self.ro
+0000e920: 626f 742e 6c69 6e6b 735b 695d 2e50 4463  bot.links[i].PDc
+0000e930: 6f6e 7472 6f6c 203d 2028 6a6f 696e 7453  ontrol = (jointS
+0000e940: 7469 6666 6e65 7373 5b69 5d2c 3029 0a0a  tiffness[i],0)..
+0000e950: 2020 2020 2020 2020 7365 6c66 2e72 6f62          self.rob
+0000e960: 6f74 4469 6374 203d 2073 656c 662e 726f  otDict = self.ro
+0000e970: 626f 742e 4372 6561 7465 4b69 6e65 6d61  bot.CreateKinema
+0000e980: 7469 6354 7265 6528 7365 6c66 2e6d 6273  ticTree(self.mbs
+0000e990: 494b 290a 2020 2020 2020 2020 0a20 2020  IK).        .   
+0000e9a0: 2020 2020 2073 656c 662e 6d54 6f6f 6c20       self.mTool 
+0000e9b0: 3d20 7365 6c66 2e6d 6273 494b 2e41 6464  = self.mbsIK.Add
+0000e9c0: 4d61 726b 6572 2865 6969 2e4d 6172 6b65  Marker(eii.Marke
+0000e9d0: 724b 696e 656d 6174 6963 5472 6565 5269  rKinematicTreeRi
+0000e9e0: 6769 6428 6f62 6a65 6374 4e75 6d62 6572  gid(objectNumber
+0000e9f0: 3d73 656c 662e 726f 626f 7444 6963 745b  =self.robotDict[
+0000ea00: 276f 626a 6563 744b 696e 656d 6174 6963  'objectKinematic
+0000ea10: 5472 6565 275d 2c20 6c69 6e6b 4e75 6d62  Tree'], linkNumb
+0000ea20: 6572 3d73 656c 662e 6e4c 696e 6b73 2d31  er=self.nLinks-1
+0000ea30: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
+0000ea40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea70: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+0000ea80: 6361 6c50 6f73 6974 696f 6e3d 6572 622e  calPosition=erb.
+0000ea90: 4854 3274 7261 6e73 6c61 7469 6f6e 2873  HT2translation(s
+0000eaa0: 656c 662e 726f 626f 742e 746f 6f6c 2e48  elf.robot.tool.H
+0000eab0: 5429 2929 0a20 2020 2020 2020 200a 2020  T))).        .  
+0000eac0: 2020 2020 2020 7365 6c66 2e73 546f 6f6c        self.sTool
+0000ead0: 5472 616e 7320 3d20 7365 6c66 2e6d 6273  Trans = self.mbs
+0000eae0: 494b 2e41 6464 5365 6e73 6f72 2865 6969  IK.AddSensor(eii
+0000eaf0: 2e53 656e 736f 724d 6172 6b65 7228 6d61  .SensorMarker(ma
+0000eb00: 726b 6572 4e75 6d62 6572 3d73 656c 662e  rkerNumber=self.
+0000eb10: 6d54 6f6f 6c2c 200a 2020 2020 2020 2020  mTool, .        
+0000eb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb40: 2020 2020 2020 6f75 7470 7574 5661 7269        outputVari
+0000eb50: 6162 6c65 5479 7065 3d65 7875 6479 6e2e  ableType=exudyn.
+0000eb60: 4f75 7470 7574 5661 7269 6162 6c65 5479  OutputVariableTy
+0000eb70: 7065 2e50 6f73 6974 696f 6e2c 2073 746f  pe.Position, sto
+0000eb80: 7265 496e 7465 726e 616c 3d46 616c 7365  reInternal=False
+0000eb90: 2929 0a20 2020 2020 2020 200a 2020 2020  )).        .    
+0000eba0: 2020 2020 7365 6c66 2e73 546f 6f6c 526f      self.sToolRo
+0000ebb0: 7420 3d20 7365 6c66 2e6d 6273 494b 2e41  t = self.mbsIK.A
+0000ebc0: 6464 5365 6e73 6f72 2865 6969 2e53 656e  ddSensor(eii.Sen
+0000ebd0: 736f 724d 6172 6b65 7228 6d61 726b 6572  sorMarker(marker
+0000ebe0: 4e75 6d62 6572 3d73 656c 662e 6d54 6f6f  Number=self.mToo
+0000ebf0: 6c2c 200a 2020 2020 2020 2020 2020 2020  l, .            
+0000ec00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec20: 6f75 7470 7574 5661 7269 6162 6c65 5479  outputVariableTy
+0000ec30: 7065 3d65 7875 6479 6e2e 4f75 7470 7574  pe=exudyn.Output
+0000ec40: 5661 7269 6162 6c65 5479 7065 2e52 6f74  VariableType.Rot
+0000ec50: 6174 696f 6e4d 6174 7269 782c 2073 746f  ationMatrix, sto
+0000ec60: 7265 496e 7465 726e 616c 3d46 616c 7365  reInternal=False
+0000ec70: 2929 0a0a 2020 2020 0a20 2020 2020 2020  ))..    .       
+0000ec80: 2069 6620 313a 2023 200a 2020 2020 2020   if 1: # .      
+0000ec90: 2020 2020 2020 7365 6c66 2e63 6f6e 7374        self.const
+0000eca0: 7261 696e 7454 6f6f 6c3d 2073 656c 662e  raintTool= self.
+0000ecb0: 6d62 7349 4b2e 4164 644f 626a 6563 7428  mbsIK.AddObject(
+0000ecc0: 6569 692e 4765 6e65 7269 634a 6f69 6e74  eii.GenericJoint
+0000ecd0: 286d 6172 6b65 724e 756d 6265 7273 3d5b  (markerNumbers=[
+0000ece0: 7365 6c66 2e6d 4772 6f75 6e64 4545 202c  self.mGroundEE ,
+0000ecf0: 2073 656c 662e 6d54 6f6f 6c5d 2c0a 2020   self.mTool],.  
+0000ed00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed30: 2072 6f74 6174 696f 6e4d 6172 6b65 7231   rotationMarker1
+0000ed40: 3d65 7262 2e48 5432 726f 7461 7469 6f6e  =erb.HT2rotation
+0000ed50: 4d61 7472 6978 2873 656c 662e 726f 626f  Matrix(self.robo
+0000ed60: 742e 746f 6f6c 2e48 5429 2c20 0a20 2020  t.tool.HT), .   
+0000ed70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eda0: 616c 7465 726e 6174 6976 6543 6f6e 7374  alternativeConst
+0000edb0: 7261 696e 7473 203d 2073 656c 662e 7573  raints = self.us
+0000edc0: 6541 6c74 6572 6e61 7469 7665 436f 6e73  eAlternativeCons
+0000edd0: 7472 6169 6e74 7329 290a 0a20 2020 2020  traints))..     
+0000ede0: 2020 2065 6c73 653a 200a 2020 2020 2020     else: .      
+0000edf0: 2020 2020 2020 7365 6c66 2e63 6f6e 7374        self.const
+0000ee00: 7261 696e 7454 6f6f 6c3d 2073 656c 662e  raintTool= self.
+0000ee10: 6d62 7349 4b2e 4164 644f 626a 6563 7428  mbsIK.AddObject(
+0000ee20: 6569 692e 5269 6769 6442 6f64 7953 7072  eii.RigidBodySpr
+0000ee30: 696e 6744 616d 7065 7228 6d61 726b 6572  ingDamper(marker
+0000ee40: 4e75 6d62 6572 733d 5b73 656c 662e 6d47  Numbers=[self.mG
+0000ee50: 726f 756e 6445 4520 2c20 7365 6c66 2e6d  roundEE , self.m
+0000ee60: 546f 6f6c 5d2c 200a 2020 2020 2020 2020  Tool], .        
+0000ee70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eea0: 2020 2020 2020 7374 6966 666e 6573 733d        stiffness=
+0000eeb0: 6e70 2e65 7965 2836 292a 3165 3820 2c20  np.eye(6)*1e8 , 
+0000eec0: 6461 6d70 696e 6720 3d20 6e70 2e65 7965  damping = np.eye
+0000eed0: 2836 292a 3165 332c 200a 2020 2020 2020  (6)*1e3, .      
+0000eee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef10: 2020 2020 2020 2020 726f 7461 7469 6f6e          rotation
+0000ef20: 4d61 726b 6572 313d 6572 622e 4854 3272  Marker1=erb.HT2r
+0000ef30: 6f74 6174 696f 6e4d 6174 7269 7828 7365  otationMatrix(se
+0000ef40: 6c66 2e72 6f62 6f74 2e74 6f6f 6c2e 4854  lf.robot.tool.HT
+0000ef50: 2929 2920 0a0a 2020 2020 2020 2020 2372  ))) ..        #r
+0000ef60: 6573 746f 7265 2050 4463 6f6e 7472 6f6c  estore PDcontrol
+0000ef70: 2066 6f72 2072 6f62 6f74 2120 2020 2020   for robot!     
+0000ef80: 2020 200a 2020 2020 2020 2020 666f 7220     .        for 
+0000ef90: 6920 696e 2072 616e 6765 2873 656c 662e  i in range(self.
+0000efa0: 6e4c 696e 6b73 293a 2020 2020 200a 2020  nLinks):     .  
+0000efb0: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
+0000efc0: 6f62 6f74 2e6c 696e 6b73 5b69 5d2e 5044  obot.links[i].PD
+0000efd0: 636f 6e74 726f 6c20 3d20 6c69 7374 4f6c  control = listOl
+0000efe0: 6443 6f6e 7472 6f6c 5b69 5d0a 2020 2020  dControl[i].    
+0000eff0: 2020 2020 0a20 2020 2020 2020 200a 2020      .        .  
+0000f000: 2020 2020 2020 2320 7365 7420 7369 6d75        # set simu
+0000f010: 6c61 7469 6f6e 2073 6574 7469 6e67 7320  lation settings 
+0000f020: 666f 7220 7374 6174 6963 2073 6f6c 7665  for static solve
+0000f030: 7220 0a20 2020 2020 2020 2073 656c 662e  r .        self.
+0000f040: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+0000f050: 6773 203d 2065 7875 6479 6e2e 5369 6d75  gs = exudyn.Simu
+0000f060: 6c61 7469 6f6e 5365 7474 696e 6773 2829  lationSettings()
+0000f070: 0a20 2020 2020 2020 2073 656c 662e 7369  .        self.si
+0000f080: 6d75 6c61 7469 6f6e 5365 7474 696e 6773  mulationSettings
+0000f090: 2e73 6f6c 7574 696f 6e53 6574 7469 6e67  .solutionSetting
+0000f0a0: 732e 7772 6974 6553 6f6c 7574 696f 6e54  s.writeSolutionT
+0000f0b0: 6f46 696c 6520 3d20 4661 6c73 650a 2020  oFile = False.  
+0000f0c0: 2020 2020 2020 7365 6c66 2e73 696d 756c        self.simul
+0000f0d0: 6174 696f 6e53 6574 7469 6e67 732e 736f  ationSettings.so
+0000f0e0: 6c75 7469 6f6e 5365 7474 696e 6773 2e62  lutionSettings.b
+0000f0f0: 696e 6172 7953 6f6c 7574 696f 6e46 696c  inarySolutionFil
+0000f100: 6520 3d20 4661 6c73 650a 2020 2020 2020  e = False.      
+0000f110: 2020 7365 6c66 2e73 696d 756c 6174 696f    self.simulatio
+0000f120: 6e53 6574 7469 6e67 732e 6c69 6e65 6172  nSettings.linear
+0000f130: 536f 6c76 6572 5365 7474 696e 6773 2e69  SolverSettings.i
+0000f140: 676e 6f72 6553 696e 6775 6c61 724a 6163  gnoreSingularJac
+0000f150: 6f62 6961 6e20 3d20 5472 7565 0a20 2020  obian = True.   
+0000f160: 2020 2020 2073 656c 662e 7369 6d75 6c61       self.simula
+0000f170: 7469 6f6e 5365 7474 696e 6773 2e64 6973  tionSettings.dis
+0000f180: 706c 6179 436f 6d70 7574 6174 696f 6e54  playComputationT
+0000f190: 696d 6520 3d20 4661 6c73 650a 2020 2020  ime = False.    
+0000f1a0: 2020 2020 7365 6c66 2e73 696d 756c 6174      self.simulat
+0000f1b0: 696f 6e53 6574 7469 6e67 732e 6469 7370  ionSettings.disp
+0000f1c0: 6c61 7953 7461 7469 7374 6963 7320 3d20  layStatistics = 
+0000f1d0: 4661 6c73 650a 2020 2020 2020 2020 0a20  False.        . 
+0000f1e0: 2020 2020 2020 2073 656c 662e 7369 6d75         self.simu
+0000f1f0: 6c61 7469 6f6e 5365 7474 696e 6773 2e73  lationSettings.s
+0000f200: 7461 7469 6353 6f6c 7665 722e 6e65 7774  taticSolver.newt
+0000f210: 6f6e 2e6d 6178 4974 6572 6174 696f 6e73  on.maxIterations
+0000f220: 203d 2035 3020 236f 7269 6769 6e61 6c3a   = 50 #original:
+0000f230: 2035 3030 0a20 2020 2020 2020 2073 656c   500.        sel
+0000f240: 662e 7369 6d75 6c61 7469 6f6e 5365 7474  f.simulationSett
+0000f250: 696e 6773 2e73 7461 7469 6353 6f6c 7665  ings.staticSolve
+0000f260: 722e 6164 6170 7469 7665 5374 6570 203d  r.adaptiveStep =
+0000f270: 2054 7275 650a 2020 2020 2020 2020 7365   True.        se
+0000f280: 6c66 2e73 696d 756c 6174 696f 6e53 6574  lf.simulationSet
+0000f290: 7469 6e67 732e 7374 6174 6963 536f 6c76  tings.staticSolv
+0000f2a0: 6572 2e76 6572 626f 7365 4d6f 6465 203d  er.verboseMode =
+0000f2b0: 2030 0a20 2020 2020 2020 2073 656c 662e   0.        self.
+0000f2c0: 7369 6d75 6c61 7469 6f6e 5365 7474 696e  simulationSettin
+0000f2d0: 6773 2e64 6973 706c 6179 476c 6f62 616c  gs.displayGlobal
+0000f2e0: 5469 6d65 7273 203d 2030 0a20 2020 2020  Timers = 0.     
+0000f2f0: 2020 2023 7365 6c66 2e73 696d 756c 6174     #self.simulat
+0000f300: 696f 6e53 6574 7469 6e67 732e 7374 6174  ionSettings.stat
+0000f310: 6963 536f 6c76 6572 2e73 7461 6269 6c69  icSolver.stabili
+0000f320: 7a65 724f 4445 3274 6572 6d20 3d20 3165  zerODE2term = 1e
+0000f330: 2d31 0a20 2020 2020 2020 2073 656c 662e  -1.        self.
+0000f340: 7374 6174 6963 536f 6c76 6572 203d 2065  staticSolver = e
+0000f350: 7875 6479 6e2e 4d61 696e 536f 6c76 6572  xudyn.MainSolver
+0000f360: 5374 6174 6963 2829 0a20 2020 2020 2020  Static().       
+0000f370: 2023 2073 7061 7273 6520 736f 6c76 6572   # sparse solver
+0000f380: 2073 6574 7469 6e67 7320 6172 6520 6661   settings are fa
+0000f390: 7374 6572 2066 6f72 2072 6564 756e 6461  ster for redunda
+0000f3a0: 6e74 206d 6273 0a20 2020 2020 2020 2073  nt mbs.        s
+0000f3b0: 656c 662e 6d62 7349 4b2e 4173 7365 6d62  elf.mbsIK.Assemb
+0000f3c0: 6c65 2829 2020 200a 2020 2020 2020 2020  le()   .        
+0000f3d0: 7365 6c66 2e73 7973 5374 6174 654c 6973  self.sysStateLis
+0000f3e0: 7420 3d20 7365 6c66 2e6d 6273 494b 2e73  t = self.mbsIK.s
+0000f3f0: 7973 7465 6d44 6174 612e 4765 7453 7973  ystemData.GetSys
+0000f400: 7465 6d53 7461 7465 2829 0a0a 2020 2020  temState()..    
+0000f410: 6465 6620 5f5f 6465 665f 5f28 7365 6c66  def __def__(self
+0000f420: 293a 0a20 2020 2020 2020 2073 656c 662e  ):.        self.
+0000f430: 7374 6174 6963 536f 6c76 6572 2e46 696e  staticSolver.Fin
+0000f440: 616c 697a 6553 6f6c 7665 7228 7365 6c66  alizeSolver(self
+0000f450: 2e6d 6273 494b 2c20 7365 6c66 2e73 696d  .mbsIK, self.sim
+0000f460: 756c 6174 696f 6e53 6574 7469 6e67 7329  ulationSettings)
+0000f470: 0a20 2020 2020 2020 200a 2020 2020 2320  .        .    # 
+0000f480: 6465 6275 6767 696e 6720 6865 6c70 6572  debugging helper
+0000f490: 2066 756e 6374 696f 6e20 0a20 2020 2064   function .    d
+0000f4a0: 6566 2063 7265 6174 6556 6563 746f 7228  ef createVector(
+0000f4b0: 7030 2c20 7030 3129 3a20 0a20 2020 2020  p0, p01): .     
+0000f4c0: 2020 2078 203d 205b 7030 5b30 5d2c 2070     x = [p0[0], p
+0000f4d0: 305b 305d 202b 2070 3031 5b30 5d5d 0a20  0[0] + p01[0]]. 
+0000f4e0: 2020 2020 2020 2079 203d 205b 7030 5b31         y = [p0[1
+0000f4f0: 5d2c 2070 305b 315d 202b 2070 3031 5b31  ], p0[1] + p01[1
+0000f500: 5d5d 0a20 2020 2020 2020 207a 203d 205b  ]].        z = [
+0000f510: 7030 5b32 5d2c 2070 305b 325d 202b 2070  p0[2], p0[2] + p
+0000f520: 3031 5b32 5d5d 0a20 2020 2020 2020 2072  01[2]].        r
+0000f530: 6574 7572 6e20 782c 2079 2c20 7a0a 0a0a  eturn x, y, z...
+0000f540: 2020 2020 232a 2a63 6c61 7373 4675 6e63      #**classFunc
+0000f550: 7469 6f6e 3a20 5574 696c 6974 7920 6675  tion: Utility fu
+0000f560: 6e63 7469 6f6e 2074 6f20 6765 7420 6375  nction to get cu
+0000f570: 7272 656e 7420 486f 6d6f 6765 6e65 6f75  rrent Homogeneou
+0000f580: 7320 7472 616e 7366 6f72 6d61 7469 6f6e  s transformation
+0000f590: 206f 6620 7468 6520 726f 626f 7420 746f   of the robot to
+0000f5a0: 2063 6865 636b 2069 6e76 6572 7365 204b   check inverse K
+0000f5b0: 696e 656d 6174 6963 7320 736f 6c75 7469  inematics soluti
+0000f5c0: 6f6e 0a20 2020 2023 202a 2a20 6f75 7470  on.    # ** outp
+0000f5d0: 7574 3a20 0a20 2020 2023 2020 2054 3a20  ut: .    #   T: 
+0000f5e0: 3478 3420 686f 6d6f 6765 6e65 6f75 7320  4x4 homogeneous 
+0000f5f0: 5472 616e 7366 6f72 6d61 7469 6f6e 206d  Transformation m
+0000f600: 6174 7269 7820 6f66 2074 6865 2063 7572  atrix of the cur
+0000f610: 7265 6e74 2054 4350 2070 6f73 650a 2020  rent TCP pose.  
+0000f620: 2020 6465 6620 4765 7443 7572 7265 6e74    def GetCurrent
+0000f630: 526f 626f 7448 5428 7365 6c66 293a 200a  RobotHT(self): .
+0000f640: 2020 2020 2020 2020 2320 7365 6c66 2e72          # self.r
+0000f650: 6f62 6f74 2e4a 6f69 6e74 4854 2871 295b  obot.JointHT(q)[
+0000f660: 2d31 5d20 2040 2073 656c 662e 726f 626f  -1]  @ self.robo
+0000f670: 742e 746f 6f6c 2e48 5420 2320 7072 6f76  t.tool.HT # prov
+0000f680: 6965 6465 7320 7361 6d65 2066 756e 6374  iedes same funct
+0000f690: 696f 6e61 6c69 7479 2061 7320 7265 6164  ionality as read
+0000f6a0: 696e 6720 7365 6e73 6f72 732e 2e2e 0a20  ing sensors.... 
+0000f6b0: 2020 2020 2020 2070 6f73 464b 696e 6520         posFKine 
+0000f6c0: 3d20 7365 6c66 2e6d 6273 494b 2e47 6574  = self.mbsIK.Get
+0000f6d0: 5365 6e73 6f72 5661 6c75 6573 2873 656c  SensorValues(sel
+0000f6e0: 662e 7354 6f6f 6c54 7261 6e73 2920 0a20  f.sToolTrans) . 
+0000f6f0: 2020 2020 2020 2052 6f74 466b 696e 6520         RotFkine 
+0000f700: 3d20 7365 6c66 2e6d 6273 494b 2e47 6574  = self.mbsIK.Get
+0000f710: 5365 6e73 6f72 5661 6c75 6573 2873 656c  SensorValues(sel
+0000f720: 662e 7354 6f6f 6c52 6f74 292e 7265 7368  f.sToolRot).resh
+0000f730: 6170 6528 2833 2c33 2929 0a20 2020 2020  ape((3,3)).     
+0000f740: 2020 2054 203d 2065 7262 2e48 6f6d 6f67     T = erb.Homog
+0000f750: 656e 656f 7573 5472 616e 7366 6f72 6d61  eneousTransforma
+0000f760: 7469 6f6e 2852 6f74 466b 696e 652c 2070  tion(RotFkine, p
+0000f770: 6f73 464b 696e 6529 2023 2067 6c6f 6261  osFKine) # globa
+0000f780: 6c20 4854 0a20 2020 2020 2020 2072 6574  l HT.        ret
+0000f790: 7572 6e20 540a 0a20 2020 2023 2a2a 636c  urn T..    #**cl
+0000f7a0: 6173 7346 756e 6374 696f 6e3a 200a 2020  assFunction: .  
+0000f7b0: 2020 232a 2a69 6e70 7574 3a0a 2020 2020    #**input:.    
+0000f7c0: 2320 2054 313a 2034 7834 2068 6f6d 6f67  #  T1: 4x4 homog
+0000f7d0: 656e 656f 7573 2074 7261 6e73 666f 726d  eneous transform
+0000f7e0: 6174 696f 6e20 6d61 7472 6978 2072 6570  ation matrix rep
+0000f7f0: 7265 7365 6e74 696e 6720 7468 6520 6669  resenting the fi
+0000f800: 7273 7420 506f 7365 0a20 2020 2023 2020  rst Pose.    #  
+0000f810: 5432 3a20 3478 3420 686f 6d6f 6765 6e65  T2: 4x4 homogene
+0000f820: 6f75 7320 7472 616e 7366 6f72 6d61 7469  ous transformati
+0000f830: 6f6e 206d 6174 7269 7820 7265 7072 6573  on matrix repres
+0000f840: 656e 7469 6e67 2074 6865 2073 6563 6f6e  enting the secon
+0000f850: 6420 506f 7365 0a20 2020 2023 2020 726f  d Pose.    #  ro
+0000f860: 7453 7465 703a 2074 6865 206d 6178 2e20  tStep: the max. 
+0000f870: 7369 7a65 206f 6620 7374 6570 7320 746f  size of steps to
+0000f880: 2074 616b 6520 666f 7220 7468 6520 6f72   take for the or
+0000f890: 6965 6e74 6174 696f 6e0a 2020 2020 2320  ientation.    # 
+0000f8a0: 206d 696e 5374 6570 733a 206d 696e 696d   minSteps: minim
+0000f8b0: 756d 206e 756d 6265 7220 6f66 2073 7562  um number of sub
+0000f8c0: 7374 6570 7320 746f 2069 6e74 6572 706f  steps to interpo
+0000f8d0: 6c61 7465 0a20 2020 2023 2a2a 6f75 7470  late.    #**outp
+0000f8e0: 7574 3a20 0a20 2020 2023 2054 3a20 6120  ut: .    # T: a 
+0000f8f0: 4c69 7374 206f 6620 686f 6d6f 6765 6e65  List of homogene
+0000f900: 6f75 7320 5472 616e 7366 6f72 6d61 7469  ous Transformati
+0000f910: 6f6e 7320 666f 7220 6561 6368 2073 7465  ons for each ste
+0000f920: 7020 6265 7477 6565 6e0a 2020 2020 232a  p between.    #*
+0000f930: 2a61 7574 686f 723a 2050 6574 6572 204d  *author: Peter M
+0000f940: 616e 7a6c 0a20 2020 2023 2a2a 6e6f 7465  anzl.    #**note
+0000f950: 733a 2073 7469 6c6c 2075 6e64 6572 2064  s: still under d
+0000f960: 6576 656c 6f70 6d65 6e74 3b20 696e 7465  evelopment; inte
+0000f970: 7270 6f6c 6174 696f 6e20 6d61 7920 6265  rpolation may be
+0000f980: 2063 6861 6e67 6564 2074 6f20 7573 696e   changed to usin
+0000f990: 6720 6c6f 6753 4533 0a20 2020 2064 6566  g logSE3.    def
+0000f9a0: 2049 6e74 6572 706f 6c61 7465 4854 7328   InterpolateHTs(
+0000f9b0: 7365 6c66 2c20 5431 2c20 5432 2c20 726f  self, T1, T2, ro
+0000f9c0: 7453 7465 703d 6e70 2e70 692f 3136 2c20  tStep=np.pi/16, 
+0000f9d0: 6d69 6e53 7465 7073 203d 2031 293a 200a  minSteps = 1): .
+0000f9e0: 2020 2020 2020 2020 5231 2c20 7431 203d          R1, t1 =
+0000f9f0: 2054 315b 3a33 2c3a 335d 2c20 6572 622e   T1[:3,:3], erb.
+0000fa00: 4854 3274 7261 6e73 6c61 7469 6f6e 2854  HT2translation(T
+0000fa10: 3129 0a20 2020 2020 2020 2052 322c 2074  1).        R2, t
+0000fa20: 3220 3d20 5432 5b3a 332c 3a33 5d2c 2065  2 = T2[:3,:3], e
+0000fa30: 7262 2e48 5432 7472 616e 736c 6174 696f  rb.HT2translatio
+0000fa40: 6e28 5432 290a 2020 2020 2020 2020 7431  n(T2).        t1
+0000fa50: 3220 3d20 7432 202d 2074 310a 2020 2020  2 = t2 - t1.    
+0000fa60: 2020 2020 5231 3220 3d20 6e70 2e74 7261      R12 = np.tra
+0000fa70: 6e73 706f 7365 2852 3129 2040 2052 320a  nspose(R1) @ R2.
+0000fa80: 2020 2020 2020 2020 726f 7431 3220 3d20          rot12 = 
+0000fa90: 6572 622e 526f 7461 7469 6f6e 4d61 7472  erb.RotationMatr
+0000faa0: 6978 3252 6f74 6174 696f 6e56 6563 746f  ix2RotationVecto
+0000fab0: 7228 5231 3229 0a20 2020 2020 2020 2072  r(R12).        r
+0000fac0: 6f74 416e 6720 3d20 6e70 2e6c 696e 616c  otAng = np.linal
+0000fad0: 672e 6e6f 726d 2872 6f74 3132 2c20 3229  g.norm(rot12, 2)
+0000fae0: 2023 2072 6f74 6174 696f 6e20 7665 6374   # rotation vect
+0000faf0: 6f72 2069 7320 616e 676c 6520 2a20 6e6f  or is angle * no
+0000fb00: 726d 616c 697a 6564 2072 6f74 6174 696f  rmalized rotatio
+0000fb10: 6e20 6178 6973 200a 0a20 2020 2020 2020  n axis ..       
+0000fb20: 2023 4445 4c45 5445 2c20 6e6f 7420 6e65   #DELETE, not ne
+0000fb30: 6564 6564 2061 6e79 206d 6f72 6520 6475  eded any more du
+0000fb40: 6520 746f 2069 6d70 726f 7665 6420 526f  e to improved Ro
+0000fb50: 7461 7469 6f6e 4d61 7472 6978 3252 6f74  tationMatrix2Rot
+0000fb60: 6174 696f 6e56 6563 746f 7220 200a 2020  ationVector  .  
+0000fb70: 2020 2020 2020 2320 6966 2074 6869 7320        # if this 
+0000fb80: 6973 2074 6865 2063 6173 652c 2074 6865  is the case, the
+0000fb90: 6e20 7477 6f20 6178 6573 2061 7265 2066  n two axes are f
+0000fba0: 6c69 7070 6564 3b20 0a20 2020 2020 2020  lipped; .       
+0000fbb0: 2023 2074 6869 7320 6361 6e20 6861 7070   # this can happ
+0000fbc0: 656e 2069 6e20 7468 6520 6765 6e65 7269  en in the generi
+0000fbd0: 6320 6a6f 696e 7420 7769 7468 2074 6865  c joint with the
+0000fbe0: 2073 7461 7469 6320 736f 6c76 6572 2061   static solver a
+0000fbf0: 6e64 2063 6f72 7265 7370 6f6e 6420 0a20  nd correspond . 
+0000fc00: 2020 2020 2020 2023 2074 6f20 6120 3138         # to a 18
+0000fc10: 30c2 b020 726f 7461 7469 6f6e 2061 726f  0.. rotation aro
+0000fc20: 756e 6420 7468 6520 6178 6973 2077 6974  und the axis wit
+0000fc30: 6820 656e 7472 7920 3120 696e 2074 6865  h entry 1 in the
+0000fc40: 2072 6f74 6174 696f 6e20 6d61 7472 6978   rotation matrix
+0000fc50: 0a20 2020 2020 2020 2023 2069 6620 6162  .        # if ab
+0000fc60: 7328 6e70 2e74 7261 6365 2852 3132 2920  s(np.trace(R12) 
+0000fc70: 2b20 3129 203c 3d20 7365 6c66 2e65 7073  + 1) <= self.eps
+0000fc80: 526f 7461 7469 6f6e 4d61 7472 6978 3a20  RotationMatrix: 
+0000fc90: 0a20 2020 2020 2020 2023 2020 2020 2052  .        #     R
+0000fca0: 3132 203d 206e 702e 726f 756e 6428 5231  12 = np.round(R1
+0000fcb0: 322c 2031 3229 0a20 2020 2020 2020 2023  2, 12).        #
+0000fcc0: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
+0000fcd0: 6e67 6528 3329 3a20 0a20 2020 2020 2020  nge(3): .       
+0000fce0: 2023 2020 2020 2020 2020 2069 6620 6162   #         if ab
+0000fcf0: 7328 5231 325b 692c 695d 2d31 2920 3c3d  s(R12[i,i]-1) <=
+0000fd00: 2073 656c 662e 6570 7352 6f74 6174 696f   self.epsRotatio
+0000fd10: 6e4d 6174 7269 783a 2072 6f74 3132 5b69  nMatrix: rot12[i
+0000fd20: 5d20 3d20 310a 2020 2020 2020 2020 2320  ] = 1.        # 
+0000fd30: 2020 2020 726f 7431 3220 2a3d 206e 702e      rot12 *= np.
+0000fd40: 7069 0a20 2020 2020 2020 2023 2020 2020  pi.        #    
+0000fd50: 2072 6f74 416e 6720 3d20 6e70 2e70 690a   rotAng = np.pi.
+0000fd60: 0a20 2020 2020 2020 206e 203d 206d 696e  .        n = min
+0000fd70: 286d 696e 5374 6570 732c 2031 2b69 6e74  (minSteps, 1+int
+0000fd80: 2872 6f74 416e 672f 726f 7453 7465 7029  (rotAng/rotStep)
+0000fd90: 2920 2320 6e75 6d62 6572 206f 6620 7374  ) # number of st
+0000fda0: 6570 730a 2020 2020 2020 2020 5420 3d20  eps.        T = 
+0000fdb0: 5b5d 0a20 2020 2020 2020 2066 6f72 2069  [].        for i
+0000fdc0: 2069 6e20 7261 6e67 6528 6e29 3a20 0a20   in range(n): . 
+0000fdd0: 2020 2020 2020 2020 2020 2072 6f74 6920             roti 
+0000fde0: 3d20 726f 7431 322a 2869 2b31 292f 6e0a  = rot12*(i+1)/n.
+0000fdf0: 2020 2020 2020 2020 2020 2020 5269 203d              Ri =
+0000fe00: 2052 3120 4020 6572 622e 526f 7461 7469   R1 @ erb.Rotati
+0000fe10: 6f6e 5665 6374 6f72 3252 6f74 6174 696f  onVector2Rotatio
+0000fe20: 6e4d 6174 7269 7828 726f 7469 290a 2020  nMatrix(roti).  
+0000fe30: 2020 2020 2020 2020 2020 2320 5269 203d            # Ri =
+0000fe40: 2052 6920 2f6e 702e 6c69 6e61 6c67 2e64   Ri /np.linalg.d
+0000fe50: 6574 2852 6929 2023 2061 766f 6964 0a20  et(Ri) # avoid. 
+0000fe60: 2020 2020 2020 2020 2020 2074 6920 3d20             ti = 
+0000fe70: 7431 202b 2028 7432 2d74 3129 2a28 692b  t1 + (t2-t1)*(i+
+0000fe80: 3129 2f6e 200a 2020 2020 2020 2020 2020  1)/n .          
+0000fe90: 2020 5469 203d 2065 7262 2e48 6f6d 6f67    Ti = erb.Homog
+0000fea0: 656e 656f 7573 5472 616e 7366 6f72 6d61  eneousTransforma
+0000feb0: 7469 6f6e 2852 692c 2074 6929 2020 2020  tion(Ri, ti)    
+0000fec0: 0a20 2020 2020 2020 2020 2020 2054 202b  .            T +
+0000fed0: 3d20 5b54 695d 0a20 2020 2020 2020 2054  = [Ti].        T
+0000fee0: 202b 3d20 5b54 325d 2023 2074 6f20 7361   += [T2] # to sa
+0000fef0: 7469 7366 7920 7468 6520 626f 756e 6472  tisfy the boundr
+0000ff00: 7920 636f 6e64 6974 696f 6e0a 2020 2020  y condition.    
+0000ff10: 2020 2020 7265 7475 726e 2054 0a20 2020      return T.   
+0000ff20: 200a 2020 2020 232a 2a63 6c61 7373 4675   .    #**classFu
+0000ff30: 6e63 7469 6f6e 3a20 5468 6973 204d 6574  nction: This Met
+0000ff40: 686f 6420 6361 6e20 6265 2075 7365 6420  hod can be used 
+0000ff50: 746f 2073 6f6c 7665 2074 6865 2069 6e76  to solve the inv
+0000ff60: 6572 7365 206b 696e 656d 6174 6963 7320  erse kinematics 
+0000ff70: 7072 6f62 6c65 6d20 6279 2073 6f6c 7669  problem by solvi
+0000ff80: 6e67 200a 2020 2020 2320 2020 2020 2020  ng .    #       
+0000ff90: 2020 2020 2074 6865 2073 7461 7469 6320       the static 
+0000ffa0: 7072 6f62 6c65 6d20 6f66 2061 2073 6572  problem of a ser
+0000ffb0: 6961 6c20 726f 626f 7420 7573 696e 6720  ial robot using 
+0000ffc0: 7374 6570 7320 746f 2069 6e74 6572 706f  steps to interpo
+0000ffd0: 6c61 7465 2062 6574 7765 656e 2073 7461  late between sta
+0000ffe0: 7274 2061 6e64 2065 6e64 2070 6f73 6974  rt and end posit
+0000fff0: 696f 6e20 636c 6f73 6520 746f 2074 6865  ion close to the
+00010000: 2066 756e 6374 696f 6e20 536f 6c76 652e   function Solve.
+00010010: 200a 2020 2020 2320 2020 2020 2020 2020   .    #         
+00010020: 2020 2054 6869 7320 6865 6c70 7320 7468     This helps th
+00010030: 6520 6675 6e63 7469 6f6e 2053 6f6c 7665  e function Solve
+00010040: 2829 2074 6f20 6669 6e64 2074 6865 2063  () to find the c
+00010050: 6f72 7265 6374 2073 6f6c 7574 696f 6e73  orrect solutions
+00010060: 2e20 0a20 2020 2023 2a2a 696e 7075 743a  . .    #**input:
+00010070: 0a20 2020 2023 2020 543a 2074 6865 2034  .    #  T: the 4
+00010080: 7834 2068 6f6d 6f67 656e 656f 7573 2074  x4 homogeneous t
+00010090: 7261 6e73 666f 726d 6174 696f 6e20 6d61  ransformation ma
+000100a0: 7472 6978 2072 6570 7265 7365 6e74 696e  trix representin
+000100b0: 6720 7468 6520 6465 7369 7265 6420 706f  g the desired po
+000100c0: 7369 7469 6f6e 2061 6e64 206f 7269 656e  sition and orien
+000100d0: 7461 7469 6f6e 206f 6620 7468 6520 456e  tation of the En
+000100e0: 6465 6666 6563 746f 720a 2020 2020 2320  deffector.    # 
+000100f0: 2071 303a 2054 6865 2063 6f6e 6669 6775   q0: The configu
+00010100: 7261 7469 6f6e 2028 6a6f 696e 7420 616e  ration (joint an
+00010110: 676c 6573 2f70 6f73 6974 696f 6e73 2920  gles/positions) 
+00010120: 6f66 2074 6865 2072 6f62 6f74 2066 726f  of the robot fro
+00010130: 6d20 7768 6963 6820 7468 6520 6e75 6d65  m which the nume
+00010140: 7269 6361 6c20 6d65 7468 6f64 7320 7374  rical methods st
+00010150: 6172 7420 736f 2063 616c 6375 6c61 7465  art so calculate
+00010160: 2074 6865 2073 6f6c 7574 696f 6e3b 2071   the solution; q
+00010170: 303d 4e6f 6e65 2069 6e64 6963 6174 6573  0=None indicates
+00010180: 2074 6861 7420 7468 6520 7374 6f72 6564   that the stored
+00010190: 2073 6f6c 7574 696f 6e20 2866 726f 6d20   solution (from 
+000101a0: 6d6f 6465 6c20 6f72 2070 7265 7669 6f75  model or previou
+000101b0: 7320 736f 6c75 7469 6f6e 2920 7368 616c  s solution) shal
+000101c0: 6c20 6265 2075 7365 6420 666f 7220 696e  l be used for in
+000101d0: 6974 6961 6c69 7a61 7469 6f6e 0a20 2020  itialization.   
+000101e0: 2023 2a2a 6f75 7470 7574 3a20 5b71 2c20   #**output: [q, 
+000101f0: 7375 6363 6573 735d 3b20 713a 2054 6865  success]; q: The
+00010200: 2073 6f6c 7574 696f 6e20 666f 7220 7468   solution for th
+00010210: 6520 6a6f 696e 7420 616e 676c 6573 2069  e joint angles i
+00010220: 6e20 7768 6963 6820 7468 6520 726f 626f  n which the robo
+00010230: 7427 7320 746f 6f6c 2063 656e 7465 7220  t's tool center 
+00010240: 706f 696e 7420 2854 4350 2920 7265 6163  point (TCP) reac
+00010250: 6865 7320 7468 6520 6465 7369 7265 6420  hes the desired 
+00010260: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
+00010270: 7366 6f72 6d61 7469 6f6e 206d 6174 7269  sformation matri
+00010280: 7820 543b 2073 7563 6365 7373 3d46 616c  x T; success=Fal
+00010290: 7365 2069 6e64 6963 6174 6573 2074 6861  se indicates tha
+000102a0: 7420 616c 6c20 7472 6961 6c73 2066 6f72  t all trials for
+000102b0: 2069 6e76 6572 7365 206b 696e 656d 6174   inverse kinemat
+000102c0: 6963 7320 6661 696c 6564 2c20 6c65 6164  ics failed, lead
+000102d0: 696e 6720 746f 2071 3d4e 6f6e 650a 2020  ing to q=None.  
+000102e0: 2020 2320 7375 6363 6573 733a 2066 6c61    # success: fla
+000102f0: 6720 746f 2069 6e64 6963 6174 6520 6966  g to indicate if
+00010300: 206d 6574 686f 6420 7761 7320 7375 6363   method was succ
+00010310: 6573 7366 756c 0a20 2020 2023 2a2a 6175  essful.    #**au
+00010320: 7468 6f72 3a20 5065 7465 7220 4d61 6e7a  thor: Peter Manz
+00010330: 6c2c 204a 6f68 616e 6e65 7320 4765 7273  l, Johannes Gers
+00010340: 746d 6179 720a 2020 2020 232a 2a6e 6f74  tmayr.    #**not
+00010350: 6573 3a20 7374 696c 6c20 756e 6465 7220  es: still under 
+00010360: 6465 7665 6c6f 706d 656e 743b 2065 7272  development; err
+00010370: 6f72 7320 696e 206f 7269 656e 7461 7469  ors in orientati
+00010380: 6f6e 7320 6f66 2073 6f6c 7574 696f 6e20  ons of solution 
+00010390: 6d61 7920 6f63 6375 7265 2e20 776f 726b  may occure. work
+000103a0: 7320 7369 6d69 6c61 7220 746f 2069 6b69  s similar to iki
+000103b0: 6e65 5c5f 4c4d 2066 756e 6374 696f 6e20  ne\_LM function 
+000103c0: 6f66 2074 6865 2072 6f62 6f74 6963 7320  of the robotics 
+000103d0: 746f 6f6c 626f 7820 6672 6f6d 2070 6574  toolbox from pet
+000103e0: 6572 2063 6f72 6b65 0a20 2020 2064 6566  er corke.    def
+000103f0: 2053 6f6c 7665 5361 6665 2873 656c 662c   SolveSafe(self,
+00010400: 2054 2c20 7130 203d 204e 6f6e 6529 3a0a   T, q0 = None):.
+00010410: 2020 2020 2020 2020 5430 203d 2073 656c          T0 = sel
+00010420: 662e 4765 7443 7572 7265 6e74 526f 626f  f.GetCurrentRobo
+00010430: 7448 5428 290a 2020 2020 2020 2020 5449  tHT().        TI
+00010440: 6e74 6572 7020 3d20 7365 6c66 2e49 6e74  nterp = self.Int
+00010450: 6572 706f 6c61 7465 4854 7328 5430 2c20  erpolateHTs(T0, 
+00010460: 542c 2072 6f74 5374 6570 3d6e 702e 7069  T, rotStep=np.pi
+00010470: 2f33 2920 2320 6e6f 2073 7465 7073 2069  /3) # no steps i
+00010480: 6e20 6265 7477 6565 6e20 6e65 6564 6564  n between needed
+00010490: 210a 2020 2020 2020 2020 7120 3d20 7130  !.        q = q0
+000104a0: 0a20 2020 2020 2020 2066 6f72 2054 6920  .        for Ti 
+000104b0: 696e 2054 496e 7465 7270 3a0a 2020 2020  in TInterp:.    
+000104c0: 2020 2020 2020 2020 5b71 2c20 7375 6363          [q, succ
+000104d0: 6573 735d 203d 2073 656c 662e 536f 6c76  ess] = self.Solv
+000104e0: 6528 5469 2c20 7129 0a20 2020 2020 2020  e(Ti, q).       
+000104f0: 2020 2020 2069 6620 6e6f 7420 7375 6363       if not succ
+00010500: 6573 733a 200a 2020 2020 2020 2020 2020  ess: .          
+00010510: 2020 2020 2020 6966 2073 656c 662e 666c        if self.fl
+00010520: 6167 4465 6275 673a 200a 2020 2020 2020  agDebug: .      
+00010530: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00010540: 696e 7428 2757 4152 4e49 4e47 3a20 496e  int('WARNING: In
+00010550: 7665 7273 654b 696e 656d 6174 6963 733a  verseKinematics:
+00010560: 2053 6f6c 7665 5361 6665 2066 6169 6c65   SolveSafe faile
+00010570: 6420 746f 2073 6f6c 7665 2729 0a20 2020  d to solve').   
+00010580: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+00010590: 616b 0a0a 2020 2020 2020 2020 6966 2073  ak..        if s
+000105a0: 7563 6365 7373 3a0a 2020 2020 2020 2020  uccess:.        
+000105b0: 2020 2020 5453 6f6c 203d 2073 656c 662e      TSol = self.
+000105c0: 4765 7443 7572 7265 6e74 526f 626f 7448  GetCurrentRobotH
+000105d0: 5428 2920 2320 7468 6520 666f 7277 6172  T() # the forwar
+000105e0: 6420 6b69 6e65 6d61 7469 6373 2061 6674  d kinematics aft
+000105f0: 6572 2073 6f6c 7669 6e67 0a20 2020 2020  er solving.     
+00010600: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00010610: 2020 2020 2054 536f 6c20 3d20 5430 0a20       TSol = T0. 
+00010620: 2020 200a 2020 2020 2020 2020 6966 2028     .        if (
+00010630: 2854 536f 6c2d 5429 203e 3d20 7365 6c66  (TSol-T) >= self
+00010640: 2e65 7073 536f 6c75 7469 6f6e 292e 616e  .epsSolution).an
+00010650: 7928 293a 2023 2a4a 473a 2031 652d 3132  y(): #*JG: 1e-12
+00010660: 3b20 7472 7920 6f6e 6365 2061 6761 696e  ; try once again
+00010670: 2077 6974 6820 6576 656e 2066 696e 6572   with even finer
+00010680: 2064 6973 6372 6574 697a 6174 696f 6e20   discretization 
+00010690: 2e2e 2e0a 2020 2020 2020 2020 2020 2020  ....            
+000106a0: 6966 2073 656c 662e 666c 6167 4465 6275  if self.flagDebu
+000106b0: 673a 0a20 2020 2020 2020 2020 2020 2020  g:.             
+000106c0: 2020 2070 7269 6e74 2827 5741 524e 494e     print('WARNIN
+000106d0: 473a 2049 6e76 6572 7365 4b69 6e65 6d61  G: InverseKinema
+000106e0: 7469 6373 3a20 536f 6c76 6553 6166 6520  tics: SolveSafe 
+000106f0: 7265 6669 6e65 2729 0a20 2020 2020 2020  refine').       
+00010700: 2020 2020 2020 2020 2069 6620 7375 6363           if succ
+00010710: 6573 733a 0a20 2020 2020 2020 2020 2020  ess:.           
+00010720: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+00010730: 2061 7420 6572 7220 3d20 5c6e 272c 2028   at err = \n', (
+00010740: 6e70 2e72 6f75 6e64 2828 5453 6f6c 2d54  np.round((TSol-T
+00010750: 292c 2031 3029 2920 2920 2320 726f 756e  ), 10)) ) # roun
+00010760: 6420 666f 7220 6265 7474 6572 2072 6561  d for better rea
+00010770: 6461 6269 6c69 7479 0a0a 2020 2020 2020  dability..      
+00010780: 2020 2020 2020 5449 6e74 6572 7020 3d20        TInterp = 
+00010790: 7365 6c66 2e49 6e74 6572 706f 6c61 7465  self.Interpolate
+000107a0: 4854 7328 5430 2c20 542c 2072 6f74 5374  HTs(T0, T, rotSt
+000107b0: 6570 203d 206e 702e 7069 2f32 302c 206d  ep = np.pi/20, m
+000107c0: 696e 5374 6570 733d 3429 2023 2a4a 473a  inSteps=4) #*JG:
+000107d0: 3230 3233 2d30 332d 3239 3a20 6368 616e  2023-03-29: chan
+000107e0: 6765 6420 6672 6f6d 2054 536f 6c20 746f  ged from TSol to
+000107f0: 2054 300a 2020 2020 2020 2020 2020 2020   T0.            
+00010800: 7120 3d20 7130 0a20 2020 2020 2020 2020  q = q0.         
+00010810: 2020 2066 6f72 2054 6920 696e 2054 496e     for Ti in TIn
+00010820: 7465 7270 3a0a 2020 2020 2020 2020 2020  terp:.          
+00010830: 2020 2020 2020 5b71 2c20 7375 6363 6573        [q, succes
+00010840: 735d 203d 2073 656c 662e 536f 6c76 6528  s] = self.Solve(
+00010850: 5469 2c20 7129 0a20 2020 2020 2020 2020  Ti, q).         
+00010860: 2020 2020 2020 2069 6620 6e6f 7420 7375         if not su
+00010870: 6363 6573 733a 200a 2020 2020 2020 2020  ccess: .        
+00010880: 2020 2020 2020 2020 2020 2020 6272 6561              brea
+00010890: 6b0a 0a20 2020 2020 2020 2020 2020 2069  k..            i
+000108a0: 6620 7375 6363 6573 733a 0a20 2020 2020  f success:.     
+000108b0: 2020 2020 2020 2020 2020 2054 536f 6c20             TSol 
+000108c0: 3d20 7365 6c66 2e47 6574 4375 7272 656e  = self.GetCurren
+000108d0: 7452 6f62 6f74 4854 2829 0a20 2020 2020  tRobotHT().     
+000108e0: 2020 2020 2020 2020 2020 2069 6620 286e             if (n
+000108f0: 702e 6162 7328 5453 6f6c 2d54 2920 3e3d  p.abs(TSol-T) >=
+00010900: 2031 652d 3829 2e61 6e79 2829 3a20 0a20   1e-8).any(): . 
+00010910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010920: 2020 2069 6620 7365 6c66 2e66 6c61 6744     if self.flagD
+00010930: 6562 7567 3a20 0a20 2020 2020 2020 2020  ebug: .         
+00010940: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00010950: 7269 6e74 2827 5741 524e 494e 473a 2049  rint('WARNING: I
+00010960: 6e76 6572 7365 4b69 6e65 6d61 7469 6373  nverseKinematics
+00010970: 3a20 536f 6c76 6553 6166 6520 7265 6669  : SolveSafe refi
+00010980: 6e65 6d65 6e74 2066 6169 6c65 643a 2065  nement failed: e
+00010990: 7272 203d 2027 2c20 286e 702e 726f 756e  rr = ', (np.roun
+000109a0: 6428 2854 536f 6c2d 5429 2c20 3130 2929  d((TSol-T), 10))
+000109b0: 2920 2320 726f 756e 6420 666f 7220 6265  ) # round for be
+000109c0: 7474 6572 2072 6561 6461 6269 6c69 7479  tter readability
+000109d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000109e0: 2020 2020 2073 7563 6365 7373 203d 2046       success = F
+000109f0: 616c 7365 0a0a 2020 2020 2020 2020 6966  alse..        if
+00010a00: 206e 6f74 2073 7563 6365 7373 3a0a 2020   not success:.  
+00010a10: 2020 2020 2020 2020 2020 7120 3d20 4e6f            q = No
+00010a20: 6e65 0a0a 2020 2020 2020 2020 7265 7475  ne..        retu
+00010a30: 726e 205b 712c 2073 7563 6365 7373 5d0a  rn [q, success].
+00010a40: 2020 2020 0a20 2020 2023 2a2a 636c 6173      .    #**clas
+00010a50: 7346 756e 6374 696f 6e3a 2054 6869 7320  sFunction: This 
+00010a60: 4d65 7468 6f64 2063 616e 2062 6520 7573  Method can be us
+00010a70: 6564 2074 6f20 736f 6c76 6520 7468 6520  ed to solve the 
+00010a80: 696e 7665 7273 6520 6b69 6e65 6d61 7469  inverse kinemati
+00010a90: 6373 2070 726f 626c 656d 2062 7920 736f  cs problem by so
+00010aa0: 6c76 696e 6720 0a20 2020 2023 2020 2020  lving .    #    
+00010ab0: 2020 2020 2020 2020 7468 6520 7374 6174          the stat
+00010ac0: 6963 2070 726f 626c 656d 206f 6620 6120  ic problem of a 
+00010ad0: 7365 7269 616c 2072 6f62 6f74 2075 7369  serial robot usi
+00010ae0: 6e67 2073 7465 7073 2074 6f20 696e 7465  ng steps to inte
+00010af0: 7270 6f6c 6174 6520 6265 7477 6565 6e20  rpolate between 
+00010b00: 7374 6172 7420 616e 6420 656e 6420 706f  start and end po
+00010b10: 7369 7469 6f6e 2063 6c6f 7365 2074 6f20  sition close to 
+00010b20: 7468 6520 6675 6e63 7469 6f6e 2053 6f6c  the function Sol
+00010b30: 7665 2e20 0a20 2020 2023 2020 2020 2020  ve. .    #      
+00010b40: 2020 2020 2054 2068 6973 2068 656c 7073       T his helps
+00010b50: 2074 6865 2066 7563 6e74 696f 6e20 536f   the fucntion So
+00010b60: 6c76 6520 746f 2066 696e 6420 7468 6520  lve to find the 
+00010b70: 636f 7272 6563 7420 736f 6c75 7469 6f6e  correct solution
+00010b80: 732e 200a 2020 2020 232a 2a69 6e70 7574  s. .    #**input
+00010b90: 3a0a 2020 2020 2320 2054 3a20 7468 6520  :.    #  T: the 
+00010ba0: 3478 3420 686f 6d6f 6765 6e65 6f75 7320  4x4 homogeneous 
+00010bb0: 7472 616e 7366 6f72 6d61 7469 6f6e 206d  transformation m
+00010bc0: 6174 7269 7820 7265 7072 6573 656e 7469  atrix representi
+00010bd0: 6e67 2074 6865 2064 6573 6972 6564 2070  ng the desired p
+00010be0: 6f73 6974 696f 6e20 616e 6420 6f72 6965  osition and orie
+00010bf0: 6e74 6174 696f 6e20 6f66 2074 6865 2045  ntation of the E
+00010c00: 6e64 6566 6665 6374 6f72 0a20 2020 2023  ndeffector.    #
+00010c10: 2020 7130 3a20 5468 6520 636f 6e66 6967    q0: The config
+00010c20: 7572 6174 696f 6e20 286a 6f69 6e74 2061  uration (joint a
+00010c30: 6e67 6c65 732f 706f 7369 7469 6f6e 7329  ngles/positions)
+00010c40: 206f 6620 7468 6520 726f 626f 7420 6672   of the robot fr
+00010c50: 6f6d 2077 6869 6368 2074 6865 206e 756d  om which the num
+00010c60: 6572 6963 616c 206d 6574 686f 6473 2073  erical methods s
+00010c70: 7461 7274 2073 6f20 6361 6c63 756c 6174  tart so calculat
+00010c80: 6520 7468 6520 736f 6c75 7469 6f6e 3b20  e the solution; 
+00010c90: 7130 3d4e 6f6e 6520 696e 6469 6361 7465  q0=None indicate
+00010ca0: 7320 7468 6174 2074 6865 2073 746f 7265  s that the store
+00010cb0: 6420 736f 6c75 7469 6f6e 2028 6672 6f6d  d solution (from
+00010cc0: 206d 6f64 656c 206f 7220 7072 6576 696f   model or previo
+00010cd0: 7573 2073 6f6c 7574 696f 6e29 2073 6861  us solution) sha
+00010ce0: 6c6c 2062 6520 7573 6564 2066 6f72 2069  ll be used for i
+00010cf0: 6e69 7469 616c 697a 6174 696f 6e0a 2020  nitialization.  
+00010d00: 2020 232a 2a6f 7574 7075 743a 205b 712c    #**output: [q,
+00010d10: 2073 7563 6365 7373 5d3b 2071 3a20 5468   success]; q: Th
+00010d20: 6520 736f 6c75 7469 6f6e 2066 6f72 2074  e solution for t
+00010d30: 6865 206a 6f69 6e74 2061 6e67 6c65 7320  he joint angles 
+00010d40: 696e 2077 6869 6368 2074 6865 2072 6f62  in which the rob
+00010d50: 6f74 2773 2074 6f6f 6c20 6365 6e74 6572  ot's tool center
+00010d60: 2070 6f69 6e74 2028 5443 5029 2072 6561   point (TCP) rea
+00010d70: 6368 6573 2074 6865 2064 6573 6972 6564  ches the desired
+00010d80: 2068 6f6d 6f67 656e 656f 7573 2074 7261   homogeneous tra
+00010d90: 6e73 666f 726d 6174 696f 6e20 6d61 7472  nsformation matr
+00010da0: 6978 2054 3b20 7375 6363 6573 733d 4661  ix T; success=Fa
+00010db0: 6c73 6520 696e 6469 6361 7465 7320 7468  lse indicates th
+00010dc0: 6174 2061 6c6c 2074 7269 616c 7320 666f  at all trials fo
+00010dd0: 7220 696e 7665 7273 6520 6b69 6e65 6d61  r inverse kinema
+00010de0: 7469 6373 2066 6169 6c65 642c 206c 6561  tics failed, lea
+00010df0: 6469 6e67 2074 6f20 713d 4e6f 6e65 0a20  ding to q=None. 
+00010e00: 2020 2023 2a2a 6175 7468 6f72 3a20 5065     #**author: Pe
+00010e10: 7465 7220 4d61 6e7a 6c2c 204a 6f68 616e  ter Manzl, Johan
+00010e20: 6e65 7320 4765 7273 746d 6179 720a 2020  nes Gerstmayr.  
+00010e30: 2020 232a 2a6e 6f74 6573 3a20 7374 696c    #**notes: stil
+00010e40: 6c20 756e 6465 7220 6465 7665 6c6f 706d  l under developm
+00010e50: 656e 743b 2065 7272 6f72 7320 696e 206f  ent; errors in o
+00010e60: 7269 656e 7461 7469 6f6e 7320 6f66 2073  rientations of s
+00010e70: 6f6c 7574 696f 6e20 6d61 7920 6f63 6375  olution may occu
+00010e80: 7265 2e20 776f 726b 7320 7369 6d69 6c61  re. works simila
+00010e90: 7220 746f 2069 6b69 6e65 5c5f 4c4d 2066  r to ikine\_LM f
+00010ea0: 756e 6374 696f 6e20 6f66 2074 6865 2072  unction of the r
+00010eb0: 6f62 6f74 6963 7320 746f 6f6c 626f 7820  obotics toolbox 
+00010ec0: 6672 6f6d 2070 6574 6572 2063 6f72 6b65  from peter corke
+00010ed0: 0a20 2020 2064 6566 2053 6f6c 7665 2873  .    def Solve(s
+00010ee0: 656c 662c 2054 2c20 7130 203d 204e 6f6e  elf, T, q0 = Non
+00010ef0: 6529 3a20 0a20 2020 2020 2020 2023 2063  e): .        # c
+00010f00: 6865 636b 2074 7970 6520 6f66 2054 200a  heck type of T .
+00010f10: 2020 2020 2020 2020 5420 3d20 6e70 2e61          T = np.a
+00010f20: 7272 6179 2854 290a 2020 2020 2020 2020  rray(T).        
+00010f30: 6966 2054 2e73 6861 7065 2021 3d20 2834  if T.shape != (4
+00010f40: 2c34 2920 6f72 2072 6f75 6e64 286e 702e  ,4) or round(np.
+00010f50: 6c69 6e61 6c67 2e64 6574 2854 5b30 3a33  linalg.det(T[0:3
+00010f60: 2c20 303a 335d 292c 3130 2920 213d 2031  , 0:3]),10) != 1
+00010f70: 2e30 3a20 2023 2063 6865 636b 2069 6620  .0:  # check if 
+00010f80: 6973 2068 6f6d 6f67 656e 656f 7573 2054  is homogeneous T
+00010f90: 460a 2020 2020 2020 2020 2020 2020 7261  F.            ra
+00010fa0: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+00010fb0: 696e 7665 7273 6520 4b69 6e65 6d61 7469  inverse Kinemati
+00010fc0: 6373 206f 6e6c 7920 706f 7373 6962 6c65  cs only possible
+00010fd0: 2066 6f72 2068 6f6d 6f67 656e 656f 7573   for homogeneous
+00010fe0: 2074 7261 6e73 666f 726d 6174 696f 6e73   transformations
+00010ff0: 2c20 7265 7072 6573 656e 7465 6420 6279  , represented by
+00011000: 2061 2034 7834 2061 7272 6179 2077 6974   a 4x4 array wit
+00011010: 6820 7374 7275 6374 7572 6520 6f66 205b  h structure of [
+00011020: 5b52 2c20 745d 2c20 5b30 2c30 2c30 2c31  [R, t], [0,0,0,1
+00011030: 5d5d 2e27 290a 2020 2020 2020 2020 7120  ]].').        q 
+00011040: 3d20 4e6f 6e65 0a20 2020 2020 2020 2069  = None.        i
+00011050: 6620 6e6f 7428 6861 7361 7474 7228 7130  f not(hasattr(q0
+00011060: 2c20 275f 5f69 7465 725f 5f27 2929 2061  , '__iter__')) a
+00011070: 6e64 2071 3020 3d3d 204e 6f6e 653a 2023  nd q0 == None: #
+00011080: 7265 706c 6163 6520 7769 7468 3a20 7130  replace with: q0
+00011090: 2069 7320 4e6f 6e65 0a20 2020 2020 2020   is None.       
+000110a0: 2020 2020 2071 3020 3d20 7365 6c66 2e6d       q0 = self.m
+000110b0: 6273 494b 2e73 7973 7465 6d44 6174 612e  bsIK.systemData.
+000110c0: 4765 744f 4445 3243 6f6f 7264 696e 6174  GetODE2Coordinat
+000110d0: 6573 2829 2023 202b 2028 6e70 2e72 616e  es() # + (np.ran
+000110e0: 646f 6d2e 7261 6e64 6f6d 2873 656c 662e  dom.random(self.
+000110f0: 6e4c 696e 6b73 292d 302e 3529 2a30 2e31  nLinks)-0.5)*0.1
+00011100: 2023 205b 305d 2a73 656c 662e 6e4c 696e   # [0]*self.nLin
+00011110: 6b73 0a20 2020 2020 2020 200a 2020 2020  ks.        .    
+00011120: 2020 2020 2361 6c77 6179 7320 7365 7420      #always set 
+00011130: 7130 2061 7320 7a65 726f 2d63 6f6e 6669  q0 as zero-confi
+00011140: 6775 7261 7469 6f6e 2066 6f72 2073 7072  guration for spr
+00011150: 696e 6773 210a 2020 2020 2020 2020 7130  ings!.        q0
+00011160: 203d 2070 726f 6a65 6374 416e 676c 6554   = projectAngleT
+00011170: 6f50 4d50 6928 7130 2920 0a20 2020 2020  oPMPi(q0) .     
+00011180: 2020 2073 656c 662e 6d62 7349 4b2e 5365     self.mbsIK.Se
+00011190: 744f 626a 6563 7450 6172 616d 6574 6572  tObjectParameter
+000111a0: 2873 656c 662e 726f 626f 7444 6963 745b  (self.robotDict[
+000111b0: 276f 626a 6563 744b 696e 656d 6174 6963  'objectKinematic
+000111c0: 5472 6565 275d 2c20 276a 6f69 6e74 506f  Tree'], 'jointPo
+000111d0: 7369 7469 6f6e 4f66 6673 6574 5665 6374  sitionOffsetVect
+000111e0: 6f72 272c 2071 3029 0a0a 2020 2020 2020  or', q0)..      
+000111f0: 2020 0a20 2020 2020 2020 2073 656c 662e    .        self.
+00011200: 6d62 7349 4b2e 7379 7374 656d 4461 7461  mbsIK.systemData
+00011210: 2e53 6574 4f44 4532 436f 6f72 6469 6e61  .SetODE2Coordina
+00011220: 7465 7328 636f 6f72 6469 6e61 7465 733d  tes(coordinates=
+00011230: 7130 2c20 636f 6e66 6967 7572 6174 696f  q0, configuratio
+00011240: 6e3d 6578 7564 796e 2e43 6f6e 6669 6775  n=exudyn.Configu
+00011250: 7261 7469 6f6e 5479 7065 2e49 6e69 7469  rationType.Initi
+00011260: 616c 290a 2020 2020 2020 2020 5220 3d20  al).        R = 
+00011270: 6572 622e 4854 3272 6f74 6174 696f 6e4d  erb.HT2rotationM
+00011280: 6174 7269 7828 5429 0a20 2020 2020 2020  atrix(T).       
+00011290: 2074 7261 6e73 203d 2028 6572 622e 4854   trans = (erb.HT
+000112a0: 3274 7261 6e73 6c61 7469 6f6e 2854 2929  2translation(T))
+000112b0: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
+000112c0: 2020 2320 7365 7420 7468 6520 706f 7369    # set the posi
+000112d0: 7469 6f6e 206f 6620 7468 6520 4772 6f75  tion of the Grou
+000112e0: 6e64 2074 6f20 6d61 7463 6820 7468 6520  nd to match the 
+000112f0: 6465 7369 7265 6420 4545 2070 6f73 6974  desired EE posit
+00011300: 696f 6e20 2869 6e20 676c 6f62 616c 2022  ion (in global "
+00011310: 6772 6f75 6e64 2220 7379 7465 6d29 0a20  ground" sytem). 
+00011320: 2020 2020 2020 2073 656c 662e 6d62 7349         self.mbsI
+00011330: 4b2e 5365 744d 6172 6b65 7250 6172 616d  K.SetMarkerParam
+00011340: 6574 6572 2873 656c 662e 6d47 726f 756e  eter(self.mGroun
+00011350: 6445 452c 2027 6c6f 6361 6c50 6f73 6974  dEE, 'localPosit
+00011360: 696f 6e27 2c20 7472 616e 7329 0a20 2020  ion', trans).   
+00011370: 2020 2020 2023 2073 6574 2074 6865 2064       # set the d
+00011380: 6573 6972 6564 2072 6f74 6174 696f 6e20  esired rotation 
+00011390: 0a20 2020 2020 2020 2073 656c 662e 6d62  .        self.mb
+000113a0: 7349 4b2e 5365 744f 626a 6563 7450 6172  sIK.SetObjectPar
+000113b0: 616d 6574 6572 2873 656c 662e 636f 6e73  ameter(self.cons
+000113c0: 7472 6169 6e74 546f 6f6c 2c20 2772 6f74  traintTool, 'rot
+000113d0: 6174 696f 6e4d 6172 6b65 7230 272c 2052  ationMarker0', R
+000113e0: 290a 2020 2020 2020 2020 0a20 2020 2020  ).        .     
+000113f0: 2020 2074 7279 3a20 0a20 2020 2020 2020     try: .       
+00011400: 2020 2020 2069 6620 7365 6c66 2e75 7365       if self.use
+00011410: 5265 6e64 6572 6572 3a20 0a20 2020 2020  Renderer: .     
+00011420: 2020 2020 2020 2020 2020 2065 7875 6479             exudy
+00011430: 6e2e 5374 6172 7452 656e 6465 7265 7228  n.StartRenderer(
+00011440: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00011450: 2020 7365 6c66 2e6d 6273 494b 2e57 6169    self.mbsIK.Wai
+00011460: 7446 6f72 5573 6572 546f 436f 6e74 696e  tForUserToContin
+00011470: 7565 2829 2023 7374 6f70 2062 6566 6f72  ue() #stop befor
+00011480: 6520 7369 6d75 6c61 7469 6e67 0a0a 2020  e simulating..  
+00011490: 2020 2020 2020 2020 2020 7375 6363 6573            succes
+000114a0: 7320 3d20 7365 6c66 2e73 7461 7469 6353  s = self.staticS
+000114b0: 6f6c 7665 722e 536f 6c76 6553 7973 7465  olver.SolveSyste
+000114c0: 6d28 7365 6c66 2e6d 6273 494b 2c20 7365  m(self.mbsIK, se
+000114d0: 6c66 2e73 696d 756c 6174 696f 6e53 6574  lf.simulationSet
+000114e0: 7469 6e67 7329 0a20 2020 2020 2020 2020  tings).         
+000114f0: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+00011500: 7120 3d20 7365 6c66 2e6d 6273 494b 2e73  q = self.mbsIK.s
+00011510: 7973 7465 6d44 6174 612e 4765 744f 4445  ystemData.GetODE
+00011520: 3243 6f6f 7264 696e 6174 6573 2829 0a20  2Coordinates(). 
+00011530: 2020 2020 2020 2020 2020 2071 203d 2070             q = p
+00011540: 726f 6a65 6374 416e 676c 6554 6f50 4d50  rojectAngleToPMP
+00011550: 6928 7129 2023 2073 6f6c 7574 696f 6e20  i(q) # solution 
+00011560: 6f66 2074 6865 2069 6e76 6572 7365 206b  of the inverse k
+00011570: 696e 656d 6174 6963 7320 7072 6f62 6c65  inematics proble
+00011580: 6d20 7072 6f6a 6563 7465 6420 696e 746f  m projected into
+00011590: 202d 7069 2f70 6920 7261 6e67 650a 2020   -pi/pi range.  
+000115a0: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+000115b0: 6273 494b 2e73 7973 7465 6d44 6174 612e  bsIK.systemData.
+000115c0: 5365 744f 4445 3243 6f6f 7264 696e 6174  SetODE2Coordinat
+000115d0: 6573 2863 6f6f 7264 696e 6174 6573 3d71  es(coordinates=q
+000115e0: 2c20 636f 6e66 6967 7572 6174 696f 6e3d  , configuration=
+000115f0: 6578 7564 796e 2e43 6f6e 6669 6775 7261  exudyn.Configura
+00011600: 7469 6f6e 5479 7065 2e49 6e69 7469 616c  tionType.Initial
+00011610: 290a 2020 2020 2020 2020 2020 2020 0a20  ).            . 
+00011620: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+00011630: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00011640: 6c66 2e66 6c61 6744 6562 7567 3a20 0a20  lf.flagDebug: . 
+00011650: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00011660: 7269 6e74 2827 5741 524e 494e 473a 2049  rint('WARNING: I
+00011670: 6e76 6572 7365 4b69 6e65 6d61 7469 6373  nverseKinematics
+00011680: 3a20 536f 6c76 653a 2073 7461 7469 6320  : Solve: static 
+00011690: 736f 6c76 6572 2066 6169 6c65 6427 290a  solver failed').
+000116a0: 2020 2020 2020 2020 2020 2020 5b71 2c20              [q, 
+000116b0: 7375 6363 6573 735d 203d 204e 6f6e 652c  success] = None,
+000116c0: 2046 616c 7365 0a20 2020 2020 2020 2020   False.         
+000116d0: 2020 200a 2020 2020 2020 2020 6966 2073     .        if s
+000116e0: 7563 6365 7373 3a0a 2020 2020 2020 2020  uccess:.        
+000116f0: 2020 2020 2320 7265 6164 206f 7574 7075      # read outpu
+00011700: 7420 6672 6f6d 2073 656e 736f 7273 2074  t from sensors t
+00011710: 6f20 6368 6563 6b20 6966 2074 6865 2073  o check if the s
+00011720: 6f6c 7574 696f 6e20 6f66 2074 6865 2069  olution of the i
+00011730: 6e76 6572 7365 204b 696e 656d 6174 6963  nverse Kinematic
+00011740: 7320 7761 7320 636f 7272 6563 740a 2020  s was correct.  
+00011750: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
+00011760: 4b69 6e65 536f 6c76 6564 203d 2073 656c  KineSolved = sel
+00011770: 662e 4765 7443 7572 7265 6e74 526f 626f  f.GetCurrentRobo
+00011780: 7448 5428 290a 2020 2020 2020 2020 2020  tHT().          
+00011790: 2020 6966 2028 6e70 2e61 6273 2873 656c    if (np.abs(sel
+000117a0: 662e 664b 696e 6553 6f6c 7665 6420 2d20  f.fKineSolved - 
+000117b0: 5429 203c 3d20 7365 6c66 2e65 7073 536f  T) <= self.epsSo
+000117c0: 6c75 7469 6f6e 292e 616c 6c28 293a 200a  lution).all(): .
+000117d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117e0: 7375 6363 6573 7320 3d20 5472 7565 0a20  success = True. 
+000117f0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00011800: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+00011810: 2020 7375 6363 6573 7320 3d20 4661 6c73    success = Fals
+00011820: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00011830: 2020 2320 666f 7277 6172 6473 206b 696e    # forwards kin
+00011840: 656d 6174 6963 7320 6465 7669 6174 6573  ematics deviates
+00011850: 2066 726f 6d20 6465 7369 7265 6420 4854   from desired HT
+00011860: 3b20 6861 7070 656e 7320 7768 656e 2064  ; happens when d
+00011870: 6573 6972 6564 2054 4350 2069 7320 6f75  esired TCP is ou
+00011880: 7473 6964 6520 6f66 2074 6865 2072 6f62  tside of the rob
+00011890: 6f74 2773 2077 6f72 6b69 6e67 2073 7061  ot's working spa
+000118a0: 6365 0a20 2020 2020 2020 2020 2020 2020  ce.             
+000118b0: 2020 2023 206f 7220 7768 656e 2074 6865     # or when the
+000118c0: 206f 7269 656e 7461 7469 6f6e 2069 7320   orientation is 
+000118d0: 6e6f 7420 7365 7420 636f 7272 6563 746c  not set correctl
+000118e0: 793b 2063 616e 2068 6170 7065 6e20 6265  y; can happen be
+000118f0: 6361 7573 6520 6f66 2063 7572 7265 6e74  cause of current
+00011900: 2069 6d70 6c65 6d65 6e74 6174 696f 6e20   implementation 
+00011910: 6f66 2067 656e 6572 6963 206a 6f69 6e74  of generic joint
+00011920: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+00011930: 2020 6966 2073 656c 662e 666c 6167 4465    if self.flagDe
+00011940: 6275 673a 200a 2020 2020 2020 2020 2020  bug: .          
+00011950: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00011960: 275c 6e27 2a31 290a 2020 2020 2020 2020  '\n'*1).        
+00011970: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00011980: 7428 2757 4152 4e49 4e47 3a20 496e 7665  t('WARNING: Inve
+00011990: 7273 654b 696e 656d 6174 6963 733a 2073  rseKinematics: s
+000119a0: 6f6c 7574 696f 6e20 696e 636f 7272 6563  olution incorrec
+000119b0: 743a 2729 200a 2020 2020 2020 2020 2020  t:') .          
+000119c0: 2020 2020 2020 2020 2020 7031 203d 2065            p1 = e
+000119d0: 7262 2e48 5432 7472 616e 736c 6174 696f  rb.HT2translatio
+000119e0: 6e28 7365 6c66 2e66 4b69 6e65 536f 6c76  n(self.fKineSolv
+000119f0: 6564 290a 2020 2020 2020 2020 2020 2020  ed).            
+00011a00: 2020 2020 2020 2020 7032 203d 2065 7262          p2 = erb
+00011a10: 2e48 5432 7472 616e 736c 6174 696f 6e28  .HT2translation(
+00011a20: 5429 0a20 2020 2020 2020 2020 2020 2020  T).             
+00011a30: 2020 2020 2020 2070 7269 6e74 2827 706f         print('po
+00011a40: 7320 6572 726f 723a 2027 2c20 6e70 2e72  s error: ', np.r
+00011a50: 6f75 6e64 2870 312d 7032 2c20 3137 2929  ound(p1-p2, 17))
+00011a60: 2023 2069 6620 5446 2069 7320 696e 2074   # if TF is in t
+00011a70: 6865 2077 6f72 6b73 7061 6365 2074 6865  he workspace the
+00011a80: 6e20 7468 6520 706f 7369 7469 6f6e 2077  n the position w
+00011a90: 6f72 6b73 0a20 2020 2020 2020 2020 2020  orks.           
+00011aa0: 2020 2020 2020 2020 2023 2072 6f74 6174           # rotat
+00011ab0: 696f 6e20 6d61 7920 7374 696c 6c20 6265  ion may still be
+00011ac0: 2077 726f 6e67 0a20 2020 2020 2020 2020   wrong.         
+00011ad0: 2020 2020 2020 2020 2020 2052 3120 3d20             R1 = 
+00011ae0: 7365 6c66 2e66 4b69 6e65 536f 6c76 6564  self.fKineSolved
+00011af0: 5b30 3a33 2c30 3a33 5d0a 2020 2020 2020  [0:3,0:3].      
+00011b00: 2020 2020 2020 2020 2020 2020 2020 5232                R2
+00011b10: 203d 2054 5b30 3a33 2c30 3a33 5d0a 2020   = T[0:3,0:3].  
+00011b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011b30: 2020 726f 7431 203d 2065 7262 2e52 6f74    rot1 = erb.Rot
+00011b40: 6174 696f 6e4d 6174 7269 7832 526f 7458  ationMatrix2RotX
+00011b50: 595a 2852 3129 0a20 2020 2020 2020 2020  YZ(R1).         
+00011b60: 2020 2020 2020 2020 2020 2072 6f74 3220             rot2 
+00011b70: 3d20 6572 622e 526f 7461 7469 6f6e 4d61  = erb.RotationMa
+00011b80: 7472 6978 3252 6f74 5859 5a28 5232 2920  trix2RotXYZ(R2) 
+00011b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011ba0: 2020 2020 2070 7269 6e74 2827 726f 7431       print('rot1
+00011bb0: 203d 207b 7d2c 2072 6f74 3220 3d20 7b7d   = {}, rot2 = {}
+00011bc0: 272e 666f 726d 6174 2872 6f74 312c 2072  '.format(rot1, r
+00011bd0: 6f74 3229 290a 2020 2020 2020 2020 2020  ot2)).          
+00011be0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00011bf0: 2752 313a 5c6e 7b7d 2c20 5c6e 5232 3a5c  'R1:\n{}, \nR2:\
+00011c00: 6e7b 7d27 2e66 6f72 6d61 7428 5231 2c20  n{}'.format(R1, 
+00011c10: 5232 2929 0a20 2020 2020 2020 2020 2020  R2)).           
+00011c20: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+00011c30: 5c6e 272a 3129 0a20 2020 2020 2020 2020  \n'*1).         
+00011c40: 2020 2020 2020 2020 2020 2023 2072 6169             # rai
+00011c50: 7365 2056 616c 7565 4572 726f 7228 276e  se ValueError('n
+00011c60: 6f20 7661 6c69 6420 736f 6c75 7469 6f6e  o valid solution
+00011c70: 2066 6f75 6e64 2066 6f72 2069 6e76 6572   found for inver
+00011c80: 7365 206b 696e 656d 6174 6963 7327 290a  se kinematics').
+00011c90: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00011ca0: 2020 2020 2020 2020 2020 7120 3d20 4e6f            q = No
+00011cb0: 6e65 0a0a 2020 2020 2020 2020 6966 2073  ne..        if s
+00011cc0: 656c 662e 7573 6552 656e 6465 7265 723a  elf.useRenderer:
+00011cd0: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
+00011ce0: 2073 656c 662e 7369 6d75 6c61 7469 6f6e   self.simulation
+00011cf0: 5365 7474 696e 6773 2e73 6f6c 7574 696f  Settings.solutio
+00011d00: 6e53 6574 7469 6e67 732e 736f 6c75 7469  nSettings.soluti
+00011d10: 6f6e 496e 666f 726d 6174 696f 6e20 3d20  onInformation = 
+00011d20: 2773 7563 6365 7373 203d 207b 7d5c 6e71  'success = {}\nq
+00011d30: 3d7b 7d27 2e66 6f72 6d61 7428 7375 6363  ={}'.format(succ
+00011d40: 6573 732c 206e 702e 726f 756e 6428 712c  ess, np.round(q,
+00011d50: 2033 2929 0a20 2020 2020 2020 2020 2020   3)).           
+00011d60: 2073 656c 662e 5343 2e57 6169 7446 6f72   self.SC.WaitFor
+00011d70: 5265 6e64 6572 456e 6769 6e65 5374 6f70  RenderEngineStop
+00011d80: 466c 6167 2829 2023 2073 746f 7020 6265  Flag() # stop be
+00011d90: 666f 7265 2063 6c6f 7369 6e67 0a20 2020  fore closing.   
+00011da0: 2020 2020 2020 2020 2065 7875 6479 6e2e           exudyn.
+00011db0: 5374 6f70 5265 6e64 6572 6572 2829 2023  StopRenderer() #
+00011dc0: 2063 6c6f 7365 2072 656e 6465 7269 6e67   close rendering
+00011dd0: 2077 696e 646f 7721 200a 0a20 2020 2020   window! ..     
+00011de0: 2020 2072 6574 7572 6e20 5b71 2c20 7375     return [q, su
+00011df0: 6363 6573 735d 0a0a 0a0a 0a23 2023 2320  ccess].....# ## 
+00011e00: 6465 6c65 7465 2065 7665 7279 7468 696e  delete everythin
+00011e10: 6720 6166 7465 7220 7468 6174 200a 2320  g after that .# 
+00011e20: 4d4f 5449 4f4e 2050 4c41 4e4e 494e 4720  MOTION PLANNING 
+00011e30: 616e 6420 5452 414a 4543 544f 5249 4553  and TRAJECTORIES
+00011e40: 2070 7265 7365 7276 6564 2069 6e20 4578   preserved in Ex
+00011e50: 7065 7269 6d65 6e74 616c 2f6d 6f74 696f  perimental/motio
+00011e60: 6e50 6c61 6e6e 696e 6754 6573 742e 7079  nPlanningTest.py
+00011e70: 0a23 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  .# #++++++++++++
+00011e80: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011e90: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011ea0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011eb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011ec0: 2b2b 2b2b 2b2b 2b2b 0a23 2023 2b2b 2b20  ++++++++.# #+++ 
+00011ed0: 204d 4f54 494f 4e20 504c 414e 4e49 4e47   MOTION PLANNING
+00011ee0: 2061 6e64 2054 5241 4a45 4354 4f52 4945   and TRAJECTORIE
+00011ef0: 5320 202b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  S  +++++++++++++
+00011f00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011f10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011f20: 0a23 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  .# #++++++++++++
+00011f30: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011f40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011f50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011f60: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00011f70: 2b2b 2b2b 2b2b 2b2b 0a23 2023 2a2a 6675  ++++++++.# #**fu
+00011f80: 6e63 7469 6f6e 3a20 436f 6d70 7574 6520  nction: Compute 
+00011f90: 7061 7261 6d65 7465 7273 2066 6f72 206f  parameters for o
+00011fa0: 7074 696d 616c 2074 7261 6a65 6374 6f72  ptimal trajector
+00011fb0: 7920 7573 696e 6720 6769 7665 6e20 6475  y using given du
+00011fc0: 7261 7469 6f6e 2061 6e64 2064 6973 7461  ration and dista
+00011fd0: 6e63 650a 2320 232a 2a6e 6f74 6573 3a20  nce.# #**notes: 
+00011fe0: 4445 5052 4543 4154 4544 2c20 444f 204e  DEPRECATED, DO N
+00011ff0: 4f54 2055 5345 202d 206d 6f76 6564 2074  OT USE - moved t
+00012000: 6f20 726f 626f 7469 6373 2e6d 6f74 696f  o robotics.motio
+00012010: 6e0a 2320 232a 2a69 6e70 7574 3a20 6475  n.# #**input: du
+00012020: 7261 7469 6f6e 2069 6e20 7365 636f 6e64  ration in second
+00012030: 7320 616e 6420 6469 7374 616e 6365 2069  s and distance i
+00012040: 6e20 6d65 7465 7273 206f 7220 7261 6469  n meters or radi
+00012050: 616e 730a 2320 232a 2a6f 7574 7075 743a  ans.# #**output:
+00012060: 2072 6574 7572 6e73 205b 764d 6178 2c20   returns [vMax, 
+00012070: 6163 634d 6178 5d20 7769 7468 206d 6178  accMax] with max
+00012080: 696d 756d 2076 656c 6f63 6974 7920 616e  imum velocity an
+00012090: 6420 6d61 7869 6d75 6d20 6163 6365 6c65  d maximum accele
+000120a0: 7261 7469 6f6e 2074 6f20 6163 6869 6576  ration to achiev
+000120b0: 6520 6769 7665 6e20 7472 616a 6563 746f  e given trajecto
+000120c0: 7279 0a23 2064 6566 2043 6f6e 7374 616e  ry.# def Constan
+000120d0: 7441 6363 656c 6572 6174 696f 6e50 6172  tAccelerationPar
+000120e0: 616d 6574 6572 7328 6475 7261 7469 6f6e  ameters(duration
+000120f0: 2c20 6469 7374 616e 6365 293a 0a23 2020  , distance):.#  
+00012100: 2020 2061 6363 4d61 7820 3d20 342a 6469     accMax = 4*di
+00012110: 7374 616e 6365 2f64 7572 6174 696f 6e2a  stance/duration*
+00012120: 2a32 0a23 2020 2020 2076 4d61 7820 3d20  *2.#     vMax = 
+00012130: 2861 6363 4d61 7820 2a20 6469 7374 616e  (accMax * distan
+00012140: 6365 292a 2a30 2e35 0a23 2020 2020 2072  ce)**0.5.#     r
+00012150: 6574 7572 6e20 5b76 4d61 782c 2061 6363  eturn [vMax, acc
+00012160: 4d61 785d 0a0a 2320 232a 2a66 756e 6374  Max]..# #**funct
+00012170: 696f 6e3a 2043 6f6d 7075 7465 2061 6e67  ion: Compute ang
+00012180: 6c65 202f 2064 6973 706c 6163 656d 656e  le / displacemen
+00012190: 7420 732c 2076 656c 6f63 6974 7920 7620  t s, velocity v 
+000121a0: 616e 6420 6163 6365 6c65 7261 7469 6f6e  and acceleration
+000121b0: 2061 0a23 2023 2a2a 696e 7075 743a 200a   a.# #**input: .
+000121c0: 2320 2320 2074 3a20 6375 7272 656e 7420  # #  t: current 
+000121d0: 7469 6d65 2074 6f20 636f 6d70 7574 6520  time to compute 
+000121e0: 7661 6c75 6573 0a23 2023 2020 7453 7461  values.# #  tSta
+000121f0: 7274 3a20 7374 6172 7420 7469 6d65 206f  rt: start time o
+00012200: 6620 7072 6f66 696c 650a 2320 2320 2073  f profile.# #  s
+00012210: 5374 6172 743a 2073 7461 7274 206f 6666  Start: start off
+00012220: 7365 7420 6f66 2070 6174 680a 2320 2320  set of path.# # 
+00012230: 2064 7572 6174 696f 6e3a 2064 7572 6174   duration: durat
+00012240: 696f 6e20 6f66 2070 726f 6669 6c65 0a23  ion of profile.#
+00012250: 2023 2020 6469 7374 616e 6365 3a20 746f   #  distance: to
+00012260: 7461 6c20 6469 7374 616e 6365 2028 6f66  tal distance (of
+00012270: 2070 6174 6829 206f 6620 7072 6f66 696c   path) of profil
+00012280: 650a 2320 232a 2a6e 6f74 6573 3a20 4445  e.# #**notes: DE
+00012290: 5052 4543 4154 4544 2c20 444f 204e 4f54  PRECATED, DO NOT
+000122a0: 2055 5345 202d 206d 6f76 6564 2074 6f20   USE - moved to 
+000122b0: 726f 626f 7469 6373 2e6d 6f74 696f 6e0a  robotics.motion.
+000122c0: 2320 232a 2a6f 7574 7075 743a 205b 732c  # #**output: [s,
+000122d0: 2076 2c20 615d 2077 6974 6820 7061 7468   v, a] with path
+000122e0: 2073 2c20 7665 6c6f 6369 7479 2076 2061   s, velocity v a
+000122f0: 6e64 2061 6363 656c 6572 6174 696f 6e20  nd acceleration 
+00012300: 6120 666f 7220 636f 6e73 7461 6e74 2061  a for constant a
+00012310: 6363 656c 6572 6174 696f 6e20 7072 6f66  cceleration prof
+00012320: 696c 653b 2062 6566 6f72 6520 7453 7461  ile; before tSta
+00012330: 7274 2c20 736f 6c75 7469 6f6e 2069 7320  rt, solution is 
+00012340: 5b30 2c30 2c30 5d20 7768 696c 6520 6166  [0,0,0] while af
+00012350: 7465 7220 6475 7261 7469 6f6e 2c20 736f  ter duration, so
+00012360: 6c75 7469 6f6e 2069 7320 5b73 5374 6172  lution is [sStar
+00012370: 742b 6469 7374 616e 6365 2c20 302c 2030  t+distance, 0, 0
+00012380: 5d0a 2320 6465 6620 436f 6e73 7461 6e74  ].# def Constant
+00012390: 4163 6365 6c65 7261 7469 6f6e 5072 6f66  AccelerationProf
+000123a0: 696c 6528 742c 2074 5374 6172 742c 2073  ile(t, tStart, s
+000123b0: 5374 6172 742c 2064 7572 6174 696f 6e2c  Start, duration,
+000123c0: 2064 6973 7461 6e63 6529 3a0a 2320 2020   distance):.#   
+000123d0: 2020 5b76 4d61 782c 2061 6363 4d61 785d    [vMax, accMax]
+000123e0: 203d 2043 6f6e 7374 616e 7441 6363 656c   = ConstantAccel
+000123f0: 6572 6174 696f 6e50 6172 616d 6574 6572  erationParameter
+00012400: 7328 6475 7261 7469 6f6e 2c20 6469 7374  s(duration, dist
+00012410: 616e 6365 290a 2020 2020 0a23 2020 2020  ance).    .#    
+00012420: 2073 203d 2073 5374 6172 740a 2320 2020   s = sStart.#   
+00012430: 2020 7620 3d20 300a 2320 2020 2020 6120    v = 0.#     a 
+00012440: 3d20 300a 2020 2020 0a23 2020 2020 2078  = 0.    .#     x
+00012450: 203d 2074 2d74 5374 6172 740a 2320 2020   = t-tStart.#   
+00012460: 2020 6966 2078 203c 2030 3a0a 2320 2020    if x < 0:.#   
+00012470: 2020 2020 2020 733d 300a 2320 2020 2020        s=0.#     
+00012480: 656c 6966 2078 203c 2030 2e35 2a64 7572  elif x < 0.5*dur
+00012490: 6174 696f 6e3a 0a23 2020 2020 2020 2020  ation:.#        
+000124a0: 2073 203d 2073 5374 6172 7420 2b20 302e   s = sStart + 0.
+000124b0: 352a 6163 634d 6178 2a78 2a2a 320a 2320  5*accMax*x**2.# 
+000124c0: 2020 2020 2020 2020 7620 3d20 782a 6163          v = x*ac
+000124d0: 634d 6178 0a23 2020 2020 2020 2020 2061  cMax.#         a
+000124e0: 203d 2061 6363 4d61 780a 2320 2020 2020   = accMax.#     
+000124f0: 656c 6966 2078 203c 2064 7572 6174 696f  elif x < duratio
+00012500: 6e3a 0a23 2020 2020 2020 2020 2073 203d  n:.#         s =
+00012510: 2073 5374 6172 7420 2b20 6469 7374 616e   sStart + distan
+00012520: 6365 202d 2030 2e35 2a61 6363 4d61 7820  ce - 0.5*accMax 
+00012530: 2a20 2864 7572 6174 696f 6e2d 7829 2a2a  * (duration-x)**
+00012540: 320a 2320 2020 2020 2020 2020 7620 3d20  2.#         v = 
+00012550: 2864 7572 6174 696f 6e20 2d20 7829 2a61  (duration - x)*a
+00012560: 6363 4d61 780a 2320 2020 2020 2020 2020  ccMax.#         
+00012570: 6120 3d20 2d61 6363 4d61 780a 2320 2020  a = -accMax.#   
+00012580: 2020 656c 7365 3a0a 2320 2020 2020 2020    else:.#       
+00012590: 2020 7320 3d20 7353 7461 7274 202b 2064    s = sStart + d
+000125a0: 6973 7461 6e63 650a 2020 2020 0a23 2020  istance.    .#  
+000125b0: 2020 2072 6574 7572 6e20 5b73 2c20 762c     return [s, v,
+000125c0: 2061 5d0a 0a23 206d 6f74 696f 6e49 6e74   a]..# motionInt
+000125d0: 6572 706f 6c61 746f 7257 6172 6e65 6420  erpolatorWarned 
+000125e0: 3d20 4661 6c73 650a 2320 232a 2a66 756e  = False.# #**fun
+000125f0: 6374 696f 6e3a 2043 6f6d 7075 7465 206a  ction: Compute j
+00012600: 6f69 6e74 2076 616c 7565 2c20 7665 6c6f  oint value, velo
+00012610: 6369 7479 2061 6e64 2061 6363 656c 6572  city and acceler
+00012620: 6174 696f 6e20 666f 7220 6769 7665 6e20  ation for given 
+00012630: 726f 626f 7454 7261 6a65 6374 6f72 795b  robotTrajectory[
+00012640: 2750 5450 275d 206f 6620 706f 696e 742d  'PTP'] of point-
+00012650: 746f 2d70 6f69 6e74 2074 7970 652c 2065  to-point type, e
+00012660: 7661 6c75 6174 6564 2066 6f72 2063 7572  valuated for cur
+00012670: 7265 6e74 2074 696d 6520 7420 616e 6420  rent time t and 
+00012680: 6a6f 696e 7420 6e75 6d62 6572 0a23 2023  joint number.# #
+00012690: 2a2a 696e 7075 743a 0a23 2023 2020 743a  **input:.# #  t:
+000126a0: 2074 696d 6520 746f 2065 7661 6c75 6174   time to evaluat
+000126b0: 6520 7472 616a 6563 746f 7279 0a23 2023  e trajectory.# #
+000126c0: 2020 726f 626f 7454 7261 6a65 6374 6f72    robotTrajector
+000126d0: 793a 2064 6963 7469 6f6e 6172 7920 746f  y: dictionary to
+000126e0: 2064 6573 6372 6962 6520 7472 616a 6563   describe trajec
+000126f0: 746f 7279 3b20 696e 2050 5450 2063 6173  tory; in PTP cas
+00012700: 652c 2065 6974 6865 7220 7573 6520 2774  e, either use 't
+00012710: 696d 6527 2070 6f69 6e74 732c 206f 7220  ime' points, or 
+00012720: 2774 696d 6527 2061 6e64 2027 6475 7261  'time' and 'dura
+00012730: 7469 6f6e 272c 206f 7220 2774 696d 6527  tion', or 'time'
+00012740: 2061 6e64 2027 6d61 7856 656c 6f63 6974   and 'maxVelocit
+00012750: 7927 2061 6e64 2027 6d61 7841 6363 656c  y' and 'maxAccel
+00012760: 6572 6174 696f 6e73 2720 696e 2061 6c6c  erations' in all
+00012770: 2063 6f6e 7365 6375 7469 7665 2070 6f69   consecutive poi
+00012780: 6e74 733b 2027 6d61 7856 656c 6f63 6974  nts; 'maxVelocit
+00012790: 6965 7327 2061 6e64 2027 6d61 7841 6363  ies' and 'maxAcc
+000127a0: 656c 6572 6174 696f 6e73 2720 6d75 7374  elerations' must
+000127b0: 2062 6520 706f 7369 7469 7665 206e 6f6e   be positive non
+000127c0: 7a65 726f 2076 616c 7565 7320 7468 6174  zero values that
+000127d0: 206c 696d 6974 2076 656c 6f63 6974 6965   limit velocitie
+000127e0: 7320 616e 6420 6163 6365 6c65 7261 7469  s and accelerati
+000127f0: 6f6e 733b 200a 2320 2320 206a 6f69 6e74  ons; .# #  joint
+00012800: 3a20 6a6f 696e 7420 6e75 6d62 6572 2066  : joint number f
+00012810: 6f72 2077 6869 6368 2074 6865 2074 7261  or which the tra
+00012820: 6a65 6374 6f72 7920 7368 616c 6c20 6265  jectory shall be
+00012830: 2065 7661 6c75 6174 6564 0a23 2023 2a2a   evaluated.# #**
+00012840: 6f75 7470 7574 3a20 666f 7220 6375 7272  output: for curr
+00012850: 656e 7420 7469 6d65 2074 2069 7420 7265  ent time t it re
+00012860: 7475 726e 7320 5b73 2c20 762c 2061 5d20  turns [s, v, a] 
+00012870: 7769 7468 2070 6174 6820 732c 2076 656c  with path s, vel
+00012880: 6f63 6974 7920 7620 616e 6420 6163 6365  ocity v and acce
+00012890: 6c65 7261 7469 6f6e 2061 2066 6f72 2063  leration a for c
+000128a0: 7572 7265 6e74 2061 6363 656c 6572 6174  urrent accelerat
+000128b0: 696f 6e20 7072 6f66 696c 653b 206f 7574  ion profile; out
+000128c0: 7369 6465 206f 6620 7072 6f66 696c 652c  side of profile,
+000128d0: 2069 7420 7265 7475 726e 7320 5b30 2c30   it returns [0,0
+000128e0: 2c30 5d20 210a 2320 232a 2a6e 6f74 6573  ,0] !.# #**notes
+000128f0: 3a20 4445 5052 4543 4154 4544 2c20 444f  : DEPRECATED, DO
+00012900: 204e 4f54 2055 5345 202d 206d 6f76 6564   NOT USE - moved
+00012910: 2074 6f20 726f 626f 7469 6373 2e6d 6f74   to robotics.mot
+00012920: 696f 6e0a 2320 232a 2a65 7861 6d70 6c65  ion.# #**example
+00012930: 3a0a 2320 2320 7130 203d 205b 302c 302c  :.# # q0 = [0,0,
+00012940: 302c 302c 302c 305d 2023 696e 6974 6961  0,0,0,0] #initia
+00012950: 6c20 636f 6e66 6967 7572 6174 696f 6e0a  l configuration.
+00012960: 2320 2320 7131 203d 205b 382c 352c 322c  # # q1 = [8,5,2,
+00012970: 302c 322c 315d 2023 6f74 6865 7220 636f  0,2,1] #other co
+00012980: 6e66 6967 7572 6174 696f 6e0a 2320 2320  nfiguration.# # 
+00012990: 5054 5020 3d5b 5d0a 2320 2320 5054 502b  PTP =[].# # PTP+
+000129a0: 3d5b 7b27 7127 3a71 302c 200a 2320 2320  =[{'q':q0, .# # 
+000129b0: 2020 2020 2020 2027 7469 6d65 273a 307d         'time':0}
+000129c0: 5d0a 2320 2320 5054 502b 3d5b 7b27 7127  ].# # PTP+=[{'q'
+000129d0: 3a71 312c 0a23 2023 2020 2020 2020 2020  :q1,.# #        
+000129e0: 2774 696d 6527 3a30 2e35 7d5d 0a23 2023  'time':0.5}].# #
+000129f0: 2050 5450 2b3d 5b7b 2771 273a 7131 2c20   PTP+=[{'q':q1, 
+00012a00: 0a23 2023 2020 2020 2020 2020 2774 696d  .# #        'tim
+00012a10: 6527 3a31 6536 7d5d 2023 666f 7265 7665  e':1e6}] #foreve
+00012a20: 720a 2320 2320 5254 3d7b 2750 5450 273a  r.# # RT={'PTP':
+00012a30: 5054 507d 0a23 2023 205b 752c 762c 615d  PTP}.# # [u,v,a]
+00012a40: 203d 204d 6f74 696f 6e49 6e74 6572 706f   = MotionInterpo
+00012a50: 6c61 746f 7228 743d 302e 352c 2072 6f62  lator(t=0.5, rob
+00012a60: 6f74 5472 616a 6563 746f 7279 3d52 542c  otTrajectory=RT,
+00012a70: 206a 6f69 6e74 3d31 290a 2320 6465 6620   joint=1).# def 
+00012a80: 4d6f 7469 6f6e 496e 7465 7270 6f6c 6174  MotionInterpolat
+00012a90: 6f72 2874 2c20 726f 626f 7454 7261 6a65  or(t, robotTraje
+00012aa0: 6374 6f72 792c 206a 6f69 6e74 293a 0a23  ctory, joint):.#
+00012ab0: 2020 2020 2067 6c6f 6261 6c20 6d6f 7469       global moti
+00012ac0: 6f6e 496e 7465 7270 6f6c 6174 6f72 5761  onInterpolatorWa
+00012ad0: 726e 6564 0a23 2020 2020 2069 6620 6e6f  rned.#     if no
+00012ae0: 7420 6d6f 7469 6f6e 496e 7465 7270 6f6c  t motionInterpol
+00012af0: 6174 6f72 5761 726e 6564 3a0a 2320 2020  atorWarned:.#   
+00012b00: 2020 2020 2020 6d6f 7469 6f6e 496e 7465        motionInte
+00012b10: 7270 6f6c 6174 6f72 5761 726e 6564 203d  rpolatorWarned =
+00012b20: 2054 7275 650a 2320 2020 2020 2020 2020   True.#         
+00012b30: 7072 696e 7428 274d 6f74 696f 6e49 6e74  print('MotionInt
+00012b40: 6572 706f 6c61 746f 723a 2064 6570 7265  erpolator: depre
+00012b50: 6361 7465 6420 2d20 7573 6520 5472 616a  cated - use Traj
+00012b60: 6563 746f 7279 2063 6c61 7373 2066 726f  ectory class fro
+00012b70: 6d20 726f 626f 7469 6373 2e74 7261 6a65  m robotics.traje
+00012b80: 6374 6f72 7920 696e 7374 6561 6427 290a  ctory instead').
+00012b90: 2320 2020 2020 6e20 3d20 6c65 6e28 726f  #     n = len(ro
+00012ba0: 626f 7454 7261 6a65 6374 6f72 795b 2750  botTrajectory['P
+00012bb0: 5450 275d 290a 2320 2020 2020 6966 206e  TP']).#     if n
+00012bc0: 203c 2032 3a0a 2320 2020 2020 2020 2020   < 2:.#         
+00012bd0: 7072 696e 7428 2245 5252 4f52 2069 6e20  print("ERROR in 
+00012be0: 4d6f 7469 6f6e 496e 7465 7270 6f6c 6174  MotionInterpolat
+00012bf0: 6f72 3a20 7472 616a 6563 746f 7279 206d  or: trajectory m
+00012c00: 7573 7420 6861 7665 2061 7420 6c65 6173  ust have at leas
+00012c10: 7420 3220 706f 696e 7473 2122 290a 2020  t 2 points!").  
+00012c20: 2020 0a23 2020 2020 2069 203d 2030 0a23    .#     i = 0.#
+00012c30: 2020 2020 2077 6869 6c65 2028 6920 3c20       while (i < 
+00012c40: 6e29 2061 6e64 2028 7420 3e3d 2072 6f62  n) and (t >= rob
+00012c50: 6f74 5472 616a 6563 746f 7279 5b27 5054  otTrajectory['PT
+00012c60: 5027 5d5b 695d 5b27 7469 6d65 275d 293a  P'][i]['time']):
+00012c70: 0a23 2020 2020 2020 2020 2069 202b 3d20  .#         i += 
+00012c80: 310a 0a23 2020 2020 2069 6620 2869 3d3d  1..#     if (i==
+00012c90: 3029 206f 7220 2869 3d3d 6e29 3a0a 2320  0) or (i==n):.# 
+00012ca0: 2020 2020 2020 2020 7265 7475 726e 205b          return [
+00012cb0: 302c 302c 305d 2023 6f75 7473 6964 6520  0,0,0] #outside 
+00012cc0: 6f66 2074 7261 6a65 6374 6f72 790a 2020  of trajectory.  
+00012cd0: 2020 0a23 2020 2020 2023 6920 6d75 7374    .#     #i must
+00012ce0: 2062 6520 3e20 3020 616e 6420 3c20 6e20   be > 0 and < n 
+00012cf0: 6e6f 7721 0a23 2020 2020 2071 3020 3d20  now!.#     q0 = 
+00012d00: 726f 626f 7454 7261 6a65 6374 6f72 795b  robotTrajectory[
+00012d10: 2750 5450 275d 5b69 2d31 5d20 236d 7573  'PTP'][i-1] #mus
+00012d20: 7420 616c 7761 7973 2065 7869 7374 0a23  t always exist.#
+00012d30: 2020 2020 2071 3120 3d20 726f 626f 7454       q1 = robotT
+00012d40: 7261 6a65 6374 6f72 795b 2750 5450 275d  rajectory['PTP']
+00012d50: 5b69 5d20 236d 7573 7420 616c 7761 7973  [i] #must always
+00012d60: 2065 7869 7374 0a20 2020 200a 2320 2020   exist.    .#   
+00012d70: 2020 7265 7475 726e 2043 6f6e 7374 616e    return Constan
+00012d80: 7441 6363 656c 6572 6174 696f 6e50 726f  tAccelerationPro
+00012d90: 6669 6c65 2874 2c20 7130 5b27 7469 6d65  file(t, q0['time
+00012da0: 275d 2c20 7130 5b27 7127 5d5b 6a6f 696e  '], q0['q'][join
+00012db0: 745d 2c20 0a23 2020 2020 2020 2020 2020  t], .#          
+00012dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012dd0: 2020 2020 2020 2020 2020 2020 2020 7131                q1
+00012de0: 5b27 7469 6d65 275d 202d 2071 305b 2774  ['time'] - q0['t
+00012df0: 696d 6527 5d2c 200a 2320 2020 2020 2020  ime'], .#       
+00012e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e20: 2071 315b 2771 275d 5b6a 6f69 6e74 5d20   q1['q'][joint] 
+00012e30: 2d20 7130 5b27 7127 5d5b 6a6f 696e 745d  - q0['q'][joint]
+00012e40: 290a 0a0a 0a0a 0a0a 0a0a 0a23 2073 6572  )..........# ser
+00012e50: 6961 6c52 6f62 6f74 324d 4253 7761 726e  ialRobot2MBSwarn
+00012e60: 6564 3d46 616c 7365 0a23 2023 2b2b 2b2b  ed=False.# #++++
+00012e70: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012e80: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012e90: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012ea0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012eb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012ec0: 0a23 2023 2b2b 2b20 2063 7265 6174 6520  .# #+++  create 
+00012ed0: 6120 5345 5249 414c 2052 4f42 4f54 2066  a SERIAL ROBOT f
+00012ee0: 726f 6d20 4448 2d70 6172 616d 6574 6572  rom DH-parameter
+00012ef0: 7320 696e 2074 6865 206d 6273 202b 2b2b  s in the mbs +++
+00012f00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012f10: 2b2b 2b2b 2b2b 2b2b 0a23 2023 2b2b 2b2b  ++++++++.# #++++
+00012f20: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012f30: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012f40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012f50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012f60: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00012f70: 0a23 2023 2a2a 6675 6e63 7469 6f6e 3a20  .# #**function: 
+00012f80: 4445 5052 4543 4154 4544 2066 756e 6374  DEPRECATED funct
+00012f90: 696f 6e2c 2075 7365 2052 6f62 6f74 2e43  ion, use Robot.C
+00012fa0: 7265 6174 6552 6564 756e 6461 6e74 436f  reateRedundantCo
+00012fb0: 6f72 6469 6e61 7465 4d42 5328 2e2e 2e29  ordinateMBS(...)
+00012fc0: 3b20 6164 6420 6974 656d 7320 746f 2065  ; add items to e
+00012fd0: 7869 7374 696e 6720 6d62 7320 6672 6f6d  xisting mbs from
+00012fe0: 2074 6865 2072 6f62 6f74 2073 7472 7563   the robot struc
+00012ff0: 7475 7265 2c20 6120 6261 7365 4d61 726b  ture, a baseMark
+00013000: 6572 2028 6361 6e20 6265 2067 726f 756e  er (can be groun
+00013010: 6420 6f62 6a65 6374 206f 7220 626f 6479  d object or body
+00013020: 290a 2320 2320 2020 2020 2020 2020 2020  ).# #           
+00013030: 2061 6e64 2074 6865 2075 7365 7220 6675   and the user fu
+00013040: 6e63 7469 6f6e 206c 6973 7420 666f 7220  nction list for 
+00013050: 7468 6520 6a6f 696e 7473 3b20 7468 6572  the joints; ther
+00013060: 6520 6172 6520 6f70 7469 6f6e 7320 7468  e are options th
+00013070: 6174 2063 616e 2062 6520 7061 7373 6564  at can be passed
+00013080: 2061 7320 6172 6773 202f 206b 7761 7267   as args / kwarg
+00013090: 732c 2077 6869 6368 2063 616e 2063 6f6e  s, which can con
+000130a0: 7461 696e 7320 6f70 7469 6f6e 7320 6173  tains options as
+000130b0: 2064 6573 6372 6962 6564 2062 656c 6f77   described below
+000130c0: 2e20 466f 7220 6465 7461 696c 732c 2073  . For details, s
+000130d0: 6565 2074 6865 2070 7974 686f 6e20 6669  ee the python fi
+000130e0: 6c65 2061 6e64 205c 7465 7874 7474 7b73  le and \texttt{s
+000130f0: 6572 6961 6c52 6f62 6f74 5465 7374 2e70  erialRobotTest.p
+00013100: 797d 2069 6e20 5465 7374 4d6f 6465 6c73  y} in TestModels
+00013110: 0a23 2023 2a2a 696e 7075 743a 200a 2320  .# #**input: .# 
+00013120: 2320 2020 6d62 733a 2074 6865 206d 756c  #   mbs: the mul
+00013130: 7469 626f 6479 2073 7973 7465 6d2c 2077  tibody system, w
+00013140: 6869 6368 2077 696c 6c20 6265 2065 7874  hich will be ext
+00013150: 656e 6465 640a 2320 2320 2020 726f 626f  ended.# #   robo
+00013160: 743a 2074 6865 2072 6f62 6f74 206d 6f64  t: the robot mod
+00013170: 656c 2061 7320 6469 6374 696f 6e61 7279  el as dictionary
+00013180: 2c20 6465 7363 7269 6265 6420 696e 2066  , described in f
+00013190: 756e 6374 696f 6e20 436f 6d70 7574 654a  unction ComputeJ
+000131a0: 6f69 6e74 4854 0a23 2023 2020 206a 6f69  ointHT.# #   joi
+000131b0: 6e74 4c6f 6164 5573 6572 4675 6e63 7469  ntLoadUserFuncti
+000131c0: 6f6e 4c69 7374 3a20 6120 6c69 7374 206f  onList: a list o
+000131d0: 6620 7573 6572 2066 756e 6374 696f 6e73  f user functions
+000131e0: 2066 6f72 2061 6374 7561 7469 6f6e 206f   for actuation o
+000131f0: 6620 6a6f 696e 7473 2061 6363 6f72 6469  f joints accordi
+00013200: 6e67 2074 6f20 6120 4c6f 6164 546f 7271  ng to a LoadTorq
+00013210: 7565 5665 6374 6f72 2075 7365 7246 756e  ueVector userFun
+00013220: 6374 696f 6e2c 2073 6565 2073 6572 6961  ction, see seria
+00013230: 6c52 6f62 6f74 5465 7374 2e70 7920 6173  lRobotTest.py as
+00013240: 2061 6e20 6578 616d 706c 653b 2063 616e   an example; can
+00013250: 2062 6520 656d 7074 7920 6c69 7374 0a23   be empty list.#
+00013260: 2023 2020 2062 6173 654d 6172 6b65 723a   #   baseMarker:
+00013270: 2061 2072 6967 6964 2062 6f64 7920 6d61   a rigid body ma
+00013280: 726b 6572 2c20 6174 2077 6869 6368 2074  rker, at which t
+00013290: 6865 2072 6f62 6f74 2077 696c 6c20 6265  he robot will be
+000132a0: 2070 6c61 6365 6420 2875 7375 616c 6c79   placed (usually
+000132b0: 2067 726f 756e 6429 3b20 6e6f 7465 2074   ground); note t
+000132c0: 6861 7420 7468 6520 6c6f 6361 6c20 636f  hat the local co
+000132d0: 6f72 6469 6e61 7465 2073 7973 7465 6d20  ordinate system 
+000132e0: 6f66 2074 6865 2062 6173 6520 6d75 7374  of the base must
+000132f0: 2062 6520 696e 2061 6363 6f72 6461 6e63   be in accordanc
+00013300: 6520 7769 7468 2074 6865 2044 482d 7061  e with the DH-pa
+00013310: 7261 6d65 7465 7273 2c20 692e 652e 2c20  rameters, i.e., 
+00013320: 7468 6520 7a2d 6178 6973 206d 7573 7420  the z-axis must 
+00013330: 6265 2074 6865 2066 6972 7374 2072 6f74  be the first rot
+00013340: 6174 696f 6e20 6178 6973 2e20 466f 7220  ation axis. For 
+00013350: 636f 7272 6563 7469 6f6e 206f 6620 7468  correction of th
+00013360: 6520 6261 7365 2063 6f6f 7264 696e 6174  e base coordinat
+00013370: 6520 7379 7374 656d 2c20 7573 6520 726f  e system, use ro
+00013380: 7461 7469 6f6e 4d61 726b 6572 4261 7365  tationMarkerBase
+00013390: 0a23 2023 2020 2072 6f74 6174 696f 6e4d  .# #   rotationM
+000133a0: 6172 6b65 7242 6173 653a 2075 7365 6420  arkerBase: used 
+000133b0: 696e 2047 656e 6572 6963 206a 6f69 6e74  in Generic joint
+000133c0: 2062 6574 7765 656e 2066 6972 7374 206a   between first j
+000133d0: 6f69 6e74 2061 6e64 2062 6173 653b 206e  oint and base; n
+000133e0: 6f74 652c 2074 6861 7420 666f 7220 6d6f  ote, that for mo
+000133f0: 7669 6e67 2062 6173 652c 2074 6865 2073  ving base, the s
+00013400: 7461 7469 6320 636f 6d70 656e 7361 7469  tatic compensati
+00013410: 6f6e 2064 6f65 7320 6e6f 7420 776f 726b  on does not work
+00013420: 2028 6261 7365 2072 6f74 6174 696f 6e20   (base rotation 
+00013430: 6d75 7374 2062 6520 7570 6461 7465 6429  must be updated)
+00013440: 0a23 2023 2020 2073 686f 7743 4f4d 3a20  .# #   showCOM: 
+00013450: 6120 7363 616c 6172 2064 2c20 7768 6963  a scalar d, whic
+00013460: 6820 6966 206e 6f6e 7a65 726f 2069 7420  h if nonzero it 
+00013470: 6361 7573 6573 2074 6f20 6472 6177 2074  causes to draw t
+00013480: 6865 2063 656e 7465 7220 6f66 206d 6173  he center of mas
+00013490: 7320 2843 4f4d 2920 6173 2072 6563 7461  s (COM) as recta
+000134a0: 6e67 756c 6172 2062 6c6f 636b 2077 6974  ngular block wit
+000134b0: 6820 7369 7a65 205b 642c 642c 645d 0a23  h size [d,d,d].#
+000134c0: 2023 2020 2062 6f64 7941 6c70 6861 3a20   #   bodyAlpha: 
+000134d0: 6120 666c 6f61 7420 7661 6c75 6520 696e  a float value in
+000134e0: 2072 616e 6765 205b 302e 2e31 5d2c 2061   range [0..1], a
+000134f0: 6464 7320 7472 616e 7370 6172 656e 6379  dds transparency
+00013500: 2074 6f20 6c69 6e6b 7320 6966 2076 616c   to links if val
+00013510: 7565 203c 2031 0a23 2023 2020 2074 6f6f  ue < 1.# #   too
+00013520: 6c47 7261 7068 6963 7353 697a 653a 206c  lGraphicsSize: l
+00013530: 6973 7420 6f66 2033 2066 6c6f 6174 7320  ist of 3 floats 
+00013540: 5b73 782c 7379 2c73 7a5d 2c20 6769 7669  [sx,sy,sz], givi
+00013550: 6e67 2074 6865 2073 697a 6520 6f66 2074  ng the size of t
+00013560: 6865 2074 6f6f 6c20 666f 7220 6772 6170  he tool for grap
+00013570: 6869 6373 2072 6570 7265 7365 6e74 6174  hics representat
+00013580: 696f 6e3b 2073 6574 2073 783d 3020 746f  ion; set sx=0 to
+00013590: 2064 6973 6162 6c65 2074 6f6f 6c20 6472   disable tool dr
+000135a0: 6177 696e 6720 6f72 2064 6f20 6e6f 7420  awing or do not 
+000135b0: 7072 6f76 6964 6520 7468 6973 206f 7074  provide this opt
+000135c0: 696f 6e61 6c20 7661 7269 6162 6c65 0a23  ional variable.#
+000135d0: 2023 2020 2064 7261 774c 696e 6b53 697a   #   drawLinkSiz
+000135e0: 653a 2064 7261 7720 7061 7261 6d65 7465  e: draw paramete
+000135f0: 7273 2066 6f72 206c 696e 6b73 2061 7320  rs for links as 
+00013600: 6c69 7374 206f 6620 3320 666c 6f61 7473  list of 3 floats
+00013610: 205b 722c 772c 305d 2c20 723d 7261 6469   [r,w,0], r=radi
+00013620: 7573 206f 6620 6a6f 696e 742c 2077 3d72  us of joint, w=r
+00013630: 6164 6975 7320 6f66 206c 696e 6b2c 2073  adius of link, s
+00013640: 6574 2072 3d30 2074 6f20 6469 7361 626c  et r=0 to disabl
+00013650: 6520 6c69 6e6b 2064 7261 7769 6e67 0a23  e link drawing.#
+00013660: 2023 2020 2072 6f74 6174 696f 6e4d 6172   #   rotationMar
+00013670: 6b65 7242 6173 653a 2061 6464 2061 206e  kerBase: add a n
+00013680: 756d 7079 2033 7833 206d 6174 7269 7820  umpy 3x3 matrix 
+00013690: 666f 7220 726f 7461 7469 6f6e 206f 6620  for rotation of 
+000136a0: 7468 6520 6261 7365 2c20 696e 206f 7264  the base, in ord
+000136b0: 6572 2074 6861 7420 7468 6520 726f 626f  er that the robo
+000136c0: 7420 6361 6e20 6265 2061 7474 6163 6865  t can be attache
+000136d0: 6420 746f 2061 6e79 2072 6f74 6174 6564  d to any rotated
+000136e0: 2062 6173 6520 6d61 726b 6572 3b20 7468   base marker; th
+000136f0: 6520 726f 7461 7469 6f6e 4d61 726b 6572  e rotationMarker
+00013700: 4261 7365 2069 7320 6163 636f 7264 696e  Base is accordin
+00013710: 6720 746f 2074 6865 2064 6566 696e 6974  g to the definit
+00013720: 696f 6e20 696e 2047 656e 6572 6963 4a6f  ion in GenericJo
+00013730: 696e 740a 2320 232a 2a6f 7574 7075 743a  int.# #**output:
+00013740: 2074 6865 2066 756e 6374 696f 6e20 7265   the function re
+00013750: 7475 726e 7320 6120 6469 6374 696f 6e61  turns a dictiona
+00013760: 7279 2063 6f6e 7461 696e 696e 6720 696e  ry containing in
+00013770: 666f 726d 6174 696f 6e20 6f6e 206e 6f64  formation on nod
+00013780: 6573 2c20 626f 6469 6573 2c20 6a6f 696e  es, bodies, join
+00013790: 7473 2c20 6d61 726b 6572 732c 2074 6f72  ts, markers, tor
+000137a0: 7175 6573 2c20 666f 7220 6576 6572 7920  ques, for every 
+000137b0: 6a6f 696e 740a 2320 6465 6620 5365 7269  joint.# def Seri
+000137c0: 616c 526f 626f 7432 4d42 5328 6d62 732c  alRobot2MBS(mbs,
+000137d0: 2072 6f62 6f74 2c20 6a6f 696e 744c 6f61   robot, jointLoa
+000137e0: 6455 7365 7246 756e 6374 696f 6e4c 6973  dUserFunctionLis
+000137f0: 742c 2062 6173 654d 6172 6b65 722c 202a  t, baseMarker, *
+00013800: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+00013810: 0a23 2020 2020 2067 6c6f 6261 6c20 7365  .#     global se
+00013820: 7269 616c 526f 626f 7432 4d42 5377 6172  rialRobot2MBSwar
+00013830: 6e65 640a 2320 2020 2020 6966 206e 6f74  ned.#     if not
+00013840: 2073 6572 6961 6c52 6f62 6f74 324d 4253   serialRobot2MBS
+00013850: 7761 726e 6564 3a0a 2320 2020 2020 2020  warned:.#       
+00013860: 2020 7365 7269 616c 526f 626f 7432 4d42    serialRobot2MB
+00013870: 5377 6172 6e65 6420 3d20 5472 7565 0a23  Swarned = True.#
+00013880: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+00013890: 6675 6e63 7469 6f6e 2053 6572 6961 6c52  function SerialR
+000138a0: 6f62 6f74 324d 4253 282e 2e2e 2920 6973  obot2MBS(...) is
+000138b0: 2064 6570 7265 6361 7465 642c 2075 7365   deprecated, use
+000138c0: 2052 6f62 6f74 2e43 7265 6174 6552 6564   Robot.CreateRed
+000138d0: 756e 6461 6e74 436f 6f72 6469 6e61 7465  undantCoordinate
+000138e0: 4d42 5328 2e2e 2e29 206f 6620 636c 6173  MBS(...) of clas
+000138f0: 7320 526f 626f 7420 696e 7374 6561 6427  s Robot instead'
+00013900: 290a 2320 2020 2020 2362 7569 6c64 2072  ).#     #build r
+00013910: 6f62 6f74 206d 6f64 656c 3a0a 2320 2020  obot model:.#   
+00013920: 2020 6e6f 6465 4c69 7374 203d 205b 5d20    nodeList = [] 
+00013930: 2020 2020 2020 2020 2020 236e 6f64 6520            #node 
+00013940: 6e75 6d62 6572 206f 7220 7269 6769 6420  number or rigid 
+00013950: 6e6f 6465 2066 6f72 206c 696e 6b0a 2320  node for link.# 
+00013960: 2020 2020 626f 6479 4c69 7374 203d 205b      bodyList = [
+00013970: 5d20 2020 2020 2020 2020 2020 2362 6f64  ]           #bod
+00013980: 7920 6e75 6d62 6572 206f 7220 7269 6769  y number or rigi
+00013990: 6420 626f 6479 2066 6f72 206c 696e 6b0a  d body for link.
+000139a0: 2320 2020 2020 6a6f 696e 744c 6973 7420  #     jointList 
+000139b0: 3d20 5b5d 2020 2020 2020 2020 2020 236a  = []          #j
+000139c0: 6f69 6e74 2077 6869 6368 206c 696e 6b73  oint which links
+000139d0: 2074 6f20 7072 6576 696f 7573 206c 696e   to previous lin
+000139e0: 6b20 6f72 2062 6173 650a 2320 2020 2020  k or base.#     
+000139f0: 6d61 726b 6572 4c69 7374 3020 3d20 5b5d  markerList0 = []
+00013a00: 2023 636f 6e74 6169 6e73 206e 206d 6172   #contains n mar
+00013a10: 6b65 7220 6e75 6d62 6572 7320 7065 7220  ker numbers per 
+00013a20: 6c69 6e6b 2077 6869 6368 2063 6f6e 6e65  link which conne
+00013a30: 6374 2074 6f20 7072 6576 696f 7573 2062  ct to previous b
+00013a40: 6f64 790a 2320 2020 2020 6d61 726b 6572  ody.#     marker
+00013a50: 4c69 7374 3120 3d20 5b5d 2023 636f 6e74  List1 = [] #cont
+00013a60: 6169 6e73 206e 206d 6172 6b65 7220 6e75  ains n marker nu
+00013a70: 6d62 6572 7320 7065 7220 6c69 6e6b 2077  mbers per link w
+00013a80: 6869 6368 2063 6f6e 6e65 6374 2074 6f20  hich connect to 
+00013a90: 6e65 7874 2062 6f64 790a 2320 2020 2020  next body.#     
+00013aa0: 6a6f 696e 7454 6f72 7175 6530 4c69 7374  jointTorque0List
+00013ab0: 203d 205b 5d20 2023 6c6f 6164 206e 756d   = []  #load num
+00013ac0: 6265 7220 6f66 206a 6f69 6e74 2074 6f72  ber of joint tor
+00013ad0: 7175 6520 6174 2070 7265 7669 6f75 7320  que at previous 
+00013ae0: 6c69 6e6b 2028 6e65 6761 7469 7665 290a  link (negative).
+00013af0: 2320 2020 2020 6a6f 696e 7454 6f72 7175  #     jointTorqu
+00013b00: 6531 4c69 7374 203d 205b 5d20 2023 6c6f  e1List = []  #lo
+00013b10: 6164 206e 756d 6265 7220 6f66 206a 6f69  ad number of joi
+00013b20: 6e74 2074 6f72 7175 6520 6174 206e 6578  nt torque at nex
+00013b30: 7420 6c69 6e6b 2028 706f 7369 7469 7665  t link (positive
+00013b40: 290a 2020 2020 0a23 2020 2020 2054 6375  ).    .#     Tcu
+00013b50: 7272 656e 7420 3d20 726f 626f 745b 2762  rrent = robot['b
+00013b60: 6173 6527 5d5b 2748 5427 5d0a 2020 2020  ase']['HT'].    
+00013b70: 0a23 2020 2020 206c 6173 744d 6172 6b65  .#     lastMarke
+00013b80: 7220 3d20 6261 7365 4d61 726b 6572 0a20  r = baseMarker. 
+00013b90: 2020 200a 2320 2020 2020 626f 6479 416c     .#     bodyAl
+00013ba0: 7068 6120 3d20 3120 2364 6566 6175 6c74  pha = 1 #default
+00013bb0: 2076 616c 7565 3b20 6e6f 2074 7261 6e73   value; no trans
+00013bc0: 7061 7265 6e63 790a 2320 2020 2020 6966  parency.#     if
+00013bd0: 2027 626f 6479 416c 7068 6127 2069 6e20   'bodyAlpha' in 
+00013be0: 6b77 6172 6773 3a0a 2320 2020 2020 2020  kwargs:.#       
+00013bf0: 2020 626f 6479 416c 7068 6120 3d20 6b77    bodyAlpha = kw
+00013c00: 6172 6773 5b27 626f 6479 416c 7068 6127  args['bodyAlpha'
+00013c10: 5d0a 0a0a 2320 2020 2020 746f 6f6c 5369  ]...#     toolSi
+00013c20: 7a65 203d 205b 302e 3035 2c30 2e30 322c  ze = [0.05,0.02,
+00013c30: 302e 3036 5d20 2364 6566 6175 6c74 2076  0.06] #default v
+00013c40: 616c 7565 730a 2320 2020 2020 6966 2027  alues.#     if '
+00013c50: 746f 6f6c 4772 6170 6869 6373 5369 7a65  toolGraphicsSize
+00013c60: 2720 696e 206b 7761 7267 733a 0a23 2020  ' in kwargs:.#  
+00013c70: 2020 2020 2020 2074 6f6f 6c53 697a 6520         toolSize 
+00013c80: 3d20 6b77 6172 6773 5b27 746f 6f6c 4772  = kwargs['toolGr
+00013c90: 6170 6869 6373 5369 7a65 275d 0a0a 2020  aphicsSize']..  
+00013ca0: 2020 2020 2020 0a23 2020 2020 2064 7261        .#     dra
+00013cb0: 774c 696e 6b53 697a 653d 5b30 2e30 362c  wLinkSize=[0.06,
+00013cc0: 302e 3035 5d20 2364 6566 6175 6c74 2076  0.05] #default v
+00013cd0: 616c 7565 730a 2320 2020 2020 6966 2027  alues.#     if '
+00013ce0: 6472 6177 4c69 6e6b 5369 7a65 2720 696e  drawLinkSize' in
+00013cf0: 206b 7761 7267 733a 0a23 2020 2020 2020   kwargs:.#      
+00013d00: 2020 2064 7261 774c 696e 6b53 697a 6520     drawLinkSize 
+00013d10: 3d20 6b77 6172 6773 5b27 6472 6177 4c69  = kwargs['drawLi
+00013d20: 6e6b 5369 7a65 275d 0a0a 2320 2020 2020  nkSize']..#     
+00013d30: 2363 7265 6174 6520 726f 626f 7420 6e6f  #create robot no
+00013d40: 6465 7320 616e 6420 626f 6469 6573 3a0a  des and bodies:.
+00013d50: 2320 2020 2020 666f 7220 6920 696e 2072  #     for i in r
+00013d60: 616e 6765 286c 656e 2872 6f62 6f74 5b27  ange(len(robot['
+00013d70: 6c69 6e6b 7327 5d29 293a 0a23 2020 2020  links'])):.#    
+00013d80: 2020 2020 206c 696e 6b20 3d20 726f 626f       link = robo
+00013d90: 745b 276c 696e 6b73 275d 5b69 5d0a 2020  t['links'][i].  
+00013da0: 2020 0a23 2020 2020 2020 2020 2044 4870    .#         DHp
+00013db0: 6172 616d 203d 206e 702e 7a65 726f 7328  aram = np.zeros(
+00013dc0: 3429 0a23 2020 2020 2020 2020 2044 4870  4).#         DHp
+00013dd0: 6172 616d 5b30 3a34 5d20 3d20 6c69 6e6b  aram[0:4] = link
+00013de0: 5b27 7374 6444 4827 5d5b 303a 345d 2023  ['stdDH'][0:4] #
+00013df0: 636f 7079 2063 6f6e 7465 6e74 210a 2320  copy content!.# 
+00013e00: 2020 2020 2020 2020 6966 2072 6f62 6f74          if robot
+00013e10: 5b27 6a6f 696e 7454 7970 6527 5d5b 695d  ['jointType'][i]
+00013e20: 203d 3d20 313a 2023 313d 3d72 6576 6f6c   == 1: #1==revol
+00013e30: 7574 652c 2030 3d3d 7072 6973 6d61 7469  ute, 0==prismati
+00013e40: 630a 2320 2020 2020 2020 2020 2020 2020  c.#             
+00013e50: 4448 7061 7261 6d5b 305d 203d 2072 6f62  DHparam[0] = rob
+00013e60: 6f74 5b27 7265 6665 7265 6e63 6543 6f6e  ot['referenceCon
+00013e70: 6669 6775 7261 7469 6f6e 275d 5b69 5d20  figuration'][i] 
+00013e80: 2361 6464 2072 6566 6572 656e 6365 2061  #add reference a
+00013e90: 6e67 6c65 0a23 2020 2020 2020 2020 2065  ngle.#         e
+00013ea0: 6c73 653a 0a23 2020 2020 2020 2020 2020  lse:.#          
+00013eb0: 2020 2044 4870 6172 616d 5b31 5d20 3d20     DHparam[1] = 
+00013ec0: 726f 626f 745b 2772 6566 6572 656e 6365  robot['reference
+00013ed0: 436f 6e66 6967 7572 6174 696f 6e27 5d5b  Configuration'][
+00013ee0: 695d 2023 6164 6420 7265 6665 7265 6e63  i] #add referenc
+00013ef0: 6520 6469 7370 6c61 6365 6d65 6e74 0a20  e displacement. 
+00013f00: 2020 2020 2020 2020 2020 200a 2320 2020             .#   
+00013f10: 2020 2020 2020 5430 3120 3d20 5374 6444        T01 = StdD
+00013f20: 4832 4854 2844 4870 6172 616d 2920 2374  H2HT(DHparam) #t
+00013f30: 7261 6e73 666f 726d 6174 696f 6e20 6672  ransformation fr
+00013f40: 6f6d 206c 6173 7420 6c69 6e6b 2074 6f20  om last link to 
+00013f50: 7468 6973 206c 696e 6b3b 2069 7420 6465  this link; it de
+00013f60: 6669 6e65 7320 7468 6520 6f72 6965 6e74  fines the orient
+00013f70: 6174 696f 6e20 6f66 2074 6865 2062 6f64  ation of the bod
+00013f80: 790a 2020 2020 0a23 2020 2020 2020 2020  y.    .#        
+00013f90: 2054 6375 7272 656e 7420 3d20 5463 7572   Tcurrent = Tcur
+00013fa0: 7265 6e74 2040 2054 3031 0a20 2020 2020  rent @ T01.     
+00013fb0: 2020 200a 2320 2020 2020 2020 2020 2374     .#         #t
+00013fc0: 6865 206e 6578 7420 2864 6973 7461 6c29  he next (distal)
+00013fd0: 206a 6f69 6e74 2028 6a6f 696e 7431 2920   joint (joint1) 
+00013fe0: 6973 2061 6c69 676e 6564 2077 6974 6820  is aligned with 
+00013ff0: 7468 6520 7a2d 6178 6973 206f 6620 7468  the z-axis of th
+00014000: 6520 626f 6479 2773 2066 7261 6d65 3a0a  e body's frame:.
+00014010: 2320 2020 2020 2020 2020 7031 203d 206e  #         p1 = n
+00014020: 702e 6172 7261 7928 5b30 2c30 2c30 2e5d  p.array([0,0,0.]
+00014030: 290a 2320 2020 2020 2020 2020 6178 6973  ).#         axis
+00014040: 3120 3d20 6e70 2e61 7272 6179 285b 302c  1 = np.array([0,
+00014050: 302c 312e 5d29 0a20 2020 200a 2320 2020  0,1.]).    .#   
+00014060: 2020 2020 2020 2374 6865 2070 7265 7669        #the previ
+00014070: 6f75 7320 6a6f 696e 7420 286a 6f69 6e74  ous joint (joint
+00014080: 3029 2061 7869 7320 6973 2072 6f74 6174  0) axis is rotat
+00014090: 6564 2062 6163 6b20 7769 7468 2061 6c70  ed back with alp
+000140a0: 6861 2061 6e64 2074 7261 6e73 6c61 7465  ha and translate
+000140b0: 6420 616c 6f6e 6720 2d78 2077 6974 6820  d along -x with 
+000140c0: 610a 2320 2020 2020 2020 2020 6420 3d20  a.#         d = 
+000140d0: 6c69 6e6b 5b27 7374 6444 4827 5d5b 315d  link['stdDH'][1]
+000140e0: 0a23 2020 2020 2020 2020 2061 203d 206c  .#         a = l
+000140f0: 696e 6b5b 2773 7464 4448 275d 5b32 5d0a  ink['stdDH'][2].
+00014100: 2320 2020 2020 2020 2020 616c 7068 6120  #         alpha 
+00014110: 3d20 6c69 6e6b 5b27 7374 6444 4827 5d5b  = link['stdDH'][
+00014120: 335d 0a23 2020 2020 2020 2020 2041 3054  3].#         A0T
+00014130: 203d 2065 7262 2e52 6f74 6174 696f 6e4d   = erb.RotationM
+00014140: 6174 7269 7858 282d 616c 7068 6129 2023  atrixX(-alpha) #
+00014150: 726f 7461 7469 6f6e 206d 6174 7269 7820  rotation matrix 
+00014160: 7472 616e 7366 6f72 6d73 2062 6163 6b20  transforms back 
+00014170: 746f 206a 6f69 6e74 300a 2320 2020 2020  to joint0.#     
+00014180: 2020 2020 7030 203d 2041 3054 2040 206e      p0 = A0T @ n
+00014190: 702e 6172 7261 7928 5b2d 612c 302c 2d64  p.array([-a,0,-d
+000141a0: 5d29 0a23 2020 2020 2020 2020 2061 7869  ]).#         axi
+000141b0: 7330 203d 2041 3054 2040 206e 702e 6172  s0 = A0T @ np.ar
+000141c0: 7261 7928 5b30 2c30 2c31 2e5d 290a 2020  ray([0,0,1.]).  
+000141d0: 2020 2020 2020 0a23 2020 2020 2020 2020        .#        
+000141e0: 2023 7269 6769 6420 626f 6479 2070 6172   #rigid body par
+000141f0: 616d 6574 6572 733a 0a23 2020 2020 2020  ameters:.#      
+00014200: 2020 2063 6f6d 203d 206c 696e 6b5b 2743     com = link['C
+00014210: 4f4d 275d 0a23 2020 2020 2020 2020 2023  OM'].#         #
+00014220: 2063 6f6d 3420 3d20 6e70 2e61 7272 6179   com4 = np.array
+00014230: 2863 6f6d 2b5b 315d 290a 2020 2020 0a23  (com+[1]).    .#
+00014240: 2020 2020 2020 2020 2069 6e65 7274 6961           inertia
+00014250: 4c69 6e6b 203d 2065 7262 2e52 6967 6964  Link = erb.Rigid
+00014260: 426f 6479 496e 6572 7469 6128 6d61 7373  BodyInertia(mass
+00014270: 3d6c 696e 6b5b 276d 6173 7327 5d2c 200a  =link['mass'], .
+00014280: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00014290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000142a0: 2020 2020 2020 2020 2069 6e65 7274 6961           inertia
+000142b0: 5465 6e73 6f72 3d6c 696e 6b5b 2769 6e65  Tensor=link['ine
+000142c0: 7274 6961 275d 290a 2320 2020 2020 2020  rtia']).#       
+000142d0: 2020 696e 6572 7469 614c 696e 6b20 3d20    inertiaLink = 
+000142e0: 696e 6572 7469 614c 696e 6b2e 5472 616e  inertiaLink.Tran
+000142f0: 736c 6174 6564 2863 6f6d 2923 6e65 6564  slated(com)#need
+00014300: 7320 746f 2062 6520 7265 636f 6d70 7574  s to be recomput
+00014310: 6564 2c20 6265 6361 7573 6520 696e 6572  ed, because iner
+00014320: 7469 6120 6973 2077 2e72 2e74 2e20 434f  tia is w.r.t. CO
+00014330: 4d0a 2020 2020 2020 2020 0a23 2020 2020  M.        .#    
+00014340: 2020 2020 2063 6f6c 6f72 203d 206c 6973       color = lis
+00014350: 7428 6e70 2e61 7272 6179 2865 6764 2e63  t(np.array(egd.c
+00014360: 6f6c 6f72 346c 6973 745b 695d 2929 0a23  olor4list[i])).#
+00014370: 2020 2020 2020 2020 2063 6f6c 6f72 5b33           color[3
+00014380: 5d20 3d20 626f 6479 416c 7068 6120 2374  ] = bodyAlpha #t
+00014390: 7261 6e73 7061 7265 6e63 7920 6f66 2062  ransparency of b
+000143a0: 6f64 6965 730a 2320 2020 2020 2020 2020  odies.#         
+000143b0: 6772 6170 6869 6373 4c69 7374 203d 205b  graphicsList = [
+000143c0: 5d0a 0a23 2020 2020 2020 2020 2023 6472  ]..#         #dr
+000143d0: 6177 2043 4f4d 3a0a 2320 2020 2020 2020  aw COM:.#       
+000143e0: 2020 6966 2027 7368 6f77 434f 4d27 2069    if 'showCOM' i
+000143f0: 6e20 6172 6773 3a0a 2320 2020 2020 2020  n args:.#       
+00014400: 2020 2020 2020 6464 3d61 7267 735b 2773        dd=args['s
+00014410: 686f 7743 4f4d 275d 0a23 2020 2020 2020  howCOM'].#      
+00014420: 2020 2020 2020 2067 7261 7068 6963 734c         graphicsL
+00014430: 6973 7420 2b3d 205b 6567 642e 4772 6170  ist += [egd.Grap
+00014440: 6869 6373 4461 7461 4f72 7468 6f43 7562  hicsDataOrthoCub
+00014450: 6550 6f69 6e74 2863 6f6d 2c20 5b64 642c  ePoint(com, [dd,
+00014460: 6464 2c64 645d 2c20 6567 642e 636f 6c6f  dd,dd], egd.colo
+00014470: 7234 6c69 7374 5b69 5d29 5d0a 0a23 2020  r4list[i])]..#  
+00014480: 2020 2020 2020 2023 6472 6177 206c 696e         #draw lin
+00014490: 6b73 3a0a 2320 2020 2020 2020 2020 7220  ks:.#         r 
+000144a0: 3d20 6472 6177 4c69 6e6b 5369 7a65 5b30  = drawLinkSize[0
+000144b0: 5d0a 2320 2020 2020 2020 2020 7720 3d20  ].#         w = 
+000144c0: 6472 6177 4c69 6e6b 5369 7a65 5b31 5d0a  drawLinkSize[1].
+000144d0: 2320 2020 2020 2020 2020 6966 2072 2021  #         if r !
+000144e0: 3d20 303a 0a23 2020 2020 2020 2020 2020  = 0:.#          
+000144f0: 2020 2068 3020 3d20 7720 2020 2368 6569     h0 = w   #hei
+00014500: 6768 7420 6f66 2068 616c 6620 6178 6973  ght of half axis
+00014510: 2c20 6669 7273 7420 6a6f 696e 740a 2320  , first joint.# 
+00014520: 2020 2020 2020 2020 2020 2020 6831 203d              h1 =
+00014530: 2077 2020 2023 6865 6967 6874 206f 6620   w   #height of 
+00014540: 6861 6c66 2061 7869 732c 2073 6563 6f6e  half axis, secon
+00014550: 6420 6a6f 696e 740a 2020 2020 2020 2020  d joint.        
+00014560: 2020 2020 0a23 2020 2020 2020 2020 2020      .#          
+00014570: 2020 2069 6620 6920 3d3d 2030 3a20 2364     if i == 0: #d
+00014580: 7261 7720 6675 6c6c 2063 796c 696e 6465  raw full cylinde
+00014590: 7220 666f 7220 6669 7273 7420 6a6f 696e  r for first join
+000145a0: 740a 2320 2020 2020 2020 2020 2020 2020  t.#             
+000145b0: 2020 2020 6830 203d 2077 2a32 0a20 2020      h0 = w*2.   
+000145c0: 2020 2020 2020 2020 200a 2320 2020 2020           .#     
+000145d0: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
+000145e0: 4c69 7374 202b 3d20 5b65 6764 2e47 7261  List += [egd.Gra
+000145f0: 7068 6963 7344 6174 6143 796c 696e 6465  phicsDataCylinde
+00014600: 7228 7041 7869 733d 7030 2c20 7641 7869  r(pAxis=p0, vAxi
+00014610: 733d 2d68 302a 6178 6973 302c 200a 2320  s=-h0*axis0, .# 
+00014620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014650: 2072 6164 6975 733d 722c 2063 6f6c 6f72   radius=r, color
+00014660: 3d63 6f6c 6f72 295d 0a23 2020 2020 2020  =color)].#      
+00014670: 2020 2020 2020 2067 7261 7068 6963 734c         graphicsL
+00014680: 6973 7420 2b3d 205b 6567 642e 4772 6170  ist += [egd.Grap
+00014690: 6869 6373 4461 7461 4379 6c69 6e64 6572  hicsDataCylinder
+000146a0: 2870 4178 6973 3d70 312c 2076 4178 6973  (pAxis=p1, vAxis
+000146b0: 3d20 6831 2a61 7869 7331 2c20 0a23 2020  = h1*axis1, .#  
+000146c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146f0: 2020 2020 2072 6164 6975 733d 722c 2063       radius=r, c
+00014700: 6f6c 6f72 3d63 6f6c 6f72 295d 0a0a 2320  olor=color)]..# 
+00014710: 2020 2020 2020 2020 2020 2020 2364 7261              #dra
+00014720: 7720 626f 6479 2061 7320 6379 6c69 6e64  w body as cylind
+00014730: 6572 3a0a 2320 2020 2020 2020 2020 2020  er:.#           
+00014740: 2020 6966 2065 6275 2e4e 6f72 6d4c 3228    if ebu.NormL2(
+00014750: 6562 752e 5653 7562 2870 312c 7030 2929  ebu.VSub(p1,p0))
+00014760: 203e 2031 652d 3135 3a0a 2320 2020 2020   > 1e-15:.#     
+00014770: 2020 2020 2020 2020 2020 2020 6772 6170              grap
+00014780: 6869 6373 4c69 7374 202b 3d20 5b65 6764  hicsList += [egd
+00014790: 2e47 7261 7068 6963 7344 6174 6143 796c  .GraphicsDataCyl
+000147a0: 696e 6465 7228 7041 7869 733d 7031 2c20  inder(pAxis=p1, 
+000147b0: 7641 7869 733d 6562 752e 5653 7562 2870  vAxis=ebu.VSub(p
+000147c0: 302c 7031 292c 200a 2320 2020 2020 2020  0,p1), .#       
+000147d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000147e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000147f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014800: 7261 6469 7573 3d77 2c20 636f 6c6f 723d  radius=w, color=
+00014810: 636f 6c6f 7229 5d0a 2020 2020 2020 2020  color)].        
+00014820: 0a23 2020 2020 2020 2020 2069 6620 693d  .#         if i=
+00014830: 3d6c 656e 2872 6f62 6f74 5b27 6c69 6e6b  =len(robot['link
+00014840: 7327 5d29 3a20 2374 6f6f 6c0a 2320 2020  s']): #tool.#   
+00014850: 2020 2020 2020 2020 2020 7054 6f6f 6c20            pTool 
+00014860: 3d20 6572 622e 4854 3274 7261 6e73 6c61  = erb.HT2transla
+00014870: 7469 6f6e 2872 6f62 6f74 5b27 746f 6f6c  tion(robot['tool
+00014880: 275d 5b27 4854 275d 290a 2320 2020 2020  ']['HT']).#     
+00014890: 2020 2020 2020 2020 6966 2074 6f6f 6c53          if toolS
+000148a0: 697a 655b 305d 2021 3d20 303a 0a23 2020  ize[0] != 0:.#  
+000148b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000148c0: 6f6c 6f72 546f 6f6c 203d 2065 6764 2e63  olorTool = egd.c
+000148d0: 6f6c 6f72 3473 7465 656c 626c 7565 0a23  olor4steelblue.#
+000148e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000148f0: 2063 6f6c 6f72 546f 6f6c 5b33 5d20 3d20   colorTool[3] = 
+00014900: 626f 6479 416c 7068 6120 2374 7261 6e73  bodyAlpha #trans
+00014910: 7061 7265 6e63 7920 6f66 2062 6f64 6965  parency of bodie
+00014920: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00014930: 2020 2020 2020 0a23 2020 2020 2020 2020        .#        
+00014940: 2020 2020 2020 2020 2069 6620 6562 752e           if ebu.
+00014950: 4e6f 726d 4c32 2870 546f 6f6c 2920 213d  NormL2(pTool) !=
+00014960: 2030 3a0a 2320 2020 2020 2020 2020 2020   0:.#           
+00014970: 2020 2020 2020 2020 2020 6772 6170 6869            graphi
+00014980: 6373 4c69 7374 202b 3d20 5b65 6764 2e47  csList += [egd.G
+00014990: 7261 7068 6963 7344 6174 6143 796c 696e  raphicsDataCylin
+000149a0: 6465 7228 7041 7869 733d 7031 2c20 7641  der(pAxis=p1, vA
+000149b0: 7869 733d 2065 6275 2e56 5375 6228 7054  xis= ebu.VSub(pT
+000149c0: 6f6f 6c2c 7031 292c 200a 2320 2020 2020  ool,p1), .#     
+000149d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000149e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000149f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a00: 2020 2020 2020 7261 6469 7573 3d72 2a30        radius=r*0
+00014a10: 2e37 352c 2063 6f6c 6f72 3d63 6f6c 6f72  .75, color=color
+00014a20: 546f 6f6c 295d 0a20 2020 2020 2020 2020  Tool)].         
+00014a30: 2020 2020 2020 2020 2020 200a 2320 2020             .#   
+00014a40: 2020 2020 2020 2020 2020 2020 2020 2361                #a
+00014a50: 6464 2073 6f6d 6520 7369 6d70 6c69 6669  dd some simplifi
+00014a60: 6564 2064 7261 7769 6e67 2066 6f72 2067  ed drawing for g
+00014a70: 7269 7070 6572 2c20 6d61 7920 6265 2072  ripper, may be r
+00014a80: 656d 6f76 6564 2069 6e20 6675 7475 7265  emoved in future
+00014a90: 0a23 2020 2020 2020 2020 2020 2020 2020  .#              
+00014aa0: 2020 2074 7920 3d20 746f 6f6c 5369 7a65     ty = toolSize
+00014ab0: 5b30 5d0a 2320 2020 2020 2020 2020 2020  [0].#           
+00014ac0: 2020 2020 2020 747a 203d 2074 6f6f 6c53        tz = toolS
+00014ad0: 697a 655b 305d 0a23 2020 2020 2020 2020  ize[0].#        
+00014ae0: 2020 2020 2020 2020 2067 7261 7068 6963           graphic
+00014af0: 734c 6973 7420 2b3d 205b 6567 642e 4772  sList += [egd.Gr
+00014b00: 6170 6869 6373 4461 7461 4f72 7468 6f43  aphicsDataOrthoC
+00014b10: 7562 6550 6f69 6e74 2870 546f 6f6c 2b5b  ubePoint(pTool+[
+00014b20: 302c 7479 2c30 2e35 2a74 7a5d 2c20 746f  0,ty,0.5*tz], to
+00014b30: 6f6c 5369 7a65 2c20 636f 6c6f 7254 6f6f  olSize, colorToo
+00014b40: 6c29 5d0a 2320 2020 2020 2020 2020 2020  l)].#           
+00014b50: 2020 2020 2020 6772 6170 6869 6373 4c69        graphicsLi
+00014b60: 7374 202b 3d20 5b65 6764 2e47 7261 7068  st += [egd.Graph
+00014b70: 6963 7344 6174 614f 7274 686f 4375 6265  icsDataOrthoCube
+00014b80: 506f 696e 7428 7054 6f6f 6c2b 5b30 2c2d  Point(pTool+[0,-
+00014b90: 7479 2c30 2e35 2a74 7a5d 2c20 746f 6f6c  ty,0.5*tz], tool
+00014ba0: 5369 7a65 2c20 636f 6c6f 7254 6f6f 6c29  Size, colorTool)
+00014bb0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00014bc0: 2020 0a20 2020 2020 2020 200a 2320 2020    .        .#   
+00014bd0: 2020 2020 2020 232b 2b2b 2b2b 2b2b 2b2b        #+++++++++
+00014be0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0a  +++++++++++++++.
+00014bf0: 2320 2020 2020 2020 2020 236e 6f77 2061  #         #now a
+00014c00: 6464 2062 6f64 7920 666f 7220 6c69 6e6b  dd body for link
+00014c10: 3a0a 2320 2020 2020 2020 2020 5b6e 4c69  :.#         [nLi
+00014c20: 6e6b 2c62 4c69 6e6b 5d3d 6572 622e 4164  nk,bLink]=erb.Ad
+00014c30: 6452 6967 6964 426f 6479 286d 6169 6e53  dRigidBody(mainS
+00014c40: 7973 203d 206d 6273 2c20 696e 6572 7469  ys = mbs, inerti
+00014c50: 613d 696e 6572 7469 614c 696e 6b2c 200a  a=inertiaLink, .
+00014c60: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00014c70: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
+00014c80: 6465 5479 7065 3d27 4e6f 6465 5479 7065  deType='NodeType
+00014c90: 2e52 6f74 6174 696f 6e45 756c 6572 5061  .RotationEulerPa
+00014ca0: 7261 6d65 7465 7273 272c 200a 2320 2020  rameters', .#   
+00014cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014cc0: 2020 2020 2020 2020 2020 706f 7369 7469            positi
+00014cd0: 6f6e 3d65 7262 2e48 5432 7472 616e 736c  on=erb.HT2transl
+00014ce0: 6174 696f 6e28 5463 7572 7265 6e74 292c  ation(Tcurrent),
+00014cf0: 200a 2320 2020 2020 2020 2020 2020 2020   .#             
 00014d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014d10: 2020 2020 2072 6164 6975 733d 722c 2063       radius=r, c
-00014d20: 6f6c 6f72 3d63 6f6c 6f72 295d 0d0a 0d0a  olor=color)]....
-00014d30: 2320 2020 2020 2020 2020 2020 2020 2364  #             #d
-00014d40: 7261 7720 626f 6479 2061 7320 6379 6c69  raw body as cyli
-00014d50: 6e64 6572 3a0d 0a23 2020 2020 2020 2020  nder:..#        
-00014d60: 2020 2020 2069 6620 6562 752e 4e6f 726d       if ebu.Norm
-00014d70: 4c32 2865 6275 2e56 5375 6228 7031 2c70  L2(ebu.VSub(p1,p
-00014d80: 3029 2920 3e20 3165 2d31 353a 0d0a 2320  0)) > 1e-15:..# 
-00014d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014da0: 6772 6170 6869 6373 4c69 7374 202b 3d20  graphicsList += 
-00014db0: 5b65 6764 2e47 7261 7068 6963 7344 6174  [egd.GraphicsDat
-00014dc0: 6143 796c 696e 6465 7228 7041 7869 733d  aCylinder(pAxis=
-00014dd0: 7031 2c20 7641 7869 733d 6562 752e 5653  p1, vAxis=ebu.VS
-00014de0: 7562 2870 302c 7031 292c 200d 0a23 2020  ub(p0,p1), ..#  
-00014df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e20: 2020 2020 2072 6164 6975 733d 772c 2063       radius=w, c
-00014e30: 6f6c 6f72 3d63 6f6c 6f72 295d 0d0a 2020  olor=color)]..  
-00014e40: 2020 2020 2020 0d0a 2320 2020 2020 2020        ..#       
-00014e50: 2020 6966 2069 3d3d 6c65 6e28 726f 626f    if i==len(robo
-00014e60: 745b 276c 696e 6b73 275d 293a 2023 746f  t['links']): #to
-00014e70: 6f6c 0d0a 2320 2020 2020 2020 2020 2020  ol..#           
-00014e80: 2020 7054 6f6f 6c20 3d20 6572 622e 4854    pTool = erb.HT
-00014e90: 3274 7261 6e73 6c61 7469 6f6e 2872 6f62  2translation(rob
-00014ea0: 6f74 5b27 746f 6f6c 275d 5b27 4854 275d  ot['tool']['HT']
-00014eb0: 290d 0a23 2020 2020 2020 2020 2020 2020  )..#            
-00014ec0: 2069 6620 746f 6f6c 5369 7a65 5b30 5d20   if toolSize[0] 
-00014ed0: 213d 2030 3a0d 0a23 2020 2020 2020 2020  != 0:..#        
-00014ee0: 2020 2020 2020 2020 2063 6f6c 6f72 546f           colorTo
-00014ef0: 6f6c 203d 2065 6764 2e63 6f6c 6f72 3473  ol = egd.color4s
-00014f00: 7465 656c 626c 7565 0d0a 2320 2020 2020  teelblue..#     
-00014f10: 2020 2020 2020 2020 2020 2020 636f 6c6f              colo
-00014f20: 7254 6f6f 6c5b 335d 203d 2062 6f64 7941  rTool[3] = bodyA
-00014f30: 6c70 6861 2023 7472 616e 7370 6172 656e  lpha #transparen
-00014f40: 6379 206f 6620 626f 6469 6573 0d0a 2020  cy of bodies..  
-00014f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f60: 2020 0d0a 2320 2020 2020 2020 2020 2020    ..#           
-00014f70: 2020 2020 2020 6966 2065 6275 2e4e 6f72        if ebu.Nor
-00014f80: 6d4c 3228 7054 6f6f 6c29 2021 3d20 303a  mL2(pTool) != 0:
-00014f90: 0d0a 2320 2020 2020 2020 2020 2020 2020  ..#             
-00014fa0: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
-00014fb0: 4c69 7374 202b 3d20 5b65 6764 2e47 7261  List += [egd.Gra
-00014fc0: 7068 6963 7344 6174 6143 796c 696e 6465  phicsDataCylinde
-00014fd0: 7228 7041 7869 733d 7031 2c20 7641 7869  r(pAxis=p1, vAxi
-00014fe0: 733d 2065 6275 2e56 5375 6228 7054 6f6f  s= ebu.VSub(pToo
-00014ff0: 6c2c 7031 292c 200d 0a23 2020 2020 2020  l,p1), ..#      
-00015000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015030: 2020 2020 2072 6164 6975 733d 722a 302e       radius=r*0.
-00015040: 3735 2c20 636f 6c6f 723d 636f 6c6f 7254  75, color=colorT
-00015050: 6f6f 6c29 5d0d 0a20 2020 2020 2020 2020  ool)]..         
-00015060: 2020 2020 2020 2020 2020 200d 0a23 2020             ..#  
-00015070: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00015080: 6164 6420 736f 6d65 2073 696d 706c 6966  add some simplif
-00015090: 6965 6420 6472 6177 696e 6720 666f 7220  ied drawing for 
-000150a0: 6772 6970 7065 722c 206d 6179 2062 6520  gripper, may be 
-000150b0: 7265 6d6f 7665 6420 696e 2066 7574 7572  removed in futur
-000150c0: 650d 0a23 2020 2020 2020 2020 2020 2020  e..#            
-000150d0: 2020 2020 2074 7920 3d20 746f 6f6c 5369       ty = toolSi
-000150e0: 7a65 5b30 5d0d 0a23 2020 2020 2020 2020  ze[0]..#        
-000150f0: 2020 2020 2020 2020 2074 7a20 3d20 746f           tz = to
-00015100: 6f6c 5369 7a65 5b30 5d0d 0a23 2020 2020  olSize[0]..#    
-00015110: 2020 2020 2020 2020 2020 2020 2067 7261               gra
-00015120: 7068 6963 734c 6973 7420 2b3d 205b 6567  phicsList += [eg
-00015130: 642e 4772 6170 6869 6373 4461 7461 4f72  d.GraphicsDataOr
-00015140: 7468 6f43 7562 6550 6f69 6e74 2870 546f  thoCubePoint(pTo
-00015150: 6f6c 2b5b 302c 7479 2c30 2e35 2a74 7a5d  ol+[0,ty,0.5*tz]
-00015160: 2c20 746f 6f6c 5369 7a65 2c20 636f 6c6f  , toolSize, colo
-00015170: 7254 6f6f 6c29 5d0d 0a23 2020 2020 2020  rTool)]..#      
-00015180: 2020 2020 2020 2020 2020 2067 7261 7068             graph
-00015190: 6963 734c 6973 7420 2b3d 205b 6567 642e  icsList += [egd.
-000151a0: 4772 6170 6869 6373 4461 7461 4f72 7468  GraphicsDataOrth
-000151b0: 6f43 7562 6550 6f69 6e74 2870 546f 6f6c  oCubePoint(pTool
-000151c0: 2b5b 302c 2d74 792c 302e 352a 747a 5d2c  +[0,-ty,0.5*tz],
-000151d0: 2074 6f6f 6c53 697a 652c 2063 6f6c 6f72   toolSize, color
-000151e0: 546f 6f6c 295d 0d0a 2020 2020 2020 2020  Tool)]..        
-000151f0: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-00015200: 2020 0d0a 2320 2020 2020 2020 2020 232b    ..#         #+
-00015210: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015220: 2b2b 2b2b 2b2b 2b0d 0a23 2020 2020 2020  +++++++..#      
-00015230: 2020 2023 6e6f 7720 6164 6420 626f 6479     #now add body
-00015240: 2066 6f72 206c 696e 6b3a 0d0a 2320 2020   for link:..#   
-00015250: 2020 2020 2020 5b6e 4c69 6e6b 2c62 4c69        [nLink,bLi
-00015260: 6e6b 5d3d 6572 622e 4164 6452 6967 6964  nk]=erb.AddRigid
-00015270: 426f 6479 286d 6169 6e53 7973 203d 206d  Body(mainSys = m
-00015280: 6273 2c20 696e 6572 7469 613d 696e 6572  bs, inertia=iner
-00015290: 7469 614c 696e 6b2c 200d 0a23 2020 2020  tiaLink, ..#    
-000152a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000152b0: 2020 2020 2020 2020 206e 6f64 6554 7970           nodeTyp
-000152c0: 653d 274e 6f64 6554 7970 652e 526f 7461  e='NodeType.Rota
-000152d0: 7469 6f6e 4575 6c65 7250 6172 616d 6574  tionEulerParamet
-000152e0: 6572 7327 2c20 0d0a 2320 2020 2020 2020  ers', ..#       
-000152f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015300: 2020 2020 2020 706f 7369 7469 6f6e 3d65        position=e
-00015310: 7262 2e48 5432 7472 616e 736c 6174 696f  rb.HT2translatio
-00015320: 6e28 5463 7572 7265 6e74 292c 200d 0a23  n(Tcurrent), ..#
+00014d10: 726f 7461 7469 6f6e 4d61 7472 6978 203d  rotationMatrix =
+00014d20: 2065 7262 2e48 5432 726f 7461 7469 6f6e   erb.HT2rotation
+00014d30: 4d61 7472 6978 2854 6375 7272 656e 7429  Matrix(Tcurrent)
+00014d40: 2c0a 2320 2020 2020 2020 2020 2020 2020  ,.#             
+00014d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d60: 6772 6176 6974 793d 726f 626f 745b 2767  gravity=robot['g
+00014d70: 7261 7669 7479 275d 2c20 0a23 2020 2020  ravity'], .#    
+00014d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d90: 2020 2020 2020 2020 2067 7261 7068 6963           graphic
+00014da0: 7344 6174 614c 6973 743d 6772 6170 6869  sDataList=graphi
+00014db0: 6373 4c69 7374 290a 2320 2020 2020 2020  csList).#       
+00014dc0: 2020 6e6f 6465 4c69 7374 2b3d 5b6e 4c69    nodeList+=[nLi
+00014dd0: 6e6b 5d0a 2320 2020 2020 2020 2020 626f  nk].#         bo
+00014de0: 6479 4c69 7374 2b3d 5b62 4c69 6e6b 5d0a  dyList+=[bLink].
+00014df0: 2320 2020 2020 2020 2020 2370 7269 6e74  #         #print
+00014e00: 286d 6273 2e47 6574 4f62 6a65 6374 2862  (mbs.GetObject(b
+00014e10: 4c69 6e6b 2929 0a20 2020 200a 2320 2020  Link)).    .#   
+00014e20: 2020 2020 2020 232b 2b2b 2b2b 2b2b 2b2b        #+++++++++
+00014e30: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0a  +++++++++++++++.
+00014e40: 2320 2020 2020 2020 2020 2361 6464 206d  #         #add m
+00014e50: 6172 6b65 7273 2061 6e64 206a 6f69 6e74  arkers and joint
+00014e60: 730a 2320 2020 2020 2020 2020 6d4c 696e  s.#         mLin
+00014e70: 6b30 203d 206d 6273 2e41 6464 4d61 726b  k0 = mbs.AddMark
+00014e80: 6572 2865 6969 2e4d 6172 6b65 7242 6f64  er(eii.MarkerBod
+00014e90: 7952 6967 6964 2862 6f64 794e 756d 6265  yRigid(bodyNumbe
+00014ea0: 723d 624c 696e 6b2c 206c 6f63 616c 506f  r=bLink, localPo
+00014eb0: 7369 7469 6f6e 3d70 3029 290a 2320 2020  sition=p0)).#   
+00014ec0: 2020 2020 2020 6d4c 696e 6b31 203d 206d        mLink1 = m
+00014ed0: 6273 2e41 6464 4d61 726b 6572 2865 6969  bs.AddMarker(eii
+00014ee0: 2e4d 6172 6b65 7242 6f64 7952 6967 6964  .MarkerBodyRigid
+00014ef0: 2862 6f64 794e 756d 6265 723d 624c 696e  (bodyNumber=bLin
+00014f00: 6b2c 206c 6f63 616c 506f 7369 7469 6f6e  k, localPosition
+00014f10: 3d5b 302c 302c 305d 2929 0a23 2020 2020  =[0,0,0])).#    
+00014f20: 2020 2020 206d 6172 6b65 724c 6973 7430       markerList0
+00014f30: 2b3d 5b6d 4c69 6e6b 305d 0a23 2020 2020  +=[mLink0].#    
+00014f40: 2020 2020 206d 6172 6b65 724c 6973 7431       markerList1
+00014f50: 2b3d 5b6d 4c69 6e6b 315d 0a20 2020 2020  +=[mLink1].     
+00014f60: 2020 200a 2320 2020 2020 2020 2020 726f     .#         ro
+00014f70: 7461 7469 6f6e 3120 3d20 6e70 2e69 6465  tation1 = np.ide
+00014f80: 6e74 6974 7928 3329 2023 6f6e 6c79 2075  ntity(3) #only u
+00014f90: 7365 6420 666f 7220 6261 7365 2072 6f74  sed for base rot
+00014fa0: 6174 696f 6e0a 2320 2020 2020 2020 2020  ation.#         
+00014fb0: 6966 2069 203d 3d20 303a 2023 6f6e 6c79  if i == 0: #only
+00014fc0: 2066 6f72 2062 6173 6520 7765 2063 616e   for base we can
+00014fd0: 2061 6464 2061 2074 7261 6e73 666f 726d   add a transform
+00014fe0: 6174 696f 6e0a 2320 2020 2020 2020 2020  ation.#         
+00014ff0: 2020 2020 6966 2027 726f 7461 7469 6f6e      if 'rotation
+00015000: 4d61 726b 6572 4261 7365 2720 696e 206b  MarkerBase' in k
+00015010: 7761 7267 733a 0a23 2020 2020 2020 2020  wargs:.#        
+00015020: 2020 2020 2020 2020 2072 6f74 6174 696f           rotatio
+00015030: 6e31 203d 206b 7761 7267 735b 2772 6f74  n1 = kwargs['rot
+00015040: 6174 696f 6e4d 6172 6b65 7242 6173 6527  ationMarkerBase'
+00015050: 5d0a 2020 2020 2020 2020 2020 2020 0a23  ].            .#
+00015060: 2020 2020 2020 2020 2023 7468 6973 2063           #this c
+00015070: 6f6e 6669 6775 7261 7469 6f6e 2069 7320  onfiguration is 
+00015080: 6c65 7373 206f 7074 696d 616c 2066 6f72  less optimal for
+00015090: 206c 6172 6765 7220 6a6f 696e 7420 7661   larger joint va
+000150a0: 6c75 6573 3a0a 2320 2020 2020 2320 2020  lues:.#     #   
+000150b0: 206a 6f69 6e74 4c69 6e6b 203d 206d 6273   jointLink = mbs
+000150c0: 2e41 6464 4f62 6a65 6374 2847 656e 6572  .AddObject(Gener
+000150d0: 6963 4a6f 696e 7428 6d61 726b 6572 4e75  icJoint(markerNu
+000150e0: 6d62 6572 733d 5b6c 6173 744d 6172 6b65  mbers=[lastMarke
+000150f0: 722c 206d 4c69 6e6b 305d 2c0a 2320 2020  r, mLink0],.#   
+00015100: 2020 2320 2020 2020 2020 2020 2020 2020    #             
+00015110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015120: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00015130: 6e73 7472 6169 6e65 6441 7865 733d 5b31  nstrainedAxes=[1
+00015140: 2c31 2c31 2c31 2c31 2c30 5d2c 0a23 2020  ,1,1,1,1,0],.#  
+00015150: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00015160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015170: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00015180: 6f74 6174 696f 6e4d 6172 6b65 7231 3d41  otationMarker1=A
+00015190: 3054 2c0a 2320 2020 2020 2320 2020 2020  0T,.#     #     
+000151a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000151b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000151c0: 2020 2020 2020 7669 7375 616c 697a 6174        visualizat
+000151d0: 696f 6e3d 564f 626a 6563 744a 6f69 6e74  ion=VObjectJoint
+000151e0: 4765 6e65 7269 6328 6178 6573 5261 6469  Generic(axesRadi
+000151f0: 7573 203d 2030 2e30 312c 6178 6573 4c65  us = 0.01,axesLe
+00015200: 6e67 7468 3d30 2e31 2c20 636f 6c6f 723d  ngth=0.1, color=
+00015210: 6567 642e 636f 6c6f 7234 7265 6429 2929  egd.color4red)))
+00015220: 0a23 2020 2020 2020 2020 206a 6f69 6e74  .#         joint
+00015230: 4c69 6e6b 203d 206d 6273 2e41 6464 4f62  Link = mbs.AddOb
+00015240: 6a65 6374 2865 6969 2e47 656e 6572 6963  ject(eii.Generic
+00015250: 4a6f 696e 7428 6d61 726b 6572 4e75 6d62  Joint(markerNumb
+00015260: 6572 733d 5b6d 4c69 6e6b 302c 206c 6173  ers=[mLink0, las
+00015270: 744d 6172 6b65 725d 2c0a 2320 2020 2020  tMarker],.#     
+00015280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000152a0: 2020 2020 2020 2020 2020 2063 6f6e 7374             const
+000152b0: 7261 696e 6564 4178 6573 3d5b 312c 312c  rainedAxes=[1,1,
+000152c0: 312c 312c 312c 305d 2c0a 2320 2020 2020  1,1,1,0],.#     
+000152d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000152e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000152f0: 2020 2020 2020 2020 2020 2072 6f74 6174             rotat
+00015300: 696f 6e4d 6172 6b65 7230 3d41 3054 2c0a  ionMarker0=A0T,.
+00015310: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00015320: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00015330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015340: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
-00015350: 6174 696f 6e4d 6174 7269 7820 3d20 6572  ationMatrix = er
-00015360: 622e 4854 3272 6f74 6174 696f 6e4d 6174  b.HT2rotationMat
-00015370: 7269 7828 5463 7572 7265 6e74 292c 0d0a  rix(Tcurrent),..
-00015380: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-00015390: 2020 2020 2020 2020 2020 2020 2020 6772                gr
-000153a0: 6176 6974 793d 726f 626f 745b 2767 7261  avity=robot['gra
-000153b0: 7669 7479 275d 2c20 0d0a 2320 2020 2020  vity'], ..#     
-000153c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000153d0: 2020 2020 2020 2020 6772 6170 6869 6373          graphics
-000153e0: 4461 7461 4c69 7374 3d67 7261 7068 6963  DataList=graphic
-000153f0: 734c 6973 7429 0d0a 2320 2020 2020 2020  sList)..#       
-00015400: 2020 6e6f 6465 4c69 7374 2b3d 5b6e 4c69    nodeList+=[nLi
-00015410: 6e6b 5d0d 0a23 2020 2020 2020 2020 2062  nk]..#         b
-00015420: 6f64 794c 6973 742b 3d5b 624c 696e 6b5d  odyList+=[bLink]
-00015430: 0d0a 2320 2020 2020 2020 2020 2370 7269  ..#         #pri
-00015440: 6e74 286d 6273 2e47 6574 4f62 6a65 6374  nt(mbs.GetObject
-00015450: 2862 4c69 6e6b 2929 0d0a 2020 2020 0d0a  (bLink))..    ..
-00015460: 2320 2020 2020 2020 2020 232b 2b2b 2b2b  #         #+++++
-00015470: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015480: 2b2b 2b0d 0a23 2020 2020 2020 2020 2023  +++..#         #
-00015490: 6164 6420 6d61 726b 6572 7320 616e 6420  add markers and 
-000154a0: 6a6f 696e 7473 0d0a 2320 2020 2020 2020  joints..#       
-000154b0: 2020 6d4c 696e 6b30 203d 206d 6273 2e41    mLink0 = mbs.A
-000154c0: 6464 4d61 726b 6572 2865 6969 2e4d 6172  ddMarker(eii.Mar
-000154d0: 6b65 7242 6f64 7952 6967 6964 2862 6f64  kerBodyRigid(bod
-000154e0: 794e 756d 6265 723d 624c 696e 6b2c 206c  yNumber=bLink, l
-000154f0: 6f63 616c 506f 7369 7469 6f6e 3d70 3029  ocalPosition=p0)
-00015500: 290d 0a23 2020 2020 2020 2020 206d 4c69  )..#         mLi
-00015510: 6e6b 3120 3d20 6d62 732e 4164 644d 6172  nk1 = mbs.AddMar
-00015520: 6b65 7228 6569 692e 4d61 726b 6572 426f  ker(eii.MarkerBo
-00015530: 6479 5269 6769 6428 626f 6479 4e75 6d62  dyRigid(bodyNumb
-00015540: 6572 3d62 4c69 6e6b 2c20 6c6f 6361 6c50  er=bLink, localP
-00015550: 6f73 6974 696f 6e3d 5b30 2c30 2c30 5d29  osition=[0,0,0])
-00015560: 290d 0a23 2020 2020 2020 2020 206d 6172  )..#         mar
-00015570: 6b65 724c 6973 7430 2b3d 5b6d 4c69 6e6b  kerList0+=[mLink
-00015580: 305d 0d0a 2320 2020 2020 2020 2020 6d61  0]..#         ma
-00015590: 726b 6572 4c69 7374 312b 3d5b 6d4c 696e  rkerList1+=[mLin
-000155a0: 6b31 5d0d 0a20 2020 2020 2020 200d 0a23  k1]..        ..#
-000155b0: 2020 2020 2020 2020 2072 6f74 6174 696f           rotatio
-000155c0: 6e31 203d 206e 702e 6964 656e 7469 7479  n1 = np.identity
-000155d0: 2833 2920 236f 6e6c 7920 7573 6564 2066  (3) #only used f
-000155e0: 6f72 2062 6173 6520 726f 7461 7469 6f6e  or base rotation
-000155f0: 0d0a 2320 2020 2020 2020 2020 6966 2069  ..#         if i
-00015600: 203d 3d20 303a 2023 6f6e 6c79 2066 6f72   == 0: #only for
-00015610: 2062 6173 6520 7765 2063 616e 2061 6464   base we can add
-00015620: 2061 2074 7261 6e73 666f 726d 6174 696f   a transformatio
-00015630: 6e0d 0a23 2020 2020 2020 2020 2020 2020  n..#            
-00015640: 2069 6620 2772 6f74 6174 696f 6e4d 6172   if 'rotationMar
-00015650: 6b65 7242 6173 6527 2069 6e20 6b77 6172  kerBase' in kwar
-00015660: 6773 3a0d 0a23 2020 2020 2020 2020 2020  gs:..#          
-00015670: 2020 2020 2020 2072 6f74 6174 696f 6e31         rotation1
-00015680: 203d 206b 7761 7267 735b 2772 6f74 6174   = kwargs['rotat
-00015690: 696f 6e4d 6172 6b65 7242 6173 6527 5d0d  ionMarkerBase'].
-000156a0: 0a20 2020 2020 2020 2020 2020 200d 0a23  .            ..#
-000156b0: 2020 2020 2020 2020 2023 7468 6973 2063           #this c
-000156c0: 6f6e 6669 6775 7261 7469 6f6e 2069 7320  onfiguration is 
-000156d0: 6c65 7373 206f 7074 696d 616c 2066 6f72  less optimal for
-000156e0: 206c 6172 6765 7220 6a6f 696e 7420 7661   larger joint va
-000156f0: 6c75 6573 3a0d 0a23 2020 2020 2023 2020  lues:..#     #  
-00015700: 2020 6a6f 696e 744c 696e 6b20 3d20 6d62    jointLink = mb
-00015710: 732e 4164 644f 626a 6563 7428 4765 6e65  s.AddObject(Gene
-00015720: 7269 634a 6f69 6e74 286d 6172 6b65 724e  ricJoint(markerN
-00015730: 756d 6265 7273 3d5b 6c61 7374 4d61 726b  umbers=[lastMark
-00015740: 6572 2c20 6d4c 696e 6b30 5d2c 0d0a 2320  er, mLink0],..# 
-00015750: 2020 2020 2320 2020 2020 2020 2020 2020      #           
-00015760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015780: 636f 6e73 7472 6169 6e65 6441 7865 733d  constrainedAxes=
-00015790: 5b31 2c31 2c31 2c31 2c31 2c30 5d2c 0d0a  [1,1,1,1,1,0],..
-000157a0: 2320 2020 2020 2320 2020 2020 2020 2020  #     #         
-000157b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000157c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000157d0: 2020 726f 7461 7469 6f6e 4d61 726b 6572    rotationMarker
-000157e0: 313d 4130 542c 0d0a 2320 2020 2020 2320  1=A0T,..#     # 
-000157f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015810: 2020 2020 2020 2020 2020 7669 7375 616c            visual
-00015820: 697a 6174 696f 6e3d 564f 626a 6563 744a  ization=VObjectJ
-00015830: 6f69 6e74 4765 6e65 7269 6328 6178 6573  ointGeneric(axes
-00015840: 5261 6469 7573 203d 2030 2e30 312c 6178  Radius = 0.01,ax
-00015850: 6573 4c65 6e67 7468 3d30 2e31 2c20 636f  esLength=0.1, co
-00015860: 6c6f 723d 6567 642e 636f 6c6f 7234 7265  lor=egd.color4re
-00015870: 6429 2929 0d0a 2320 2020 2020 2020 2020  d)))..#         
-00015880: 6a6f 696e 744c 696e 6b20 3d20 6d62 732e  jointLink = mbs.
-00015890: 4164 644f 626a 6563 7428 6569 692e 4765  AddObject(eii.Ge
-000158a0: 6e65 7269 634a 6f69 6e74 286d 6172 6b65  nericJoint(marke
-000158b0: 724e 756d 6265 7273 3d5b 6d4c 696e 6b30  rNumbers=[mLink0
-000158c0: 2c20 6c61 7374 4d61 726b 6572 5d2c 0d0a  , lastMarker],..
-000158d0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-000158e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000158f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015900: 2063 6f6e 7374 7261 696e 6564 4178 6573   constrainedAxes
-00015910: 3d5b 312c 312c 312c 312c 312c 305d 2c0d  =[1,1,1,1,1,0],.
-00015920: 0a23 2020 2020 2020 2020 2020 2020 2020  .#              
-00015930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015950: 2020 726f 7461 7469 6f6e 4d61 726b 6572    rotationMarker
-00015960: 303d 4130 542c 0d0a 2320 2020 2020 2020  0=A0T,..#       
-00015970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015990: 2020 2020 2020 2020 2072 6f74 6174 696f           rotatio
-000159a0: 6e4d 6172 6b65 7231 3d72 6f74 6174 696f  nMarker1=rotatio
-000159b0: 6e31 2c0d 0a23 2020 2020 2020 2020 2020  n1,..#          
-000159c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000159d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000159e0: 2020 2020 2020 7669 7375 616c 697a 6174        visualizat
-000159f0: 696f 6e3d 6569 692e 564f 626a 6563 744a  ion=eii.VObjectJ
-00015a00: 6f69 6e74 4765 6e65 7269 6328 6178 6573  ointGeneric(axes
-00015a10: 5261 6469 7573 203d 2030 2e30 312c 6178  Radius = 0.01,ax
-00015a20: 6573 4c65 6e67 7468 3d30 2e31 2c20 636f  esLength=0.1, co
-00015a30: 6c6f 723d 6567 642e 636f 6c6f 7234 7265  lor=egd.color4re
-00015a40: 6429 2929 0d0a 2020 2020 2020 2020 2020  d)))..          
-00015a50: 2020 2020 2020 0d0a 2320 2020 2020 2020        ..#       
-00015a60: 2020 236c 6f61 6420 6f6e 2070 7265 7669    #load on previ
-00015a70: 6f75 7320 626f 6479 2c20 6e65 6761 7469  ous body, negati
-00015a80: 7665 2073 6967 6e0d 0a23 2020 2020 2020  ve sign..#      
-00015a90: 2020 206c 6f61 6453 697a 6520 3d20 310d     loadSize = 1.
-00015aa0: 0a23 2020 2020 2020 2020 2074 6f72 7175  .#         torqu
-00015ab0: 6531 203d 2041 3054 2040 206e 702e 6172  e1 = A0T @ np.ar
-00015ac0: 7261 7928 5b30 2c30 2c20 6c6f 6164 5369  ray([0,0, loadSi
-00015ad0: 7a65 5d29 2023 726f 7461 7465 6420 746f  ze]) #rotated to
-00015ae0: 7271 7565 2076 6563 746f 7220 666f 7220  rque vector for 
-00015af0: 6375 7272 656e 7420 6c69 6e6b 2c20 6974  current link, it
-00015b00: 2069 7320 6e6f 7420 7468 6520 7a2d 6178   is not the z-ax
-00015b10: 6973 0d0a 2320 2020 2020 2020 2020 2370  is..#         #p
-00015b20: 7269 6e74 2822 746f 7271 7565 313d 222c  rint("torque1=",
-00015b30: 2074 6f72 7175 6531 290d 0a23 2020 2020   torque1)..#    
-00015b40: 2020 2020 2069 6620 6920 3c20 6c65 6e28       if i < len(
-00015b50: 6a6f 696e 744c 6f61 6455 7365 7246 756e  jointLoadUserFun
-00015b60: 6374 696f 6e4c 6973 7429 3a0d 0a23 2020  ctionList):..#  
-00015b70: 2020 2020 2020 2020 2020 206c 6f61 6430             load0
-00015b80: 203d 206d 6273 2e41 6464 4c6f 6164 2865   = mbs.AddLoad(e
-00015b90: 6969 2e4c 6f61 6454 6f72 7175 6556 6563  ii.LoadTorqueVec
-00015ba0: 746f 7228 6d61 726b 6572 4e75 6d62 6572  tor(markerNumber
-00015bb0: 3d6c 6173 744d 6172 6b65 722c 206c 6f61  =lastMarker, loa
-00015bc0: 6456 6563 746f 723d 5b30 2c30 2c2d 6c6f  dVector=[0,0,-lo
-00015bd0: 6164 5369 7a65 5d2c 200d 0a23 2020 2020  adSize], ..#    
-00015be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015c10: 2020 2020 2020 2020 2062 6f64 7946 6978           bodyFix
-00015c20: 6564 3d54 7275 652c 206c 6f61 6456 6563  ed=True, loadVec
-00015c30: 746f 7255 7365 7246 756e 6374 696f 6e3d  torUserFunction=
-00015c40: 6a6f 696e 744c 6f61 6455 7365 7246 756e  jointLoadUserFun
-00015c50: 6374 696f 6e4c 6973 745b 695d 2929 0d0a  ctionList[i]))..
-00015c60: 2320 2020 2020 2020 2020 2020 2020 6c6f  #             lo
-00015c70: 6164 3120 3d20 6d62 732e 4164 644c 6f61  ad1 = mbs.AddLoa
-00015c80: 6428 6569 692e 4c6f 6164 546f 7271 7565  d(eii.LoadTorque
-00015c90: 5665 6374 6f72 286d 6172 6b65 724e 756d  Vector(markerNum
-00015ca0: 6265 723d 6d4c 696e 6b30 2c20 6c6f 6164  ber=mLink0, load
-00015cb0: 5665 6374 6f72 3d74 6f72 7175 6531 2c20  Vector=torque1, 
-00015cc0: 0d0a 2320 2020 2020 2020 2020 2020 2020  ..#             
-00015cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d00: 626f 6479 4669 7865 643d 5472 7565 2c20  bodyFixed=True, 
-00015d10: 6c6f 6164 5665 6374 6f72 5573 6572 4675  loadVectorUserFu
-00015d20: 6e63 7469 6f6e 3d6a 6f69 6e74 4c6f 6164  nction=jointLoad
-00015d30: 5573 6572 4675 6e63 7469 6f6e 4c69 7374  UserFunctionList
-00015d40: 5b69 5d29 290d 0a20 2020 200d 0a23 2020  [i]))..    ..#  
-00015d50: 2020 2020 2020 2020 2020 206a 6f69 6e74             joint
-00015d60: 546f 7271 7565 304c 6973 7420 2b3d 205b  Torque0List += [
-00015d70: 6c6f 6164 305d 0d0a 2320 2020 2020 2020  load0]..#       
-00015d80: 2020 2020 2020 6a6f 696e 7454 6f72 7175        jointTorqu
-00015d90: 6531 4c69 7374 202b 3d20 5b6c 6f61 6431  e1List += [load1
-00015da0: 5d0d 0a20 2020 200d 0a23 2020 2020 2020  ]..    ..#      
-00015db0: 2020 206a 6f69 6e74 4c69 7374 2b3d 5b6a     jointList+=[j
-00015dc0: 6f69 6e74 4c69 6e6b 5d0d 0a0d 0a23 2020  ointLink]....#  
-00015dd0: 2020 2020 2020 206c 6173 744d 6172 6b65         lastMarke
-00015de0: 7220 3d20 6d4c 696e 6b31 0d0a 2320 2020  r = mLink1..#   
-00015df0: 2020 2020 2020 2365 6e64 206c 6f6f 7020        #end loop 
-00015e00: 6f76 6572 206c 696e 6b73 0d0a 2320 2020  over links..#   
-00015e10: 2020 2020 2020 232b 2b2b 2b2b 2b2b 2b2b        #+++++++++
-00015e20: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015e30: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015e40: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015e50: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d  +++++++++++++++.
-00015e60: 0a20 2020 200d 0a23 2020 2020 2064 203d  .    ..#     d =
-00015e70: 207b 276e 6f64 654c 6973 7427 3a20 6e6f   {'nodeList': no
-00015e80: 6465 4c69 7374 2c27 626f 6479 4c69 7374  deList,'bodyList
-00015e90: 273a 2062 6f64 794c 6973 742c 276a 6f69  ': bodyList,'joi
-00015ea0: 6e74 4c69 7374 273a 206a 6f69 6e74 4c69  ntList': jointLi
-00015eb0: 7374 2c0d 0a23 2020 2020 2020 2020 2020  st,..#          
-00015ec0: 276d 6172 6b65 724c 6973 7430 273a 206d  'markerList0': m
-00015ed0: 6172 6b65 724c 6973 7430 2c27 6d61 726b  arkerList0,'mark
-00015ee0: 6572 4c69 7374 3127 3a20 6d61 726b 6572  erList1': marker
-00015ef0: 4c69 7374 312c 0d0a 2320 2020 2020 2020  List1,..#       
-00015f00: 2020 2027 6a6f 696e 7454 6f72 7175 6530     'jointTorque0
-00015f10: 4c69 7374 273a 206a 6f69 6e74 546f 7271  List': jointTorq
-00015f20: 7565 304c 6973 742c 276a 6f69 6e74 546f  ue0List,'jointTo
-00015f30: 7271 7565 314c 6973 7427 3a20 6a6f 696e  rque1List': join
-00015f40: 7454 6f72 7175 6531 4c69 7374 7d0d 0a23  tTorque1List}..#
-00015f50: 2020 2020 2072 6574 7572 6e20 640d 0a0d       return d...
-00015f60: 0a0d 0a0d 0a0d 0a23 2023 2525 2b2b 2b2b  .......# #%%++++
-00015f70: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015f80: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015f90: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015fa0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015fb0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015fc0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d 0a23  +++++++++++++..#
-00015fd0: 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b   #++++++++++++++
-00015fe0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00015ff0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016000: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016010: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016020: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016030: 2b2b 2b2b 2b0d 0a23 2023 2b2b 2b2b 2b2b  +++++..# #++++++
-00016040: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016050: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016060: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016070: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016080: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
-00016090: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b0d 0a23  +++++++++++++..#
-000160a0: 2023 4445 5052 4543 4154 4544 2066 756e   #DEPRECATED fun
-000160b0: 6374 696f 6e61 6c69 7479 3a0d 0a23 2064  ctionality:..# d
-000160c0: 6832 4854 7761 726e 6564 203d 2046 616c  h2HTwarned = Fal
-000160d0: 7365 0d0a 2320 6465 6620 4448 3248 5428  se..# def DH2HT(
-000160e0: 4448 7061 7261 6d65 7465 7273 293a 0d0a  DHparameters):..
-000160f0: 2320 2020 2020 676c 6f62 616c 2064 6832  #     global dh2
-00016100: 4854 7761 726e 6564 200d 0a23 2020 2020  HTwarned ..#    
-00016110: 2069 6620 6e6f 7420 6468 3248 5477 6172   if not dh2HTwar
-00016120: 6e65 643a 0d0a 2320 2020 2020 2020 2020  ned:..#         
-00016130: 6468 3248 5477 6172 6e65 6420 3d20 5472  dh2HTwarned = Tr
-00016140: 7565 0d0a 2320 2020 2020 2020 2020 7072  ue..#         pr
-00016150: 696e 7428 2766 756e 6374 696f 6e20 4448  int('function DH
-00016160: 3248 5428 2e2e 2e29 2069 7320 6465 7072  2HT(...) is depr
-00016170: 6563 6174 6564 2c20 7573 6520 5374 6444  ecated, use StdD
-00016180: 4832 4854 2069 6e73 7465 6164 2729 0d0a  H2HT instead')..
-00016190: 2320 2020 2020 7265 7475 726e 2053 7464  #     return Std
-000161a0: 4448 3248 5428 4448 7061 7261 6d65 7465  DH2HT(DHparamete
-000161b0: 7273 290d 0a0d 0a23 2063 6f6d 7075 7465  rs)....# compute
-000161c0: 4a6f 696e 7448 5477 6172 6e65 6420 3d20  JointHTwarned = 
-000161d0: 4661 6c73 650d 0a23 2023 636f 6d70 7574  False..# #comput
-000161e0: 6520 4854 2066 6f72 2065 7665 7279 206a  e HT for every j
-000161f0: 6f69 6e74 2c20 7573 696e 6720 6769 7665  oint, using give
-00016200: 6e20 636f 6e66 6967 7572 6174 696f 6e0d  n configuration.
-00016210: 0a23 2023 2a2a 6675 6e63 7469 6f6e 3a20  .# #**function: 
-00016220: 4445 5052 4543 4154 4544 3a20 636f 6d70  DEPRECATED: comp
-00016230: 7574 6520 6c69 7374 206f 6620 2068 6f6d  ute list of  hom
-00016240: 6f67 656e 656f 7573 2074 7261 6e73 666f  ogeneous transfo
-00016250: 726d 6174 696f 6e73 2048 5420 6672 6f6d  rmations HT from
-00016260: 2062 6173 6520 746f 2065 7665 7279 206a   base to every j
-00016270: 6f69 6e74 2028 6d6f 7265 2070 7265 6369  oint (more preci
-00016280: 7365 6c79 206f 6620 6576 6572 7920 6c69  sely of every li
-00016290: 6e6b 2129 2066 6f72 2067 6976 656e 2063  nk!) for given c
-000162a0: 6f6e 6669 6775 7261 7469 6f6e 0d0a 2320  onfiguration..# 
-000162b0: 232a 2a65 7861 6d70 6c65 3a0d 0a23 2023  #**example:..# #
-000162c0: 6c69 6e6b 303d 7b27 7374 6444 4827 3a5b  link0={'stdDH':[
-000162d0: 302c 302c 302c 6e70 2e70 692f 325d 2c20  0,0,0,np.pi/2], 
-000162e0: 0d0a 2320 2320 2020 2020 2020 2020 276d  ..# #         'm
-000162f0: 6173 7327 3a32 302c 2020 236e 6f74 206e  ass':20,  #not n
-00016300: 6565 6465 6421 0d0a 2320 2320 2020 2020  eeded!..# #     
-00016310: 2020 2020 2769 6e65 7274 6961 273a 6e70      'inertia':np
-00016320: 2e64 6961 6728 5b31 652d 382c 302e 3335  .diag([1e-8,0.35
-00016330: 2c31 652d 385d 292c 2023 772e 722e 742e  ,1e-8]), #w.r.t.
-00016340: 2043 4f4d 210d 0a23 2023 2020 2020 2020   COM!..# #      
-00016350: 2020 2027 434f 4d27 3a5b 302c 302c 305d     'COM':[0,0,0]
-00016360: 7d0d 0a23 2023 6c69 6e6b 313d 7b27 7374  }..# #link1={'st
-00016370: 6444 4827 3a5b 302c 302c 302e 3433 3138  dDH':[0,0,0.4318
-00016380: 2c30 5d2c 0d0a 2320 2320 2020 2020 2020  ,0],..# #       
-00016390: 2020 276d 6173 7327 3a31 372e 342c 200d    'mass':17.4, .
-000163a0: 0a23 2023 2020 2020 2020 2020 2027 696e  .# #         'in
-000163b0: 6572 7469 6127 3a6e 702e 6469 6167 285b  ertia':np.diag([
-000163c0: 302e 3133 2c30 2e35 3234 2c30 2e35 3339  0.13,0.524,0.539
-000163d0: 5d29 2c20 2377 2e72 2e74 2e20 434f 4d21  ]), #w.r.t. COM!
-000163e0: 0d0a 2320 2320 2020 2020 2020 2020 2743  ..# #         'C
-000163f0: 4f4d 273a 5b2d 302e 3336 3338 2c20 302e  OM':[-0.3638, 0.
-00016400: 3030 362c 2030 2e32 3237 355d 7d0d 0a23  006, 0.2275]}..#
-00016410: 2023 726f 626f 743d 7b27 6c69 6e6b 7327   #robot={'links'
-00016420: 3a5b 6c69 6e6b 302c 206c 696e 6b31 5d2c  :[link0, link1],
-00016430: 0d0a 2320 2320 2020 2020 2020 2020 276a  ..# #         'j
-00016440: 6f69 6e74 5479 7065 273a 5b31 2c31 5d2c  ointType':[1,1],
-00016450: 2023 313d 7265 766f 6c75 7465 2c20 303d   #1=revolute, 0=
-00016460: 7072 6973 6d61 7469 630d 0a23 2023 2020  prismatic..# #  
-00016470: 2020 2020 2020 2027 6261 7365 273a 7b27         'base':{'
-00016480: 4854 273a 4854 3028 297d 2c0d 0a23 2023  HT':HT0()},..# #
-00016490: 2020 2020 2020 2020 2027 746f 6f6c 273a           'tool':
-000164a0: 7b27 4854 273a 4854 7472 616e 736c 6174  {'HT':HTtranslat
-000164b0: 6528 5b30 2c30 2c30 2e31 5d29 7d2c 0d0a  e([0,0,0.1])},..
-000164c0: 2320 2320 2020 2020 2020 2020 2767 7261  # #         'gra
-000164d0: 7669 7479 273a 5b30 2c30 2c39 2e38 315d  vity':[0,0,9.81]
-000164e0: 2c0d 0a23 2023 2020 2020 2020 2020 2027  ,..# #         '
-000164f0: 7265 6665 7265 6e63 6543 6f6e 6669 6775  referenceConfigu
-00016500: 7261 7469 6f6e 273a 5b30 5d2a 3220 2372  ration':[0]*2 #r
-00016510: 6566 6572 656e 6365 2063 6f6e 6669 6775  eference configu
-00016520: 7261 7469 6f6e 2066 6f72 2062 6f64 6965  ration for bodie
-00016530: 733b 2061 7420 7768 6963 6820 7468 6520  s; at which the 
-00016540: 726f 626f 7420 6973 2062 7569 6c74 0d0a  robot is built..
-00016550: 2320 2320 2020 2020 2020 2020 7d20 0d0a  # #         } ..
-00016560: 2320 2348 546c 6973 7420 3d20 436f 6d70  # #HTlist = Comp
-00016570: 7574 654a 6f69 6e74 4854 2872 6f62 6f74  uteJointHT(robot
-00016580: 2c20 5b6e 702e 7069 2f38 5d2a 3229 0d0a  , [np.pi/8]*2)..
-00016590: 2320 6465 6620 436f 6d70 7574 654a 6f69  # def ComputeJoi
-000165a0: 6e74 4854 2872 6f62 6f74 2c20 636f 6e66  ntHT(robot, conf
-000165b0: 6967 7572 6174 696f 6e29 3a0d 0a23 2020  iguration):..#  
-000165c0: 2020 2067 6c6f 6261 6c20 636f 6d70 7574     global comput
-000165d0: 654a 6f69 6e74 4854 7761 726e 6564 0d0a  eJointHTwarned..
-000165e0: 2320 2020 2020 6966 206e 6f74 2063 6f6d  #     if not com
-000165f0: 7075 7465 4a6f 696e 7448 5477 6172 6e65  puteJointHTwarne
-00016600: 643a 0d0a 2320 2020 2020 2020 2020 636f  d:..#         co
-00016610: 6d70 7574 654a 6f69 6e74 4854 7761 726e  mputeJointHTwarn
-00016620: 6564 203d 2054 7275 650d 0a23 2020 2020  ed = True..#    
-00016630: 2020 2020 2070 7269 6e74 2827 6675 6e63       print('func
-00016640: 7469 6f6e 2043 6f6d 7075 7465 4a6f 696e  tion ComputeJoin
-00016650: 7448 5428 726f 626f 742c 2063 6f6e 6669  tHT(robot, confi
-00016660: 6775 7261 7469 6f6e 2920 6973 2064 6570  guration) is dep
-00016670: 7265 6361 7465 642c 2075 7365 2052 6f62  recated, use Rob
-00016680: 6f74 2e4a 6f69 6e74 4854 282e 2e2e 2920  ot.JointHT(...) 
-00016690: 6f66 2063 6c61 7373 2052 6f62 6f74 2069  of class Robot i
-000166a0: 6e73 7465 6164 2729 0d0a 0d0a 2320 2020  nstead')....#   
-000166b0: 2020 5463 7572 7265 6e74 203d 2072 6f62    Tcurrent = rob
-000166c0: 6f74 5b27 6261 7365 275d 5b27 4854 275d  ot['base']['HT']
-000166d0: 0d0a 2320 2020 2020 4854 203d 205b 5d0d  ..#     HT = [].
-000166e0: 0a20 2020 200d 0a23 2020 2020 2066 6f72  .    ..#     for
-000166f0: 2069 2069 6e20 7261 6e67 6528 6c65 6e28   i in range(len(
-00016700: 726f 626f 745b 276c 696e 6b73 275d 2929  robot['links']))
-00016710: 3a0d 0a23 2020 2020 2020 2020 206c 696e  :..#         lin
-00016720: 6b20 3d20 726f 626f 745b 276c 696e 6b73  k = robot['links
-00016730: 275d 5b69 5d0d 0a23 2020 2020 2020 2020  '][i]..#        
-00016740: 2044 4870 6172 616d 203d 206e 702e 7a65   DHparam = np.ze
-00016750: 726f 7328 3429 0d0a 2320 2020 2020 2020  ros(4)..#       
-00016760: 2020 4448 7061 7261 6d5b 303a 345d 203d    DHparam[0:4] =
-00016770: 206c 696e 6b5b 2773 7464 4448 275d 5b30   link['stdDH'][0
-00016780: 3a34 5d20 2363 6f70 7973 2063 6f6e 7465  :4] #copys conte
-00016790: 6e74 210d 0a23 2020 2020 2020 2020 2069  nt!..#         i
-000167a0: 6620 726f 626f 745b 276a 6f69 6e74 5479  f robot['jointTy
-000167b0: 7065 275d 5b69 5d20 3d3d 2031 3a20 2331  pe'][i] == 1: #1
-000167c0: 3d3d 7265 766f 6c75 7465 2c20 303d 3d70  ==revolute, 0==p
-000167d0: 7269 736d 6174 6963 0d0a 2320 2020 2020  rismatic..#     
-000167e0: 2020 2020 2020 2020 4448 7061 7261 6d5b          DHparam[
-000167f0: 305d 203d 2063 6f6e 6669 6775 7261 7469  0] = configurati
-00016800: 6f6e 5b69 5d20 2361 6464 2063 7572 7265  on[i] #add curre
-00016810: 6e74 2061 6e67 6c65 0d0a 2320 2020 2020  nt angle..#     
-00016820: 2020 2020 656c 7365 3a0d 0a23 2020 2020      else:..#    
-00016830: 2020 2020 2020 2020 2044 4870 6172 616d           DHparam
-00016840: 5b31 5d20 3d20 636f 6e66 6967 7572 6174  [1] = configurat
-00016850: 696f 6e5b 695d 2023 6164 6420 6375 7272  ion[i] #add curr
-00016860: 656e 7420 6469 7370 6c61 6365 6d65 6e74  ent displacement
-00016870: 0d0a 2020 2020 2020 2020 2020 2020 0d0a  ..            ..
-00016880: 2320 2020 2020 2020 2020 5430 3120 3d20  #         T01 = 
-00016890: 4448 3248 5428 4448 7061 7261 6d29 2023  DH2HT(DHparam) #
-000168a0: 7472 616e 7366 6f72 6d61 7469 6f6e 2066  transformation f
-000168b0: 726f 6d20 6c61 7374 206c 696e 6b20 746f  rom last link to
-000168c0: 2074 6869 7320 6c69 6e6b 3b20 6974 2064   this link; it d
-000168d0: 6566 696e 6573 2074 6865 206f 7269 656e  efines the orien
-000168e0: 7461 7469 6f6e 206f 6620 7468 6520 626f  tation of the bo
-000168f0: 6479 0d0a 2320 2020 2020 2020 2020 5463  dy..#         Tc
-00016900: 7572 7265 6e74 203d 2054 6375 7272 656e  urrent = Tcurren
-00016910: 7420 4020 5430 310d 0a23 2020 2020 2020  t @ T01..#      
-00016920: 2020 2048 5420 2b3d 205b 5463 7572 7265     HT += [Tcurre
-00016930: 6e74 5d0d 0a20 2020 200d 0a23 2020 2020  nt]..    ..#    
-00016940: 2072 6574 7572 6e20 4854 0d0a 0d0a 0d0a   return HT......
-00016950: 2320 636f 6d70 7574 6543 4f4d 4854 7761  # computeCOMHTwa
-00016960: 726e 6564 203d 2046 616c 7365 0d0a 2320  rned = False..# 
-00016970: 2363 6f6d 7075 7465 2048 5420 666f 7220  #compute HT for 
-00016980: 6576 6572 7920 6c69 6e6b 2773 2043 4f4d  every link's COM
-00016990: 3b20 7461 6b65 7320 6375 7272 656e 7420  ; takes current 
-000169a0: 6a6f 696e 7448 5420 6173 2069 6e70 7574  jointHT as input
-000169b0: 0d0a 2320 232a 2a66 756e 6374 696f 6e3a  ..# #**function:
-000169c0: 2044 4550 5245 4341 5445 443a 2063 6f6d   DEPRECATED: com
-000169d0: 7075 7465 206c 6973 7420 6f66 2020 686f  pute list of  ho
-000169e0: 6d6f 6765 6e65 6f75 7320 7472 616e 7366  mogeneous transf
-000169f0: 6f72 6d61 7469 6f6e 7320 4854 2066 726f  ormations HT fro
-00016a00: 6d20 6261 7365 2074 6f20 6576 6572 7920  m base to every 
-00016a10: 434f 4d20 7573 696e 6720 4854 206c 6973  COM using HT lis
-00016a20: 7420 6672 6f6d 2043 6f6d 7075 7465 4a6f  t from ComputeJo
-00016a30: 696e 7448 540d 0a23 2064 6566 2043 6f6d  intHT..# def Com
-00016a40: 7075 7465 434f 4d48 5428 726f 626f 742c  puteCOMHT(robot,
-00016a50: 2048 5429 3a0d 0a23 2020 2020 2067 6c6f   HT):..#     glo
-00016a60: 6261 6c20 636f 6d70 7574 6543 4f4d 4854  bal computeCOMHT
-00016a70: 7761 726e 6564 0d0a 2320 2020 2020 6966  warned..#     if
-00016a80: 206e 6f74 2063 6f6d 7075 7465 434f 4d48   not computeCOMH
-00016a90: 5477 6172 6e65 643a 0d0a 2320 2020 2020  Twarned:..#     
-00016aa0: 2020 2020 636f 6d70 7574 6543 4f4d 4854      computeCOMHT
-00016ab0: 7761 726e 6564 203d 2054 7275 650d 0a23  warned = True..#
-00016ac0: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-00016ad0: 6675 6e63 7469 6f6e 2043 6f6d 7075 7465  function Compute
-00016ae0: 434f 4d48 5428 726f 626f 742c 2048 5429  COMHT(robot, HT)
-00016af0: 2069 7320 6465 7072 6563 6174 6564 2c20   is deprecated, 
-00016b00: 7573 6520 526f 626f 742e 434f 4d48 5428  use Robot.COMHT(
-00016b10: 2e2e 2e29 206f 6620 636c 6173 7320 526f  ...) of class Ro
-00016b20: 626f 7420 696e 7374 6561 6427 290d 0a23  bot instead')..#
-00016b30: 2020 2020 2048 5443 4f4d 203d 205b 5d0d       HTCOM = [].
-00016b40: 0a20 2020 200d 0a23 2020 2020 2023 4854  .    ..#     #HT
-00016b50: 434f 4d20 2b3d 205b 726f 626f 745b 2762  COM += [robot['b
-00016b60: 6173 6527 5d5b 2748 5427 5d5d 0d0a 2320  ase']['HT']]..# 
-00016b70: 2020 2020 666f 7220 6920 696e 2072 616e      for i in ran
-00016b80: 6765 286c 656e 2872 6f62 6f74 5b27 6c69  ge(len(robot['li
-00016b90: 6e6b 7327 5d29 293a 0d0a 2320 2020 2020  nks'])):..#     
-00016ba0: 2020 2020 6c69 6e6b 203d 2072 6f62 6f74      link = robot
-00016bb0: 5b27 6c69 6e6b 7327 5d5b 695d 0d0a 2320  ['links'][i]..# 
-00016bc0: 2020 2020 2020 2020 4854 434f 4d20 2b3d          HTCOM +=
-00016bd0: 205b 4854 5b69 5d20 4020 6572 622e 4854   [HT[i] @ erb.HT
-00016be0: 7472 616e 736c 6174 6528 6c69 6e6b 5b27  translate(link['
-00016bf0: 434f 4d27 5d29 5d0d 0a20 2020 200d 0a23  COM'])]..    ..#
-00016c00: 2020 2020 2072 6574 7572 6e20 4854 434f       return HTCO
-00016c10: 4d0d 0a0d 0a23 2063 6f6d 7075 7465 5374  M....# computeSt
-00016c20: 6174 6963 546f 7271 7565 7377 6172 6e65  aticTorqueswarne
-00016c30: 643d 4661 6c73 650d 0a23 2023 636f 6d70  d=False..# #comp
-00016c40: 7574 6520 7374 6174 6963 2074 6f72 7175  ute static torqu
-00016c50: 6573 2066 6f72 2072 6f62 6f74 2064 6566  es for robot def
-00016c60: 696e 6564 2062 7920 4448 2d70 6172 616d  ined by DH-param
-00016c70: 6574 6572 7320 616e 6420 666f 7220 6769  eters and for gi
-00016c80: 7665 6e20 4854 0d0a 2320 232a 2a66 756e  ven HT..# #**fun
-00016c90: 6374 696f 6e3a 2044 4550 5245 4341 5445  ction: DEPRECATE
-00016ca0: 443a 2063 6f6d 7075 7465 206c 6973 7420  D: compute list 
-00016cb0: 6a6f 696e 7420 746f 7271 7565 7320 666f  joint torques fo
-00016cc0: 7220 7365 7269 616c 2072 6f62 6f74 2075  r serial robot u
-00016cd0: 6e64 6572 2067 7261 7669 7479 2028 6772  nder gravity (gr
-00016ce0: 6176 6974 7920 616e 6420 6d61 7373 2061  avity and mass a
-00016cf0: 7320 6769 7665 6e20 696e 2072 6f62 6f74  s given in robot
-00016d00: 290d 0a23 2064 6566 2043 6f6d 7075 7465  )..# def Compute
-00016d10: 5374 6174 6963 546f 7271 7565 7328 726f  StaticTorques(ro
-00016d20: 626f 742c 4854 293a 0d0a 2320 2020 2020  bot,HT):..#     
-00016d30: 676c 6f62 616c 2063 6f6d 7075 7465 5374  global computeSt
-00016d40: 6174 6963 546f 7271 7565 7377 6172 6e65  aticTorqueswarne
-00016d50: 640d 0a23 2020 2020 2069 6620 6e6f 7420  d..#     if not 
-00016d60: 636f 6d70 7574 6553 7461 7469 6354 6f72  computeStaticTor
-00016d70: 7175 6573 7761 726e 6564 3a0d 0a23 2020  queswarned:..#  
-00016d80: 2020 2020 2020 2063 6f6d 7075 7465 5374         computeSt
-00016d90: 6174 6963 546f 7271 7565 7377 6172 6e65  aticTorqueswarne
-00016da0: 6420 3d20 5472 7565 0d0a 2320 2020 2020  d = True..#     
-00016db0: 2020 2020 7072 696e 7428 2766 756e 6374      print('funct
-00016dc0: 696f 6e20 436f 6d70 7574 6553 7461 7469  ion ComputeStati
-00016dd0: 6354 6f72 7175 6573 2872 6f62 6f74 2c20  cTorques(robot, 
-00016de0: 4854 2920 6973 2064 6570 7265 6361 7465  HT) is deprecate
-00016df0: 642c 2075 7365 2052 6f62 6f74 2e53 7461  d, use Robot.Sta
-00016e00: 7469 6354 6f72 7175 6573 282e 2e2e 2920  ticTorques(...) 
-00016e10: 6f66 2063 6c61 7373 2052 6f62 6f74 2069  of class Robot i
-00016e20: 6e73 7465 6164 2729 0d0a 2320 2020 2020  nstead')..#     
-00016e30: 6a6f 696e 7454 6f72 7175 6573 203d 206e  jointTorques = n
-00016e40: 702e 7a65 726f 7328 6e70 2e73 697a 6528  p.zeros(np.size(
-00016e50: 726f 626f 745b 276c 696e 6b73 275d 2929  robot['links']))
-00016e60: 0d0a 2320 2020 2020 236f 6c64 2c20 6c69  ..#     #old, li
-00016e70: 6d69 7465 6420 746f 2036 206a 6f69 6e74  mited to 6 joint
-00016e80: 733a 206a 6f69 6e74 546f 7271 7565 7320  s: jointTorques 
-00016e90: 3d20 6e70 2e7a 6572 6f73 2836 290d 0a0d  = np.zeros(6)...
-00016ea0: 0a23 2020 2020 2023 636f 6d70 7574 6520  .#     #compute 
-00016eb0: 4854 7320 666f 7220 434f 4d0d 0a23 2020  HTs for COM..#  
-00016ec0: 2020 2048 5463 6f6d 3d43 6f6d 7075 7465     HTcom=Compute
-00016ed0: 434f 4d48 5428 726f 626f 742c 2048 5429  COMHT(robot, HT)
-00016ee0: 0d0a 2320 2020 2020 6772 6176 203d 206e  ..#     grav = n
-00016ef0: 702e 6172 7261 7928 726f 626f 745b 2767  p.array(robot['g
-00016f00: 7261 7669 7479 275d 290d 0a20 2020 200d  ravity'])..    .
-00016f10: 0a23 2020 2020 2023 7375 6d20 7570 2074  .#     #sum up t
-00016f20: 6865 2074 6f72 7175 6573 206f 6620 616c  he torques of al
-00016f30: 6c20 6772 6176 6974 7920 6c6f 6164 733a  l gravity loads:
-00016f40: 0d0a 2320 2020 2020 666f 7220 6920 696e  ..#     for i in
-00016f50: 2072 616e 6765 286c 656e 2848 5463 6f6d   range(len(HTcom
-00016f60: 2929 3a0d 0a23 2020 2020 2020 2020 2070  )):..#         p
-00016f70: 203d 2065 7262 2e48 5432 7472 616e 736c   = erb.HT2transl
-00016f80: 6174 696f 6e28 4854 636f 6d5b 695d 290d  ation(HTcom[i]).
-00016f90: 0a23 2020 2020 2020 2020 204a 636f 6d3d  .#         Jcom=
-00016fa0: 4a61 636f 6269 616e 2872 6f62 6f74 2c48  Jacobian(robot,H
-00016fb0: 545b 303a 692b 315d 2c74 6f6f 6c50 6f73  T[0:i+1],toolPos
-00016fc0: 6974 696f 6e3d 702c 6d6f 6465 3d27 7472  ition=p,mode='tr
-00016fd0: 616e 7327 290d 0a23 2020 2020 2020 2020  ans')..#        
-00016fe0: 2023 7072 696e 7428 6572 622e 4854 3274   #print(erb.HT2t
-00016ff0: 7261 6e73 6c61 7469 6f6e 2848 5463 6f6d  ranslation(HTcom
-00017000: 5b69 5d29 290d 0a23 2020 2020 2020 2020  [i]))..#        
-00017010: 2066 4720 3d20 726f 626f 745b 276c 696e   fG = robot['lin
-00017020: 6b73 275d 5b69 5d5b 276d 6173 7327 5d20  ks'][i]['mass'] 
-00017030: 2a20 6772 6176 0d0a 2320 2020 2020 2020  * grav..#       
-00017040: 2020 2370 7269 6e74 2866 4729 0d0a 2320    #print(fG)..# 
-00017050: 2020 2020 2020 2020 7461 7520 3d20 4a63          tau = Jc
-00017060: 6f6d 2e54 2040 2066 470d 0a23 2020 2020  om.T @ fG..#    
-00017070: 2020 2020 206a 6f69 6e74 546f 7271 7565       jointTorque
-00017080: 735b 303a 692b 315d 202b 3d20 7461 750d  s[0:i+1] += tau.
-00017090: 0a23 2020 2020 2072 6574 7572 6e20 6a6f  .#     return jo
-000170a0: 696e 7454 6f72 7175 6573 0d0a 0d0a 0d0a  intTorques......
-000170b0: 2320 636f 6d70 7574 654a 6163 6f62 6961  # computeJacobia
-000170c0: 6e77 6172 6e65 643d 4661 6c73 650d 0a23  nwarned=False..#
-000170d0: 2023 636f 6d70 7574 6520 6a61 636f 6269   #compute jacobi
-000170e0: 616e 2c20 6e65 6564 7320 7065 722d 6c69  an, needs per-li
-000170f0: 6e6b 2048 5420 696e 2063 7572 7265 6e74  nk HT in current
-00017100: 2063 6f6e 6669 6775 7261 7469 6f6e 0d0a   configuration..
-00017110: 2320 2372 756e 7320 6f76 6572 206e 756d  # #runs over num
-00017120: 6265 7220 6f66 2048 5473 2067 6976 656e  ber of HTs given
-00017130: 2069 6e20 4854 2028 6d61 7920 6265 206c   in HT (may be l
-00017140: 6573 7320 7468 616e 206e 756d 6265 7220  ess than number 
-00017150: 6f66 206c 696e 6b73 290d 0a23 2023 6d6f  of links)..# #mo
-00017160: 6465 7320 6172 653a 2027 616c 6c27 2c20  des are: 'all', 
-00017170: 2774 7261 6e73 272e 2e2e 6f6e 6c79 2074  'trans'...only t
-00017180: 7261 6e73 6c61 7469 6f6e 2070 6172 742c  ranslation part,
-00017190: 2027 726f 7427 3a20 6f6e 6c79 2072 6f74   'rot': only rot
-000171a0: 6174 696f 6e20 7061 7274 0d0a 2320 232a  ation part..# #*
-000171b0: 2a66 756e 6374 696f 6e3a 2044 4550 5245  *function: DEPRE
-000171c0: 4341 5445 443a 2063 6f6d 7075 7465 206a  CATED: compute j
-000171d0: 6163 6f62 6961 6e20 666f 7220 7472 616e  acobian for tran
-000171e0: 736c 6174 696f 6e20 616e 6420 726f 7461  slation and rota
-000171f0: 7469 6f6e 2061 7420 746f 6f6c 506f 7369  tion at toolPosi
-00017200: 7469 6f6e 2075 7369 6e67 206a 6f69 6e74  tion using joint
-00017210: 2048 540d 0a23 2064 6566 204a 6163 6f62   HT..# def Jacob
-00017220: 6961 6e28 726f 626f 742c 4854 2c74 6f6f  ian(robot,HT,too
-00017230: 6c50 6f73 6974 696f 6e3d 5b5d 2c6d 6f64  lPosition=[],mod
-00017240: 653d 2761 6c6c 2729 3a0d 0a23 2020 2020  e='all'):..#    
-00017250: 2067 6c6f 6261 6c20 636f 6d70 7574 654a   global computeJ
-00017260: 6163 6f62 6961 6e77 6172 6e65 640d 0a23  acobianwarned..#
-00017270: 2020 2020 2069 6620 6e6f 7420 636f 6d70       if not comp
-00017280: 7574 654a 6163 6f62 6961 6e77 6172 6e65  uteJacobianwarne
-00017290: 643a 0d0a 2320 2020 2020 2020 2020 636f  d:..#         co
-000172a0: 6d70 7574 654a 6163 6f62 6961 6e77 6172  mputeJacobianwar
-000172b0: 6e65 6420 3d20 5472 7565 0d0a 2320 2020  ned = True..#   
-000172c0: 2020 2020 2020 7072 696e 7428 2766 756e        print('fun
-000172d0: 6374 696f 6e20 4a61 636f 6269 616e 2872  ction Jacobian(r
-000172e0: 6f62 6f74 2c20 4854 2c2e 2e2e 2920 6973  obot, HT,...) is
-000172f0: 2064 6570 7265 6361 7465 642c 2075 7365   deprecated, use
-00017300: 2052 6f62 6f74 2e4a 6163 6f62 6961 6e28   Robot.Jacobian(
-00017310: 2e2e 2e29 206f 6620 636c 6173 7320 526f  ...) of class Ro
-00017320: 626f 7420 696e 7374 6561 6427 290d 0a23  bot instead')..#
-00017330: 2020 2020 206e 203d 206c 656e 2848 5429       n = len(HT)
-00017340: 0d0a 2320 2020 2020 6966 206e 203e 206c  ..#     if n > l
-00017350: 656e 2872 6f62 6f74 5b27 6c69 6e6b 7327  en(robot['links'
-00017360: 5d29 3a0d 0a23 2020 2020 2020 2020 2070  ]):..#         p
-00017370: 7269 6e74 2822 4552 524f 523a 206e 756d  rint("ERROR: num
-00017380: 6265 7220 6f66 2068 6f6d 6f67 656e 656f  ber of homogeneo
-00017390: 7573 2074 7261 6e73 666f 726d 6174 696f  us transformatio
-000173a0: 6e73 2028 4854 2920 6772 6561 7465 7220  ns (HT) greater 
-000173b0: 7468 616e 206e 756d 6265 7220 6f66 206c  than number of l
-000173c0: 696e 6b73 2229 0d0a 0d0a 2320 2020 2020  inks")....#     
-000173d0: 4a6f 6d65 6761 203d 206e 702e 7a65 726f  Jomega = np.zero
-000173e0: 7328 2833 2c6e 2929 2372 6f74 6174 696f  s((3,n))#rotatio
-000173f0: 6e20 7061 7274 206f 6620 6a61 636f 6269  n part of jacobi
-00017400: 616e 0d0a 2320 2020 2020 4a76 656c 203d  an..#     Jvel =
-00017410: 206e 702e 7a65 726f 7328 2833 2c6e 2929   np.zeros((3,n))
-00017420: 2020 2374 7261 6e73 6c61 7469 6f6e 2070    #translation p
-00017430: 6172 7420 6f66 206a 6163 6f62 6961 6e0d  art of jacobian.
-00017440: 0a23 2020 2020 2041 203d 2065 7262 2e48  .#     A = erb.H
-00017450: 5432 726f 7461 7469 6f6e 4d61 7472 6978  T2rotationMatrix
-00017460: 2872 6f62 6f74 5b27 6261 7365 275d 5b27  (robot['base']['
-00017470: 4854 275d 290d 0a23 2020 2020 2072 6f74  HT'])..#     rot
-00017480: 4178 6973 203d 206e 702e 6172 7261 7928  Axis = np.array(
-00017490: 5b30 2c30 2c31 5d29 2023 726f 626f 7420  [0,0,1]) #robot 
-000174a0: 6178 6973 2069 6e20 6c6f 6361 6c20 636f  axis in local co
-000174b0: 6f72 6469 6e61 7465 730d 0a23 2020 2020  ordinates..#    
-000174c0: 2076 5072 6576 696f 7573 203d 2065 7262   vPrevious = erb
-000174d0: 2e48 5432 7472 616e 736c 6174 696f 6e28  .HT2translation(
-000174e0: 726f 626f 745b 2762 6173 6527 5d5b 2748  robot['base']['H
-000174f0: 5427 5d29 0d0a 2320 2020 2020 766e 203d  T'])..#     vn =
-00017500: 2074 6f6f 6c50 6f73 6974 696f 6e0d 0a23   toolPosition..#
-00017510: 2020 2020 2069 6620 6c65 6e28 766e 2920       if len(vn) 
-00017520: 3d3d 2030 3a0d 0a23 2020 2020 2020 2020  == 0:..#        
-00017530: 2076 6e20 3d20 6572 622e 4854 3274 7261   vn = erb.HT2tra
-00017540: 6e73 6c61 7469 6f6e 2848 545b 2d31 5d29  nslation(HT[-1])
-00017550: 2023 746f 6f6c 2070 6f73 6974 696f 6e2c   #tool position,
-00017560: 2066 6f72 206a 6163 6f62 6961 6e20 2863   for jacobian (c
-00017570: 6f75 6c64 2069 6e63 6c75 6465 2074 6f6f  ould include too
-00017580: 6c20 6974 7365 6c66 290d 0a20 2020 200d  l itself)..    .
-00017590: 0a23 2020 2020 2023 6372 6561 7465 2072  .#     #create r
-000175a0: 6f62 6f74 206e 6f64 6573 2061 6e64 2062  obot nodes and b
-000175b0: 6f64 6965 733a 0d0a 2320 2020 2020 666f  odies:..#     fo
-000175c0: 7220 6920 696e 2072 616e 6765 286e 293a  r i in range(n):
-000175d0: 0d0a 2020 2020 2020 2020 0d0a 2320 2020  ..        ..#   
-000175e0: 2020 2020 2020 6966 2069 203e 2030 3a0d        if i > 0:.
-000175f0: 0a23 2020 2020 2020 2020 2020 2020 2041  .#             A
-00017600: 203d 2065 7262 2e48 5432 726f 7461 7469   = erb.HT2rotati
-00017610: 6f6e 4d61 7472 6978 2848 545b 692d 315d  onMatrix(HT[i-1]
-00017620: 2920 2372 6f74 6174 696f 6e20 6f66 206a  ) #rotation of j
-00017630: 6f69 6e74 2069 0d0a 2320 2020 2020 2020  oint i..#       
-00017640: 2020 6178 6973 203d 2041 2040 2072 6f74    axis = A @ rot
-00017650: 4178 6973 2023 6178 6973 2069 6e20 676c  Axis #axis in gl
-00017660: 6f62 616c 2063 6f6f 7264 696e 6174 6573  obal coordinates
-00017670: 0d0a 2320 2020 2020 2020 2020 4a6f 6d65  ..#         Jome
-00017680: 6761 5b30 3a33 2c69 5d20 3d20 726f 626f  ga[0:3,i] = robo
-00017690: 745b 276a 6f69 6e74 5479 7065 275d 5b69  t['jointType'][i
-000176a0: 5d20 2a20 6178 6973 2023 6f6e 6c79 2063  ] * axis #only c
-000176b0: 6f6e 7369 6465 7265 642c 2069 6620 7265  onsidered, if re
-000176c0: 766f 6c75 7465 206a 6f69 6e74 0d0a 2020  volute joint..  
-000176d0: 2020 2020 2020 0d0a 2320 2020 2020 2020        ..#       
-000176e0: 2020 6966 2069 203e 2030 3a0d 0a23 2020    if i > 0:..#  
-000176f0: 2020 2020 2020 2020 2020 2076 5072 6576             vPrev
-00017700: 696f 7573 203d 2065 7262 2e48 5432 7472  ious = erb.HT2tr
-00017710: 616e 736c 6174 696f 6e28 4854 5b69 2d31  anslation(HT[i-1
-00017720: 5d29 0d0a 2020 2020 2020 2020 200d 0a23  ])..         ..#
-00017730: 2020 2020 2020 2020 2023 7265 766f 6c75           #revolu
-00017740: 7465 206a 6f69 6e74 3a0d 0a23 2020 2020  te joint:..#    
-00017750: 2020 2020 2069 6620 726f 626f 745b 276a       if robot['j
-00017760: 6f69 6e74 5479 7065 275d 5b69 5d20 3d3d  ointType'][i] ==
-00017770: 2031 3a20 2372 6576 6f6c 7574 6520 6a6f   1: #revolute jo
-00017780: 696e 740d 0a23 2020 2020 2020 2020 2020  int..#          
-00017790: 2020 204a 7665 6c5b 303a 332c 695d 2020     Jvel[0:3,i]  
-000177a0: 203d 2065 7262 2e53 6b65 7728 6178 6973   = erb.Skew(axis
-000177b0: 2920 4020 2876 6e20 2d20 7650 7265 7669  ) @ (vn - vPrevi
-000177c0: 6f75 7329 2023 6f6e 6c79 2063 6f6e 7369  ous) #only consi
-000177d0: 6465 7265 642c 2069 6620 7265 766f 6c75  dered, if revolu
-000177e0: 7465 206a 6f69 6e74 0d0a 2320 2020 2020  te joint..#     
-000177f0: 2020 2020 656c 7365 3a20 2370 7269 736d      else: #prism
-00017800: 6174 6963 206a 6f69 6e74 0d0a 2320 2020  atic joint..#   
-00017810: 2020 2020 2020 2020 2020 4a76 656c 5b30            Jvel[0
-00017820: 3a33 2c69 5d20 2020 3d20 6178 6973 2023  :3,i]   = axis #
-00017830: 4e4f 5420 5445 5354 4544 2121 210d 0a20  NOT TESTED!!!.. 
-00017840: 2020 200d 0a23 2020 2020 2069 6620 6d6f     ..#     if mo
-00017850: 6465 203d 3d20 2761 6c6c 273a 0d0a 2320  de == 'all':..# 
-00017860: 2020 2020 2020 2020 4a20 3d20 6e70 2e7a          J = np.z
-00017870: 6572 6f73 2828 362c 6e29 290d 0a23 2020  eros((6,n))..#  
-00017880: 2020 2065 6c73 653a 0d0a 2320 2020 2020     else:..#     
-00017890: 2020 2020 4a20 3d20 6e70 2e7a 6572 6f73      J = np.zeros
-000178a0: 2828 332c 6e29 290d 0a20 2020 200d 0a23  ((3,n))..    ..#
-000178b0: 2020 2020 2069 6620 6d6f 6465 203d 3d20       if mode == 
-000178c0: 2772 6f74 273a 0d0a 2320 2020 2020 2020  'rot':..#       
-000178d0: 2020 4a5b 303a 332c 303a 6e5d 203d 204a    J[0:3,0:n] = J
-000178e0: 6f6d 6567 610d 0a23 2020 2020 2065 6c69  omega..#     eli
-000178f0: 6620 6d6f 6465 203d 3d20 2774 7261 6e73  f mode == 'trans
-00017900: 273a 0d0a 2320 2020 2020 2020 2020 4a5b  ':..#         J[
-00017910: 303a 332c 303a 6e5d 203d 204a 7665 6c0d  0:3,0:n] = Jvel.
-00017920: 0a23 2020 2020 2065 6c69 6620 6d6f 6465  .#     elif mode
-00017930: 203d 3d20 2761 6c6c 273a 0d0a 2320 2020   == 'all':..#   
-00017940: 2020 2020 2020 4a5b 303a 332c 303a 6e5d        J[0:3,0:n]
-00017950: 203d 204a 7665 6c0d 0a23 2020 2020 2020   = Jvel..#      
-00017960: 2020 204a 5b33 3a36 2c30 3a6e 5d20 3d20     J[3:6,0:n] = 
-00017970: 4a6f 6d65 6761 0d0a 0d0a 2320 2020 2020  Jomega....#     
-00017980: 7265 7475 726e 204a 0d0a 0d0a 0d0a 0d0a  return J........
-00017990: 2320 2374 6865 2066 6f6c 6c6f 7769 6e67  # #the following
-000179a0: 2066 756e 6374 696f 6e73 2075 7365 2061   functions use a
-000179b0: 2073 7472 7563 7475 7265 2066 6f72 2074   structure for t
-000179c0: 6865 2064 6573 6372 6970 7469 6f6e 206f  he description o
-000179d0: 6620 7468 6520 726f 626f 7420 6163 636f  f the robot acco
-000179e0: 7264 696e 6720 746f 3a0d 0a23 2023 206c  rding to:..# # l
-000179f0: 696e 6b30 3d7b 2773 7464 4448 273a 5b30  ink0={'stdDH':[0
-00017a00: 2c30 2c30 2c6e 702e 7069 2f32 5d2c 2023  ,0,0,np.pi/2], #
-00017a10: 7468 6574 612c 2064 2c20 612c 2061 6c70  theta, d, a, alp
-00017a20: 6861 0d0a 2320 2020 2020 2020 2023 2027  ha..#        # '
-00017a30: 6d61 7373 273a 3230 2c20 2023 6e6f 7420  mass':20,  #not 
-00017a40: 6e65 6564 6564 210d 0a23 2020 2020 2020  needed!..#      
-00017a50: 2020 2320 2769 6e65 7274 6961 273a 6e70    # 'inertia':np
-00017a60: 2e64 6961 6728 5b31 652d 382c 302e 3335  .diag([1e-8,0.35
-00017a70: 2c31 652d 385d 292c 2023 772e 722e 742e  ,1e-8]), #w.r.t.
-00017a80: 2043 4f4d 210d 0a23 2020 2020 2020 2020   COM!..#        
-00017a90: 2320 2743 4f4d 273a 5b30 2c30 2c30 5d7d  # 'COM':[0,0,0]}
-00017aa0: 0d0a 0d0a 2320 2320 6c69 6e6b 313d 7b27  ....# # link1={'
-00017ab0: 7374 6444 4827 3a5b 302c 302c 302e 3433  stdDH':[0,0,0.43
-00017ac0: 3138 2c30 5d2c 0d0a 2320 2020 2020 2020  18,0],..#       
-00017ad0: 2023 2027 6d61 7373 273a 3137 2e34 2c20   # 'mass':17.4, 
-00017ae0: 0d0a 2320 2020 2020 2020 2023 2027 696e  ..#        # 'in
-00017af0: 6572 7469 6127 3a6e 702e 6469 6167 285b  ertia':np.diag([
-00017b00: 302e 3133 2c30 2e35 3234 2c30 2e35 3339  0.13,0.524,0.539
-00017b10: 5d29 2c20 2377 2e72 2e74 2e20 434f 4d21  ]), #w.r.t. COM!
-00017b20: 0d0a 2320 2020 2020 2020 2023 2027 434f  ..#        # 'CO
-00017b30: 4d27 3a5b 2d30 2e33 3633 382c 2030 2e30  M':[-0.3638, 0.0
-00017b40: 3036 2c20 302e 3232 3735 5d7d 0d0a 0d0a  06, 0.2275]}....
-00017b50: 2320 2320 6c69 6e6b 323d 7b27 7374 6444  # # link2={'stdD
-00017b60: 4827 3a5b 302c 302e 3135 2c30 2e30 3230  H':[0,0.15,0.020
-00017b70: 332c 2d6e 702e 7069 2f32 5d2c 200d 0a23  3,-np.pi/2], ..#
-00017b80: 2020 2020 2020 2020 2320 276d 6173 7327          # 'mass'
-00017b90: 3a34 2e38 2c20 0d0a 2320 2020 2020 2020  :4.8, ..#       
-00017ba0: 2023 2027 696e 6572 7469 6127 3a6e 702e   # 'inertia':np.
-00017bb0: 6469 6167 285b 302e 3036 362c 302e 3038  diag([0.066,0.08
-00017bc0: 362c 302e 3031 3235 5d29 2c20 2377 2e72  6,0.0125]), #w.r
-00017bd0: 2e74 2e20 434f 4d21 0d0a 2320 2020 2020  .t. COM!..#     
-00017be0: 2020 2023 2027 434f 4d27 3a5b 2d30 2e30     # 'COM':[-0.0
-00017bf0: 3230 332c 2d30 2e30 3134 312c 302e 3037  203,-0.0141,0.07
-00017c00: 5d7d 0d0a 0d0a 2320 2320 6c69 6e6b 333d  ]}....# # link3=
-00017c10: 7b27 7374 6444 4827 3a5b 302c 302e 3433  {'stdDH':[0,0.43
-00017c20: 3138 2c30 2c6e 702e 7069 2f32 5d2c 200d  18,0,np.pi/2], .
-00017c30: 0a23 2020 2020 2020 2020 2320 276d 6173  .#        # 'mas
-00017c40: 7327 3a30 2e38 322c 200d 0a23 2020 2020  s':0.82, ..#    
-00017c50: 2020 2020 2320 2769 6e65 7274 6961 273a      # 'inertia':
-00017c60: 6e70 2e64 6961 6728 5b30 2e30 3031 382c  np.diag([0.0018,
-00017c70: 302e 3030 3133 2c30 2e30 3031 385d 292c  0.0013,0.0018]),
-00017c80: 2023 772e 722e 742e 2043 4f4d 210d 0a23   #w.r.t. COM!..#
-00017c90: 2020 2020 2020 2020 2320 2743 4f4d 273a          # 'COM':
-00017ca0: 5b30 2c30 2e30 3139 2c30 5d7d 0d0a 0d0a  [0,0.019,0]}....
-00017cb0: 2320 2320 6c69 6e6b 343d 7b27 7374 6444  # # link4={'stdD
-00017cc0: 4827 3a5b 302c 302c 302c 2d6e 702e 7069  H':[0,0,0,-np.pi
-00017cd0: 2f32 5d2c 200d 0a23 2020 2020 2020 2020  /2], ..#        
-00017ce0: 2320 276d 6173 7327 3a30 2e33 342c 200d  # 'mass':0.34, .
-00017cf0: 0a23 2020 2020 2020 2020 2320 2769 6e65  .#        # 'ine
-00017d00: 7274 6961 273a 6e70 2e64 6961 6728 5b30  rtia':np.diag([0
-00017d10: 2e30 3030 332c 302e 3030 3034 2c30 2e30  .0003,0.0004,0.0
-00017d20: 3030 335d 292c 2023 772e 722e 742e 2043  003]), #w.r.t. C
-00017d30: 4f4d 210d 0a23 2020 2020 2020 2020 2320  OM!..#        # 
-00017d40: 2743 4f4d 273a 5b30 2c30 2c30 5d7d 0d0a  'COM':[0,0,0]}..
-00017d50: 0d0a 2320 2320 6c69 6e6b 353d 7b27 7374  ..# # link5={'st
-00017d60: 6444 4827 3a5b 302c 302c 302c 305d 2c20  dDH':[0,0,0,0], 
-00017d70: 0d0a 2320 2020 2020 2020 2023 2027 6d61  ..#        # 'ma
-00017d80: 7373 273a 302e 3039 2c20 0d0a 2320 2020  ss':0.09, ..#   
-00017d90: 2020 2020 2023 2027 696e 6572 7469 6127       # 'inertia'
-00017da0: 3a6e 702e 6469 6167 285b 302e 3030 3031  :np.diag([0.0001
-00017db0: 352c 302e 3030 3031 352c 3465 2d35 5d29  5,0.00015,4e-5])
-00017dc0: 2c20 2377 2e72 2e74 2e20 434f 4d21 0d0a  , #w.r.t. COM!..
-00017dd0: 2320 2020 2020 2020 2023 2027 434f 4d27  #        # 'COM'
-00017de0: 3a5b 302c 302c 302e 3033 325d 7d0d 0a0d  :[0,0,0.032]}...
-00017df0: 0a23 2023 2023 7468 6973 2069 7320 7468  .# # #this is th
-00017e00: 6520 676c 6f62 616c 2072 6f62 6f74 2073  e global robot s
-00017e10: 7472 7563 7475 7265 0d0a 2320 2320 726f  tructure..# # ro
-00017e20: 626f 743d 7b27 6c69 6e6b 7327 3a5b 6c69  bot={'links':[li
-00017e30: 6e6b 302c 206c 696e 6b31 2c20 6c69 6e6b  nk0, link1, link
-00017e40: 322c 206c 696e 6b33 2c20 6c69 6e6b 342c  2, link3, link4,
-00017e50: 206c 696e 6b35 5d2c 0d0a 2320 2020 2020   link5],..#     
-00017e60: 2020 2023 2027 6a6f 696e 7454 7970 6527     # 'jointType'
-00017e70: 3a5b 312c 312c 312c 312c 312c 315d 2c20  :[1,1,1,1,1,1], 
-00017e80: 2331 3d72 6576 6f6c 7574 652c 2030 3d70  #1=revolute, 0=p
-00017e90: 7269 736d 6174 6963 0d0a 2320 2020 2020  rismatic..#     
-00017ea0: 2020 2023 2027 6261 7365 273a 7b27 4854     # 'base':{'HT
-00017eb0: 273a 6572 622e 4854 3028 297d 2c0d 0a23  ':erb.HT0()},..#
-00017ec0: 2020 2020 2020 2020 2320 2774 6f6f 6c27          # 'tool'
-00017ed0: 3a7b 2748 5427 3a65 7262 2e48 5474 7261  :{'HT':erb.HTtra
-00017ee0: 6e73 6c61 7465 285b 302c 302c 302e 315d  nslate([0,0,0.1]
-00017ef0: 297d 2c0d 0a23 2020 2020 2020 2020 2320  )},..#        # 
-00017f00: 2767 7261 7669 7479 273a 5b30 2c30 2c39  'gravity':[0,0,9
-00017f10: 2e38 315d 2c0d 0a23 2020 2020 2020 2020  .81],..#        
-00017f20: 2320 2772 6566 6572 656e 6365 436f 6e66  # 'referenceConf
-00017f30: 6967 7572 6174 696f 6e27 3a5b 305d 2a36  iguration':[0]*6
-00017f40: 2023 7265 6665 7265 6e63 6520 636f 6e66   #reference conf
-00017f50: 6967 7572 6174 696f 6e20 666f 7220 626f  iguration for bo
-00017f60: 6469 6573 3b20 6174 2077 6869 6368 2074  dies; at which t
-00017f70: 6865 2072 6f62 6f74 2069 7320 6275 696c  he robot is buil
-00017f80: 740d 0a23 2020 2020 2020 2020 2320 7d20  t..#        # } 
-00017f90: 0d0a 0d0a                                ....
+00015340: 2072 6f74 6174 696f 6e4d 6172 6b65 7231   rotationMarker1
+00015350: 3d72 6f74 6174 696f 6e31 2c0a 2320 2020  =rotation1,.#   
+00015360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015380: 2020 2020 2020 2020 2020 2020 2076 6973               vis
+00015390: 7561 6c69 7a61 7469 6f6e 3d65 6969 2e56  ualization=eii.V
+000153a0: 4f62 6a65 6374 4a6f 696e 7447 656e 6572  ObjectJointGener
+000153b0: 6963 2861 7865 7352 6164 6975 7320 3d20  ic(axesRadius = 
+000153c0: 302e 3031 2c61 7865 734c 656e 6774 683d  0.01,axesLength=
+000153d0: 302e 312c 2063 6f6c 6f72 3d65 6764 2e63  0.1, color=egd.c
+000153e0: 6f6c 6f72 3472 6564 2929 290a 2020 2020  olor4red))).    
+000153f0: 2020 2020 2020 2020 2020 2020 0a23 2020              .#  
+00015400: 2020 2020 2020 2023 6c6f 6164 206f 6e20         #load on 
+00015410: 7072 6576 696f 7573 2062 6f64 792c 206e  previous body, n
+00015420: 6567 6174 6976 6520 7369 676e 0a23 2020  egative sign.#  
+00015430: 2020 2020 2020 206c 6f61 6453 697a 6520         loadSize 
+00015440: 3d20 310a 2320 2020 2020 2020 2020 746f  = 1.#         to
+00015450: 7271 7565 3120 3d20 4130 5420 4020 6e70  rque1 = A0T @ np
+00015460: 2e61 7272 6179 285b 302c 302c 206c 6f61  .array([0,0, loa
+00015470: 6453 697a 655d 2920 2372 6f74 6174 6564  dSize]) #rotated
+00015480: 2074 6f72 7175 6520 7665 6374 6f72 2066   torque vector f
+00015490: 6f72 2063 7572 7265 6e74 206c 696e 6b2c  or current link,
+000154a0: 2069 7420 6973 206e 6f74 2074 6865 207a   it is not the z
+000154b0: 2d61 7869 730a 2320 2020 2020 2020 2020  -axis.#         
+000154c0: 2370 7269 6e74 2822 746f 7271 7565 313d  #print("torque1=
+000154d0: 222c 2074 6f72 7175 6531 290a 2320 2020  ", torque1).#   
+000154e0: 2020 2020 2020 6966 2069 203c 206c 656e        if i < len
+000154f0: 286a 6f69 6e74 4c6f 6164 5573 6572 4675  (jointLoadUserFu
+00015500: 6e63 7469 6f6e 4c69 7374 293a 0a23 2020  nctionList):.#  
+00015510: 2020 2020 2020 2020 2020 206c 6f61 6430             load0
+00015520: 203d 206d 6273 2e41 6464 4c6f 6164 2865   = mbs.AddLoad(e
+00015530: 6969 2e4c 6f61 6454 6f72 7175 6556 6563  ii.LoadTorqueVec
+00015540: 746f 7228 6d61 726b 6572 4e75 6d62 6572  tor(markerNumber
+00015550: 3d6c 6173 744d 6172 6b65 722c 206c 6f61  =lastMarker, loa
+00015560: 6456 6563 746f 723d 5b30 2c30 2c2d 6c6f  dVector=[0,0,-lo
+00015570: 6164 5369 7a65 5d2c 200a 2320 2020 2020  adSize], .#     
+00015580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000155a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000155b0: 2020 2020 2020 2020 626f 6479 4669 7865          bodyFixe
+000155c0: 643d 5472 7565 2c20 6c6f 6164 5665 6374  d=True, loadVect
+000155d0: 6f72 5573 6572 4675 6e63 7469 6f6e 3d6a  orUserFunction=j
+000155e0: 6f69 6e74 4c6f 6164 5573 6572 4675 6e63  ointLoadUserFunc
+000155f0: 7469 6f6e 4c69 7374 5b69 5d29 290a 2320  tionList[i])).# 
+00015600: 2020 2020 2020 2020 2020 2020 6c6f 6164              load
+00015610: 3120 3d20 6d62 732e 4164 644c 6f61 6428  1 = mbs.AddLoad(
+00015620: 6569 692e 4c6f 6164 546f 7271 7565 5665  eii.LoadTorqueVe
+00015630: 6374 6f72 286d 6172 6b65 724e 756d 6265  ctor(markerNumbe
+00015640: 723d 6d4c 696e 6b30 2c20 6c6f 6164 5665  r=mLink0, loadVe
+00015650: 6374 6f72 3d74 6f72 7175 6531 2c20 0a23  ctor=torque1, .#
+00015660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015690: 2020 2020 2020 2020 2020 2020 2062 6f64               bod
+000156a0: 7946 6978 6564 3d54 7275 652c 206c 6f61  yFixed=True, loa
+000156b0: 6456 6563 746f 7255 7365 7246 756e 6374  dVectorUserFunct
+000156c0: 696f 6e3d 6a6f 696e 744c 6f61 6455 7365  ion=jointLoadUse
+000156d0: 7246 756e 6374 696f 6e4c 6973 745b 695d  rFunctionList[i]
+000156e0: 2929 0a20 2020 200a 2320 2020 2020 2020  )).    .#       
+000156f0: 2020 2020 2020 6a6f 696e 7454 6f72 7175        jointTorqu
+00015700: 6530 4c69 7374 202b 3d20 5b6c 6f61 6430  e0List += [load0
+00015710: 5d0a 2320 2020 2020 2020 2020 2020 2020  ].#             
+00015720: 6a6f 696e 7454 6f72 7175 6531 4c69 7374  jointTorque1List
+00015730: 202b 3d20 5b6c 6f61 6431 5d0a 2020 2020   += [load1].    
+00015740: 0a23 2020 2020 2020 2020 206a 6f69 6e74  .#         joint
+00015750: 4c69 7374 2b3d 5b6a 6f69 6e74 4c69 6e6b  List+=[jointLink
+00015760: 5d0a 0a23 2020 2020 2020 2020 206c 6173  ]..#         las
+00015770: 744d 6172 6b65 7220 3d20 6d4c 696e 6b31  tMarker = mLink1
+00015780: 0a23 2020 2020 2020 2020 2023 656e 6420  .#         #end 
+00015790: 6c6f 6f70 206f 7665 7220 6c69 6e6b 730a  loop over links.
+000157a0: 2320 2020 2020 2020 2020 232b 2b2b 2b2b  #         #+++++
+000157b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000157c0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000157d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000157e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000157f0: 2b2b 2b0a 2020 2020 0a23 2020 2020 2064  +++.    .#     d
+00015800: 203d 207b 276e 6f64 654c 6973 7427 3a20   = {'nodeList': 
+00015810: 6e6f 6465 4c69 7374 2c27 626f 6479 4c69  nodeList,'bodyLi
+00015820: 7374 273a 2062 6f64 794c 6973 742c 276a  st': bodyList,'j
+00015830: 6f69 6e74 4c69 7374 273a 206a 6f69 6e74  ointList': joint
+00015840: 4c69 7374 2c0a 2320 2020 2020 2020 2020  List,.#         
+00015850: 2027 6d61 726b 6572 4c69 7374 3027 3a20   'markerList0': 
+00015860: 6d61 726b 6572 4c69 7374 302c 276d 6172  markerList0,'mar
+00015870: 6b65 724c 6973 7431 273a 206d 6172 6b65  kerList1': marke
+00015880: 724c 6973 7431 2c0a 2320 2020 2020 2020  rList1,.#       
+00015890: 2020 2027 6a6f 696e 7454 6f72 7175 6530     'jointTorque0
+000158a0: 4c69 7374 273a 206a 6f69 6e74 546f 7271  List': jointTorq
+000158b0: 7565 304c 6973 742c 276a 6f69 6e74 546f  ue0List,'jointTo
+000158c0: 7271 7565 314c 6973 7427 3a20 6a6f 696e  rque1List': join
+000158d0: 7454 6f72 7175 6531 4c69 7374 7d0a 2320  tTorque1List}.# 
+000158e0: 2020 2020 7265 7475 726e 2064 0a0a 0a0a      return d....
+000158f0: 0a23 2023 2525 2b2b 2b2b 2b2b 2b2b 2b2b  .# #%%++++++++++
+00015900: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015910: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015920: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015930: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015940: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015950: 2b2b 2b2b 2b2b 2b0a 2320 232b 2b2b 2b2b  +++++++.# #+++++
+00015960: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015970: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015980: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015990: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000159a0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000159b0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 0a23  ++++++++++++++.#
+000159c0: 2023 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b   #++++++++++++++
+000159d0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000159e0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+000159f0: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015a00: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015a10: 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b 2b2b  ++++++++++++++++
+00015a20: 2b2b 2b2b 2b0a 2320 2344 4550 5245 4341  +++++.# #DEPRECA
+00015a30: 5445 4420 6675 6e63 7469 6f6e 616c 6974  TED functionalit
+00015a40: 793a 0a23 2064 6832 4854 7761 726e 6564  y:.# dh2HTwarned
+00015a50: 203d 2046 616c 7365 0a23 2064 6566 2044   = False.# def D
+00015a60: 4832 4854 2844 4870 6172 616d 6574 6572  H2HT(DHparameter
+00015a70: 7329 3a0a 2320 2020 2020 676c 6f62 616c  s):.#     global
+00015a80: 2064 6832 4854 7761 726e 6564 200a 2320   dh2HTwarned .# 
+00015a90: 2020 2020 6966 206e 6f74 2064 6832 4854      if not dh2HT
+00015aa0: 7761 726e 6564 3a0a 2320 2020 2020 2020  warned:.#       
+00015ab0: 2020 6468 3248 5477 6172 6e65 6420 3d20    dh2HTwarned = 
+00015ac0: 5472 7565 0a23 2020 2020 2020 2020 2070  True.#         p
+00015ad0: 7269 6e74 2827 6675 6e63 7469 6f6e 2044  rint('function D
+00015ae0: 4832 4854 282e 2e2e 2920 6973 2064 6570  H2HT(...) is dep
+00015af0: 7265 6361 7465 642c 2075 7365 2053 7464  recated, use Std
+00015b00: 4448 3248 5420 696e 7374 6561 6427 290a  DH2HT instead').
+00015b10: 2320 2020 2020 7265 7475 726e 2053 7464  #     return Std
+00015b20: 4448 3248 5428 4448 7061 7261 6d65 7465  DH2HT(DHparamete
+00015b30: 7273 290a 0a23 2063 6f6d 7075 7465 4a6f  rs)..# computeJo
+00015b40: 696e 7448 5477 6172 6e65 6420 3d20 4661  intHTwarned = Fa
+00015b50: 6c73 650a 2320 2363 6f6d 7075 7465 2048  lse.# #compute H
+00015b60: 5420 666f 7220 6576 6572 7920 6a6f 696e  T for every join
+00015b70: 742c 2075 7369 6e67 2067 6976 656e 2063  t, using given c
+00015b80: 6f6e 6669 6775 7261 7469 6f6e 0a23 2023  onfiguration.# #
+00015b90: 2a2a 6675 6e63 7469 6f6e 3a20 4445 5052  **function: DEPR
+00015ba0: 4543 4154 4544 3a20 636f 6d70 7574 6520  ECATED: compute 
+00015bb0: 6c69 7374 206f 6620 2068 6f6d 6f67 656e  list of  homogen
+00015bc0: 656f 7573 2074 7261 6e73 666f 726d 6174  eous transformat
+00015bd0: 696f 6e73 2048 5420 6672 6f6d 2062 6173  ions HT from bas
+00015be0: 6520 746f 2065 7665 7279 206a 6f69 6e74  e to every joint
+00015bf0: 2028 6d6f 7265 2070 7265 6369 7365 6c79   (more precisely
+00015c00: 206f 6620 6576 6572 7920 6c69 6e6b 2129   of every link!)
+00015c10: 2066 6f72 2067 6976 656e 2063 6f6e 6669   for given confi
+00015c20: 6775 7261 7469 6f6e 0a23 2023 2a2a 6578  guration.# #**ex
+00015c30: 616d 706c 653a 0a23 2023 6c69 6e6b 303d  ample:.# #link0=
+00015c40: 7b27 7374 6444 4827 3a5b 302c 302c 302c  {'stdDH':[0,0,0,
+00015c50: 6e70 2e70 692f 325d 2c20 0a23 2023 2020  np.pi/2], .# #  
+00015c60: 2020 2020 2020 2027 6d61 7373 273a 3230         'mass':20
+00015c70: 2c20 2023 6e6f 7420 6e65 6564 6564 210a  ,  #not needed!.
+00015c80: 2320 2320 2020 2020 2020 2020 2769 6e65  # #         'ine
+00015c90: 7274 6961 273a 6e70 2e64 6961 6728 5b31  rtia':np.diag([1
+00015ca0: 652d 382c 302e 3335 2c31 652d 385d 292c  e-8,0.35,1e-8]),
+00015cb0: 2023 772e 722e 742e 2043 4f4d 210a 2320   #w.r.t. COM!.# 
+00015cc0: 2320 2020 2020 2020 2020 2743 4f4d 273a  #         'COM':
+00015cd0: 5b30 2c30 2c30 5d7d 0a23 2023 6c69 6e6b  [0,0,0]}.# #link
+00015ce0: 313d 7b27 7374 6444 4827 3a5b 302c 302c  1={'stdDH':[0,0,
+00015cf0: 302e 3433 3138 2c30 5d2c 0a23 2023 2020  0.4318,0],.# #  
+00015d00: 2020 2020 2020 2027 6d61 7373 273a 3137         'mass':17
+00015d10: 2e34 2c20 0a23 2023 2020 2020 2020 2020  .4, .# #        
+00015d20: 2027 696e 6572 7469 6127 3a6e 702e 6469   'inertia':np.di
+00015d30: 6167 285b 302e 3133 2c30 2e35 3234 2c30  ag([0.13,0.524,0
+00015d40: 2e35 3339 5d29 2c20 2377 2e72 2e74 2e20  .539]), #w.r.t. 
+00015d50: 434f 4d21 0a23 2023 2020 2020 2020 2020  COM!.# #        
+00015d60: 2027 434f 4d27 3a5b 2d30 2e33 3633 382c   'COM':[-0.3638,
+00015d70: 2030 2e30 3036 2c20 302e 3232 3735 5d7d   0.006, 0.2275]}
+00015d80: 0a23 2023 726f 626f 743d 7b27 6c69 6e6b  .# #robot={'link
+00015d90: 7327 3a5b 6c69 6e6b 302c 206c 696e 6b31  s':[link0, link1
+00015da0: 5d2c 0a23 2023 2020 2020 2020 2020 2027  ],.# #         '
+00015db0: 6a6f 696e 7454 7970 6527 3a5b 312c 315d  jointType':[1,1]
+00015dc0: 2c20 2331 3d72 6576 6f6c 7574 652c 2030  , #1=revolute, 0
+00015dd0: 3d70 7269 736d 6174 6963 0a23 2023 2020  =prismatic.# #  
+00015de0: 2020 2020 2020 2027 6261 7365 273a 7b27         'base':{'
+00015df0: 4854 273a 4854 3028 297d 2c0a 2320 2320  HT':HT0()},.# # 
+00015e00: 2020 2020 2020 2020 2774 6f6f 6c27 3a7b          'tool':{
+00015e10: 2748 5427 3a48 5474 7261 6e73 6c61 7465  'HT':HTtranslate
+00015e20: 285b 302c 302c 302e 315d 297d 2c0a 2320  ([0,0,0.1])},.# 
+00015e30: 2320 2020 2020 2020 2020 2767 7261 7669  #         'gravi
+00015e40: 7479 273a 5b30 2c30 2c39 2e38 315d 2c0a  ty':[0,0,9.81],.
+00015e50: 2320 2320 2020 2020 2020 2020 2772 6566  # #         'ref
+00015e60: 6572 656e 6365 436f 6e66 6967 7572 6174  erenceConfigurat
+00015e70: 696f 6e27 3a5b 305d 2a32 2023 7265 6665  ion':[0]*2 #refe
+00015e80: 7265 6e63 6520 636f 6e66 6967 7572 6174  rence configurat
+00015e90: 696f 6e20 666f 7220 626f 6469 6573 3b20  ion for bodies; 
+00015ea0: 6174 2077 6869 6368 2074 6865 2072 6f62  at which the rob
+00015eb0: 6f74 2069 7320 6275 696c 740a 2320 2320  ot is built.# # 
+00015ec0: 2020 2020 2020 2020 7d20 0a23 2023 4854          } .# #HT
+00015ed0: 6c69 7374 203d 2043 6f6d 7075 7465 4a6f  list = ComputeJo
+00015ee0: 696e 7448 5428 726f 626f 742c 205b 6e70  intHT(robot, [np
+00015ef0: 2e70 692f 385d 2a32 290a 2320 6465 6620  .pi/8]*2).# def 
+00015f00: 436f 6d70 7574 654a 6f69 6e74 4854 2872  ComputeJointHT(r
+00015f10: 6f62 6f74 2c20 636f 6e66 6967 7572 6174  obot, configurat
+00015f20: 696f 6e29 3a0a 2320 2020 2020 676c 6f62  ion):.#     glob
+00015f30: 616c 2063 6f6d 7075 7465 4a6f 696e 7448  al computeJointH
+00015f40: 5477 6172 6e65 640a 2320 2020 2020 6966  Twarned.#     if
+00015f50: 206e 6f74 2063 6f6d 7075 7465 4a6f 696e   not computeJoin
+00015f60: 7448 5477 6172 6e65 643a 0a23 2020 2020  tHTwarned:.#    
+00015f70: 2020 2020 2063 6f6d 7075 7465 4a6f 696e       computeJoin
+00015f80: 7448 5477 6172 6e65 6420 3d20 5472 7565  tHTwarned = True
+00015f90: 0a23 2020 2020 2020 2020 2070 7269 6e74  .#         print
+00015fa0: 2827 6675 6e63 7469 6f6e 2043 6f6d 7075  ('function Compu
+00015fb0: 7465 4a6f 696e 7448 5428 726f 626f 742c  teJointHT(robot,
+00015fc0: 2063 6f6e 6669 6775 7261 7469 6f6e 2920   configuration) 
+00015fd0: 6973 2064 6570 7265 6361 7465 642c 2075  is deprecated, u
+00015fe0: 7365 2052 6f62 6f74 2e4a 6f69 6e74 4854  se Robot.JointHT
+00015ff0: 282e 2e2e 2920 6f66 2063 6c61 7373 2052  (...) of class R
+00016000: 6f62 6f74 2069 6e73 7465 6164 2729 0a0a  obot instead')..
+00016010: 2320 2020 2020 5463 7572 7265 6e74 203d  #     Tcurrent =
+00016020: 2072 6f62 6f74 5b27 6261 7365 275d 5b27   robot['base']['
+00016030: 4854 275d 0a23 2020 2020 2048 5420 3d20  HT'].#     HT = 
+00016040: 5b5d 0a20 2020 200a 2320 2020 2020 666f  [].    .#     fo
+00016050: 7220 6920 696e 2072 616e 6765 286c 656e  r i in range(len
+00016060: 2872 6f62 6f74 5b27 6c69 6e6b 7327 5d29  (robot['links'])
+00016070: 293a 0a23 2020 2020 2020 2020 206c 696e  ):.#         lin
+00016080: 6b20 3d20 726f 626f 745b 276c 696e 6b73  k = robot['links
+00016090: 275d 5b69 5d0a 2320 2020 2020 2020 2020  '][i].#         
+000160a0: 4448 7061 7261 6d20 3d20 6e70 2e7a 6572  DHparam = np.zer
+000160b0: 6f73 2834 290a 2320 2020 2020 2020 2020  os(4).#         
+000160c0: 4448 7061 7261 6d5b 303a 345d 203d 206c  DHparam[0:4] = l
+000160d0: 696e 6b5b 2773 7464 4448 275d 5b30 3a34  ink['stdDH'][0:4
+000160e0: 5d20 2363 6f70 7973 2063 6f6e 7465 6e74  ] #copys content
+000160f0: 210a 2320 2020 2020 2020 2020 6966 2072  !.#         if r
+00016100: 6f62 6f74 5b27 6a6f 696e 7454 7970 6527  obot['jointType'
+00016110: 5d5b 695d 203d 3d20 313a 2023 313d 3d72  ][i] == 1: #1==r
+00016120: 6576 6f6c 7574 652c 2030 3d3d 7072 6973  evolute, 0==pris
+00016130: 6d61 7469 630a 2320 2020 2020 2020 2020  matic.#         
+00016140: 2020 2020 4448 7061 7261 6d5b 305d 203d      DHparam[0] =
+00016150: 2063 6f6e 6669 6775 7261 7469 6f6e 5b69   configuration[i
+00016160: 5d20 2361 6464 2063 7572 7265 6e74 2061  ] #add current a
+00016170: 6e67 6c65 0a23 2020 2020 2020 2020 2065  ngle.#         e
+00016180: 6c73 653a 0a23 2020 2020 2020 2020 2020  lse:.#          
+00016190: 2020 2044 4870 6172 616d 5b31 5d20 3d20     DHparam[1] = 
+000161a0: 636f 6e66 6967 7572 6174 696f 6e5b 695d  configuration[i]
+000161b0: 2023 6164 6420 6375 7272 656e 7420 6469   #add current di
+000161c0: 7370 6c61 6365 6d65 6e74 0a20 2020 2020  splacement.     
+000161d0: 2020 2020 2020 200a 2320 2020 2020 2020         .#       
+000161e0: 2020 5430 3120 3d20 4448 3248 5428 4448    T01 = DH2HT(DH
+000161f0: 7061 7261 6d29 2023 7472 616e 7366 6f72  param) #transfor
+00016200: 6d61 7469 6f6e 2066 726f 6d20 6c61 7374  mation from last
+00016210: 206c 696e 6b20 746f 2074 6869 7320 6c69   link to this li
+00016220: 6e6b 3b20 6974 2064 6566 696e 6573 2074  nk; it defines t
+00016230: 6865 206f 7269 656e 7461 7469 6f6e 206f  he orientation o
+00016240: 6620 7468 6520 626f 6479 0a23 2020 2020  f the body.#    
+00016250: 2020 2020 2054 6375 7272 656e 7420 3d20       Tcurrent = 
+00016260: 5463 7572 7265 6e74 2040 2054 3031 0a23  Tcurrent @ T01.#
+00016270: 2020 2020 2020 2020 2048 5420 2b3d 205b           HT += [
+00016280: 5463 7572 7265 6e74 5d0a 2020 2020 0a23  Tcurrent].    .#
+00016290: 2020 2020 2072 6574 7572 6e20 4854 0a0a       return HT..
+000162a0: 0a23 2063 6f6d 7075 7465 434f 4d48 5477  .# computeCOMHTw
+000162b0: 6172 6e65 6420 3d20 4661 6c73 650a 2320  arned = False.# 
+000162c0: 2363 6f6d 7075 7465 2048 5420 666f 7220  #compute HT for 
+000162d0: 6576 6572 7920 6c69 6e6b 2773 2043 4f4d  every link's COM
+000162e0: 3b20 7461 6b65 7320 6375 7272 656e 7420  ; takes current 
+000162f0: 6a6f 696e 7448 5420 6173 2069 6e70 7574  jointHT as input
+00016300: 0a23 2023 2a2a 6675 6e63 7469 6f6e 3a20  .# #**function: 
+00016310: 4445 5052 4543 4154 4544 3a20 636f 6d70  DEPRECATED: comp
+00016320: 7574 6520 6c69 7374 206f 6620 2068 6f6d  ute list of  hom
+00016330: 6f67 656e 656f 7573 2074 7261 6e73 666f  ogeneous transfo
+00016340: 726d 6174 696f 6e73 2048 5420 6672 6f6d  rmations HT from
+00016350: 2062 6173 6520 746f 2065 7665 7279 2043   base to every C
+00016360: 4f4d 2075 7369 6e67 2048 5420 6c69 7374  OM using HT list
+00016370: 2066 726f 6d20 436f 6d70 7574 654a 6f69   from ComputeJoi
+00016380: 6e74 4854 0a23 2064 6566 2043 6f6d 7075  ntHT.# def Compu
+00016390: 7465 434f 4d48 5428 726f 626f 742c 2048  teCOMHT(robot, H
+000163a0: 5429 3a0a 2320 2020 2020 676c 6f62 616c  T):.#     global
+000163b0: 2063 6f6d 7075 7465 434f 4d48 5477 6172   computeCOMHTwar
+000163c0: 6e65 640a 2320 2020 2020 6966 206e 6f74  ned.#     if not
+000163d0: 2063 6f6d 7075 7465 434f 4d48 5477 6172   computeCOMHTwar
+000163e0: 6e65 643a 0a23 2020 2020 2020 2020 2063  ned:.#         c
+000163f0: 6f6d 7075 7465 434f 4d48 5477 6172 6e65  omputeCOMHTwarne
+00016400: 6420 3d20 5472 7565 0a23 2020 2020 2020  d = True.#      
+00016410: 2020 2070 7269 6e74 2827 6675 6e63 7469     print('functi
+00016420: 6f6e 2043 6f6d 7075 7465 434f 4d48 5428  on ComputeCOMHT(
+00016430: 726f 626f 742c 2048 5429 2069 7320 6465  robot, HT) is de
+00016440: 7072 6563 6174 6564 2c20 7573 6520 526f  precated, use Ro
+00016450: 626f 742e 434f 4d48 5428 2e2e 2e29 206f  bot.COMHT(...) o
+00016460: 6620 636c 6173 7320 526f 626f 7420 696e  f class Robot in
+00016470: 7374 6561 6427 290a 2320 2020 2020 4854  stead').#     HT
+00016480: 434f 4d20 3d20 5b5d 0a20 2020 200a 2320  COM = [].    .# 
+00016490: 2020 2020 2348 5443 4f4d 202b 3d20 5b72      #HTCOM += [r
+000164a0: 6f62 6f74 5b27 6261 7365 275d 5b27 4854  obot['base']['HT
+000164b0: 275d 5d0a 2320 2020 2020 666f 7220 6920  ']].#     for i 
+000164c0: 696e 2072 616e 6765 286c 656e 2872 6f62  in range(len(rob
+000164d0: 6f74 5b27 6c69 6e6b 7327 5d29 293a 0a23  ot['links'])):.#
+000164e0: 2020 2020 2020 2020 206c 696e 6b20 3d20           link = 
+000164f0: 726f 626f 745b 276c 696e 6b73 275d 5b69  robot['links'][i
+00016500: 5d0a 2320 2020 2020 2020 2020 4854 434f  ].#         HTCO
+00016510: 4d20 2b3d 205b 4854 5b69 5d20 4020 6572  M += [HT[i] @ er
+00016520: 622e 4854 7472 616e 736c 6174 6528 6c69  b.HTtranslate(li
+00016530: 6e6b 5b27 434f 4d27 5d29 5d0a 2020 2020  nk['COM'])].    
+00016540: 0a23 2020 2020 2072 6574 7572 6e20 4854  .#     return HT
+00016550: 434f 4d0a 0a23 2063 6f6d 7075 7465 5374  COM..# computeSt
+00016560: 6174 6963 546f 7271 7565 7377 6172 6e65  aticTorqueswarne
+00016570: 643d 4661 6c73 650a 2320 2363 6f6d 7075  d=False.# #compu
+00016580: 7465 2073 7461 7469 6320 746f 7271 7565  te static torque
+00016590: 7320 666f 7220 726f 626f 7420 6465 6669  s for robot defi
+000165a0: 6e65 6420 6279 2044 482d 7061 7261 6d65  ned by DH-parame
+000165b0: 7465 7273 2061 6e64 2066 6f72 2067 6976  ters and for giv
+000165c0: 656e 2048 540a 2320 232a 2a66 756e 6374  en HT.# #**funct
+000165d0: 696f 6e3a 2044 4550 5245 4341 5445 443a  ion: DEPRECATED:
+000165e0: 2063 6f6d 7075 7465 206c 6973 7420 6a6f   compute list jo
+000165f0: 696e 7420 746f 7271 7565 7320 666f 7220  int torques for 
+00016600: 7365 7269 616c 2072 6f62 6f74 2075 6e64  serial robot und
+00016610: 6572 2067 7261 7669 7479 2028 6772 6176  er gravity (grav
+00016620: 6974 7920 616e 6420 6d61 7373 2061 7320  ity and mass as 
+00016630: 6769 7665 6e20 696e 2072 6f62 6f74 290a  given in robot).
+00016640: 2320 6465 6620 436f 6d70 7574 6553 7461  # def ComputeSta
+00016650: 7469 6354 6f72 7175 6573 2872 6f62 6f74  ticTorques(robot
+00016660: 2c48 5429 3a0a 2320 2020 2020 676c 6f62  ,HT):.#     glob
+00016670: 616c 2063 6f6d 7075 7465 5374 6174 6963  al computeStatic
+00016680: 546f 7271 7565 7377 6172 6e65 640a 2320  Torqueswarned.# 
+00016690: 2020 2020 6966 206e 6f74 2063 6f6d 7075      if not compu
+000166a0: 7465 5374 6174 6963 546f 7271 7565 7377  teStaticTorquesw
+000166b0: 6172 6e65 643a 0a23 2020 2020 2020 2020  arned:.#        
+000166c0: 2063 6f6d 7075 7465 5374 6174 6963 546f   computeStaticTo
+000166d0: 7271 7565 7377 6172 6e65 6420 3d20 5472  rqueswarned = Tr
+000166e0: 7565 0a23 2020 2020 2020 2020 2070 7269  ue.#         pri
+000166f0: 6e74 2827 6675 6e63 7469 6f6e 2043 6f6d  nt('function Com
+00016700: 7075 7465 5374 6174 6963 546f 7271 7565  puteStaticTorque
+00016710: 7328 726f 626f 742c 2048 5429 2069 7320  s(robot, HT) is 
+00016720: 6465 7072 6563 6174 6564 2c20 7573 6520  deprecated, use 
+00016730: 526f 626f 742e 5374 6174 6963 546f 7271  Robot.StaticTorq
+00016740: 7565 7328 2e2e 2e29 206f 6620 636c 6173  ues(...) of clas
+00016750: 7320 526f 626f 7420 696e 7374 6561 6427  s Robot instead'
+00016760: 290a 2320 2020 2020 6a6f 696e 7454 6f72  ).#     jointTor
+00016770: 7175 6573 203d 206e 702e 7a65 726f 7328  ques = np.zeros(
+00016780: 6e70 2e73 697a 6528 726f 626f 745b 276c  np.size(robot['l
+00016790: 696e 6b73 275d 2929 0a23 2020 2020 2023  inks'])).#     #
+000167a0: 6f6c 642c 206c 696d 6974 6564 2074 6f20  old, limited to 
+000167b0: 3620 6a6f 696e 7473 3a20 6a6f 696e 7454  6 joints: jointT
+000167c0: 6f72 7175 6573 203d 206e 702e 7a65 726f  orques = np.zero
+000167d0: 7328 3629 0a0a 2320 2020 2020 2363 6f6d  s(6)..#     #com
+000167e0: 7075 7465 2048 5473 2066 6f72 2043 4f4d  pute HTs for COM
+000167f0: 0a23 2020 2020 2048 5463 6f6d 3d43 6f6d  .#     HTcom=Com
+00016800: 7075 7465 434f 4d48 5428 726f 626f 742c  puteCOMHT(robot,
+00016810: 2048 5429 0a23 2020 2020 2067 7261 7620   HT).#     grav 
+00016820: 3d20 6e70 2e61 7272 6179 2872 6f62 6f74  = np.array(robot
+00016830: 5b27 6772 6176 6974 7927 5d29 0a20 2020  ['gravity']).   
+00016840: 200a 2320 2020 2020 2373 756d 2075 7020   .#     #sum up 
+00016850: 7468 6520 746f 7271 7565 7320 6f66 2061  the torques of a
+00016860: 6c6c 2067 7261 7669 7479 206c 6f61 6473  ll gravity loads
+00016870: 3a0a 2320 2020 2020 666f 7220 6920 696e  :.#     for i in
+00016880: 2072 616e 6765 286c 656e 2848 5463 6f6d   range(len(HTcom
+00016890: 2929 3a0a 2320 2020 2020 2020 2020 7020  )):.#         p 
+000168a0: 3d20 6572 622e 4854 3274 7261 6e73 6c61  = erb.HT2transla
+000168b0: 7469 6f6e 2848 5463 6f6d 5b69 5d29 0a23  tion(HTcom[i]).#
+000168c0: 2020 2020 2020 2020 204a 636f 6d3d 4a61           Jcom=Ja
+000168d0: 636f 6269 616e 2872 6f62 6f74 2c48 545b  cobian(robot,HT[
+000168e0: 303a 692b 315d 2c74 6f6f 6c50 6f73 6974  0:i+1],toolPosit
+000168f0: 696f 6e3d 702c 6d6f 6465 3d27 7472 616e  ion=p,mode='tran
+00016900: 7327 290a 2320 2020 2020 2020 2020 2370  s').#         #p
+00016910: 7269 6e74 2865 7262 2e48 5432 7472 616e  rint(erb.HT2tran
+00016920: 736c 6174 696f 6e28 4854 636f 6d5b 695d  slation(HTcom[i]
+00016930: 2929 0a23 2020 2020 2020 2020 2066 4720  )).#         fG 
+00016940: 3d20 726f 626f 745b 276c 696e 6b73 275d  = robot['links']
+00016950: 5b69 5d5b 276d 6173 7327 5d20 2a20 6772  [i]['mass'] * gr
+00016960: 6176 0a23 2020 2020 2020 2020 2023 7072  av.#         #pr
+00016970: 696e 7428 6647 290a 2320 2020 2020 2020  int(fG).#       
+00016980: 2020 7461 7520 3d20 4a63 6f6d 2e54 2040    tau = Jcom.T @
+00016990: 2066 470a 2320 2020 2020 2020 2020 6a6f   fG.#         jo
+000169a0: 696e 7454 6f72 7175 6573 5b30 3a69 2b31  intTorques[0:i+1
+000169b0: 5d20 2b3d 2074 6175 0a23 2020 2020 2072  ] += tau.#     r
+000169c0: 6574 7572 6e20 6a6f 696e 7454 6f72 7175  eturn jointTorqu
+000169d0: 6573 0a0a 0a23 2063 6f6d 7075 7465 4a61  es...# computeJa
+000169e0: 636f 6269 616e 7761 726e 6564 3d46 616c  cobianwarned=Fal
+000169f0: 7365 0a23 2023 636f 6d70 7574 6520 6a61  se.# #compute ja
+00016a00: 636f 6269 616e 2c20 6e65 6564 7320 7065  cobian, needs pe
+00016a10: 722d 6c69 6e6b 2048 5420 696e 2063 7572  r-link HT in cur
+00016a20: 7265 6e74 2063 6f6e 6669 6775 7261 7469  rent configurati
+00016a30: 6f6e 0a23 2023 7275 6e73 206f 7665 7220  on.# #runs over 
+00016a40: 6e75 6d62 6572 206f 6620 4854 7320 6769  number of HTs gi
+00016a50: 7665 6e20 696e 2048 5420 286d 6179 2062  ven in HT (may b
+00016a60: 6520 6c65 7373 2074 6861 6e20 6e75 6d62  e less than numb
+00016a70: 6572 206f 6620 6c69 6e6b 7329 0a23 2023  er of links).# #
+00016a80: 6d6f 6465 7320 6172 653a 2027 616c 6c27  modes are: 'all'
+00016a90: 2c20 2774 7261 6e73 272e 2e2e 6f6e 6c79  , 'trans'...only
+00016aa0: 2074 7261 6e73 6c61 7469 6f6e 2070 6172   translation par
+00016ab0: 742c 2027 726f 7427 3a20 6f6e 6c79 2072  t, 'rot': only r
+00016ac0: 6f74 6174 696f 6e20 7061 7274 0a23 2023  otation part.# #
+00016ad0: 2a2a 6675 6e63 7469 6f6e 3a20 4445 5052  **function: DEPR
+00016ae0: 4543 4154 4544 3a20 636f 6d70 7574 6520  ECATED: compute 
+00016af0: 6a61 636f 6269 616e 2066 6f72 2074 7261  jacobian for tra
+00016b00: 6e73 6c61 7469 6f6e 2061 6e64 2072 6f74  nslation and rot
+00016b10: 6174 696f 6e20 6174 2074 6f6f 6c50 6f73  ation at toolPos
+00016b20: 6974 696f 6e20 7573 696e 6720 6a6f 696e  ition using join
+00016b30: 7420 4854 0a23 2064 6566 204a 6163 6f62  t HT.# def Jacob
+00016b40: 6961 6e28 726f 626f 742c 4854 2c74 6f6f  ian(robot,HT,too
+00016b50: 6c50 6f73 6974 696f 6e3d 5b5d 2c6d 6f64  lPosition=[],mod
+00016b60: 653d 2761 6c6c 2729 3a0a 2320 2020 2020  e='all'):.#     
+00016b70: 676c 6f62 616c 2063 6f6d 7075 7465 4a61  global computeJa
+00016b80: 636f 6269 616e 7761 726e 6564 0a23 2020  cobianwarned.#  
+00016b90: 2020 2069 6620 6e6f 7420 636f 6d70 7574     if not comput
+00016ba0: 654a 6163 6f62 6961 6e77 6172 6e65 643a  eJacobianwarned:
+00016bb0: 0a23 2020 2020 2020 2020 2063 6f6d 7075  .#         compu
+00016bc0: 7465 4a61 636f 6269 616e 7761 726e 6564  teJacobianwarned
+00016bd0: 203d 2054 7275 650a 2320 2020 2020 2020   = True.#       
+00016be0: 2020 7072 696e 7428 2766 756e 6374 696f    print('functio
+00016bf0: 6e20 4a61 636f 6269 616e 2872 6f62 6f74  n Jacobian(robot
+00016c00: 2c20 4854 2c2e 2e2e 2920 6973 2064 6570  , HT,...) is dep
+00016c10: 7265 6361 7465 642c 2075 7365 2052 6f62  recated, use Rob
+00016c20: 6f74 2e4a 6163 6f62 6961 6e28 2e2e 2e29  ot.Jacobian(...)
+00016c30: 206f 6620 636c 6173 7320 526f 626f 7420   of class Robot 
+00016c40: 696e 7374 6561 6427 290a 2320 2020 2020  instead').#     
+00016c50: 6e20 3d20 6c65 6e28 4854 290a 2320 2020  n = len(HT).#   
+00016c60: 2020 6966 206e 203e 206c 656e 2872 6f62    if n > len(rob
+00016c70: 6f74 5b27 6c69 6e6b 7327 5d29 3a0a 2320  ot['links']):.# 
+00016c80: 2020 2020 2020 2020 7072 696e 7428 2245          print("E
+00016c90: 5252 4f52 3a20 6e75 6d62 6572 206f 6620  RROR: number of 
+00016ca0: 686f 6d6f 6765 6e65 6f75 7320 7472 616e  homogeneous tran
+00016cb0: 7366 6f72 6d61 7469 6f6e 7320 2848 5429  sformations (HT)
+00016cc0: 2067 7265 6174 6572 2074 6861 6e20 6e75   greater than nu
+00016cd0: 6d62 6572 206f 6620 6c69 6e6b 7322 290a  mber of links").
+00016ce0: 0a23 2020 2020 204a 6f6d 6567 6120 3d20  .#     Jomega = 
+00016cf0: 6e70 2e7a 6572 6f73 2828 332c 6e29 2923  np.zeros((3,n))#
+00016d00: 726f 7461 7469 6f6e 2070 6172 7420 6f66  rotation part of
+00016d10: 206a 6163 6f62 6961 6e0a 2320 2020 2020   jacobian.#     
+00016d20: 4a76 656c 203d 206e 702e 7a65 726f 7328  Jvel = np.zeros(
+00016d30: 2833 2c6e 2929 2020 2374 7261 6e73 6c61  (3,n))  #transla
+00016d40: 7469 6f6e 2070 6172 7420 6f66 206a 6163  tion part of jac
+00016d50: 6f62 6961 6e0a 2320 2020 2020 4120 3d20  obian.#     A = 
+00016d60: 6572 622e 4854 3272 6f74 6174 696f 6e4d  erb.HT2rotationM
+00016d70: 6174 7269 7828 726f 626f 745b 2762 6173  atrix(robot['bas
+00016d80: 6527 5d5b 2748 5427 5d29 0a23 2020 2020  e']['HT']).#    
+00016d90: 2072 6f74 4178 6973 203d 206e 702e 6172   rotAxis = np.ar
+00016da0: 7261 7928 5b30 2c30 2c31 5d29 2023 726f  ray([0,0,1]) #ro
+00016db0: 626f 7420 6178 6973 2069 6e20 6c6f 6361  bot axis in loca
+00016dc0: 6c20 636f 6f72 6469 6e61 7465 730a 2320  l coordinates.# 
+00016dd0: 2020 2020 7650 7265 7669 6f75 7320 3d20      vPrevious = 
+00016de0: 6572 622e 4854 3274 7261 6e73 6c61 7469  erb.HT2translati
+00016df0: 6f6e 2872 6f62 6f74 5b27 6261 7365 275d  on(robot['base']
+00016e00: 5b27 4854 275d 290a 2320 2020 2020 766e  ['HT']).#     vn
+00016e10: 203d 2074 6f6f 6c50 6f73 6974 696f 6e0a   = toolPosition.
+00016e20: 2320 2020 2020 6966 206c 656e 2876 6e29  #     if len(vn)
+00016e30: 203d 3d20 303a 0a23 2020 2020 2020 2020   == 0:.#        
+00016e40: 2076 6e20 3d20 6572 622e 4854 3274 7261   vn = erb.HT2tra
+00016e50: 6e73 6c61 7469 6f6e 2848 545b 2d31 5d29  nslation(HT[-1])
+00016e60: 2023 746f 6f6c 2070 6f73 6974 696f 6e2c   #tool position,
+00016e70: 2066 6f72 206a 6163 6f62 6961 6e20 2863   for jacobian (c
+00016e80: 6f75 6c64 2069 6e63 6c75 6465 2074 6f6f  ould include too
+00016e90: 6c20 6974 7365 6c66 290a 2020 2020 0a23  l itself).    .#
+00016ea0: 2020 2020 2023 6372 6561 7465 2072 6f62       #create rob
+00016eb0: 6f74 206e 6f64 6573 2061 6e64 2062 6f64  ot nodes and bod
+00016ec0: 6965 733a 0a23 2020 2020 2066 6f72 2069  ies:.#     for i
+00016ed0: 2069 6e20 7261 6e67 6528 6e29 3a0a 2020   in range(n):.  
+00016ee0: 2020 2020 2020 0a23 2020 2020 2020 2020        .#        
+00016ef0: 2069 6620 6920 3e20 303a 0a23 2020 2020   if i > 0:.#    
+00016f00: 2020 2020 2020 2020 2041 203d 2065 7262           A = erb
+00016f10: 2e48 5432 726f 7461 7469 6f6e 4d61 7472  .HT2rotationMatr
+00016f20: 6978 2848 545b 692d 315d 2920 2372 6f74  ix(HT[i-1]) #rot
+00016f30: 6174 696f 6e20 6f66 206a 6f69 6e74 2069  ation of joint i
+00016f40: 0a23 2020 2020 2020 2020 2061 7869 7320  .#         axis 
+00016f50: 3d20 4120 4020 726f 7441 7869 7320 2361  = A @ rotAxis #a
+00016f60: 7869 7320 696e 2067 6c6f 6261 6c20 636f  xis in global co
+00016f70: 6f72 6469 6e61 7465 730a 2320 2020 2020  ordinates.#     
+00016f80: 2020 2020 4a6f 6d65 6761 5b30 3a33 2c69      Jomega[0:3,i
+00016f90: 5d20 3d20 726f 626f 745b 276a 6f69 6e74  ] = robot['joint
+00016fa0: 5479 7065 275d 5b69 5d20 2a20 6178 6973  Type'][i] * axis
+00016fb0: 2023 6f6e 6c79 2063 6f6e 7369 6465 7265   #only considere
+00016fc0: 642c 2069 6620 7265 766f 6c75 7465 206a  d, if revolute j
+00016fd0: 6f69 6e74 0a20 2020 2020 2020 200a 2320  oint.        .# 
+00016fe0: 2020 2020 2020 2020 6966 2069 203e 2030          if i > 0
+00016ff0: 3a0a 2320 2020 2020 2020 2020 2020 2020  :.#             
+00017000: 7650 7265 7669 6f75 7320 3d20 6572 622e  vPrevious = erb.
+00017010: 4854 3274 7261 6e73 6c61 7469 6f6e 2848  HT2translation(H
+00017020: 545b 692d 315d 290a 2020 2020 2020 2020  T[i-1]).        
+00017030: 200a 2320 2020 2020 2020 2020 2372 6576   .#         #rev
+00017040: 6f6c 7574 6520 6a6f 696e 743a 0a23 2020  olute joint:.#  
+00017050: 2020 2020 2020 2069 6620 726f 626f 745b         if robot[
+00017060: 276a 6f69 6e74 5479 7065 275d 5b69 5d20  'jointType'][i] 
+00017070: 3d3d 2031 3a20 2372 6576 6f6c 7574 6520  == 1: #revolute 
+00017080: 6a6f 696e 740a 2320 2020 2020 2020 2020  joint.#         
+00017090: 2020 2020 4a76 656c 5b30 3a33 2c69 5d20      Jvel[0:3,i] 
+000170a0: 2020 3d20 6572 622e 536b 6577 2861 7869    = erb.Skew(axi
+000170b0: 7329 2040 2028 766e 202d 2076 5072 6576  s) @ (vn - vPrev
+000170c0: 696f 7573 2920 236f 6e6c 7920 636f 6e73  ious) #only cons
+000170d0: 6964 6572 6564 2c20 6966 2072 6576 6f6c  idered, if revol
+000170e0: 7574 6520 6a6f 696e 740a 2320 2020 2020  ute joint.#     
+000170f0: 2020 2020 656c 7365 3a20 2370 7269 736d      else: #prism
+00017100: 6174 6963 206a 6f69 6e74 0a23 2020 2020  atic joint.#    
+00017110: 2020 2020 2020 2020 204a 7665 6c5b 303a           Jvel[0:
+00017120: 332c 695d 2020 203d 2061 7869 7320 234e  3,i]   = axis #N
+00017130: 4f54 2054 4553 5445 4421 2121 0a20 2020  OT TESTED!!!.   
+00017140: 200a 2320 2020 2020 6966 206d 6f64 6520   .#     if mode 
+00017150: 3d3d 2027 616c 6c27 3a0a 2320 2020 2020  == 'all':.#     
+00017160: 2020 2020 4a20 3d20 6e70 2e7a 6572 6f73      J = np.zeros
+00017170: 2828 362c 6e29 290a 2320 2020 2020 656c  ((6,n)).#     el
+00017180: 7365 3a0a 2320 2020 2020 2020 2020 4a20  se:.#         J 
+00017190: 3d20 6e70 2e7a 6572 6f73 2828 332c 6e29  = np.zeros((3,n)
+000171a0: 290a 2020 2020 0a23 2020 2020 2069 6620  ).    .#     if 
+000171b0: 6d6f 6465 203d 3d20 2772 6f74 273a 0a23  mode == 'rot':.#
+000171c0: 2020 2020 2020 2020 204a 5b30 3a33 2c30           J[0:3,0
+000171d0: 3a6e 5d20 3d20 4a6f 6d65 6761 0a23 2020  :n] = Jomega.#  
+000171e0: 2020 2065 6c69 6620 6d6f 6465 203d 3d20     elif mode == 
+000171f0: 2774 7261 6e73 273a 0a23 2020 2020 2020  'trans':.#      
+00017200: 2020 204a 5b30 3a33 2c30 3a6e 5d20 3d20     J[0:3,0:n] = 
+00017210: 4a76 656c 0a23 2020 2020 2065 6c69 6620  Jvel.#     elif 
+00017220: 6d6f 6465 203d 3d20 2761 6c6c 273a 0a23  mode == 'all':.#
+00017230: 2020 2020 2020 2020 204a 5b30 3a33 2c30           J[0:3,0
+00017240: 3a6e 5d20 3d20 4a76 656c 0a23 2020 2020  :n] = Jvel.#    
+00017250: 2020 2020 204a 5b33 3a36 2c30 3a6e 5d20       J[3:6,0:n] 
+00017260: 3d20 4a6f 6d65 6761 0a0a 2320 2020 2020  = Jomega..#     
+00017270: 7265 7475 726e 204a 0a0a 0a0a 2320 2374  return J....# #t
+00017280: 6865 2066 6f6c 6c6f 7769 6e67 2066 756e  he following fun
+00017290: 6374 696f 6e73 2075 7365 2061 2073 7472  ctions use a str
+000172a0: 7563 7475 7265 2066 6f72 2074 6865 2064  ucture for the d
+000172b0: 6573 6372 6970 7469 6f6e 206f 6620 7468  escription of th
+000172c0: 6520 726f 626f 7420 6163 636f 7264 696e  e robot accordin
+000172d0: 6720 746f 3a0a 2320 2320 6c69 6e6b 303d  g to:.# # link0=
+000172e0: 7b27 7374 6444 4827 3a5b 302c 302c 302c  {'stdDH':[0,0,0,
+000172f0: 6e70 2e70 692f 325d 2c20 2374 6865 7461  np.pi/2], #theta
+00017300: 2c20 642c 2061 2c20 616c 7068 610a 2320  , d, a, alpha.# 
+00017310: 2020 2020 2020 2023 2027 6d61 7373 273a         # 'mass':
+00017320: 3230 2c20 2023 6e6f 7420 6e65 6564 6564  20,  #not needed
+00017330: 210a 2320 2020 2020 2020 2023 2027 696e  !.#        # 'in
+00017340: 6572 7469 6127 3a6e 702e 6469 6167 285b  ertia':np.diag([
+00017350: 3165 2d38 2c30 2e33 352c 3165 2d38 5d29  1e-8,0.35,1e-8])
+00017360: 2c20 2377 2e72 2e74 2e20 434f 4d21 0a23  , #w.r.t. COM!.#
+00017370: 2020 2020 2020 2020 2320 2743 4f4d 273a          # 'COM':
+00017380: 5b30 2c30 2c30 5d7d 0a0a 2320 2320 6c69  [0,0,0]}..# # li
+00017390: 6e6b 313d 7b27 7374 6444 4827 3a5b 302c  nk1={'stdDH':[0,
+000173a0: 302c 302e 3433 3138 2c30 5d2c 0a23 2020  0,0.4318,0],.#  
+000173b0: 2020 2020 2020 2320 276d 6173 7327 3a31        # 'mass':1
+000173c0: 372e 342c 200a 2320 2020 2020 2020 2023  7.4, .#        #
+000173d0: 2027 696e 6572 7469 6127 3a6e 702e 6469   'inertia':np.di
+000173e0: 6167 285b 302e 3133 2c30 2e35 3234 2c30  ag([0.13,0.524,0
+000173f0: 2e35 3339 5d29 2c20 2377 2e72 2e74 2e20  .539]), #w.r.t. 
+00017400: 434f 4d21 0a23 2020 2020 2020 2020 2320  COM!.#        # 
+00017410: 2743 4f4d 273a 5b2d 302e 3336 3338 2c20  'COM':[-0.3638, 
+00017420: 302e 3030 362c 2030 2e32 3237 355d 7d0a  0.006, 0.2275]}.
+00017430: 0a23 2023 206c 696e 6b32 3d7b 2773 7464  .# # link2={'std
+00017440: 4448 273a 5b30 2c30 2e31 352c 302e 3032  DH':[0,0.15,0.02
+00017450: 3033 2c2d 6e70 2e70 692f 325d 2c20 0a23  03,-np.pi/2], .#
+00017460: 2020 2020 2020 2020 2320 276d 6173 7327          # 'mass'
+00017470: 3a34 2e38 2c20 0a23 2020 2020 2020 2020  :4.8, .#        
+00017480: 2320 2769 6e65 7274 6961 273a 6e70 2e64  # 'inertia':np.d
+00017490: 6961 6728 5b30 2e30 3636 2c30 2e30 3836  iag([0.066,0.086
+000174a0: 2c30 2e30 3132 355d 292c 2023 772e 722e  ,0.0125]), #w.r.
+000174b0: 742e 2043 4f4d 210a 2320 2020 2020 2020  t. COM!.#       
+000174c0: 2023 2027 434f 4d27 3a5b 2d30 2e30 3230   # 'COM':[-0.020
+000174d0: 332c 2d30 2e30 3134 312c 302e 3037 5d7d  3,-0.0141,0.07]}
+000174e0: 0a0a 2320 2320 6c69 6e6b 333d 7b27 7374  ..# # link3={'st
+000174f0: 6444 4827 3a5b 302c 302e 3433 3138 2c30  dDH':[0,0.4318,0
+00017500: 2c6e 702e 7069 2f32 5d2c 200a 2320 2020  ,np.pi/2], .#   
+00017510: 2020 2020 2023 2027 6d61 7373 273a 302e       # 'mass':0.
+00017520: 3832 2c20 0a23 2020 2020 2020 2020 2320  82, .#        # 
+00017530: 2769 6e65 7274 6961 273a 6e70 2e64 6961  'inertia':np.dia
+00017540: 6728 5b30 2e30 3031 382c 302e 3030 3133  g([0.0018,0.0013
+00017550: 2c30 2e30 3031 385d 292c 2023 772e 722e  ,0.0018]), #w.r.
+00017560: 742e 2043 4f4d 210a 2320 2020 2020 2020  t. COM!.#       
+00017570: 2023 2027 434f 4d27 3a5b 302c 302e 3031   # 'COM':[0,0.01
+00017580: 392c 305d 7d0a 0a23 2023 206c 696e 6b34  9,0]}..# # link4
+00017590: 3d7b 2773 7464 4448 273a 5b30 2c30 2c30  ={'stdDH':[0,0,0
+000175a0: 2c2d 6e70 2e70 692f 325d 2c20 0a23 2020  ,-np.pi/2], .#  
+000175b0: 2020 2020 2020 2320 276d 6173 7327 3a30        # 'mass':0
+000175c0: 2e33 342c 200a 2320 2020 2020 2020 2023  .34, .#        #
+000175d0: 2027 696e 6572 7469 6127 3a6e 702e 6469   'inertia':np.di
+000175e0: 6167 285b 302e 3030 3033 2c30 2e30 3030  ag([0.0003,0.000
+000175f0: 342c 302e 3030 3033 5d29 2c20 2377 2e72  4,0.0003]), #w.r
+00017600: 2e74 2e20 434f 4d21 0a23 2020 2020 2020  .t. COM!.#      
+00017610: 2020 2320 2743 4f4d 273a 5b30 2c30 2c30    # 'COM':[0,0,0
+00017620: 5d7d 0a0a 2320 2320 6c69 6e6b 353d 7b27  ]}..# # link5={'
+00017630: 7374 6444 4827 3a5b 302c 302c 302c 305d  stdDH':[0,0,0,0]
+00017640: 2c20 0a23 2020 2020 2020 2020 2320 276d  , .#        # 'm
+00017650: 6173 7327 3a30 2e30 392c 200a 2320 2020  ass':0.09, .#   
+00017660: 2020 2020 2023 2027 696e 6572 7469 6127       # 'inertia'
+00017670: 3a6e 702e 6469 6167 285b 302e 3030 3031  :np.diag([0.0001
+00017680: 352c 302e 3030 3031 352c 3465 2d35 5d29  5,0.00015,4e-5])
+00017690: 2c20 2377 2e72 2e74 2e20 434f 4d21 0a23  , #w.r.t. COM!.#
+000176a0: 2020 2020 2020 2020 2320 2743 4f4d 273a          # 'COM':
+000176b0: 5b30 2c30 2c30 2e30 3332 5d7d 0a0a 2320  [0,0,0.032]}..# 
+000176c0: 2320 2374 6869 7320 6973 2074 6865 2067  # #this is the g
+000176d0: 6c6f 6261 6c20 726f 626f 7420 7374 7275  lobal robot stru
+000176e0: 6374 7572 650a 2320 2320 726f 626f 743d  cture.# # robot=
+000176f0: 7b27 6c69 6e6b 7327 3a5b 6c69 6e6b 302c  {'links':[link0,
+00017700: 206c 696e 6b31 2c20 6c69 6e6b 322c 206c   link1, link2, l
+00017710: 696e 6b33 2c20 6c69 6e6b 342c 206c 696e  ink3, link4, lin
+00017720: 6b35 5d2c 0a23 2020 2020 2020 2020 2320  k5],.#        # 
+00017730: 276a 6f69 6e74 5479 7065 273a 5b31 2c31  'jointType':[1,1
+00017740: 2c31 2c31 2c31 2c31 5d2c 2023 313d 7265  ,1,1,1,1], #1=re
+00017750: 766f 6c75 7465 2c20 303d 7072 6973 6d61  volute, 0=prisma
+00017760: 7469 630a 2320 2020 2020 2020 2023 2027  tic.#        # '
+00017770: 6261 7365 273a 7b27 4854 273a 6572 622e  base':{'HT':erb.
+00017780: 4854 3028 297d 2c0a 2320 2020 2020 2020  HT0()},.#       
+00017790: 2023 2027 746f 6f6c 273a 7b27 4854 273a   # 'tool':{'HT':
+000177a0: 6572 622e 4854 7472 616e 736c 6174 6528  erb.HTtranslate(
+000177b0: 5b30 2c30 2c30 2e31 5d29 7d2c 0a23 2020  [0,0,0.1])},.#  
+000177c0: 2020 2020 2020 2320 2767 7261 7669 7479        # 'gravity
+000177d0: 273a 5b30 2c30 2c39 2e38 315d 2c0a 2320  ':[0,0,9.81],.# 
+000177e0: 2020 2020 2020 2023 2027 7265 6665 7265         # 'refere
+000177f0: 6e63 6543 6f6e 6669 6775 7261 7469 6f6e  nceConfiguration
+00017800: 273a 5b30 5d2a 3620 2372 6566 6572 656e  ':[0]*6 #referen
+00017810: 6365 2063 6f6e 6669 6775 7261 7469 6f6e  ce configuration
+00017820: 2066 6f72 2062 6f64 6965 733b 2061 7420   for bodies; at 
+00017830: 7768 6963 6820 7468 6520 726f 626f 7420  which the robot 
+00017840: 6973 2062 7569 6c74 0a23 2020 2020 2020  is built.#      
+00017850: 2020 2320 7d20 0a0a                        # } ..
```

## exudyn/robotics/rosInterface.py

 * *Ordering differences only*

```diff
@@ -1,302 +1,302 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library for robotics
-#
-# Details:  This interface collects interfaces and functionality for ROS comunication
-#           This library is under construction (2023-05);
-#           To make use of this libraries, you need to 
-#           install ROS (ROS1 noetic) including rospy
-#           Please consider following workflow:
-#           make sure to have a working ROS1-NOETIC installation, ROS2 is not supported yet
-#           tested only with ROS1-NOETIC, ubuntu 20.04, and Python 3.8.10
-#           you find all ROS1 installation steps on: 
-#           http://wiki.ros.org/noetic/Installation/Ubuntu
-#           Step 1.4 we recommend to install: (sudo apt install ros-noetic-desktop)
-#           Check the installation of the turtlesim package (rosrun turtlesim turtlesim\_node )
-#           if not installed: sudo apt install ros-noetic-turtlesim
-#           use a catkin workspace and build a ROS1 Package  
-#           Follow instructions on:
-#           http://wiki.ros.org/ROS/Tutorials (recommend go trough step 1 to 6)
-#           Minimal example to use:
-#           create catkin workspace: 
-#               mkdir -p ~/catkin\_ws/src
-#               cd ~/catkin\_ws
-#               catkin\_make
-#               source devel/setup.bash
-#           build ROS package:
-#               cd ~/catkin\_ws/src
-#               catkin\_create\_pkg my\_pkg\_name rospy roscpp std\_msgs geometry\_msgs sensor\_msgs 
-#           build catkin workspace and sourcing setup file
-#               cd ~/catkin\_ws
-#               cakin\_make
-#               source ~/catkin\_ws/devel/setup.bash
-#           for more functionality see also: ROSExampleMassPoint.py, ROSExampleBringup.launch, ROSExampleControlVelocity.py
-# Author:   Martin Sereinig, Peter Manzl 
-# Date:     2023-05-31 (created)
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. 
-# You can redistribute it and/or modify it under the terms of the Exudyn license. 
-# See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-import exudyn as exu
-from exudyn.utilities import *
-import time
-import os
-
-# import needed ROS modules and messages
-import rospy
-from geometry_msgs.msg import PoseStamped, WrenchStamped, Twist
-from std_msgs.msg import Float64MultiArray, Empty, String, Time
-
-#**class: interface super class to establish a ROS Exudyn interface 
-#           see specific class functions which can be used and extended 
-#           by inheritance with class MyClass(ROSInterface)
-#**author: Martin Sereinig, Peter Manzl 
-#**notes: some inspiration can be taken from 
-class ROSInterface: 
-    def __init__(self, name = 'ExudynRobotInterface'): 
-
-        # check ROS version 
-        self.CheckROSversion()
-
-        # init ros node
-        rospy.init_node(name, anonymous=True)        
-
-        # topics namespace, will be used in all topics
-        self.topicBase = '/exudyn/'
-
-        # set ROS node start time Time 
-        self.t0 = rospy.get_time()
-        print('ROS node initialization at time {} done!'.format(self.t0))
-        # initialize simulation runtime
-        self.tsim = self.t0 -  rospy.get_time()
-
-        # initialization of some timing variables
-        self.rosPoseSendInterval = 0.01  #ms
-        self.rosTwistSendInterval = 0.01 #ms
-        self.lastPoseSendTime = -self.rosPoseSendInterval
-        self.lastTwistSendTime = -self.rosTwistSendInterval
-        self.systemStateUpdateInterval = 0.01  #ms
-        self.lastSystemStateUpdateTime = -self.systemStateUpdateInterval
-        self.lastStepTime = 0    # last step time (exudyn time)
-        
-        # initialize standard publisher
-        # publisher for time message 
-        self.exuTimePublisher =  self.InitPublisher(pubTopicName='SimiulationTime', 
-                                        pubType = Time, queueSize = 10)
-        # publisher for simple string message 
-        self.exuStringPublisher =  self.InitPublisher(pubTopicName='SimpleString', 
-                                        pubType = String, queueSize = 10)
-        # publisher for velocities (Twist)
-        self.exuTwistPublisher =  self.InitPublisher(pubTopicName='Twist', 
-                                        pubType = Twist, queueSize = 10)
-        # publisher for Pose
-        self.exuPosePublisher =  self.InitPublisher(pubTopicName='Pose', 
-                                        pubType = PoseStamped, queueSize = 10)
-        # publisher for Wrench
-        self.exuWrenchPublisher =  self.InitPublisher(pubTopicName='Wrensh', 
-                                        pubType = WrenchStamped, queueSize = 10)
-        # publisher for system data
-        self.exuSystemstatePublisher =  self.InitPublisher(pubTopicName='Systemstate', 
-                                        pubType = Float64MultiArray, queueSize = 1)
-        # add further publisher if needed in inherited class
-        # initialization of subscriber and needed callback function will be done in inherited class   
-        # self.callbackData =
-        return
-    #**classFunction: function to create a publisher
-    #**input:
-    #       pubTopicName: topic name to publish, actual topic will be /exudyn/pubTopicName
-    #       pubType: data type used in topic
-    #       queSize: length of queue to hold messages, should be as small as sending frequency (= simulation sample time)
-    #**author: Martin Sereinig
-    #**notes: find msgs types here
-    #  http://docs.ros.org/en/melodic/api/std\_msgs/html/index-msg.html
-    #**examples: 
-    #       publisher for poses, pubType = PoseStamped, 
-    #       publisher for system data, pubType = Float64MultiArray,
-    #       publisher for filtered force, pubType = WrenchStamped,
-    #       publisher for velocities, pubType = Twist,
-    def InitPublisher(self, pubTopicName='', pubType = Empty, queueSize = 10): 
-        exuPublisher = rospy.Publisher(self.topicBase  + pubTopicName, 
-                            pubType, queue_size=queueSize)
-        return exuPublisher 
-    
-    #**classFunction: function to create a generic callback function for a subscriber
-    #**input:
-    #       topic: topic name generated by init Subscriber
-    #       data: data structure for regarding individual topic 
-    #**author: Peter Manzl 
-    def ExuCallbackGeneric(self,subTopicName, data): 
-        setattr(self, subTopicName, data)
-        return True
-    
-    #**classFunction: function to create a subscriber
-    #**input:
-    #       subTopicNameSpace: topic namespace: 'exudyn/'
-    #       subTopicName: topic name to subscribe
-    #       subType: data type for topic to subscribe
-    #**author: Peter Manzl 
-    #**note: callback function will be automatic generated for each subscriber, depending
-    #        on subTopicName. Data will be found under self.subTopicName
-    def InitSubscriber(self,subTopicNameSpace, subTopicName, subType): 
-        exuSubscriber = rospy.Subscriber(subTopicNameSpace+subTopicName, subType, 
-                                    lambda data: self.ExuCallbackGeneric(subTopicName, data))
-        return exuSubscriber
-
-    #**classFunction: check the current used ROS version
-    #**author: Martin Sereinig
-    #**note: just supports ROS1, ROS2 support will be given in future releases 
-    def CheckROSversion(self):
-        # check and set ROSVersion 
-        #os.system('rosversion -d')
-        #self.myROSversionString = os.popen('rosversion -d').read()
-        self.myROSversionEnvInt = int(os.getenv('ROS_VERSION','0'))
-        self.myROSdistriEnv = os.getenv('ROS_DISTRO','unknown')
-        rospy.loginfo('-ROS'+str(self.myROSversionEnvInt)+' '+self.myROSdistriEnv+'-')  
-        if self.myROSversionEnvInt != 0:
-            return True
-        else:
-            return False        
-
-    #**classFunction: Example method to be called once per frame/control cycle in Exudyn PreStepUserFunction
-    #**note:        reads sensor values, creates message, publish and subscribe to ROS 
-    #**input:
-    #  mbs:     mbs (exudyn.exudynCPP.MainSystem), multi-body simulation system from exudyn
-    #  tExu:    tExu (float), elapsed time since simulation start
-    #  getData: getData (string), get pose information from 'node' or from 'sensor'
-    #**author: Martin Sereinig
-    #**notes: 
-    #           reads sensor values, creates message, publish and subscribe to ROS
-    #           publishing each and every step is too much, this would slow down the connection
-    #           thus: publish every few seconds, only
-    #           furthermore, as vrInterface is only updating the graphics with f=60Hz, we don't have to update
-    #           system state every 1ms, so with f=1000Hz. Instead f=60Hz equivalents to update every 1/60=17ms
-    #           timing variable to know when to send new command to robot or when to publish new mbs system state update
-    def PublishPoseUpdate(self, mbs, tExu, getData = 'node'):
-        if tExu - self.lastPoseSendTime >= self.rosPoseSendInterval:
-            self.lastPoseSendTime = tExu
-            if getData == 'sensor':
-                # read current kinematic state and orientation from predefined variables send via mbs.variables
-                posFromExu = mbs.GetSensorValues(mbs.variables['pos'])
-                oriFromExu = mbs.GetSensorValues(mbs.variables['ori'])
-                # convert data to numpy arrays
-                pos = np.array(posFromExu)
-                rot = np.array(oriFromExu)
-                rotE = np.roll(RotXYZ2EulerParameters(rot),-1)  # use roll to meet ROS eulerparameter convention [x,y,z,w]
-
-            elif getData == 'node':
-                nodeDic = mbs.GetNode(mbs.variables['nodeNumber'])
-                if nodeDic['nodeType'] == 'RigidBodyEP':
-                    # get position [x,y,z] and orientation (eulerparameter) [w,x,y,z] from exudyn via node coordinates 
-                    # nodeCoordinates = [x,y,z, w,x,y,z]
-                    nodeCoordinates = list(np.array(nodeDic['referenceCoordinates']) + 
-                                        np.array(mbs.GetNodeOutput(mbs.variables['nodeNumber'],variableType = exu.OutputVariableType.Coordinates)))
-                    # reformulation for ROS 
-                    pos = nodeCoordinates[0:3] # pos = [x,y,z]
-                    rotE = np.roll(nodeCoordinates[3:7],-1) # rotE = [x,y,z,w]
-
-                    if False: # for debug
-                        print('position: ',nodeCoordinates[0:3])
-                        print('orientation: ',nodeCoordinates[3:7]) # eulerparameter exu [w,x,y,z]
-                else: 
-                    print('node type not supported')
-            else:
-                print('Error! Please choose how to get pose information!')
-            
-            
-            poseExu = np.append(pos,rotE)
-            # compose message and publish
-            msgData = PoseStamped()
-            # postion
-            msgData.pose.position.x = poseExu[0]
-            msgData.pose.position.y = poseExu[1]
-            msgData.pose.position.z = poseExu[2]
-            # orientation given in unit quarternions
-            msgData.pose.orientation.x = poseExu[3]
-            msgData.pose.orientation.y = poseExu[4]
-            msgData.pose.orientation.z = poseExu[5]
-            msgData.pose.orientation.w = poseExu[6]
-            # write current time into message
-            msgData.header.stamp = rospy.Time.now()
-            self.exuPosePublisher.publish(msgData)
-
-
-
-    #**classFunction: Example method to be called once per frame/control cycle in Exudyn PreStepUserFunction
-    #**note:        reads sensor values, creates message, publish and subscribe to ROS 
-    #**input:
-    #  mbs:     mbs (exudyn.exudynCPP.MainSystem), multi-body simulation system from exudyn
-    #  tExu:    tExu (float), elapsed time since simulation start
-    #  getData: getData (string), get pose information from 'node' or from 'sensor'
-    #**author: Martin Sereinig
-    #**notes: 
-    #           reads sensor values, creates message, publish and subscribe to ROS
-    def PublishTwistUpdate(self, mbs, tExu, getData='node'):
-        if tExu - self.lastTwistSendTime >= self.rosTwistSendInterval:
-            self.lastTwistSendTime = tExu
-
-            if getData == 'sensor':
-                # read current kinematic state and orientation from predefined variables
-                velocityLinearFromExu = mbs.GetSensorValues(mbs.variables['velt'])
-                velocityAngularFromExu = mbs.GetSensorValues(mbs.variables['velr'])
-                # convert data to numpy arrays
-                velLin = np.array(velocityLinearFromExu)
-                velAng = np.array(velocityAngularFromExu)
-
-            elif getData == 'node':
-                nodeDic = mbs.GetNode(mbs.variables['nodeNumber'])
-                if nodeDic['nodeType'] == 'RigidBodyEP':
-                    # get linear and angular velocity form exudyn via node 
-                    velLin= mbs.GetNodeOutput(mbs.variables['nodeNumber'],variableType = exu.OutputVariableType.Velocity)
-                    velAng = mbs.GetNodeOutput(mbs.variables['nodeNumber'],variableType = exu.OutputVariableType.AngularVelocity)
-                    # same could be done to get acceleration from exudyn node 
-                    # nUIPLinearAcc= mbs.GetNodeOutput(nUIP,variableType = exu.OutputVariableType.Acceleration)
-                    # nUIPAngularAcc= mbs.GetNodeOutput(nUIP,variableType = exu.OutputVariableType.AngularAcceleration)
-            
-            twistExu = np.append(velLin,velAng)
-            # compose message and publish
-            msgData = Twist()
-            # linear velocities
-            msgData.linear.x = twistExu[0]
-            msgData.linear.y = twistExu[1]
-            msgData.linear.z = twistExu[2]
-            # angular velocities
-            msgData.angular.x = twistExu[3]
-            msgData.angular.y = twistExu[4]
-            msgData.angular.z = twistExu[5]
-            # write current time into message
-            self.exuTwistPublisher.publish(msgData)
-
-    #**classFunction: method to be send system state data once per frame/control cycle in Exudyn PreStepUserFunction
-    #**input:
-    #  mbs:     mbs (exudyn.exudynCPP.MainSystem), multi-body simulation system from exudyn
-    #  tExu:       tExu (float),  simulation time
-    # systemStateData:   systemStateData (list), full Exudyn SystemState
-    #**author: Martin Sereinig
-    #**note:        collects important exudyn system data and send it to ros-topic
-    def PublishSystemStateUpdate(self, mbs, tExu):
-        if tExu - self.lastSystemStateUpdateTime >= self.systemStateUpdateInterval:
-            self.lastSystemStateUpdateTime = tExu
-            
-            systemStateList1d = []
-            # publish system state to ros-topic 
-            systemStateData = mbs.systemData.GetSystemState()
-
-            # first entry is current time
-            systemStateList1d.append(tExu)
-
-            # then systemData itself follows
-            for array in systemStateData:
-                # add length of next array
-                systemStateList1d.append(float(len(array)))
-                # add array itself
-                for i in range(len(array)):
-                    systemStateList1d.append(array[i])
-
-            msg = Float64MultiArray()
-            msg.data = systemStateList1d # dataList
-            self.exuSystemstatePublisher.publish(msg)
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library for robotics
+#
+# Details:  This interface collects interfaces and functionality for ROS comunication
+#           This library is under construction (2023-05);
+#           To make use of this libraries, you need to 
+#           install ROS (ROS1 noetic) including rospy
+#           Please consider following workflow:
+#           make sure to have a working ROS1-NOETIC installation, ROS2 is not supported yet
+#           tested only with ROS1-NOETIC, ubuntu 20.04, and Python 3.8.10
+#           you find all ROS1 installation steps on: 
+#           http://wiki.ros.org/noetic/Installation/Ubuntu
+#           Step 1.4 we recommend to install: (sudo apt install ros-noetic-desktop)
+#           Check the installation of the turtlesim package (rosrun turtlesim turtlesim\_node )
+#           if not installed: sudo apt install ros-noetic-turtlesim
+#           use a catkin workspace and build a ROS1 Package  
+#           Follow instructions on:
+#           http://wiki.ros.org/ROS/Tutorials (recommend go trough step 1 to 6)
+#           Minimal example to use:
+#           create catkin workspace: 
+#               mkdir -p ~/catkin\_ws/src
+#               cd ~/catkin\_ws
+#               catkin\_make
+#               source devel/setup.bash
+#           build ROS package:
+#               cd ~/catkin\_ws/src
+#               catkin\_create\_pkg my\_pkg\_name rospy roscpp std\_msgs geometry\_msgs sensor\_msgs 
+#           build catkin workspace and sourcing setup file
+#               cd ~/catkin\_ws
+#               cakin\_make
+#               source ~/catkin\_ws/devel/setup.bash
+#           for more functionality see also: ROSExampleMassPoint.py, ROSExampleBringup.launch, ROSExampleControlVelocity.py
+# Author:   Martin Sereinig, Peter Manzl 
+# Date:     2023-05-31 (created)
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. 
+# You can redistribute it and/or modify it under the terms of the Exudyn license. 
+# See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+import exudyn as exu
+from exudyn.utilities import *
+import time
+import os
+
+# import needed ROS modules and messages
+import rospy
+from geometry_msgs.msg import PoseStamped, WrenchStamped, Twist
+from std_msgs.msg import Float64MultiArray, Empty, String, Time
+
+#**class: interface super class to establish a ROS Exudyn interface 
+#           see specific class functions which can be used and extended 
+#           by inheritance with class MyClass(ROSInterface)
+#**author: Martin Sereinig, Peter Manzl 
+#**notes: some inspiration can be taken from 
+class ROSInterface: 
+    def __init__(self, name = 'ExudynRobotInterface'): 
+
+        # check ROS version 
+        self.CheckROSversion()
+
+        # init ros node
+        rospy.init_node(name, anonymous=True)        
+
+        # topics namespace, will be used in all topics
+        self.topicBase = '/exudyn/'
+
+        # set ROS node start time Time 
+        self.t0 = rospy.get_time()
+        print('ROS node initialization at time {} done!'.format(self.t0))
+        # initialize simulation runtime
+        self.tsim = self.t0 -  rospy.get_time()
+
+        # initialization of some timing variables
+        self.rosPoseSendInterval = 0.01  #ms
+        self.rosTwistSendInterval = 0.01 #ms
+        self.lastPoseSendTime = -self.rosPoseSendInterval
+        self.lastTwistSendTime = -self.rosTwistSendInterval
+        self.systemStateUpdateInterval = 0.01  #ms
+        self.lastSystemStateUpdateTime = -self.systemStateUpdateInterval
+        self.lastStepTime = 0    # last step time (exudyn time)
+        
+        # initialize standard publisher
+        # publisher for time message 
+        self.exuTimePublisher =  self.InitPublisher(pubTopicName='SimiulationTime', 
+                                        pubType = Time, queueSize = 10)
+        # publisher for simple string message 
+        self.exuStringPublisher =  self.InitPublisher(pubTopicName='SimpleString', 
+                                        pubType = String, queueSize = 10)
+        # publisher for velocities (Twist)
+        self.exuTwistPublisher =  self.InitPublisher(pubTopicName='Twist', 
+                                        pubType = Twist, queueSize = 10)
+        # publisher for Pose
+        self.exuPosePublisher =  self.InitPublisher(pubTopicName='Pose', 
+                                        pubType = PoseStamped, queueSize = 10)
+        # publisher for Wrench
+        self.exuWrenchPublisher =  self.InitPublisher(pubTopicName='Wrensh', 
+                                        pubType = WrenchStamped, queueSize = 10)
+        # publisher for system data
+        self.exuSystemstatePublisher =  self.InitPublisher(pubTopicName='Systemstate', 
+                                        pubType = Float64MultiArray, queueSize = 1)
+        # add further publisher if needed in inherited class
+        # initialization of subscriber and needed callback function will be done in inherited class   
+        # self.callbackData =
+        return
+    #**classFunction: function to create a publisher
+    #**input:
+    #       pubTopicName: topic name to publish, actual topic will be /exudyn/pubTopicName
+    #       pubType: data type used in topic
+    #       queSize: length of queue to hold messages, should be as small as sending frequency (= simulation sample time)
+    #**author: Martin Sereinig
+    #**notes: find msgs types here
+    #  http://docs.ros.org/en/melodic/api/std\_msgs/html/index-msg.html
+    #**examples: 
+    #       publisher for poses, pubType = PoseStamped, 
+    #       publisher for system data, pubType = Float64MultiArray,
+    #       publisher for filtered force, pubType = WrenchStamped,
+    #       publisher for velocities, pubType = Twist,
+    def InitPublisher(self, pubTopicName='', pubType = Empty, queueSize = 10): 
+        exuPublisher = rospy.Publisher(self.topicBase  + pubTopicName, 
+                            pubType, queue_size=queueSize)
+        return exuPublisher 
+    
+    #**classFunction: function to create a generic callback function for a subscriber
+    #**input:
+    #       topic: topic name generated by init Subscriber
+    #       data: data structure for regarding individual topic 
+    #**author: Peter Manzl 
+    def ExuCallbackGeneric(self,subTopicName, data): 
+        setattr(self, subTopicName, data)
+        return True
+    
+    #**classFunction: function to create a subscriber
+    #**input:
+    #       subTopicNameSpace: topic namespace: 'exudyn/'
+    #       subTopicName: topic name to subscribe
+    #       subType: data type for topic to subscribe
+    #**author: Peter Manzl 
+    #**note: callback function will be automatic generated for each subscriber, depending
+    #        on subTopicName. Data will be found under self.subTopicName
+    def InitSubscriber(self,subTopicNameSpace, subTopicName, subType): 
+        exuSubscriber = rospy.Subscriber(subTopicNameSpace+subTopicName, subType, 
+                                    lambda data: self.ExuCallbackGeneric(subTopicName, data))
+        return exuSubscriber
+
+    #**classFunction: check the current used ROS version
+    #**author: Martin Sereinig
+    #**note: just supports ROS1, ROS2 support will be given in future releases 
+    def CheckROSversion(self):
+        # check and set ROSVersion 
+        #os.system('rosversion -d')
+        #self.myROSversionString = os.popen('rosversion -d').read()
+        self.myROSversionEnvInt = int(os.getenv('ROS_VERSION','0'))
+        self.myROSdistriEnv = os.getenv('ROS_DISTRO','unknown')
+        rospy.loginfo('-ROS'+str(self.myROSversionEnvInt)+' '+self.myROSdistriEnv+'-')  
+        if self.myROSversionEnvInt != 0:
+            return True
+        else:
+            return False        
+
+    #**classFunction: Example method to be called once per frame/control cycle in Exudyn PreStepUserFunction
+    #**note:        reads sensor values, creates message, publish and subscribe to ROS 
+    #**input:
+    #  mbs:     mbs (exudyn.exudynCPP.MainSystem), multi-body simulation system from exudyn
+    #  tExu:    tExu (float), elapsed time since simulation start
+    #  getData: getData (string), get pose information from 'node' or from 'sensor'
+    #**author: Martin Sereinig
+    #**notes: 
+    #           reads sensor values, creates message, publish and subscribe to ROS
+    #           publishing each and every step is too much, this would slow down the connection
+    #           thus: publish every few seconds, only
+    #           furthermore, as vrInterface is only updating the graphics with f=60Hz, we don't have to update
+    #           system state every 1ms, so with f=1000Hz. Instead f=60Hz equivalents to update every 1/60=17ms
+    #           timing variable to know when to send new command to robot or when to publish new mbs system state update
+    def PublishPoseUpdate(self, mbs, tExu, getData = 'node'):
+        if tExu - self.lastPoseSendTime >= self.rosPoseSendInterval:
+            self.lastPoseSendTime = tExu
+            if getData == 'sensor':
+                # read current kinematic state and orientation from predefined variables send via mbs.variables
+                posFromExu = mbs.GetSensorValues(mbs.variables['pos'])
+                oriFromExu = mbs.GetSensorValues(mbs.variables['ori'])
+                # convert data to numpy arrays
+                pos = np.array(posFromExu)
+                rot = np.array(oriFromExu)
+                rotE = np.roll(RotXYZ2EulerParameters(rot),-1)  # use roll to meet ROS eulerparameter convention [x,y,z,w]
+
+            elif getData == 'node':
+                nodeDic = mbs.GetNode(mbs.variables['nodeNumber'])
+                if nodeDic['nodeType'] == 'RigidBodyEP':
+                    # get position [x,y,z] and orientation (eulerparameter) [w,x,y,z] from exudyn via node coordinates 
+                    # nodeCoordinates = [x,y,z, w,x,y,z]
+                    nodeCoordinates = list(np.array(nodeDic['referenceCoordinates']) + 
+                                        np.array(mbs.GetNodeOutput(mbs.variables['nodeNumber'],variableType = exu.OutputVariableType.Coordinates)))
+                    # reformulation for ROS 
+                    pos = nodeCoordinates[0:3] # pos = [x,y,z]
+                    rotE = np.roll(nodeCoordinates[3:7],-1) # rotE = [x,y,z,w]
+
+                    if False: # for debug
+                        print('position: ',nodeCoordinates[0:3])
+                        print('orientation: ',nodeCoordinates[3:7]) # eulerparameter exu [w,x,y,z]
+                else: 
+                    print('node type not supported')
+            else:
+                print('Error! Please choose how to get pose information!')
+            
+            
+            poseExu = np.append(pos,rotE)
+            # compose message and publish
+            msgData = PoseStamped()
+            # postion
+            msgData.pose.position.x = poseExu[0]
+            msgData.pose.position.y = poseExu[1]
+            msgData.pose.position.z = poseExu[2]
+            # orientation given in unit quarternions
+            msgData.pose.orientation.x = poseExu[3]
+            msgData.pose.orientation.y = poseExu[4]
+            msgData.pose.orientation.z = poseExu[5]
+            msgData.pose.orientation.w = poseExu[6]
+            # write current time into message
+            msgData.header.stamp = rospy.Time.now()
+            self.exuPosePublisher.publish(msgData)
+
+
+
+    #**classFunction: Example method to be called once per frame/control cycle in Exudyn PreStepUserFunction
+    #**note:        reads sensor values, creates message, publish and subscribe to ROS 
+    #**input:
+    #  mbs:     mbs (exudyn.exudynCPP.MainSystem), multi-body simulation system from exudyn
+    #  tExu:    tExu (float), elapsed time since simulation start
+    #  getData: getData (string), get pose information from 'node' or from 'sensor'
+    #**author: Martin Sereinig
+    #**notes: 
+    #           reads sensor values, creates message, publish and subscribe to ROS
+    def PublishTwistUpdate(self, mbs, tExu, getData='node'):
+        if tExu - self.lastTwistSendTime >= self.rosTwistSendInterval:
+            self.lastTwistSendTime = tExu
+
+            if getData == 'sensor':
+                # read current kinematic state and orientation from predefined variables
+                velocityLinearFromExu = mbs.GetSensorValues(mbs.variables['velt'])
+                velocityAngularFromExu = mbs.GetSensorValues(mbs.variables['velr'])
+                # convert data to numpy arrays
+                velLin = np.array(velocityLinearFromExu)
+                velAng = np.array(velocityAngularFromExu)
+
+            elif getData == 'node':
+                nodeDic = mbs.GetNode(mbs.variables['nodeNumber'])
+                if nodeDic['nodeType'] == 'RigidBodyEP':
+                    # get linear and angular velocity form exudyn via node 
+                    velLin= mbs.GetNodeOutput(mbs.variables['nodeNumber'],variableType = exu.OutputVariableType.Velocity)
+                    velAng = mbs.GetNodeOutput(mbs.variables['nodeNumber'],variableType = exu.OutputVariableType.AngularVelocity)
+                    # same could be done to get acceleration from exudyn node 
+                    # nUIPLinearAcc= mbs.GetNodeOutput(nUIP,variableType = exu.OutputVariableType.Acceleration)
+                    # nUIPAngularAcc= mbs.GetNodeOutput(nUIP,variableType = exu.OutputVariableType.AngularAcceleration)
+            
+            twistExu = np.append(velLin,velAng)
+            # compose message and publish
+            msgData = Twist()
+            # linear velocities
+            msgData.linear.x = twistExu[0]
+            msgData.linear.y = twistExu[1]
+            msgData.linear.z = twistExu[2]
+            # angular velocities
+            msgData.angular.x = twistExu[3]
+            msgData.angular.y = twistExu[4]
+            msgData.angular.z = twistExu[5]
+            # write current time into message
+            self.exuTwistPublisher.publish(msgData)
+
+    #**classFunction: method to be send system state data once per frame/control cycle in Exudyn PreStepUserFunction
+    #**input:
+    #  mbs:     mbs (exudyn.exudynCPP.MainSystem), multi-body simulation system from exudyn
+    #  tExu:       tExu (float),  simulation time
+    # systemStateData:   systemStateData (list), full Exudyn SystemState
+    #**author: Martin Sereinig
+    #**note:        collects important exudyn system data and send it to ros-topic
+    def PublishSystemStateUpdate(self, mbs, tExu):
+        if tExu - self.lastSystemStateUpdateTime >= self.systemStateUpdateInterval:
+            self.lastSystemStateUpdateTime = tExu
+            
+            systemStateList1d = []
+            # publish system state to ros-topic 
+            systemStateData = mbs.systemData.GetSystemState()
+
+            # first entry is current time
+            systemStateList1d.append(tExu)
+
+            # then systemData itself follows
+            for array in systemStateData:
+                # add length of next array
+                systemStateList1d.append(float(len(array)))
+                # add array itself
+                for i in range(len(array)):
+                    systemStateList1d.append(array[i])
+
+            msg = Float64MultiArray()
+            msg.data = systemStateList1d # dataList
+            self.exuSystemstatePublisher.publish(msg)
+
+
```

## exudyn/robotics/special.py

 * *Ordering differences only*

```diff
@@ -1,372 +1,372 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library for robotics
-#
-# Details:  additional support functions for robotics;
-#           The library is built on Denavit-Hartenberg Parameters and
-#           Homogeneous Transformations (HT) to describe transformations and coordinate systems
-#
-# Author:   Martin Sereinig
-# Date:     2021-22-09
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-import exudyn.robotics as rob
-from exudyn.basicUtilities import ScalarMult
-from exudyn.rigidBodyUtilities import RotationMatrix2RotZYZ, HT2rotationMatrix, HT2translation, Skew, HTtranslate
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute velocity manipulability measure for given pose (homogeneous  transformation)
-#**input:
-#  robot: robot class
-#  HT: actual pose as homogeneous transformaton matrix
-#  mode: rotational or translational part of the movement
-#**output: velocity manipulability measure as scalar value, defined as $\sqrt(det(JJ^T))$
-#**author: Martin Sereinig
-#**notes: compute velocity dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}
-def VelocityManipulability(robot, HT, mode):
-    if mode == 'all':
-        J = robot.Jacobian(HT, [], 'all')
-
-    elif mode == 'rot':
-        J = robot.Jacobian(HT, [], 'rot')
-
-    elif mode == 'trans':
-        J = robot.Jacobian(HT, [], 'trans')
-
-    #check for singular Matrix not needed, no inverse is used
-    mv2 = np.linalg.det(J@J.T)
-    mv3 = np.max([0, mv2]) # to avoid negative values they are set to zero, same as corke
-    #mv3 = np.abs(mv2)  #to avoid negative values, the absolute value of the determinat is used should be better
-    mv = np.sqrt(mv3)
-
-    return np.real(mv)
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute force manipulability measure for given pose (homogeneous  transformation)
-#**input:
-#  robot: robot class
-#  HT: actual pose as hoogenious transformaton matrix
-#  singularWeight: Weighting of singular configurations where the value would be infinity, default value=100
-#  mode: rotational or translational part of the movement
-#**output: force manipulability measure as scalar value, defined as $\sqrt((det(JJ^T))^{-1})$
-#**author: Martin Sereinig
-#**notes: compute force dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}
-def ForceManipulability(robot, HT, mode,singularWeight=100):
-    if mode == 'all':
-        J = robot.Jacobian( HT, [], 'all')
-
-
-    elif mode == 'rot':
-        J = robot.Jacobian(HT, [], 'rot')
-
-
-    elif mode == 'trans':
-        J = robot.Jacobian(HT, [], 'trans')
-    
-    Jhelp=J@J.T
-    
-    if np.linalg.det(Jhelp)!=0: #check singular Matrix 
-        mf2 = np.linalg.det(np.linalg.inv(Jhelp))
-        mf3 = np.max([0, mf2])      # to avoid negative values they are set to zero, same as corke
-        #mf3 = np.abs(mf2) #to avoid negative values, the absolute value of the determinat is used should be better 
-        mf = np.sqrt(mf3)
-    else:   #matrix is singular for this joint configuration, force manipulability is set to a high value
-        #alternative idea to handle singular matrix inversion(not working yet)
-        #JhelpPinv=np.linalg.pinv(Jhelp)
-        #mf2 = np.linalg.det(JhelpPinv)
-        #mf = np.max([0, mf2])      # to avoid negative values they are set to zero, same as corke
-        mf =singularWeight
-    return np.real(mf)
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute cartesian stiffness measure for given pose (homogeneous transformation)
-#**input:
-#  robot: robot class
-#  JointStiffness: joint stiffness matrix
-#  HT: actual pose as homogeneous transformaton matrix
-#  mode: rotational or translational part of the movement
-#  singularWeight: Weighting of singular configurations where the value would be infinity,default value=1000
-#**output:
-#  stiffness manipulability measure as scalar value, defined as minimum Eigenvalaue of the Cartesian stiffness matrix
-#  Cartesian stiffness matrix
-#**author: Martin Sereinig
-#**notes:
-#**status: this function is {\bf currently under development} and under testing!
-def StiffnessManipulability(robot, JointStiffness, HT, mode,singularWeight=1000):
-    if mode == 'all':
-        J = robot.Jacobian( HT, [], 'all')
-
-    elif mode == 'rot':
-        J = robot.Jacobian( HT, [], 'rot')
-
-    elif mode == 'trans':
-        J = robot.Jacobian( HT, [], 'trans')
-        
-    # check for NAN values or singularities in cartesian stiffnes matrix
-    # has to be checkt for plausability 
-    try:
-        CartesianStiffness = np.linalg.inv(J@np.linalg.inv(JointStiffness)@J.T)
-        
-    except: 
-        HelpMatrix = np.ones(CartesianStiffness.shape)
-        CartesianStiffness = HelpMatrix*singularWeight
-    
-    HelpSum = np.sum(CartesianStiffness)
-    if np.isnan(HelpSum):       #to weight infinite stiffnes solutino to 1000
-        # your error handling block
-        HelpMatrix = np.ones(CartesianStiffness.shape)
-        CartesianStiffness = HelpMatrix*singularWeight
-
-    mst = min(np.linalg.eigvals(CartesianStiffness))
-
-    return [np.real(mst), CartesianStiffness]
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute joint jacobian for each frame for given pose (homogeneous transformation)
-#**input:
-#  robot: robot class
-#  HT: actual pose as homogeneous transformaton matrix
-#**output:
-#  Link(body)-Jacobi matrix JJ: $\LU{i}{JJ_i}=[\LU{i}{J_{Ri}},\; \LU{i}{J_{Ti}}]$ for each link i, seperated in rotational ($J_R$) and translational ($J_T$) part of Jacobian matrix located in the $i^{th}$ coordiante system, see \cite{woernle2016}
-#**author: Martin Sereinig
-#**notes: runs over number of HTs given in HT (may be less than number of links), caclulations in link coordinate system located at the end of each link regarding Standard  Denavid-Hartenberg parameters, see \cite{Corke2013}
-def JointJacobian(robot, HTJoint,HTLink):
-    n = len(HTJoint)
-    # center of mass (COM) in global coordinate frame
-    HTCOM = robot.COMHT(HTJoint)
-    JJ = [np.zeros((6, n))]*n
-    Jomega = np.zeros((3, n))  # rotation part of jacobian
-    Jvel = np.zeros((3, n))  # translation part of jacobian
-    u = [[0, 0, 0]]*n  # rotation axis for each joint frame 0 to (n-1)
-    d = [[0, 0, 0]]*n  # distance vector between rotation axis and COM of each link
-    rotAxis = np.array([0, 0, 1])  # robot axis in local coordinates
-    
-    for frame in range(n):  # frames located in joints
-        #if n > len(robot['links']): #old robot dictionary
-        if n > len(robot.links):
-            print(
-                "ERROR: number of homogeneous transformations (HT) greater than number of links")
-        # create robot nodes and bodies:
-        for i in range(frame+1):
-            if i == 0:
-                # for first frame rotation axis=[0,0,1] is z-axis
-                u[i] = HT2rotationMatrix(HTLink[frame]).T @ (rotAxis)
-                # fpr first frame no difference needet
-                d[i] = HT2rotationMatrix(HTLink[frame]).T @ (HT2translation(HTCOM[frame]))
-
-                
-            else:
-                # rotation axis (always z-axis of the last frame) transformed in actual frame
-                u[i] = HT2rotationMatrix(HTLink[frame]).T @ (HT2rotationMatrix(HTLink[i-1]) @ rotAxis)
-                # difference between rotation axis and COM
-                d[i] = HT2rotationMatrix(HTLink[frame]).T @ (HT2translation(HTCOM[frame])-HT2translation(HTLink[i-1]))
-            #print('Frame=%i, i=%i'%(frame,i))
-            #print('di',d[i])
-        
- 
-            # revolute joint:
-            # if robot['jointType'][frame] == 1:  # revolute joint  #old version with robot dictionary
-            if robot.links[frame].jointType[0] == 'R':
-                # only considered, if revolute joint
-                Jvel[0:3, i] = Skew(u[i]) @ d[i]
-                Jomega[0:3, i] = u[i]
-            else:  # prismatic joint
-                Jvel[0:3, i] = u[i]  # NOT TESTED!!!
-                Jomega[0:3, i] = ScalarMult(0, u[i]) # for prismatic joint
-
-
-        JJ[frame] = np.array([Jomega, Jvel])
-    return JJ
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute mass matrix from jointJacobian
-#**input:
-#  robot: robot structure
-#  HT: actual pose as homogeneous transformaton matrix
-#  jointJacobian: provide list of jacobians as provided by function JointJacobian(...)
-#**output:
-#  MM: Mass matrix
-#**author: Martin Sereinig
-#**notes: Mass Matrix calculation calculated in joint coordinates regarding (std) DH parameter:
-#**       Dynamic equations in minimal coordinates as described in Mehrkörpersysteme by Woernle, \cite{woernle2016}, p206, eq6.90.
-#**       Caclulations in link coordinate system at the end of each link
-def MassMatrix(robot, HT, jointJacobian):
-    # inertia (mass) matrix
-    MM = np.zeros((len(robot.links), len(robot.links)))
-    # MMa=[MM]*3  #for testing
-    for i in range(len(robot.links)):
-            # inertia matrix given in actual frame
-            I = robot.links[i].inertia
-            MM += jointJacobian[i][0].T @ I @ jointJacobian[i][0] + \
-                robot.links[i].mass * \
-                    jointJacobian[i][1].T @ jointJacobian[i][1]
-            # MMa[i]=jointJacobian[i][0].T @ I @ jointJacobian[i][0]+ robot['links'][i]['mass'] * jointJacobian[i][1].T @ jointJacobian[i][1]
-
-    return MM
-
-
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: compute dynamic manipulability measure for given pose (homogeneous transformation)
-#**input:
-#  robot: robot structure
-#  HT: actual pose as homogeneous transformaton matrix
-#  Tmax: maximum joint torques
-#  mode: rotational or translational part of the movement
-#  MassMatrix: Mass (inertia) Maxtrix provided by the function MassMatrix
-#  singularWeight: Weighting of singular configurations where the value would be infinity,default value=1000
-#**output:
-#  dynamic manipulability measure as scalar value, defined as minimum Eigenvalaue of the dynamic manipulability matrix N
-#  dynamic manipulability matrix
-#**author: Martin Sereinig
-#**notes: acceleration dependent manipulability definded by Chiacchio, see \cite{Chiacchio1998}, eq.32. The eigenvectors and eigenvalues of N ([eigenvec eigenval]=eig(N))gives the direction and value of minimal and maximal accaleration )
-#**status: this function is {\bf currently under development} and under testing!
-def DynamicManipulability(robot, HT, MassMatrix, Tmax, mode, singularWeight=1000):
-    MM = MassMatrix
-    B = MM
-    if mode == 'all':
-        J = robot.Jacobian( HT, [], 'all')
-
-    elif mode == 'rot':
-        J = robot.Jacobian( HT, [], 'rot')
-
-    elif mode == 'trans':
-        J = robot.Jacobian( HT, [], 'trans')
-    
-     # check for singularity
-    B = MM
-    Q = (np.linalg.inv(Tmax)@B).T @ (np.linalg.inv(Tmax)@B)
-    JWeightPseudo = np.linalg.inv(Q) @ J.T @ np.linalg.inv((J @ np.linalg.inv(Q) @ J.T))
-
-    N = JWeightPseudo.T @ Q @ JWeightPseudo
-    HelpSum = np.sum(N)
-    if np.isnan(HelpSum):
-         # your error handling block
-         HelpMatrix = np.ones(N.shape)
-         N = HelpMatrix*singularWeight
-
-    ma = min(np.linalg.eigvals(N))
-    
-    
-    return [np.real(ma), N]
-
-
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#+++
-#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: calculation of 4 different manipulability measures using a certain serial robot
-#**input:
-#  robot: robot class
-#  robotDic: robot dictionary
-#  q: joint position vector  
-#  mode: trans or rot, for used parts of the manipulator Jacobi Matrix
-#  Tmax: maximum joint torques
-#  mode: rotational or translational part of the movement
-#  flag: flag vector to swich individual measure on and of [flagmv,flagmf,flagmst,flagma] = [1,1,1,1]
-#**output:
-#  [mv,mf,mst,mstM,ma,maM]
-#**author: Martin Sereinig
-#**notes:  
-#**status: this function is {\bf currently under development} and under testing!
-def CalculateAllMeasures(robot,robotDic,q,mode, flag = [0,0,0,0] ):
-    
-    JointStiffnesM=robotDic['jointStiffnessMatrix']
-    TmaxDiag=robotDic['joinTorqueMaxMatrix']
-
-    HT0newJoint=robot.JointHT(q)
-    HT0newLink=robot.LinkHT(q)
-    JointJacobianHT0 = JointJacobian(robot,HT0newJoint,HT0newLink)
-    MMatrixHT0 = MassMatrix(robot,HT0newJoint,JointJacobianHT0)
-    mv=[]
-    mf=[]
-    mst=[]
-    mstM=[]
-    ma=[]
-    maM=[]
-    
-    if len(flag) != 4:
-        raise ValueError('CalculateAllMeasures: flag needs to be list with 4 int, being either 0 or 1')
-    if flag[0]:
-        mv = VelocityManipulability(robot, HT0newJoint, mode)       
-    if flag[1]:
-        mf = ForceManipulability(robot, HT0newJoint, mode, singularWeight=100)        
-    if flag[2]:
-        mst,mstM = StiffnessManipulability(robot, JointStiffnesM, HT0newJoint, mode, singularWeight=1000)            
-    if flag[3]:
-        ma,maM = DynamicManipulability(robot, HT0newJoint, MMatrixHT0, TmaxDiag, mode, singularWeight=1000)        
-
-    #too complicated:
-    # if flag == [1,0,0,0]:
-    #     mv = VelocityManipulability(robot, HT0newJoint, mode)       
-    # elif flag ==  [1,1,0,0]:
-    #     mv = VelocityManipulability(robot, HT0newJoint, mode)     
-    #     mf = ForceManipulability(robot, HT0newJoint, mode,singularWeight=100)        
-    # elif flag ==  [1,1,1,0]:
-    #     mv = VelocityManipulability(robot, HT0newJoint, mode)     
-    #     mf = ForceManipulability(robot, HT0newJoint, mode,singularWeight=100)     
-    #     mst,mstM = StiffnessManipulability(robot, JointStiffnesM, HT0newJoint, mode, singularWeight=1000)            
-    # elif flag ==  [1,1,1,1]:
-    #     mv = VelocityManipulability(robot, HT0newJoint, mode)     
-    #     mf = ForceManipulability(robot, HT0newJoint, mode,singularWeight=100)     
-    #     mst,mstM = StiffnessManipulability(robot, JointStiffnesM, HT0newJoint, mode, singularWeight=1000)      
-    #     ma,maM = DynamicManipulability(robot, HT0newJoint, MMatrixHT0, TmaxDiag, mode, singularWeight=1000)        
-    # else:
-    #     print('flag not defined')
- 
-
-    return [mv,mf,mst,mstM,ma,maM]
-
-
-
-#%%++++++++++++++++++++++++
-#testing of module spezial
-if __name__ == '__main__':
-
-    #imports
-    from exudyn.utilities import *
-    from exudyn.rigidBodyUtilities import *
-    from exudyn.graphicsDataUtilities import *
-    from exudyn.robotics import *   # to import  robotics core functions
-
-
-
-#MS Todo: check each function 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library for robotics
+#
+# Details:  additional support functions for robotics;
+#           The library is built on Denavit-Hartenberg Parameters and
+#           Homogeneous Transformations (HT) to describe transformations and coordinate systems
+#
+# Author:   Martin Sereinig
+# Date:     2021-22-09
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+import exudyn.robotics as rob
+from exudyn.basicUtilities import ScalarMult
+from exudyn.rigidBodyUtilities import RotationMatrix2RotZYZ, HT2rotationMatrix, HT2translation, Skew, HTtranslate
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute velocity manipulability measure for given pose (homogeneous  transformation)
+#**input:
+#  robot: robot class
+#  HT: actual pose as homogeneous transformaton matrix
+#  mode: rotational or translational part of the movement
+#**output: velocity manipulability measure as scalar value, defined as $\sqrt(det(JJ^T))$
+#**author: Martin Sereinig
+#**notes: compute velocity dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}
+def VelocityManipulability(robot, HT, mode):
+    if mode == 'all':
+        J = robot.Jacobian(HT, [], 'all')
+
+    elif mode == 'rot':
+        J = robot.Jacobian(HT, [], 'rot')
+
+    elif mode == 'trans':
+        J = robot.Jacobian(HT, [], 'trans')
+
+    #check for singular Matrix not needed, no inverse is used
+    mv2 = np.linalg.det(J@J.T)
+    mv3 = np.max([0, mv2]) # to avoid negative values they are set to zero, same as corke
+    #mv3 = np.abs(mv2)  #to avoid negative values, the absolute value of the determinat is used should be better
+    mv = np.sqrt(mv3)
+
+    return np.real(mv)
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute force manipulability measure for given pose (homogeneous  transformation)
+#**input:
+#  robot: robot class
+#  HT: actual pose as hoogenious transformaton matrix
+#  singularWeight: Weighting of singular configurations where the value would be infinity, default value=100
+#  mode: rotational or translational part of the movement
+#**output: force manipulability measure as scalar value, defined as $\sqrt((det(JJ^T))^{-1})$
+#**author: Martin Sereinig
+#**notes: compute force dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}
+def ForceManipulability(robot, HT, mode,singularWeight=100):
+    if mode == 'all':
+        J = robot.Jacobian( HT, [], 'all')
+
+
+    elif mode == 'rot':
+        J = robot.Jacobian(HT, [], 'rot')
+
+
+    elif mode == 'trans':
+        J = robot.Jacobian(HT, [], 'trans')
+    
+    Jhelp=J@J.T
+    
+    if np.linalg.det(Jhelp)!=0: #check singular Matrix 
+        mf2 = np.linalg.det(np.linalg.inv(Jhelp))
+        mf3 = np.max([0, mf2])      # to avoid negative values they are set to zero, same as corke
+        #mf3 = np.abs(mf2) #to avoid negative values, the absolute value of the determinat is used should be better 
+        mf = np.sqrt(mf3)
+    else:   #matrix is singular for this joint configuration, force manipulability is set to a high value
+        #alternative idea to handle singular matrix inversion(not working yet)
+        #JhelpPinv=np.linalg.pinv(Jhelp)
+        #mf2 = np.linalg.det(JhelpPinv)
+        #mf = np.max([0, mf2])      # to avoid negative values they are set to zero, same as corke
+        mf =singularWeight
+    return np.real(mf)
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute cartesian stiffness measure for given pose (homogeneous transformation)
+#**input:
+#  robot: robot class
+#  JointStiffness: joint stiffness matrix
+#  HT: actual pose as homogeneous transformaton matrix
+#  mode: rotational or translational part of the movement
+#  singularWeight: Weighting of singular configurations where the value would be infinity,default value=1000
+#**output:
+#  stiffness manipulability measure as scalar value, defined as minimum Eigenvalaue of the Cartesian stiffness matrix
+#  Cartesian stiffness matrix
+#**author: Martin Sereinig
+#**notes:
+#**status: this function is {\bf currently under development} and under testing!
+def StiffnessManipulability(robot, JointStiffness, HT, mode,singularWeight=1000):
+    if mode == 'all':
+        J = robot.Jacobian( HT, [], 'all')
+
+    elif mode == 'rot':
+        J = robot.Jacobian( HT, [], 'rot')
+
+    elif mode == 'trans':
+        J = robot.Jacobian( HT, [], 'trans')
+        
+    # check for NAN values or singularities in cartesian stiffnes matrix
+    # has to be checkt for plausability 
+    try:
+        CartesianStiffness = np.linalg.inv(J@np.linalg.inv(JointStiffness)@J.T)
+        
+    except: 
+        HelpMatrix = np.ones(CartesianStiffness.shape)
+        CartesianStiffness = HelpMatrix*singularWeight
+    
+    HelpSum = np.sum(CartesianStiffness)
+    if np.isnan(HelpSum):       #to weight infinite stiffnes solutino to 1000
+        # your error handling block
+        HelpMatrix = np.ones(CartesianStiffness.shape)
+        CartesianStiffness = HelpMatrix*singularWeight
+
+    mst = min(np.linalg.eigvals(CartesianStiffness))
+
+    return [np.real(mst), CartesianStiffness]
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute joint jacobian for each frame for given pose (homogeneous transformation)
+#**input:
+#  robot: robot class
+#  HT: actual pose as homogeneous transformaton matrix
+#**output:
+#  Link(body)-Jacobi matrix JJ: $\LU{i}{JJ_i}=[\LU{i}{J_{Ri}},\; \LU{i}{J_{Ti}}]$ for each link i, seperated in rotational ($J_R$) and translational ($J_T$) part of Jacobian matrix located in the $i^{th}$ coordiante system, see \cite{woernle2016}
+#**author: Martin Sereinig
+#**notes: runs over number of HTs given in HT (may be less than number of links), caclulations in link coordinate system located at the end of each link regarding Standard  Denavid-Hartenberg parameters, see \cite{Corke2013}
+def JointJacobian(robot, HTJoint,HTLink):
+    n = len(HTJoint)
+    # center of mass (COM) in global coordinate frame
+    HTCOM = robot.COMHT(HTJoint)
+    JJ = [np.zeros((6, n))]*n
+    Jomega = np.zeros((3, n))  # rotation part of jacobian
+    Jvel = np.zeros((3, n))  # translation part of jacobian
+    u = [[0, 0, 0]]*n  # rotation axis for each joint frame 0 to (n-1)
+    d = [[0, 0, 0]]*n  # distance vector between rotation axis and COM of each link
+    rotAxis = np.array([0, 0, 1])  # robot axis in local coordinates
+    
+    for frame in range(n):  # frames located in joints
+        #if n > len(robot['links']): #old robot dictionary
+        if n > len(robot.links):
+            print(
+                "ERROR: number of homogeneous transformations (HT) greater than number of links")
+        # create robot nodes and bodies:
+        for i in range(frame+1):
+            if i == 0:
+                # for first frame rotation axis=[0,0,1] is z-axis
+                u[i] = HT2rotationMatrix(HTLink[frame]).T @ (rotAxis)
+                # fpr first frame no difference needet
+                d[i] = HT2rotationMatrix(HTLink[frame]).T @ (HT2translation(HTCOM[frame]))
+
+                
+            else:
+                # rotation axis (always z-axis of the last frame) transformed in actual frame
+                u[i] = HT2rotationMatrix(HTLink[frame]).T @ (HT2rotationMatrix(HTLink[i-1]) @ rotAxis)
+                # difference between rotation axis and COM
+                d[i] = HT2rotationMatrix(HTLink[frame]).T @ (HT2translation(HTCOM[frame])-HT2translation(HTLink[i-1]))
+            #print('Frame=%i, i=%i'%(frame,i))
+            #print('di',d[i])
+        
+ 
+            # revolute joint:
+            # if robot['jointType'][frame] == 1:  # revolute joint  #old version with robot dictionary
+            if robot.links[frame].jointType[0] == 'R':
+                # only considered, if revolute joint
+                Jvel[0:3, i] = Skew(u[i]) @ d[i]
+                Jomega[0:3, i] = u[i]
+            else:  # prismatic joint
+                Jvel[0:3, i] = u[i]  # NOT TESTED!!!
+                Jomega[0:3, i] = ScalarMult(0, u[i]) # for prismatic joint
+
+
+        JJ[frame] = np.array([Jomega, Jvel])
+    return JJ
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute mass matrix from jointJacobian
+#**input:
+#  robot: robot structure
+#  HT: actual pose as homogeneous transformaton matrix
+#  jointJacobian: provide list of jacobians as provided by function JointJacobian(...)
+#**output:
+#  MM: Mass matrix
+#**author: Martin Sereinig
+#**notes: Mass Matrix calculation calculated in joint coordinates regarding (std) DH parameter:
+#**       Dynamic equations in minimal coordinates as described in Mehrkörpersysteme by Woernle, \cite{woernle2016}, p206, eq6.90.
+#**       Caclulations in link coordinate system at the end of each link
+def MassMatrix(robot, HT, jointJacobian):
+    # inertia (mass) matrix
+    MM = np.zeros((len(robot.links), len(robot.links)))
+    # MMa=[MM]*3  #for testing
+    for i in range(len(robot.links)):
+            # inertia matrix given in actual frame
+            I = robot.links[i].inertia
+            MM += jointJacobian[i][0].T @ I @ jointJacobian[i][0] + \
+                robot.links[i].mass * \
+                    jointJacobian[i][1].T @ jointJacobian[i][1]
+            # MMa[i]=jointJacobian[i][0].T @ I @ jointJacobian[i][0]+ robot['links'][i]['mass'] * jointJacobian[i][1].T @ jointJacobian[i][1]
+
+    return MM
+
+
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: compute dynamic manipulability measure for given pose (homogeneous transformation)
+#**input:
+#  robot: robot structure
+#  HT: actual pose as homogeneous transformaton matrix
+#  Tmax: maximum joint torques
+#  mode: rotational or translational part of the movement
+#  MassMatrix: Mass (inertia) Maxtrix provided by the function MassMatrix
+#  singularWeight: Weighting of singular configurations where the value would be infinity,default value=1000
+#**output:
+#  dynamic manipulability measure as scalar value, defined as minimum Eigenvalaue of the dynamic manipulability matrix N
+#  dynamic manipulability matrix
+#**author: Martin Sereinig
+#**notes: acceleration dependent manipulability definded by Chiacchio, see \cite{Chiacchio1998}, eq.32. The eigenvectors and eigenvalues of N ([eigenvec eigenval]=eig(N))gives the direction and value of minimal and maximal accaleration )
+#**status: this function is {\bf currently under development} and under testing!
+def DynamicManipulability(robot, HT, MassMatrix, Tmax, mode, singularWeight=1000):
+    MM = MassMatrix
+    B = MM
+    if mode == 'all':
+        J = robot.Jacobian( HT, [], 'all')
+
+    elif mode == 'rot':
+        J = robot.Jacobian( HT, [], 'rot')
+
+    elif mode == 'trans':
+        J = robot.Jacobian( HT, [], 'trans')
+    
+     # check for singularity
+    B = MM
+    Q = (np.linalg.inv(Tmax)@B).T @ (np.linalg.inv(Tmax)@B)
+    JWeightPseudo = np.linalg.inv(Q) @ J.T @ np.linalg.inv((J @ np.linalg.inv(Q) @ J.T))
+
+    N = JWeightPseudo.T @ Q @ JWeightPseudo
+    HelpSum = np.sum(N)
+    if np.isnan(HelpSum):
+         # your error handling block
+         HelpMatrix = np.ones(N.shape)
+         N = HelpMatrix*singularWeight
+
+    ma = min(np.linalg.eigvals(N))
+    
+    
+    return [np.real(ma), N]
+
+
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#+++
+#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#**function: calculation of 4 different manipulability measures using a certain serial robot
+#**input:
+#  robot: robot class
+#  robotDic: robot dictionary
+#  q: joint position vector  
+#  mode: trans or rot, for used parts of the manipulator Jacobi Matrix
+#  Tmax: maximum joint torques
+#  mode: rotational or translational part of the movement
+#  flag: flag vector to swich individual measure on and of [flagmv,flagmf,flagmst,flagma] = [1,1,1,1]
+#**output:
+#  [mv,mf,mst,mstM,ma,maM]
+#**author: Martin Sereinig
+#**notes:  
+#**status: this function is {\bf currently under development} and under testing!
+def CalculateAllMeasures(robot,robotDic,q,mode, flag = [0,0,0,0] ):
+    
+    JointStiffnesM=robotDic['jointStiffnessMatrix']
+    TmaxDiag=robotDic['joinTorqueMaxMatrix']
+
+    HT0newJoint=robot.JointHT(q)
+    HT0newLink=robot.LinkHT(q)
+    JointJacobianHT0 = JointJacobian(robot,HT0newJoint,HT0newLink)
+    MMatrixHT0 = MassMatrix(robot,HT0newJoint,JointJacobianHT0)
+    mv=[]
+    mf=[]
+    mst=[]
+    mstM=[]
+    ma=[]
+    maM=[]
+    
+    if len(flag) != 4:
+        raise ValueError('CalculateAllMeasures: flag needs to be list with 4 int, being either 0 or 1')
+    if flag[0]:
+        mv = VelocityManipulability(robot, HT0newJoint, mode)       
+    if flag[1]:
+        mf = ForceManipulability(robot, HT0newJoint, mode, singularWeight=100)        
+    if flag[2]:
+        mst,mstM = StiffnessManipulability(robot, JointStiffnesM, HT0newJoint, mode, singularWeight=1000)            
+    if flag[3]:
+        ma,maM = DynamicManipulability(robot, HT0newJoint, MMatrixHT0, TmaxDiag, mode, singularWeight=1000)        
+
+    #too complicated:
+    # if flag == [1,0,0,0]:
+    #     mv = VelocityManipulability(robot, HT0newJoint, mode)       
+    # elif flag ==  [1,1,0,0]:
+    #     mv = VelocityManipulability(robot, HT0newJoint, mode)     
+    #     mf = ForceManipulability(robot, HT0newJoint, mode,singularWeight=100)        
+    # elif flag ==  [1,1,1,0]:
+    #     mv = VelocityManipulability(robot, HT0newJoint, mode)     
+    #     mf = ForceManipulability(robot, HT0newJoint, mode,singularWeight=100)     
+    #     mst,mstM = StiffnessManipulability(robot, JointStiffnesM, HT0newJoint, mode, singularWeight=1000)            
+    # elif flag ==  [1,1,1,1]:
+    #     mv = VelocityManipulability(robot, HT0newJoint, mode)     
+    #     mf = ForceManipulability(robot, HT0newJoint, mode,singularWeight=100)     
+    #     mst,mstM = StiffnessManipulability(robot, JointStiffnesM, HT0newJoint, mode, singularWeight=1000)      
+    #     ma,maM = DynamicManipulability(robot, HT0newJoint, MMatrixHT0, TmaxDiag, mode, singularWeight=1000)        
+    # else:
+    #     print('flag not defined')
+ 
+
+    return [mv,mf,mst,mstM,ma,maM]
+
+
+
+#%%++++++++++++++++++++++++
+#testing of module spezial
+if __name__ == '__main__':
+
+    #imports
+    from exudyn.utilities import *
+    from exudyn.rigidBodyUtilities import *
+    from exudyn.graphicsDataUtilities import *
+    from exudyn.robotics import *   # to import  robotics core functions
+
+
+
+#MS Todo: check each function 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
```

## exudyn/robotics/utilities.py

```diff
@@ -1,65 +1,72 @@
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-# This is an EXUDYN python utility library for robotics
-#
-# Details:  The utilities contains general helper functions for the robotics module
-#
-# Authors:  Johannes Gerstmayr
-# Date:     2023-04-15
-#
-# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
-#
-#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-
-import numpy as np
-from math import sin, cos
-import exudyn
-from exudyn.utilities import CreateDistanceSensor
-
-#**function: Function to add many distance sensors to represent Lidar; sensors can be either placed on absolute position or attached to rigid body marker
-#**input:
-#  generalContactIndex: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
-#  positionOrMarker: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
-#  minDistance: the minimum distance which is accepted; smaller distance will be ignored
-#  maxDistance: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
-#  cylinderRadius: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
-#  lineLength: length of line to be drawn; note that this length is drawn from obstacle towards sensor if drawDisplaced=True, but the length is always constant
-#  numberOfSensors: number of sensors arranged between angleStart and angleEnd; higher numbers give finer resolution (but requires more CPU time)
-#  angleStart: starting rangle of angles to be used (in radiant)
-#  angleEnd: end of range for angle to be used (in radiant)
-#  inclination: angle of inclination (radiant), positive values showing upwards if placed
-#  rotation: a 3x3 rotation matrix (numpy); the sensor is placed in the X-Y plane of the marker where it is added to; however, you can use this rotation matrix to change the orientation
-#  selectedTypeIndex: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
-#  storeInternal: like with any SensorUserFunction, setting to True stores sensor data internally
-#  fileName: if defined, recorded data of SensorUserFunction is written to specified file
-#  measureVelocity: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
-#  addGraphicsObject: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
-#  drawDisplaced: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
-#  color: optional color for 'laser beam' to be drawn
-#**output: creates sensor and returns list of sensor numbers for all laser sensors
-#**notes: use generalContactIndex = CreateDistanceSensorGeometry(...) before to create GeneralContact module containing geometry
-def AddLidar(mbs, generalContactIndex,
-            positionOrMarker, minDistance=-1e7, 
-            maxDistance=1e7, cylinderRadius=0, lineLength=1,
-            numberOfSensors=100, angleStart=0, angleEnd=2*np.pi,
-            inclination=0, rotation=np.eye(3),
-            selectedTypeIndex=exudyn.ContactTypeIndex.IndexEndOfEnumList,
-            storeInternal = False, fileName = '', measureVelocity = False,
-            addGraphicsObject=False, drawDisplaced=True, color=[1.0, 0.0, 0.0, 1.0]):
-
-    a=inclination
-    L=lineLength
-    phiRange=angleEnd-angleStart
-    sensorList = []
-    for i in range(numberOfSensors):
-        phi = i/numberOfSensors*phiRange+angleStart
-        dirSensor = np.array([L*sin(phi)*cos(a), L*cos(phi)*cos(a),L*sin(a)])#@rotation
-        #print(dirSensor, positionOrMarker)
-        sensorList += [CreateDistanceSensor(mbs, generalContactIndex, positionOrMarker=positionOrMarker, 
-                                         dirSensor=dirSensor,minDistance=0, maxDistance=maxDistance, 
-                                         cylinderRadius=0, storeInternal=True, 
-                                         fileName=fileName, measureVelocity=True, addGraphicsObject=True,
-                                         selectedTypeIndex=selectedTypeIndex,
-                                         color=color)]
-
-    return sensorList
-
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# This is an EXUDYN python utility library for robotics
+#
+# Details:  The utilities contains general helper functions for the robotics module
+#
+# Authors:  Johannes Gerstmayr
+# Date:     2023-04-15
+#
+# Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
+#
+#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+import numpy as np
+from math import sin, cos
+import exudyn
+from exudyn.utilities import CreateDistanceSensor
+
+#**function: Function to add many distance sensors to represent Lidar; sensors can be either placed on absolute position or attached to rigid body marker
+#**input:
+#  generalContactIndex: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
+#  positionOrMarker: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
+#  minDistance: the minimum distance which is accepted; smaller distance will be ignored
+#  maxDistance: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
+#  cylinderRadius: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
+#  lineLength: length of line to be drawn; note that this length is drawn from obstacle towards sensor if drawDisplaced=True, but the length is always constant
+#  numberOfSensors: number of sensors arranged between angleStart and angleEnd; higher numbers give finer resolution (but requires more CPU time); must be larger than 1
+#  angleStart: starting rangle of angles to be used (in radiant); angle of lidar beam is relative to X-axis, using positive rotation sense about Z-axis
+#  angleEnd: end of range for angle to be used (in radiant); angle of lidar beam is relative to X-axis, using positive rotation sense about Z-axis
+#  inclination: angle of inclination (radiant), positive values showing upwards (Z-direction) if rotation is the identity matrix
+#  rotation: a 3x3 rotation matrix (numpy); the sensor is placed in the X-Y plane of the marker where it is added to; however, you can use this rotation matrix to change the orientation
+#  selectedTypeIndex: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
+#  storeInternal: like with any SensorUserFunction, setting to True stores sensor data internally
+#  fileName: if defined, recorded data of SensorUserFunction is written to specified file
+#  measureVelocity: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
+#  addGraphicsObject: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
+#  drawDisplaced: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
+#  color: optional color for 'laser beam' to be drawn
+#**output: creates sensor and returns list of sensor numbers for all laser sensors
+#**notes: use generalContactIndex = CreateDistanceSensorGeometry(...) before to create GeneralContact module containing geometry
+def AddLidar(mbs, generalContactIndex,
+            positionOrMarker, minDistance=0,
+            maxDistance=1e7, cylinderRadius=0, lineLength=1,
+            numberOfSensors=100, angleStart=0, angleEnd=2*np.pi,
+            inclination=0, rotation=np.eye(3),
+            selectedTypeIndex=exudyn.ContactTypeIndex.IndexEndOfEnumList,
+            storeInternal = False, fileName = '', measureVelocity = False,
+            addGraphicsObject=True, drawDisplaced=True, color=[1.0, 0.0, 0.0, 1.0]):
+
+    if numberOfSensors <= 1: raise ValueError('AddLidar: numberOfSensors must be > 1')
+    a=inclination
+    L=lineLength
+    phiRange=angleEnd-angleStart
+    sensorList = []
+    for i in range(numberOfSensors):
+        phi = i/(numberOfSensors-1)*phiRange+angleStart
+        dirSensor = rotation @ np.array([L*cos(phi)*cos(a), L*sin(phi)*cos(a),L*sin(a)])
+        #print(dirSensor, positionOrMarker)
+        sensorList += [CreateDistanceSensor(mbs, generalContactIndex, 
+                                            positionOrMarker=positionOrMarker, 
+                                            dirSensor=dirSensor,
+                                            minDistance=minDistance, maxDistance=maxDistance, 
+                                            cylinderRadius=cylinderRadius, 
+                                            selectedTypeIndex=selectedTypeIndex,
+                                            storeInternal=storeInternal, 
+                                            fileName=fileName, 
+                                            measureVelocity=measureVelocity, 
+                                            addGraphicsObject=addGraphicsObject,
+                                            drawDisplaced=drawDisplaced,
+                                            color=color)]
+
+    return sensorList
+
```

## Comparing `exudyn-1.8.0.dist-info/METADATA` & `exudyn-1.8.28.dev1.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-Metadata-Version: 2.1
-Name: exudyn
-Version: 1.8.0
-Summary: EXUDYN flexible multibody dynamics simulation in C++ and Python
-Home-page: https://github.com/jgerstmayr/EXUDYN
-Author: Johannes Gerstmayr
-Author-email: reply.exudyn@gmail.com
-License: BSD
-Platform: any
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: 3.12
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: BSD License
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Operating System :: MacOS
-Classifier: Topic :: Scientific/Engineering
-Requires-Python: >=3.6
-Description-Content-Type: text/x-rst
-Requires-Dist: numpy
-
-==========
-**Exudyn**
-==========
-
-A flexible multibody dynamics systems simulation code with Python and C++
-
-Exudyn is hosted on `Github <https://github.com/jgerstmayr/EXUDYN>`_ which provides full documentation, tutorial, examples, etc.
-
-See `License on github <https://github.com/jgerstmayr/EXUDYN/blob/master/LICENSE.txt>`_ .
-Pre-compiled available for Windows / Python 3.6 - 3.10.
-
-For more information, installation and tutorials see: 
-
-https://github.com/jgerstmayr/EXUDYN 
-
-For CHANGES (section Issues and Bugs), detailed DOCUMENTATION on theory, usage, and REFERENCE MANUAL on **600+** pages: 
-
-https://github.com/jgerstmayr/EXUDYN/tree/master/docs/theDoc/theDoc.pdf
-
+Metadata-Version: 2.1
+Name: exudyn
+Version: 1.8.28.dev1
+Summary: EXUDYN flexible multibody dynamics simulation in C++ and Python
+Home-page: https://github.com/jgerstmayr/EXUDYN
+Author: Johannes Gerstmayr
+Author-email: reply.exudyn@gmail.com
+License: BSD
+Platform: any
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: MacOS
+Classifier: Topic :: Scientific/Engineering
+Requires-Python: >=3.6
+Description-Content-Type: text/x-rst
+Requires-Dist: numpy
+
+==========
+**Exudyn**
+==========
+
+A flexible multibody dynamics systems simulation code with Python and C++
+
+Exudyn is hosted on `Github <https://github.com/jgerstmayr/EXUDYN>`_ which provides full documentation, tutorial, examples, etc.
+
+See `License on github <https://github.com/jgerstmayr/EXUDYN/blob/master/LICENSE.txt>`_ .
+Pre-compiled available for Windows / Python 3.6 - 3.10.
+
+For more information, installation and tutorials see: 
+
+https://github.com/jgerstmayr/EXUDYN 
+
+For CHANGES (section Issues and Bugs), detailed DOCUMENTATION on theory, usage, and REFERENCE MANUAL on **600+** pages: 
+
+https://github.com/jgerstmayr/EXUDYN/tree/master/docs/theDoc/theDoc.pdf
+
```

