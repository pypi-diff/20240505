# Comparing `tmp/hondana-3.5.1-py3-none-any.whl.zip` & `tmp/hondana-4.0.0a0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,31 @@
-Zip file size: 139661 bytes, number of entries: 52
+Zip file size: 140649 bytes, number of entries: 52
 -rw-r--r--  2.0 unx     1061 b- defN 80-Jan-01 00:00 LICENSE
--rw-r--r--  2.0 unx     2213 b- defN 80-Jan-01 00:00 hondana/__init__.py
+-rw-r--r--  2.0 unx     2214 b- defN 80-Jan-01 00:00 hondana/__init__.py
 -rw-r--r--  2.0 unx     2624 b- defN 80-Jan-01 00:00 hondana/__main__.py
 -rw-r--r--  2.0 unx    12908 b- defN 80-Jan-01 00:00 hondana/artist.py
 -rw-r--r--  2.0 unx    12885 b- defN 80-Jan-01 00:00 hondana/author.py
 -rw-r--r--  2.0 unx    40695 b- defN 80-Jan-01 00:00 hondana/chapter.py
--rw-r--r--  2.0 unx   140994 b- defN 80-Jan-01 00:00 hondana/client.py
+-rw-r--r--  2.0 unx   146208 b- defN 80-Jan-01 00:00 hondana/client.py
 -rw-r--r--  2.0 unx    22211 b- defN 80-Jan-01 00:00 hondana/collections.py
 -rw-r--r--  2.0 unx     8416 b- defN 80-Jan-01 00:00 hondana/cover.py
--rw-r--r--  2.0 unx    10481 b- defN 80-Jan-01 00:00 hondana/custom_list.py
+-rw-r--r--  2.0 unx    11059 b- defN 80-Jan-01 00:00 hondana/custom_list.py
 -rw-r--r--  2.0 unx     6904 b- defN 80-Jan-01 00:00 hondana/enums.py
 -rw-r--r--  2.0 unx     8405 b- defN 80-Jan-01 00:00 hondana/errors.py
 -rw-r--r--  2.0 unx     2933 b- defN 80-Jan-01 00:00 hondana/extras/report_reasons.json
--rw-r--r--  2.0 unx     4324 b- defN 80-Jan-01 00:00 hondana/extras/tags.json
+-rw-r--r--  2.0 unx     4322 b- defN 80-Jan-01 00:00 hondana/extras/tags.json
 -rw-r--r--  2.0 unx     5220 b- defN 80-Jan-01 00:00 hondana/forums.py
--rwxr-xr-x  2.0 unx    75936 b- defN 80-Jan-01 00:00 hondana/http.py
+-rwxr-xr-x  2.0 unx    78044 b- defN 80-Jan-01 00:00 hondana/http.py
 -rw-r--r--  2.0 unx     2764 b- defN 80-Jan-01 00:00 hondana/legacy.py
--rw-r--r--  2.0 unx    56864 b- defN 80-Jan-01 00:00 hondana/manga.py
+-rw-r--r--  2.0 unx    56870 b- defN 80-Jan-01 00:00 hondana/manga.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 hondana/py.typed
--rw-r--r--  2.0 unx    16683 b- defN 80-Jan-01 00:00 hondana/query.py
+-rw-r--r--  2.0 unx    16840 b- defN 80-Jan-01 00:00 hondana/query.py
 -rw-r--r--  2.0 unx     2381 b- defN 80-Jan-01 00:00 hondana/relationship.py
 -rw-r--r--  2.0 unx     6939 b- defN 80-Jan-01 00:00 hondana/report.py
--rw-r--r--  2.0 unx    18535 b- defN 80-Jan-01 00:00 hondana/scanlator_group.py
+-rw-r--r--  2.0 unx    18539 b- defN 80-Jan-01 00:00 hondana/scanlator_group.py
 -rw-r--r--  2.0 unx     6476 b- defN 80-Jan-01 00:00 hondana/tags.py
 -rw-r--r--  2.0 unx     1304 b- defN 80-Jan-01 00:00 hondana/types_/account.py
 -rw-r--r--  2.0 unx     4144 b- defN 80-Jan-01 00:00 hondana/types_/artist.py
 -rw-r--r--  2.0 unx     2155 b- defN 80-Jan-01 00:00 hondana/types_/auth.py
 -rw-r--r--  2.0 unx     4147 b- defN 80-Jan-01 00:00 hondana/types_/author.py
 -rw-r--r--  2.0 unx     4697 b- defN 80-Jan-01 00:00 hondana/types_/chapter.py
 -rw-r--r--  2.0 unx     2790 b- defN 80-Jan-01 00:00 hondana/types_/common.py
@@ -35,20 +35,20 @@
 -rw-r--r--  2.0 unx     1483 b- defN 80-Jan-01 00:00 hondana/types_/forums.py
 -rw-r--r--  2.0 unx     2490 b- defN 80-Jan-01 00:00 hondana/types_/legacy.py
 -rw-r--r--  2.0 unx     9865 b- defN 80-Jan-01 00:00 hondana/types_/manga.py
 -rw-r--r--  2.0 unx     2124 b- defN 80-Jan-01 00:00 hondana/types_/relationship.py
 -rw-r--r--  2.0 unx     3816 b- defN 80-Jan-01 00:00 hondana/types_/report.py
 -rw-r--r--  2.0 unx     4298 b- defN 80-Jan-01 00:00 hondana/types_/scanlator_group.py
 -rw-r--r--  2.0 unx     1690 b- defN 80-Jan-01 00:00 hondana/types_/settings.py
--rw-r--r--  2.0 unx     4014 b- defN 80-Jan-01 00:00 hondana/types_/statistics.py
+-rw-r--r--  2.0 unx     4022 b- defN 80-Jan-01 00:00 hondana/types_/statistics.py
 -rw-r--r--  2.0 unx     2710 b- defN 80-Jan-01 00:00 hondana/types_/tags.py
 -rw-r--r--  2.0 unx     3537 b- defN 80-Jan-01 00:00 hondana/types_/token.py
 -rw-r--r--  2.0 unx     4714 b- defN 80-Jan-01 00:00 hondana/types_/upload.py
 -rw-r--r--  2.0 unx     3138 b- defN 80-Jan-01 00:00 hondana/types_/user.py
 -rw-r--r--  2.0 unx     6774 b- defN 80-Jan-01 00:00 hondana/user.py
 -rw-r--r--  2.0 unx    19571 b- defN 80-Jan-01 00:00 hondana/utils.py
--rw-r--r--  2.0 unx     1061 b- defN 80-Jan-01 00:00 hondana-3.5.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     6318 b- defN 80-Jan-01 00:00 hondana-3.5.1.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 hondana-3.5.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       57 b- defN 80-Jan-01 00:00 hondana-3.5.1.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     4074 b- defN 16-Jan-01 00:00 hondana-3.5.1.dist-info/RECORD
-52 files, 577856 bytes uncompressed, 133369 bytes compressed:  76.9%
+-rw-r--r--  2.0 unx     1061 b- defN 80-Jan-01 00:00 hondana-4.0.0a0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     6353 b- defN 80-Jan-01 00:00 hondana-4.0.0a0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 hondana-4.0.0a0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       57 b- defN 80-Jan-01 00:00 hondana-4.0.0a0.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     4084 b- defN 16-Jan-01 00:00 hondana-4.0.0a0.dist-info/RECORD
+52 files, 585975 bytes uncompressed, 134337 bytes compressed:  77.1%
```

## zipnote {}

```diff
@@ -135,23 +135,23 @@
 
 Filename: hondana/user.py
 Comment: 
 
 Filename: hondana/utils.py
 Comment: 
 
-Filename: hondana-3.5.1.dist-info/LICENSE
+Filename: hondana-4.0.0a0.dist-info/LICENSE
 Comment: 
 
-Filename: hondana-3.5.1.dist-info/METADATA
+Filename: hondana-4.0.0a0.dist-info/METADATA
 Comment: 
 
-Filename: hondana-3.5.1.dist-info/WHEEL
+Filename: hondana-4.0.0a0.dist-info/WHEEL
 Comment: 
 
-Filename: hondana-3.5.1.dist-info/entry_points.txt
+Filename: hondana-4.0.0a0.dist-info/entry_points.txt
 Comment: 
 
-Filename: hondana-3.5.1.dist-info/RECORD
+Filename: hondana-4.0.0a0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## hondana/__init__.py

```diff
@@ -22,15 +22,15 @@
 DEALINGS IN THE SOFTWARE.
 """
 
 __title__ = "Hondana"
 __author__ = "AbstractUmbra"
 __license__ = "MIT"
 __copyright__ = "Copyright 2021-present AbstractUmbra"
-__version__ = "3.5.1"
+__version__ = "4.0.0a"
 
 import logging
 from typing import Literal, NamedTuple
 
 from . import query as query, types_ as types_, utils as utils
 from .artist import *
 from .author import *
@@ -56,12 +56,12 @@
     major: int
     minor: int
     micro: int
     releaselevel: Literal["alpha", "beta", "candidate", "final"]
     serial: int
 
 
-version_info: VersionInfo = VersionInfo(major=3, minor=5, micro=1, releaselevel="final", serial=0)
+version_info: VersionInfo = VersionInfo(major=4, minor=0, micro=0, releaselevel="alpha", serial=0)
 
 logging.getLogger(__name__).addHandler(logging.NullHandler())
 
 del logging, NamedTuple, Literal, VersionInfo
```

## hondana/client.py

```diff
@@ -77,14 +77,15 @@
     FeedOrderQuery,
     MangaDraftListOrderQuery,
     MangaIncludes,
     MangaListOrderQuery,
     ReportListOrderQuery,
     ScanlatorGroupIncludes,
     ScanlatorGroupListOrderQuery,
+    SubscriptionIncludes,
     UserListOrderQuery,
     UserReportIncludes,
 )
 from .report import ReportDetails, UserReport
 from .scanlator_group import ScanlatorGroup
 from .tags import Tag
 from .user import User
@@ -304,14 +305,15 @@
             The list of tags.
         """
         data = await self._http.update_tags()
 
         return [Tag(item) for item in data["data"]]
 
     @require_authentication
+    @deprecated("subscription_feed")
     async def get_my_feed(
         self,
         *,
         limit: int | None = 100,
         offset: int = 0,
         translated_language: list[common.LanguageCode] | None = None,
         original_language: list[common.LanguageCode] | None = None,
@@ -1399,14 +1401,37 @@
         :exc:`NotFound`
             The specified manga or specified custom list are not found, likely due to an incorrect UUID.
         """
 
         await self._http.add_manga_to_custom_list(custom_list_id, manga_id=manga_id)
 
     @require_authentication
+    async def batch_add_manga_to_custom_list(self, custom_list_id: str, /, *, manga_ids: list[str]) -> None:
+        """|coro|
+
+        This method will add the specified manga to the specified custom list.
+
+        Parameters
+        -----------
+        custom_list_id: :class:`str`
+            The UUID associated with the custom list you wish to add the manga to.
+        manga_ids: list[:class:`str`]
+            The UUIDs associated with the manga you wish to add to the custom list.
+
+        Raises
+        -------
+        :exc:`Forbidden`
+            You are not authorised to add manga to this custom list.
+        :exc:`NotFound`
+            The specified manga or specified custom list are not found, likely due to an incorrect UUID.
+        """
+
+        await self._http.batch_add_manga_to_custom_list(custom_list_id, manga_ids=manga_ids)
+
+    @require_authentication
     async def remove_manga_from_custom_list(self, manga_id: str, /, *, custom_list_id: str) -> None:
         """|coro|
 
         This method will remove the specified manga from the specified custom list.
 
         Parameters
         -----------
@@ -1421,14 +1446,37 @@
             You are not authorised to remove a manga from the specified custom list.
         :exc:`NotFound`
             The specified manga or specified custom list are not found, likely due to an incorrect UUID.
         """
 
         await self._http.remove_manga_from_custom_list(custom_list_id, manga_id=manga_id)
 
+    @require_authentication
+    async def batch_remove_manga_from_custom_list(self, custom_list_id: str, /, *, manga_ids: list[str]) -> None:
+        """|coro|
+
+        This method will remove the specified manga from the specified custom list.
+
+        Parameters
+        -----------
+        custom_list_id: :class:`str`
+            THe UUID associated with the custom list you wish to add the manga to.
+        manga_ids: list[:class:`str`]
+            The UUIDs associated with the manga you wish to remove from the specified custom list.
+
+        Raises
+        -------
+        :exc:`Forbidden`
+            You are not authorised to remove a manga from the specified custom list.
+        :exc:`NotFound`
+            The specified manga or specified custom list are not found, likely due to an incorrect UUID.
+        """
+
+        await self._http.batch_remove_manga_from_custom_list(custom_list_id, manga_ids=manga_ids)
+
     async def chapter_list(
         self,
         *,
         limit: int | None = 100,
         offset: int = 0,
         ids: list[str] | None = None,
         title: str | None = None,
@@ -2166,14 +2214,15 @@
             Your current user details returned from the API.
         """
         data = await self._http.get_my_details()
 
         return User(self._http, data["data"])
 
     @require_authentication
+    @deprecated("get_my_bookmarked_groups")
     async def get_my_followed_groups(self, limit: int = 10, offset: int = 0) -> list[ScanlatorGroup]:
         """|coro|
 
         This method will return a list of scanlation groups the current authenticated user follows.
 
         Parameters
         -----------
@@ -2188,19 +2237,22 @@
             The request returned an error due to authentication failure.
 
         Returns
         --------
         List[:class:`ScanlatorGroup`]
             The list of groups that are being followed.
         """
-        data = await self._http.get_my_followed_groups(limit=limit, offset=offset)
+        data = await self._http.get_my_bookmarked_groups(limit=limit, offset=offset)
 
         return [ScanlatorGroup(self._http, item) for item in data["data"]]
 
+    get_my_bookmarked_groups = get_my_followed_groups
+
     @require_authentication
+    @deprecated("check_if_group_is_bookmarked")
     async def check_if_following_group(self, group_id: str, /) -> bool:
         """|coro|
 
         This method will check if the current authenticated user is following a scanlation group.
 
         Parameters
         -----------
@@ -2210,28 +2262,24 @@
         Returns
         --------
         :class:`bool`
             Whether the passed scanlation group is followed or not.
         """
 
         try:
-            await self._http.is_group_followed(group_id)
+            await self._http.is_group_bookmarked(group_id)
         except errors.NotFound:
             return False
-        return True
+        else:
+            return True
 
-    @require_authentication
-    async def check_if_following_manga(self, manga_id: str, /) -> bool:
-        try:
-            await self._http.is_manga_followed(manga_id)
-        except errors.NotFound:
-            return False
-        return True
+    check_if_group_is_bookmarked = check_if_following_group
 
     @require_authentication
+    @deprecated("get_my_bookmarked_users")
     async def get_my_followed_users(self, *, limit: int | None = 10, offset: int = 0) -> UserCollection:
         """|coro|
 
         This method will return the current authenticated user's followed users.
 
         Parameters
         -----------
@@ -2254,24 +2302,27 @@
         :class:`~hondana.UserCollection`
             A returned collection of users.
         """
         inner_limit = limit or 10
 
         users: list[User] = []
         while True:
-            data = await self._http.get_my_followed_users(limit=inner_limit, offset=offset)
+            data = await self._http.get_my_bookmarked_users(limit=inner_limit, offset=offset)
             users.extend([User(self._http, item) for item in data["data"]])
 
             offset += inner_limit
             if not data["data"] or offset >= 10_000 or limit is not None:
                 break
 
         return UserCollection(self._http, data, users)
 
+    get_my_bookmarked_users = get_my_followed_users
+
     @require_authentication
+    @deprecated("is_user_bookmarked")
     async def check_if_following_user(self, user_id: str, /) -> bool:
         """|coro|
 
         This method will check if the current authenticated user is following the specified user.
 
         Parameters
         -----------
@@ -2286,53 +2337,61 @@
         Returns
         --------
         :class:`bool`
             Whether the target user is followed or not.
         """
 
         try:
-            await self._http.is_user_followed(user_id)
+            await self._http.is_user_bookmarked(user_id)
         except errors.NotFound:
             return False
         else:
             return True
 
+    is_user_bookmarked = check_if_following_user
+
     @require_authentication
+    @deprecated("get_my_bookmarked_custom_lists")
     async def get_my_custom_list_follows(self, limit: int = 10, offset: int = 0) -> list[CustomList]:
         """|coro|
 
         This method will return the current authenticated user's custom list follows.
 
         Returns
         --------
         list[:class:`CustomList`]
             The list of custom lists you follow.
         """
-        data = await self._http.get_user_custom_list_follows(limit=limit, offset=offset)
+        data = await self._http.get_user_custom_list_bookmarks(limit=limit, offset=offset)
 
         return [CustomList(self._http, item) for item in data["data"]]
 
+    get_my_bookmarked_custom_lists = get_my_custom_list_follows
+
     @require_authentication
+    @deprecated("is_custom_list_bookmarked")
     async def check_if_following_custom_list(self, custom_list_id: str, /) -> bool:
         """|coro|
 
         This method will check if the current authenticated user is following the specified custom list.
 
         Returns
         --------
         :class:`bool`
             Whether you follow this custom list or not.
         """
         try:
-            await self._http.is_custom_list_followed(custom_list_id)
+            await self._http.is_custom_list_bookmarked(custom_list_id)
         except errors.NotFound:
             return False
         else:
             return True
 
+    is_custom_list_bookmarked = check_if_following_custom_list
+
     async def create_account(self, *, username: str, password: str, email: str) -> User:
         """|coro|
 
         This method will create an account with the passed parameters within the MangaDex API.
 
         Parameters
         -----------
@@ -2660,15 +2719,15 @@
         :exc:`BadRequest`
             The request was malformed.
         :exc:`Forbidden`
             You are not authorized to follow this custom list.
         :exc:`NotFound`
             The specified custom list does not exist.
         """
-        await self._http.follow_custom_list(custom_list_id)
+        await self._http.bookmark_custom_list(custom_list_id)
 
     bookmark_custom_list = follow_custom_list
 
     @require_authentication
     @deprecated("unbookmark_custom_list")
     async def unfollow_custom_list(self, custom_list_id: str, /) -> None:
         """|coro|
@@ -2683,30 +2742,34 @@
         Raises
         -------
         :exc:`Forbidden`
             You are not authorized to unbookmark this custom list.
         :exc:`NotFound`
             The specified custom list does not exist.
         """
-        await self._http.unfollow_custom_list(custom_list_id)
+        await self._http.unbookmark_custom_list(custom_list_id)
 
     unbookmark_custom_list = unfollow_custom_list
 
     @require_authentication
-    async def get_my_custom_lists(self, *, limit: int | None = 10, offset: int = 0) -> CustomListCollection:
+    async def get_my_custom_lists(
+        self, *, limit: int | None = 10, offset: int = 0, pinned: bool = False
+    ) -> CustomListCollection:
         """|coro|
 
         This method will get the current authenticated user's custom list.
 
         Parameters
         -----------
         limit: Optional[:class:`int`]
             Defaults to 10. The amount of custom lists to return in one request.
         offset: :class:`int`
             Defaults to 0. The pagination offset.
+        pinned: :class:`bool`
+            Defaults to ``False``. Whether to filter by pinned lists or not.
 
 
         .. note::
             Passing ``None`` to ``limit`` will attempt to retrieve all items in the chapter feed.
 
         Raises
         -------
@@ -2718,39 +2781,41 @@
         :class:`~hondana.CustomListCollection`
             A returned collection of custom lists.
         """
         inner_limit = limit or 10
 
         lists: list[CustomList] = []
         while True:
-            data = await self._http.get_my_custom_lists(limit=inner_limit, offset=offset)
+            data = await self._http.get_my_custom_lists(limit=inner_limit, offset=offset, pinned=pinned)
             lists.extend([CustomList(self._http, item) for item in data["data"]])
 
             offset += inner_limit
             if not data["data"] or offset >= 10_000 or limit is not None:
                 break
 
         return CustomListCollection(self._http, data, lists)
 
     @require_authentication
     async def get_users_custom_lists(
-        self, user_id: str, /, *, limit: int | None = 10, offset: int = 0
+        self, user_id: str, /, *, limit: int | None = 10, offset: int = 0, pinned: bool = False
     ) -> CustomListCollection:
         """|coro|
 
         This method will retrieve another user's custom lists.
 
         Parameters
         -----------
         user_id: :class:`str`
             The UUID of the user whose lists we wish to retrieve.
         limit: Optional[:class:`int`]
             Defaults to 10. The amount of custom lists to return in one request.
         offset: :class:`int`
             Defaults to 0. The pagination offset.
+        pinned: :class:`bool`
+            Defaults to ``False``. Whether to filter by pinned lists or not.
 
 
         .. note::
             Passing ``None`` to ``limit`` will attempt to retrieve all items in the chapter feed.
 
         Raises
         -------
@@ -2762,15 +2827,15 @@
         :class:`~hondana.CustomListCollection`
             A returned collection of custom lists.
         """
         inner_limit = limit or 10
 
         lists: list[CustomList] = []
         while True:
-            data = await self._http.get_users_custom_lists(user_id, limit=inner_limit, offset=offset)
+            data = await self._http.get_users_custom_lists(user_id, limit=inner_limit, offset=offset, pinned=pinned)
             lists.extend([CustomList(self._http, item) for item in data["data"]])
 
             offset += inner_limit
             if not data["data"] or offset >= 10_000 or limit is not None:
                 break
 
         return CustomListCollection(self._http, data, lists)
@@ -3147,15 +3212,15 @@
             The UUID relating to the scanlation group you wish to follow.
 
         Raises
         -------
         :exc:`NotFound`
             The scanlation group cannot be found, likely due to an incorrect ID.
         """
-        await self._http.follow_scanlation_group(scanlation_group_id)
+        await self._http.bookmark_scanlation_group(scanlation_group_id)
 
     bookmark_scanlation_group = follow_scanlation_group
 
     @require_authentication
     @deprecated("unbookmark_scanlation_group")
     async def unfollow_scanlation_group(self, scanlation_group_id: str, /) -> None:
         """|coro|
@@ -3168,15 +3233,15 @@
             The UUID relating to the scanlation group you wish to unfollow.
 
         Raises
         -------
         :exc:`NotFound`
             The scanlation group cannot be found, likely due to an incorrect ID.
         """
-        await self._http.unfollow_scanlation_group(scanlation_group_id)
+        await self._http.unbookmark_scanlation_group(scanlation_group_id)
 
     unbookmark_scanlation_group = unfollow_scanlation_group
 
     async def author_list(
         self,
         *,
         limit: int | None = 10,
@@ -3933,14 +3998,102 @@
     @require_authentication
     async def create_forum_thread(self, thread_type: ForumThreadType, resource_id: str) -> ForumThread:
         data = await self._http.create_forum_thread(thread_type=thread_type, resource_id=resource_id)
 
         return ForumThread(self._http, data["data"])
 
     @require_authentication
+    async def get_custom_lists_where_manga_is_present(self, manga_id: str, /) -> list[str]:
+        """|coro|
+
+        This method will return all custom lists where the given manga is present.
+
+        Parameters
+        -----------
+        manga_id: :class:`str`
+            The Manga id we are filtering for.
+
+        Returns
+        --------
+        list[:class:`str`]
+            The array of custom list ids.
+        """
+        return await self._http.get_custom_lists_where_manga_is_present(manga_id)
+
+    @require_authentication
+    async def is_subscribed_to_custom_list(self, custom_list_id: str, /) -> bool:
+        """|coro|
+
+        A method to check if your are subscribed to the passed custom list.
+
+        Parameters
+        -----------
+        custom_list_id: :class:`str`
+            The custom list id to check against.
+
+        Returns
+        --------
+        :class:`bool`
+            Whether we are subscribed or not.
+        """
+        try:
+            await self._http.is_custom_list_subscribed(custom_list_id)
+        except errors.NotFound:
+            return False
+
+        return True
+
+    @require_authentication
+    async def pin_custom_list(self, custom_list_id: str, /) -> None:
+        """|coro|
+
+        This method will pin the custom list so it is part of the "pinned" section of the logged in user's profile.
+
+        Parameters
+        -----------
+        custom_list_id: :class:`str`
+            The custom list to pin.
+        """
+        await self._http.pin_custom_list(custom_list_id)
+
+    @require_authentication
+    async def unpin_custom_list(self, custom_list_id: str, /) -> None:
+        """|coro|
+
+        This method will unpin the custom list.
+
+        Parameters
+        -----------
+        custom_list_id: :class:`str`
+            The custom list to unpin.
+        """
+        await self._http.unpin_custom_list(custom_list_id)
+
+    @require_authentication
+    async def get_subscriptions(
+        self,
+        *,
+        limit: int | None = 20,
+        offset: int = 0,
+        includes: SubscriptionIncludes | None = SubscriptionIncludes(),
+    ) -> CustomListCollection:
+        inner_limit = limit or 20
+
+        lists: list[CustomList] = []
+        while True:
+            data = await self._http.get_subscription_list(limit=inner_limit, offset=offset, includes=includes)
+            lists.extend([CustomList(self._http, item) for item in data["data"]])
+
+            offset += inner_limit
+            if not data["data"] or offset >= 10_000 or limit is not None:
+                break
+
+        return CustomListCollection(self._http, data, lists)
+
+    @require_authentication
     async def check_upload_approval_required(self, *, manga_id: str, locale: common.LanguageCode) -> bool:
         """|coro|
 
         This method will check if moderator approval will be required for uploading to a manga.
 
         Parameters
         -----------
```

## hondana/custom_list.py

```diff
@@ -26,15 +26,15 @@
 
 from typing import TYPE_CHECKING
 
 from .enums import CustomListVisibility
 from .manga import Manga
 from .query import MangaIncludes
 from .user import User
-from .utils import RelationshipResolver, require_authentication
+from .utils import RelationshipResolver, deprecated, require_authentication
 
 if TYPE_CHECKING:
     from .http import HTTPClient
     from .types_.custom_list import CustomListResponse
     from .types_.manga import MangaResponse
     from .types_.relationship import RelationshipResponse
     from .types_.user import UserResponse
@@ -296,35 +296,57 @@
             You are not authorized to delete this custom list.
         :exc:`NotFound`
             The custom list with this UUID was not found.
         """
         await self._http.delete_custom_list(self.id)
 
     @require_authentication
+    @deprecated("bookmark")
     async def follow(self) -> None:
         """|coro|
 
         The method will follow a custom list within the MangaDex API.
 
         Raises
         -------
         :exc:`Forbidden`
             You are not authorized to follow this custom list.
         :exc:`NotFound`
             The specified custom list does not exist.
         """
-        await self._http.follow_custom_list(self.id)
+        await self._http.bookmark_custom_list(self.id)
+
+    bookmark = follow
 
     @require_authentication
+    @deprecated("unbookmark")
     async def unfollow(self) -> None:
         """|coro|
 
         The method will unfollow a custom list within the MangaDex API.
 
         Raises
         -------
         :exc:`Forbidden`
             You are not authorized to unfollow this custom list.
         :exc:`NotFound`
             The specified custom list does not exist.
         """
-        await self._http.unfollow_custom_list(self.id)
+        await self._http.unbookmark_custom_list(self.id)
+
+    unbookmark = unfollow
+
+    @require_authentication
+    async def pin(self) -> None:
+        """|coro|
+
+        This method will pin the custom list so it is part of the "pinned" section of the logged in user's profile.
+        """
+        await self._http.pin_custom_list(self.id)
+
+    @require_authentication
+    async def unpin(self) -> None:
+        """|coro|
+
+        This method will unpin the custom list.
+        """
+        await self._http.unpin_custom_list(self.id)
```

## hondana/extras/report_reasons.json

### Pretty-printed

 * *Similarity: 0.9928571428571429%*

 * *Differences: {"'manga'": "{'missing_cover_art': '97d0a78d-1d08-4a30-b382-3de2effe43c'}"}*

```diff
@@ -26,15 +26,15 @@
         "uploaded_on_wrong_manga": "893e1b3c-88bf-11ec-a27d-0242ac110002",
         "watermarked_images": "8a44e250-d2b1-11eb-a84d-0242ac110002"
     },
     "manga": {
         "duplicate_entry": "8a44e584-d2b1-11eb-a84d-0242ac110002",
         "incorrect_or_missing_volume_numbers": "1a0b6e60-cacd-453f-ba16-b0aafee3ddad",
         "information_to_correct": "8a44e5ca-d2b1-11eb-a84d-0242ac110002",
-        "missing_cover_art": "97d0a78d-1d08-4a30-b382-3de2effe43c3",
+        "missing_cover_art": "97d0a78d-1d08-4a30-b382-3de2effe43c",
         "other": "8a44e624-d2b1-11eb-a84d-0242ac110002",
         "troll_entry": "8a44e534-d2b1-11eb-a84d-0242ac110002",
         "vandalism": "fc472c20-fe84-4bc4-92d9-6660133c2412"
     },
     "scanlation_group": {
         "duplicate_entry": "8a44e70a-d2b1-11eb-a84d-0242ac110002",
         "group_claim_request": "893e133a-88bf-11ec-a27d-0242ac110002",
```

## hondana/extras/tags.json

### Pretty-printed

 * *Similarity: 0.974025974025974%*

 * *Differences: {"'User Created'": "'891cf039-b895-47f0-9229-bef4c96eccd4'", 'delete': "['Self-Published']"}*

```diff
@@ -52,26 +52,26 @@
     "Psychological": "3b60b75c-a2d7-4860-ab56-05f391bb889c",
     "Reincarnation": "0bc90acb-ccc1-44ca-a34a-b9f3a73259d0",
     "Reverse Harem": "65761a2a-415e-47f3-bef2-a9dababba7a6",
     "Romance": "423e2eae-a7a2-4a8b-ac03-a8351462d71d",
     "Samurai": "81183756-1453-4c81-aa9e-f6e1b63be016",
     "School Life": "caaa44eb-cd40-4177-b930-79d3ef2afe87",
     "Sci-Fi": "256c8bd9-4904-4360-bf4f-508a76d67183",
-    "Self-Published": "891cf039-b895-47f0-9229-bef4c96eccd4",
     "Sexual Violence": "97893a4c-12af-4dac-b6be-0dffb353568e",
     "Shota": "ddefd648-5140-4e5f-ba18-4eca4071d19b",
     "Slice of Life": "e5301a23-ebd9-49dd-a0cb-2add944c7fe9",
     "Sports": "69964a64-2f90-4d33-beeb-f3ed2875eb4c",
     "Superhero": "7064a261-a137-4d3a-8848-2d385de3a99c",
     "Supernatural": "eabc5b4c-6aff-42f3-b657-3e90cbd00b75",
     "Survival": "5fff9cde-849c-4d78-aab0-0d52b2ee1d25",
     "Thriller": "07251805-a27e-4d59-b488-f0bfbec15168",
     "Time Travel": "292e862b-2d17-4062-90a2-0356caa4ae27",
     "Traditional Games": "31932a7e-5b8e-49a6-9f12-2afa39dc544c",
     "Tragedy": "f8f62932-27da-4fe4-8ee1-6779a8c5edba",
+    "User Created": "891cf039-b895-47f0-9229-bef4c96eccd4",
     "Vampires": "d7d1730f-6eb0-4ba6-9437-602cac38664c",
     "Video Games": "9438db5a-7e2a-4ac0-b39e-e0d95a34b8a8",
     "Villainess": "d14322ac-4d6f-4e9b-afd9-629d5f4d8a41",
     "Virtual Reality": "8c86611e-fab7-4986-9dec-d1a2f44acdd5",
     "Web Comic": "e197df38-d0e7-43b5-9b09-2842d0c326dd",
     "Wuxia": "acc803a4-c95a-4c22-86fc-eb6b582d82a2",
     "Zombies": "631ef465-9aba-4afb-b0fc-ea10efe274a8"
```

## hondana/http.py

```diff
@@ -85,14 +85,15 @@
         FeedOrderQuery,
         MangaDraftListOrderQuery,
         MangaIncludes,
         MangaListOrderQuery,
         ReportListOrderQuery,
         ScanlatorGroupIncludes,
         ScanlatorGroupListOrderQuery,
+        SubscriptionIncludes,
         UserListOrderQuery,
         UserReportIncludes,
     )
     from .report import ReportDetails
     from .tags import QueryTags
     from .types_ import (
         artist,
@@ -129,19 +130,19 @@
 
 
 __all__ = ("HTTPClient",)
 
 
 class Token:
     __slots__ = (
-        "raw_token",
         "refresh_token",
         "created_at",
         "client_id",
         "expires",
+        "_inner",
         "_http",
         "_client_secret",
     )
     created_at: datetime.datetime
     expires: datetime.datetime
 
     def __init__(
@@ -149,35 +150,35 @@
         token: str,
         /,
         *,
         client_id: str,
         client_secret: str,
         session: aiohttp.ClientSession,
     ) -> None:
+        self._inner: str = token
         self._http: aiohttp.ClientSession = session
         self._client_secret: str = client_secret
-        self.raw_token: str = token
         self.client_id: str = client_id
         self.refresh_token: Token | None = None
         self._parse()
 
     def __str__(self) -> str:
-        return self.raw_token
+        return self._inner
 
     @classmethod
     def from_token_response(
         cls, *, payload: token.GetTokenPayload, session: aiohttp.ClientSession, client_secret: str, client_id: str
     ) -> Self:
         self = cls(payload["access_token"], session=session, client_id=client_id, client_secret=client_secret)
         self.add_refresh_token(payload["refresh_token"])
 
         return self
 
     def _parse(self) -> None:
-        _, payload, _ = self.raw_token.split(".")
+        _, payload, _ = self._inner.split(".")
 
         padding = len(payload) % 4
         token = payload + ("=" * padding)
 
         raw = b64decode(token).decode("utf-8")
         parsed: token.TokenPayload = from_json(raw)
 
@@ -196,24 +197,24 @@
             raise TypeError("Current token has no refresh_token.")
 
         route = AuthRoute("POST", "/token")
 
         data = aiohttp.FormData(
             [
                 ("grant_type", "refresh_token"),
-                ("refresh_token", self.refresh_token.raw_token),
+                ("refresh_token", self._inner),
                 ("client_id", self.client_id),
                 ("client_secret", self._client_secret),
             ]
         )
 
         async with self._http.request(route.verb, route.url, data=data) as resp:
             response_data: token.GetTokenPayload = await resp.json()
 
-        self.raw_token = response_data["access_token"]
+        self._inner = response_data["access_token"]
 
         self._parse()
 
         self.add_refresh_token(response_data["refresh_token"])
         return self
 
     def add_refresh_token(self, raw_token: str) -> None:
@@ -284,15 +285,15 @@
         self._resolve_api_type(dev_api)
         if any([username, password, client_id, client_secret]) and not self._authenticated:
             raise RuntimeError(
                 "You must pass all required login attributes: `username`, `password`, `client_id`, `client_secret`"
             )
 
     def _resolve_api_type(self, dev_api: bool) -> None:
-        if dev_api is True or getenv("HONDANA_API_DEV"):
+        if dev_api or getenv("HONDANA_API_DEV"):
             Route.BASE = Route.DEV_BASE
             AuthRoute.BASE = AuthRoute.DEV_BASE
 
     async def _generate_session(self) -> aiohttp.ClientSession:
         """|coro|
 
         Creates an :class:`aiohttp.ClientSession` for use in the http client.
@@ -801,15 +802,15 @@
         order: FeedOrderQuery | None,
         includes: ChapterIncludes | None,
         include_empty_pages: bool | None,
         include_future_publish_at: bool | None,
         include_external_url: bool | None,
     ) -> Response[chapter.GetMultiChapterResponse]:
         if manga_id is None:
-            route = Route("GET", "/user/follows/manga/feed")
+            route = Route("GET", "/subscription/feed")
         else:
             route = Route("GET", "/manga/{manga_id}/feed", manga_id=manga_id)
 
         limit, offset = calculate_limits(limit, offset, max_limit=500)
 
         query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
 
@@ -1362,77 +1363,73 @@
         query: dict[str, Any] = {"email": email}
         return self.request(route, json=query)
 
     def get_my_details(self) -> Response[user.GetSingleUserResponse]:
         route = Route("GET", "/user/me")
         return self.request(route)
 
-    def follow_user(self, user_id: str) -> Response[DefaultResponseType]:
-        route = Route("POST", "/user/{user_id}/follow", user_id=user_id)
+    def bookmark_user(self, user_id: str) -> Response[DefaultResponseType]:
+        route = Route("POST", "/user/{user_id}/bookmark", user_id=user_id)
         return self.request(route)
 
-    def unfollow_user(self, user_id: str) -> Response[DefaultResponseType]:
-        route = Route("DELETE", "/user/{user_id}/follow", user_id=user_id)
+    def unbookmark_user(self, user_id: str) -> Response[DefaultResponseType]:
+        route = Route("DELETE", "/user/{user_id}/bookmark", user_id=user_id)
         return self.request(route)
 
-    def get_my_followed_groups(
+    def get_my_bookmarked_groups(
         self, *, limit: int, offset: int
     ) -> Response[scanlator_group.GetMultiScanlationGroupResponse]:
-        route = Route("GET", "/user/follows/group")
+        route = Route("GET", "/user/bookmarks/group")
 
         limit, offset = calculate_limits(limit, offset, max_limit=100)
 
         query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
         return self.request(route, params=query)
 
-    def is_group_followed(self, group_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("GET", "/user/follows/group/{group_id}", group_id=group_id)
+    def is_group_bookmarked(self, group_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("GET", "/user/bookmarks/group/{group_id}", group_id=group_id)
         return self.request(route)
 
-    def get_my_followed_users(self, *, limit: int, offset: int) -> Response[user.GetMultiUserResponse]:
-        route = Route("GET", "/user/follows/user")
+    def get_my_bookmarked_users(self, *, limit: int, offset: int) -> Response[user.GetMultiUserResponse]:
+        route = Route("GET", "/user/bookmarks/user")
 
         limit, offset = calculate_limits(limit, offset, max_limit=100)
 
         query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
 
         return self.request(route, params=query)
 
-    def is_user_followed(self, user_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("GET", "/user/follows/user/{user_id}", user_id=user_id)
+    def is_user_bookmarked(self, user_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("GET", "/user/bookmarks/user/{user_id}", user_id=user_id)
         return self.request(route)
 
-    def get_user_custom_list_follows(self, limit: int, offset: int) -> Response[custom_list.GetMultiCustomListResponse]:
-        route = Route("GET", "/user/follows/list")
+    def get_user_custom_list_bookmarks(self, limit: int, offset: int) -> Response[custom_list.GetMultiCustomListResponse]:
+        route = Route("GET", "/user/bookmarks/list")
 
         limit, offset = calculate_limits(limit, offset, max_limit=100)
         query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
 
         return self.request(route, params=query)
 
-    def is_custom_list_followed(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("GET", "/user/follows/list/{custom_list_id}", custom_list_id=custom_list_id)
+    def is_custom_list_bookmarked(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("GET", "/user/bookmarks/list/{custom_list_id}", custom_list_id=custom_list_id)
         return self.request(route)
 
     def get_user_followed_manga(
         self, limit: int, offset: int, includes: MangaIncludes | None
     ) -> Response[manga.MangaSearchResponse]:
         route = Route("GET", "/user/follows/manga")
 
         query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
 
         if includes:
             query["includes"] = includes.to_query()
 
         return self.request(route, params=query)
 
-    def is_manga_followed(self, manga_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("GET", "/user/follows/manga/{manga_id}", manga_id=manga_id)
-        return self.request(route)
-
     def create_account(self, *, username: str, password: str, email: str) -> Response[user.GetSingleUserResponse]:
         route = Route("POST", "/account/create")
         query: dict[str, Any] = {"username": username, "password": password, "email": email}
         return self.request(route, json=query)
 
     def activate_account(self, activation_code: str, /) -> Response[DefaultResponseType]:
         route = Route("POST", "/account/activate/{activation_code}", activation_code=activation_code)
@@ -1523,43 +1520,63 @@
 
         return self.request(route, json=query)
 
     def delete_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
         route = Route("DELETE", "/list/{custom_list_id}", custom_list_id=custom_list_id)
         return self.request(route)
 
-    def follow_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("POST", "/list/{custom_list_id}/follow", custom_list_id=custom_list_id)
+    def bookmark_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("POST", "/list/{custom_list_id}/bookmark", custom_list_id=custom_list_id)
         return self.request(route)
 
-    def unfollow_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("DELETE", "/list/{custom_list_id}/follow", custom_list_id=custom_list_id)
+    def unbookmark_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("DELETE", "/list/{custom_list_id}/bookmark", custom_list_id=custom_list_id)
         return self.request(route)
 
     def add_manga_to_custom_list(self, custom_list_id: str, /, *, manga_id: str) -> Response[DefaultResponseType]:
         route = Route("POST", "/manga/{manga_id}/list/{custom_list_id}", manga_id=manga_id, custom_list_id=custom_list_id)
         return self.request(route)
 
+    def batch_add_manga_to_custom_list(
+        self, custom_list_id: str, /, *, manga_ids: list[str]
+    ) -> Response[DefaultResponseType]:
+        route = Route("POST", "/list/{custom_list_id}/batch-manga", custom_list_id=custom_list_id)
+        return self.request(route, json={"mangaIds": manga_ids})
+
     def remove_manga_from_custom_list(self, custom_list_id: str, /, *, manga_id: str) -> Response[DefaultResponseType]:
         route = Route("DELETE", "/manga/{manga_id}/list/{custom_list_id}", manga_id=manga_id, custom_list_id=custom_list_id)
         return self.request(route)
 
-    def get_my_custom_lists(self, limit: int, offset: int) -> Response[custom_list.GetMultiCustomListResponse]:
+    def batch_remove_manga_from_custom_list(
+        self, custom_list_id: str, /, *, manga_ids: list[str]
+    ) -> Response[DefaultResponseType]:
+        route = Route("DELETE", "/list/{custom_list_id}/batch-manga", custom_list_id=custom_list_id)
+        return self.request(route, json={"mangaIds": manga_ids})
+
+    def get_my_custom_lists(self, limit: int, offset: int, pinned: bool) -> Response[custom_list.GetMultiCustomListResponse]:
         route = Route("GET", "/user/list")
 
-        query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
+        query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset, "pinned": pinned}
 
         return self.request(route, params=query)
 
+    def get_custom_lists_where_manga_is_present(self, manga_id: str) -> Response[list[str]]:
+        route = Route("GET", "/user/list/manga/{manga_id}", manga_id=manga_id)
+        return self.request(route)
+
+    def is_custom_list_subscribed(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("GET", "/user/subscription/{custom_list_id}", custom_list_id=custom_list_id)
+        return self.request(route)
+
     def get_users_custom_lists(
-        self, user_id: str, /, *, limit: int, offset: int
+        self, user_id: str, /, *, limit: int, offset: int, pinned: bool
     ) -> Response[custom_list.GetMultiCustomListResponse]:
         route = Route("GET", "/user/{user_id}/list", user_id=user_id)
 
-        query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
+        query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset, "pinned": pinned}
 
         return self.request(route, params=query)
 
     def custom_list_manga_feed(
         self,
         custom_list_id: str,
         /,
@@ -1782,20 +1799,20 @@
 
         return self.request(route, json=query)
 
     def delete_scanlation_group(self, scanlation_group_id: str, /) -> Response[DefaultResponseType]:
         route = Route("DELETE", "/group/{scanlation_group_id}", scanlation_group_id=scanlation_group_id)
         return self.request(route)
 
-    def follow_scanlation_group(self, scanlation_group_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("POST", "/group/{scanlation_group_id}/follow", scanlation_group_id=scanlation_group_id)
+    def bookmark_scanlation_group(self, scanlation_group_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("POST", "/group/{scanlation_group_id}/bookmark", scanlation_group_id=scanlation_group_id)
         return self.request(route)
 
-    def unfollow_scanlation_group(self, scanlation_group_id: str, /) -> Response[DefaultResponseType]:
-        route = Route("DELETE", "/group/{scanlation_group_id}/follow", scanlation_group_id=scanlation_group_id)
+    def unbookmark_scanlation_group(self, scanlation_group_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("DELETE", "/group/{scanlation_group_id}/bookmark", scanlation_group_id=scanlation_group_id)
         return self.request(route)
 
     def author_list(
         self,
         *,
         limit: int,
         offset: int,
@@ -2208,14 +2225,40 @@
     def create_forum_thread(self, thread_type: ForumThreadType, resource_id: str) -> Response[ForumPayloadResponse]:
         route = Route("POST", "/forums/thread")
 
         query: dict[str, str] = {"type": thread_type.value, "id": resource_id}
 
         return self.request(route, json=query)
 
+    def set_default_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("POST", "/list/{custom_list_id}/default", custom_list_id=custom_list_id)
+        return self.request(route)
+
+    def pin_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("POST", "/list/{custom_list_id}/pin", custom_list_id=custom_list_id)
+        return self.request(route)
+
+    def unpin_custom_list(self, custom_list_id: str, /) -> Response[DefaultResponseType]:
+        route = Route("POST", "/list/{custom_list_id}/unpin", custom_list_id=custom_list_id)
+        return self.request(route)
+
+    def get_subscription_list(
+        self, *, limit: int, offset: int, includes: SubscriptionIncludes | None
+    ) -> Response[custom_list.GetMultiCustomListResponse]:
+        route = Route("GET", "/subscription")
+
+        limit, offset = calculate_limits(limit, offset, max_limit=20)
+
+        query: MANGADEX_QUERY_PARAM_TYPE = {"limit": limit, "offset": offset}
+
+        if includes:
+            query["includes"] = includes.to_query()
+
+        return self.request(route, params=query)
+
     def check_approval_required(
         self, manga_id: str, locale: common.LanguageCode
     ) -> Response[upload.GetCheckApprovalRequired]:
         route = Route("POST", "/upload/check-approval-required")
 
         query: dict[str, Any] = {"manga": manga_id, "locale": locale}
```

## hondana/manga.py

```diff
@@ -1484,27 +1484,27 @@
 
     __slots__ = (
         "_http",
         "_data",
         "_rating",
         "_comments",
         "_cs_comments",
-        "follows",
+        "bookmarks",
         "parent_id",
         "average",
         "bayesian",
         "distribution",
     )
 
     def __init__(self, http: HTTPClient, parent_id: str, payload: MangaStatisticsResponse | BatchStatisticsResponse) -> None:
         self._http: HTTPClient = http
         self._data = payload
         self._rating = payload["rating"]
         self._comments: CommentMetaData | None = payload.get("comments")
-        self.follows: int = payload["follows"]
+        self.bookmarks: int = payload["bookmarks"]
         self.parent_id: str = parent_id
         self.average: float | None = self._rating["average"]
         self.bayesian: float | None = self._rating["bayesian"]
         self.distribution: dict[str, int] | None = self._rating.get("distribution")
 
     def __repr__(self) -> str:
         return f"<MangaStatistics for={self.parent_id!r}>"
```

## hondana/query.py

```diff
@@ -143,35 +143,39 @@
         Year ordering.
     created_at: :class:`~hondana.query.Order`
         Ordering by creation date.
     updated_at: :class:`~hondana.query.Order`
         Ordering by last updated date.
     latest_uploaded_chapter: :class:`~hondana.query.Order`
         Ordering by latest uploaded chapter.
+    subscribed_count: :class:`~hondana.query.Order`
+        Ordering by followed count.
     relevance: :class:`~hondana.query.Order`
         Ordering by relevance to search query.
     rating: :class:`~hondana.query.Order`
         Ordering by rating.
     """
 
     __slots__ = (
         "title",
         "year",
         "created_at",
         "updated_at",
         "latest_uploaded_chapter",
+        "subscribed_count",
         "relevance",
         "rating",
     )
 
     title: Order | None
     year: Order | None
     created_at: Order | None
     updated_at: Order | None
     latest_uploaded_chapter: Order | None
+    subscribed_count: Order | None
     relevance: Order | None
     rating: Order | None
 
     def __init__(self, **kwargs: Order) -> None:
         super().__init__(**kwargs)
 
 
@@ -275,32 +279,32 @@
     -----------
     name: :class:`~hondana.query.Order`
         Name ordering.
     created_at: :class:`~hondana.query.Order`
         Ordering by creation date.
     updated_at: :class:`~hondana.query.Order`
         Ordering by last updated date.
-    followed_count: :class:`~hondana.query.Order`
+    bookmarked_count: :class:`~hondana.query.Order`
         Ordering by followed count.
     relevance: :class:`~hondana.query.Order`
         Ordering by relevance to search query.
     """
 
     __slots__ = (
         "name",
         "created_at",
         "updated_at",
-        "followed_count",
+        "bookmarked_count",
         "relevance",
     )
 
     name: Order | None
     created_at: Order | None
     updated_at: Order | None
-    followed_count: Order | None
+    bookmarked_count: Order | None
     relevance: Order | None
 
     def __init__(self, **kwargs: Order) -> None:
         super().__init__(**kwargs)
 
 
 class AuthorListOrderQuery(_OrderQuery):
```

## hondana/scanlator_group.py

```diff
@@ -367,15 +367,15 @@
         This method will follow the current scanlation group.
 
         Raises
         -------
         :exc:`NotFound`
             The scanlation group cannot be found, likely due to an incorrect ID.
         """
-        await self._http.follow_scanlation_group(self.id)
+        await self._http.bookmark_scanlation_group(self.id)
 
     bookmark = follow
 
     @require_authentication
     @deprecated("unbookmark")
     async def unfollow(self) -> None:
         """|coro|
@@ -383,15 +383,15 @@
         This method will unfollow the current scanlation group.
 
         Raises
         -------
         :exc:`NotFound`
             The scanlation group cannot be found, likely due to an incorrect ID.
         """
-        await self._http.unfollow_scanlation_group(self.id)
+        await self._http.unbookmark_scanlation_group(self.id)
 
     unbookmark = unfollow
 
     @require_authentication
     async def update(
         self,
         *,
```

## hondana/types_/statistics.py

```diff
@@ -65,31 +65,31 @@
     bayesian: float
 
 
 class MangaStatisticsResponse(TypedDict):
     """
     rating: :class:`~hondana.types_.statistics.StatisticsRatingResponse`
 
-    follows: :class:`int`
+    bookmarks: :class:`int`
     """
 
     comments: CommentMetaData | None
     rating: StatisticsRatingResponse
-    follows: int
+    bookmarks: int
 
 
 class BatchStatisticsResponse(TypedDict):
     """
     rating: :class:`~hondana.types_.statistics.BatchStatisticsRatingResponse`
 
-    follows: :class:`int`
+    bookmarks: :class:`int`
     """
 
     rating: BatchStatisticsRatingResponse
-    follows: int
+    bookmarks: int
 
 
 class GetMangaStatisticsResponse(TypedDict):
     """
     result: Literal[``"ok"``]
 
     statistics: Dict[:class:`str`, :class:`~hondana.types_.statistics.StatisticsRatingResponse`]
```

## Comparing `hondana-3.5.1.dist-info/LICENSE` & `hondana-4.0.0a0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `hondana-3.5.1.dist-info/METADATA` & `hondana-4.0.0a0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: Hondana
-Version: 3.5.1
+Version: 4.0.0a0
 Summary: An asynchronous wrapper around the MangaDex v5 API
 Home-page: https://github.com/AbstractUmbra/hondana
 License: MIT
 Keywords: mangadex,manga,api,wrapper
 Author: Alex Nrgaard
 Author-email: umbra@abstractumbra.dev
 Requires-Python: >=3.11,<4.0
@@ -17,14 +17,15 @@
 Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: Internet
 Classifier: Typing :: Typed
 Provides-Extra: speed
 Requires-Dist: aiohttp (>=3.9,<4.0) ; extra == "speed"
 Requires-Dist: aiohttp[speedups] (>=3.9,<4.0) ; extra == "speed"
 Requires-Dist: orjson ; extra == "speed"
+Requires-Dist: typing-extensions
 Project-URL: Discord, https://discord.gg/aYGYJxwqe5
 Project-URL: Issue Tracker, https://github.com/AbstractUmbra/hondana/issues
 Project-URL: Repository, https://github.com/AbstractUmbra/hondana
 Description-Content-Type: text/markdown
 
 <div align="center">
     <h1 align="center">
```

### html2text {}

```diff
@@ -1,22 +1,22 @@
-Metadata-Version: 2.1 Name: Hondana Version: 3.5.1 Summary: An asynchronous
+Metadata-Version: 2.1 Name: Hondana Version: 4.0.0a0 Summary: An asynchronous
 wrapper around the MangaDex v5 API Home-page: https://github.com/AbstractUmbra/
 hondana License: MIT Keywords: mangadex,manga,api,wrapper Author: Alex
 Nrgaard Author-email: umbra@abstractumbra.dev Requires-Python: >=3.11,<4.0
 Classifier: Intended Audience :: Developers Classifier: License :: OSI Approved
 :: MIT License Classifier: Natural Language :: English Classifier: Operating
 System :: OS Independent Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.11 Classifier: Programming
 Language :: Python :: 3.12 Classifier: Topic :: Internet Classifier: Typing ::
 Typed Provides-Extra: speed Requires-Dist: aiohttp (>=3.9,<4.0) ; extra ==
 "speed" Requires-Dist: aiohttp[speedups] (>=3.9,<4.0) ; extra == "speed"
-Requires-Dist: orjson ; extra == "speed" Project-URL: Discord, https://
-discord.gg/aYGYJxwqe5 Project-URL: Issue Tracker, https://github.com/
-AbstractUmbra/hondana/issues Project-URL: Repository, https://github.com/
-AbstractUmbra/hondana Description-Content-Type: text/markdown
+Requires-Dist: orjson ; extra == "speed" Requires-Dist: typing-extensions
+Project-URL: Discord, https://discord.gg/aYGYJxwqe5 Project-URL: Issue Tracker,
+https://github.com/AbstractUmbra/hondana/issues Project-URL: Repository, https:
+//github.com/AbstractUmbra/hondana Description-Content-Type: text/markdown
                           ************ _HH_oo_nn_dd_aa_nn_aa_ _?_?_?_?_?_?_?_?_?_?_?_?
                         [[..ggiitthhuubb//aasssseettss//mmdd..ssvvgg]] ************
                    _[_B_u_i_l_d_ _s_t_a_t_u_s_]_[_L_i_n_t_i_n_g_ _a_n_d_ _T_y_p_e_c_h_e_c_k_i_n_g_]
               _[_A_P_I_ _S_t_a_t_u_s_]_[_D_o_c_u_m_e_n_t_a_t_i_o_n_ _S_t_a_t_u_s_]_[_D_i_s_c_o_r_d_ _S_e_r_v_e_r_]
 
 A lightweight and asynchronous wrapper around the [MangaDex v5 API](https://
 api.mangadex.org/docs.html). You can see our stable docs [here](https://
```

## Comparing `hondana-3.5.1.dist-info/RECORD` & `hondana-4.0.0a0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 LICENSE,sha256=fJjjpWNu05MN7HziRDaJAsLNwUH0O6xpOc8Vyq89jlg,1061
-hondana/__init__.py,sha256=g4D2eZ9r4Oy5QcAIxnO0aXAzheTZpzEGQ7oevvQ83Rw,2213
+hondana/__init__.py,sha256=Wg-ckaC3kgWlQVFbb1Ez1ix8TfKR-MhIWGAWkpLtk6s,2214
 hondana/__main__.py,sha256=3fiIFHRyWo9o15AYdeuqe3bpOzMCiDHwFrw86Pi4MBQ,2624
 hondana/artist.py,sha256=E7qI5ywNqfM31DXQOIMEYJjrFmnG5w0TwagcJfWPwPo,12908
 hondana/author.py,sha256=kyKnt7pRxq0GNfIsovf_vBGzv9YHXpeAU942DKo61b0,12885
 hondana/chapter.py,sha256=jgedLUiMIy8dCpVeJKlPQZh7_VIBVk6ydtM8iohBPLk,40695
-hondana/client.py,sha256=D7qJHrk-OnvDR17EXjwri_KOIwKN7_RLbGCkFuR9gVo,140994
+hondana/client.py,sha256=0ZHM-Dvbu35UOpGxnNLjNFaKWL9LX0pZ5M9mNaUL-dc,146208
 hondana/collections.py,sha256=3DyM48T5EZTVsDYEbXaH8SZwhczcD0YsJc15E4kdkNw,22211
 hondana/cover.py,sha256=Nitzl894rXtGNv-HnTr2KvkJj12D16dQrfWHZG6J9IU,8416
-hondana/custom_list.py,sha256=RVinx_wp1W9TEsuACcmQZfVdxwCjS-K41HVsZ17caO8,10481
+hondana/custom_list.py,sha256=yCWZgZyZrlWVVXIK9CE-yHgj1Vk_CRxvlD5eqkZyhak,11059
 hondana/enums.py,sha256=0wMEitXmuJ_pahgktFpNC_p4MlcqEXeDVrrB8rt9FJc,6904
 hondana/errors.py,sha256=g4teHQq01BQaTcsXS4KRFZxRZVa2m6YmMrCJU9P6V2k,8405
-hondana/extras/report_reasons.json,sha256=OTYNR72zSnPBrgw74xdqYOWCMpQVSLc3mzxnqnDw_oQ,2933
-hondana/extras/tags.json,sha256=0quMvWPTjTrylgspMmpqaqethsb0yBL2AQk9NRbCPlQ,4324
+hondana/extras/report_reasons.json,sha256=ydi4-m8wrBGCOJ4lJjNYV9JIk0ErBieEoDhZS_U4E4w,2933
+hondana/extras/tags.json,sha256=2mLD-x7GKIiTLc8Kh6Gz1rSO5hxV26Hmk_hVLeQVKj4,4322
 hondana/forums.py,sha256=mAGfUZzHYU49QUubCg7ig2x-mcZhjl03O36kuQ-rce8,5220
-hondana/http.py,sha256=miqi57nTzsf1rz4wEXLBivx6JxlUkZpfQ4yIOfTyoGM,75936
+hondana/http.py,sha256=8Vb-DxBz-l_q-bEMzee3SngA87j2QEnZff7kgPVmSVg,78044
 hondana/legacy.py,sha256=4oRvt5bclj7StIfkS6KleSSK3jqeCQTTxxIVdykuHHM,2764
-hondana/manga.py,sha256=2wSHN_-vnEQLMDZ4X661_gtzhs9VV-78TPk4t8GN0sA,56864
+hondana/manga.py,sha256=9rxe54MKeG_0C8hvea0mnUXHXZdKcCfckvfajE4zsl0,56870
 hondana/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-hondana/query.py,sha256=Pr3deFdvxToU8_wLNKX-QCQRNjRLHlWbAKK-DQUNM3g,16683
+hondana/query.py,sha256=Stp5AHJVq3bv410FJLeVzX7nUEn5fwVROQH1qUiHV8o,16840
 hondana/relationship.py,sha256=Bpl81f1hWKNHPYTtTYfBWJ9y3xUXgrbWF9ZWimLvFxQ,2381
 hondana/report.py,sha256=JSAvDCA6jeYg_oRb-xU_d4vjhqnfuUTlgbwC_xEIGmw,6939
-hondana/scanlator_group.py,sha256=qf1PZhGc725z0ffEfDWLew-zVIOXFf6YC0ly-LfR-10,18535
+hondana/scanlator_group.py,sha256=Rw-EM626arT4FMSbvtKyMq7OazvHNvm5lGVU7Hx50E0,18539
 hondana/tags.py,sha256=Ec_gVmJY6sQjKhkiUYPqPA4NdOrh5j-irHnjoZghTok,6476
 hondana/types_/account.py,sha256=NtDBq-3V-3GsThlsjx3c9afPwy0981T5BKIUszz6VBU,1304
 hondana/types_/artist.py,sha256=OVsyYCV29NRlmHqt443dxtx-9VL0JQdQYWjO3kVhwMw,4144
 hondana/types_/auth.py,sha256=W9BRXXO_pMGdk6fZEg7zQJLVSb1Di3Ku54_8rRenw1A,2155
 hondana/types_/author.py,sha256=HpEv5YQ5sSXj3-l_vkZyjA-PN8VbAoEQoUMsC_kSzQ8,4147
 hondana/types_/chapter.py,sha256=XrEPyRJtmldWS3pLMVXviy2j5hoDL1eHr8LpHub35jI,4697
 hondana/types_/common.py,sha256=kBbBxO1V6b2D38SihTuMAOp1GGO1oUziBxULmVBaQx8,2790
@@ -34,19 +34,19 @@
 hondana/types_/forums.py,sha256=yWgtQR1Wzaq-iwXgNfB9KNORM2AtpklahFOLd0wus3s,1483
 hondana/types_/legacy.py,sha256=74K1Bc0eSdTj6mAz-Xf20zmF-5v7VI3DQHp9l3JFL3A,2490
 hondana/types_/manga.py,sha256=v9PT857v70gM47sSCV2ZKfDQqK_8ONvy6BQ1T33kAz0,9865
 hondana/types_/relationship.py,sha256=6bf_DdfEnySfjPPvplVoPDonvIvt_m64WbcwsM90gcI,2124
 hondana/types_/report.py,sha256=yKcQTLRKMoyF0g09Ua0AER38VYOSVkc8xfxVpwYE5Q8,3816
 hondana/types_/scanlator_group.py,sha256=fdj-7_UPDAQZtk-ta3evCiz1HD7sIUHtNXSRnG_sHBI,4298
 hondana/types_/settings.py,sha256=0bCqJCjlPkbKm6BsJqOlYDwG9EOUjksuiaycMvwhNxY,1690
-hondana/types_/statistics.py,sha256=9mpEUNRX7S6t-MAcKKekviq1MsCyJNWayHCdoMMTclg,4014
+hondana/types_/statistics.py,sha256=A07iY3172NmlpOkZ1xoX2OsaJHeSnWcd6XQhz8q5KQU,4022
 hondana/types_/tags.py,sha256=oPpl8hlwOvxwG8bIY2KJOvK5xaNzZadntmt-MKkSLnI,2710
 hondana/types_/token.py,sha256=Y2OzEqR73A8tbQKM-Xx6JDQGlHd7fNEiSj8PU8oW1g4,3537
 hondana/types_/upload.py,sha256=8MDeoc9WKynPmp16B3u3WoUH2tSwt1JjtaVWY-zEC7c,4714
 hondana/types_/user.py,sha256=h8m7LytBufk8RjEoF39kwOyRskziaL1M5_QYCvcjoWs,3138
 hondana/user.py,sha256=l1d8uhc8TNchqzei4EBhPSjdX4JPN1STakzqXCy6ow8,6774
 hondana/utils.py,sha256=UMMXNXoh_BGmCIFdbHVI_kXZWpfBTK_T-ZXVLodJ28o,19571
-hondana-3.5.1.dist-info/LICENSE,sha256=fJjjpWNu05MN7HziRDaJAsLNwUH0O6xpOc8Vyq89jlg,1061
-hondana-3.5.1.dist-info/METADATA,sha256=huV5UPFZbwUSwg5qQW0Ae1po8yAVg-jv4FOoi8RkFHo,6318
-hondana-3.5.1.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-hondana-3.5.1.dist-info/entry_points.txt,sha256=dKooTEkZ35IkTnGpnrUf_0kCWKLDbGgVCMZmMSHF3s4,57
-hondana-3.5.1.dist-info/RECORD,,
+hondana-4.0.0a0.dist-info/LICENSE,sha256=fJjjpWNu05MN7HziRDaJAsLNwUH0O6xpOc8Vyq89jlg,1061
+hondana-4.0.0a0.dist-info/METADATA,sha256=dkMoG7qNw7umHpBdhV-7sjvhfzMewgfa8L7R8H4vE-c,6353
+hondana-4.0.0a0.dist-info/WHEEL,sha256=FMvqSimYX_P7y0a7UY-_Mc83r5zkBZsCYPm7Lr0Bsq4,88
+hondana-4.0.0a0.dist-info/entry_points.txt,sha256=dKooTEkZ35IkTnGpnrUf_0kCWKLDbGgVCMZmMSHF3s4,57
+hondana-4.0.0a0.dist-info/RECORD,,
```

