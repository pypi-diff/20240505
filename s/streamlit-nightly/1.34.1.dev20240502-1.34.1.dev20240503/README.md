# Comparing `tmp/streamlit_nightly-1.34.1.dev20240502.tar.gz` & `tmp/streamlit_nightly-1.34.1.dev20240503.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "streamlit_nightly-1.34.1.dev20240502.tar", last modified: Fri May  3 06:55:01 2024, max compression
+gzip compressed data, was "streamlit_nightly-1.34.1.dev20240503.tar", last modified: Sat May  4 06:53:14 2024, max compression
```

## Comparing `streamlit_nightly-1.34.1.dev20240502.tar` & `streamlit_nightly-1.34.1.dev20240503.tar`

### file list

```diff
@@ -1,574 +1,573 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.749687 streamlit_nightly-1.34.1.dev20240502/
--rw-r--r--   0 runner    (1001) docker     (127)      100 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (127)     8500 2024-05-03 06:55:01.749687 streamlit_nightly-1.34.1.dev20240502/PKG-INFO
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.617688 streamlit_nightly-1.34.1.dev20240502/bin/
--rw-r--r--   0 runner    (1001) docker     (127)      676 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/bin/streamlit.cmd
--rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-03 06:55:01.749687 streamlit_nightly-1.34.1.dev20240502/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)     6787 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.625688 streamlit_nightly-1.34.1.dev20240502/streamlit/
--rw-r--r--   0 runner    (1001) docker     (127)     8101 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      868 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/__main__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2468 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/case_converters.py
--rw-r--r--   0 runner    (1001) docker     (127)     1407 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/cli_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     2395 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/code_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     9330 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/color_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1414 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/column_config.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.625688 streamlit_nightly-1.34.1.dev20240502/streamlit/commands/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/commands/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5429 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/commands/execution_control.py
--rw-r--r--   0 runner    (1001) docker     (127)     5042 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/commands/experimental_query_params.py
--rw-r--r--   0 runner    (1001) docker     (127)    12997 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/commands/page_config.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.625688 streamlit_nightly-1.34.1.dev20240502/streamlit/components/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.625688 streamlit_nightly-1.34.1.dev20240502/streamlit/components/lib/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/lib/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2978 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/lib/local_component_registry.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.625688 streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3100 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/base_component_registry.py
--rw-r--r--   0 runner    (1001) docker     (127)     3829 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/base_custom_component.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.625688 streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/
--rw-r--r--   0 runner    (1001) docker     (127)     1027 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4125 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/component_arrow.py
--rw-r--r--   0 runner    (1001) docker     (127)     3773 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/component_registry.py
--rw-r--r--   0 runner    (1001) docker     (127)     1274 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/components.py
--rw-r--r--   0 runner    (1001) docker     (127)     9170 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/custom_component.py
--rw-r--r--   0 runner    (1001) docker     (127)    43895 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/config.py
--rw-r--r--   0 runner    (1001) docker     (127)    11469 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/config_option.py
--rw-r--r--   0 runner    (1001) docker     (127)     6015 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/config_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.629688 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/
--rw-r--r--   0 runner    (1001) docker     (127)     1083 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7465 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/base_connection.py
--rw-r--r--   0 runner    (1001) docker     (127)    12517 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/snowflake_connection.py
--rw-r--r--   0 runner    (1001) docker     (127)     8184 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/snowpark_connection.py
--rw-r--r--   0 runner    (1001) docker     (127)    12234 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/sql_connection.py
--rw-r--r--   0 runner    (1001) docker     (127)     3022 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/connections/util.py
--rw-r--r--   0 runner    (1001) docker     (127)      798 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/constants.py
--rw-r--r--   0 runner    (1001) docker     (127)     6001 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/cursor.py
--rw-r--r--   0 runner    (1001) docker     (127)    33936 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/delta_generator.py
--rw-r--r--   0 runner    (1001) docker     (127)     6516 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/deprecation_util.py
--rw-r--r--   0 runner    (1001) docker     (127)      813 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/development.py
--rw-r--r--   0 runner    (1001) docker     (127)     4077 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/echo.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.633688 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7432 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/alert.py
--rw-r--r--   0 runner    (1001) docker     (127)     1222 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/altair_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    14558 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/arrow.py
--rw-r--r--   0 runner    (1001) docker     (127)    57049 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/arrow_altair.py
--rw-r--r--   0 runner    (1001) docker     (127)     7579 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/arrow_vega_lite.py
--rw-r--r--   0 runner    (1001) docker     (127)     1482 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/balloons.py
--rw-r--r--   0 runner    (1001) docker     (127)     3916 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/bokeh_chart.py
--rw-r--r--   0 runner    (1001) docker     (127)     2476 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/code.py
--rw-r--r--   0 runner    (1001) docker     (127)     6429 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/deck_gl_json_chart.py
--rw-r--r--   0 runner    (1001) docker     (127)     8039 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/dialog_decorator.py
--rw-r--r--   0 runner    (1001) docker     (127)    16168 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/doc_string.py
--rw-r--r--   0 runner    (1001) docker     (127)     3824 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/empty.py
--rw-r--r--   0 runner    (1001) docker     (127)     9121 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/exception.py
--rw-r--r--   0 runner    (1001) docker     (127)    12072 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/form.py
--rw-r--r--   0 runner    (1001) docker     (127)     4557 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/graphviz_chart.py
--rw-r--r--   0 runner    (1001) docker     (127)    11268 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/heading.py
--rw-r--r--   0 runner    (1001) docker     (127)     2810 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/html.py
--rw-r--r--   0 runner    (1001) docker     (127)     4383 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/iframe.py
--rw-r--r--   0 runner    (1001) docker     (127)    20394 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/image.py
--rw-r--r--   0 runner    (1001) docker     (127)     3365 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/json.py
--rw-r--r--   0 runner    (1001) docker     (127)    28251 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/layouts.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.637688 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    17226 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/column_config_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    51174 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/column_types.py
--rw-r--r--   0 runner    (1001) docker     (127)     5685 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/dialog.py
--rw-r--r--   0 runner    (1001) docker     (127)     3839 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/dicttools.py
--rw-r--r--   0 runner    (1001) docker     (127)     1496 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/event_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     6634 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/mutable_status_container.py
--rw-r--r--   0 runner    (1001) docker     (127)     8079 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/pandas_styler_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     8307 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/streamlit_plotly_theme.py
--rw-r--r--   0 runner    (1001) docker     (127)     6246 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/subtitle_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    16299 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/map.py
--rw-r--r--   0 runner    (1001) docker     (127)    10384 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/markdown.py
--rw-r--r--   0 runner    (1001) docker     (127)    29678 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/media.py
--rw-r--r--   0 runner    (1001) docker     (127)    10114 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/metric.py
--rw-r--r--   0 runner    (1001) docker     (127)    15332 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/plotly_chart.py
--rw-r--r--   0 runner    (1001) docker     (127)     5844 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/progress.py
--rw-r--r--   0 runner    (1001) docker     (127)     6441 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/pyplot.py
--rw-r--r--   0 runner    (1001) docker     (127)     1439 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/snow.py
--rw-r--r--   0 runner    (1001) docker     (127)     2934 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/spinner.py
--rw-r--r--   0 runner    (1001) docker     (127)     1856 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/text.py
--rw-r--r--   0 runner    (1001) docker     (127)     4336 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/toast.py
--rw-r--r--   0 runner    (1001) docker     (127)     8458 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.641687 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    32277 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/button.py
--rw-r--r--   0 runner    (1001) docker     (127)     9141 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/camera_input.py
--rw-r--r--   0 runner    (1001) docker     (127)    14320 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/chat.py
--rw-r--r--   0 runner    (1001) docker     (127)    12573 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/checkbox.py
--rw-r--r--   0 runner    (1001) docker     (127)     9142 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/color_picker.py
--rw-r--r--   0 runner    (1001) docker     (127)    35827 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/data_editor.py
--rw-r--r--   0 runner    (1001) docker     (127)    17656 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/file_uploader.py
--rw-r--r--   0 runner    (1001) docker     (127)    13752 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/multiselect.py
--rw-r--r--   0 runner    (1001) docker     (127)    18036 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/number_input.py
--rw-r--r--   0 runner    (1001) docker     (127)    12824 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/radio.py
--rw-r--r--   0 runner    (1001) docker     (127)    13442 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/select_slider.py
--rw-r--r--   0 runner    (1001) docker     (127)    11665 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/selectbox.py
--rw-r--r--   0 runner    (1001) docker     (127)    26661 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/slider.py
--rw-r--r--   0 runner    (1001) docker     (127)    22333 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/text_widgets.py
--rw-r--r--   0 runner    (1001) docker     (127)    30042 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/time_widgets.py
--rw-r--r--   0 runner    (1001) docker     (127)    20804 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/elements/write.py
--rw-r--r--   0 runner    (1001) docker     (127)    73749 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/emojis.py
--rw-r--r--   0 runner    (1001) docker     (127)     1791 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/env_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/error_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     4017 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/errors.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.641687 streamlit_nightly-1.34.1.dev20240502/streamlit/external/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/external/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.641687 streamlit_nightly-1.34.1.dev20240502/streamlit/external/langchain/
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/external/langchain/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15280 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/external/langchain/streamlit_callback_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     7216 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/file_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     2342 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/folder_black_list.py
--rw-r--r--   0 runner    (1001) docker     (127)     5271 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/git_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.641687 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/
--rw-r--r--   0 runner    (1001) docker     (127)     1671 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/Hello.py
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.641687 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/
--rw-r--r--   0 runner    (1001) docker     (127)     2956 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/0_Animation_Demo.py
--rw-r--r--   0 runner    (1001) docker     (127)     1743 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/1_Plotting_Demo.py
--rw-r--r--   0 runner    (1001) docker     (127)     3826 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/2_Mapping_Demo.py
--rw-r--r--   0 runner    (1001) docker     (127)     2527 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/3_DataFrame_Demo.py
--rw-r--r--   0 runner    (1001) docker     (127)      992 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/hello/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     3524 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/js_number.py
--rw-r--r--   0 runner    (1001) docker     (127)     3990 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/logger.py
--rw-r--r--   0 runner    (1001) docker     (127)    57136 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/material_icon_names.py
--rw-r--r--   0 runner    (1001) docker     (127)     3280 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/net_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1104 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/platform.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.669687 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/
--rw-r--r--   0 runner    (1001) docker     (127)     1439 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Alert_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3116 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Alert_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1208 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AppPage_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1971 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AppPage_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1410 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowNamedDataSet_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2051 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowNamedDataSet_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1710 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowVegaLiteChart_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2898 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowVegaLiteChart_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1996 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Arrow_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     5904 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Arrow_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1390 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Audio_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2172 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Audio_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1032 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AutoRerun_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1560 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AutoRerun_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2090 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BackMsg_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     5251 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BackMsg_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1175 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Balloons_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1401 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Balloons_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     4193 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Block_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)    12049 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Block_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1235 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BokehChart_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1830 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BokehChart_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1456 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Button_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2552 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Button_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1551 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/CameraInput_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2279 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/CameraInput_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1583 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ChatInput_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2927 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ChatInput_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1870 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Checkbox_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3504 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Checkbox_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1485 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ClientState_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2226 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ClientState_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1187 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Code_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1678 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Code_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1664 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ColorPicker_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2656 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ColorPicker_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     3195 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Common_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     9670 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Common_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2421 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Components_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     6589 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Components_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     4394 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DataFrame_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)    15040 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DataFrame_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1790 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DateInput_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3438 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DateInput_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1358 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DeckGlJsonChart_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2281 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DeckGlJsonChart_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1910 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Delta_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3313 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Delta_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1609 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DocString_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3514 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DocString_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1498 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DownloadButton_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2328 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DownloadButton_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)    10146 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Element_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)    16972 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Element_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1070 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Empty_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)      996 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Empty_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1308 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Exception_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2784 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Exception_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1132 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Favicon_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1301 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Favicon_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1707 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/FileUploader_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3209 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/FileUploader_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     4770 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ForwardMsg_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)    12046 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ForwardMsg_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1574 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GitInfo_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3269 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GitInfo_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1338 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GraphVizChart_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2015 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GraphVizChart_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1311 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Heading_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1944 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Heading_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1096 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Html_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1316 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Html_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1323 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/IFrame_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2275 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/IFrame_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1383 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Image_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2641 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Image_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1139 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Json_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1459 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Json_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1550 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LabelVisibilityMessage_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2779 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LabelVisibilityMessage_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1330 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LinkButton_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1964 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LinkButton_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1585 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Markdown_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3205 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Markdown_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1979 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Metric_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     4041 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Metric_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1784 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/MultiSelect_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3542 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/MultiSelect_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1378 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NamedDataSet_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2123 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NamedDataSet_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     5205 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NewSession_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)    18437 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NewSession_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2359 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NumberInput_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     5182 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NumberInput_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageConfig_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     5480 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageConfig_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1130 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageInfo_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1464 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageInfo_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1462 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageLink_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2679 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageLink_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1159 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageNotFound_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1429 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageNotFound_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1958 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageProfile_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     4825 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageProfile_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1295 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PagesChanged_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1704 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PagesChanged_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1164 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ParentMessage_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1616 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ParentMessage_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1937 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PlotlyChart_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     5103 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PlotlyChart_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1156 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Progress_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1424 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Progress_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1802 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Radio_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3843 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Radio_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1245 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/RootContainer_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2093 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/RootContainer_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1793 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Selectbox_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Selectbox_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1469 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionEvent_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2935 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionEvent_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1226 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionStatus_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2252 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionStatus_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1402 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Skeleton_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2713 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Skeleton_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2349 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Slider_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     6044 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Slider_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1098 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Snow_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1389 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Snow_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1165 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Spinner_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1535 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Spinner_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1815 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextArea_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3529 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextArea_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2056 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextInput_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     4564 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextInput_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1128 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Text_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1466 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Text_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1750 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TimeInput_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3242 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TimeInput_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1135 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Toast_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1452 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Toast_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1617 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/VegaLiteChart_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2829 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/VegaLiteChart_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1864 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Video_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     4327 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Video_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     2352 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/WidgetStates_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)     6240 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/WidgetStates_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)      668 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5938 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/openmetrics_data_model_pb2.py
--rw-r--r--   0 runner    (1001) docker     (127)    20476 2024-05-03 06:51:17.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/proto/openmetrics_data_model_pb2.pyi
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/py.typed
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.673688 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/
--rw-r--r--   0 runner    (1001) docker     (127)     1523 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    36802 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/app_session.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.673688 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/
--rw-r--r--   0 runner    (1001) docker     (127)     4370 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    26393 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_data_api.py
--rw-r--r--   0 runner    (1001) docker     (127)     4730 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_errors.py
--rw-r--r--   0 runner    (1001) docker     (127)    21616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_resource_api.py
--rw-r--r--   0 runner    (1001) docker     (127)     1131 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_type.py
--rw-r--r--   0 runner    (1001) docker     (127)    18329 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    17358 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cached_message_replay.py
--rw-r--r--   0 runner    (1001) docker     (127)    18986 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/hashing.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.677688 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/
--rw-r--r--   0 runner    (1001) docker     (127)      965 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8922 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/cache_storage_protocol.py
--rw-r--r--   0 runner    (1001) docker     (127)     1945 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/dummy_cache_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     5389 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py
--rw-r--r--   0 runner    (1001) docker     (127)     9311 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/local_disk_cache_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)    12414 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/connection_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    11500 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/credentials.py
--rw-r--r--   0 runner    (1001) docker     (127)     9805 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/forward_msg_cache.py
--rw-r--r--   0 runner    (1001) docker     (127)     5550 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/forward_msg_queue.py
--rw-r--r--   0 runner    (1001) docker     (127)    11558 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/fragment.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.677688 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/
--rw-r--r--   0 runner    (1001) docker     (127)      759 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    27873 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/caching.py
--rw-r--r--   0 runner    (1001) docker     (127)    35033 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/hashing.py
--rw-r--r--   0 runner    (1001) docker     (127)     8510 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/media_file_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     4375 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/media_file_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     6331 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/memory_media_file_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     2940 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/memory_session_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     4422 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/memory_uploaded_file_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)    14265 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/metrics_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    29567 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/runtime.py
--rw-r--r--   0 runner    (1001) docker     (127)     4192 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/runtime_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1749 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/script_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.677688 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/
--rw-r--r--   0 runner    (1001) docker     (127)     1159 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9116 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/magic.py
--rw-r--r--   0 runner    (1001) docker     (127)     1056 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/magic_funcs.py
--rw-r--r--   0 runner    (1001) docker     (127)     2856 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_cache.py
--rw-r--r--   0 runner    (1001) docker     (127)     8027 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_requests.py
--rw-r--r--   0 runner    (1001) docker     (127)     8818 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_run_context.py
--rw-r--r--   0 runner    (1001) docker     (127)    29911 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_runner.py
--rw-r--r--   0 runner    (1001) docker     (127)    12302 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/secrets.py
--rw-r--r--   0 runner    (1001) docker     (127)    13017 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/session_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.677688 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/
--rw-r--r--   0 runner    (1001) docker     (127)     1528 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8065 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/common.py
--rw-r--r--   0 runner    (1001) docker     (127)     7397 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/query_params.py
--rw-r--r--   0 runner    (1001) docker     (127)     7070 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/query_params_proxy.py
--rw-r--r--   0 runner    (1001) docker     (127)     5169 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/safe_session_state.py
--rw-r--r--   0 runner    (1001) docker     (127)    27500 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/session_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     5119 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/session_state_proxy.py
--rw-r--r--   0 runner    (1001) docker     (127)    11263 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/widgets.py
--rw-r--r--   0 runner    (1001) docker     (127)     3807 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/stats.py
--rw-r--r--   0 runner    (1001) docker     (127)     4784 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/uploaded_file_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     6443 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/websocket_session_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     5749 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/source_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.681687 streamlit_nightly-1.34.1.dev20240502/streamlit/static/
--rw-r--r--   0 runner    (1001) docker     (127)    14501 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/asset-manifest.json
--rw-r--r--   0 runner    (1001) docker     (127)     1019 2024-05-03 06:51:45.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/favicon.png
--rw-r--r--   0 runner    (1001) docker     (127)      891 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/index.html
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.613688 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.681687 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/
--rw-r--r--   0 runner    (1001) docker     (127)    12090 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/3092.95a45cfe.chunk.css
--rw-r--r--   0 runner    (1001) docker     (127)    33275 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/3466.8b8f33d6.chunk.css
--rw-r--r--   0 runner    (1001) docker     (127)     2633 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/43.e3b876c5.chunk.css
--rw-r--r--   0 runner    (1001) docker     (127)    29246 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/main.3aaaea00.css
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.721687 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/
--rw-r--r--   0 runner    (1001) docker     (127)     5446 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1074.73973756.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    11471 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1168.fc5c673b.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1524 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1307.8ea033f1.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     5024 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1451.3b0a3e31.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     9618 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1479.6709db03.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     2249 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/178.7bea8c5d.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      740 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1792.b8efa879.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    32468 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2187.9469f035.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     3396 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2469.3e9c3ce9.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      789 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2634.1249dc7a.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)  3636801 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2736.914069e5.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     2051 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2736.914069e5.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)     3259 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3053.7e70ec3b.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    32270 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3061.67758376.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    43574 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3092.bc07c48b.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1931 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3301.1d1b10bb.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)  2306325 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3466.05d62820.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1219 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3466.05d62820.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)      929 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3513.e3e7300a.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     5288 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3631.be5c35fa.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     2559 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4113.1e7eff4d.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     9226 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4132.49bf3f2c.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      479 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4132.49bf3f2c.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)     2178 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4177.69f9f18d.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)   395952 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4253.749d5244.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      281 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4253.749d5244.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)     8717 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/43.c6749504.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     2412 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4319.bf1c86bf.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    20661 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4477.e10e4373.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      587 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4500.b6f348d1.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    14830 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4666.c4b22a63.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     4800 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/474.87506447.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     7161 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5106.44f0ff51.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    21681 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5117.04bfe5d3.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     8252 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5345.65c91ee7.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    10874 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5379.6571574f.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)   107585 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5791.9a42fb4b.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    11420 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6013.64cd6d28.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)  2262785 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6150.427a30f5.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    13239 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6405.ac5a6f23.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)   825783 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/656.7150a933.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      212 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/656.7150a933.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)    24494 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6718.802da17e.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1371 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6853.3cbd385e.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    88545 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7142.83028745.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     9607 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7175.be4076bc.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    65522 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7217.d970c074.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)  3383788 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7323.2808d029.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     5061 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7323.2808d029.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)    13275 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7602.e8abc06b.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1069 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7805.51638fbc.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     3358 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8005.43974a35.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     3113 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8427.65ddaf36.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1888 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8477.7419a0aa.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    15492 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8492.3e609489.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     6699 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8536.f13dff49.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    12214 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8570.6de19120.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    10471 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8691.9ccf7f89.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     1361 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9330.2b4c99e0.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    13482 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9336.2d95d840.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)    20791 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/937.a1248039.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)      188 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/937.a1248039.chunk.js.LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (127)    22113 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9656.8c935274.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     2119 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9758.6e6d8662.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)     4011 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9865.fd93213d.chunk.js
--rw-r--r--   0 runner    (1001) docker     (127)  4402089 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/main.af77b7ba.js
--rw-r--r--   0 runner    (1001) docker     (127)     3184 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/main.af77b7ba.js.LICENSE.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/
--rw-r--r--   0 runner    (1001) docker     (127)    28076 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_AMS-Regular.73ea273a72f4aca30ca5.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    63632 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_AMS-Regular.853be92419a6c3766b9a.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    33516 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_AMS-Regular.d562e886c52f12660a41.woff
--rw-r--r--   0 runner    (1001) docker     (127)    12368 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Bold.7489a2fbfb9bfe704420.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     6912 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Bold.a1abf90dfd72792a577a.woff2
--rw-r--r--   0 runner    (1001) docker     (127)     7716 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Bold.d757c535a2e5902f1325.woff
--rw-r--r--   0 runner    (1001) docker     (127)    12344 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Regular.7e873d3833eb108a0758.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     6908 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Regular.d6484fce1ef428d5bd94.woff2
--rw-r--r--   0 runner    (1001) docker     (127)     7656 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Regular.db074fa22cf224af93d7.woff
--rw-r--r--   0 runner    (1001) docker     (127)    13296 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Bold.354501bac435c3264834.woff
--rw-r--r--   0 runner    (1001) docker     (127)    19584 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Bold.4c761b3711973ab04edf.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    11348 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Bold.931d67ea207ab37ee693.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    11316 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Regular.172d3529b26f8cedef6b.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    13208 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Regular.6fdf0ac577be0ba82a4c.woff
--rw-r--r--   0 runner    (1001) docker     (127)    19572 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Regular.ed305b5434865e06ffde.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    29912 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Bold.0c3b8929d377c0e9b2f3.woff
--rw-r--r--   0 runner    (1001) docker     (127)    25324 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Bold.39890742bc957b368704.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    51336 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Bold.8169508bf58f8bd92ad8.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    16780 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-BoldItalic.20f389c4120be058d80a.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    19412 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-BoldItalic.428978dc7837d46de091.woff
--rw-r--r--   0 runner    (1001) docker     (127)    32968 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-BoldItalic.828abcb200061cffbaae.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    33580 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Italic.fa675e5e4bec9eb250b6.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    19676 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Italic.fd947498bc16392e76c2.woff
--rw-r--r--   0 runner    (1001) docker     (127)    16988 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Italic.fe2176f79edaa716e621.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    30772 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Regular.4f35fbcc9ee8614c2bcc.woff
--rw-r--r--   0 runner    (1001) docker     (127)    53580 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Regular.9eba1d77abcf2aa6e94e.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    26272 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Regular.f650f111a3b890d116f1.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    18668 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-BoldItalic.3f07ed67f06c720120ce.woff
--rw-r--r--   0 runner    (1001) docker     (127)    31196 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-BoldItalic.bf2d440b3a42ea78a998.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    16400 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-BoldItalic.dcbcbd93bac0470b462d.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    16440 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-Italic.6d3d25f4820d0da8f01f.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    31308 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-Italic.8a5f936332e8028c7278.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    18748 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-Italic.96759856b4e70f3a8338.woff
--rw-r--r--   0 runner    (1001) docker     (127)    24504 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Bold.5b49f4993ae22d7975b4.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    12216 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Bold.95591a929f0d32aa282a.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    14408 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Bold.b9cd458ac6d5889ff9c3.woff
--rw-r--r--   0 runner    (1001) docker     (127)    12028 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Italic.7d393d382f3e7fb1c637.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    14112 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Italic.8d593cfaa96238d5e2f8.woff
--rw-r--r--   0 runner    (1001) docker     (127)    22364 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Italic.b257a18c016f37ee4543.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    12316 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Regular.02271ec5cb9f5b4588ac.woff
--rw-r--r--   0 runner    (1001) docker     (127)    19436 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Regular.2f7bc363fc5424ebda59.ttf
--rw-r--r--   0 runner    (1001) docker     (127)    10344 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Regular.cd5e231e0cc53b2cb2c0.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    10588 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Script-Regular.073b3402d036714b4370.woff
--rw-r--r--   0 runner    (1001) docker     (127)     9644 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Script-Regular.c81d1b2a4b75d3eded60.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    16648 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Script-Regular.fc9ba5249878cd8f8d88.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     6496 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size1-Regular.0108e89c9003e8c14ea3.woff
--rw-r--r--   0 runner    (1001) docker     (127)    12228 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size1-Regular.6de7d4b539221a49e9e2.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     5468 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size1-Regular.6eec866c69313624be60.woff2
--rw-r--r--   0 runner    (1001) docker     (127)     5208 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size2-Regular.2960900c4f271311eb36.woff2
--rw-r--r--   0 runner    (1001) docker     (127)     6188 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size2-Regular.3a99e70aee4076660d38.woff
--rw-r--r--   0 runner    (1001) docker     (127)    11508 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size2-Regular.57f5c1837853986ea1db.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     4420 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size3-Regular.7947224e8a9914fa332b.woff
--rw-r--r--   0 runner    (1001) docker     (127)     7588 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size3-Regular.8d6b6822586eea3d3b20.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     3624 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size3-Regular.e1951519f6f0596f7356.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    10364 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size4-Regular.4ad7c7e8bb8d10a34bb7.ttf
--rw-r--r--   0 runner    (1001) docker     (127)     5980 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size4-Regular.aeffd8025cba3647f1a6.woff
--rw-r--r--   0 runner    (1001) docker     (127)     4928 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size4-Regular.e418bf257af1052628d8.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    16028 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Typewriter-Regular.4c6b94fd1d07f8beff7c.woff
--rw-r--r--   0 runner    (1001) docker     (127)    13568 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Typewriter-Regular.c295e7f71970f03c0549.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    27556 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Typewriter-Regular.c5c02d763c89380dcb4e.ttf
--rw-r--r--   0 runner    (1001) docker     (127)   247332 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/MaterialSymbols-Outlined.909d2dce4aba724ad02f.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    74492 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-Bold.17a68a0751a813474a0e.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    63060 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-BoldItalic.d45b7a3df103d441d78b.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    62096 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-Italic.ec122a420df4175e74f2.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    74052 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-Regular.84b900b88d09398d86b0.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    74132 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-SemiBold.17291d1c493cb25eb2c3.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    62988 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-SemiBoldItalic.f879ae27307c3926522b.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    76860 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-Bold.118dea98980e20a81ced.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    44640 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-BoldItalic.1d664be59d2eb5fef029.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    44748 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-Italic.8a9bfea74d43927d6eec.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    77664 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-Regular.0d69e5ff5e92ac64a0c9.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    77452 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-SemiBold.abed79cd0df1827e18cf.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    44608 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-SemiBoldItalic.befb0a2824eabc5ce36b.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    72892 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-Bold.d7975b56594770699ae0.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    30756 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-BoldItalic.913697a7178b128caa4c.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    29384 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-Italic.d3529cb5797663ac5d88.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    68356 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-Regular.e6c37aa3926474cc93e1.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    72668 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-SemiBold.5c1d378dd5990ef334ca.woff2
--rw-r--r--   0 runner    (1001) docker     (127)    30628 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-SemiBoldItalic.249e948b885d0c7d30a8.woff2
--rw-r--r--   0 runner    (1001) docker     (127)      455 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/checkmark.29851c8e9e6ef0c3d6c1e4efe3c1bb9e.svg
--rw-r--r--   0 runner    (1001) docker     (127)   101906 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/fireworks.0906f02ea43f1018a6d2.gif
--rw-r--r--   0 runner    (1001) docker     (127)    73528 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/flake-0.beded754e8024c73d9d2.png
--rw-r--r--   0 runner    (1001) docker     (127)    86179 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/flake-1.8077dc154e0bf900aa73.png
--rw-r--r--   0 runner    (1001) docker     (127)    92182 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/flake-2.e3f07d06933dd0e84c24.png
--rw-r--r--   0 runner    (1001) docker     (127)     1697 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/logo.83ae4f2fb87e38be7cbb8a5d2beb64d2.svg
--rw-r--r--   0 runner    (1001) docker     (127)    39315 2024-05-03 06:54:58.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/rocket.b75b17d2b0a063c6cea230d1a9d77f1e.svg
--rw-r--r--   0 runner    (1001) docker     (127)     6347 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/string_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1627 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/temporary_directory.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/
--rw-r--r--   0 runner    (1001) docker     (127)      690 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    36577 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/app_test.py
--rw-r--r--   0 runner    (1001) docker     (127)    59854 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/element_tree.py
--rw-r--r--   0 runner    (1001) docker     (127)     6415 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/local_script_runner.py
--rw-r--r--   0 runner    (1001) docker     (127)     1791 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/util.py
--rw-r--r--   0 runner    (1001) docker     (127)     2844 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/time_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    47503 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/type_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     3019 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/url_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     3472 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/user_info.py
--rw-r--r--   0 runner    (1001) docker     (127)     6379 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/ipython/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/ipython/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2746 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/ipython/modified_sys_path.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/pympler/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/pympler/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    87925 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/pympler/asizeof.py
--rw-r--r--   0 runner    (1001) docker     (127)     3478 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/version.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.741687 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/
--rw-r--r--   0 runner    (1001) docker     (127)      915 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    13980 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/event_based_path_watcher.py
--rw-r--r--   0 runner    (1001) docker     (127)     8238 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/local_sources_watcher.py
--rw-r--r--   0 runner    (1001) docker     (127)     5654 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/path_watcher.py
--rw-r--r--   0 runner    (1001) docker     (127)     3822 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/polling_path_watcher.py
--rw-r--r--   0 runner    (1001) docker     (127)     5203 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.745687 streamlit_nightly-1.34.1.dev20240502/streamlit/web/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14374 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/bootstrap.py
--rw-r--r--   0 runner    (1001) docker     (127)     1158 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/cache_storage_manager_config.py
--rw-r--r--   0 runner    (1001) docker     (127)    11321 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/cli.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.745687 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/
--rw-r--r--   0 runner    (1001) docker     (127)     1080 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3076 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/app_static_file_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     7803 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/browser_websocket_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     4120 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/component_request_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     5270 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/media_file_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     9922 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/routes.py
--rw-r--r--   0 runner    (1001) docker     (127)    14834 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/server.py
--rw-r--r--   0 runner    (1001) docker     (127)     4158 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/server_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     3680 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/stats_request_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     4966 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/upload_file_request_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     1870 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/websocket_headers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.745687 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     8500 2024-05-03 06:55:00.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    23355 2024-05-03 06:55:00.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-03 06:55:00.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)       53 2024-05-03 06:55:00.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-03 06:51:14.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (127)      499 2024-05-03 06:55:00.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       10 2024-05-03 06:55:00.000000 streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-03 06:55:01.745687 streamlit_nightly-1.34.1.dev20240502/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     4039 2024-05-03 06:49:37.000000 streamlit_nightly-1.34.1.dev20240502/tests/testutil.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.741305 streamlit_nightly-1.34.1.dev20240503/
+-rw-r--r--   0 runner    (1001) docker     (127)      100 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)     8500 2024-05-04 06:53:14.741305 streamlit_nightly-1.34.1.dev20240503/PKG-INFO
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.613305 streamlit_nightly-1.34.1.dev20240503/bin/
+-rw-r--r--   0 runner    (1001) docker     (127)      676 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/bin/streamlit.cmd
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-04 06:53:14.741305 streamlit_nightly-1.34.1.dev20240503/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     6787 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.617305 streamlit_nightly-1.34.1.dev20240503/streamlit/
+-rw-r--r--   0 runner    (1001) docker     (127)     8101 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      868 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2468 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/case_converters.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1407 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/cli_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2395 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/code_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9330 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/color_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1414 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/column_config.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.617305 streamlit_nightly-1.34.1.dev20240503/streamlit/commands/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/commands/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5429 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/commands/execution_control.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5042 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/commands/experimental_query_params.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12997 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/commands/page_config.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.621305 streamlit_nightly-1.34.1.dev20240503/streamlit/components/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.621305 streamlit_nightly-1.34.1.dev20240503/streamlit/components/lib/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/lib/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2978 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/lib/local_component_registry.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.621305 streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3100 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/base_component_registry.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3829 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/base_custom_component.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.621305 streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/
+-rw-r--r--   0 runner    (1001) docker     (127)     1027 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4125 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/component_arrow.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3773 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/component_registry.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1274 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/components.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8869 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/custom_component.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43895 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11469 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/config_option.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6015 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/config_util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.621305 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/
+-rw-r--r--   0 runner    (1001) docker     (127)     1083 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7465 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/base_connection.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12517 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/snowflake_connection.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8184 2024-05-04 06:47:37.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/snowpark_connection.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12234 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/sql_connection.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3022 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/connections/util.py
+-rw-r--r--   0 runner    (1001) docker     (127)      798 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/constants.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6001 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/cursor.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28228 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/delta_generator.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6516 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/deprecation_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)      813 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/development.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4077 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/echo.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.629305 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7432 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/alert.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14558 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/arrow.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1482 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/balloons.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3916 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/bokeh_chart.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2476 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/code.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6429 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/deck_gl_json_chart.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8039 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/dialog_decorator.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16168 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/doc_string.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3824 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/empty.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9121 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/exception.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12072 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/form.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4557 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/graphviz_chart.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11268 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/heading.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2810 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/html.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4383 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/iframe.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20394 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/image.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3365 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/json.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28251 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/layouts.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.629305 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30666 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/built_in_chart_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17226 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/column_config_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    51174 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/column_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5685 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/dialog.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3839 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/dicttools.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1496 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/event_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6634 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/mutable_status_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8079 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/pandas_styler_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8307 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/streamlit_plotly_theme.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6246 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/subtitle_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16299 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/map.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10384 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/markdown.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29678 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/media.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10114 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/metric.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15332 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/plotly_chart.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5844 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/progress.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6441 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/pyplot.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1439 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/snow.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2934 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/spinner.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1856 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/text.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4336 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/toast.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8085 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38336 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/vega_charts.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.633305 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32277 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/button.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9141 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/camera_input.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14320 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/chat.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12573 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/checkbox.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9142 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/color_picker.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35827 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/data_editor.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17656 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/file_uploader.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13752 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/multiselect.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18036 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/number_input.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12824 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/radio.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13442 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/select_slider.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11665 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/selectbox.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26661 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/slider.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22333 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/text_widgets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30042 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/time_widgets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20804 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/elements/write.py
+-rw-r--r--   0 runner    (1001) docker     (127)    73749 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/emojis.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1791 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/env_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/error_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4017 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/errors.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.633305 streamlit_nightly-1.34.1.dev20240503/streamlit/external/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/external/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.633305 streamlit_nightly-1.34.1.dev20240503/streamlit/external/langchain/
+-rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/external/langchain/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15280 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/external/langchain/streamlit_callback_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7216 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/file_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2342 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/folder_black_list.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5271 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/git_util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.633305 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/
+-rw-r--r--   0 runner    (1001) docker     (127)     1671 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/Hello.py
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.637305 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/
+-rw-r--r--   0 runner    (1001) docker     (127)     2956 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/0_Animation_Demo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1743 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/1_Plotting_Demo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3826 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/2_Mapping_Demo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2527 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/3_DataFrame_Demo.py
+-rw-r--r--   0 runner    (1001) docker     (127)      992 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/hello/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3524 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/js_number.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3990 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/logger.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57136 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/material_icon_names.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3280 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/net_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1104 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/platform.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.661305 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/
+-rw-r--r--   0 runner    (1001) docker     (127)     1439 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Alert_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3116 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Alert_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1208 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AppPage_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1971 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AppPage_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1410 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowNamedDataSet_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2051 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowNamedDataSet_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1710 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowVegaLiteChart_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2898 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowVegaLiteChart_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1996 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Arrow_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5904 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Arrow_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1390 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Audio_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2172 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Audio_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1032 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AutoRerun_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1560 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AutoRerun_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2090 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BackMsg_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5251 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BackMsg_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1175 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Balloons_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1401 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Balloons_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     4193 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Block_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12049 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Block_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1235 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BokehChart_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1830 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BokehChart_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1456 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Button_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2552 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Button_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1551 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/CameraInput_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2279 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/CameraInput_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1583 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ChatInput_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2927 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ChatInput_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1870 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Checkbox_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3504 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Checkbox_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1485 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ClientState_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2226 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ClientState_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1187 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Code_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1678 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Code_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1664 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ColorPicker_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2656 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ColorPicker_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     3195 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Common_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9670 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Common_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2421 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Components_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6589 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Components_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     4394 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DataFrame_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15040 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DataFrame_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1790 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DateInput_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3438 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DateInput_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1358 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DeckGlJsonChart_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2281 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DeckGlJsonChart_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1910 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Delta_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3313 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Delta_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1609 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DocString_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3514 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DocString_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1498 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DownloadButton_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2328 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DownloadButton_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)    10146 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Element_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16972 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Element_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1070 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Empty_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)      996 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Empty_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1308 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Exception_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2784 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Exception_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1132 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Favicon_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1301 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Favicon_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1707 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/FileUploader_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3209 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/FileUploader_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     4770 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ForwardMsg_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12046 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ForwardMsg_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1574 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GitInfo_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3269 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GitInfo_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1338 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GraphVizChart_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2015 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GraphVizChart_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1311 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Heading_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1944 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Heading_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1096 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Html_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1316 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Html_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1323 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/IFrame_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2275 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/IFrame_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1383 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Image_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2641 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Image_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1139 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Json_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1459 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Json_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1550 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LabelVisibilityMessage_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2779 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LabelVisibilityMessage_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1330 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LinkButton_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1964 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LinkButton_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1585 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Markdown_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3205 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Markdown_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1979 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Metric_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4041 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Metric_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1784 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/MultiSelect_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3542 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/MultiSelect_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1378 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NamedDataSet_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2123 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NamedDataSet_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     5205 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NewSession_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18437 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NewSession_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2359 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NumberInput_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5182 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NumberInput_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageConfig_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5480 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageConfig_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1130 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageInfo_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1464 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageInfo_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1462 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageLink_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2679 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageLink_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1159 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageNotFound_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1429 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageNotFound_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1958 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageProfile_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4825 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageProfile_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1295 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PagesChanged_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1704 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PagesChanged_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1164 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ParentMessage_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1616 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ParentMessage_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1937 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PlotlyChart_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5103 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PlotlyChart_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1156 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Progress_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1424 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Progress_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1802 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Radio_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3843 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Radio_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1245 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/RootContainer_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2093 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/RootContainer_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1793 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Selectbox_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Selectbox_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1469 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionEvent_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2935 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionEvent_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1226 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionStatus_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2252 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionStatus_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1402 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Skeleton_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2713 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Skeleton_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2349 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Slider_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6044 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Slider_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1098 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Snow_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1389 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Snow_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1165 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Spinner_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1535 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Spinner_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1815 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextArea_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3529 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextArea_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2056 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextInput_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4564 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextInput_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1128 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Text_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1466 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Text_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1750 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TimeInput_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3242 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TimeInput_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1135 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Toast_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1452 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Toast_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1617 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/VegaLiteChart_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2829 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/VegaLiteChart_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1864 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Video_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4327 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Video_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     2352 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/WidgetStates_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6240 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/WidgetStates_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)      668 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5938 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/openmetrics_data_model_pb2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20476 2024-05-04 06:49:26.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/proto/openmetrics_data_model_pb2.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.665305 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/
+-rw-r--r--   0 runner    (1001) docker     (127)     1523 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36802 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/app_session.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.669305 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/
+-rw-r--r--   0 runner    (1001) docker     (127)     4370 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26393 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_data_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4730 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_resource_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1131 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_type.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18329 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17358 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cached_message_replay.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18986 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/hashing.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.669305 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/
+-rw-r--r--   0 runner    (1001) docker     (127)      965 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8922 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/cache_storage_protocol.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1945 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/dummy_cache_storage.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5389 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9311 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/local_disk_cache_storage.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12414 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/connection_factory.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11500 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/credentials.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9805 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/forward_msg_cache.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5550 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/forward_msg_queue.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11558 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/fragment.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.669305 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/
+-rw-r--r--   0 runner    (1001) docker     (127)      759 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27873 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/caching.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35033 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/hashing.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8510 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/media_file_manager.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4375 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/media_file_storage.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6331 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/memory_media_file_storage.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2940 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/memory_session_storage.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4422 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/memory_uploaded_file_manager.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14265 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/metrics_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29567 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/runtime.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4192 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/runtime_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1749 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/script_data.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.669305 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/
+-rw-r--r--   0 runner    (1001) docker     (127)     1159 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9116 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/magic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1056 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/magic_funcs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2856 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_cache.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8027 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_requests.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8818 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_run_context.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29911 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_runner.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12302 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/secrets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13017 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/session_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.673305 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/
+-rw-r--r--   0 runner    (1001) docker     (127)     1528 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8065 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/common.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7397 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/query_params.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7070 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/query_params_proxy.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5169 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/safe_session_state.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27500 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/session_state.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5119 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/session_state_proxy.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11263 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/widgets.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3807 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/stats.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4784 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/uploaded_file_manager.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6443 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/websocket_session_manager.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5749 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/source_util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.673305 streamlit_nightly-1.34.1.dev20240503/streamlit/static/
+-rw-r--r--   0 runner    (1001) docker     (127)    14511 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/asset-manifest.json
+-rw-r--r--   0 runner    (1001) docker     (127)     1019 2024-05-04 06:49:54.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/favicon.png
+-rw-r--r--   0 runner    (1001) docker     (127)      891 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/index.html
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.609305 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.673305 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/
+-rw-r--r--   0 runner    (1001) docker     (127)    12090 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/3092.95a45cfe.chunk.css
+-rw-r--r--   0 runner    (1001) docker     (127)    33275 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/3466.8b8f33d6.chunk.css
+-rw-r--r--   0 runner    (1001) docker     (127)     2633 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/5441.e3b876c5.chunk.css
+-rw-r--r--   0 runner    (1001) docker     (127)    29246 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/main.3aaaea00.css
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.709305 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/
+-rw-r--r--   0 runner    (1001) docker     (127)     5446 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1074.73973756.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    11471 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1168.fc5c673b.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1524 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1307.8ea033f1.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     5024 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1451.3b0a3e31.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     9618 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1479.6709db03.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     2249 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/178.7bea8c5d.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      740 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1792.b8efa879.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    32468 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2187.9469f035.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     3396 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2469.3e9c3ce9.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      789 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2634.1249dc7a.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)  3636801 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2736.914069e5.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     2051 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2736.914069e5.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     3259 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3053.7e70ec3b.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    32270 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3061.67758376.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    43574 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3092.bc07c48b.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1931 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3301.1d1b10bb.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)  2306325 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3466.05d62820.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1219 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3466.05d62820.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      929 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3513.e3e7300a.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     5288 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3631.be5c35fa.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     2559 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4113.1e7eff4d.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     9226 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4132.49bf3f2c.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      479 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4132.49bf3f2c.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     2178 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4177.69f9f18d.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)   395952 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4253.749d5244.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      281 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4253.749d5244.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     2412 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4319.bf1c86bf.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    20661 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4477.e10e4373.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      587 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4500.b6f348d1.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    14830 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4666.c4b22a63.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     4800 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/474.87506447.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     7161 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5106.44f0ff51.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    21681 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5117.04bfe5d3.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     8252 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5345.65c91ee7.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    10874 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5379.6571574f.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     8703 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5441.71804c26.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)   107585 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5791.9a42fb4b.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    11420 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6013.64cd6d28.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)  2262785 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6150.427a30f5.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    13239 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6405.ac5a6f23.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    24494 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6718.802da17e.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1371 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6853.3cbd385e.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    88545 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7142.83028745.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     9607 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7175.be4076bc.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    65522 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7217.d970c074.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)  3383788 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7323.2808d029.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     5061 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7323.2808d029.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)   936700 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7483.64f23be7.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      212 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7483.64f23be7.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    13275 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7602.e8abc06b.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1069 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7805.51638fbc.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     3358 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8005.43974a35.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     3113 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8427.65ddaf36.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1888 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8477.7419a0aa.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    15492 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8492.3e609489.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     6699 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8536.f13dff49.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    12214 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8570.6de19120.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    10471 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8691.9ccf7f89.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     1361 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9330.2b4c99e0.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    13482 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9336.2d95d840.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)    20791 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/937.a1248039.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)      188 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/937.a1248039.chunk.js.LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    22113 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9656.8c935274.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     2119 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9758.6e6d8662.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)     4011 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9865.fd93213d.chunk.js
+-rw-r--r--   0 runner    (1001) docker     (127)  4402098 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/main.3b0201f6.js
+-rw-r--r--   0 runner    (1001) docker     (127)     3184 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/main.3b0201f6.js.LICENSE.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.729305 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/
+-rw-r--r--   0 runner    (1001) docker     (127)    28076 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_AMS-Regular.73ea273a72f4aca30ca5.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    63632 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_AMS-Regular.853be92419a6c3766b9a.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    33516 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_AMS-Regular.d562e886c52f12660a41.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    12368 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Bold.7489a2fbfb9bfe704420.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     6912 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Bold.a1abf90dfd72792a577a.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)     7716 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Bold.d757c535a2e5902f1325.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    12344 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Regular.7e873d3833eb108a0758.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     6908 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Regular.d6484fce1ef428d5bd94.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)     7656 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Regular.db074fa22cf224af93d7.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    13296 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Bold.354501bac435c3264834.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    19584 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Bold.4c761b3711973ab04edf.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    11348 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Bold.931d67ea207ab37ee693.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    11316 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Regular.172d3529b26f8cedef6b.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    13208 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Regular.6fdf0ac577be0ba82a4c.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    19572 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Regular.ed305b5434865e06ffde.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    29912 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Bold.0c3b8929d377c0e9b2f3.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    25324 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Bold.39890742bc957b368704.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    51336 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Bold.8169508bf58f8bd92ad8.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    16780 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-BoldItalic.20f389c4120be058d80a.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    19412 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-BoldItalic.428978dc7837d46de091.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    32968 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-BoldItalic.828abcb200061cffbaae.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    33580 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Italic.fa675e5e4bec9eb250b6.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    19676 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Italic.fd947498bc16392e76c2.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    16988 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Italic.fe2176f79edaa716e621.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    30772 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Regular.4f35fbcc9ee8614c2bcc.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    53580 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Regular.9eba1d77abcf2aa6e94e.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    26272 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Regular.f650f111a3b890d116f1.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    18668 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-BoldItalic.3f07ed67f06c720120ce.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    31196 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-BoldItalic.bf2d440b3a42ea78a998.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    16400 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-BoldItalic.dcbcbd93bac0470b462d.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    16440 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-Italic.6d3d25f4820d0da8f01f.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    31308 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-Italic.8a5f936332e8028c7278.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    18748 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-Italic.96759856b4e70f3a8338.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    24504 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Bold.5b49f4993ae22d7975b4.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    12216 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Bold.95591a929f0d32aa282a.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    14408 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Bold.b9cd458ac6d5889ff9c3.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    12028 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Italic.7d393d382f3e7fb1c637.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    14112 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Italic.8d593cfaa96238d5e2f8.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    22364 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Italic.b257a18c016f37ee4543.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    12316 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Regular.02271ec5cb9f5b4588ac.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    19436 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Regular.2f7bc363fc5424ebda59.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)    10344 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Regular.cd5e231e0cc53b2cb2c0.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    10588 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Script-Regular.073b3402d036714b4370.woff
+-rw-r--r--   0 runner    (1001) docker     (127)     9644 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Script-Regular.c81d1b2a4b75d3eded60.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    16648 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Script-Regular.fc9ba5249878cd8f8d88.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     6496 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size1-Regular.0108e89c9003e8c14ea3.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    12228 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size1-Regular.6de7d4b539221a49e9e2.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     5468 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size1-Regular.6eec866c69313624be60.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)     5208 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size2-Regular.2960900c4f271311eb36.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)     6188 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size2-Regular.3a99e70aee4076660d38.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    11508 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size2-Regular.57f5c1837853986ea1db.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     4420 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size3-Regular.7947224e8a9914fa332b.woff
+-rw-r--r--   0 runner    (1001) docker     (127)     7588 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size3-Regular.8d6b6822586eea3d3b20.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     3624 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size3-Regular.e1951519f6f0596f7356.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    10364 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size4-Regular.4ad7c7e8bb8d10a34bb7.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)     5980 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size4-Regular.aeffd8025cba3647f1a6.woff
+-rw-r--r--   0 runner    (1001) docker     (127)     4928 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size4-Regular.e418bf257af1052628d8.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    16028 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Typewriter-Regular.4c6b94fd1d07f8beff7c.woff
+-rw-r--r--   0 runner    (1001) docker     (127)    13568 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Typewriter-Regular.c295e7f71970f03c0549.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    27556 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Typewriter-Regular.c5c02d763c89380dcb4e.ttf
+-rw-r--r--   0 runner    (1001) docker     (127)   247332 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/MaterialSymbols-Outlined.909d2dce4aba724ad02f.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    74492 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-Bold.17a68a0751a813474a0e.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    63060 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-BoldItalic.d45b7a3df103d441d78b.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    62096 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-Italic.ec122a420df4175e74f2.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    74052 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-Regular.84b900b88d09398d86b0.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    74132 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-SemiBold.17291d1c493cb25eb2c3.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    62988 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-SemiBoldItalic.f879ae27307c3926522b.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    76860 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-Bold.118dea98980e20a81ced.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    44640 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-BoldItalic.1d664be59d2eb5fef029.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    44748 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-Italic.8a9bfea74d43927d6eec.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    77664 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-Regular.0d69e5ff5e92ac64a0c9.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    77452 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-SemiBold.abed79cd0df1827e18cf.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    44608 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-SemiBoldItalic.befb0a2824eabc5ce36b.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    72892 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-Bold.d7975b56594770699ae0.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    30756 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-BoldItalic.913697a7178b128caa4c.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    29384 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-Italic.d3529cb5797663ac5d88.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    68356 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-Regular.e6c37aa3926474cc93e1.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    72668 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-SemiBold.5c1d378dd5990ef334ca.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)    30628 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-SemiBoldItalic.249e948b885d0c7d30a8.woff2
+-rw-r--r--   0 runner    (1001) docker     (127)      455 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/checkmark.29851c8e9e6ef0c3d6c1e4efe3c1bb9e.svg
+-rw-r--r--   0 runner    (1001) docker     (127)   101906 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/fireworks.0906f02ea43f1018a6d2.gif
+-rw-r--r--   0 runner    (1001) docker     (127)    73528 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/flake-0.beded754e8024c73d9d2.png
+-rw-r--r--   0 runner    (1001) docker     (127)    86179 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/flake-1.8077dc154e0bf900aa73.png
+-rw-r--r--   0 runner    (1001) docker     (127)    92182 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/flake-2.e3f07d06933dd0e84c24.png
+-rw-r--r--   0 runner    (1001) docker     (127)     1697 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/logo.83ae4f2fb87e38be7cbb8a5d2beb64d2.svg
+-rw-r--r--   0 runner    (1001) docker     (127)    39315 2024-05-04 06:53:11.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/rocket.b75b17d2b0a063c6cea230d1a9d77f1e.svg
+-rw-r--r--   0 runner    (1001) docker     (127)     6347 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/string_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1627 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/temporary_directory.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.729305 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.733305 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/
+-rw-r--r--   0 runner    (1001) docker     (127)      690 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36577 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/app_test.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59854 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/element_tree.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6415 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/local_script_runner.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1791 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2844 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/time_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    47503 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/type_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3019 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/url_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3472 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/user_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6379 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.733305 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.733305 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/ipython/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/ipython/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2746 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/ipython/modified_sys_path.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.733305 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/pympler/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/pympler/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    87925 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/pympler/asizeof.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3478 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/version.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.733305 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/
+-rw-r--r--   0 runner    (1001) docker     (127)      915 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13980 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/event_based_path_watcher.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8238 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/local_sources_watcher.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5654 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/path_watcher.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3822 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/polling_path_watcher.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5203 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.733305 streamlit_nightly-1.34.1.dev20240503/streamlit/web/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14374 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/bootstrap.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1158 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/cache_storage_manager_config.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11321 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/cli.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.737305 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/
+-rw-r--r--   0 runner    (1001) docker     (127)     1080 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3076 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/app_static_file_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7803 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/browser_websocket_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4120 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/component_request_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5270 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/media_file_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9922 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/routes.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14834 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/server.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4158 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/server_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3680 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/stats_request_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4966 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/upload_file_request_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1870 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/websocket_headers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.737305 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     8500 2024-05-04 06:53:13.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    23334 2024-05-04 06:53:13.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-04 06:53:13.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       53 2024-05-04 06:53:13.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-04 06:49:23.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (127)      499 2024-05-04 06:53:13.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       10 2024-05-04 06:53:13.000000 streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-04 06:53:14.737305 streamlit_nightly-1.34.1.dev20240503/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)     4039 2024-05-04 06:47:38.000000 streamlit_nightly-1.34.1.dev20240503/tests/testutil.py
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/PKG-INFO` & `streamlit_nightly-1.34.1.dev20240503/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: streamlit-nightly
-Version: 1.34.1.dev20240502
+Version: 1.34.1.dev20240503
 Summary: A faster way to build and share data apps
 Home-page: https://streamlit.io
 Author: Snowflake Inc
 Author-email: hello@streamlit.io
 License: Apache License 2.0
 Project-URL: Source Code, https://github.com/streamlit/streamlit
 Project-URL: Bug Tracker, https://github.com/streamlit/streamlit/issues
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/bin/streamlit.cmd` & `streamlit_nightly-1.34.1.dev20240503/bin/streamlit.cmd`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/setup.py` & `streamlit_nightly-1.34.1.dev20240503/setup.py`

 * *Files 0% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 from pathlib import Path
 
 from setuptools import find_packages, setup
 from setuptools.command.install import install
 
 THIS_DIRECTORY = Path(__file__).parent
 
-VERSION = "1.34.1.dev20240502"  # PEP-440
+VERSION = "1.34.1.dev20240503"  # PEP-440
 
 # IMPORTANT: We should try very hard *not* to add dependencies to Streamlit.
 # And if you do add one, make the required version as general as possible:
 # - Include relevant lower bound for any features we use from our dependencies
 # - Always include the lower bound as >= VERSION, to keep testing min versions easy
 # - And include an upper bound that's < NEXT_MAJOR_VERSION
 INSTALL_REQUIRES = [
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/__main__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/__main__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/case_converters.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/case_converters.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/cli_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/cli_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/code_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/code_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/color_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/color_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/column_config.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/column_config.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/commands/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/commands/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/commands/execution_control.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/commands/execution_control.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/commands/experimental_query_params.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/commands/experimental_query_params.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/commands/page_config.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/commands/page_config.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/lib/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/lib/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/lib/local_component_registry.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/lib/local_component_registry.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/base_component_registry.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/base_component_registry.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/types/base_custom_component.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/types/base_custom_component.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/component_arrow.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/component_arrow.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/component_registry.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/component_registry.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/components.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/components.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/components/v1/custom_component.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/components/v1/custom_component.py`

 * *Files 4% similar despite different names*

```diff
@@ -201,31 +201,25 @@
             if key is not None:
                 marshall_element_args()
 
             if widget_value is None:
                 widget_value = default
             elif isinstance(widget_value, ArrowTableProto):
                 widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)
-
-            # widget_value will be either None or whatever the component's most
-            # recent setWidgetValue value is. We coerce None -> NoValue,
-            # because that's what DeltaGenerator._enqueue expects.
-            return widget_value if widget_value is not None else NoValue
+            return widget_value
 
         # We currently only support writing to st._main, but this will change
         # when we settle on an improved API in a post-layout world.
         dg = _main
 
         element = Element()
         return_value = marshall_component(dg, element)
-        result = dg._enqueue(
-            "component_instance", element.component_instance, return_value
-        )
 
-        return result
+        dg._enqueue("component_instance", element.component_instance)
+        return return_value
 
     def __eq__(self, other) -> bool:
         """Equality operator."""
         return (
             isinstance(other, CustomComponent)
             and self.name == other.name
             and self.path == other.path
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/config.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/config.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/config_option.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/config_option.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/config_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/config_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/connections/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/connections/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/connections/base_connection.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/connections/base_connection.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/connections/snowflake_connection.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/connections/snowflake_connection.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/connections/snowpark_connection.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/connections/snowpark_connection.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/connections/sql_connection.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/connections/sql_connection.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/connections/util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/connections/util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/constants.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/constants.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/cursor.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/cursor.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/delta_generator.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/delta_generator.py`

 * *Files 15% similar despite different names*

```diff
@@ -27,33 +27,31 @@
     Hashable,
     Iterable,
     List,
     Literal,
     NoReturn,
     TypeVar,
     cast,
-    overload,
 )
 
+from typing_extensions import TypeAlias
+
 from streamlit import (
     cli_util,
     config,
     cursor,
     env_util,
     logger,
     runtime,
     type_util,
     util,
 )
 from streamlit.cursor import Cursor
 from streamlit.elements.alert import AlertMixin
-from streamlit.elements.altair_utils import AddRowsMetadata
 from streamlit.elements.arrow import ArrowMixin
-from streamlit.elements.arrow_altair import ArrowAltairMixin, prep_data
-from streamlit.elements.arrow_vega_lite import ArrowVegaLiteMixin
 from streamlit.elements.balloons import BalloonsMixin
 from streamlit.elements.bokeh_chart import BokehMixin
 from streamlit.elements.code import CodeMixin
 from streamlit.elements.deck_gl_json_chart import PydeckMixin
 from streamlit.elements.doc_string import HelpMixin
 from streamlit.elements.empty import EmptyMixin
 from streamlit.elements.exception import ExceptionMixin
@@ -71,14 +69,15 @@
 from streamlit.elements.metric import MetricMixin
 from streamlit.elements.plotly_chart import PlotlyMixin
 from streamlit.elements.progress import ProgressMixin
 from streamlit.elements.pyplot import PyplotMixin
 from streamlit.elements.snow import SnowMixin
 from streamlit.elements.text import TextMixin
 from streamlit.elements.toast import ToastMixin
+from streamlit.elements.vega_charts import VegaChartsMixin
 from streamlit.elements.widgets.button import ButtonMixin
 from streamlit.elements.widgets.camera_input import CameraInputMixin
 from streamlit.elements.widgets.chat import ChatMixin
 from streamlit.elements.widgets.checkbox import CheckboxMixin
 from streamlit.elements.widgets.color_picker import ColorPickerMixin
 from streamlit.elements.widgets.data_editor import DataEditorMixin
 from streamlit.elements.widgets.file_uploader import FileUploaderMixin
@@ -90,43 +89,34 @@
 from streamlit.elements.widgets.slider import SliderMixin
 from streamlit.elements.widgets.text_widgets import TextWidgetsMixin
 from streamlit.elements.widgets.time_widgets import TimeWidgetsMixin
 from streamlit.elements.write import WriteMixin
 from streamlit.errors import NoSessionContext, StreamlitAPIException
 from streamlit.proto import Block_pb2, ForwardMsg_pb2
 from streamlit.proto.RootContainer_pb2 import RootContainer
-from streamlit.runtime import caching, legacy_caching
+from streamlit.runtime import caching
 from streamlit.runtime.scriptrunner import get_script_run_ctx
-from streamlit.runtime.state import NoValue
 
 if TYPE_CHECKING:
     from google.protobuf.message import Message
     from numpy import typing as npt
-    from pandas import DataFrame, Series
+    from pandas import DataFrame
 
     from streamlit.elements.arrow import Data
+    from streamlit.elements.lib.built_in_chart_utils import AddRowsMetadata
 
 
 MAX_DELTA_BYTES: Final[int] = 14 * 1024 * 1024  # 14MB
 
-# List of Streamlit commands that perform a Pandas "melt" operation on
-# input dataframes:
-ARROW_DELTA_TYPES_THAT_MELT_DATAFRAMES: Final = (
-    "arrow_line_chart",
-    "arrow_area_chart",
-    "arrow_bar_chart",
-    "arrow_scatter_chart",
-)
-
 Value = TypeVar("Value")
 DG = TypeVar("DG", bound="DeltaGenerator")
 
 # Type aliases for Ancestor Block Types
-BlockType = str
-AncestorBlockTypes = Iterable[BlockType]
+BlockType: TypeAlias = str
+AncestorBlockTypes: TypeAlias = Iterable[BlockType]
 
 
 _use_warning_has_been_displayed: bool = False
 
 
 def _maybe_print_use_warning() -> None:
     """Print a warning if Streamlit is imported but not being run with `streamlit run`.
@@ -193,16 +183,15 @@
     JsonMixin,
     TextMixin,
     TextWidgetsMixin,
     TimeWidgetsMixin,
     ToastMixin,
     WriteMixin,
     ArrowMixin,
-    ArrowAltairMixin,
-    ArrowVegaLiteMixin,
+    VegaChartsMixin,
     DataEditorMixin,
 ):
     """Creator of Delta protobuf messages.
 
     Parameters
     ----------
     root_container: BlockPath_pb2.BlockPath.ContainerValue or None
@@ -420,106 +409,34 @@
         This way, users can (say) use st.image with a stream of different images,
         and Streamlit will expire the older images and replace them in place.
         """
         # Operate on the active DeltaGenerator, in case we're in a `with` block.
         dg = self._active_dg
         return str(dg._cursor.delta_path) if dg._cursor is not None else "[]"
 
-    @overload
     def _enqueue(
         self,
         delta_type: str,
         element_proto: Message,
-        return_value: None,
         add_rows_metadata: AddRowsMetadata | None = None,
-        element_width: int | None = None,
-        element_height: int | None = None,
     ) -> DeltaGenerator:
-        ...
-
-    @overload
-    def _enqueue(  # type: ignore[misc]
-        self,
-        delta_type: str,
-        element_proto: Message,
-        return_value: type[NoValue],
-        add_rows_metadata: AddRowsMetadata | None = None,
-        element_width: int | None = None,
-        element_height: int | None = None,
-    ) -> None:
-        ...
-
-    @overload
-    def _enqueue(
-        self,
-        delta_type: str,
-        element_proto: Message,
-        return_value: Value,
-        add_rows_metadata: AddRowsMetadata | None = None,
-        element_width: int | None = None,
-        element_height: int | None = None,
-    ) -> Value:
-        ...
-
-    @overload
-    def _enqueue(
-        self,
-        delta_type: str,
-        element_proto: Message,
-        return_value: None = None,
-        add_rows_metadata: AddRowsMetadata | None = None,
-        element_width: int | None = None,
-        element_height: int | None = None,
-    ) -> DeltaGenerator:
-        ...
-
-    @overload
-    def _enqueue(
-        self,
-        delta_type: str,
-        element_proto: Message,
-        return_value: type[NoValue] | Value | None = None,
-        add_rows_metadata: AddRowsMetadata | None = None,
-        element_width: int | None = None,
-        element_height: int | None = None,
-    ) -> DeltaGenerator | Value | None:
-        ...
-
-    def _enqueue(
-        self,
-        delta_type: str,
-        element_proto: Message,
-        return_value: type[NoValue] | Value | None = None,
-        add_rows_metadata: AddRowsMetadata | None = None,
-        element_width: int | None = None,
-        element_height: int | None = None,
-    ) -> DeltaGenerator | Value | None:
         """Create NewElement delta, fill it, and enqueue it.
 
         Parameters
         ----------
         delta_type : str
             The name of the streamlit method being called
         element_proto : proto
             The actual proto in the NewElement type e.g. Alert/Button/Slider
-        return_value : any or None
-            The value to return to the calling script (for widgets)
-        element_width : int or None
-            Desired width for the element
-        element_height : int or None
-            Desired height for the element
 
         Returns
         -------
-        DeltaGenerator or any
-            If this element is NOT an interactive widget, return a
-            DeltaGenerator that can be used to modify the newly-created
-            element. Otherwise, if the element IS a widget, return the
-            `return_value` parameter.
-
+        DeltaGenerator
+            Return a DeltaGenerator that can be used to modify the newly-created
+            element.
         """
         # Operate on the active DeltaGenerator, in case we're in a `with` block.
         dg = self._active_dg
 
         ctx = get_script_run_ctx()
         if ctx and ctx.current_fragment_id and _writes_directly_to_sidebar(dg):
             raise StreamlitAPIException(
@@ -527,38 +444,24 @@
                 "is not supported. To write elements to the sidebar with a fragment, "
                 "call your fragment function inside a `with st.sidebar` context manager."
             )
 
         # Warn if an element is being changed but the user isn't running the streamlit server.
         _maybe_print_use_warning()
 
-        # Some elements have a method.__name__ != delta_type in proto.
-        # This really matters for line_chart, bar_chart & area_chart,
-        # since add_rows() relies on method.__name__ == delta_type
-        # TODO: Fix for all elements (or the cache warning above will be wrong)
-        proto_type = delta_type
-
-        if proto_type in ARROW_DELTA_TYPES_THAT_MELT_DATAFRAMES:
-            proto_type = "arrow_vega_lite_chart"
-
         # Copy the marshalled proto into the overall msg proto
         msg = ForwardMsg_pb2.ForwardMsg()
-        msg_el_proto = getattr(msg.delta.new_element, proto_type)
+        msg_el_proto = getattr(msg.delta.new_element, delta_type)
         msg_el_proto.CopyFrom(element_proto)
 
         # Only enqueue message and fill in metadata if there's a container.
         msg_was_enqueued = False
         if dg._root_container is not None and dg._cursor is not None:
             msg.metadata.delta_path[:] = dg._cursor.delta_path
 
-            if element_width is not None:
-                msg.metadata.element_dimension_spec.width = element_width
-            if element_height is not None:
-                msg.metadata.element_dimension_spec.height = element_height
-
             _enqueue_message(msg)
             msg_was_enqueued = True
 
         if msg_was_enqueued:
             # Get a DeltaGenerator that is locked to the current element
             # position.
             new_cursor = (
@@ -575,24 +478,24 @@
                 parent=dg,
             )
         else:
             # If the message was not enqueued, just return self since it's a
             # no-op from the point of view of the app.
             output_dg = dg
 
-        # Save message for replay if we're called from within @st.memo or @st.singleton
+        # Save message for replay if we're called from within @st.cache_data or @st.cache_resource
         caching.save_element_message(
             delta_type,
             element_proto,
             invoked_dg_id=self.id,
             used_dg_id=dg.id,
             returned_dg_id=output_dg.id,
         )
 
-        return _value_or_dg(return_value, output_dg)
+        return output_dg
 
     def _block(
         self,
         block_proto: Block_pb2.Block = Block_pb2.Block(),
         dg_type: type | None = None,
     ) -> DeltaGenerator:
         # Operate on the active DeltaGenerator, in case we're in a `with` block.
@@ -728,30 +631,28 @@
             raise StreamlitAPIException(
                 "Wrong number of arguments to add_rows()."
                 "Command requires exactly one dataset"
             )
 
         # When doing _arrow_add_rows on an element that does not already have data
         # (for example, st.line_chart() without any args), call the original
-        # st._arrow_foo() element with new data instead of doing a _arrow_add_rows().
+        # st.foo() element with new data instead of doing a _arrow_add_rows().
         if (
-            self._cursor.props["delta_type"] in ARROW_DELTA_TYPES_THAT_MELT_DATAFRAMES
+            "add_rows_metadata" in self._cursor.props
+            and self._cursor.props["add_rows_metadata"]
             and self._cursor.props["add_rows_metadata"].last_index is None
         ):
-            # IMPORTANT: This assumes delta types and st method names always
-            # match!
-            # delta_type starts with "arrow_", but st_method_name doesn't use this prefix.
-            st_method_name = self._cursor.props["delta_type"].replace("arrow_", "")
-            st_method = getattr(self, st_method_name)
+            st_method = getattr(
+                self, self._cursor.props["add_rows_metadata"].chart_command
+            )
             st_method(data, **kwargs)
             return None
 
         new_data, self._cursor.props["add_rows_metadata"] = _prep_data_for_add_rows(
             data,
-            self._cursor.props["delta_type"],
             self._cursor.props["add_rows_metadata"],
         )
 
         msg = ForwardMsg_pb2.ForwardMsg()
         msg.metadata.delta_path[:] = self._cursor.delta_path
 
         import streamlit.elements.arrow as arrow_proto
@@ -793,106 +694,29 @@
     if len(current_stack) > 1:
         return current_stack[-1]
     return None
 
 
 def _prep_data_for_add_rows(
     data: Data,
-    delta_type: str,
-    add_rows_metadata: AddRowsMetadata,
-) -> tuple[Data, AddRowsMetadata]:
-    out_data: Data
-
-    # For some delta types we have to reshape the data structure
-    # otherwise the input data and the actual data used
-    # by vega_lite will be different, and it will throw an error.
-    if delta_type in ARROW_DELTA_TYPES_THAT_MELT_DATAFRAMES:
-        import pandas as pd
-
-        df = cast(pd.DataFrame, type_util.convert_anything_to_df(data))
-
-        # Make range indices start at last_index.
-        if isinstance(df.index, pd.RangeIndex):
-            old_step = _get_pandas_index_attr(df, "step")
-
-            # We have to drop the predefined index
-            df = df.reset_index(drop=True)
-
-            old_stop = _get_pandas_index_attr(df, "stop")
-
-            if old_step is None or old_stop is None:
-                raise StreamlitAPIException(
-                    "'RangeIndex' object has no attribute 'step'"
-                )
-
-            start = add_rows_metadata.last_index + old_step
-            stop = add_rows_metadata.last_index + old_step + old_stop
-
-            df.index = pd.RangeIndex(start=start, stop=stop, step=old_step)
-            add_rows_metadata.last_index = stop - 1
-
-        out_data, *_ = prep_data(df, **add_rows_metadata.columns)
-
-    else:
+    add_rows_metadata: AddRowsMetadata | None,
+) -> tuple[Data, AddRowsMetadata | None]:
+    if not add_rows_metadata:
         # When calling add_rows on st.table or st.dataframe we want styles to pass through.
-        out_data = type_util.convert_anything_to_df(data, allow_styler=True)
-
-    return out_data, add_rows_metadata
-
-
-def _get_pandas_index_attr(
-    data: DataFrame | Series,
-    attr: str,
-) -> Any | None:
-    return getattr(data.index, attr, None)
-
-
-@overload
-def _value_or_dg(value: None, dg: DG) -> DG:
-    ...
-
-
-@overload
-def _value_or_dg(value: type[NoValue], dg: DG) -> None:  # type: ignore[misc]
-    ...
+        return type_util.convert_anything_to_df(data, allow_styler=True), None
 
+    # If add_rows_metadata is set, it indicates that the add_rows used called
+    # on a chart based on our built-in chart commands.
 
-@overload
-def _value_or_dg(value: Value, dg: DG) -> Value:
-    # This overload definition technically overlaps with the one above (Value
-    # contains Type[NoValue]), and since the return types are conflicting,
-    # mypy complains. Hence, the ignore-comment above. But, in practice, since
-    # the overload above is more specific, and is matched first, there is no
-    # actual overlap. The `Value` type here is thus narrowed to the cases
-    # where value is neither None nor NoValue.
-
-    # The ignore-comment should thus be fine.
-    ...
-
-
-def _value_or_dg(
-    value: type[NoValue] | Value | None,
-    dg: DG,
-) -> DG | Value | None:
-    """Return either value, or None, or dg.
-
-    This is needed because Widgets have meaningful return values. This is
-    unlike other elements, which always return None. Then we internally replace
-    that None with a DeltaGenerator instance.
-
-    However, sometimes a widget may want to return None, and in this case it
-    should not be replaced by a DeltaGenerator. So we have a special NoValue
-    object that gets replaced by None.
+    # For built-in chart commands we have to reshape the data structure
+    # otherwise the input data and the actual data used
+    # by vega_lite will be different, and it will throw an error.
+    from streamlit.elements.lib.built_in_chart_utils import prep_chart_data_for_add_rows
 
-    """
-    if value is NoValue:
-        return None
-    if value is None:
-        return dg
-    return cast(Value, value)
+    return prep_chart_data_for_add_rows(data, add_rows_metadata)
 
 
 def _enqueue_message(msg: ForwardMsg_pb2.ForwardMsg) -> None:
     """Enqueues a ForwardMsg proto to send to the app."""
     ctx = get_script_run_ctx()
 
     if ctx is None:
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/deprecation_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/deprecation_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/development.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/development.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/echo.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/echo.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/alert.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/alert.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/altair_utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/magic_funcs.py`

 * *Files 24% similar despite different names*

```diff
@@ -8,33 +8,25 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-"""Useful classes for our native Altair-based charts.
-
-These classes are used to pass some important info to add_rows.
-"""
-
 from __future__ import annotations
 
-from dataclasses import dataclass
-from typing import Hashable, TypedDict
-
-
-class PrepDataColumns(TypedDict):
-    """Columns used for the prep_data step in Altair Arrow charts."""
-
-    x_column: str | None
-    y_column_list: list[str]
-    color_column: str | None
-    size_column: str | None
+from typing import Any
 
+from streamlit.runtime.metrics_util import gather_metrics
 
-@dataclass
-class AddRowsMetadata:
-    """Metadata needed by add_rows on native charts."""
 
-    last_index: Hashable | None
-    columns: PrepDataColumns
+@gather_metrics("magic")
+def transparent_write(*args: Any) -> Any:
+    """The function that gets magic-ified into Streamlit apps.
+    This is just st.write, but returns the arguments you passed to it.
+    """
+    import streamlit as st
+
+    st.write(*args)
+    if len(args) == 1:
+        return args[0]
+    return args
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/arrow.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/arrow.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/balloons.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/balloons.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/bokeh_chart.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/bokeh_chart.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/code.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/code.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/deck_gl_json_chart.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/deck_gl_json_chart.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/dialog_decorator.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/dialog_decorator.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/doc_string.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/doc_string.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/empty.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/empty.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/exception.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/exception.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/form.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/form.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/graphviz_chart.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/graphviz_chart.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/heading.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/heading.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/html.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/html.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/iframe.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/iframe.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/image.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/image.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/json.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/json.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/layouts.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/layouts.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/column_config_utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/column_config_utils.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/column_types.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/column_types.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/dialog.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/dialog.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/dicttools.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/dicttools.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/event_utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/event_utils.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/mutable_status_container.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/mutable_status_container.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/pandas_styler_utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/pandas_styler_utils.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/streamlit_plotly_theme.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/streamlit_plotly_theme.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/lib/subtitle_utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/lib/subtitle_utils.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/map.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/map.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/markdown.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/markdown.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/media.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/media.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/metric.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/metric.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/plotly_chart.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/plotly_chart.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/progress.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/progress.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/pyplot.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/pyplot.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/snow.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/snow.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/spinner.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/spinner.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/text.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/text.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/toast.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/toast.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,40 +11,27 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from __future__ import annotations
 
 from enum import Enum, EnumMeta
-from typing import TYPE_CHECKING, Any, Hashable, Iterable, Sequence, cast, overload
+from typing import TYPE_CHECKING, Any, Iterable, Sequence, overload
 
 import streamlit
 from streamlit import config, runtime, type_util
 from streamlit.elements.form import is_in_form
 from streamlit.errors import StreamlitAPIException, StreamlitAPIWarning
 from streamlit.proto.LabelVisibilityMessage_pb2 import LabelVisibilityMessage
 from streamlit.runtime.state import WidgetCallback, get_session_state
 from streamlit.runtime.state.common import RegisterWidgetResult
 from streamlit.type_util import T
 
 if TYPE_CHECKING:
     from streamlit.delta_generator import DeltaGenerator
-    from streamlit.type_util import DataFrameCompatible
-
-
-def last_index_for_melted_dataframes(
-    data: DataFrameCompatible | Any,
-) -> Hashable | None:
-    if type_util.is_dataframe_compatible(data):
-        data = type_util.convert_anything_to_df(data)
-
-        if data.index.size > 0:
-            return cast(Hashable, data.index[-1])
-
-    return None
 
 
 def check_callback_rules(dg: DeltaGenerator, on_change: WidgetCallback | None) -> None:
     if runtime.exists() and is_in_form(dg) and on_change is not None:
         raise StreamlitAPIException(
             "With forms, callbacks can only be defined on the `st.form_submit_button`."
             " Defining callbacks on other widgets inside a form is not allowed."
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/button.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/button.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/camera_input.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/camera_input.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/chat.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/chat.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/checkbox.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/checkbox.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/color_picker.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/color_picker.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/data_editor.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/data_editor.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/file_uploader.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/file_uploader.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/multiselect.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/multiselect.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/number_input.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/number_input.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/radio.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/radio.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/select_slider.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/select_slider.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/selectbox.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/selectbox.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/slider.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/slider.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/text_widgets.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/text_widgets.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/widgets/time_widgets.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/widgets/time_widgets.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/elements/write.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/elements/write.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/emojis.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/emojis.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/env_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/env_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/error_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/error_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/errors.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/errors.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/external/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/external/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/external/langchain/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/external/langchain/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/external/langchain/streamlit_callback_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/external/langchain/streamlit_callback_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/file_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/file_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/folder_black_list.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/folder_black_list.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/git_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/git_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/Hello.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/Hello.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/0_Animation_Demo.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/0_Animation_Demo.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/1_Plotting_Demo.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/1_Plotting_Demo.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/2_Mapping_Demo.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/2_Mapping_Demo.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/pages/3_DataFrame_Demo.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/pages/3_DataFrame_Demo.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/hello/utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/hello/utils.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/js_number.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/js_number.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/logger.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/logger.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/material_icon_names.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/material_icon_names.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/net_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/net_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/platform.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/platform.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Alert_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Alert_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Alert_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Alert_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AppPage_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AppPage_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AppPage_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AppPage_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowNamedDataSet_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowNamedDataSet_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowNamedDataSet_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowNamedDataSet_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowVegaLiteChart_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowVegaLiteChart_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ArrowVegaLiteChart_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ArrowVegaLiteChart_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Arrow_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Arrow_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Arrow_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Arrow_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Audio_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Audio_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Audio_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Audio_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AutoRerun_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AutoRerun_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/AutoRerun_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/AutoRerun_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BackMsg_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BackMsg_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BackMsg_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BackMsg_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Balloons_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Balloons_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Balloons_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Balloons_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Block_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Block_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Block_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Block_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BokehChart_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BokehChart_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/BokehChart_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/BokehChart_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Button_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Button_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Button_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Button_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/CameraInput_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/CameraInput_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/CameraInput_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/CameraInput_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ChatInput_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ChatInput_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ChatInput_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ChatInput_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Checkbox_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Checkbox_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Checkbox_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Checkbox_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ClientState_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ClientState_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ClientState_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ClientState_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Code_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Code_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Code_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Code_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ColorPicker_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ColorPicker_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ColorPicker_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ColorPicker_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Common_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Common_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Common_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Common_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Components_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Components_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Components_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Components_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DataFrame_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DataFrame_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DataFrame_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DataFrame_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DateInput_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DateInput_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DateInput_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DateInput_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DeckGlJsonChart_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DeckGlJsonChart_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DeckGlJsonChart_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DeckGlJsonChart_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Delta_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Delta_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Delta_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Delta_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DocString_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DocString_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DocString_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DocString_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DownloadButton_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DownloadButton_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/DownloadButton_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/DownloadButton_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Element_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Element_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Element_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Element_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Empty_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Empty_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Empty_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Empty_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Exception_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Exception_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Exception_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Exception_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Favicon_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Favicon_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Favicon_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Favicon_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/FileUploader_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/FileUploader_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/FileUploader_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/FileUploader_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ForwardMsg_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ForwardMsg_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ForwardMsg_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ForwardMsg_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GitInfo_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GitInfo_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GitInfo_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GitInfo_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GraphVizChart_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GraphVizChart_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/GraphVizChart_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/GraphVizChart_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Heading_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Heading_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Heading_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Heading_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Html_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Html_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Html_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Html_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/IFrame_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/IFrame_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/IFrame_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/IFrame_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Image_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Image_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Image_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Image_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Json_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Json_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Json_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Json_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LabelVisibilityMessage_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LabelVisibilityMessage_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LabelVisibilityMessage_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LabelVisibilityMessage_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LinkButton_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LinkButton_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/LinkButton_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/LinkButton_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Markdown_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Markdown_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Markdown_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Markdown_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Metric_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Metric_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Metric_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Metric_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/MultiSelect_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/MultiSelect_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/MultiSelect_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/MultiSelect_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NamedDataSet_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NamedDataSet_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NamedDataSet_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NamedDataSet_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NewSession_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NewSession_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NewSession_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NewSession_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NumberInput_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NumberInput_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/NumberInput_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/NumberInput_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageConfig_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageConfig_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageConfig_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageConfig_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageInfo_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageInfo_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageInfo_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageInfo_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageLink_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageLink_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageLink_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageLink_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageNotFound_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageNotFound_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageNotFound_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageNotFound_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageProfile_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageProfile_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PageProfile_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PageProfile_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PagesChanged_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PagesChanged_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PagesChanged_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PagesChanged_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ParentMessage_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ParentMessage_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/ParentMessage_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/ParentMessage_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PlotlyChart_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PlotlyChart_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/PlotlyChart_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/PlotlyChart_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Progress_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Progress_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Progress_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Progress_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Radio_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Radio_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Radio_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Radio_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/RootContainer_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/RootContainer_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/RootContainer_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/RootContainer_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Selectbox_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Selectbox_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Selectbox_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Selectbox_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionEvent_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionEvent_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionEvent_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionEvent_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionStatus_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionStatus_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/SessionStatus_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/SessionStatus_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Skeleton_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Skeleton_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Skeleton_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Skeleton_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Slider_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Slider_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Slider_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Slider_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Snow_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Snow_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Snow_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Snow_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Spinner_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Spinner_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Spinner_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Spinner_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextArea_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextArea_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextArea_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextArea_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextInput_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextInput_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TextInput_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TextInput_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Text_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Text_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Text_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Text_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TimeInput_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TimeInput_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/TimeInput_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/TimeInput_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Toast_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Toast_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Toast_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Toast_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/VegaLiteChart_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/VegaLiteChart_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/VegaLiteChart_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/VegaLiteChart_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Video_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Video_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/Video_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/Video_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/WidgetStates_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/WidgetStates_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/WidgetStates_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/WidgetStates_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/openmetrics_data_model_pb2.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/openmetrics_data_model_pb2.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/proto/openmetrics_data_model_pb2.pyi` & `streamlit_nightly-1.34.1.dev20240503/streamlit/proto/openmetrics_data_model_pb2.pyi`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/app_session.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/app_session.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_data_api.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_data_api.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_errors.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_errors.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_resource_api.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_resource_api.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_type.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_type.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cache_utils.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cache_utils.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/cached_message_replay.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/cached_message_replay.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/hashing.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/hashing.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/cache_storage_protocol.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/cache_storage_protocol.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/dummy_cache_storage.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/dummy_cache_storage.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/caching/storage/local_disk_cache_storage.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/caching/storage/local_disk_cache_storage.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/connection_factory.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/connection_factory.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/credentials.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/credentials.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/forward_msg_cache.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/forward_msg_cache.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/forward_msg_queue.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/forward_msg_queue.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/fragment.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/fragment.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/caching.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/caching.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/legacy_caching/hashing.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/legacy_caching/hashing.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/media_file_manager.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/media_file_manager.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/media_file_storage.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/media_file_storage.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/memory_media_file_storage.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/memory_media_file_storage.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/memory_session_storage.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/memory_session_storage.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/memory_uploaded_file_manager.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/memory_uploaded_file_manager.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/metrics_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/metrics_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/runtime.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/runtime.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/runtime_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/runtime_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/script_data.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/script_data.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/magic.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/magic.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/magic_funcs.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -8,25 +8,10 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from __future__ import annotations
+from streamlit.testing.v1.app_test import AppTest
 
-from typing import Any
-
-from streamlit.runtime.metrics_util import gather_metrics
-
-
-@gather_metrics("magic")
-def transparent_write(*args: Any) -> Any:
-    """The function that gets magic-ified into Streamlit apps.
-    This is just st.write, but returns the arguments you passed to it.
-    """
-    import streamlit as st
-
-    st.write(*args)
-    if len(args) == 1:
-        return args[0]
-    return args
+__all__ = ["AppTest"]
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_cache.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_cache.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_requests.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_requests.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_run_context.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_run_context.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/scriptrunner/script_runner.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/scriptrunner/script_runner.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/secrets.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/secrets.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/session_manager.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/session_manager.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/common.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/common.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/query_params.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/query_params.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/query_params_proxy.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/query_params_proxy.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/safe_session_state.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/safe_session_state.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/session_state.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/session_state.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/session_state_proxy.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/session_state_proxy.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/state/widgets.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/state/widgets.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/stats.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/stats.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/uploaded_file_manager.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/uploaded_file_manager.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/runtime/websocket_session_manager.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/runtime/websocket_session_manager.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/source_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/source_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/asset-manifest.json` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/asset-manifest.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8227124183006536%*

 * *Differences: {"'entrypoints'": "{insert: [(1, 'static/js/main.3b0201f6.js')], delete: [1]}",*

 * * "'files'": "{'main.js': './static/js/main.3b0201f6.js', 'static/css/5441.e3b876c5.chunk.css': "*

 * *            "'./static/css/5441.e3b876c5.chunk.css', 'static/js/5441.71804c26.chunk.js': "*

 * *            "'./static/js/5441.71804c26.chunk.js', 'static/js/7483.64f23be7.chunk.js': "*

 * *            "'./static/js/7483.64f23be7.chunk.js', delete: ['static/css/43.e3b876c5.chunk.css', "*

 * *            "'static/js/43.c6749504.chunk.js', 'static/js […]*

```diff
@@ -1,19 +1,19 @@
 {
     "entrypoints": [
         "static/css/main.3aaaea00.css",
-        "static/js/main.af77b7ba.js"
+        "static/js/main.3b0201f6.js"
     ],
     "files": {
         "index.html": "./index.html",
         "main.css": "./static/css/main.3aaaea00.css",
-        "main.js": "./static/js/main.af77b7ba.js",
+        "main.js": "./static/js/main.3b0201f6.js",
         "static/css/3092.95a45cfe.chunk.css": "./static/css/3092.95a45cfe.chunk.css",
         "static/css/3466.8b8f33d6.chunk.css": "./static/css/3466.8b8f33d6.chunk.css",
-        "static/css/43.e3b876c5.chunk.css": "./static/css/43.e3b876c5.chunk.css",
+        "static/css/5441.e3b876c5.chunk.css": "./static/css/5441.e3b876c5.chunk.css",
         "static/js/1074.73973756.chunk.js": "./static/js/1074.73973756.chunk.js",
         "static/js/1168.fc5c673b.chunk.js": "./static/js/1168.fc5c673b.chunk.js",
         "static/js/1307.8ea033f1.chunk.js": "./static/js/1307.8ea033f1.chunk.js",
         "static/js/1451.3b0a3e31.chunk.js": "./static/js/1451.3b0a3e31.chunk.js",
         "static/js/1479.6709db03.chunk.js": "./static/js/1479.6709db03.chunk.js",
         "static/js/178.7bea8c5d.chunk.js": "./static/js/178.7bea8c5d.chunk.js",
         "static/js/1792.b8efa879.chunk.js": "./static/js/1792.b8efa879.chunk.js",
@@ -28,35 +28,35 @@
         "static/js/3466.05d62820.chunk.js": "./static/js/3466.05d62820.chunk.js",
         "static/js/3513.e3e7300a.chunk.js": "./static/js/3513.e3e7300a.chunk.js",
         "static/js/3631.be5c35fa.chunk.js": "./static/js/3631.be5c35fa.chunk.js",
         "static/js/4113.1e7eff4d.chunk.js": "./static/js/4113.1e7eff4d.chunk.js",
         "static/js/4132.49bf3f2c.chunk.js": "./static/js/4132.49bf3f2c.chunk.js",
         "static/js/4177.69f9f18d.chunk.js": "./static/js/4177.69f9f18d.chunk.js",
         "static/js/4253.749d5244.chunk.js": "./static/js/4253.749d5244.chunk.js",
-        "static/js/43.c6749504.chunk.js": "./static/js/43.c6749504.chunk.js",
         "static/js/4319.bf1c86bf.chunk.js": "./static/js/4319.bf1c86bf.chunk.js",
         "static/js/4477.e10e4373.chunk.js": "./static/js/4477.e10e4373.chunk.js",
         "static/js/4500.b6f348d1.chunk.js": "./static/js/4500.b6f348d1.chunk.js",
         "static/js/4666.c4b22a63.chunk.js": "./static/js/4666.c4b22a63.chunk.js",
         "static/js/474.87506447.chunk.js": "./static/js/474.87506447.chunk.js",
         "static/js/5106.44f0ff51.chunk.js": "./static/js/5106.44f0ff51.chunk.js",
         "static/js/5117.04bfe5d3.chunk.js": "./static/js/5117.04bfe5d3.chunk.js",
         "static/js/5345.65c91ee7.chunk.js": "./static/js/5345.65c91ee7.chunk.js",
         "static/js/5379.6571574f.chunk.js": "./static/js/5379.6571574f.chunk.js",
+        "static/js/5441.71804c26.chunk.js": "./static/js/5441.71804c26.chunk.js",
         "static/js/5791.9a42fb4b.chunk.js": "./static/js/5791.9a42fb4b.chunk.js",
         "static/js/6013.64cd6d28.chunk.js": "./static/js/6013.64cd6d28.chunk.js",
         "static/js/6150.427a30f5.chunk.js": "./static/js/6150.427a30f5.chunk.js",
         "static/js/6405.ac5a6f23.chunk.js": "./static/js/6405.ac5a6f23.chunk.js",
-        "static/js/656.7150a933.chunk.js": "./static/js/656.7150a933.chunk.js",
         "static/js/6718.802da17e.chunk.js": "./static/js/6718.802da17e.chunk.js",
         "static/js/6853.3cbd385e.chunk.js": "./static/js/6853.3cbd385e.chunk.js",
         "static/js/7142.83028745.chunk.js": "./static/js/7142.83028745.chunk.js",
         "static/js/7175.be4076bc.chunk.js": "./static/js/7175.be4076bc.chunk.js",
         "static/js/7217.d970c074.chunk.js": "./static/js/7217.d970c074.chunk.js",
         "static/js/7323.2808d029.chunk.js": "./static/js/7323.2808d029.chunk.js",
+        "static/js/7483.64f23be7.chunk.js": "./static/js/7483.64f23be7.chunk.js",
         "static/js/7602.e8abc06b.chunk.js": "./static/js/7602.e8abc06b.chunk.js",
         "static/js/7805.51638fbc.chunk.js": "./static/js/7805.51638fbc.chunk.js",
         "static/js/8005.43974a35.chunk.js": "./static/js/8005.43974a35.chunk.js",
         "static/js/8427.65ddaf36.chunk.js": "./static/js/8427.65ddaf36.chunk.js",
         "static/js/8477.7419a0aa.chunk.js": "./static/js/8477.7419a0aa.chunk.js",
         "static/js/8492.3e609489.chunk.js": "./static/js/8492.3e609489.chunk.js",
         "static/js/8536.f13dff49.chunk.js": "./static/js/8536.f13dff49.chunk.js",
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/favicon.png` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/favicon.png`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/index.html` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/index.html`

 * *Files 3% similar despite different names*

```diff
@@ -1 +1 @@
-<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="shortcut icon" href="./favicon.png"/><link rel="preload" href="./static/media/SourceSansPro-Regular.0d69e5ff5e92ac64a0c9.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="./static/media/SourceSansPro-SemiBold.abed79cd0df1827e18cf.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="./static/media/SourceSansPro-Bold.118dea98980e20a81ced.woff2" as="font" type="font/woff2" crossorigin><title>Streamlit</title><script>window.prerenderReady=!1</script><script defer="defer" src="./static/js/main.af77b7ba.js"></script><link href="./static/css/main.3aaaea00.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div></body></html>
+<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="shortcut icon" href="./favicon.png"/><link rel="preload" href="./static/media/SourceSansPro-Regular.0d69e5ff5e92ac64a0c9.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="./static/media/SourceSansPro-SemiBold.abed79cd0df1827e18cf.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="./static/media/SourceSansPro-Bold.118dea98980e20a81ced.woff2" as="font" type="font/woff2" crossorigin><title>Streamlit</title><script>window.prerenderReady=!1</script><script defer="defer" src="./static/js/main.3b0201f6.js"></script><link href="./static/css/main.3aaaea00.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div></body></html>
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/3092.95a45cfe.chunk.css` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/3092.95a45cfe.chunk.css`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/3466.8b8f33d6.chunk.css` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/3466.8b8f33d6.chunk.css`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/43.e3b876c5.chunk.css` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/5441.e3b876c5.chunk.css`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/css/main.3aaaea00.css` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/css/main.3aaaea00.css`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1074.73973756.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1074.73973756.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1168.fc5c673b.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1168.fc5c673b.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1307.8ea033f1.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1307.8ea033f1.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1451.3b0a3e31.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1451.3b0a3e31.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1479.6709db03.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1479.6709db03.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/178.7bea8c5d.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/178.7bea8c5d.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/1792.b8efa879.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/1792.b8efa879.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2187.9469f035.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2187.9469f035.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2469.3e9c3ce9.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2469.3e9c3ce9.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2634.1249dc7a.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2634.1249dc7a.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2736.914069e5.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2736.914069e5.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/2736.914069e5.chunk.js.LICENSE.txt` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/2736.914069e5.chunk.js.LICENSE.txt`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3053.7e70ec3b.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3053.7e70ec3b.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3061.67758376.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3061.67758376.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3092.bc07c48b.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3092.bc07c48b.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3301.1d1b10bb.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3301.1d1b10bb.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3466.05d62820.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3466.05d62820.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3466.05d62820.chunk.js.LICENSE.txt` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3466.05d62820.chunk.js.LICENSE.txt`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3513.e3e7300a.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3513.e3e7300a.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/3631.be5c35fa.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/3631.be5c35fa.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4113.1e7eff4d.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4113.1e7eff4d.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4132.49bf3f2c.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4132.49bf3f2c.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4177.69f9f18d.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4177.69f9f18d.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4253.749d5244.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4253.749d5244.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/43.c6749504.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5441.71804c26.chunk.js`

 * *Files 5% similar despite different names*

#### js-beautify {}

```diff
@@ -1,30 +1,75 @@
 "use strict";
 (self.webpackChunk_streamlit_app = self.webpackChunk_streamlit_app || []).push([
-    [43], {
-        10043: (t, e, o) => {
+    [5441], {
+        5441: (t, e, o) => {
             o.r(e), o.d(e, {
                 default: () => W
             });
             var n = o(66845),
                 i = o(25621),
-                a = o(41558),
-                s = o(91149),
+                a = o(72965),
+                s = o(94206),
                 r = o(60784),
                 l = o(23849),
                 d = o(62622),
                 c = o(63765),
-                h = o(91191),
-                g = o(96825),
-                u = o.n(g),
-                m = o(99394),
-                f = o.n(m),
-                p = o(27466);
+                h = o(91191);
+            const g = {
+                    DATAFRAME_INDEX: "(index)"
+                },
+                u = new Set([h.GI.DatetimeIndex, h.GI.Float64Index, h.GI.Int64Index, h.GI.RangeIndex, h.GI.UInt64Index]);
+
+            function m(t) {
+                var e;
+                if (0 === (null === (e = t.datasets) || void 0 === e ? void 0 : e.length)) return null;
+                const o = {};
+                return t.datasets.forEach((t => {
+                    if (!t) return;
+                    const e = t.hasName ? t.name : null;
+                    o[e] = t.data
+                })), o
+            }
+
+            function f(t) {
+                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
+                if (t.isEmpty()) return [];
+                const o = [],
+                    {
+                        dataRows: n,
+                        dataColumns: i
+                    } = t.dimensions,
+                    a = h.fu.getTypeName(t.types.index[0]),
+                    s = u.has(a);
+                for (let r = e; r < n; r++) {
+                    const e = {};
+                    if (s) {
+                        const o = t.getIndexValue(r, 0);
+                        e[g.DATAFRAME_INDEX] = "bigint" === typeof o ? Number(o) : o
+                    }
+                    for (let o = 0; o < i; o++) {
+                        const n = t.getDataValue(r, o),
+                            i = t.types.data[o],
+                            a = h.fu.getTypeName(i);
+                        if ("datetimetz" !== a && (n instanceof Date || Number.isFinite(n)) && (a.startsWith("datetime") || "date" === a)) {
+                            const i = 60 * new Date(n).getTimezoneOffset() * 1e3;
+                            e[t.columns[0][o]] = n.valueOf() + i
+                        } else e[t.columns[0][o]] = "bigint" === typeof n ? Number(n) : n
+                    }
+                    o.push(e)
+                }
+                return o
+            }
+            var p = o(96825),
+                b = o.n(p),
+                y = o(99394),
+                w = o.n(y),
+                v = o(27466);
 
-            function b(t, e) {
+            function x(t, e) {
                 const o = {
                     font: e.genericFonts.bodyFont,
                     background: e.colors.bgColor,
                     fieldTitle: "verbal",
                     autosize: {
                         type: "fit",
                         contains: "padding"
@@ -38,64 +83,64 @@
                         fontSize: e.fontSizes.smPx + 2,
                         orient: "top",
                         offset: 26
                     },
                     header: {
                         titleFontWeight: e.fontWeights.normal,
                         titleFontSize: e.fontSizes.mdPx,
-                        titleColor: (0, p.Xy)(e),
+                        titleColor: (0, v.Xy)(e),
                         titleFontStyle: "normal",
                         labelFontSize: e.fontSizes.twoSmPx,
                         labelFontWeight: e.fontWeights.normal,
-                        labelColor: (0, p.Xy)(e),
+                        labelColor: (0, v.Xy)(e),
                         labelFontStyle: "normal"
                     },
                     axis: {
                         labelFontSize: e.fontSizes.twoSmPx,
                         labelFontWeight: e.fontWeights.normal,
-                        labelColor: (0, p.Xy)(e),
+                        labelColor: (0, v.Xy)(e),
                         labelFontStyle: "normal",
                         titleFontWeight: e.fontWeights.normal,
                         titleFontSize: e.fontSizes.smPx,
-                        titleColor: (0, p.Xy)(e),
+                        titleColor: (0, v.Xy)(e),
                         titleFontStyle: "normal",
                         ticks: !1,
-                        gridColor: (0, p.ny)(e),
+                        gridColor: (0, v.ny)(e),
                         domain: !1,
                         domainWidth: 1,
-                        domainColor: (0, p.ny)(e),
+                        domainColor: (0, v.ny)(e),
                         labelFlush: !0,
                         labelFlushOffset: 1,
                         labelBound: !1,
                         labelLimit: 100,
                         titlePadding: e.spacing.lgPx,
                         labelPadding: e.spacing.lgPx,
                         labelSeparation: e.spacing.twoXSPx,
                         labelOverlap: !0
                     },
                     legend: {
                         labelFontSize: e.fontSizes.smPx,
                         labelFontWeight: e.fontWeights.normal,
-                        labelColor: (0, p.Xy)(e),
+                        labelColor: (0, v.Xy)(e),
                         titleFontSize: e.fontSizes.smPx,
                         titleFontWeight: e.fontWeights.normal,
                         titleFontStyle: "normal",
-                        titleColor: (0, p.Xy)(e),
+                        titleColor: (0, v.Xy)(e),
                         titlePadding: 5,
                         labelPadding: e.spacing.lgPx,
                         columnPadding: e.spacing.smPx,
                         rowPadding: e.spacing.twoXSPx,
                         padding: 7,
                         symbolStrokeWidth: 4
                     },
                     range: {
-                        category: (0, p.iY)(e),
-                        diverging: (0, p.ru)(e),
-                        ramp: (0, p.Gy)(e),
-                        heatmap: (0, p.Gy)(e)
+                        category: (0, v.iY)(e),
+                        diverging: (0, v.ru)(e),
+                        ramp: (0, v.Gy)(e),
+                        heatmap: (0, v.Gy)(e)
                     },
                     view: {
                         columns: 1,
                         strokeWidth: 0,
                         stroke: "transparent",
                         continuousHeight: 350,
                         continuousWidth: 400,
@@ -108,15 +153,15 @@
                         columns: 1
                     },
                     facet: {
                         columns: 1
                     },
                     mark: {
                         tooltip: !0,
-                        ...(0, p.Iy)(e) ? {
+                        ...(0, v.Iy)(e) ? {
                             color: "#0068C9"
                         } : {
                             color: "#83C9FF"
                         }
                     },
                     bar: {
                         binSpacing: e.spacing.twoXSPx,
@@ -133,17 +178,17 @@
                     axisTemporal: {
                         grid: !1
                     },
                     axisXBand: {
                         grid: !1
                     }
                 };
-                return t ? f()({}, o, t, ((t, e) => Array.isArray(e) ? e : void 0)) : o
+                return t ? w()({}, o, t, ((t, e) => Array.isArray(e) ? e : void 0)) : o
             }
-            const y = (0, o(1515).Z)("div", {
+            const S = (0, o(1515).Z)("div", {
                 target: "egd2k5h0"
             })((t => {
                 let {
                     theme: e,
                     useContainerWidth: o,
                     isFullScreen: n
                 } = t;
@@ -198,53 +243,49 @@
                                 opacity: "1 !important",
                                 background: e.colors.darkenedBgMix25
                             }
                         }
                     }
                 }
             }), "");
-            var w = o(40864);
-            const v = {
-                    DATAFRAME_INDEX: "(index)"
-                },
-                x = "source",
-                S = new Set([h.GI.DatetimeIndex, h.GI.Float64Index, h.GI.Int64Index, h.GI.RangeIndex, h.GI.UInt64Index]);
-            class F extends n.PureComponent {
+            var F = o(40864);
+            const z = "source";
+            class C extends n.PureComponent {
                 constructor() {
-                    super(...arguments), this.vegaView = void 0, this.vegaFinalizer = void 0, this.defaultDataName = x, this.element = null, this.state = {
+                    super(...arguments), this.vegaView = void 0, this.vegaFinalizer = void 0, this.defaultDataName = z, this.element = null, this.state = {
                         error: void 0
                     }, this.finalizeView = () => {
                         this.vegaFinalizer && this.vegaFinalizer(), this.vegaFinalizer = void 0, this.vegaView = void 0
                     }, this.generateSpec = () => {
                         var t, e;
                         const {
                             element: o,
                             theme: n,
                             isFullScreen: i,
                             width: a,
                             height: s
                         } = this.props, r = JSON.parse(o.spec), {
                             useContainerWidth: l
                         } = o;
-                        if ("streamlit" === o.vegaLiteTheme ? r.config = b(r.config, n) : "streamlit" === (null === (t = r.usermeta) || void 0 === t || null === (e = t.embedOptions) || void 0 === e ? void 0 : e.theme) ? (r.config = b(r.config, n), r.usermeta.embedOptions.theme = void 0) : r.config = function(t, e) {
+                        if ("streamlit" === o.vegaLiteTheme ? r.config = x(r.config, n) : "streamlit" === (null === (t = r.usermeta) || void 0 === t || null === (e = t.embedOptions) || void 0 === e ? void 0 : e.theme) ? (r.config = x(r.config, n), r.usermeta.embedOptions.theme = void 0) : r.config = function(t, e) {
                                 const {
                                     colors: o,
                                     fontSizes: n,
                                     genericFonts: i
                                 } = e, a = {
                                     labelFont: i.bodyFont,
                                     titleFont: i.bodyFont,
                                     labelFontSize: n.twoSmPx,
                                     titleFontSize: n.twoSmPx
                                 }, s = {
                                     background: o.bgColor,
                                     axis: {
                                         labelColor: o.bodyText,
                                         titleColor: o.bodyText,
-                                        gridColor: (0, p.ny)(e),
+                                        gridColor: (0, v.ny)(e),
                                         ...a
                                     },
                                     legend: {
                                         labelColor: o.bodyText,
                                         titleColor: o.bodyText,
                                         ...a
                                     },
@@ -255,27 +296,27 @@
                                     },
                                     header: {
                                         labelColor: o.bodyText,
                                         titleColor: o.bodyText,
                                         ...a
                                     },
                                     view: {
-                                        stroke: (0, p.ny)(e),
+                                        stroke: (0, v.ny)(e),
                                         continuousHeight: 350,
                                         continuousWidth: 400,
                                         discreteHeight: 350,
                                         discreteWidth: {
                                             step: 20
                                         }
                                     },
                                     mark: {
                                         tooltip: !0
                                     }
                                 };
-                                return t ? u()({}, s, t) : s
+                                return t ? b()({}, s, t) : s
                             }(r.config, n), i ? (r.width = a, r.height = s, "vconcat" in r && r.vconcat.forEach((t => {
                                 t.width = a
                             }))) : l && (r.width = a, "vconcat" in r && r.vconcat.forEach((t => {
                                 t.width = a
                             }))), r.padding || (r.padding = {}), null == r.padding.bottom && (r.padding.bottom = 20), r.datasets) throw new Error("Datasets should not be passed as part of the spec");
                         return r
                     }
@@ -316,48 +357,47 @@
                         return
                     }
                     const r = e.data,
                         {
                             data: d
                         } = n;
                     (r || d) && this.updateData(this.defaultDataName, r, d);
-                    const h = z(e) || {},
-                        g = z(n) || {};
+                    const h = m(e) || {},
+                        g = m(n) || {};
                     for (const [l, c] of Object.entries(g)) {
                         const t = l || this.defaultDataName,
                             e = h[t];
                         this.updateData(t, e, c)
                     }
                     for (const l of Object.keys(h)) g.hasOwnProperty(l) || l === this.defaultDataName || this.updateData(l, null, null);
                     this.vegaView.resize().runAsync()
                 }
                 updateData(t, e, o) {
                     if (!this.vegaView) throw new Error("Chart has not been drawn yet");
                     if (!o || 0 === o.data.numRows) {
                         return void(this.vegaView._runtime.data.hasOwnProperty(t) && this.vegaView.remove(t, s.truthy))
                     }
-                    if (!e || 0 === e.data.numRows) return void this.vegaView.insert(t, C(o));
+                    if (!e || 0 === e.data.numRows) return void this.vegaView.insert(t, f(o));
                     const {
                         dataRows: n,
                         dataColumns: i
                     } = e.dimensions, {
                         dataRows: a,
                         dataColumns: r
                     } = o.dimensions;
                     if (function(t, e, o, n, i, a) {
                             if (o !== a) return !1;
                             if (e >= i) return !1;
                             if (0 === e) return !1;
                             const s = a - 1,
                                 r = e - 1;
-                            if (t.getDataValue(0, s) !== n.getDataValue(0, s) || t.getDataValue(r, s) !== n.getDataValue(r, s)) return !1;
-                            return !0
-                        }(e, n, i, o, a, r)) n < a && this.vegaView.insert(t, C(o, n));
+                            return t.getDataValue(0, s) === n.getDataValue(0, s) && t.getDataValue(r, s) === n.getDataValue(r, s)
+                        }(e, n, i, o, a, r)) n < a && this.vegaView.insert(t, f(o, n));
                     else {
-                        const e = s.changeset().remove(s.truthy).insert(C(o));
+                        const e = s.changeset().remove(s.truthy).insert(f(o));
                         this.vegaView.change(t, e), (0, l.ji)("Had to clear the ".concat(t, " dataset before inserting data through Vega view."))
                     }
                 }
                 async createView() {
                     if ((0, l.ji)("Creating a new Vega view."), !this.element) throw Error("Element missing.");
                     this.finalizeView();
                     const t = this.props.element,
@@ -374,84 +414,42 @@
                         {
                             vgSpec: n,
                             view: i,
                             finalize: s
                         } = await (0, a.ZP)(this.element, e, o);
                     this.vegaView = i, this.vegaFinalizer = s;
                     const d = function(t) {
-                            const e = z(t);
+                            const e = m(t);
                             if (null == e) return null;
                             const o = {};
-                            for (const [n, i] of Object.entries(e)) o[n] = C(i);
+                            for (const [n, i] of Object.entries(e)) o[n] = f(i);
                             return o
                         }(t),
                         c = d ? Object.keys(d) : [];
                     if (1 === c.length) {
                         const [t] = c;
                         this.defaultDataName = t
-                    } else 0 === c.length && n.data && (this.defaultDataName = x);
+                    } else 0 === c.length && n.data && (this.defaultDataName = z);
                     const h = function(t) {
                         const e = t.data;
-                        if (!e || 0 === e.data.numRows) return null;
-                        return C(e)
+                        return e && 0 !== e.data.numRows ? f(e) : null
                     }(t);
                     if (h && i.insert(this.defaultDataName, h), d)
                         for (const [a, r] of Object.entries(d)) i.insert(a, r);
                     await i.runAsync(), this.vegaView.resize().runAsync()
                 }
                 render() {
                     if (this.state.error) throw this.state.error;
-                    return (0, w.jsx)(y, {
+                    return (0, F.jsx)(S, {
                         "data-testid": "stArrowVegaLiteChart",
                         useContainerWidth: this.props.element.useContainerWidth,
                         isFullScreen: this.props.isFullScreen,
                         ref: t => {
                             this.element = t
                         }
                     })
                 }
             }
-
-            function z(t) {
-                var e;
-                if (0 === (null === (e = t.datasets) || void 0 === e ? void 0 : e.length)) return null;
-                const o = {};
-                return t.datasets.forEach((t => {
-                    if (!t) return;
-                    const e = t.hasName ? t.name : null;
-                    o[e] = t.data
-                })), o
-            }
-
-            function C(t) {
-                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
-                if (t.isEmpty()) return [];
-                const o = [],
-                    {
-                        dataRows: n,
-                        dataColumns: i
-                    } = t.dimensions,
-                    a = h.fu.getTypeName(t.types.index[0]),
-                    s = S.has(a);
-                for (let r = e; r < n; r++) {
-                    const e = {};
-                    if (s) {
-                        const o = t.getIndexValue(r, 0);
-                        e[v.DATAFRAME_INDEX] = "bigint" === typeof o ? Number(o) : o
-                    }
-                    for (let o = 0; o < i; o++) {
-                        const n = t.getDataValue(r, o),
-                            i = t.types.data[o],
-                            a = h.fu.getTypeName(i);
-                        if ("datetimetz" !== a && (n instanceof Date || Number.isFinite(n)) && (a.startsWith("datetime") || "date" === a)) {
-                            const i = 60 * new Date(n).getTimezoneOffset() * 1e3;
-                            e[t.columns[0][o]] = n.valueOf() + i
-                        } else e[t.columns[0][o]] = "bigint" === typeof n ? Number(n) : n
-                    }
-                    o.push(e)
-                }
-                return o
-            }
-            const W = (0, i.b)((0, d.Z)(F))
+            const W = (0, i.b)((0, d.Z)(C))
         }
     }
 ]);
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4319.bf1c86bf.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4319.bf1c86bf.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4477.e10e4373.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4477.e10e4373.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4500.b6f348d1.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4500.b6f348d1.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/4666.c4b22a63.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/4666.c4b22a63.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/474.87506447.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/474.87506447.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5106.44f0ff51.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5106.44f0ff51.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5117.04bfe5d3.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5117.04bfe5d3.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5345.65c91ee7.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5345.65c91ee7.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5379.6571574f.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5379.6571574f.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/5791.9a42fb4b.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/5791.9a42fb4b.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6013.64cd6d28.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6013.64cd6d28.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6150.427a30f5.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6150.427a30f5.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6405.ac5a6f23.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6405.ac5a6f23.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/656.7150a933.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7483.64f23be7.chunk.js`

 * *Files 2% similar despite different names*

#### js-beautify {}

```diff
@@ -1,10 +1,10 @@
-/*! For license information please see 656.7150a933.chunk.js.LICENSE.txt */
+/*! For license information please see 7483.64f23be7.chunk.js.LICENSE.txt */
 (self.webpackChunk_streamlit_app = self.webpackChunk_streamlit_app || []).push([
-    [656], {
+    [7483], {
         86893: t => {
             var e = function() {
                 "use strict";
 
                 function t(t, e) {
                     return null != e && t instanceof e
                 }
@@ -190,101 +190,101 @@
         99394: (t, e, n) => {
             var i = n(63256),
                 r = n(80693)((function(t, e, n, r) {
                     i(t, e, n, r)
                 }));
             t.exports = r
         },
-        41558: (t, e, n) => {
+        72965: (t, e, n) => {
             "use strict";
             n.d(e, {
-                ZP: () => oy
+                ZP: () => uy
             });
             var i = {};
             n.r(i), n.d(i, {
                 JsonPatchError: () => y,
                 _areEquals: () => C,
                 applyOperation: () => k,
                 applyPatch: () => E,
-                applyReducer: () => D,
+                applyReducer: () => A,
                 deepClone: () => b,
                 getValueByPointer: () => w,
                 validate: () => S,
-                validator: () => A
+                validator: () => D
             });
             var r = {};
             n.r(r), n.d(r, {
                 compare: () => P,
-                generate: () => z,
+                generate: () => R,
                 observe: () => N,
                 unobserve: () => T
             });
             var o = {};
             n.r(o), n.d(o, {
                 accessPathDepth: () => Nt,
                 accessPathWithDatum: () => St,
-                compile: () => pm,
+                compile: () => km,
                 contains: () => st,
                 deepEqual: () => Q,
-                deleteNestedProperty: () => Dt,
+                deleteNestedProperty: () => At,
                 duplicate: () => tt,
                 entries: () => _t,
                 every: () => lt,
                 fieldIntersection: () => vt,
                 flatAccessWithDatum: () => Ct,
-                getFirstDefined: () => zt,
+                getFirstDefined: () => Rt,
                 hasIntersection: () => mt,
                 hash: () => ot,
-                internalField: () => jt,
+                internalField: () => Bt,
                 isBoolean: () => wt,
                 isEmpty: () => yt,
                 isEqual: () => ht,
-                isInternalField: () => Bt,
+                isInternalField: () => It,
                 isNullOrFalse: () => at,
                 isNumeric: () => Ut,
                 keys: () => bt,
                 logicalExpr: () => Et,
                 mergeDeep: () => ut,
                 never: () => et,
-                normalize: () => Tl,
-                normalizeAngle: () => It,
+                normalize: () => Bl,
+                normalizeAngle: () => jt,
                 omit: () => it,
                 pick: () => nt,
                 prefixGenerator: () => gt,
                 removePathFromField: () => Tt,
                 replaceAll: () => Ot,
-                replacePathInField: () => Mt,
+                replacePathInField: () => Ft,
                 resetIdCounter: () => Lt,
                 setEqual: () => pt,
                 some: () => ct,
                 stringify: () => rt,
-                titleCase: () => At,
+                titleCase: () => Dt,
                 unique: () => dt,
                 uniqueId: () => Pt,
                 vals: () => xt,
                 varName: () => kt,
-                version: () => mm
+                version: () => Em
             });
             var a = {};
             n.r(a), n.d(a, {
-                carbong10: () => mg,
-                carbong100: () => vg,
-                carbong90: () => gg,
-                carbonwhite: () => pg,
-                dark: () => xm,
-                excel: () => wm,
-                fivethirtyeight: () => Sm,
-                ggplot2: () => Fm,
-                googlecharts: () => Ym,
-                latimes: () => Rm,
-                powerbi: () => lg,
-                quartz: () => jm,
-                urbaninstitute: () => Jm,
-                version: () => yg,
-                vox: () => Im
+                carbong10: () => Eg,
+                carbong100: () => Dg,
+                carbong90: () => Ag,
+                carbonwhite: () => kg,
+                dark: () => Mm,
+                excel: () => Om,
+                fivethirtyeight: () => Pm,
+                ggplot2: () => Bm,
+                googlecharts: () => og,
+                latimes: () => Hm,
+                powerbi: () => yg,
+                quartz: () => Jm,
+                urbaninstitute: () => eg,
+                version: () => Sg,
+                vox: () => $m
             });
             var s = function() {
                     var t = function(e, n) {
                         return t = Object.setPrototypeOf || {
                             __proto__: []
                         }
                         instanceof Array && function(t, e) {
@@ -474,15 +474,15 @@
                     op: "_get",
                     path: e
                 };
                 return k(t, n), n.value
             }
 
             function k(t, e, n, i, r, o) {
-                if (void 0 === n && (n = !1), void 0 === i && (i = !0), void 0 === r && (r = !0), void 0 === o && (o = 0), n && ("function" == typeof n ? n(e, 0, t, e.path) : A(e, 0)), "" === e.path) {
+                if (void 0 === n && (n = !1), void 0 === i && (i = !0), void 0 === r && (r = !0), void 0 === o && (o = 0), n && ("function" == typeof n ? n(e, 0, t, e.path) : D(e, 0)), "" === e.path) {
                     var a = {
                         newDocument: t
                     };
                     if ("add" === e.op) return a.newDocument = e.value, a;
                     if ("replace" === e.op) return a.newDocument = e.value, a.removed = t, a;
                     if ("move" === e.op || "copy" === e.op) return a.newDocument = w(t, e.from), "move" === e.op && (a.removed = t), a;
                     if ("test" === e.op) {
@@ -498,15 +498,15 @@
                 var s = (e.path || "").split("/"),
                     c = t,
                     l = 1,
                     u = s.length,
                     h = void 0,
                     m = void 0,
                     g = void 0;
-                for (g = "function" == typeof n ? n : A;;) {
+                for (g = "function" == typeof n ? n : D;;) {
                     if ((m = s[l]) && -1 != m.indexOf("~") && (m = p(m)), r && ("__proto__" == m || "prototype" == m && l > 0 && "constructor" == s[l - 1])) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
                     if (n && void 0 === h && (void 0 === c[m] ? h = s.slice(0, l).join("/") : l == u - 1 && (h = e.path), void 0 !== h && g(e, 0, t, h)), l++, Array.isArray(c)) {
                         if ("-" === m) m = c.length;
                         else {
                             if (n && !d(m)) throw new y("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", o, e, t);
                             d(m) && (m = ~~m)
                         }
@@ -526,21 +526,21 @@
             function E(t, e, n, i, r) {
                 if (void 0 === i && (i = !0), void 0 === r && (r = !0), n && !Array.isArray(e)) throw new y("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
                 i || (t = f(t));
                 for (var o = new Array(e.length), a = 0, s = e.length; a < s; a++) o[a] = k(t, e[a], n, !0, r, a), t = o[a].newDocument;
                 return o.newDocument = t, o
             }
 
-            function D(t, e, n) {
+            function A(t, e, n) {
                 var i = k(t, e);
                 if (!1 === i.test) throw new y("Test operation failed", "TEST_OPERATION_FAILED", n, e, t);
                 return i.newDocument
             }
 
-            function A(t, e, n, i) {
+            function D(t, e, n, i) {
                 if ("object" !== typeof t || null === t || Array.isArray(t)) throw new y("Operation is not an object", "OPERATION_NOT_AN_OBJECT", e, t, n);
                 if (!x[t.op]) throw new y("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", e, t, n);
                 if ("string" !== typeof t.path) throw new y("Operation `path` property is not a string", "OPERATION_PATH_INVALID", e, t, n);
                 if (0 !== t.path.indexOf("/") && t.path.length > 0) throw new y('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", e, t, n);
                 if (("move" === t.op || "copy" === t.op) && "string" !== typeof t.from) throw new y("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", e, t, n);
                 if (("add" === t.op || "replace" === t.op || "test" === t.op) && void 0 === t.value) throw new y("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", e, t, n);
                 if (("add" === t.op || "replace" === t.op || "test" === t.op) && m(t.value)) throw new y("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", e, t, n);
@@ -562,15 +562,15 @@
             }
 
             function S(t, e, n) {
                 try {
                     if (!Array.isArray(t)) throw new y("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
                     if (e) E(f(e), f(t), n || !0);
                     else {
-                        n = n || A;
+                        n = n || D;
                         for (var i = 0; i < t.length; i++) n(t[i], i, e, void 0)
                     }
                 } catch (r) {
                     if (r instanceof y) return r;
                     throw r
                 }
             }
@@ -593,64 +593,64 @@
                         if (!e.hasOwnProperty(s[n])) return !1;
                     for (n = i; 0 !== n--;)
                         if (!C(t[r = s[n]], e[r])) return !1;
                     return !0
                 }
                 return t !== t && e !== e
             }
-            var F = new WeakMap,
-                M = function(t) {
+            var M = new WeakMap,
+                F = function(t) {
                     this.observers = new Map, this.obj = t
                 },
                 O = function(t, e) {
                     this.callback = t, this.observer = e
                 };
 
             function T(t, e) {
                 e.unobserve()
             }
 
             function N(t, e) {
                 var n, i = function(t) {
-                    return F.get(t)
+                    return M.get(t)
                 }(t);
                 if (i) {
                     var r = function(t, e) {
                         return t.observers.get(e)
                     }(i, e);
                     n = r && r.observer
-                } else i = new M(t), F.set(t, i);
+                } else i = new F(t), M.set(t, i);
                 if (n) return n;
                 if (n = {}, i.value = f(t), e) {
                     n.callback = e, n.next = null;
                     var o = function() {
-                            z(n)
+                            R(n)
                         },
                         a = function() {
                             clearTimeout(n.next), n.next = setTimeout(o)
                         };
                     "undefined" !== typeof window && (window.addEventListener("mouseup", a), window.addEventListener("keyup", a), window.addEventListener("mousedown", a), window.addEventListener("keydown", a), window.addEventListener("change", a))
                 }
                 return n.patches = [], n.object = t, n.unobserve = function() {
-                    z(n), clearTimeout(n.next),
+                    R(n), clearTimeout(n.next),
                         function(t, e) {
                             t.observers.delete(e.callback)
                         }(i, n), "undefined" !== typeof window && (window.removeEventListener("mouseup", a), window.removeEventListener("keyup", a), window.removeEventListener("mousedown", a), window.removeEventListener("keydown", a), window.removeEventListener("change", a))
                 }, i.observers.set(e, new O(e, n)), n
             }
 
-            function z(t, e) {
+            function R(t, e) {
                 void 0 === e && (e = !1);
-                var n = F.get(t.object);
-                R(n.value, t.object, t.patches, "", e), t.patches.length && E(n.value, t.patches);
+                var n = M.get(t.object);
+                z(n.value, t.object, t.patches, "", e), t.patches.length && E(n.value, t.patches);
                 var i = t.patches;
                 return i.length > 0 && (t.patches = [], t.callback && t.callback(i)), i
             }
 
-            function R(t, e, n, i, r) {
+            function z(t, e, n, i, r) {
                 if (e !== t) {
                     "function" === typeof e.toJSON && (e = e.toJSON());
                     for (var o = u(e), a = u(t), s = !1, c = a.length - 1; c >= 0; c--) {
                         var d = t[m = a[c]];
                         if (!l(e, m) || void 0 === e[m] && void 0 !== d && !1 === Array.isArray(e)) Array.isArray(t) === Array.isArray(e) ? (r && n.push({
                             op: "test",
                             path: i + "/" + h(m),
@@ -665,15 +665,15 @@
                         }), n.push({
                             op: "replace",
                             path: i,
                             value: e
                         }), !0);
                         else {
                             var p = e[m];
-                            "object" == typeof d && null != d && "object" == typeof p && null != p && Array.isArray(d) === Array.isArray(p) ? R(d, p, n, i + "/" + h(m), r) : d !== p && (!0, r && n.push({
+                            "object" == typeof d && null != d && "object" == typeof p && null != p && Array.isArray(d) === Array.isArray(p) ? z(d, p, n, i + "/" + h(m), r) : d !== p && (!0, r && n.push({
                                 op: "test",
                                 path: i + "/" + h(m),
                                 value: f(d)
                             }), n.push({
                                 op: "replace",
                                 path: i + "/" + h(m),
                                 value: f(p)
@@ -691,61 +691,61 @@
                         }
                 }
             }
 
             function P(t, e, n) {
                 void 0 === n && (n = !1);
                 var i = [];
-                return R(t, e, i, "", n), i
+                return z(t, e, i, "", n), i
             }
             Object.assign({}, i, r, {
                 JsonPatchError: v,
                 deepClone: f,
                 escapePathComponent: h,
                 unescapePathComponent: p
             });
             var L = n(76248),
-                j = n.n(L),
-                B = n(91149),
-                I = n(60784);
+                B = n.n(L),
+                I = n(94206),
+                j = n(60784);
             var U = n(15721),
                 q = n(86893),
                 W = n.n(q),
                 H = n(60473),
                 X = n.n(H),
-                J = n(4761),
-                G = n.n(J);
+                G = n(4761),
+                J = n.n(G);
 
-            function $(t) {
+            function Z(t) {
                 return !!t.or
             }
 
-            function Z(t) {
+            function $(t) {
                 return !!t.and
             }
 
             function Y(t) {
                 return !!t.not
             }
 
             function V(t, e) {
                 if (Y(t)) V(t.not, e);
-                else if (Z(t))
-                    for (const n of t.and) V(n, e);
                 else if ($(t))
+                    for (const n of t.and) V(n, e);
+                else if (Z(t))
                     for (const n of t.or) V(n, e);
                 else e(t)
             }
 
             function K(t, e) {
                 return Y(t) ? {
                     not: K(t.not, e)
-                } : Z(t) ? {
-                    and: t.and.map((t => K(t, e)))
                 } : $(t) ? {
+                    and: t.and.map((t => K(t, e)))
+                } : Z(t) ? {
                     or: t.or.map((t => K(t, e)))
                 } : e(t)
             }
             const Q = X(),
                 tt = W();
 
             function et(t) {
@@ -762,21 +762,21 @@
                 const n = {
                     ...t
                 };
                 for (const i of e) delete n[i];
                 return n
             }
             Set.prototype.toJSON = function() {
-                return "Set(".concat([...this].map((t => G()(t))).join(","), ")")
+                return "Set(".concat([...this].map((t => J()(t))).join(","), ")")
             };
-            const rt = G();
+            const rt = J();
 
             function ot(t) {
                 if ((0, U.hj)(t)) return t;
-                const e = (0, U.HD)(t) ? t : G()(t);
+                const e = (0, U.HD)(t) ? t : J()(t);
                 if (e.length < 250) return e;
                 let n = 0;
                 for (let i = 0; i < e.length; i++) {
                     n = (n << 5) - n + e.charCodeAt(i), n |= 0
                 }
                 return n
             }
@@ -870,24 +870,24 @@
 
             function kt(t) {
                 const e = t.replace(/\W/g, "_");
                 return (t.match(/^\d+/) ? "_" : "") + e
             }
 
             function Et(t, e) {
-                return Y(t) ? "!(".concat(Et(t.not, e), ")") : Z(t) ? "(".concat(t.and.map((t => Et(t, e))).join(") && ("), ")") : $(t) ? "(".concat(t.or.map((t => Et(t, e))).join(") || ("), ")") : e(t)
+                return Y(t) ? "!(".concat(Et(t.not, e), ")") : $(t) ? "(".concat(t.and.map((t => Et(t, e))).join(") && ("), ")") : Z(t) ? "(".concat(t.or.map((t => Et(t, e))).join(") || ("), ")") : e(t)
             }
 
-            function Dt(t, e) {
+            function At(t, e) {
                 if (0 === e.length) return !0;
                 const n = e.shift();
-                return n in t && Dt(t[n], e) && delete t[n], yt(t)
+                return n in t && At(t[n], e) && delete t[n], yt(t)
             }
 
-            function At(t) {
+            function Dt(t) {
                 return t.charAt(0).toUpperCase() + t.substr(1)
             }
 
             function St(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "datum";
                 const n = (0, U._k)(t),
                     i = [];
@@ -898,73 +898,73 @@
                 return i.join(" && ")
             }
 
             function Ct(t) {
                 return "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "datum", "[").concat((0, U.m8)((0, U._k)(t).join(".")), "]")
             }
 
-            function Ft(t) {
+            function Mt(t) {
                 return t.replace(/(\[|\]|\.|'|")/g, "\\$1")
             }
 
-            function Mt(t) {
-                return "".concat((0, U._k)(t).map(Ft).join("\\."))
+            function Ft(t) {
+                return "".concat((0, U._k)(t).map(Mt).join("\\."))
             }
 
             function Ot(t, e, n) {
                 return t.replace(new RegExp(e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n)
             }
 
             function Tt(t) {
                 return "".concat((0, U._k)(t).join("."))
             }
 
             function Nt(t) {
                 return t ? (0, U._k)(t).length : 0
             }
 
-            function zt() {
+            function Rt() {
                 for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                 for (const i of e)
                     if (void 0 !== i) return i
             }
-            let Rt = 42;
+            let zt = 42;
 
             function Pt(t) {
-                const e = ++Rt;
+                const e = ++zt;
                 return t ? String(t) + e : e
             }
 
             function Lt() {
-                Rt = 42
+                zt = 42
             }
 
-            function jt(t) {
-                return Bt(t) ? t : "__".concat(t)
+            function Bt(t) {
+                return It(t) ? t : "__".concat(t)
             }
 
-            function Bt(t) {
+            function It(t) {
                 return t.startsWith("__")
             }
 
-            function It(t) {
+            function jt(t) {
                 if (void 0 !== t) return (t % 360 + 360) % 360
             }
 
             function Ut(t) {
                 return !!(0, U.hj)(t) || !isNaN(t) && !isNaN(parseFloat(t))
             }
             const qt = "row",
                 Wt = "column",
                 Ht = "facet",
                 Xt = "x",
-                Jt = "y",
-                Gt = "x2",
-                $t = "y2",
-                Zt = "xOffset",
+                Gt = "y",
+                Jt = "x2",
+                Zt = "y2",
+                $t = "xOffset",
                 Yt = "yOffset",
                 Vt = "radius",
                 Kt = "radius2",
                 Qt = "theta",
                 te = "theta2",
                 ee = "latitude",
                 ne = "longitude",
@@ -992,18 +992,18 @@
                 Ee = {
                     theta: 1,
                     theta2: 1,
                     radius: 1,
                     radius2: 1
                 };
 
-            function De(t) {
+            function Ae(t) {
                 return t in Ee
             }
-            const Ae = {
+            const De = {
                 longitude: 1,
                 longitude2: 1,
                 latitude: 1,
                 latitude2: 1
             };
 
             function Se(t) {
@@ -1016,24 +1016,24 @@
                         return "x";
                     case re:
                         return "x2"
                 }
             }
 
             function Ce(t) {
-                return t in Ae
+                return t in De
             }
-            const Fe = bt(Ae),
-                Me = {
+            const Me = bt(De),
+                Fe = {
                     x: 1,
                     y: 1,
                     x2: 1,
                     y2: 1,
                     ...Ee,
-                    ...Ae,
+                    ...De,
                     xOffset: 1,
                     yOffset: 1,
                     color: 1,
                     fill: 1,
                     stroke: 1,
                     opacity: 1,
                     fillOpacity: 1,
@@ -1058,111 +1058,111 @@
             }
             const Te = {
                     row: 1,
                     column: 1,
                     facet: 1
                 },
                 Ne = bt(Te),
-                ze = {
-                    ...Me,
+                Re = {
+                    ...Fe,
                     ...Te
                 },
-                Re = bt(ze),
+                ze = bt(Re),
                 {
                     order: Pe,
                     detail: Le,
-                    tooltip: je,
-                    ...Be
-                } = ze,
+                    tooltip: Be,
+                    ...Ie
+                } = Re,
                 {
-                    row: Ie,
+                    row: je,
                     column: Ue,
                     facet: qe,
                     ...We
-                } = Be;
-            bt(Be), bt(We);
+                } = Ie;
+            bt(Ie), bt(We);
 
             function He(t) {
-                return !!ze[t]
+                return !!Re[t]
             }
-            const Xe = [Gt, $t, ie, re, te, Kt];
+            const Xe = [Jt, Zt, ie, re, te, Kt];
 
-            function Je(t) {
-                return Ge(t) !== t
+            function Ge(t) {
+                return Je(t) !== t
             }
 
-            function Ge(t) {
+            function Je(t) {
                 switch (t) {
-                    case Gt:
+                    case Jt:
                         return Xt;
-                    case $t:
-                        return Jt;
+                    case Zt:
+                        return Gt;
                     case ie:
                         return ee;
                     case re:
                         return ne;
                     case te:
                         return Qt;
                     case Kt:
                         return Vt
                 }
                 return t
             }
 
-            function $e(t) {
-                if (De(t)) switch (t) {
+            function Ze(t) {
+                if (Ae(t)) switch (t) {
                     case Qt:
                         return "startAngle";
                     case te:
                         return "endAngle";
                     case Vt:
                         return "outerRadius";
                     case Kt:
                         return "innerRadius"
                 }
                 return t
             }
 
-            function Ze(t) {
+            function $e(t) {
                 switch (t) {
                     case Xt:
-                        return Gt;
-                    case Jt:
-                        return $t;
+                        return Jt;
+                    case Gt:
+                        return Zt;
                     case ee:
                         return ie;
                     case ne:
                         return re;
                     case Qt:
                         return te;
                     case Vt:
                         return Kt
                 }
             }
 
             function Ye(t) {
                 switch (t) {
                     case Xt:
-                    case Gt:
-                        return "width";
                     case Jt:
-                    case $t:
+                        return "width";
+                    case Gt:
+                    case Zt:
                         return "height"
                 }
             }
 
             function Ve(t) {
                 switch (t) {
                     case Xt:
                         return "xOffset";
-                    case Jt:
-                        return "yOffset";
                     case Gt:
+                        return "yOffset";
+                    case Jt:
                         return "x2Offset";
-                    case $t:
+                    case Zt:
                         return "y2Offset";
                     case Qt:
                         return "thetaOffset";
                     case Vt:
                         return "radiusOffset";
                     case te:
                         return "theta2Offset";
@@ -1171,28 +1171,28 @@
                 }
             }
 
             function Ke(t) {
                 switch (t) {
                     case Xt:
                         return "xOffset";
-                    case Jt:
+                    case Gt:
                         return "yOffset"
                 }
             }
 
             function Qe(t) {
                 switch (t) {
                     case "xOffset":
                         return "x";
                     case "yOffset":
                         return "y"
                 }
             }
-            const tn = bt(Me),
+            const tn = bt(Fe),
                 {
                     x: en,
                     y: nn,
                     x2: rn,
                     y2: on,
                     xOffset: an,
                     yOffset: sn,
@@ -1201,15 +1201,15 @@
                     latitude2: un,
                     longitude2: fn,
                     theta: dn,
                     theta2: hn,
                     radius: pn,
                     radius2: mn,
                     ...gn
-                } = Me,
+                } = Fe,
                 vn = bt(gn),
                 yn = {
                     x: 1,
                     y: 1
                 },
                 bn = bt(yn);
 
@@ -1219,49 +1219,49 @@
             const _n = {
                     theta: 1,
                     radius: 1
                 },
                 wn = bt(_n);
 
             function kn(t) {
-                return "width" === t ? Xt : Jt
+                return "width" === t ? Xt : Gt
             }
             const En = {
                 xOffset: 1,
                 yOffset: 1
             };
             bt(En);
 
-            function Dn(t) {
+            function An(t) {
                 return t in En
             }
             const {
-                text: An,
+                text: Dn,
                 tooltip: Sn,
                 href: Cn,
-                url: Fn,
-                description: Mn,
+                url: Mn,
+                description: Fn,
                 detail: On,
                 key: Tn,
                 order: Nn,
-                ...zn
-            } = gn, Rn = bt(zn);
+                ...Rn
+            } = gn, zn = bt(Rn);
             const Pn = {
                     ...yn,
                     ..._n,
                     ...En,
-                    ...zn
+                    ...Rn
                 },
                 Ln = bt(Pn);
 
-            function jn(t) {
+            function Bn(t) {
                 return !!Pn[t]
             }
 
-            function Bn(t, e) {
+            function In(t, e) {
                 return function(t) {
                     switch (t) {
                         case oe:
                         case ae:
                         case se:
                         case ke:
                         case ye:
@@ -1272,24 +1272,24 @@
                         case fe:
                         case de:
                         case he:
                         case pe:
                         case Ht:
                         case qt:
                         case Wt:
-                            return In;
+                            return jn;
                         case Xt:
-                        case Jt:
-                        case Zt:
+                        case Gt:
+                        case $t:
                         case Yt:
                         case ee:
                         case ne:
                             return qn;
-                        case Gt:
-                        case $t:
+                        case Jt:
+                        case Zt:
                         case ie:
                         case re:
                             return {
                                 area: "always", bar: "always", image: "always", rect: "always", rule: "always", circle: "binned", point: "binned", square: "binned", tick: "binned", line: "binned", trail: "binned"
                             };
                         case le:
                             return {
@@ -1324,15 +1324,15 @@
                         case Kt:
                             return {
                                 arc: "always"
                             }
                     }
                 }(t)[e]
             }
-            const In = {
+            const jn = {
                     arc: "always",
                     area: "always",
                     bar: "always",
                     circle: "always",
                     geoshape: "always",
                     image: "always",
                     line: "always",
@@ -1343,32 +1343,32 @@
                     trail: "always",
                     text: "always",
                     tick: "always"
                 },
                 {
                     geoshape: Un,
                     ...qn
-                } = In;
+                } = jn;
 
             function Wn(t) {
                 switch (t) {
                     case Xt:
-                    case Jt:
+                    case Gt:
                     case Qt:
                     case Vt:
-                    case Zt:
+                    case $t:
                     case Yt:
                     case le:
                     case ue:
                     case pe:
                     case fe:
                     case de:
                     case he:
-                    case Gt:
-                    case $t:
+                    case Jt:
+                    case Zt:
                     case te:
                     case Kt:
                         return;
                     case Ht:
                     case qt:
                     case Wt:
                     case ce:
@@ -1420,35 +1420,35 @@
                 },
                 Xn = {
                     count: 1,
                     min: 1,
                     max: 1
                 };
 
-            function Jn(t) {
+            function Gn(t) {
                 return !!t && !!t.argmin
             }
 
-            function Gn(t) {
+            function Jn(t) {
                 return !!t && !!t.argmax
             }
 
-            function $n(t) {
+            function Zn(t) {
                 return (0, U.HD)(t) && !!Hn[t]
             }
-            const Zn = new Set(["count", "valid", "missing", "distinct"]);
+            const $n = new Set(["count", "valid", "missing", "distinct"]);
 
             function Yn(t) {
-                return (0, U.HD)(t) && Zn.has(t)
+                return (0, U.HD)(t) && $n.has(t)
             }
             const Vn = new Set(["count", "sum", "distinct", "valid", "missing"]),
                 Kn = new Set(["mean", "average", "median", "q1", "q3", "min", "max"]);
 
             function Qn(t) {
-                return (0, U.jn)(t) && (t = ss(t, void 0)), "bin" + bt(t).map((e => ii(t[e]) ? kt("_".concat(e, "_").concat(_t(t[e]))) : kt("_".concat(e, "_").concat(t[e])))).join("")
+                return (0, U.jn)(t) && (t = ds(t, void 0)), "bin" + bt(t).map((e => ii(t[e]) ? kt("_".concat(e, "_").concat(_t(t[e]))) : kt("_".concat(e, "_").concat(t[e])))).join("")
             }
 
             function ti(t) {
                 return !0 === t || ni(t) && !t.binned
             }
 
             function ei(t) {
@@ -1739,35 +1739,35 @@
                 return r && void 0 !== e[r] ? e[r] : void 0 !== e[t] ? e[t] : !o || r && r !== t ? Ei(t, e, n, i) : void 0
             }
 
             function Ei(t, e, n) {
                 let {
                     vgChannel: i
                 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
-                return zt(i ? Di(t, e, n.style) : void 0, Di(t, e, n.style), i ? n[e.type][i] : void 0, n[e.type][t], i ? n.mark[i] : n.mark[t])
+                return Rt(i ? Ai(t, e, n.style) : void 0, Ai(t, e, n.style), i ? n[e.type][i] : void 0, n[e.type][t], i ? n.mark[i] : n.mark[t])
             }
 
-            function Di(t, e, n) {
-                return Ai(t, wi(e), n)
+            function Ai(t, e, n) {
+                return Di(t, wi(e), n)
             }
 
-            function Ai(t, e, n) {
+            function Di(t, e, n) {
                 let i;
                 e = (0, U.IX)(e);
                 for (const r of e) {
                     const e = n[r];
                     e && void 0 !== e[t] && (i = e[t])
                 }
                 return i
             }
 
             function Si(t, e) {
                 return (0, U.IX)(t).reduce(((t, n) => {
                     var i;
-                    return t.field.push(Ga(n, e)), t.order.push(null !== (i = n.sort) && void 0 !== i ? i : "ascending"), t
+                    return t.field.push(Ka(n, e)), t.order.push(null !== (i = n.sort) && void 0 !== i ? i : "ascending"), t
                 }), {
                     field: [],
                     order: []
                 })
             }
 
             function Ci(t, e) {
@@ -1775,28 +1775,28 @@
                 return e.forEach((t => {
                     for (const e of n)
                         if (Q(e, t)) return;
                     n.push(t)
                 })), n
             }
 
-            function Fi(t, e) {
+            function Mi(t, e) {
                 return Q(t, e) || !e ? t : t ? [...(0, U.IX)(t), ...(0, U.IX)(e)].join(", ") : e
             }
 
-            function Mi(t, e) {
+            function Fi(t, e) {
                 const n = t.value,
                     i = e.value;
                 if (null == n || null === i) return {
                     explicit: t.explicit,
                     value: null
                 };
                 if ((ci(n) || li(n)) && (ci(i) || li(i))) return {
                     explicit: t.explicit,
-                    value: Fi(n, i)
+                    value: Mi(n, i)
                 };
                 if (ci(n) || li(n)) return {
                     explicit: t.explicit,
                     value: n
                 };
                 if (ci(i) || li(i)) return {
                     explicit: t.explicit,
@@ -1814,39 +1814,39 @@
             }
             const Ti = 'Autosize "fit" only works for single views and layered views.';
 
             function Ni(t) {
                 return "".concat("width" == t ? "Width" : "Height", ' "container" only works for single views and layered views.')
             }
 
-            function zi(t) {
+            function Ri(t) {
                 const e = "width" == t ? "x" : "y";
                 return "".concat("width" == t ? "Width" : "Height", ' "container" only works well with autosize "fit" or "fit-').concat(e, '".')
             }
 
-            function Ri(t) {
+            function zi(t) {
                 return t ? 'Dropping "fit-'.concat(t, '" because spec has discrete ').concat(Ye(t), ".") : 'Dropping "fit" because spec has discrete size.'
             }
 
             function Pi(t) {
                 return "Unknown field for ".concat(t, ". Cannot calculate view size.")
             }
 
             function Li(t) {
                 return 'Cannot project a selection on encoding channel "'.concat(t, '", which has no field.')
             }
 
-            function ji(t, e) {
+            function Bi(t, e) {
                 return 'Cannot project a selection on encoding channel "'.concat(t, '" as it uses an aggregate function ("').concat(e, '").')
             }
 
-            function Bi(t) {
+            function Ii(t) {
                 return "Selection not supported for ".concat(t, " yet.")
             }
-            const Ii = "The same selection must be used to override scale domains in a layered view.";
+            const ji = "The same selection must be used to override scale domains in a layered view.";
 
             function Ui(t) {
                 return 'The "columns" property cannot be used when "'.concat(t, '" has nested row/column.')
             }
 
             function qi(t, e, n) {
                 return 'An ancestor parsed field "'.concat(t, '" as ').concat(n, " but a child wants to parse the field as ").concat(e, ".")
@@ -1860,31 +1860,31 @@
                 return "".concat(t, "Offset dropped because ").concat(t, " is continuous")
             }
 
             function Xi(t) {
                 return "There is no ".concat(t, " encoding. Replacing ").concat(t, "Offset encoding as ").concat(t, ".")
             }
 
-            function Ji(t) {
+            function Gi(t) {
                 return 'Invalid field type "'.concat(t, '".')
             }
 
-            function Gi(t, e) {
+            function Ji(t, e) {
                 const {
                     fill: n,
                     stroke: i
                 } = e;
                 return "Dropping color ".concat(t, " as the plot also has ").concat(n && i ? "fill and stroke" : n ? "fill" : "stroke", ".")
             }
 
-            function $i(t, e) {
+            function Zi(t, e) {
                 return "Dropping ".concat(rt(t), ' from channel "').concat(e, '" since it does not contain any data field, datum, value, or signal.')
             }
 
-            function Zi(t, e, n) {
+            function $i(t, e, n) {
                 return "".concat(t, ' dropped as it is incompatible with "').concat(e, '"').concat(n ? " when ".concat(n) : "", ".")
             }
 
             function Yi(t) {
                 return "".concat(t, " encoding has no scale, so specified scale is ignored.")
             }
 
@@ -2019,224 +2019,269 @@
                     minutes: 1,
                     seconds: 1,
                     milliseconds: 1
                 },
                 _r = bt(xr);
 
             function wr(t) {
+                return (0, U.Kn)(t) ? t.binned : kr(t)
+            }
+
+            function kr(t) {
+                return t && t.startsWith("binned")
+            }
+
+            function Er(t) {
                 return t.startsWith("utc")
             }
-            const kr = {
+            const Ar = {
                 "year-month": "%b %Y ",
                 "year-month-date": "%b %d, %Y "
             };
 
-            function Er(t) {
-                return _r.filter((e => Dr(t, e)))
+            function Dr(t) {
+                return _r.filter((e => Cr(t, e)))
             }
 
-            function Dr(t, e) {
+            function Sr(t) {
+                const e = Dr(t);
+                return e[e.length - 1]
+            }
+
+            function Cr(t, e) {
                 const n = t.indexOf(e);
                 return !(n < 0) && (!(n > 0 && "seconds" === e && "i" === t.charAt(n - 1)) && (!(t.length > n + 3 && "day" === e && "o" === t.charAt(n + 3)) && !(n > 0 && "year" === e && "f" === t.charAt(n - 1))))
             }
 
-            function Ar(t, e) {
+            function Mr(t, e) {
                 let {
                     end: n
                 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                     end: !1
                 };
                 const i = St(e),
-                    r = wr(t) ? "utc" : "";
+                    r = Er(t) ? "utc" : "";
                 let o;
                 const a = {};
-                for (const c of _r) Dr(t, c) && (a[c] = "quarter" === (s = c) ? "(".concat(r, "quarter(").concat(i, ")-1)") : "".concat(r).concat(s, "(").concat(i, ")"), o = c);
+                for (const c of _r) Cr(t, c) && (a[c] = "quarter" === (s = c) ? "(".concat(r, "quarter(").concat(i, ")-1)") : "".concat(r).concat(s, "(").concat(i, ")"), o = c);
                 var s;
                 return n && (a[o] += "+1"),
                     function(t) {
                         const e = yr(t, !1).join(", ");
                         return t.utc ? "utc(".concat(e, ")") : "datetime(".concat(e, ")")
                     }(a)
             }
 
-            function Sr(t) {
+            function Fr(t) {
                 if (!t) return;
-                const e = Er(t);
-                return "timeUnitSpecifier(".concat(rt(e), ", ").concat(rt(kr), ")")
+                const e = Dr(t);
+                return "timeUnitSpecifier(".concat(rt(e), ", ").concat(rt(Ar), ")")
             }
 
-            function Cr(t) {
+            function Or(t) {
                 if (!t) return;
                 let e;
-                return (0, U.HD)(t) ? e = {
+                return (0, U.HD)(t) ? e = kr(t) ? {
+                    unit: t.substring(6),
+                    binned: !0
+                } : {
                     unit: t
                 } : (0, U.Kn)(t) && (e = {
                     ...t,
                     ...t.unit ? {
                         unit: t.unit
                     } : {}
-                }), wr(e.unit) && (e.utc = !0, e.unit = function(t) {
-                    return t.substr(3)
+                }), Er(e.unit) && (e.utc = !0, e.unit = function(t) {
+                    return t.substring(3)
                 }(e.unit)), e
             }
 
-            function Fr(t) {
+            function Tr(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t => t;
-                const n = Cr(t),
-                    i = function(t) {
-                        const e = Er(t);
-                        return e[e.length - 1]
-                    }(n.unit);
+                const n = Or(t),
+                    i = Sr(n.unit);
                 if (i && "day" !== i) {
                     const t = {
                             year: 2001,
                             month: 1,
                             date: 1,
                             hours: 0,
                             minutes: 0,
                             seconds: 0,
                             milliseconds: 0
                         },
-                        r = n.step || 1,
-                        o = {
+                        {
+                            step: r,
+                            part: o
+                        } = Rr(i, n.step),
+                        a = {
                             ...t,
-                            ..."quarter" === i ? {
-                                month: +t.month + 3 * r
-                            } : "week" === i ? {
-                                date: +t.date + 7 * r
-                            } : {
-                                [i]: +t[i] + r
-                            }
+                            [o]: +t[o] + r
                         };
-                    return "".concat(e(br(o)), " - ").concat(e(br(t)))
+                    return "".concat(e(br(a)), " - ").concat(e(br(t)))
                 }
             }
+            const Nr = {
+                year: 1,
+                month: 1,
+                date: 1,
+                hours: 1,
+                minutes: 1,
+                seconds: 1,
+                milliseconds: 1
+            };
 
-            function Mr(t) {
+            function Rr(t) {
+                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
+                if (function(t) {
+                        return !!Nr[t]
+                    }(t)) return {
+                    part: t,
+                    step: e
+                };
+                switch (t) {
+                    case "day":
+                    case "dayofyear":
+                        return {
+                            part: "date", step: e
+                        };
+                    case "quarter":
+                        return {
+                            part: "month", step: 3 * e
+                        };
+                    case "week":
+                        return {
+                            part: "date", step: 7 * e
+                        }
+                }
+            }
+
+            function zr(t) {
                 return !(null === t || void 0 === t || !t.field) && void 0 !== t.equal
             }
 
-            function Or(t) {
+            function Pr(t) {
                 return !(null === t || void 0 === t || !t.field) && void 0 !== t.lt
             }
 
-            function Tr(t) {
+            function Lr(t) {
                 return !(null === t || void 0 === t || !t.field) && void 0 !== t.lte
             }
 
-            function Nr(t) {
+            function Br(t) {
                 return !(null === t || void 0 === t || !t.field) && void 0 !== t.gt
             }
 
-            function zr(t) {
+            function Ir(t) {
                 return !(null === t || void 0 === t || !t.field) && void 0 !== t.gte
             }
 
-            function Rr(t) {
+            function jr(t) {
                 if (null !== t && void 0 !== t && t.field) {
                     if ((0, U.kJ)(t.range) && 2 === t.range.length) return !0;
                     if (li(t.range)) return !0
                 }
                 return !1
             }
 
-            function Pr(t) {
+            function Ur(t) {
                 return !(null === t || void 0 === t || !t.field) && ((0, U.kJ)(t.oneOf) || (0, U.kJ)(t.in))
             }
 
-            function Lr(t) {
-                return Pr(t) || Mr(t) || Rr(t) || Or(t) || Nr(t) || Tr(t) || zr(t)
+            function qr(t) {
+                return Ur(t) || zr(t) || jr(t) || Pr(t) || Br(t) || Lr(t) || Ir(t)
             }
 
-            function jr(t, e) {
-                return us(t, {
+            function Wr(t, e) {
+                return ms(t, {
                     timeUnit: e,
                     wrapTime: !0
                 })
             }
 
-            function Br(t) {
-                var e;
-                let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
+            function Hr(t) {
+                let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                 const {
-                    field: i
-                } = t, r = null === (e = Cr(t.timeUnit)) || void 0 === e ? void 0 : e.unit, o = r ? "time(".concat(Ar(r, i), ")") : Ga(t, {
+                    field: n
+                } = t, i = Or(t.timeUnit), {
+                    unit: r,
+                    binned: o
+                } = i || {}, a = Ka(t, {
                     expr: "datum"
-                });
-                if (Mr(t)) return "".concat(o, "===").concat(jr(t.equal, r));
-                if (Or(t)) {
+                }), s = r ? "time(".concat(o ? a : Mr(r, n), ")") : a;
+                if (zr(t)) return "".concat(s, "===").concat(Wr(t.equal, r));
+                if (Pr(t)) {
                     const e = t.lt;
-                    return "".concat(o, "<").concat(jr(e, r))
+                    return "".concat(s, "<").concat(Wr(e, r))
                 }
-                if (Nr(t)) {
+                if (Br(t)) {
                     const e = t.gt;
-                    return "".concat(o, ">").concat(jr(e, r))
+                    return "".concat(s, ">").concat(Wr(e, r))
                 }
-                if (Tr(t)) {
+                if (Lr(t)) {
                     const e = t.lte;
-                    return "".concat(o, "<=").concat(jr(e, r))
+                    return "".concat(s, "<=").concat(Wr(e, r))
                 }
-                if (zr(t)) {
+                if (Ir(t)) {
                     const e = t.gte;
-                    return "".concat(o, ">=").concat(jr(e, r))
+                    return "".concat(s, ">=").concat(Wr(e, r))
                 }
-                if (Pr(t)) return "indexof([".concat(function(t, e) {
-                    return t.map((t => jr(t, e)))
-                }(t.oneOf, r).join(","), "], ").concat(o, ") !== -1");
+                if (Ur(t)) return "indexof([".concat(function(t, e) {
+                    return t.map((t => Wr(t, e)))
+                }(t.oneOf, r).join(","), "], ").concat(s, ") !== -1");
                 if (function(t) {
                         return !(null === t || void 0 === t || !t.field) && void 0 !== t.valid
-                    }(t)) return Ir(o, t.valid);
-                if (Rr(t)) {
+                    }(t)) return Xr(s, t.valid);
+                if (jr(t)) {
                     const {
-                        range: e
-                    } = t, i = li(e) ? {
-                        signal: "".concat(e.signal, "[0]")
-                    } : e[0], a = li(e) ? {
-                        signal: "".concat(e.signal, "[1]")
-                    } : e[1];
-                    if (null !== i && null !== a && n) return "inrange(" + o + ", [" + jr(i, r) + ", " + jr(a, r) + "])";
-                    const s = [];
-                    return null !== i && s.push("".concat(o, " >= ").concat(jr(i, r))), null !== a && s.push("".concat(o, " <= ").concat(jr(a, r))), s.length > 0 ? s.join(" && ") : "true"
+                        range: n
+                    } = t, i = li(n) ? {
+                        signal: "".concat(n.signal, "[0]")
+                    } : n[0], o = li(n) ? {
+                        signal: "".concat(n.signal, "[1]")
+                    } : n[1];
+                    if (null !== i && null !== o && e) return "inrange(" + s + ", [" + Wr(i, r) + ", " + Wr(o, r) + "])";
+                    const a = [];
+                    return null !== i && a.push("".concat(s, " >= ").concat(Wr(i, r))), null !== o && a.push("".concat(s, " <= ").concat(Wr(o, r))), a.length > 0 ? a.join(" && ") : "true"
                 }
                 throw new Error("Invalid field predicate: ".concat(rt(t)))
             }
 
-            function Ir(t) {
+            function Xr(t) {
                 return !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? "isValid(".concat(t, ") && isFinite(+").concat(t, ")") : "!isValid(".concat(t, ") || !isFinite(+").concat(t, ")")
             }
 
-            function Ur(t) {
-                var e;
-                return Lr(t) && t.timeUnit ? {
+            function Gr(t) {
+                return qr(t) && t.timeUnit ? {
                     ...t,
-                    timeUnit: null === (e = Cr(t.timeUnit)) || void 0 === e ? void 0 : e.unit
+                    timeUnit: Or(t.timeUnit)
                 } : t
             }
-            const qr = {
+            const Jr = {
                 quantitative: "quantitative",
                 ordinal: "ordinal",
                 temporal: "temporal",
                 nominal: "nominal",
                 geojson: "geojson"
             };
 
-            function Wr(t) {
+            function Zr(t) {
                 return "quantitative" === t || "temporal" === t
             }
 
-            function Hr(t) {
+            function $r(t) {
                 return "ordinal" === t || "nominal" === t
             }
-            const Xr = qr.quantitative,
-                Jr = qr.ordinal,
-                Gr = qr.temporal,
-                $r = qr.nominal,
-                Zr = qr.geojson;
-            bt(qr);
-            const Yr = {
+            const Yr = Jr.quantitative,
+                Vr = Jr.ordinal,
+                Kr = Jr.temporal,
+                Qr = Jr.nominal,
+                to = Jr.geojson;
+            bt(Jr);
+            const eo = {
                     LINEAR: "linear",
                     LOG: "log",
                     POW: "pow",
                     SQRT: "sqrt",
                     SYMLOG: "symlog",
                     IDENTITY: "identity",
                     SEQUENTIAL: "sequential",
@@ -2246,15 +2291,15 @@
                     QUANTIZE: "quantize",
                     THRESHOLD: "threshold",
                     BIN_ORDINAL: "bin-ordinal",
                     ORDINAL: "ordinal",
                     POINT: "point",
                     BAND: "band"
                 },
-                Vr = {
+                no = {
                     linear: "numeric",
                     log: "numeric",
                     pow: "numeric",
                     sqrt: "numeric",
                     symlog: "numeric",
                     identity: "numeric",
                     sequential: "numeric",
@@ -2264,22 +2309,22 @@
                     "bin-ordinal": "bin-ordinal",
                     point: "ordinal-position",
                     band: "ordinal-position",
                     quantile: "discretizing",
                     quantize: "discretizing",
                     threshold: "discretizing"
                 };
-            bt(Vr);
+            bt(no);
 
-            function Kr(t, e) {
-                const n = Vr[t],
-                    i = Vr[e];
+            function io(t, e) {
+                const n = no[t],
+                    i = no[e];
                 return n === i || "ordinal-position" === n && "time" === i || "ordinal-position" === i && "time" === n
             }
-            const Qr = {
+            const ro = {
                 linear: 0,
                 log: 1,
                 pow: 1,
                 sqrt: 1,
                 symlog: 1,
                 identity: 1,
                 sequential: 1,
@@ -2290,53 +2335,54 @@
                 ordinal: 0,
                 "bin-ordinal": 0,
                 quantile: 0,
                 quantize: 0,
                 threshold: 0
             };
 
-            function to(t) {
-                return Qr[t]
+            function oo(t) {
+                return ro[t]
             }
-            const eo = new Set(["linear", "log", "pow", "sqrt", "symlog"]),
-                no = new Set([...eo, "time", "utc"]);
+            const ao = new Set(["linear", "log", "pow", "sqrt", "symlog"]),
+                so = new Set([...ao, "time", "utc"]);
 
-            function io(t) {
-                return eo.has(t)
+            function co(t) {
+                return ao.has(t)
             }
-            const ro = new Set(["quantile", "quantize", "threshold"]),
-                oo = new Set([...no, ...ro, "sequential", "identity"]),
-                ao = new Set(["ordinal", "bin-ordinal", "point", "band"]);
+            const lo = new Set(["quantile", "quantize", "threshold"]),
+                uo = new Set([...so, ...lo, "sequential", "identity"]),
+                fo = new Set(["ordinal", "bin-ordinal", "point", "band"]);
             new Set(["time", "utc"]);
 
-            function so(t) {
-                return ao.has(t)
+            function ho(t) {
+                return fo.has(t)
             }
 
-            function co(t) {
-                return oo.has(t)
+            function po(t) {
+                return uo.has(t)
             }
 
-            function lo(t) {
-                return no.has(t)
+            function mo(t) {
+                return so.has(t)
             }
 
-            function uo(t) {
-                return ro.has(t)
+            function go(t) {
+                return lo.has(t)
             }
 
-            function fo(t) {
+            function vo(t) {
                 return null === t || void 0 === t ? void 0 : t.param
             }
-            const ho = {
+            const yo = {
                     type: 1,
                     domain: 1,
                     domainMax: 1,
                     domainMin: 1,
                     domainMid: 1,
+                    domainRaw: 1,
                     align: 1,
                     range: 1,
                     rangeMax: 1,
                     rangeMin: 1,
                     scheme: 1,
                     bins: 1,
                     reverse: 1,
@@ -2349,77 +2395,79 @@
                     interpolate: 1,
                     zero: 1,
                     padding: 1,
                     paddingInner: 1,
                     paddingOuter: 1
                 },
                 {
-                    type: po,
-                    domain: mo,
-                    range: go,
-                    rangeMax: vo,
-                    rangeMin: yo,
-                    scheme: bo,
-                    ...xo
-                } = (bt(ho), ho),
-                _o = bt(xo);
+                    type: bo,
+                    domain: xo,
+                    range: _o,
+                    rangeMax: wo,
+                    rangeMin: ko,
+                    scheme: Eo,
+                    ...Ao
+                } = (bt(yo), yo),
+                Do = bt(Ao);
 
-            function wo(t, e) {
+            function So(t, e) {
                 switch (e) {
                     case "type":
                     case "domain":
                     case "reverse":
                     case "range":
                         return !0;
                     case "scheme":
                     case "interpolate":
                         return !["point", "band", "identity"].includes(t);
                     case "bins":
                         return !["point", "band", "identity", "ordinal"].includes(t);
                     case "round":
-                        return lo(t) || "band" === t || "point" === t;
+                        return mo(t) || "band" === t || "point" === t;
                     case "padding":
                     case "rangeMin":
                     case "rangeMax":
-                        return lo(t) || ["point", "band"].includes(t);
+                        return mo(t) || ["point", "band"].includes(t);
                     case "paddingOuter":
                     case "align":
                         return ["point", "band"].includes(t);
                     case "paddingInner":
                         return "band" === t;
                     case "domainMax":
                     case "domainMid":
                     case "domainMin":
+                    case "domainRaw":
                     case "clamp":
-                        return lo(t);
+                        return mo(t);
                     case "nice":
-                        return lo(t) || "quantize" === t || "threshold" === t;
+                        return mo(t) || "quantize" === t || "threshold" === t;
                     case "exponent":
                         return "pow" === t;
                     case "base":
                         return "log" === t;
                     case "constant":
                         return "symlog" === t;
                     case "zero":
-                        return co(t) && !st(["log", "time", "utc", "threshold", "quantile"], t)
+                        return po(t) && !st(["log", "time", "utc", "threshold", "quantile"], t)
                 }
             }
 
-            function ko(t, e) {
+            function Co(t, e) {
                 switch (e) {
                     case "interpolate":
                     case "scheme":
                     case "domainMid":
                         return Oe(t) ? void 0 : 'Cannot use the scale property "'.concat(e, '" with non-color channel.');
                     case "align":
                     case "type":
                     case "bins":
                     case "domain":
                     case "domainMax":
                     case "domainMin":
+                    case "domainRaw":
                     case "range":
                     case "base":
                     case "exponent":
                     case "constant":
                     case "nice":
                     case "padding":
                     case "paddingInner":
@@ -2429,15 +2477,15 @@
                     case "reverse":
                     case "round":
                     case "clamp":
                     case "zero":
                         return
                 }
             }
-            const Eo = {
+            const Mo = {
                     arc: "arc",
                     area: "area",
                     bar: "bar",
                     image: "image",
                     line: "line",
                     point: "point",
                     rect: "rect",
@@ -2445,53 +2493,53 @@
                     text: "text",
                     tick: "tick",
                     trail: "trail",
                     circle: "circle",
                     square: "square",
                     geoshape: "geoshape"
                 },
-                Do = Eo.arc,
-                Ao = Eo.area,
-                So = Eo.bar,
-                Co = Eo.image,
-                Fo = Eo.line,
-                Mo = Eo.point,
-                Oo = Eo.rect,
-                To = Eo.rule,
-                No = Eo.text,
-                zo = Eo.tick,
-                Ro = Eo.trail,
-                Po = Eo.circle,
-                Lo = Eo.square,
-                jo = Eo.geoshape;
+                Fo = Mo.arc,
+                Oo = Mo.area,
+                To = Mo.bar,
+                No = Mo.image,
+                Ro = Mo.line,
+                zo = Mo.point,
+                Po = Mo.rect,
+                Lo = Mo.rule,
+                Bo = Mo.text,
+                Io = Mo.tick,
+                jo = Mo.trail,
+                Uo = Mo.circle,
+                qo = Mo.square,
+                Wo = Mo.geoshape;
 
-            function Bo(t) {
+            function Ho(t) {
                 return ["line", "area", "trail"].includes(t)
             }
 
-            function Io(t) {
+            function Xo(t) {
                 return ["rect", "bar", "image", "arc"].includes(t)
             }
-            const Uo = new Set(bt(Eo));
+            const Go = new Set(bt(Mo));
 
-            function qo(t) {
+            function Jo(t) {
                 return t.type
             }
-            const Wo = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit", "fill", "fillOpacity"],
-                Ho = bt({
+            const Zo = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit", "fill", "fillOpacity"],
+                $o = bt({
                     color: 1,
                     filled: 1,
                     invalid: 1,
                     order: 1,
                     radius2: 1,
                     theta2: 1,
                     timeUnitBandSize: 1,
                     timeUnitBandPosition: 1
                 }),
-                Xo = bt({
+                Yo = bt({
                     mark: 1,
                     arc: 1,
                     area: 1,
                     bar: 1,
                     circle: 1,
                     image: 1,
                     line: 1,
@@ -2501,116 +2549,118 @@
                     square: 1,
                     text: 1,
                     tick: 1,
                     trail: 1,
                     geoshape: 1
                 });
 
-            function Jo(t) {
+            function Vo(t) {
                 return t && void 0 != t.band
             }
-            const Go = {
+            const Ko = {
                     horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
                     vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
                 },
-                $o = {
+                Qo = {
                     binSpacing: 1,
                     continuousBandSize: 5,
+                    minBandSize: .25,
                     timeUnitBandPosition: .5
                 },
-                Zo = {
+                ta = {
                     binSpacing: 0,
                     continuousBandSize: 5,
+                    minBandSize: .25,
                     timeUnitBandPosition: .5
                 };
 
-            function Yo(t) {
+            function ea(t) {
                 const {
                     channel: e,
                     channelDef: n,
                     markDef: i,
                     scale: r,
                     config: o
-                } = t, a = ea(t);
-                return Na(n) && !Yn(n.aggregate) && r && lo(r.get("type")) ? function(t) {
+                } = t, a = aa(t);
+                return Ba(n) && !Yn(n.aggregate) && r && mo(r.get("type")) ? function(t) {
                     let {
                         fieldDef: e,
                         channel: n,
                         markDef: i,
                         ref: r,
                         config: o
                     } = t;
-                    if (Bo(i.type)) return r;
+                    if (Ho(i.type)) return r;
                     const a = ki("invalid", i, o);
-                    if (null === a) return [Vo(e, n), r];
+                    if (null === a) return [na(e, n), r];
                     return r
                 }({
                     fieldDef: n,
                     channel: e,
                     markDef: i,
                     ref: a,
                     config: o
                 }) : a
             }
 
-            function Vo(t, e) {
+            function na(t, e) {
                 return {
-                    test: Ko(t, !0),
-                    ..."y" === Ge(e) ? {
+                    test: ia(t, !0),
+                    ..."y" === Je(e) ? {
                         field: {
                             group: "height"
                         }
                     } : {
                         value: 0
                     }
                 }
             }
 
-            function Ko(t) {
+            function ia(t) {
                 let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
-                return Ir((0, U.HD)(t) ? t : Ga(t, {
+                return Xr((0, U.HD)(t) ? t : Ka(t, {
                     expr: "datum"
                 }), !e)
             }
 
-            function Qo(t, e, n, i) {
+            function ra(t, e, n, i) {
                 const r = {};
-                if (e && (r.scale = e), Ra(t)) {
+                if (e && (r.scale = e), ja(t)) {
                     const {
                         datum: e
                     } = t;
                     hr(e) ? r.signal = br(e) : li(e) ? r.signal = e.signal : oi(e) ? r.signal = e.expr : r.value = e
-                } else r.field = Ga(t, n);
+                } else r.field = Ka(t, n);
                 if (i) {
                     const {
                         offset: t,
                         band: e
                     } = i;
                     t && (r.offset = t), e && (r.band = e)
                 }
                 return r
             }
 
-            function ta(t) {
+            function oa(t) {
                 let {
                     scaleName: e,
                     fieldOrDatumDef: n,
                     fieldOrDatumDef2: i,
                     offset: r,
                     startSuffix: o,
                     bandPosition: a = .5
                 } = t;
                 const s = 0 < a && a < 1 ? "datum" : void 0,
-                    c = Ga(n, {
+                    c = Ka(n, {
                         expr: s,
                         suffix: o
                     }),
-                    l = void 0 !== i ? Ga(i, {
+                    l = void 0 !== i ? Ka(i, {
                         expr: s
-                    }) : Ga(n, {
+                    }) : Ka(n, {
                         suffix: "end",
                         expr: s
                     }),
                     u = {};
                 if (0 === a || 1 === a) {
                     u.scale = e;
                     const t = 0 === a ? c : l;
@@ -2618,366 +2668,366 @@
                 } else {
                     const t = li(a) ? "".concat(a.signal, " * ").concat(c, " + (1-").concat(a.signal, ") * ").concat(l) : "".concat(a, " * ").concat(c, " + ").concat(1 - a, " * ").concat(l);
                     u.signal = 'scale("'.concat(e, '", ').concat(t, ")")
                 }
                 return r && (u.offset = r), u
             }
 
-            function ea(t) {
+            function aa(t) {
                 let {
                     channel: e,
                     channelDef: n,
                     channel2Def: i,
                     markDef: r,
                     config: o,
                     scaleName: a,
                     scale: s,
                     stack: c,
                     offset: l,
                     defaultRef: u,
                     bandPosition: f
                 } = t;
                 if (n) {
-                    if (Ba(n)) {
+                    if (Ha(n)) {
                         var d, h;
                         const t = null === s || void 0 === s ? void 0 : s.get("type");
-                        if (Ia(n)) {
+                        if (Xa(n)) {
                             var p;
-                            null !== (p = f) && void 0 !== p || (f = Aa({
+                            null !== (p = f) && void 0 !== p || (f = Oa({
                                 fieldDef: n,
                                 fieldDef2: i,
                                 markDef: r,
                                 config: o
                             }));
                             const {
                                 bin: s,
                                 timeUnit: u,
                                 type: d
                             } = n;
-                            if (ti(s) || f && u && d === Gr) return null !== c && void 0 !== c && c.impute ? Qo(n, a, {
+                            if (ti(s) || f && u && d === Kr) return null !== c && void 0 !== c && c.impute ? ra(n, a, {
                                 binSuffix: "mid"
                             }, {
                                 offset: l
-                            }) : f && !so(t) ? ta({
+                            }) : f && !ho(t) ? oa({
                                 scaleName: a,
                                 fieldOrDatumDef: n,
                                 bandPosition: f,
                                 offset: l
-                            }) : Qo(n, a, ds(n, e) ? {
+                            }) : ra(n, a, vs(n, e) ? {
                                 binSuffix: "range"
                             } : {}, {
                                 offset: l
                             });
                             if (ei(s)) {
-                                if (Na(i)) return ta({
+                                if (Ba(i)) return oa({
                                     scaleName: a,
                                     fieldOrDatumDef: n,
                                     fieldOrDatumDef2: i,
                                     bandPosition: f,
                                     offset: l
                                 });
-                                dr(cr(e === Xt ? Gt : $t))
+                                dr(cr(e === Xt ? Jt : Zt))
                             }
                         }
-                        return Qo(n, a, so(t) ? {
+                        return ra(n, a, ho(t) ? {
                             binSuffix: "range"
                         } : {}, {
                             offset: l,
                             band: "band" === t ? null !== (d = null !== (h = f) && void 0 !== h ? h : n.bandPosition) && void 0 !== d ? d : .5 : void 0
                         })
                     }
-                    if (Ua(n)) {
+                    if (Ga(n)) {
                         const t = l ? {
                             offset: l
                         } : {};
                         return {
-                            ...na(e, n.value),
+                            ...sa(e, n.value),
                             ...t
                         }
                     }
                 }
                 return (0, U.mf)(u) && (u = u()), u ? {
                     ...u,
                     ...l ? {
                         offset: l
                     } : {}
                 } : u
             }
 
-            function na(t, e) {
+            function sa(t, e) {
                 return st(["x", "x2"], t) && "width" === e ? {
                     field: {
                         group: "width"
                     }
                 } : st(["y", "y2"], t) && "height" === e ? {
                     field: {
                         group: "height"
                     }
                 } : yi(e)
             }
 
-            function ia(t) {
+            function ca(t) {
                 return t && "number" !== t && "time" !== t
             }
 
-            function ra(t, e, n) {
+            function la(t, e, n) {
                 return "".concat(t, "(").concat(e).concat(n ? ", ".concat(rt(n)) : "", ")")
             }
-            const oa = " \u2013 ";
+            const ua = " \u2013 ";
 
-            function aa(t) {
+            function fa(t) {
                 let {
                     fieldOrDatumDef: e,
                     format: n,
                     formatType: i,
                     expr: r,
                     normalizeStack: o,
                     config: a
                 } = t;
-                if (ia(i)) return ca({
+                if (ca(i)) return ha({
                     fieldOrDatumDef: e,
                     format: n,
                     formatType: i,
                     expr: r,
                     config: a
                 });
-                const s = sa(e, r, o),
-                    c = za(e);
+                const s = da(e, r, o),
+                    c = Ia(e);
                 if (void 0 === n && void 0 === i && a.customFormatTypes) {
                     if ("quantitative" === c) {
-                        if (o && a.normalizedNumberFormatType) return ca({
+                        if (o && a.normalizedNumberFormatType) return ha({
                             fieldOrDatumDef: e,
                             format: a.normalizedNumberFormat,
                             formatType: a.normalizedNumberFormatType,
                             expr: r,
                             config: a
                         });
-                        if (a.numberFormatType) return ca({
+                        if (a.numberFormatType) return ha({
                             fieldOrDatumDef: e,
                             format: a.numberFormat,
                             formatType: a.numberFormatType,
                             expr: r,
                             config: a
                         })
                     }
-                    if ("temporal" === c && a.timeFormatType && Na(e) && void 0 === e.timeUnit) return ca({
+                    if ("temporal" === c && a.timeFormatType && Ba(e) && void 0 === e.timeUnit) return ha({
                         fieldOrDatumDef: e,
                         format: a.timeFormat,
                         formatType: a.timeFormatType,
                         expr: r,
                         config: a
                     })
                 }
-                if (ls(e)) {
+                if (ps(e)) {
                     var l, u;
                     const t = function(t) {
                         let {
                             field: e,
                             timeUnit: n,
                             format: i,
                             formatType: r,
                             rawTimeFormat: o,
                             isUTCScale: a
                         } = t;
                         return !n || i ? !n && r ? "".concat(r, "(").concat(e, ", '").concat(i, "')") : (i = (0, U.HD)(i) ? i : o, "".concat(a ? "utc" : "time", "Format(").concat(e, ", '").concat(i, "')")) : function(t, e, n) {
                             if (!t) return;
-                            const i = Sr(t),
-                                r = n || wr(t);
+                            const i = Fr(t),
+                                r = n || Er(t);
                             return "".concat(r ? "utc" : "time", "Format(").concat(e, ", ").concat(i, ")")
                         }(n, e, a)
                     }({
                         field: s,
-                        timeUnit: Na(e) ? null === (l = Cr(e.timeUnit)) || void 0 === l ? void 0 : l.unit : void 0,
+                        timeUnit: Ba(e) ? null === (l = Or(e.timeUnit)) || void 0 === l ? void 0 : l.unit : void 0,
                         format: n,
                         formatType: a.timeFormatType,
                         rawTimeFormat: a.timeFormat,
-                        isUTCScale: qa(e) && (null === (u = e.scale) || void 0 === u ? void 0 : u.type) === Yr.UTC
+                        isUTCScale: Ja(e) && (null === (u = e.scale) || void 0 === u ? void 0 : u.type) === eo.UTC
                     });
                     return t ? {
                         signal: t
                     } : void 0
                 }
-                if (n = fa({
+                if (n = ga({
                         type: c,
                         specifiedFormat: n,
                         config: a,
                         normalizeStack: o
-                    }), Na(e) && ti(e.bin)) {
+                    }), Ba(e) && ti(e.bin)) {
                     return {
-                        signal: pa(s, Ga(e, {
+                        signal: ba(s, Ka(e, {
                             expr: r,
                             binSuffix: "end"
                         }), n, i, a)
                     }
                 }
-                return n || "quantitative" === za(e) ? {
-                    signal: "".concat(da(s, n))
+                return n || "quantitative" === Ia(e) ? {
+                    signal: "".concat(va(s, n))
                 } : {
                     signal: "isValid(".concat(s, ") ? ").concat(s, ' : ""+').concat(s)
                 }
             }
 
-            function sa(t, e, n) {
-                return Na(t) ? n ? "".concat(Ga(t, {
+            function da(t, e, n) {
+                return Ba(t) ? n ? "".concat(Ka(t, {
                     expr: e,
                     suffix: "end"
-                }), "-").concat(Ga(t, {
+                }), "-").concat(Ka(t, {
                     expr: e,
                     suffix: "start"
-                })) : Ga(t, {
+                })) : Ka(t, {
                     expr: e
                 }) : function(t) {
                     const {
                         datum: e
                     } = t;
                     return hr(e) ? br(e) : "".concat(rt(e))
                 }(t)
             }
 
-            function ca(t) {
+            function ha(t) {
                 var e;
                 let {
                     fieldOrDatumDef: n,
                     format: i,
                     formatType: r,
                     expr: o,
                     normalizeStack: a,
                     config: s,
                     field: c
                 } = t;
-                if (null !== (e = c) && void 0 !== e || (c = sa(n, o, a)), "datum.value" !== c && Na(n) && ti(n.bin)) {
+                if (null !== (e = c) && void 0 !== e || (c = da(n, o, a)), "datum.value" !== c && Ba(n) && ti(n.bin)) {
                     return {
-                        signal: pa(c, Ga(n, {
+                        signal: ba(c, Ka(n, {
                             expr: o,
                             binSuffix: "end"
                         }), i, r, s)
                     }
                 }
                 return {
-                    signal: ra(r, c, i)
+                    signal: la(r, c, i)
                 }
             }
 
-            function la(t, e, n, i, r, o) {
-                if (!(0, U.HD)(i) || !ia(i)) {
-                    if (void 0 === n && void 0 === i && r.customFormatTypes && "quantitative" === za(t)) {
-                        if (r.normalizedNumberFormatType && Wa(t) && "normalize" === t.stack) return;
+            function pa(t, e, n, i, r, o) {
+                if (!(0, U.HD)(i) || !ca(i)) {
+                    if (void 0 === n && void 0 === i && r.customFormatTypes && "quantitative" === Ia(t)) {
+                        if (r.normalizedNumberFormatType && Za(t) && "normalize" === t.stack) return;
                         if (r.numberFormatType) return
                     }
-                    if (Wa(t) && "normalize" === t.stack && r.normalizedNumberFormat) return fa({
+                    if (Za(t) && "normalize" === t.stack && r.normalizedNumberFormat) return ga({
                         type: "quantitative",
                         config: r,
                         normalizeStack: !0
                     });
-                    if (ls(t)) {
+                    if (ps(t)) {
                         var a;
-                        const e = Na(t) ? null === (a = Cr(t.timeUnit)) || void 0 === a ? void 0 : a.unit : void 0;
+                        const e = Ba(t) ? null === (a = Or(t.timeUnit)) || void 0 === a ? void 0 : a.unit : void 0;
                         if (void 0 === e && r.customFormatTypes && r.timeFormatType) return;
                         return function(t) {
                             let {
                                 specifiedFormat: e,
                                 timeUnit: n,
                                 config: i,
                                 omitTimeFormatConfig: r
                             } = t;
                             if (e) return e;
                             if (n) return {
-                                signal: Sr(n)
+                                signal: Fr(n)
                             };
                             return r ? void 0 : i.timeFormat
                         }({
                             specifiedFormat: n,
                             timeUnit: e,
                             config: r,
                             omitTimeFormatConfig: o
                         })
                     }
-                    return fa({
+                    return ga({
                         type: e,
                         specifiedFormat: n,
                         config: r
                     })
                 }
             }
 
-            function ua(t, e, n) {
-                return t && (li(t) || "number" === t || "time" === t) ? t : ls(e) && "time" !== n && "utc" !== n ? Na(e) && null !== (i = Cr(null === e || void 0 === e ? void 0 : e.timeUnit)) && void 0 !== i && i.utc ? "utc" : "time" : void 0;
+            function ma(t, e, n) {
+                return t && (li(t) || "number" === t || "time" === t) ? t : ps(e) && "time" !== n && "utc" !== n ? Ba(e) && null !== (i = Or(null === e || void 0 === e ? void 0 : e.timeUnit)) && void 0 !== i && i.utc ? "utc" : "time" : void 0;
                 var i
             }
 
-            function fa(t) {
+            function ga(t) {
                 let {
                     type: e,
                     specifiedFormat: n,
                     config: i,
                     normalizeStack: r
                 } = t;
-                return (0, U.HD)(n) ? n : e === Xr ? r ? i.normalizedNumberFormat : i.numberFormat : void 0
+                return (0, U.HD)(n) ? n : e === Yr ? r ? i.normalizedNumberFormat : i.numberFormat : void 0
             }
 
-            function da(t, e) {
+            function va(t, e) {
                 return "format(".concat(t, ', "').concat(e || "", '")')
             }
 
-            function ha(t, e, n, i) {
+            function ya(t, e, n, i) {
                 var r;
-                return ia(n) ? ra(n, t, e) : da(t, null !== (r = (0, U.HD)(e) ? e : void 0) && void 0 !== r ? r : i.numberFormat)
+                return ca(n) ? la(n, t, e) : va(t, null !== (r = (0, U.HD)(e) ? e : void 0) && void 0 !== r ? r : i.numberFormat)
             }
 
-            function pa(t, e, n, i, r) {
-                if (void 0 === n && void 0 === i && r.customFormatTypes && r.numberFormatType) return pa(t, e, r.numberFormat, r.numberFormatType, r);
-                const o = ha(t, n, i, r),
-                    a = ha(e, n, i, r);
-                return "".concat(Ir(t, !1), ' ? "null" : ').concat(o, ' + "').concat(oa, '" + ').concat(a)
+            function ba(t, e, n, i, r) {
+                if (void 0 === n && void 0 === i && r.customFormatTypes && r.numberFormatType) return ba(t, e, r.numberFormat, r.numberFormatType, r);
+                const o = ya(t, n, i, r),
+                    a = ya(e, n, i, r);
+                return "".concat(Xr(t, !1), ' ? "null" : ').concat(o, ' + "').concat(ua, '" + ').concat(a)
             }
-            const ma = "min",
-                ga = {
+            const xa = "min",
+                _a = {
                     x: 1,
                     y: 1,
                     color: 1,
                     fill: 1,
                     stroke: 1,
                     strokeWidth: 1,
                     size: 1,
                     shape: 1,
                     fillOpacity: 1,
                     strokeOpacity: 1,
                     opacity: 1,
                     text: 1
                 };
 
-            function va(t) {
-                return t in ga
+            function wa(t) {
+                return t in _a
             }
 
-            function ya(t) {
+            function ka(t) {
                 return !(null === t || void 0 === t || !t.encoding)
             }
 
-            function ba(t) {
+            function Ea(t) {
                 return t && ("count" === t.op || !!t.field)
             }
 
-            function xa(t) {
+            function Aa(t) {
                 return t && (0, U.kJ)(t)
             }
 
-            function _a(t) {
+            function Da(t) {
                 return "row" in t || "column" in t
             }
 
-            function wa(t) {
+            function Sa(t) {
                 return !!t && "header" in t
             }
 
-            function ka(t) {
+            function Ca(t) {
                 return "facet" in t
             }
 
-            function Ea(t) {
+            function Ma(t) {
                 const {
                     field: e,
                     timeUnit: n,
                     bin: i,
                     aggregate: r
                 } = t;
                 return {
@@ -2990,392 +3040,392 @@
                     ...r ? {
                         aggregate: r
                     } : {},
                     field: e
                 }
             }
 
-            function Da(t) {
+            function Fa(t) {
                 return "sort" in t
             }
 
-            function Aa(t) {
+            function Oa(t) {
                 let {
                     fieldDef: e,
                     fieldDef2: n,
                     markDef: i,
                     config: r
                 } = t;
-                if (Ba(e) && void 0 !== e.bandPosition) return e.bandPosition;
-                if (Na(e)) {
+                if (Ha(e) && void 0 !== e.bandPosition) return e.bandPosition;
+                if (Ba(e)) {
                     const {
                         timeUnit: t,
                         bin: o
                     } = e;
-                    if (t && !n) return Io(i.type) ? 0 : Ei("timeUnitBandPosition", i, r);
+                    if (t && !n) return Xo(i.type) ? 0 : Ei("timeUnitBandPosition", i, r);
                     if (ti(o)) return .5
                 }
             }
 
-            function Sa(t) {
+            function Ta(t) {
                 let {
                     channel: e,
                     fieldDef: n,
                     fieldDef2: i,
                     markDef: r,
                     config: o,
                     scaleType: a,
                     useVlSizeChannel: s
                 } = t;
                 const c = Ye(e),
                     l = ki(s ? "size" : c, r, o, {
                         vgChannel: c
                     });
                 if (void 0 !== l) return l;
-                if (Na(n)) {
+                if (Ba(n)) {
                     const {
                         timeUnit: t,
                         bin: e
                     } = n;
                     if (t && !i) return {
                         band: Ei("timeUnitBandSize", r, o)
                     };
-                    if (ti(e) && !so(a)) return {
+                    if (ti(e) && !ho(a)) return {
                         band: 1
                     }
                 }
                 var u, f, d;
-                return Io(r.type) ? a ? so(a) ? (null === (f = o[r.type]) || void 0 === f ? void 0 : f.discreteBandSize) || {
+                return Xo(r.type) ? a ? ho(a) ? (null === (f = o[r.type]) || void 0 === f ? void 0 : f.discreteBandSize) || {
                     band: 1
                 } : null === (d = o[r.type]) || void 0 === d ? void 0 : d.continuousBandSize : null === (u = o[r.type]) || void 0 === u ? void 0 : u.discreteBandSize : void 0
             }
 
-            function Ca(t, e, n, i) {
-                return !!(ti(t.bin) || t.timeUnit && Ia(t) && "temporal" === t.type) && void 0 !== Aa({
+            function Na(t, e, n, i) {
+                return !!(ti(t.bin) || t.timeUnit && Xa(t) && "temporal" === t.type) && void 0 !== Oa({
                     fieldDef: t,
                     fieldDef2: e,
                     markDef: n,
                     config: i
                 })
             }
 
-            function Fa(t) {
+            function Ra(t) {
                 return t && !!t.sort && !t.field
             }
 
-            function Ma(t) {
+            function za(t) {
                 return t && "condition" in t
             }
 
-            function Oa(t) {
+            function Pa(t) {
                 const e = null === t || void 0 === t ? void 0 : t.condition;
-                return !!e && !(0, U.kJ)(e) && Na(e)
+                return !!e && !(0, U.kJ)(e) && Ba(e)
             }
 
-            function Ta(t) {
+            function La(t) {
                 const e = null === t || void 0 === t ? void 0 : t.condition;
-                return !!e && !(0, U.kJ)(e) && Ba(e)
+                return !!e && !(0, U.kJ)(e) && Ha(e)
             }
 
-            function Na(t) {
+            function Ba(t) {
                 return t && (!!t.field || "count" === t.aggregate)
             }
 
-            function za(t) {
+            function Ia(t) {
                 return null === t || void 0 === t ? void 0 : t.type
             }
 
-            function Ra(t) {
+            function ja(t) {
                 return t && "datum" in t
             }
 
-            function Pa(t) {
-                return Ia(t) && !$a(t) || ja(t)
+            function Ua(t) {
+                return Xa(t) && !Qa(t) || Wa(t)
             }
 
-            function La(t) {
-                return Ia(t) && "quantitative" === t.type && !t.bin || ja(t)
+            function qa(t) {
+                return Xa(t) && "quantitative" === t.type && !t.bin || Wa(t)
             }
 
-            function ja(t) {
-                return Ra(t) && (0, U.hj)(t.datum)
+            function Wa(t) {
+                return ja(t) && (0, U.hj)(t.datum)
             }
 
-            function Ba(t) {
-                return Na(t) || Ra(t)
+            function Ha(t) {
+                return Ba(t) || ja(t)
             }
 
-            function Ia(t) {
+            function Xa(t) {
                 return t && ("field" in t || "count" === t.aggregate) && "type" in t
             }
 
-            function Ua(t) {
+            function Ga(t) {
                 return t && "value" in t && "value" in t
             }
 
-            function qa(t) {
+            function Ja(t) {
                 return t && ("scale" in t || "sort" in t)
             }
 
-            function Wa(t) {
+            function Za(t) {
                 return t && ("axis" in t || "stack" in t || "impute" in t)
             }
 
-            function Ha(t) {
+            function $a(t) {
                 return t && "legend" in t
             }
 
-            function Xa(t) {
+            function Ya(t) {
                 return t && ("format" in t || "formatType" in t)
             }
 
-            function Ja(t) {
+            function Va(t) {
                 return it(t, ["legend", "axis", "header", "scale"])
             }
 
-            function Ga(t) {
+            function Ka(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                     n = t.field;
                 const i = e.prefix;
                 let r = e.suffix,
                     o = "";
                 if (function(t) {
                         return "count" === t.aggregate
-                    }(t)) n = jt("count");
+                    }(t)) n = Bt("count");
                 else {
                     let i;
                     if (!e.nofn)
                         if (function(t) {
                                 return "op" in t
                             }(t)) i = t.op;
                         else {
                             const {
                                 bin: l,
                                 aggregate: u,
                                 timeUnit: f
                             } = t;
                             var a, s;
                             if (ti(l)) i = Qn(l), r = (null !== (a = e.binSuffix) && void 0 !== a ? a : "") + (null !== (s = e.suffix) && void 0 !== s ? s : "");
-                            else if (u) Gn(u) ? (o = '["'.concat(n, '"]'), n = "argmax_".concat(u.argmax)) : Jn(u) ? (o = '["'.concat(n, '"]'), n = "argmin_".concat(u.argmin)) : i = String(u);
-                            else if (f) {
+                            else if (u) Jn(u) ? (o = '["'.concat(n, '"]'), n = "argmax_".concat(u.argmax)) : Gn(u) ? (o = '["'.concat(n, '"]'), n = "argmin_".concat(u.argmin)) : i = String(u);
+                            else if (f && !wr(f)) {
                                 var c;
                                 i = function(t) {
                                     const {
                                         utc: e,
                                         ...n
-                                    } = Cr(t);
+                                    } = Or(t);
                                     return n.unit ? (e ? "utc" : "") + bt(n).map((t => kt("".concat("unit" === t ? "" : "_".concat(t, "_")).concat(n[t])))).join("") : (e ? "utc" : "") + "timeunit" + bt(n).map((t => kt("_".concat(t, "_").concat(n[t])))).join("")
                                 }(f), r = (!["range", "mid"].includes(e.binSuffix) && e.binSuffix || "") + (null !== (c = e.suffix) && void 0 !== c ? c : "")
                             }
                         } i && (n = n ? "".concat(i, "_").concat(n) : i)
                 }
-                return r && (n = "".concat(n, "_").concat(r)), i && (n = "".concat(i, "_").concat(n)), e.forAs ? Tt(n) : e.expr ? Ct(n, e.expr) + o : Mt(n) + o
+                return r && (n = "".concat(n, "_").concat(r)), i && (n = "".concat(i, "_").concat(n)), e.forAs ? Tt(n) : e.expr ? Ct(n, e.expr) + o : Ft(n) + o
             }
 
-            function $a(t) {
+            function Qa(t) {
                 switch (t.type) {
                     case "nominal":
                     case "ordinal":
                     case "geojson":
                         return !0;
                     case "quantitative":
-                        return Na(t) && !!t.bin;
+                        return Ba(t) && !!t.bin;
                     case "temporal":
                         return !1
                 }
-                throw new Error(Ji(t.type))
+                throw new Error(Gi(t.type))
             }
-            const Za = (t, e) => {
+            const ts = (t, e) => {
                 switch (e.fieldTitle) {
                     case "plain":
                         return t.field;
                     case "functional":
                         return function(t) {
                             const {
                                 aggregate: e,
                                 bin: n,
                                 timeUnit: i,
                                 field: r
                             } = t;
-                            if (Gn(e)) return "".concat(r, " for argmax(").concat(e.argmax, ")");
-                            if (Jn(e)) return "".concat(r, " for argmin(").concat(e.argmin, ")");
-                            const o = Cr(i),
+                            if (Jn(e)) return "".concat(r, " for argmax(").concat(e.argmax, ")");
+                            if (Gn(e)) return "".concat(r, " for argmin(").concat(e.argmin, ")");
+                            const o = i && !wr(i) ? Or(i) : void 0,
                                 a = e || (null === o || void 0 === o ? void 0 : o.unit) || (null === o || void 0 === o ? void 0 : o.maxbins) && "timeunit" || ti(n) && "bin";
                             return a ? "".concat(a.toUpperCase(), "(").concat(r, ")") : r
                         }(t);
                     default:
                         return function(t, e) {
                             const {
                                 field: n,
                                 bin: i,
                                 timeUnit: r,
                                 aggregate: o
                             } = t;
                             if ("count" === o) return e.countTitle;
                             if (ti(i)) return "".concat(n, " (binned)");
-                            if (r) {
+                            if (r && !wr(r)) {
                                 var a;
-                                const t = null === (a = Cr(r)) || void 0 === a ? void 0 : a.unit;
-                                if (t) return "".concat(n, " (").concat(Er(t).join("-"), ")")
-                            } else if (o) return Gn(o) ? "".concat(n, " for max ").concat(o.argmax) : Jn(o) ? "".concat(n, " for min ").concat(o.argmin) : "".concat(At(o), " of ").concat(n);
+                                const t = null === (a = Or(r)) || void 0 === a ? void 0 : a.unit;
+                                if (t) return "".concat(n, " (").concat(Dr(t).join("-"), ")")
+                            } else if (o) return Jn(o) ? "".concat(n, " for max ").concat(o.argmax) : Gn(o) ? "".concat(n, " for min ").concat(o.argmin) : "".concat(Dt(o), " of ").concat(n);
                             return n
                         }(t, e)
                 }
             };
-            let Ya = Za;
+            let es = ts;
 
-            function Va(t) {
-                Ya = t
+            function ns(t) {
+                es = t
             }
 
-            function Ka(t, e, n) {
+            function is(t, e, n) {
                 var i;
                 let {
                     allowDisabling: r,
                     includeDefault: o = !0
                 } = n;
-                const a = null === (i = Qa(t)) || void 0 === i ? void 0 : i.title;
-                if (!Na(t)) return null !== a && void 0 !== a ? a : t.title;
+                const a = null === (i = rs(t)) || void 0 === i ? void 0 : i.title;
+                if (!Ba(t)) return null !== a && void 0 !== a ? a : t.title;
                 const s = t,
-                    c = o ? ts(s, e) : void 0;
-                return r ? zt(a, s.title, c) : null !== (l = null !== a && void 0 !== a ? a : s.title) && void 0 !== l ? l : c;
+                    c = o ? os(s, e) : void 0;
+                return r ? Rt(a, s.title, c) : null !== (l = null !== a && void 0 !== a ? a : s.title) && void 0 !== l ? l : c;
                 var l
             }
 
-            function Qa(t) {
-                return Wa(t) && t.axis ? t.axis : Ha(t) && t.legend ? t.legend : wa(t) && t.header ? t.header : void 0
+            function rs(t) {
+                return Za(t) && t.axis ? t.axis : $a(t) && t.legend ? t.legend : Sa(t) && t.header ? t.header : void 0
             }
 
-            function ts(t, e) {
-                return Ya(t, e)
+            function os(t, e) {
+                return es(t, e)
             }
 
-            function es(t) {
-                if (Xa(t)) {
+            function as(t) {
+                if (Ya(t)) {
                     const {
                         format: e,
                         formatType: n
                     } = t;
                     return {
                         format: e,
                         formatType: n
                     }
                 } {
                     var e;
-                    const n = null !== (e = Qa(t)) && void 0 !== e ? e : {},
+                    const n = null !== (e = rs(t)) && void 0 !== e ? e : {},
                         {
                             format: i,
                             formatType: r
                         } = n;
                     return {
                         format: i,
                         formatType: r
                     }
                 }
             }
 
-            function ns(t) {
-                return Na(t) ? t : Oa(t) ? t.condition : void 0
+            function ss(t) {
+                return Ba(t) ? t : Pa(t) ? t.condition : void 0
             }
 
-            function is(t) {
-                return Ba(t) ? t : Ta(t) ? t.condition : void 0
+            function cs(t) {
+                return Ha(t) ? t : La(t) ? t.condition : void 0
             }
 
-            function rs(t, e, n) {
+            function ls(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                 if ((0, U.HD)(t) || (0, U.hj)(t) || (0, U.jn)(t)) {
                     return dr(function(t, e, n) {
                         return "Channel ".concat(t, " is a ").concat(e, ". Converted to {value: ").concat(rt(n), "}.")
                     }(e, (0, U.HD)(t) ? "string" : (0, U.hj)(t) ? "number" : "boolean", t)), {
                         value: t
                     }
                 }
-                return Ba(t) ? os(t, e, n, i) : Ta(t) ? {
+                return Ha(t) ? us(t, e, n, i) : La(t) ? {
                     ...t,
-                    condition: os(t.condition, e, n, i)
+                    condition: us(t.condition, e, n, i)
                 } : t
             }
 
-            function os(t, e, n, i) {
-                if (Xa(t)) {
+            function us(t, e, n, i) {
+                if (Ya(t)) {
                     const {
                         format: r,
                         formatType: o,
                         ...a
                     } = t;
-                    if (ia(o) && !n.customFormatTypes) return dr(Wi(e)), os(a, e, n, i)
+                    if (ca(o) && !n.customFormatTypes) return dr(Wi(e)), us(a, e, n, i)
                 } else {
-                    const r = Wa(t) ? "axis" : Ha(t) ? "legend" : wa(t) ? "header" : null;
+                    const r = Za(t) ? "axis" : $a(t) ? "legend" : Sa(t) ? "header" : null;
                     if (r && t[r]) {
                         const {
                             format: o,
                             formatType: a,
                             ...s
                         } = t[r];
-                        if (ia(a) && !n.customFormatTypes) return dr(Wi(e)), os({
+                        if (ca(a) && !n.customFormatTypes) return dr(Wi(e)), us({
                             ...t,
                             [r]: s
                         }, e, n, i)
                     }
                 }
-                return Na(t) ? as(t, e, i) : function(t) {
+                return Ba(t) ? fs(t, e, i) : function(t) {
                     let e = t.type;
                     if (e) return t;
                     const {
                         datum: n
                     } = t;
                     return e = (0, U.hj)(n) ? "quantitative" : (0, U.HD)(n) ? "nominal" : hr(n) ? "temporal" : void 0, {
                         ...t,
                         type: e
                     }
                 }(t)
             }
 
-            function as(t, e) {
+            function fs(t, e) {
                 let {
                     compositeMark: n = !1
                 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                 const {
                     aggregate: i,
                     timeUnit: r,
                     bin: o,
                     field: a
                 } = t, s = {
                     ...t
                 };
-                if (n || !i || $n(i) || Gn(i) || Jn(i) || (dr(function(t) {
+                if (n || !i || Zn(i) || Jn(i) || Gn(i) || (dr(function(t) {
                         return 'Invalid aggregation operator "'.concat(t, '".')
-                    }(i)), delete s.aggregate), r && (s.timeUnit = Cr(r)), a && (s.field = "".concat(a)), ti(o) && (s.bin = ss(o, e)), ei(o) && !xn(e) && dr(function(t) {
+                    }(i)), delete s.aggregate), r && (s.timeUnit = Or(r)), a && (s.field = "".concat(a)), ti(o) && (s.bin = ds(o, e)), ei(o) && !xn(e) && dr(function(t) {
                         return "Channel ".concat(t, ' should not be used with "binned" bin.')
-                    }(e)), Ia(s)) {
+                    }(e)), Xa(s)) {
                     const {
                         type: t
                     } = s, e = function(t) {
                         if (t) switch (t = t.toLowerCase()) {
                             case "q":
-                            case Xr:
+                            case Yr:
                                 return "quantitative";
                             case "t":
-                            case Gr:
+                            case Kr:
                                 return "temporal";
                             case "o":
-                            case Jr:
+                            case Vr:
                                 return "ordinal";
                             case "n":
-                            case $r:
+                            case Qr:
                                 return "nominal";
-                            case Zr:
+                            case to:
                                 return "geojson"
                         }
                     }(t);
                     t !== e && (s.type = e), "quantitative" !== t && Yn(i) && (dr(function(t, e) {
                         return 'Invalid field type "'.concat(t, '" for aggregate: "').concat(e, '", using "quantitative" instead.')
                     }(t, i)), s.type = "quantitative")
-                } else if (!Je(e)) {
+                } else if (!Ge(e)) {
                     const t = function(t, e) {
                         var n;
                         switch (e) {
                             case "latitude":
                             case "longitude":
                                 return "quantitative";
                             case "row":
@@ -3383,128 +3433,128 @@
                             case "facet":
                             case "shape":
                             case "strokeDash":
                                 return "nominal";
                             case "order":
                                 return "ordinal"
                         }
-                        if (Da(t) && (0, U.kJ)(t.sort)) return "ordinal";
+                        if (Fa(t) && (0, U.kJ)(t.sort)) return "ordinal";
                         const {
                             aggregate: i,
                             bin: r,
                             timeUnit: o
                         } = t;
                         if (o) return "temporal";
-                        if (r || i && !Gn(i) && !Jn(i)) return "quantitative";
-                        if (qa(t) && null !== (n = t.scale) && void 0 !== n && n.type) switch (Vr[t.scale.type]) {
+                        if (r || i && !Jn(i) && !Gn(i)) return "quantitative";
+                        if (Ja(t) && null !== (n = t.scale) && void 0 !== n && n.type) switch (no[t.scale.type]) {
                             case "numeric":
                             case "discretizing":
                                 return "quantitative";
                             case "time":
                                 return "temporal"
                         }
                         return "nominal"
                     }(s, e);
                     s.type = t
                 }
-                if (Ia(s)) {
+                if (Xa(s)) {
                     const {
                         compatible: t,
                         warning: n
                     } = function(t, e) {
                         const n = t.type;
                         if ("geojson" === n && "shape" !== e) return {
                             compatible: !1,
                             warning: "Channel ".concat(e, " should not be used with a geojson data.")
                         };
                         switch (e) {
                             case qt:
                             case Wt:
                             case Ht:
-                                return $a(t) ? cs : {
+                                return Qa(t) ? hs : {
                                     compatible: !1,
                                     warning: Vi(e)
                                 };
                             case Xt:
-                            case Jt:
-                            case Zt:
+                            case Gt:
+                            case $t:
                             case Yt:
                             case oe:
                             case ae:
                             case se:
                             case ge:
                             case ye:
                             case be:
                             case xe:
                             case _e:
                             case we:
                             case ue:
                             case Qt:
                             case Vt:
                             case ke:
-                                return cs;
+                                return hs;
                             case ne:
                             case re:
                             case ee:
                             case ie:
-                                return n !== Xr ? {
+                                return n !== Yr ? {
                                     compatible: !1,
                                     warning: "Channel ".concat(e, " should be used with a quantitative field only, not ").concat(t.type, " field.")
-                                } : cs;
+                                } : hs;
                             case fe:
                             case de:
                             case he:
                             case pe:
                             case le:
                             case te:
                             case Kt:
-                            case Gt:
-                            case $t:
-                                return "nominal" !== n || t.sort ? cs : {
+                            case Jt:
+                            case Zt:
+                                return "nominal" !== n || t.sort ? hs : {
                                     compatible: !1,
                                     warning: "Channel ".concat(e, " should not be used with an unsorted discrete field.")
                                 };
                             case ce:
                             case me:
-                                return $a(t) || function(t) {
+                                return Qa(t) || function(t) {
                                     var e;
-                                    return qa(t) && uo(null === (e = t.scale) || void 0 === e ? void 0 : e.type)
-                                }(t) ? cs : {
+                                    return Ja(t) && go(null === (e = t.scale) || void 0 === e ? void 0 : e.type)
+                                }(t) ? hs : {
                                     compatible: !1,
                                     warning: Ki(e)
                                 };
                             case ve:
-                                return "nominal" !== t.type || "sort" in t ? cs : {
+                                return "nominal" !== t.type || "sort" in t ? hs : {
                                     compatible: !1,
                                     warning: "Channel order is inappropriate for nominal field, which has no inherent order."
                                 }
                         }
                     }(s, e) || {};
                     !1 === t && dr(n)
                 }
-                if (Da(s) && (0, U.HD)(s.sort)) {
+                if (Fa(s) && (0, U.HD)(s.sort)) {
                     const {
                         sort: t
                     } = s;
-                    if (va(t)) return {
+                    if (wa(t)) return {
                         ...s,
                         sort: {
                             encoding: t
                         }
                     };
                     const e = t.substr(1);
-                    if ("-" === t.charAt(0) && va(e)) return {
+                    if ("-" === t.charAt(0) && wa(e)) return {
                         ...s,
                         sort: {
                             encoding: e,
                             order: "descending"
                         }
                     }
                 }
-                if (wa(s)) {
+                if (Sa(s)) {
                     const {
                         header: t
                     } = s;
                     if (t) {
                         const {
                             orient: e,
                             ...n
@@ -3518,73 +3568,73 @@
                             }
                         }
                     }
                 }
                 return s
             }
 
-            function ss(t, e) {
+            function ds(t, e) {
                 return (0, U.jn)(t) ? {
                     maxbins: ri(e)
                 } : "binned" === t ? {
                     binned: !0
                 } : t.maxbins || t.step ? t : {
                     ...t,
                     maxbins: ri(e)
                 }
             }
-            const cs = {
+            const hs = {
                 compatible: !0
             };
 
-            function ls(t) {
+            function ps(t) {
                 const {
                     formatType: e
-                } = es(t);
-                return "time" === e || !e && ((n = t) && ("temporal" === n.type || Na(n) && !!n.timeUnit));
+                } = as(t);
+                return "time" === e || !e && ((n = t) && ("temporal" === n.type || Ba(n) && !!n.timeUnit));
                 var n
             }
 
-            function us(t, e) {
+            function ms(t, e) {
                 var n;
                 let {
                     timeUnit: i,
                     type: r,
                     wrapTime: o,
                     undefinedIfExprNotRequired: a
                 } = e;
-                const s = i && (null === (n = Cr(i)) || void 0 === n ? void 0 : n.unit);
+                const s = i && (null === (n = Or(i)) || void 0 === n ? void 0 : n.unit);
                 let c, l = s || "temporal" === r;
                 return oi(t) ? c = t.expr : li(t) ? c = t.signal : hr(t) ? (l = !0, c = br(t)) : ((0, U.HD)(t) || (0, U.hj)(t)) && l && (c = "datetime(".concat(rt(t), ")"), function(t) {
                     return !!xr[t]
                 }(s) && ((0, U.hj)(t) && t < 1e4 || (0, U.HD)(t) && isNaN(Date.parse(t))) && (c = br({
                     [s]: t
                 }))), c ? o && l ? "time(".concat(c, ")") : c : a ? void 0 : rt(t)
             }
 
-            function fs(t, e) {
+            function gs(t, e) {
                 const {
                     type: n
                 } = t;
                 return e.map((e => {
-                    const i = us(e, {
-                        timeUnit: Na(t) ? t.timeUnit : void 0,
+                    const i = ms(e, {
+                        timeUnit: Ba(t) && !wr(t.timeUnit) ? t.timeUnit : void 0,
                         type: n,
                         undefinedIfExprNotRequired: !0
                     });
                     return void 0 !== i ? {
                         signal: i
                     } : e
                 }))
             }
 
-            function ds(t, e) {
-                return ti(t.bin) ? jn(e) && ["ordinal", "nominal"].includes(t.type) : (console.warn("Only call this method for binned field defs."), !1)
+            function vs(t, e) {
+                return ti(t.bin) ? Bn(e) && ["ordinal", "nominal"].includes(t.type) : (console.warn("Only call this method for binned field defs."), !1)
             }
-            const hs = {
+            const ys = {
                 labelAlign: {
                     part: "labels",
                     vgProp: "align"
                 },
                 labelBaseline: {
                     part: "labels",
                     vgProp: "baseline"
@@ -3654,19 +3704,19 @@
                 tickSize: null,
                 tickWidth: {
                     part: "ticks",
                     vgProp: "strokeWidth"
                 }
             };
 
-            function ps(t) {
+            function bs(t) {
                 return null === t || void 0 === t ? void 0 : t.condition
             }
-            const ms = ["domain", "grid", "labels", "ticks", "title"],
-                gs = {
+            const xs = ["domain", "grid", "labels", "ticks", "title"],
+                _s = {
                     grid: "grid",
                     gridCap: "grid",
                     gridColor: "grid",
                     gridDash: "grid",
                     gridDashOffset: "grid",
                     gridOpacity: "grid",
                     gridScale: "grid",
@@ -3739,15 +3789,15 @@
                     tickBand: "both",
                     tickCount: "both",
                     tickExtra: "both",
                     translate: "both",
                     values: "both",
                     zindex: "both"
                 },
-                vs = {
+                ws = {
                     orient: 1,
                     aria: 1,
                     bandPosition: 1,
                     description: 1,
                     domain: 1,
                     domainCap: 1,
                     domainColor: 1,
@@ -3817,26 +3867,26 @@
                     titlePadding: 1,
                     titleX: 1,
                     titleY: 1,
                     translate: 1,
                     values: 1,
                     zindex: 1
                 },
-                ys = {
-                    ...vs,
+                ks = {
+                    ...ws,
                     style: 1,
                     labelExpr: 1,
                     encoding: 1
                 };
 
-            function bs(t) {
-                return !!ys[t]
+            function Es(t) {
+                return !!ks[t]
             }
-            bt(ys);
-            const xs = bt({
+            bt(ks);
+            const As = bt({
                 axis: 1,
                 axisBand: 1,
                 axisBottom: 1,
                 axisDiscrete: 1,
                 axisLeft: 1,
                 axisPoint: 1,
                 axisQuantitative: 1,
@@ -3853,133 +3903,133 @@
                 axisYBand: 1,
                 axisYDiscrete: 1,
                 axisYPoint: 1,
                 axisYQuantitative: 1,
                 axisYTemporal: 1
             });
 
-            function _s(t) {
+            function Ds(t) {
                 return "mark" in t
             }
-            class ws {
+            class Ss {
                 constructor(t, e) {
                     this.name = t, this.run = e
                 }
                 hasMatchingType(t) {
-                    return !!_s(t) && (qo(e = t.mark) ? e.type : e) === this.name;
+                    return !!Ds(t) && (Jo(e = t.mark) ? e.type : e) === this.name;
                     var e
                 }
             }
 
-            function ks(t, e) {
+            function Cs(t, e) {
                 const n = t && t[e];
-                return !!n && ((0, U.kJ)(n) ? ct(n, (t => !!t.field)) : Na(n) || Oa(n))
+                return !!n && ((0, U.kJ)(n) ? ct(n, (t => !!t.field)) : Ba(n) || Pa(n))
             }
 
-            function Es(t, e) {
+            function Ms(t, e) {
                 const n = t && t[e];
-                return !!n && ((0, U.kJ)(n) ? ct(n, (t => !!t.field)) : Na(n) || Ra(n) || Ta(n))
+                return !!n && ((0, U.kJ)(n) ? ct(n, (t => !!t.field)) : Ba(n) || ja(n) || La(n))
             }
 
-            function Ds(t, e) {
+            function Fs(t, e) {
                 if (xn(e)) {
                     const n = t[e];
-                    if ((Na(n) || Ra(n)) && (Hr(n.type) || Na(n) && n.timeUnit)) {
-                        return Es(t, Ke(e))
+                    if ((Ba(n) || ja(n)) && ($r(n.type) || Ba(n) && n.timeUnit)) {
+                        return Ms(t, Ke(e))
                     }
                 }
                 return !1
             }
 
-            function As(t) {
-                return ct(Re, (e => {
-                    if (ks(t, e)) {
+            function Os(t) {
+                return ct(ze, (e => {
+                    if (Cs(t, e)) {
                         const n = t[e];
                         if ((0, U.kJ)(n)) return ct(n, (t => !!t.aggregate));
                         {
-                            const t = ns(n);
+                            const t = ss(n);
                             return t && !!t.aggregate
                         }
                     }
                     return !1
                 }))
             }
 
-            function Ss(t, e) {
+            function Ts(t, e) {
                 const n = [],
                     i = [],
                     r = [],
                     o = [],
                     a = {};
-                return Ms(t, ((s, c) => {
-                    if (Na(s)) {
+                return zs(t, ((s, c) => {
+                    if (Ba(s)) {
                         const {
                             field: l,
                             aggregate: u,
                             bin: f,
                             timeUnit: d,
                             ...h
                         } = s;
                         if (u || d || f) {
-                            const t = Qa(s),
+                            const t = rs(s),
                                 p = null === t || void 0 === t ? void 0 : t.title;
-                            let m = Ga(s, {
+                            let m = Ka(s, {
                                 forAs: !0
                             });
                             const g = {
                                 ...p ? [] : {
-                                    title: Ka(s, e, {
+                                    title: is(s, e, {
                                         allowDisabling: !0
                                     })
                                 },
                                 ...h,
                                 field: m
                             };
                             if (u) {
                                 let t;
-                                if (Gn(u) ? (t = "argmax", m = Ga({
+                                if (Jn(u) ? (t = "argmax", m = Ka({
                                         op: "argmax",
                                         field: u.argmax
                                     }, {
                                         forAs: !0
-                                    }), g.field = "".concat(m, ".").concat(l)) : Jn(u) ? (t = "argmin", m = Ga({
+                                    }), g.field = "".concat(m, ".").concat(l)) : Gn(u) ? (t = "argmin", m = Ka({
                                         op: "argmin",
                                         field: u.argmin
                                     }, {
                                         forAs: !0
                                     }), g.field = "".concat(m, ".").concat(l)) : "boxplot" !== u && "errorbar" !== u && "errorband" !== u && (t = u), t) {
                                     const e = {
                                         op: t,
                                         as: m
                                     };
                                     l && (e.field = l), o.push(e)
                                 }
-                            } else if (n.push(m), Ia(s) && ti(f)) {
+                            } else if (n.push(m), Xa(s) && ti(f)) {
                                 if (i.push({
                                         bin: f,
                                         field: l,
                                         as: m
-                                    }), n.push(Ga(s, {
+                                    }), n.push(Ka(s, {
                                         binSuffix: "end"
-                                    })), ds(s, c) && n.push(Ga(s, {
+                                    })), vs(s, c) && n.push(Ka(s, {
                                         binSuffix: "range"
                                     })), xn(c)) {
                                     const t = {
                                         field: "".concat(m, "_end")
                                     };
                                     a["".concat(c, "2")] = t
                                 }
-                                g.bin = "binned", Je(c) || (g.type = Xr)
-                            } else if (d) {
+                                g.bin = "binned", Ge(c) || (g.type = Yr)
+                            } else if (d && !wr(d)) {
                                 r.push({
                                     timeUnit: d,
                                     field: l,
                                     as: m
                                 });
-                                const t = Ia(s) && s.type !== Gr && "time";
+                                const t = Xa(s) && s.type !== Kr && "time";
                                 t && (c === ge || c === xe ? g.formatType = t : ! function(t) {
                                     return !!gn[t]
                                 }(c) ? xn(c) && (g.axis = {
                                     formatType: t,
                                     ...g.axis
                                 }) : g.legend = {
                                     formatType: t,
@@ -3994,56 +4044,56 @@
                     timeUnits: r,
                     aggregate: o,
                     groupby: n,
                     encoding: a
                 }
             }
 
-            function Cs(t, e, n) {
-                const i = Bn(e, n);
+            function Ns(t, e, n) {
+                const i = In(e, n);
                 if (!i) return !1;
                 if ("binned" === i) {
-                    const n = t[e === Gt ? Xt : Jt];
-                    return !!(Na(n) && Na(t[e]) && ei(n.bin))
+                    const n = t[e === Jt ? Xt : Gt];
+                    return !!(Ba(n) && Ba(t[e]) && ei(n.bin))
                 }
                 return !0
             }
 
-            function Fs(t, e) {
+            function Rs(t, e) {
                 const n = {};
                 for (const i of bt(t)) {
-                    const r = rs(t[i], i, e, {
+                    const r = ls(t[i], i, e, {
                         compositeMark: !0
                     });
                     n[i] = r
                 }
                 return n
             }
 
-            function Ms(t, e, n) {
+            function zs(t, e, n) {
                 if (t)
                     for (const i of bt(t)) {
                         const r = t[i];
                         if ((0, U.kJ)(r))
                             for (const t of r) e.call(n, t, i);
                         else e.call(n, r, i)
                     }
             }
 
-            function Os(t, e) {
+            function Ps(t, e) {
                 return bt(e).reduce(((n, i) => {
                     switch (i) {
                         case Xt:
-                        case Jt:
+                        case Gt:
                         case _e:
                         case ke:
                         case we:
-                        case Gt:
-                        case $t:
+                        case Jt:
                         case Zt:
+                        case $t:
                         case Yt:
                         case Qt:
                         case te:
                         case Vt:
                         case Kt:
                         case ee:
                         case ne:
@@ -4055,89 +4105,89 @@
                         case xe:
                             return n;
                         case ve:
                             if ("line" === t || "trail" === t) return n;
                         case ye:
                         case be: {
                             const t = e[i];
-                            if ((0, U.kJ)(t) || Na(t))
-                                for (const e of (0, U.IX)(t)) e.aggregate || n.push(Ga(e, {}));
+                            if ((0, U.kJ)(t) || Ba(t))
+                                for (const e of (0, U.IX)(t)) e.aggregate || n.push(Ka(e, {}));
                             return n
                         }
                         case le:
                             if ("trail" === t) return n;
                         case oe:
                         case ae:
                         case se:
                         case fe:
                         case de:
                         case he:
                         case me:
                         case pe: {
-                            const t = ns(e[i]);
-                            return t && !t.aggregate && n.push(Ga(t, {})), n
+                            const t = ss(e[i]);
+                            return t && !t.aggregate && n.push(Ka(t, {})), n
                         }
                     }
                 }), [])
             }
 
-            function Ts(t, e, n) {
+            function Ls(t, e, n) {
                 let i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                 if ("tooltip" in n) return {
                     tooltip: n.tooltip
                 };
                 return {
                     tooltip: [...t.map((t => {
                         let {
                             fieldPrefix: n,
                             titlePrefix: r
                         } = t;
-                        const o = i ? " of ".concat(Ns(e)) : "";
+                        const o = i ? " of ".concat(Bs(e)) : "";
                         return {
                             field: n + e.field,
                             type: e.type,
                             title: li(r) ? {
                                 signal: "".concat(r, '"').concat(escape(o), '"')
                             } : r + o
                         }
                     })), ...dt(function(t) {
                         const e = [];
                         for (const n of bt(t))
-                            if (ks(t, n)) {
+                            if (Cs(t, n)) {
                                 const i = t[n],
                                     r = (0, U.IX)(i);
-                                for (const t of r) Na(t) ? e.push(t) : Oa(t) && e.push(t.condition)
+                                for (const t of r) Ba(t) ? e.push(t) : Pa(t) && e.push(t.condition)
                             } return e
-                    }(n).map(Ja), ot)]
+                    }(n).map(Va), ot)]
                 }
             }
 
-            function Ns(t) {
+            function Bs(t) {
                 const {
                     title: e,
                     field: n
                 } = t;
-                return zt(e, n)
+                return Rt(e, n)
             }
 
-            function zs(t, e, n, i, r) {
+            function Is(t, e, n, i, r) {
                 const {
                     scale: o,
                     axis: a
                 } = n;
                 return s => {
                     let {
                         partName: c,
                         mark: l,
                         positionPrefix: u,
                         endPositionPrefix: f,
                         extraEncoding: d = {}
                     } = s;
-                    const h = Ns(n);
-                    return Rs(t, c, r, {
+                    const h = Bs(n);
+                    return js(t, c, r, {
                         mark: l,
                         encoding: {
                             [e]: {
                                 field: "".concat(u, "_").concat(n.field),
                                 type: n.type,
                                 ...void 0 !== h ? {
                                     title: h
@@ -4157,15 +4207,15 @@
                             ...i,
                             ...d
                         }
                     })
                 }
             }
 
-            function Rs(t, e, n, i) {
+            function js(t, e, n, i) {
                 const {
                     clip: r,
                     color: o,
                     opacity: a
                 } = t, s = t.type;
                 return t[e] || void 0 === t[e] && n[e] ? [{
                     ...i,
@@ -4176,127 +4226,127 @@
                         } : {},
                         ...o ? {
                             color: o
                         } : {},
                         ...a ? {
                             opacity: a
                         } : {},
-                        ...qo(i.mark) ? i.mark : {
+                        ...Jo(i.mark) ? i.mark : {
                             type: i.mark
                         },
                         style: "".concat(s, "-").concat(String(e)),
                         ...(0, U.jn)(t[e]) ? {} : t[e]
                     }
                 }] : []
             }
 
-            function Ps(t, e, n) {
+            function Us(t, e, n) {
                 const {
                     encoding: i
                 } = t, r = "vertical" === e ? "y" : "x", o = i[r], a = i["".concat(r, "2")], s = i["".concat(r, "Error")], c = i["".concat(r, "Error2")];
                 return {
-                    continuousAxisChannelDef: Ls(o, n),
-                    continuousAxisChannelDef2: Ls(a, n),
-                    continuousAxisChannelDefError: Ls(s, n),
-                    continuousAxisChannelDefError2: Ls(c, n),
+                    continuousAxisChannelDef: qs(o, n),
+                    continuousAxisChannelDef2: qs(a, n),
+                    continuousAxisChannelDefError: qs(s, n),
+                    continuousAxisChannelDefError2: qs(c, n),
                     continuousAxis: r
                 }
             }
 
-            function Ls(t, e) {
+            function qs(t, e) {
                 if (null !== t && void 0 !== t && t.aggregate) {
                     const {
                         aggregate: n,
                         ...i
                     } = t;
                     return n !== e && dr(function(t, e) {
                         return "Continuous axis should not have customized aggregation function ".concat(t, "; ").concat(e, " already agregates the axis.")
                     }(n, e)), i
                 }
                 return t
             }
 
-            function js(t, e) {
+            function Ws(t, e) {
                 const {
                     mark: n,
                     encoding: i
                 } = t, {
                     x: r,
                     y: o
                 } = i;
-                if (qo(n) && n.orient) return n.orient;
-                if (Pa(r)) {
-                    if (Pa(o)) {
-                        const t = Na(r) && r.aggregate,
-                            n = Na(o) && o.aggregate;
+                if (Jo(n) && n.orient) return n.orient;
+                if (Ua(r)) {
+                    if (Ua(o)) {
+                        const t = Ba(r) && r.aggregate,
+                            n = Ba(o) && o.aggregate;
                         if (t || n !== e) {
                             if (n || t !== e) {
                                 if (t === e && n === e) throw new Error("Both x and y cannot have aggregate");
-                                return ls(o) && !ls(r) ? "horizontal" : "vertical"
+                                return ps(o) && !ps(r) ? "horizontal" : "vertical"
                             }
                             return "horizontal"
                         }
                         return "vertical"
                     }
                     return "horizontal"
                 }
-                if (Pa(o)) return "vertical";
+                if (Ua(o)) return "vertical";
                 throw new Error("Need a valid continuous axis for ".concat(e, "s"))
             }
-            const Bs = "boxplot",
-                Is = new ws(Bs, qs);
+            const Hs = "boxplot",
+                Xs = new Ss(Hs, Js);
 
-            function Us(t) {
+            function Gs(t) {
                 return (0, U.hj)(t) ? "tukey" : t
             }
 
-            function qs(t, e) {
+            function Js(t, e) {
                 var n;
                 let {
                     config: i
                 } = e;
                 t = {
                     ...t,
-                    encoding: Fs(t.encoding, i)
+                    encoding: Rs(t.encoding, i)
                 };
                 const {
                     mark: r,
                     encoding: o,
                     params: a,
                     projection: s,
                     ...c
-                } = t, l = qo(r) ? r : {
+                } = t, l = Jo(r) ? r : {
                     type: r
                 };
-                a && dr(Bi("boxplot"));
+                a && dr(Ii("boxplot"));
                 const u = null !== (n = l.extent) && void 0 !== n ? n : i.boxplot.extent,
                     f = ki("size", l, i),
                     d = l.invalid,
-                    h = Us(u),
+                    h = Gs(u),
                     {
                         bins: p,
                         timeUnits: m,
                         transform: g,
                         continuousAxisChannelDef: v,
                         continuousAxis: y,
                         groupby: b,
                         aggregate: x,
                         encodingWithoutContinuousAxis: _,
                         ticksOrient: w,
                         boxOrient: k,
                         customTooltipWithoutAggregatedField: E
                     } = function(t, e, n) {
-                        const i = js(t, Bs),
+                        const i = Ws(t, Hs),
                             {
                                 continuousAxisChannelDef: r,
                                 continuousAxis: o
-                            } = Ps(t, i, Bs),
+                            } = Us(t, i, Hs),
                             a = r.field,
-                            s = Us(e),
-                            c = [...Ws(a), {
+                            s = Gs(e),
+                            c = [...Zs(a), {
                                 op: "median",
                                 field: a,
                                 as: "mid_box_".concat(a)
                             }, {
                                 op: "min",
                                 field: a,
                                 as: ("min-max" === s ? "lower_whisker_" : "min_") + a
@@ -4342,15 +4392,15 @@
                             }(f),
                             {
                                 bins: p,
                                 timeUnits: m,
                                 aggregate: g,
                                 groupby: v,
                                 encoding: y
-                            } = Ss(h, n),
+                            } = Ts(h, n),
                             b = "vertical" === i ? "horizontal" : "vertical",
                             x = i,
                             _ = [...p, ...m, {
                                 aggregate: [...g, ...c],
                                 groupby: v
                             }, ...l];
                         return {
@@ -4364,28 +4414,28 @@
                             encodingWithoutContinuousAxis: y,
                             ticksOrient: b,
                             boxOrient: x,
                             customTooltipWithoutAggregatedField: d
                         }
                     }(t, u, i),
                     {
-                        color: D,
-                        size: A,
+                        color: A,
+                        size: D,
                         ...S
                     } = _,
-                    C = t => zs(l, y, v, t, i.boxplot),
-                    F = C(S),
-                    M = C(_),
+                    C = t => Is(l, y, v, t, i.boxplot),
+                    M = C(S),
+                    F = C(_),
                     O = C({
                         ...S,
-                        ...A ? {
-                            size: A
+                        ...D ? {
+                            size: D
                         } : {}
                     }),
-                    T = Ts([{
+                    T = Ls([{
                         fieldPrefix: "min-max" === h ? "upper_whisker_" : "max_",
                         titlePrefix: "Max"
                     }, {
                         fieldPrefix: "upper_box_",
                         titlePrefix: "Q3"
                     }, {
                         fieldPrefix: "mid_box_",
@@ -4401,53 +4451,53 @@
                         type: "tick",
                         color: "black",
                         opacity: 1,
                         orient: w,
                         invalid: d,
                         aria: !1
                     },
-                    z = "min-max" === h ? T : Ts([{
+                    R = "min-max" === h ? T : Ls([{
                         fieldPrefix: "upper_whisker_",
                         titlePrefix: "Upper Whisker"
                     }, {
                         fieldPrefix: "lower_whisker_",
                         titlePrefix: "Lower Whisker"
                     }], v, _),
-                    R = [...F({
+                    z = [...M({
                         partName: "rule",
                         mark: {
                             type: "rule",
                             invalid: d,
                             aria: !1
                         },
                         positionPrefix: "lower_whisker",
                         endPositionPrefix: "lower_box",
-                        extraEncoding: z
-                    }), ...F({
+                        extraEncoding: R
+                    }), ...M({
                         partName: "rule",
                         mark: {
                             type: "rule",
                             invalid: d,
                             aria: !1
                         },
                         positionPrefix: "upper_box",
                         endPositionPrefix: "upper_whisker",
-                        extraEncoding: z
-                    }), ...F({
+                        extraEncoding: R
+                    }), ...M({
                         partName: "ticks",
                         mark: N,
                         positionPrefix: "lower_whisker",
-                        extraEncoding: z
-                    }), ...F({
+                        extraEncoding: R
+                    }), ...M({
                         partName: "ticks",
                         mark: N,
                         positionPrefix: "upper_whisker",
-                        extraEncoding: z
+                        extraEncoding: R
                     })],
-                    P = [..."tukey" !== h ? R : [], ...M({
+                    P = [..."tukey" !== h ? z : [], ...F({
                         partName: "box",
                         mark: {
                             type: "bar",
                             ...f ? {
                                 size: f
                             } : {},
                             orient: k,
@@ -4476,25 +4526,25 @@
                     })];
                 var L;
                 if ("min-max" === h) return {
                     ...c,
                     transform: (null !== (L = c.transform) && void 0 !== L ? L : []).concat(g),
                     layer: P
                 };
-                const j = 'datum["lower_box_'.concat(v.field, '"]'),
-                    B = 'datum["upper_box_'.concat(v.field, '"]'),
-                    I = "(".concat(B, " - ").concat(j, ")"),
-                    q = "".concat(j, " - ").concat(u, " * ").concat(I),
-                    W = "".concat(B, " + ").concat(u, " * ").concat(I),
+                const B = 'datum["lower_box_'.concat(v.field, '"]'),
+                    I = 'datum["upper_box_'.concat(v.field, '"]'),
+                    j = "(".concat(I, " - ").concat(B, ")"),
+                    q = "".concat(B, " - ").concat(u, " * ").concat(j),
+                    W = "".concat(I, " + ").concat(u, " * ").concat(j),
                     H = 'datum["'.concat(v.field, '"]'),
                     X = {
-                        joinaggregate: Ws(v.field),
+                        joinaggregate: Zs(v.field),
                         groupby: b
                     },
-                    J = {
+                    G = {
                         transform: [{
                             filter: "(".concat(q, " <= ").concat(H, ") && (").concat(H, " <= ").concat(W, ")")
                         }, {
                             aggregate: [{
                                 op: "min",
                                 field: v.field,
                                 as: "lower_whisker_".concat(v.field)
@@ -4509,102 +4559,102 @@
                             }, {
                                 op: "max",
                                 field: "upper_box_".concat(v.field),
                                 as: "upper_box_".concat(v.field)
                             }, ...x],
                             groupby: b
                         }],
-                        layer: R
+                        layer: z
                     },
                     {
-                        tooltip: G,
-                        ...$
+                        tooltip: J,
+                        ...Z
                     } = S,
                     {
-                        scale: Z,
+                        scale: $,
                         axis: Y
                     } = v,
-                    V = Ns(v),
+                    V = Bs(v),
                     K = it(Y, ["title"]),
-                    Q = Rs(l, "outliers", i.boxplot, {
+                    Q = js(l, "outliers", i.boxplot, {
                         transform: [{
                             filter: "(".concat(H, " < ").concat(q, ") || (").concat(H, " > ").concat(W, ")")
                         }],
                         mark: "point",
                         encoding: {
                             [y]: {
                                 field: v.field,
                                 type: v.type,
                                 ...void 0 !== V ? {
                                     title: V
                                 } : {},
-                                ...void 0 !== Z ? {
-                                    scale: Z
+                                ...void 0 !== $ ? {
+                                    scale: $
                                 } : {},
                                 ...yt(K) ? {} : {
                                     axis: K
                                 }
                             },
-                            ...$,
-                            ...D ? {
-                                color: D
+                            ...Z,
+                            ...A ? {
+                                color: A
                             } : {},
                             ...E ? {
                                 tooltip: E
                             } : {}
                         }
                     })[0];
                 let tt;
                 const et = [...p, ...m, X];
                 return Q ? tt = {
                     transform: et,
-                    layer: [Q, J]
-                } : (tt = J, tt.transform.unshift(...et)), {
+                    layer: [Q, G]
+                } : (tt = G, tt.transform.unshift(...et)), {
                     ...c,
                     layer: [tt, {
                         transform: g,
                         layer: P
                     }]
                 }
             }
 
-            function Ws(t) {
+            function Zs(t) {
                 return [{
                     op: "q1",
                     field: t,
                     as: "lower_box_".concat(t)
                 }, {
                     op: "q3",
                     field: t,
                     as: "upper_box_".concat(t)
                 }]
             }
-            const Hs = "errorbar",
-                Xs = new ws(Hs, Js);
+            const $s = "errorbar",
+                Ys = new Ss($s, Vs);
 
-            function Js(t, e) {
+            function Vs(t, e) {
                 let {
                     config: n
                 } = e;
                 t = {
                     ...t,
-                    encoding: Fs(t.encoding, n)
+                    encoding: Rs(t.encoding, n)
                 };
                 const {
                     transform: i,
                     continuousAxisChannelDef: r,
                     continuousAxis: o,
                     encodingWithoutContinuousAxis: a,
                     ticksOrient: s,
                     markDef: c,
                     outerSpec: l,
                     tooltipEncoding: u
-                } = $s(t, Hs, n);
+                } = Qs(t, $s, n);
                 delete a.size;
-                const f = zs(c, o, r, a, n.errorbar),
+                const f = Is(c, o, r, a, n.errorbar),
                     d = c.thickness,
                     h = c.size,
                     p = {
                         type: "tick",
                         orient: s,
                         aria: !1,
                         ...void 0 !== d ? {
@@ -4644,100 +4694,100 @@
                         layer: m
                     } : {
                         ...m[0]
                     }
                 }
             }
 
-            function Gs(t, e) {
+            function Ks(t, e) {
                 const {
                     encoding: n
                 } = t;
                 if (function(t) {
-                        return (Ba(t.x) || Ba(t.y)) && !Ba(t.x2) && !Ba(t.y2) && !Ba(t.xError) && !Ba(t.xError2) && !Ba(t.yError) && !Ba(t.yError2)
+                        return (Ha(t.x) || Ha(t.y)) && !Ha(t.x2) && !Ha(t.y2) && !Ha(t.xError) && !Ha(t.xError2) && !Ha(t.yError) && !Ha(t.yError2)
                     }(n)) return {
-                    orient: js(t, e),
+                    orient: Ws(t, e),
                     inputType: "raw"
                 };
                 const i = function(t) {
-                        return Ba(t.x2) || Ba(t.y2)
+                        return Ha(t.x2) || Ha(t.y2)
                     }(n),
                     r = function(t) {
-                        return Ba(t.xError) || Ba(t.xError2) || Ba(t.yError) || Ba(t.yError2)
+                        return Ha(t.xError) || Ha(t.xError2) || Ha(t.yError) || Ha(t.yError2)
                     }(n),
                     o = n.x,
                     a = n.y;
                 if (i) {
                     if (r) throw new Error("".concat(e, " cannot be both type aggregated-upper-lower and aggregated-error"));
                     const t = n.x2,
                         i = n.y2;
-                    if (Ba(t) && Ba(i)) throw new Error("".concat(e, " cannot have both x2 and y2"));
-                    if (Ba(t)) {
-                        if (Pa(o)) return {
+                    if (Ha(t) && Ha(i)) throw new Error("".concat(e, " cannot have both x2 and y2"));
+                    if (Ha(t)) {
+                        if (Ua(o)) return {
                             orient: "horizontal",
                             inputType: "aggregated-upper-lower"
                         };
                         throw new Error("Both x and x2 have to be quantitative in ".concat(e))
                     }
-                    if (Ba(i)) {
-                        if (Pa(a)) return {
+                    if (Ha(i)) {
+                        if (Ua(a)) return {
                             orient: "vertical",
                             inputType: "aggregated-upper-lower"
                         };
                         throw new Error("Both y and y2 have to be quantitative in ".concat(e))
                     }
                     throw new Error("No ranged axis")
                 } {
                     const t = n.xError,
                         i = n.xError2,
                         r = n.yError,
                         s = n.yError2;
-                    if (Ba(i) && !Ba(t)) throw new Error("".concat(e, " cannot have xError2 without xError"));
-                    if (Ba(s) && !Ba(r)) throw new Error("".concat(e, " cannot have yError2 without yError"));
-                    if (Ba(t) && Ba(r)) throw new Error("".concat(e, " cannot have both xError and yError with both are quantiative"));
-                    if (Ba(t)) {
-                        if (Pa(o)) return {
+                    if (Ha(i) && !Ha(t)) throw new Error("".concat(e, " cannot have xError2 without xError"));
+                    if (Ha(s) && !Ha(r)) throw new Error("".concat(e, " cannot have yError2 without yError"));
+                    if (Ha(t) && Ha(r)) throw new Error("".concat(e, " cannot have both xError and yError with both are quantiative"));
+                    if (Ha(t)) {
+                        if (Ua(o)) return {
                             orient: "horizontal",
                             inputType: "aggregated-error"
                         };
                         throw new Error("All x, xError, and xError2 (if exist) have to be quantitative")
                     }
-                    if (Ba(r)) {
-                        if (Pa(a)) return {
+                    if (Ha(r)) {
+                        if (Ua(a)) return {
                             orient: "vertical",
                             inputType: "aggregated-error"
                         };
                         throw new Error("All y, yError, and yError2 (if exist) have to be quantitative")
                     }
                     throw new Error("No ranged axis")
                 }
             }
 
-            function $s(t, e, n) {
+            function Qs(t, e, n) {
                 var i;
                 const {
                     mark: r,
                     encoding: o,
                     params: a,
                     projection: s,
                     ...c
-                } = t, l = qo(r) ? r : {
+                } = t, l = Jo(r) ? r : {
                     type: r
                 };
-                a && dr(Bi(e));
+                a && dr(Ii(e));
                 const {
                     orient: u,
                     inputType: f
-                } = Gs(t, e), {
+                } = Ks(t, e), {
                     continuousAxisChannelDef: d,
                     continuousAxisChannelDef2: h,
                     continuousAxisChannelDefError: p,
                     continuousAxisChannelDefError2: m,
                     continuousAxis: g
-                } = Ps(t, u, e), {
+                } = Us(t, u, e), {
                     errorBarSpecificAggregate: v,
                     postAggregateCalculates: y,
                     tooltipSummary: b,
                     tooltipTitleWithFieldName: x
                 } = function(t, e, n, i, r, o, a, s) {
                     let c = [],
                         l = [];
@@ -4760,21 +4810,21 @@
                             calculate: 'datum["center_'.concat(u, '"] + datum["extent_').concat(u, '"]'),
                             as: "upper_".concat(u)
                         }, {
                             calculate: 'datum["center_'.concat(u, '"] - datum["extent_').concat(u, '"]'),
                             as: "lower_".concat(u)
                         }], f = [{
                             fieldPrefix: "center_",
-                            titlePrefix: At(e)
+                            titlePrefix: Dt(e)
                         }, {
                             fieldPrefix: "upper_",
-                            titlePrefix: Zs(e, n, "+")
+                            titlePrefix: tc(e, n, "+")
                         }, {
                             fieldPrefix: "lower_",
-                            titlePrefix: Zs(e, n, "-")
+                            titlePrefix: tc(e, n, "-")
                         }], d = !0;
                         else {
                             let t, e, i;
                             "ci" === n ? (t = "mean", e = "ci0", i = "ci1") : (t = "median", e = "q1", i = "q3"), c = [{
                                 op: e,
                                 field: u,
                                 as: "lower_".concat(u)
@@ -4784,33 +4834,33 @@
                                 as: "upper_".concat(u)
                             }, {
                                 op: t,
                                 field: u,
                                 as: "center_".concat(u)
                             }], f = [{
                                 fieldPrefix: "upper_",
-                                titlePrefix: Ka({
+                                titlePrefix: is({
                                     field: u,
                                     aggregate: i,
                                     type: "quantitative"
                                 }, s, {
                                     allowDisabling: !1
                                 })
                             }, {
                                 fieldPrefix: "lower_",
-                                titlePrefix: Ka({
+                                titlePrefix: is({
                                     field: u,
                                     aggregate: e,
                                     type: "quantitative"
                                 }, s, {
                                     allowDisabling: !1
                                 })
                             }, {
                                 fieldPrefix: "center_",
-                                titlePrefix: Ka({
+                                titlePrefix: is({
                                     field: u,
                                     aggregate: t,
                                     type: "quantitative"
                                 }, s, {
                                     allowDisabling: !1
                                 })
                             }]
@@ -4848,61 +4898,61 @@
                         tooltipTitleWithFieldName: d
                     }
                 }(l, d, h, p, m, f, e, n), {
                     [g]: _,
                     ["x" === g ? "x2" : "y2"]: w,
                     ["x" === g ? "xError" : "yError"]: k,
                     ["x" === g ? "xError2" : "yError2"]: E,
-                    ...D
+                    ...A
                 } = o, {
-                    bins: A,
+                    bins: D,
                     timeUnits: S,
                     aggregate: C,
-                    groupby: F,
-                    encoding: M
-                } = Ss(D, n), O = [...C, ...v], T = "raw" !== f ? [] : F, N = Ts(b, d, M, x);
+                    groupby: M,
+                    encoding: F
+                } = Ts(A, n), O = [...C, ...v], T = "raw" !== f ? [] : M, N = Ls(b, d, F, x);
                 return {
-                    transform: [...null !== (i = c.transform) && void 0 !== i ? i : [], ...A, ...S, ...0 === O.length ? [] : [{
+                    transform: [...null !== (i = c.transform) && void 0 !== i ? i : [], ...D, ...S, ...0 === O.length ? [] : [{
                         aggregate: O,
                         groupby: T
                     }], ...y],
                     groupby: T,
                     continuousAxisChannelDef: d,
                     continuousAxis: g,
-                    encodingWithoutContinuousAxis: M,
+                    encodingWithoutContinuousAxis: F,
                     ticksOrient: "vertical" === u ? "horizontal" : "vertical",
                     markDef: l,
                     outerSpec: c,
                     tooltipEncoding: N
                 }
             }
 
-            function Zs(t, e, n) {
-                return "".concat(At(t), " ").concat(n, " ").concat(e)
+            function tc(t, e, n) {
+                return "".concat(Dt(t), " ").concat(n, " ").concat(e)
             }
-            const Ys = "errorband",
-                Vs = new ws(Ys, Ks);
+            const ec = "errorband",
+                nc = new Ss(ec, ic);
 
-            function Ks(t, e) {
+            function ic(t, e) {
                 let {
                     config: n
                 } = e;
                 t = {
                     ...t,
-                    encoding: Fs(t.encoding, n)
+                    encoding: Rs(t.encoding, n)
                 };
                 const {
                     transform: i,
                     continuousAxisChannelDef: r,
                     continuousAxis: o,
                     encodingWithoutContinuousAxis: a,
                     markDef: s,
                     outerSpec: c,
                     tooltipEncoding: l
-                } = $s(t, Ys, n), u = s, f = zs(u, o, r, a, n.errorband), d = void 0 !== t.encoding.x && void 0 !== t.encoding.y;
+                } = Qs(t, ec, n), u = s, f = Is(u, o, r, a, n.errorband), d = void 0 !== t.encoding.x && void 0 !== t.encoding.y;
                 let h = {
                         type: d ? "area" : "rect"
                     },
                     p = {
                         type: d ? "line" : "rule"
                     };
                 const m = {
@@ -4939,65 +4989,65 @@
                         partName: "borders",
                         mark: p,
                         positionPrefix: "upper",
                         extraEncoding: l
                     })]
                 }
             }
-            const Qs = {};
+            const rc = {};
 
-            function tc(t, e, n) {
-                const i = new ws(t, e);
-                Qs[t] = {
+            function oc(t, e, n) {
+                const i = new Ss(t, e);
+                rc[t] = {
                     normalizer: i,
                     parts: n
                 }
             }
-            tc(Bs, qs, ["box", "median", "outliers", "rule", "ticks"]), tc(Hs, Js, ["ticks", "rule"]), tc(Ys, Ks, ["band", "borders"]);
-            const ec = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],
-                nc = {
+            oc(Hs, Js, ["box", "median", "outliers", "rule", "ticks"]), oc($s, Vs, ["ticks", "rule"]), oc(ec, ic, ["band", "borders"]);
+            const ac = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],
+                sc = {
                     titleAlign: "align",
                     titleAnchor: "anchor",
                     titleAngle: "angle",
                     titleBaseline: "baseline",
                     titleColor: "color",
                     titleFont: "font",
                     titleFontSize: "fontSize",
                     titleFontStyle: "fontStyle",
                     titleFontWeight: "fontWeight",
                     titleLimit: "limit",
                     titleLineHeight: "lineHeight",
                     titleOrient: "orient",
                     titlePadding: "offset"
                 },
-                ic = {
+                cc = {
                     labelAlign: "align",
                     labelAnchor: "anchor",
                     labelAngle: "angle",
                     labelBaseline: "baseline",
                     labelColor: "color",
                     labelFont: "font",
                     labelFontSize: "fontSize",
                     labelFontStyle: "fontStyle",
                     labelFontWeight: "fontWeight",
                     labelLimit: "limit",
                     labelLineHeight: "lineHeight",
                     labelOrient: "orient",
                     labelPadding: "offset"
                 },
-                rc = bt(nc),
-                oc = bt(ic),
-                ac = bt({
+                lc = bt(sc),
+                uc = bt(cc),
+                fc = bt({
                     header: 1,
                     headerRow: 1,
                     headerColumn: 1,
                     headerFacet: 1
                 }),
-                sc = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],
-                cc = {
+                dc = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],
+                hc = {
                     aria: 1,
                     clipHeight: 1,
                     columnPadding: 1,
                     columns: 1,
                     cornerRadius: 1,
                     description: 1,
                     direction: 1,
@@ -5056,19 +5106,19 @@
                     titleOpacity: 1,
                     titleOrient: 1,
                     titlePadding: 1,
                     type: 1,
                     values: 1,
                     zindex: 1
                 },
-                lc = (bt(cc), "_vgsid_"),
-                uc = {
+                pc = (bt(hc), "_vgsid_"),
+                mc = {
                     point: {
                         on: "click",
-                        fields: [lc],
+                        fields: [pc],
                         toggle: "event.shiftKey",
                         resolve: "global",
                         clear: "dblclick"
                     },
                     interval: {
                         on: "[mousedown, window:mouseup] > window:mousemove!",
                         encodings: ["x", "y"],
@@ -5080,30 +5130,30 @@
                             stroke: "white"
                         },
                         resolve: "global",
                         clear: "dblclick"
                     }
                 };
 
-            function fc(t) {
+            function gc(t) {
                 return "legend" === t || !(null === t || void 0 === t || !t.legend)
             }
 
-            function dc(t) {
-                return fc(t) && (0, U.Kn)(t)
+            function vc(t) {
+                return gc(t) && (0, U.Kn)(t)
             }
 
-            function hc(t) {
+            function yc(t) {
                 return !(null === t || void 0 === t || !t.select)
             }
 
-            function pc(t) {
+            function bc(t) {
                 const e = [];
                 for (const n of t || []) {
-                    if (hc(n)) continue;
+                    if (yc(n)) continue;
                     const {
                         expr: t,
                         bind: i,
                         ...r
                     } = n;
                     if (i && t) {
                         const n = {
@@ -5124,91 +5174,91 @@
                         };
                         e.push(n)
                     }
                 }
                 return e
             }
 
-            function mc(t) {
+            function xc(t) {
                 return "concat" in t
             }
 
-            function gc(t) {
+            function _c(t) {
                 return "vconcat" in t
             }
 
-            function vc(t) {
+            function wc(t) {
                 return "hconcat" in t
             }
 
-            function yc(t) {
+            function kc(t) {
                 let {
                     step: e,
                     offsetIsDiscrete: n
                 } = t;
                 var i;
                 return n ? null !== (i = e.for) && void 0 !== i ? i : "offset" : "position"
             }
 
-            function bc(t) {
+            function Ec(t) {
                 return (0, U.Kn)(t) && void 0 !== t.step
             }
 
-            function xc(t) {
+            function Ac(t) {
                 return t.view || t.width || t.height
             }
-            const _c = bt({
+            const Dc = bt({
                 align: 1,
                 bounds: 1,
                 center: 1,
                 columns: 1,
                 spacing: 1
             });
 
-            function wc(t, e) {
+            function Sc(t, e) {
                 var n;
                 return null !== (n = t[e]) && void 0 !== n ? n : t["width" === e ? "continuousWidth" : "continuousHeight"]
             }
 
-            function kc(t, e) {
-                const n = Ec(t, e);
-                return bc(n) ? n.step : Dc
+            function Cc(t, e) {
+                const n = Mc(t, e);
+                return Ec(n) ? n.step : Fc
             }
 
-            function Ec(t, e) {
+            function Mc(t, e) {
                 var n;
-                return zt(null !== (n = t[e]) && void 0 !== n ? n : t["width" === e ? "discreteWidth" : "discreteHeight"], {
+                return Rt(null !== (n = t[e]) && void 0 !== n ? n : t["width" === e ? "discreteWidth" : "discreteHeight"], {
                     step: t.step
                 })
             }
-            const Dc = 20;
-            const Ac = {
+            const Fc = 20;
+            const Oc = {
                     background: "white",
                     padding: 5,
                     timeFormat: "%b %d, %Y",
                     countTitle: "Count of Records",
                     view: {
                         continuousWidth: 200,
                         continuousHeight: 200,
-                        step: Dc
+                        step: Fc
                     },
                     mark: {
                         color: "#4c78a8",
                         invalid: "filter",
                         timeUnitBandSize: 1
                     },
                     arc: {},
                     area: {},
-                    bar: $o,
+                    bar: Qo,
                     circle: {},
                     geoshape: {},
                     image: {},
                     line: {},
                     point: {},
-                    rect: Zo,
+                    rect: ta,
                     rule: {
                         color: "black"
                     },
                     square: {},
                     text: {
                         color: "black"
                     },
@@ -5267,43 +5317,43 @@
                     header: {
                         titlePadding: 10,
                         labelPadding: 10
                     },
                     headerColumn: {},
                     headerRow: {},
                     headerFacet: {},
-                    selection: uc,
+                    selection: mc,
                     style: {},
                     title: {},
                     facet: {
                         spacing: 20
                     },
                     concat: {
                         spacing: 20
                     },
                     normalizedNumberFormat: ".0%"
                 },
-                Sc = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],
-                Cc = {
+                Tc = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],
+                Nc = {
                     text: 11,
                     guideLabel: 10,
                     guideTitle: 11,
                     groupTitle: 13,
                     groupSubtitle: 12
                 },
-                Fc = {
-                    blue: Sc[0],
-                    orange: Sc[1],
-                    red: Sc[2],
-                    teal: Sc[3],
-                    green: Sc[4],
-                    yellow: Sc[5],
-                    purple: Sc[6],
-                    pink: Sc[7],
-                    brown: Sc[8],
+                Rc = {
+                    blue: Tc[0],
+                    orange: Tc[1],
+                    red: Tc[2],
+                    teal: Tc[3],
+                    green: Tc[4],
+                    yellow: Tc[5],
+                    purple: Tc[6],
+                    pink: Tc[7],
+                    brown: Tc[8],
                     gray0: "#000",
                     gray1: "#111",
                     gray2: "#222",
                     gray3: "#333",
                     gray4: "#444",
                     gray5: "#555",
                     gray6: "#666",
@@ -5314,34 +5364,34 @@
                     gray11: "#bbb",
                     gray12: "#ccc",
                     gray13: "#ddd",
                     gray14: "#eee",
                     gray15: "#fff"
                 };
 
-            function Mc(t) {
+            function zc(t) {
                 const e = bt(t || {}),
                     n = {};
                 for (const i of e) {
                     const e = t[i];
-                    n[i] = ps(e) ? mi(e) : gi(e)
+                    n[i] = bs(e) ? mi(e) : gi(e)
                 }
                 return n
             }
-            const Oc = [...Xo, ...xs, ...ac, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];
+            const Pc = [...Yo, ...As, ...fc, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];
 
-            function Tc() {
+            function Lc() {
                 let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                 const {
                     color: e,
                     font: n,
                     fontSize: i,
                     selection: r,
                     ...o
-                } = t, a = (0, U.fE)({}, tt(Ac), n ? function(t) {
+                } = t, a = (0, U.fE)({}, tt(Oc), n ? function(t) {
                     return {
                         text: {
                             font: t
                         },
                         style: {
                             "guide-label": {
                                 font: t
@@ -5359,17 +5409,17 @@
                     }
                 }(n) : {}, e ? function() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                     return {
                         signals: [{
                             name: "color",
                             value: (0, U.Kn)(t) ? {
-                                ...Fc,
+                                ...Rc,
                                 ...t
-                            } : Fc
+                            } : Rc
                         }],
                         mark: {
                             color: {
                                 signal: "color.blue"
                             }
                         },
                         rule: {
@@ -5445,17 +5495,17 @@
                         }
                     }
                 }(e) : {}, i ? function(t) {
                     return {
                         signals: [{
                             name: "fontSize",
                             value: (0, U.Kn)(t) ? {
-                                ...Cc,
+                                ...Nc,
                                 ...t
-                            } : Cc
+                            } : Nc
                         }],
                         text: {
                             fontSize: {
                                 signal: "fontSize.text"
                             }
                         },
                         style: {
@@ -5478,58 +5528,58 @@
                                 fontSize: {
                                     signal: "fontSize.groupSubtitle"
                                 }
                             }
                         }
                     }
                 }(i) : {}, o || {});
-                r && (0, B.writeConfig)(a, "selection", r, !0);
-                const s = it(a, Oc);
+                r && (0, I.writeConfig)(a, "selection", r, !0);
+                const s = it(a, Pc);
                 for (const c of ["background", "lineBreak", "padding"]) a[c] && (s[c] = gi(a[c]));
-                for (const c of Xo) a[c] && (s[c] = ai(a[c]));
-                for (const c of xs) a[c] && (s[c] = Mc(a[c]));
-                for (const c of ac) a[c] && (s[c] = ai(a[c]));
+                for (const c of Yo) a[c] && (s[c] = ai(a[c]));
+                for (const c of As) a[c] && (s[c] = zc(a[c]));
+                for (const c of fc) a[c] && (s[c] = ai(a[c]));
                 return a.legend && (s.legend = ai(a.legend)), a.scale && (s.scale = ai(a.scale)), a.style && (s.style = function(t) {
                     const e = bt(t),
                         n = {};
-                    for (const i of e) n[i] = Mc(t[i]);
+                    for (const i of e) n[i] = zc(t[i]);
                     return n
                 }(a.style)), a.title && (s.title = ai(a.title)), a.view && (s.view = ai(a.view)), s
             }
-            const Nc = new Set(["view", ...Uo]),
-                zc = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],
-                Rc = {
+            const Bc = new Set(["view", ...Go]),
+                Ic = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],
+                jc = {
                     view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
                     area: ["line", "point"],
-                    bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
-                    rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
+                    bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
+                    rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
                     line: ["point"],
                     tick: ["bandSize", "thickness"]
                 };
 
-            function Pc(t) {
+            function Uc(t) {
                 t = tt(t);
-                for (const e of zc) delete t[e];
+                for (const e of Ic) delete t[e];
                 if (t.axis)
-                    for (const e in t.axis) ps(t.axis[e]) && delete t.axis[e];
+                    for (const e in t.axis) bs(t.axis[e]) && delete t.axis[e];
                 if (t.legend)
-                    for (const e of ec) delete t.legend[e];
+                    for (const e of ac) delete t.legend[e];
                 if (t.mark) {
-                    for (const e of Ho) delete t.mark[e];
+                    for (const e of $o) delete t.mark[e];
                     t.mark.tooltip && (0, U.Kn)(t.mark.tooltip) && delete t.mark.tooltip
                 }
-                t.params && (t.signals = (t.signals || []).concat(pc(t.params)), delete t.params);
-                for (const e of Nc) {
-                    for (const i of Ho) delete t[e][i];
-                    const n = Rc[e];
+                t.params && (t.signals = (t.signals || []).concat(bc(t.params)), delete t.params);
+                for (const e of Bc) {
+                    for (const i of $o) delete t[e][i];
+                    const n = jc[e];
                     if (n)
                         for (const i of n) delete t[e][i];
-                    Lc(t, e)
+                    qc(t, e)
                 }
-                for (const e of bt(Qs)) delete t[e];
+                for (const e of bt(rc)) delete t[e];
                 ! function(t) {
                     const {
                         titleMarkConfig: e,
                         subtitleMarkConfig: n,
                         subtitle: i
                     } = si(t.title);
                     yt(e) || (t.style["group-title"] = {
@@ -5542,38 +5592,38 @@
                     });
                     yt(i) ? delete t.title : t.title = i
                 }(t);
                 for (const e in t)(0, U.Kn)(t[e]) && yt(t[e]) && delete t[e];
                 return yt(t) ? void 0 : t
             }
 
-            function Lc(t, e, n, i) {
+            function qc(t, e, n, i) {
                 var r;
                 "view" === e && (n = "cell");
                 const o = {
                     ...i ? t[e][i] : t[e],
                     ...t.style[null !== (r = n) && void 0 !== r ? r : e]
                 };
                 var a;
                 yt(o) || (t.style[null !== (a = n) && void 0 !== a ? a : e] = o);
                 i || delete t[e]
             }
 
-            function jc(t) {
+            function Wc(t) {
                 return "layer" in t
             }
-            class Bc {
+            class Hc {
                 map(t, e) {
-                    return ka(t) ? this.mapFacet(t, e) : function(t) {
+                    return Ca(t) ? this.mapFacet(t, e) : function(t) {
                         return "repeat" in t
-                    }(t) ? this.mapRepeat(t, e) : vc(t) ? this.mapHConcat(t, e) : gc(t) ? this.mapVConcat(t, e) : mc(t) ? this.mapConcat(t, e) : this.mapLayerOrUnit(t, e)
+                    }(t) ? this.mapRepeat(t, e) : wc(t) ? this.mapHConcat(t, e) : _c(t) ? this.mapVConcat(t, e) : xc(t) ? this.mapConcat(t, e) : this.mapLayerOrUnit(t, e)
                 }
                 mapLayerOrUnit(t, e) {
-                    if (jc(t)) return this.mapLayer(t, e);
-                    if (_s(t)) return this.mapUnit(t, e);
+                    if (Wc(t)) return this.mapLayer(t, e);
+                    if (Ds(t)) return this.mapUnit(t, e);
                     throw new Error(Oi(t))
                 }
                 mapLayer(t, e) {
                     return {
                         ...t,
                         layer: t.layer.map((t => this.mapLayerOrUnit(t, e)))
                     }
@@ -5609,66 +5659,66 @@
                 mapRepeat(t, e) {
                     return {
                         ...t,
                         spec: this.map(t.spec, e)
                     }
                 }
             }
-            const Ic = {
+            const Xc = {
                 zero: 1,
                 center: 1,
                 normalize: 1
             };
-            const Uc = new Set([Do, So, Ao, To, Mo, Po, Lo, Fo, No, zo]),
-                qc = new Set([So, Ao, Do]);
+            const Gc = new Set([Fo, To, Oo, Lo, zo, Uo, qo, Ro, Bo, Io]),
+                Jc = new Set([To, Oo, Fo]);
 
-            function Wc(t) {
-                return Na(t) && "quantitative" === za(t) && !t.bin
+            function Zc(t) {
+                return Ba(t) && "quantitative" === Ia(t) && !t.bin
             }
 
-            function Hc(t, e, n) {
+            function $c(t, e, n) {
                 let {
                     orient: i,
                     type: r
                 } = n;
                 const o = "x" === e ? "y" : "radius",
                     a = "x" === e,
                     s = t[e],
                     c = t[o];
-                if (Na(s) && Na(c))
-                    if (Wc(s) && Wc(c)) {
+                if (Ba(s) && Ba(c))
+                    if (Zc(s) && Zc(c)) {
                         if (s.stack) return e;
                         if (c.stack) return o;
-                        const t = Na(s) && !!s.aggregate;
-                        if (t !== (Na(c) && !!c.aggregate)) return t ? e : o;
+                        const t = Ba(s) && !!s.aggregate;
+                        if (t !== (Ba(c) && !!c.aggregate)) return t ? e : o;
                         if (a && "bar" === r) {
                             if ("vertical" === i) return o;
                             if ("horizontal" === i) return e
                         }
                     } else {
-                        if (Wc(s)) return e;
-                        if (Wc(c)) return o
+                        if (Zc(s)) return e;
+                        if (Zc(c)) return o
                     }
                 else {
-                    if (Wc(s)) return e;
-                    if (Wc(c)) return o
+                    if (Zc(s)) return e;
+                    if (Zc(c)) return o
                 }
             }
 
-            function Xc(t, e) {
+            function Yc(t, e) {
                 var n, i;
-                const r = qo(t) ? t : {
+                const r = Jo(t) ? t : {
                         type: t
                     },
                     o = r.type;
-                if (!Uc.has(o)) return null;
-                const a = Hc(e, "x", r) || Hc(e, "theta", r);
+                if (!Gc.has(o)) return null;
+                const a = $c(e, "x", r) || $c(e, "theta", r);
                 if (!a) return null;
                 const s = e[a],
-                    c = Na(s) ? Ga(s, {}) : void 0,
+                    c = Ba(s) ? Ka(s, {}) : void 0,
                     l = function(t) {
                         switch (t) {
                             case "x":
                                 return "y";
                             case "y":
                                 return "x";
                             case "theta":
@@ -5677,127 +5727,127 @@
                                 return "theta"
                         }
                     }(a),
                     u = [],
                     f = new Set;
                 if (e[l]) {
                     const t = e[l],
-                        n = Na(t) ? Ga(t, {}) : void 0;
+                        n = Ba(t) ? Ka(t, {}) : void 0;
                     n && n !== c && (u.push(l), f.add(n));
                     const i = "x" === l ? "xOffset" : "yOffset",
                         r = e[i],
-                        o = Na(r) ? Ga(r, {}) : void 0;
+                        o = Ba(r) ? Ka(r, {}) : void 0;
                     o && o !== c && (u.push(i), f.add(o))
                 }
                 const d = vn.reduce(((t, n) => {
-                    if ("tooltip" !== n && ks(e, n)) {
+                    if ("tooltip" !== n && Cs(e, n)) {
                         const i = e[n];
                         for (const e of (0, U.IX)(i)) {
-                            const i = ns(e);
+                            const i = ss(e);
                             if (i.aggregate) continue;
-                            const r = Ga(i, {});
+                            const r = Ka(i, {});
                             r && f.has(r) || t.push({
                                 channel: n,
                                 fieldDef: i
                             })
                         }
                     }
                     return t
                 }), []);
                 let h;
-                return void 0 !== s.stack ? h = (0, U.jn)(s.stack) ? s.stack ? "zero" : null : s.stack : qc.has(o) && (h = "zero"), h && h in Ic ? As(e) && 0 === d.length ? null : null !== s && void 0 !== s && null !== (n = s.scale) && void 0 !== n && n.type && (null === s || void 0 === s || null === (i = s.scale) || void 0 === i ? void 0 : i.type) !== Yr.LINEAR ? (null !== s && void 0 !== s && s.stack && dr(function(t) {
+                return void 0 !== s.stack ? h = (0, U.jn)(s.stack) ? s.stack ? "zero" : null : s.stack : Jc.has(o) && (h = "zero"), h && h in Xc ? Os(e) && 0 === d.length ? null : null !== s && void 0 !== s && null !== (n = s.scale) && void 0 !== n && n.type && (null === s || void 0 === s || null === (i = s.scale) || void 0 === i ? void 0 : i.type) !== eo.LINEAR ? (null !== s && void 0 !== s && s.stack && dr(function(t) {
                     return "Cannot stack non-linear scale (".concat(t, ").")
-                }(s.scale.type)), null) : Ba(e[Ze(a)]) ? (void 0 !== s.stack && dr('Cannot stack "'.concat(p = a, '" if there is already "').concat(p, '2".')), null) : (Na(s) && s.aggregate && !Vn.has(s.aggregate) && dr((m = s.aggregate, 'Stacking is applied even though the aggregate function is non-summative ("'.concat(m, '").'))), {
+                }(s.scale.type)), null) : Ha(e[$e(a)]) ? (void 0 !== s.stack && dr('Cannot stack "'.concat(p = a, '" if there is already "').concat(p, '2".')), null) : (Ba(s) && s.aggregate && !Vn.has(s.aggregate) && dr((m = s.aggregate, 'Stacking is applied even though the aggregate function is non-summative ("'.concat(m, '").'))), {
                     groupbyChannels: u,
                     groupbyFields: f,
                     fieldChannel: a,
-                    impute: null !== s.impute && Bo(o),
+                    impute: null !== s.impute && Ho(o),
                     stackBy: d,
                     offset: h
                 }) : null;
                 var p, m
             }
 
-            function Jc(t) {
+            function Vc(t) {
                 const {
                     point: e,
                     line: n,
                     ...i
                 } = t;
                 return bt(i).length > 1 ? i : i.type
             }
 
-            function Gc(t) {
+            function Kc(t) {
                 for (const e of ["line", "area", "rule", "trail"]) t[e] && (t = {
                     ...t,
                     [e]: it(t[e], ["point", "line"])
                 });
                 return t
             }
 
-            function $c(t) {
+            function Qc(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                     n = arguments.length > 2 ? arguments[2] : void 0;
                 return "transparent" === t.point ? {
                     opacity: 0
                 } : t.point ? (0, U.Kn)(t.point) ? t.point : {} : void 0 !== t.point ? null : e.point || n.shape ? (0, U.Kn)(e.point) ? e.point : {} : void 0
             }
 
-            function Zc(t) {
+            function tl(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 return t.line ? !0 === t.line ? {} : t.line : void 0 !== t.line ? null : e.line ? !0 === e.line ? {} : e.line : void 0
             }
-            class Yc {
+            class el {
                 constructor() {
                     this.name = "path-overlay"
                 }
                 hasMatchingType(t, e) {
-                    if (_s(t)) {
+                    if (Ds(t)) {
                         const {
                             mark: n,
                             encoding: i
-                        } = t, r = qo(n) ? n : {
+                        } = t, r = Jo(n) ? n : {
                             type: n
                         };
                         switch (r.type) {
                             case "line":
                             case "rule":
                             case "trail":
-                                return !!$c(r, e[r.type], i);
+                                return !!Qc(r, e[r.type], i);
                             case "area":
-                                return !!$c(r, e[r.type], i) || !!Zc(r, e[r.type])
+                                return !!Qc(r, e[r.type], i) || !!tl(r, e[r.type])
                         }
                     }
                     return !1
                 }
                 run(t, e, n) {
                     const {
                         config: i
                     } = e, {
                         params: r,
                         projection: o,
                         mark: a,
                         name: s,
                         encoding: c,
                         ...l
-                    } = t, u = Fs(c, i), f = qo(a) ? a : {
+                    } = t, u = Rs(c, i), f = Jo(a) ? a : {
                         type: a
-                    }, d = $c(f, i[f.type], u), h = "area" === f.type && Zc(f, i[f.type]), p = [{
+                    }, d = Qc(f, i[f.type], u), h = "area" === f.type && tl(f, i[f.type]), p = [{
                         name: s,
                         ...r ? {
                             params: r
                         } : {},
-                        mark: Jc({
+                        mark: Vc({
                             ..."area" === f.type && void 0 === f.opacity && void 0 === f.fillOpacity ? {
                                 opacity: .7
                             } : {},
                             ...f
                         }),
                         encoding: it(u, ["shape"])
-                    }], m = Xc(f, u);
+                    }], m = Yc(f, u);
                     let g = u;
                     if (m) {
                         const {
                             fieldChannel: t,
                             offset: e
                         } = m;
                         g = {
@@ -5833,114 +5883,114 @@
                         },
                         encoding: g
                     }), n({
                         ...l,
                         layer: p
                     }, {
                         ...e,
-                        config: Gc(i)
+                        config: Kc(i)
                     })
                 }
             }
 
-            function Vc(t, e) {
-                return e ? _a(t) ? il(t, e) : tl(t, e) : t
+            function nl(t, e) {
+                return e ? Da(t) ? cl(t, e) : ol(t, e) : t
             }
 
-            function Kc(t, e) {
-                return e ? il(t, e) : t
+            function il(t, e) {
+                return e ? cl(t, e) : t
             }
 
-            function Qc(t, e, n) {
+            function rl(t, e, n) {
                 const i = e[t];
                 return (r = i) && !(0, U.HD)(r) && "repeat" in r ? i.repeat in n ? {
                     ...e,
                     [t]: n[i.repeat]
                 } : void dr(function(t) {
                     return 'Unknown repeated value "'.concat(t, '".')
                 }(i.repeat)) : e;
                 var r
             }
 
-            function tl(t, e) {
-                if (void 0 !== (t = Qc("field", t, e))) {
+            function ol(t, e) {
+                if (void 0 !== (t = rl("field", t, e))) {
                     if (null === t) return null;
-                    if (Da(t) && ba(t.sort)) {
-                        const n = Qc("field", t.sort, e);
+                    if (Fa(t) && Ea(t.sort)) {
+                        const n = rl("field", t.sort, e);
                         t = {
                             ...t,
                             ...n ? {
                                 sort: n
                             } : {}
                         }
                     }
                     return t
                 }
             }
 
-            function el(t, e) {
-                if (Na(t)) return tl(t, e);
+            function al(t, e) {
+                if (Ba(t)) return ol(t, e);
                 {
-                    const n = Qc("datum", t, e);
+                    const n = rl("datum", t, e);
                     return n === t || n.type || (n.type = "nominal"), n
                 }
             }
 
-            function nl(t, e) {
-                if (!Ba(t)) {
-                    if (Ta(t)) {
-                        const n = el(t.condition, e);
+            function sl(t, e) {
+                if (!Ha(t)) {
+                    if (La(t)) {
+                        const n = al(t.condition, e);
                         if (n) return {
                             ...t,
                             condition: n
                         };
                         {
                             const {
                                 condition: e,
                                 ...n
                             } = t;
                             return n
                         }
                     }
                     return t
                 } {
-                    const n = el(t, e);
+                    const n = al(t, e);
                     if (n) return n;
-                    if (Ma(t)) return {
+                    if (za(t)) return {
                         condition: t.condition
                     }
                 }
             }
 
-            function il(t, e) {
+            function cl(t, e) {
                 const n = {};
                 for (const i in t)
                     if ((0, U.nr)(t, i)) {
                         const r = t[i];
-                        if ((0, U.kJ)(r)) n[i] = r.map((t => nl(t, e))).filter((t => t));
+                        if ((0, U.kJ)(r)) n[i] = r.map((t => sl(t, e))).filter((t => t));
                         else {
-                            const t = nl(r, e);
+                            const t = sl(r, e);
                             void 0 !== t && (n[i] = t)
                         }
                     } return n
             }
-            class rl {
+            class ll {
                 constructor() {
                     this.name = "RuleForRangedLine"
                 }
                 hasMatchingType(t) {
-                    if (_s(t)) {
+                    if (Ds(t)) {
                         const {
                             encoding: e,
                             mark: n
                         } = t;
-                        if ("line" === n || qo(n) && "line" === n.type)
+                        if ("line" === n || Jo(n) && "line" === n.type)
                             for (const t of Xe) {
-                                const n = e[Ge(t)];
-                                if (e[t] && (Na(n) && !ei(n.bin) || Ra(n))) return !0
+                                const n = e[Je(t)];
+                                if (e[t] && (Ba(n) && !ei(n.bin) || ja(n))) return !0
                             }
                     }
                     return !1
                 }
                 run(t, e, n) {
                     const {
                         encoding: i,
@@ -5953,44 +6003,44 @@
                             ...r,
                             type: "rule"
                         } : "rule"
                     }, e)
                 }
             }
 
-            function ol(t) {
+            function ul(t) {
                 let {
                     parentEncoding: e,
                     encoding: n = {},
                     layer: i
                 } = t, r = {};
                 if (e) {
                     const t = new Set([...bt(e), ...bt(n)]);
                     for (const o of t) {
                         const t = n[o],
                             a = e[o];
-                        if (Ba(t)) {
+                        if (Ha(t)) {
                             const e = {
                                 ...a,
                                 ...t
                             };
                             r[o] = e
-                        } else Ta(t) ? r[o] = {
+                        } else La(t) ? r[o] = {
                             ...t,
                             condition: {
                                 ...a,
                                 ...t.condition
                             }
-                        } : t || null === t ? r[o] = t : (i || Ua(a) || li(a) || Ba(a) || (0, U.kJ)(a)) && (r[o] = a)
+                        } : t || null === t ? r[o] = t : (i || Ga(a) || li(a) || Ha(a) || (0, U.kJ)(a)) && (r[o] = a)
                     }
                 } else r = n;
                 return !r || yt(r) ? void 0 : r
             }
 
-            function al(t) {
+            function fl(t) {
                 const {
                     parentProjection: e,
                     projection: n
                 } = t;
                 return e && n && dr(function(t) {
                     const {
                         parentProjection: e,
@@ -5999,105 +6049,109 @@
                     return "Layer's shared projection ".concat(rt(e), " is overridden by a child projection ").concat(rt(n), ".")
                 }({
                     parentProjection: e,
                     projection: n
                 })), null !== n && void 0 !== n ? n : e
             }
 
-            function sl(t) {
+            function dl(t) {
                 return "filter" in t
             }
 
-            function cl(t) {
+            function hl(t) {
                 return void 0 !== (null === t || void 0 === t ? void 0 : t.stop)
             }
 
-            function ll(t) {
+            function pl(t) {
                 return "lookup" in t
             }
 
-            function ul(t) {
+            function ml(t) {
                 return "pivot" in t
             }
 
-            function fl(t) {
+            function gl(t) {
                 return "density" in t
             }
 
-            function dl(t) {
+            function vl(t) {
                 return "quantile" in t
             }
 
-            function hl(t) {
+            function yl(t) {
                 return "regression" in t
             }
 
-            function pl(t) {
+            function bl(t) {
                 return "loess" in t
             }
 
-            function ml(t) {
+            function xl(t) {
                 return "sample" in t
             }
 
-            function gl(t) {
+            function _l(t) {
                 return "window" in t
             }
 
-            function vl(t) {
+            function wl(t) {
                 return "joinaggregate" in t
             }
 
-            function yl(t) {
+            function kl(t) {
                 return "flatten" in t
             }
 
-            function bl(t) {
+            function El(t) {
                 return "calculate" in t
             }
 
-            function xl(t) {
+            function Al(t) {
                 return "bin" in t
             }
 
-            function _l(t) {
+            function Dl(t) {
                 return "impute" in t
             }
 
-            function wl(t) {
+            function Sl(t) {
                 return "timeUnit" in t
             }
 
-            function kl(t) {
+            function Cl(t) {
                 return "aggregate" in t
             }
 
-            function El(t) {
+            function Ml(t) {
                 return "stack" in t
             }
 
-            function Dl(t) {
+            function Fl(t) {
                 return "fold" in t
             }
 
-            function Al(t, e) {
+            function Ol(t) {
+                return "extent" in t && !("density" in t)
+            }
+
+            function Tl(t, e) {
                 const {
                     transform: n,
                     ...i
                 } = t;
                 if (n) {
                     const t = n.map((t => {
-                        if (sl(t)) return {
-                            filter: Fl(t, e)
+                        if (dl(t)) return {
+                            filter: zl(t, e)
                         };
-                        if (xl(t) && ni(t.bin)) return {
+                        if (Al(t) && ni(t.bin)) return {
                             ...t,
-                            bin: Cl(t.bin)
+                            bin: Rl(t.bin)
                         };
-                        if (ll(t)) {
+                        if (pl(t)) {
                             const {
                                 selection: e,
                                 ...n
                             } = t.from;
                             return e ? {
                                 ...t,
                                 from: {
@@ -6112,57 +6166,57 @@
                         ...i,
                         transform: t
                     }
                 }
                 return t
             }
 
-            function Sl(t, e) {
+            function Nl(t, e) {
                 var n, i;
                 const r = tt(t);
-                if (Na(r) && ni(r.bin) && (r.bin = Cl(r.bin)), qa(r) && null !== (n = r.scale) && void 0 !== n && null !== (i = n.domain) && void 0 !== i && i.selection) {
+                if (Ba(r) && ni(r.bin) && (r.bin = Rl(r.bin)), Ja(r) && null !== (n = r.scale) && void 0 !== n && null !== (i = n.domain) && void 0 !== i && i.selection) {
                     const {
                         selection: t,
                         ...e
                     } = r.scale.domain;
                     r.scale.domain = {
                         ...e,
                         ...t ? {
                             param: t
                         } : {}
                     }
                 }
-                if (Ma(r))
-                    if ((0, B.isArray)(r.condition)) r.condition = r.condition.map((t => {
+                if (za(r))
+                    if ((0, I.isArray)(r.condition)) r.condition = r.condition.map((t => {
                         const {
                             selection: n,
                             param: i,
                             test: r,
                             ...o
                         } = t;
                         return i ? t : {
                             ...o,
-                            test: Fl(t, e)
+                            test: zl(t, e)
                         }
                     }));
                     else {
                         const {
                             selection: t,
                             param: n,
                             test: i,
                             ...o
-                        } = Sl(r.condition, e);
+                        } = Nl(r.condition, e);
                         r.condition = n ? r.condition : {
                             ...o,
-                            test: Fl(r.condition, e)
+                            test: zl(r.condition, e)
                         }
                     } return r
             }
 
-            function Cl(t) {
+            function Rl(t) {
                 const e = t.extent;
                 if (null !== e && void 0 !== e && e.selection) {
                     const {
                         selection: n,
                         ...i
                     } = e;
                     return {
@@ -6172,94 +6226,94 @@
                             param: n
                         }
                     }
                 }
                 return t
             }
 
-            function Fl(t, e) {
+            function zl(t, e) {
                 const n = t => K(t, (t => {
                     var n, i, r;
                     const o = {
                         param: t,
                         empty: null === (n = e.emptySelections[t]) || void 0 === n || n
                     };
                     return null !== (i = (r = e.selectionPredicates)[t]) && void 0 !== i || (r[t] = []), e.selectionPredicates[t].push(o), o
                 }));
                 return t.selection ? n(t.selection) : K(t.test || t.filter, (t => t.selection ? n(t.selection) : t))
             }
-            class Ml extends Bc {
+            class Pl extends Hc {
                 map(t, e) {
                     var n;
                     const i = null !== (n = e.selections) && void 0 !== n ? n : [];
-                    if (t.params && !_s(t)) {
+                    if (t.params && !Ds(t)) {
                         const e = [];
-                        for (const n of t.params) hc(n) ? i.push(n) : e.push(n);
+                        for (const n of t.params) yc(n) ? i.push(n) : e.push(n);
                         t.params = e
                     }
                     return e.selections = i, super.map(t, e)
                 }
                 mapUnit(t, e) {
                     var n;
                     const i = e.selections;
                     if (!i || !i.length) return t;
                     const r = (null !== (n = e.path) && void 0 !== n ? n : []).concat(t.name),
                         o = [];
                     for (const a of i)
                         if (a.views && a.views.length)
-                            for (const e of a.views)((0, B.isString)(e) && (e === t.name || r.includes(e)) || (0, B.isArray)(e) && e.map((t => r.indexOf(t))).every(((t, e, n) => -1 !== t && (0 === e || t > n[e - 1])))) && o.push(a);
+                            for (const e of a.views)((0, I.isString)(e) && (e === t.name || r.includes(e)) || (0, I.isArray)(e) && e.map((t => r.indexOf(t))).every(((t, e, n) => -1 !== t && (0 === e || t > n[e - 1])))) && o.push(a);
                         else o.push(a);
                     return o.length && (t.params = o), t
                 }
             }
-            for (const cy of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
-                const t = Ml.prototype[cy];
-                Ml.prototype[cy] = function(e, n) {
-                    return t.call(this, e, Ol(e, n))
+            for (const hy of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
+                const t = Pl.prototype[hy];
+                Pl.prototype[hy] = function(e, n) {
+                    return t.call(this, e, Ll(e, n))
                 }
             }
 
-            function Ol(t, e) {
+            function Ll(t, e) {
                 var n;
                 return t.name ? {
                     ...e,
                     path: (null !== (n = e.path) && void 0 !== n ? n : []).concat(t.name)
                 } : e
             }
 
-            function Tl(t, e) {
-                void 0 === e && (e = Tc(t.config));
+            function Bl(t, e) {
+                void 0 === e && (e = Lc(t.config));
                 const n = function(t) {
                         let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                         const n = {
                             config: e
                         };
-                        return Rl.map(Nl.map(zl.map(t, n), n), n)
+                        return Ul.map(Il.map(jl.map(t, n), n), n)
                     }(t, e),
                     {
                         width: i,
                         height: r
                     } = t,
                     o = function(t, e, n) {
                         let {
                             width: i,
                             height: r
                         } = e;
-                        const o = _s(t) || jc(t),
+                        const o = Ds(t) || Wc(t),
                             a = {};
                         o ? "container" == i && "container" == r ? (a.type = "fit", a.contains = "padding") : "container" == i ? (a.type = "fit-x", a.contains = "padding") : "container" == r && (a.type = "fit-y", a.contains = "padding") : ("container" == i && (dr(Ni("width")), i = void 0), "container" == r && (dr(Ni("height")), r = void 0));
                         const s = {
                             type: "pad",
                             ...a,
-                            ...n ? Pl(n.autosize) : {},
-                            ...Pl(t.autosize)
+                            ...n ? ql(n.autosize) : {},
+                            ...ql(t.autosize)
                         };
                         "fit" !== s.type || o || (dr(Ti), s.type = "pad");
-                        "container" == i && "fit" != s.type && "fit-x" != s.type && dr(zi("width"));
-                        "container" == r && "fit" != s.type && "fit-y" != s.type && dr(zi("height"));
+                        "container" == i && "fit" != s.type && "fit-x" != s.type && dr(Ri("width"));
+                        "container" == r && "fit" != s.type && "fit-y" != s.type && dr(Ri("height"));
                         if (Q(s, {
                                 type: "pad"
                             })) return;
                         return s
                     }(n, {
                         width: i,
                         height: r,
@@ -6268,32 +6322,32 @@
                 return {
                     ...n,
                     ...o ? {
                         autosize: o
                     } : {}
                 }
             }
-            const Nl = new class extends Bc {
+            const Il = new class extends Hc {
                     constructor() {
-                        super(...arguments), this.nonFacetUnitNormalizers = [Is, Xs, Vs, new Yc, new rl]
+                        super(...arguments), this.nonFacetUnitNormalizers = [Xs, Ys, nc, new el, new ll]
                     }
                     map(t, e) {
-                        if (_s(t)) {
-                            const n = ks(t.encoding, qt),
-                                i = ks(t.encoding, Wt),
-                                r = ks(t.encoding, Ht);
+                        if (Ds(t)) {
+                            const n = Cs(t.encoding, qt),
+                                i = Cs(t.encoding, Wt),
+                                r = Cs(t.encoding, Ht);
                             if (n || i || r) return this.mapFacetedUnit(t, e)
                         }
                         return super.map(t, e)
                     }
                     mapUnit(t, e) {
                         const {
                             parentEncoding: n,
                             parentProjection: i
-                        } = e, r = Kc(t.encoding, e.repeater), o = {
+                        } = e, r = il(t.encoding, e.repeater), o = {
                             ...t,
                             ...t.name ? {
                                 name: [e.repeaterPrefix, t.name].filter((t => t)).join("_")
                             } : {},
                             ...r ? {
                                 encoding: r
                             } : {}
@@ -6398,30 +6452,30 @@
                             concat: s
                         }
                     }
                     mapFacet(t, e) {
                         const {
                             facet: n
                         } = t;
-                        return _a(n) && t.columns && (t = it(t, ["columns"]), dr(Ui("facet"))), super.mapFacet(t, e)
+                        return Da(n) && t.columns && (t = it(t, ["columns"]), dr(Ui("facet"))), super.mapFacet(t, e)
                     }
                     mapUnitWithParentEncodingOrProjection(t, e) {
                         const {
                             encoding: n,
                             projection: i
                         } = t, {
                             parentEncoding: r,
                             parentProjection: o,
                             config: a
-                        } = e, s = al({
+                        } = e, s = fl({
                             parentProjection: o,
                             projection: i
-                        }), c = ol({
+                        }), c = ul({
                             parentEncoding: r,
-                            encoding: Kc(n, e.repeater)
+                            encoding: il(n, e.repeater)
                         });
                         return this.mapUnit({
                             ...t,
                             ...s ? {
                                 projection: s
                             } : {},
                             ...c ? {
@@ -6449,15 +6503,15 @@
                         } = t, {
                             facetMapping: p,
                             layout: m
                         } = this.getFacetMappingAndLayout({
                             row: n,
                             column: i,
                             facet: r
-                        }, e), g = Kc(o, e.repeater);
+                        }, e), g = il(o, e.repeater);
                         return this.mapFacet({
                             ...h,
                             ...m,
                             facet: p,
                             spec: {
                                 ...s ? {
                                     width: s
@@ -6515,15 +6569,15 @@
                                 align: t,
                                 center: n,
                                 spacing: i,
                                 columns: o,
                                 ...a
                             } = r;
                             return {
-                                facetMapping: Vc(a, e.repeater),
+                                facetMapping: nl(a, e.repeater),
                                 layout: {
                                     ...t ? {
                                         align: t
                                     } : {},
                                     ...n ? {
                                         center: n
                                     } : {},
@@ -6546,41 +6600,41 @@
                         } = e;
                         const {
                             encoding: o,
                             projection: a,
                             ...s
                         } = t, c = {
                             ...r,
-                            parentEncoding: ol({
+                            parentEncoding: ul({
                                 parentEncoding: n,
                                 encoding: o,
                                 layer: !0
                             }),
-                            parentProjection: al({
+                            parentProjection: fl({
                                 parentProjection: i,
                                 projection: a
                             })
                         };
                         return super.mapLayer({
                             ...s,
                             ...t.name ? {
                                 name: [c.repeaterPrefix, t.name].filter((t => t)).join("_")
                             } : {}
                         }, c)
                     }
                 },
-                zl = new class extends Bc {
+                jl = new class extends Hc {
                     map(t, e) {
                         var n, i;
-                        return null !== (n = e.emptySelections) && void 0 !== n || (e.emptySelections = {}), null !== (i = e.selectionPredicates) && void 0 !== i || (e.selectionPredicates = {}), t = Al(t, e), super.map(t, e)
+                        return null !== (n = e.emptySelections) && void 0 !== n || (e.emptySelections = {}), null !== (i = e.selectionPredicates) && void 0 !== i || (e.selectionPredicates = {}), t = Tl(t, e), super.map(t, e)
                     }
                     mapLayerOrUnit(t, e) {
-                        if ((t = Al(t, e)).encoding) {
+                        if ((t = Tl(t, e)).encoding) {
                             const n = {};
-                            for (const [i, r] of _t(t.encoding)) n[i] = Sl(r, e);
+                            for (const [i, r] of _t(t.encoding)) n[i] = Nl(r, e);
                             t = {
                                 ...t,
                                 encoding: n
                             }
                         }
                         return super.mapLayerOrUnit(t, e)
                     }
@@ -6610,45 +6664,45 @@
                                     select: s,
                                     bind: o
                                 }
                             }))
                         } : t
                     }
                 },
-                Rl = new Ml;
+                Ul = new Pl;
 
-            function Pl(t) {
+            function ql(t) {
                 return (0, U.HD)(t) ? {
                     type: t
                 } : null !== t && void 0 !== t ? t : {}
             }
-            const Ll = ["background", "padding"];
+            const Wl = ["background", "padding"];
 
-            function jl(t, e) {
+            function Hl(t, e) {
                 const n = {};
-                for (const i of Ll) t && void 0 !== t[i] && (n[i] = gi(t[i]));
+                for (const i of Wl) t && void 0 !== t[i] && (n[i] = gi(t[i]));
                 return e && (n.params = t.params), n
             }
-            class Bl {
+            class Xl {
                 constructor() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                         e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     this.explicit = t, this.implicit = e
                 }
                 clone() {
-                    return new Bl(tt(this.explicit), tt(this.implicit))
+                    return new Xl(tt(this.explicit), tt(this.implicit))
                 }
                 combine() {
                     return {
                         ...this.explicit,
                         ...this.implicit
                     }
                 }
                 get(t) {
-                    return zt(this.explicit[t], this.implicit[t])
+                    return Rt(this.explicit[t], this.implicit[t])
                 }
                 getWithExplicit(t) {
                     return void 0 !== this.explicit[t] ? {
                         explicit: !0,
                         value: this.explicit[t]
                     } : void 0 !== this.implicit[t] ? {
                         explicit: !1,
@@ -6682,160 +6736,160 @@
                     for (const e of bt(t.combine())) {
                         const n = t.getWithExplicit(e);
                         this.setWithExplicit(e, n)
                     }
                 }
             }
 
-            function Il(t) {
+            function Gl(t) {
                 return {
                     explicit: !0,
                     value: t
                 }
             }
 
-            function Ul(t) {
+            function Jl(t) {
                 return {
                     explicit: !1,
                     value: t
                 }
             }
 
-            function ql(t) {
+            function Zl(t) {
                 return (e, n, i, r) => {
                     const o = t(e.value, n.value);
-                    return o > 0 ? e : o < 0 ? n : Wl(e, n, i, r)
+                    return o > 0 ? e : o < 0 ? n : $l(e, n, i, r)
                 }
             }
 
-            function Wl(t, e, n, i) {
+            function $l(t, e, n, i) {
                 return t.explicit && e.explicit && dr(function(t, e, n, i) {
                     return "Conflicting ".concat(e.toString(), ' property "').concat(t.toString(), '" (').concat(rt(n), " and ").concat(rt(i), "). Using ").concat(rt(n), ".")
                 }(n, i, t.value, e.value)), t
             }
 
-            function Hl(t, e, n, i) {
-                let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Wl;
+            function Yl(t, e, n, i) {
+                let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : $l;
                 return void 0 === t || void 0 === t.value ? e : t.explicit && !e.explicit ? t : e.explicit && !t.explicit ? e : Q(t.value, e.value) ? t : r(t, e, n, i)
             }
-            class Xl extends Bl {
+            class Vl extends Xl {
                 constructor() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                         e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                         n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                     super(t, e), this.explicit = t, this.implicit = e, this.parseNothing = n
                 }
                 clone() {
                     const t = super.clone();
                     return t.parseNothing = this.parseNothing, t
                 }
             }
 
-            function Jl(t) {
+            function Kl(t) {
                 return "url" in t
             }
 
-            function Gl(t) {
+            function Ql(t) {
                 return "values" in t
             }
 
-            function $l(t) {
-                return "name" in t && !Jl(t) && !Gl(t) && !Zl(t)
+            function tu(t) {
+                return "name" in t && !Kl(t) && !Ql(t) && !eu(t)
             }
 
-            function Zl(t) {
-                return t && (Yl(t) || Vl(t) || Kl(t))
+            function eu(t) {
+                return t && (nu(t) || iu(t) || ru(t))
             }
 
-            function Yl(t) {
+            function nu(t) {
                 return "sequence" in t
             }
 
-            function Vl(t) {
+            function iu(t) {
                 return "sphere" in t
             }
 
-            function Kl(t) {
+            function ru(t) {
                 return "graticule" in t
             }
-            var Ql;
+            var ou;
             ! function(t) {
                 t[t.Raw = 0] = "Raw", t[t.Main = 1] = "Main", t[t.Row = 2] = "Row", t[t.Column = 3] = "Column", t[t.Lookup = 4] = "Lookup"
-            }(Ql || (Ql = {}));
-            var tu = n(77155);
+            }(ou || (ou = {}));
+            var au = n(77155);
 
-            function eu(t) {
+            function su(t) {
                 const {
                     signals: e,
                     hasLegend: n,
                     index: i,
                     ...r
                 } = t;
-                return r.field = Mt(r.field), r
+                return r.field = Ft(r.field), r
             }
 
-            function nu(t) {
+            function cu(t) {
                 let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                     n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : U.yR;
                 if ((0, U.kJ)(t)) {
-                    const i = t.map((t => nu(t, e, n)));
+                    const i = t.map((t => cu(t, e, n)));
                     return e ? "[".concat(i.join(", "), "]") : i
                 }
                 return hr(t) ? n(e ? br(t) : function(t) {
                     const e = yr(t, !0);
                     return t.utc ? +new Date(Date.UTC(...e)) : +new Date(...e)
                 }(t)) : e ? n(rt(t)) : t
             }
 
-            function iu(t, e) {
+            function lu(t, e) {
                 for (const i of xt(null !== (n = t.component.selection) && void 0 !== n ? n : {})) {
                     var n;
                     const r = i.name;
-                    let o = "".concat(r).concat(wf, ", ").concat("global" === i.resolve ? "true" : "{unit: ".concat(Af(t), "}"));
-                    for (const n of Df) n.defined(i) && (n.signals && (e = n.signals(t, i, e)), n.modifyExpr && (o = n.modifyExpr(t, i, o)));
+                    let o = "".concat(r).concat(Ff, ", ").concat("global" === i.resolve ? "true" : "{unit: ".concat(Rf(t), "}"));
+                    for (const n of Nf) n.defined(i) && (n.signals && (e = n.signals(t, i, e)), n.modifyExpr && (o = n.modifyExpr(t, i, o)));
                     e.push({
-                        name: r + kf,
+                        name: r + Of,
                         on: [{
                             events: {
-                                signal: i.name + wf
+                                signal: i.name + Ff
                             },
-                            update: "modify(".concat((0, U.m8)(i.name + _f), ", ").concat(o, ")")
+                            update: "modify(".concat((0, U.m8)(i.name + Mf), ", ").concat(o, ")")
                         }]
                     })
                 }
-                return au(e)
+                return du(e)
             }
 
-            function ru(t, e) {
+            function uu(t, e) {
                 if (t.component.selection && bt(t.component.selection).length) {
                     const n = (0, U.m8)(t.getName("cell"));
                     e.unshift({
                         name: "facet",
                         value: {},
                         on: [{
-                            events: (0, tu.r)("mousemove", "scope"),
+                            events: (0, au.r)("mousemove", "scope"),
                             update: "isTuple(facet) ? facet : group(".concat(n, ").datum")
                         }]
                     })
                 }
-                return au(e)
+                return du(e)
             }
 
-            function ou(t, e) {
+            function fu(t, e) {
                 for (const i of xt(null !== (n = t.component.selection) && void 0 !== n ? n : {})) {
                     var n;
-                    for (const n of Df) n.defined(i) && n.marks && (e = n.marks(t, i, e))
+                    for (const n of Nf) n.defined(i) && n.marks && (e = n.marks(t, i, e))
                 }
                 return e
             }
 
-            function au(t) {
+            function du(t) {
                 return t.map((t => (t.on && !t.on.length && delete t.on, t)))
             }
-            class su {
+            class hu {
                 constructor(t, e) {
                     this.debugName = e, this._children = [], this._parent = null, t && (this.parent = t)
                 }
                 clone() {
                     throw new Error("Cannot clone node")
                 }
                 get parent() {
@@ -6870,15 +6924,15 @@
                         e = t.parent;
                     for (const i of this._children) i.parent = t;
                     this._children = [], t.removeChild(this);
                     const n = t.parent.removeChild(t);
                     this._parent = e, e.addChild(this, n), t.parent = this
                 }
             }
-            class cu extends su {
+            class pu extends hu {
                 clone() {
                     const t = new this.constructor;
                     return t.debugName = "clone_".concat(this.debugName), t._source = this._source, t._name = "clone_".concat(this._name), t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t
                 }
                 constructor(t, e, n, i) {
                     super(t, e), this.type = n, this.refCounts = i, this._source = this._name = e, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0)
                 }
@@ -6897,122 +6951,154 @@
                 isRequired() {
                     return !!this.refCounts[this._name]
                 }
                 setSource(t) {
                     this._source = t
                 }
             }
-            class lu extends su {
+
+            function mu(t) {
+                return void 0 !== t.as
+            }
+
+            function gu(t) {
+                return "".concat(t, "_end")
+            }
+            class vu extends hu {
                 clone() {
-                    return new lu(null, tt(this.formula))
+                    return new vu(null, tt(this.formula))
                 }
                 constructor(t, e) {
                     super(t), this.formula = e
                 }
                 static makeFromEncoding(t, e) {
-                    const n = e.reduceFieldDef(((t, e) => {
+                    const n = e.reduceFieldDef(((t, n) => {
                         const {
-                            field: n,
-                            timeUnit: i
-                        } = e;
-                        if (i) {
-                            const r = Ga(e, {
-                                forAs: !0
-                            });
-                            t[ot({
-                                as: r,
-                                field: n,
-                                timeUnit: i
-                            })] = {
-                                as: r,
-                                field: n,
-                                timeUnit: i
-                            }
+                            field: i,
+                            timeUnit: r
+                        } = n;
+                        if (r) {
+                            let o;
+                            if (wr(r)) {
+                                if (bp(e)) {
+                                    const {
+                                        mark: t
+                                    } = e;
+                                    (Xo(t) || n.bandPosition) && (o = {
+                                        timeUnit: Or(r),
+                                        field: i
+                                    })
+                                }
+                            } else o = {
+                                as: Ka(n, {
+                                    forAs: !0
+                                }),
+                                field: i,
+                                timeUnit: r
+                            };
+                            o && (t[ot(o)] = o)
                         }
                         return t
                     }), {});
-                    return yt(n) ? null : new lu(t, n)
+                    return yt(n) ? null : new vu(t, n)
                 }
                 static makeFromTransform(t, e) {
                     const {
                         timeUnit: n,
                         ...i
                     } = {
                         ...e
                     }, r = {
                         ...i,
-                        timeUnit: Cr(n)
+                        timeUnit: Or(n)
                     };
-                    return new lu(t, {
+                    return new vu(t, {
                         [ot(r)]: r
                     })
                 }
                 merge(t) {
                     this.formula = {
                         ...this.formula
                     };
                     for (const e in t.formula) this.formula[e] || (this.formula[e] = t.formula[e]);
                     for (const e of t.children) t.removeChild(e), e.parent = this;
                     t.remove()
                 }
                 removeFormulas(t) {
                     const e = {};
-                    for (const [n, i] of _t(this.formula)) t.has(i.as) || (e[n] = i);
+                    for (const [n, i] of _t(this.formula)) {
+                        const r = mu(i) ? i.as : "".concat(i.field, "_end");
+                        t.has(r) || (e[n] = i)
+                    }
                     this.formula = e
                 }
                 producedFields() {
-                    return new Set(xt(this.formula).map((t => t.as)))
+                    return new Set(xt(this.formula).map((t => mu(t) ? t.as : gu(t.field))))
                 }
                 dependentFields() {
                     return new Set(xt(this.formula).map((t => t.field)))
                 }
                 hash() {
                     return "TimeUnit ".concat(ot(this.formula))
                 }
                 assemble() {
                     const t = [];
-                    for (const e of xt(this.formula)) {
+                    for (const e of xt(this.formula))
+                        if (mu(e)) {
+                            const {
+                                field: n,
+                                as: i,
+                                timeUnit: r
+                            } = e, {
+                                unit: o,
+                                utc: a,
+                                ...s
+                            } = Or(r);
+                            t.push({
+                                field: Ft(n),
+                                type: "timeunit",
+                                ...o ? {
+                                    units: Dr(o)
+                                } : {},
+                                ...a ? {
+                                    timezone: "utc"
+                                } : {},
+                                ...s,
+                                as: [i, "".concat(i, "_end")]
+                            })
+                        } else if (e) {
                         const {
                             field: n,
-                            as: i,
-                            timeUnit: r
-                        } = e, {
-                            unit: o,
-                            utc: a,
-                            ...s
-                        } = Cr(r);
+                            timeUnit: i
+                        } = e, r = Sr(null === i || void 0 === i ? void 0 : i.unit), {
+                            part: o,
+                            step: a
+                        } = Rr(r, i.step);
                         t.push({
-                            field: Mt(n),
-                            type: "timeunit",
-                            ...o ? {
-                                units: Er(o)
-                            } : {},
-                            ...a ? {
-                                timezone: "utc"
-                            } : {},
-                            ...s,
-                            as: [i, "".concat(i, "_end")]
+                            type: "formula",
+                            expr: "timeOffset('".concat(o, "', datum['").concat(n, "'], ").concat(a, ")"),
+                            as: gu(n)
                         })
                     }
                     return t
                 }
             }
-            const uu = "_tuple_fields";
-            class fu {
+            const yu = "_tuple_fields";
+            class bu {
                 constructor() {
                     for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                     this.items = e, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1
                 }
             }
-            const du = {
+            const xu = {
                     defined: () => !0,
                     parse: (t, e, n) => {
                         var i;
                         const r = e.name,
-                            o = null !== (i = e.project) && void 0 !== i ? i : e.project = new fu,
+                            o = null !== (i = e.project) && void 0 !== i ? i : e.project = new bu,
                             a = {},
                             s = {},
                             c = new Set,
                             l = (t, e) => {
                                 const n = "visual" === e ? t.channel : t.field;
                                 let i = kt("".concat(r, "_").concat(n));
                                 for (let o = 1; c.has(i); o++) i = kt("".concat(r, "_").concat(n, "_").concat(o));
@@ -7039,153 +7125,153 @@
                         h || p || (p = f.encodings, "fields" in f && (h = f.fields));
                         for (const y of null !== (g = p) && void 0 !== g ? g : []) {
                             var g;
                             const e = t.fieldDef(y);
                             if (e) {
                                 let n = e.field;
                                 if (e.aggregate) {
-                                    dr(ji(y, e.aggregate));
+                                    dr(Bi(y, e.aggregate));
                                     continue
                                 }
                                 if (!n) {
                                     dr(Li(y));
                                     continue
                                 }
-                                if (e.timeUnit) {
+                                if (e.timeUnit && !wr(e.timeUnit)) {
                                     n = t.vgField(y);
                                     const i = {
                                         timeUnit: e.timeUnit,
                                         as: n,
                                         field: e.field
                                     };
                                     s[ot(i)] = i
                                 }
                                 if (!a[n]) {
                                     const i = {
                                         field: n,
                                         channel: y,
-                                        type: "interval" === u && jn(y) && co(t.getScaleComponent(y).get("type")) ? "R" : e.bin ? "R-RE" : "E",
+                                        type: "interval" === u && Bn(y) && po(t.getScaleComponent(y).get("type")) ? "R" : e.bin ? "R-RE" : "E",
                                         index: o.items.length
                                     };
                                     i.signals = {
                                         ...l(i, "data"),
                                         ...l(i, "visual")
-                                    }, o.items.push(a[n] = i), o.hasField[n] = a[n], o.hasSelectionId = o.hasSelectionId || n === lc, Ce(y) ? (i.geoChannel = y, i.channel = Se(y), o.hasChannel[i.channel] = a[n]) : o.hasChannel[y] = a[n]
+                                    }, o.items.push(a[n] = i), o.hasField[n] = a[n], o.hasSelectionId = o.hasSelectionId || n === pc, Ce(y) ? (i.geoChannel = y, i.channel = Se(y), o.hasChannel[i.channel] = a[n]) : o.hasChannel[y] = a[n]
                                 }
                             } else dr(Li(y))
                         }
                         for (const y of null !== (v = h) && void 0 !== v ? v : []) {
                             var v;
                             if (o.hasField[y]) continue;
                             const t = {
                                 type: "E",
                                 field: y,
                                 index: o.items.length
                             };
                             t.signals = {
                                 ...l(t, "data")
-                            }, o.items.push(t), o.hasField[y] = t, o.hasSelectionId = o.hasSelectionId || y === lc
+                            }, o.items.push(t), o.hasField[y] = t, o.hasSelectionId = o.hasSelectionId || y === pc
                         }
-                        d && (e.init = d.map((t => o.items.map((e => (0, U.Kn)(t) ? void 0 !== t[e.geoChannel || e.channel] ? t[e.geoChannel || e.channel] : t[e.field] : t))))), yt(s) || (o.timeUnit = new lu(null, s))
+                        d && (e.init = d.map((t => o.items.map((e => (0, U.Kn)(t) ? void 0 !== t[e.geoChannel || e.channel] ? t[e.geoChannel || e.channel] : t[e.field] : t))))), yt(s) || (o.timeUnit = new vu(null, s))
                     },
                     signals: (t, e, n) => {
-                        const i = e.name + uu;
+                        const i = e.name + yu;
                         return n.filter((t => t.name === i)).length > 0 || e.project.hasSelectionId ? n : n.concat({
                             name: i,
-                            value: e.project.items.map(eu)
+                            value: e.project.items.map(su)
                         })
                     }
                 },
-                hu = du,
-                pu = {
+                _u = xu,
+                wu = {
                     defined: t => "interval" === t.type && "global" === t.resolve && t.bind && "scales" === t.bind,
                     parse: (t, e) => {
                         const n = e.scales = [];
                         for (const i of e.project.items) {
                             const r = i.channel;
-                            if (!jn(r)) continue;
+                            if (!Bn(r)) continue;
                             const o = t.getScaleComponent(r),
                                 a = o ? o.get("type") : void 0;
-                            o && co(a) ? (o.set("selectionExtent", {
+                            o && po(a) ? (o.set("selectionExtent", {
                                 param: e.name,
                                 field: i.field
                             }, !0), n.push(i)) : dr("Scale bindings are currently only supported for scales with unbinned, continuous domains.")
                         }
                     },
                     topLevelSignals: (t, e, n) => {
                         const i = e.scales.filter((t => 0 === n.filter((e => e.name === t.signals.data)).length));
-                        if (!t.parent || vu(t) || 0 === i.length) return n;
+                        if (!t.parent || Au(t) || 0 === i.length) return n;
                         const r = n.filter((t => t.name === e.name))[0];
                         let o = r.update;
-                        if (o.indexOf(Ef) >= 0) r.update = "{".concat(i.map((t => "".concat((0, U.m8)(Mt(t.field)), ": ").concat(t.signals.data))).join(", "), "}");
+                        if (o.indexOf(Tf) >= 0) r.update = "{".concat(i.map((t => "".concat((0, U.m8)(Ft(t.field)), ": ").concat(t.signals.data))).join(", "), "}");
                         else {
                             for (const t of i) {
-                                const e = "".concat((0, U.m8)(Mt(t.field)), ": ").concat(t.signals.data);
+                                const e = "".concat((0, U.m8)(Ft(t.field)), ": ").concat(t.signals.data);
                                 o.includes(e) || (o = "".concat(o.substring(0, o.length - 1), ", ").concat(e, "}"))
                             }
                             r.update = o
                         }
                         return n.concat(i.map((t => ({
                             name: t.signals.data
                         }))))
                     },
                     signals: (t, e, n) => {
-                        if (t.parent && !vu(t))
+                        if (t.parent && !Au(t))
                             for (const i of e.scales) {
                                 const t = n.filter((t => t.name === i.signals.data))[0];
                                 t.push = "outer", delete t.value, delete t.update
                             }
                         return n
                     }
                 },
-                mu = pu;
+                ku = wu;
 
-            function gu(t, e) {
+            function Eu(t, e) {
                 const n = (0, U.m8)(t.scaleName(e));
                 return "domain(".concat(n, ")")
             }
 
-            function vu(t) {
+            function Au(t) {
                 var e;
-                return t.parent && pp(t.parent) && (null !== (e = !t.parent.parent) && void 0 !== e ? e : vu(t.parent.parent))
+                return t.parent && wp(t.parent) && (null !== (e = !t.parent.parent) && void 0 !== e ? e : Au(t.parent.parent))
             }
-            const yu = "_brush",
-                bu = "_scale_trigger",
-                xu = "geo_interval_init_tick",
-                _u = "_init",
-                wu = {
+            const Du = "_brush",
+                Su = "_scale_trigger",
+                Cu = "geo_interval_init_tick",
+                Mu = "_init",
+                Fu = {
                     defined: t => "interval" === t.type,
                     parse: (t, e, n) => {
                         var i;
                         if (t.hasProjection) {
                             const t = {
-                                ...(0, B.isObject)(n.select) ? n.select : {}
+                                ...(0, I.isObject)(n.select) ? n.select : {}
                             };
-                            t.fields = [lc], t.encodings || (t.encodings = n.value ? bt(n.value) : [ne, ee]), n.select = {
+                            t.fields = [pc], t.encodings || (t.encodings = n.value ? bt(n.value) : [ne, ee]), n.select = {
                                 type: "interval",
                                 ...t
                             }
                         }
-                        if (e.translate && !mu.defined(e)) {
-                            const t = "!event.item || event.item.mark.name !== ".concat((0, U.m8)(e.name + yu));
+                        if (e.translate && !ku.defined(e)) {
+                            const t = "!event.item || event.item.mark.name !== ".concat((0, U.m8)(e.name + Du));
                             for (const n of e.events) {
                                 var r;
                                 if (!n.between) {
                                     dr("".concat(n, " is not an ordered event stream for interval selections."));
                                     continue
                                 }
                                 const e = (0, U.IX)(null !== (r = (i = n.between[0]).filter) && void 0 !== r ? r : i.filter = []);
                                 e.indexOf(t) < 0 && e.push(t)
                             }
                         }
                     },
                     signals: (t, e, n) => {
                         const i = e.name,
-                            r = i + wf,
-                            o = xt(e.project.hasChannel).filter((t => t.channel === Xt || t.channel === Jt)),
+                            r = i + Ff,
+                            o = xt(e.project.hasChannel).filter((t => t.channel === Xt || t.channel === Gt)),
                             a = e.init ? e.init[0] : null;
                         if (n.push(...o.reduce(((n, i) => n.concat(function(t, e, n, i) {
                                 const r = !t.hasProjection,
                                     o = n.channel,
                                     a = n.signals.visual,
                                     s = (0, U.m8)(r ? t.scaleName(o) : t.projectionName()),
                                     c = t => "scale(".concat(s, ", ").concat(t, ")"),
@@ -7196,49 +7282,49 @@
                                         update: "[".concat(u, ", ").concat(u, "]")
                                     }, {
                                         events: e,
                                         update: "[".concat(a, "[0], clamp(").concat(u, ", 0, ").concat(l, ")]")
                                     }]), []);
                                 if (r) {
                                     const r = n.signals.data,
-                                        l = mu.defined(e),
+                                        l = ku.defined(e),
                                         u = t.getScaleComponent(o),
                                         d = u ? u.get("type") : void 0,
                                         h = i ? {
-                                            init: nu(i, !0, c)
+                                            init: cu(i, !0, c)
                                         } : {
                                             value: []
                                         };
                                     return f.push({
                                         events: {
-                                            signal: e.name + bu
+                                            signal: e.name + Su
                                         },
-                                        update: co(d) ? "[".concat(c("".concat(r, "[0]")), ", ").concat(c("".concat(r, "[1]")), "]") : "[0, 0]"
+                                        update: po(d) ? "[".concat(c("".concat(r, "[0]")), ", ").concat(c("".concat(r, "[1]")), "]") : "[0, 0]"
                                     }), l ? [{
                                         name: r,
                                         on: []
                                     }] : [{
                                         name: a,
                                         ...h,
                                         on: f
                                     }, {
                                         name: r,
                                         ...i ? {
-                                            init: nu(i)
+                                            init: cu(i)
                                         } : {},
                                         on: [{
                                             events: {
                                                 signal: a
                                             },
                                             update: "".concat(a, "[0] === ").concat(a, "[1] ? null : invert(").concat(s, ", ").concat(a, ")")
                                         }]
                                     }]
                                 } {
                                     const t = o === Xt ? 0 : 1,
-                                        n = e.name + _u,
+                                        n = e.name + Mu,
                                         r = i ? {
                                             init: "[".concat(n, "[0][").concat(t, "], ").concat(n, "[1][").concat(t, "]]")
                                         } : {
                                             value: []
                                         };
                                     return [{
                                         name: a,
@@ -7256,102 +7342,102 @@
                                 f = l && l.signals.visual,
                                 d = u && u.signals.visual,
                                 h = l ? a && a[l.index] : "".concat(c, "[0]"),
                                 p = u ? a && a[u.index] : "".concat(c, "[1]"),
                                 m = e => t.getSizeSignalRef(e).signal,
                                 g = "[" + "[".concat(f ? f + "[0]" : "0", ", ").concat(d ? d + "[0]" : "0", "],") + "[".concat(f ? f + "[1]" : m("width"), ", ") + "".concat(d ? d + "[1]" : m("height"), "]") + "]";
                             if (a && (n.unshift({
-                                    name: i + _u,
+                                    name: i + Mu,
                                     init: "[scale(".concat(s, ", [").concat(l ? h[0] : h, ", ").concat(u ? p[0] : p, "]), ") + "scale(".concat(s, ", [").concat(l ? h[1] : h, ", ").concat(u ? p[1] : p, "])]")
                                 }), !l || !u)) {
                                 n.find((t => t.name === c)) || n.unshift({
                                     name: c,
                                     update: "invert(".concat(s, ", [").concat(m("width"), "/2, ").concat(m("height"), "/2])")
                                 })
                             }
                             const v = "intersect(".concat(g, ", {markname: ").concat((0, U.m8)(t.getName("marks")), "}, unit.mark)"),
-                                y = "{unit: ".concat(Af(t), "}"),
+                                y = "{unit: ".concat(Rf(t), "}"),
                                 b = "vlSelectionTuples(".concat(v, ", ").concat(y, ")"),
                                 x = o.map((t => t.signals.visual));
                             return n.concat({
                                 name: r,
                                 on: [{
                                     events: [...x.length ? [{
                                         signal: x.join(" || ")
                                     }] : [], ...a ? [{
-                                        signal: xu
+                                        signal: Cu
                                     }] : []],
                                     update: b
                                 }]
                             })
                         } {
-                            if (!mu.defined(e)) {
-                                const e = i + bu,
+                            if (!ku.defined(e)) {
+                                const e = i + Su,
                                     r = o.map((e => {
                                         const n = e.channel,
                                             {
                                                 data: i,
                                                 visual: r
                                             } = e.signals,
                                             o = (0, U.m8)(t.scaleName(n)),
-                                            a = co(t.getScaleComponent(n).get("type")) ? "+" : "";
+                                            a = po(t.getScaleComponent(n).get("type")) ? "+" : "";
                                         return "(!isArray(".concat(i, ") || ") + "(".concat(a, "invert(").concat(o, ", ").concat(r, ")[0] === ").concat(a).concat(i, "[0] && ") + "".concat(a, "invert(").concat(o, ", ").concat(r, ")[1] === ").concat(a).concat(i, "[1]))")
                                     }));
                                 r.length && n.push({
                                     name: e,
                                     value: {},
                                     on: [{
                                         events: o.map((e => ({
                                             scale: t.scaleName(e.channel)
                                         }))),
                                         update: r.join(" && ") + " ? ".concat(e, " : {}")
                                     }]
                                 })
                             }
                             const s = o.map((t => t.signals.data)),
-                                c = "unit: ".concat(Af(t), ", fields: ").concat(i + uu, ", values");
+                                c = "unit: ".concat(Rf(t), ", fields: ").concat(i + yu, ", values");
                             return n.concat({
                                 name: r,
                                 ...a ? {
-                                    init: "{".concat(c, ": ").concat(nu(a), "}")
+                                    init: "{".concat(c, ": ").concat(cu(a), "}")
                                 } : {},
                                 ...s.length ? {
                                     on: [{
                                         events: [{
                                             signal: s.join(" || ")
                                         }],
                                         update: "".concat(s.join(" && "), " ? {").concat(c, ": [").concat(s, "]} : null")
                                     }]
                                 } : {}
                             })
                         }
                     },
                     topLevelSignals: (t, e, n) => {
-                        if (fp(t) && t.hasProjection && e.init) {
-                            n.filter((t => t.name === xu)).length || n.unshift({
-                                name: xu,
+                        if (bp(t) && t.hasProjection && e.init) {
+                            n.filter((t => t.name === Cu)).length || n.unshift({
+                                name: Cu,
                                 value: null,
                                 on: [{
                                     events: "timer{1}",
-                                    update: "".concat(xu, " === null ? {} : ").concat(xu)
+                                    update: "".concat(Cu, " === null ? {} : ").concat(Cu)
                                 }]
                             })
                         }
                         return n
                     },
                     marks: (t, e, n) => {
                         const i = e.name,
                             {
                                 x: r,
                                 y: o
                             } = e.project.hasChannel,
                             a = null === r || void 0 === r ? void 0 : r.signals.visual,
                             s = null === o || void 0 === o ? void 0 : o.signals.visual,
-                            c = "data(".concat((0, U.m8)(e.name + _f), ")");
-                        if (mu.defined(e) || !r && !o) return n;
+                            c = "data(".concat((0, U.m8)(e.name + Mf), ")");
+                        if (ku.defined(e) || !r && !o) return n;
                         const l = {
                             x: void 0 !== r ? {
                                 signal: "".concat(a, "[0]")
                             } : {
                                 value: 0
                             },
                             y: void 0 !== o ? {
@@ -7372,15 +7458,15 @@
                                 field: {
                                     group: "height"
                                 }
                             }
                         };
                         if ("global" === e.resolve)
                             for (const m of bt(l)) l[m] = [{
-                                test: "".concat(c, ".length && ").concat(c, "[0].unit === ").concat(Af(t)),
+                                test: "".concat(c, ".length && ").concat(c, "[0].unit === ").concat(Rf(t)),
                                 ...l[m]
                             }, {
                                 value: 0
                             }];
                         const {
                             fill: u,
                             fillOpacity: f,
@@ -7389,30 +7475,30 @@
                         } = e.mark, p = bt(h).reduce(((t, e) => (t[e] = [{
                             test: [void 0 !== r && "".concat(a, "[0] !== ").concat(a, "[1]"), void 0 !== o && "".concat(s, "[0] !== ").concat(s, "[1]")].filter((t => t)).join(" && "),
                             value: h[e]
                         }, {
                             value: null
                         }], t)), {});
                         return [{
-                            name: "".concat(i + yu, "_bg"),
+                            name: "".concat(i + Du, "_bg"),
                             type: "rect",
                             clip: !0,
                             encode: {
                                 enter: {
                                     fill: {
                                         value: u
                                     },
                                     fillOpacity: {
                                         value: f
                                     }
                                 },
                                 update: l
                             }
                         }, ...n, {
-                            name: i + yu,
+                            name: i + Du,
                             type: "rect",
                             clip: !0,
                             encode: {
                                 enter: {
                                     ...d ? {
                                         cursor: {
                                             value: d
@@ -7426,243 +7512,243 @@
                                     ...l,
                                     ...p
                                 }
                             }
                         }]
                     }
                 },
-                ku = wu;
-            const Eu = {
+                Ou = Fu;
+            const Tu = {
                     defined: t => "point" === t.type,
                     signals: (t, e, n) => {
                         var i;
                         const r = e.name,
-                            o = r + uu,
+                            o = r + yu,
                             a = e.project,
                             s = "(item().isVoronoi ? datum.datum : datum)",
-                            c = xt(null !== (i = t.component.selection) && void 0 !== i ? i : {}).reduce(((t, e) => "interval" === e.type ? t.concat(e.name + yu) : t), []).map((t => "indexof(item().mark.name, '".concat(t, "') < 0"))).join(" && "),
+                            c = xt(null !== (i = t.component.selection) && void 0 !== i ? i : {}).reduce(((t, e) => "interval" === e.type ? t.concat(e.name + Du) : t), []).map((t => "indexof(item().mark.name, '".concat(t, "') < 0"))).join(" && "),
                             l = "datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0".concat(c ? " && ".concat(c) : "");
-                        let u = "unit: ".concat(Af(t), ", ");
-                        if (e.project.hasSelectionId) u += "".concat(lc, ": ").concat(s, "[").concat((0, U.m8)(lc), "]");
+                        let u = "unit: ".concat(Rf(t), ", ");
+                        if (e.project.hasSelectionId) u += "".concat(pc, ": ").concat(s, "[").concat((0, U.m8)(pc), "]");
                         else {
                             const e = a.items.map((e => {
                                 const n = t.fieldDef(e.channel);
                                 return null !== n && void 0 !== n && n.bin ? "[".concat(s, "[").concat((0, U.m8)(t.vgField(e.channel, {})), "], ") + "".concat(s, "[").concat((0, U.m8)(t.vgField(e.channel, {
                                     binSuffix: "end"
                                 })), "]]") : "".concat(s, "[").concat((0, U.m8)(e.field), "]")
                             })).join(", ");
                             u += "fields: ".concat(o, ", values: [").concat(e, "]")
                         }
                         const f = e.events;
                         return n.concat([{
-                            name: r + wf,
+                            name: r + Ff,
                             on: f ? [{
                                 events: f,
                                 update: "".concat(l, " ? {").concat(u, "} : null"),
                                 force: !0
                             }] : []
                         }])
                     }
                 },
-                Du = Eu;
+                Nu = Tu;
 
-            function Au(t, e, n, i) {
-                const r = Ma(e) && e.condition,
+            function Ru(t, e, n, i) {
+                const r = za(e) && e.condition,
                     o = i(e);
                 if (r) {
                     return {
                         [n]: [...(0, U.IX)(r).map((e => {
                             const n = i(e);
                             if (function(t) {
                                     return t.param
                                 }(e)) {
                                 const {
                                     param: i,
                                     empty: r
                                 } = e;
                                 return {
-                                    test: zf(t, {
+                                    test: qf(t, {
                                         param: i,
                                         empty: r
                                     }),
                                     ...n
                                 }
                             }
                             return {
-                                test: Pf(t, e.test),
+                                test: Hf(t, e.test),
                                 ...n
                             }
                         })), ...void 0 !== o ? [o] : []]
                     }
                 }
                 return void 0 !== o ? {
                     [n]: o
                 } : {}
             }
 
-            function Su(t) {
+            function zu(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "text";
                 const n = t.encoding[e];
-                return Au(t, n, e, (e => Cu(e, t.config)))
+                return Ru(t, n, e, (e => Pu(e, t.config)))
             }
 
-            function Cu(t, e) {
+            function Pu(t, e) {
                 let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "datum";
                 if (t) {
-                    if (Ua(t)) return yi(t.value);
-                    if (Ba(t)) {
+                    if (Ga(t)) return yi(t.value);
+                    if (Ha(t)) {
                         const {
                             format: i,
                             formatType: r
-                        } = es(t);
-                        return aa({
+                        } = as(t);
+                        return fa({
                             fieldOrDatumDef: t,
                             format: i,
                             formatType: r,
                             expr: n,
                             config: e
                         })
                     }
                 }
             }
 
-            function Fu(t) {
+            function Lu(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 const {
                     encoding: n,
                     markDef: i,
                     config: r,
                     stack: o
                 } = t, a = n.tooltip;
                 if ((0, U.kJ)(a)) return {
-                    tooltip: Ou({
+                    tooltip: Iu({
                         tooltip: a
                     }, o, r, e)
                 };
                 {
                     const s = e.reactiveGeom ? "datum.datum" : "datum";
-                    return Au(t, a, "tooltip", (t => {
-                        const a = Cu(t, r, s);
+                    return Ru(t, a, "tooltip", (t => {
+                        const a = Pu(t, r, s);
                         if (a) return a;
                         if (null === t) return;
                         let c = ki("tooltip", i, r);
                         return !0 === c && (c = {
                             content: "encoding"
                         }), (0, U.HD)(c) ? {
                             value: c
-                        } : (0, U.Kn)(c) ? li(c) ? c : "encoding" === c.content ? Ou(n, o, r, e) : {
+                        } : (0, U.Kn)(c) ? li(c) ? c : "encoding" === c.content ? Iu(n, o, r, e) : {
                             signal: s
                         } : void 0
                     }))
                 }
             }
 
-            function Mu(t, e, n) {
+            function Bu(t, e, n) {
                 let {
                     reactiveGeom: i
                 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                 const r = {
                         ...n,
                         ...n.tooltipFormat
                     },
                     o = {},
                     a = i ? "datum.datum" : "datum",
                     s = [];
 
                 function c(n, i) {
                     var c;
-                    const l = Ge(i),
-                        u = Ia(n) ? n : {
+                    const l = Je(i),
+                        u = Xa(n) ? n : {
                             ...n,
                             type: t[l].type
                         },
-                        f = u.title || ts(u, r),
-                        d = (0, U.IX)(f).join(", ");
+                        f = u.title || os(u, r),
+                        d = (0, U.IX)(f).join(", ").replaceAll(/"/g, '\\"');
                     let h;
                     if (xn(i)) {
                         const e = "x" === i ? "x2" : "y2",
-                            n = ns(t[e]);
+                            n = ss(t[e]);
                         if (ei(u.bin) && n) {
-                            const t = Ga(u, {
+                            const t = Ka(u, {
                                     expr: a
                                 }),
-                                i = Ga(n, {
+                                i = Ka(n, {
                                     expr: a
                                 }),
                                 {
                                     format: s,
                                     formatType: c
-                                } = es(u);
-                            h = pa(t, i, s, c, r), o[e] = !0
+                                } = as(u);
+                            h = ba(t, i, s, c, r), o[e] = !0
                         }
                     }
                     if ((xn(i) || i === Qt || i === Vt) && e && e.fieldChannel === i && "normalize" === e.offset) {
                         const {
                             format: t,
                             formatType: e
-                        } = es(u);
-                        h = aa({
+                        } = as(u);
+                        h = fa({
                             fieldOrDatumDef: u,
                             format: t,
                             formatType: e,
                             expr: a,
                             config: r,
                             normalizeStack: !0
                         }).signal
                     }
-                    null !== (c = h) && void 0 !== c || (h = Cu(u, r, a).signal), s.push({
+                    null !== (c = h) && void 0 !== c || (h = Pu(u, r, a).signal), s.push({
                         channel: i,
                         key: d,
                         value: h
                     })
                 }
-                Ms(t, ((t, e) => {
-                    Na(t) ? c(t, e) : Oa(t) && c(t.condition, e)
+                zs(t, ((t, e) => {
+                    Ba(t) ? c(t, e) : Pa(t) && c(t.condition, e)
                 }));
                 const l = {};
                 for (const {
                         channel: u,
                         key: f,
                         value: d
                     }
                     of s) o[u] || l[f] || (l[f] = d);
                 return l
             }
 
-            function Ou(t, e, n) {
+            function Iu(t, e, n) {
                 let {
                     reactiveGeom: i
                 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
-                const r = Mu(t, e, n, {
+                const r = Bu(t, e, n, {
                         reactiveGeom: i
                     }),
                     o = _t(r).map((t => {
                         let [e, n] = t;
                         return '"'.concat(e, '": ').concat(n)
                     }));
                 return o.length > 0 ? {
                     signal: "{".concat(o.join(", "), "}")
                 } : void 0
             }
 
-            function Tu(t) {
+            function ju(t) {
                 const {
                     markDef: e,
                     config: n
                 } = t, i = ki("aria", e, n);
                 return !1 === i ? {} : {
                     ...i ? {
                         aria: i
                     } : {},
-                    ...Nu(t),
-                    ...zu(t)
+                    ...Uu(t),
+                    ...qu(t)
                 }
             }
 
-            function Nu(t) {
+            function Uu(t) {
                 const {
                     mark: e,
                     markDef: n,
                     config: i
                 } = t;
                 if (!1 === i.aria) return {};
                 const r = ki("ariaRoleDescription", n, i);
@@ -7673,39 +7759,39 @@
                 } : e in hi ? {} : {
                     ariaRoleDescription: {
                         value: e
                     }
                 }
             }
 
-            function zu(t) {
+            function qu(t) {
                 const {
                     encoding: e,
                     markDef: n,
                     config: i,
                     stack: r
                 } = t, o = e.description;
-                if (o) return Au(t, o, "description", (e => Cu(e, t.config)));
+                if (o) return Ru(t, o, "description", (e => Pu(e, t.config)));
                 const a = ki("description", n, i);
                 if (null != a) return {
                     description: yi(a)
                 };
                 if (!1 === i.aria) return {};
-                const s = Mu(e, r, i);
+                const s = Bu(e, r, i);
                 return yt(s) ? void 0 : {
                     description: {
                         signal: _t(s).map(((t, e) => {
                             let [n, i] = t;
                             return '"'.concat(e > 0 ? "; " : "").concat(n, ': " + (').concat(i, ")")
                         })).join(" + ")
                     }
                 }
             }
 
-            function Ru(t, e) {
+            function Wu(t, e) {
                 let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                 const {
                     markDef: i,
                     encoding: r,
                     config: o
                 } = e, {
                     vgChannel: a
@@ -7716,27 +7802,27 @@
                 } = n;
                 var l;
                 void 0 === s && (null !== (l = c) && void 0 !== l || (c = ki(t, i, o, {
                     vgChannel: a,
                     ignoreVgConfig: !0
                 })), void 0 !== c && (s = yi(c)));
                 const u = r[t];
-                return Au(e, u, null !== a && void 0 !== a ? a : t, (n => ea({
+                return Ru(e, u, null !== a && void 0 !== a ? a : t, (n => aa({
                     channel: t,
                     channelDef: n,
                     markDef: i,
                     config: o,
                     scaleName: e.scaleName(t),
                     scale: e.getScaleComponent(t),
                     stack: null,
                     defaultRef: s
                 })))
             }
 
-            function Pu(t) {
+            function Hu(t) {
                 var e, n, i, r;
                 let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                     filled: void 0
                 };
                 const {
                     markDef: a,
                     encoding: s,
@@ -7751,55 +7837,55 @@
                     ...d ? {
                         fill: yi(d)
                     } : {},
                     ...h ? {
                         stroke: yi(h)
                     } : {}
                 };
-                return a.color && (u ? a.fill : a.stroke) && dr(Gi("property", {
+                return a.color && (u ? a.fill : a.stroke) && dr(Ji("property", {
                     fill: "fill" in a,
                     stroke: "stroke" in a
                 })), {
                     ...m,
-                    ...Ru("color", t, {
+                    ...Wu("color", t, {
                         vgChannel: p,
                         defaultValue: u ? d : h
                     }),
-                    ...Ru("fill", t, {
+                    ...Wu("fill", t, {
                         defaultValue: s.fill ? d : void 0
                     }),
-                    ...Ru("stroke", t, {
+                    ...Wu("stroke", t, {
                         defaultValue: s.stroke ? h : void 0
                     })
                 }
             }
 
-            function Lu(t) {
+            function Xu(t) {
                 const {
                     encoding: e,
                     mark: n
                 } = t, i = e.order;
-                return !Bo(n) && Ua(i) ? Au(t, i, "zindex", (t => yi(t.value))) : {}
+                return !Ho(n) && Ga(i) ? Ru(t, i, "zindex", (t => yi(t.value))) : {}
             }
 
-            function ju(t) {
+            function Gu(t) {
                 let {
                     channel: e,
                     markDef: n,
                     encoding: i = {},
                     model: r,
                     bandPosition: o
                 } = t;
                 const a = "".concat(e, "Offset"),
                     s = n[a],
                     c = i[a];
                 if (("xOffset" === a || "yOffset" === a) && c) {
                     return {
                         offsetType: "encoding",
-                        offset: ea({
+                        offset: aa({
                             channel: a,
                             channelDef: c,
                             markDef: n,
                             config: null === r || void 0 === r ? void 0 : r.config,
                             scaleName: r.scaleName(a),
                             scale: r.getScaleComponent(a),
                             stack: null,
@@ -7811,34 +7897,34 @@
                 const l = n[a];
                 return l ? {
                     offsetType: "visual",
                     offset: l
                 } : {}
             }
 
-            function Bu(t, e, n) {
+            function Ju(t, e, n) {
                 let {
                     defaultPos: i,
                     vgChannel: r
                 } = n;
                 const {
                     encoding: o,
                     markDef: a,
                     config: s,
                     stack: c
-                } = e, l = o[t], u = o[Ze(t)], f = e.scaleName(t), d = e.getScaleComponent(t), {
+                } = e, l = o[t], u = o[$e(t)], f = e.scaleName(t), d = e.getScaleComponent(t), {
                     offset: h,
                     offsetType: p
-                } = ju({
+                } = Gu({
                     channel: t,
                     markDef: a,
                     encoding: o,
                     model: e,
                     bandPosition: .5
-                }), m = Iu({
+                }), m = Zu({
                     model: e,
                     defaultPos: i,
                     channel: t,
                     scaleName: f,
                     scale: d
                 }), g = !l && xn(t) && (o.latitude || o.longitude) ? {
                     field: e.getName(t)
@@ -7847,32 +7933,32 @@
                         channel: e,
                         channelDef: n,
                         scaleName: i,
                         stack: r,
                         offset: o,
                         markDef: a
                     } = t;
-                    if (Ba(n) && r && e === r.fieldChannel) {
-                        if (Na(n)) {
+                    if (Ha(n) && r && e === r.fieldChannel) {
+                        if (Ba(n)) {
                             let t = n.bandPosition;
-                            if (void 0 !== t || "text" !== a.type || "radius" !== e && "theta" !== e || (t = .5), void 0 !== t) return ta({
+                            if (void 0 !== t || "text" !== a.type || "radius" !== e && "theta" !== e || (t = .5), void 0 !== t) return oa({
                                 scaleName: i,
                                 fieldOrDatumDef: n,
                                 startSuffix: "start",
                                 bandPosition: t,
                                 offset: o
                             })
                         }
-                        return Qo(n, i, {
+                        return ra(n, i, {
                             suffix: "end"
                         }, {
                             offset: o
                         })
                     }
-                    return Yo(t)
+                    return ea(t)
                 }({
                     channel: t,
                     channelDef: l,
                     channel2Def: u,
                     markDef: a,
                     config: s,
                     scaleName: f,
@@ -7883,39 +7969,39 @@
                     bandPosition: "encoding" === p ? 0 : void 0
                 });
                 return g ? {
                     [r || t]: g
                 } : void 0
             }
 
-            function Iu(t) {
+            function Zu(t) {
                 let {
                     model: e,
                     defaultPos: n,
                     channel: i,
                     scaleName: r,
                     scale: o
                 } = t;
                 const {
                     markDef: a,
                     config: s
                 } = e;
                 return () => {
-                    const t = Ge(i),
-                        c = $e(i),
+                    const t = Je(i),
+                        c = Ze(i),
                         l = ki(i, a, s, {
                             vgChannel: c
                         });
-                    if (void 0 !== l) return na(i, l);
+                    if (void 0 !== l) return sa(i, l);
                     switch (n) {
                         case "zeroOrMin":
                         case "zeroOrMax":
                             if (r) {
                                 const t = o.get("type");
-                                if (st([Yr.LOG, Yr.TIME, Yr.UTC], t));
+                                if (st([eo.LOG, eo.TIME, eo.UTC], t));
                                 else if (o.domainDefinitelyIncludesZero()) return {
                                     scale: r,
                                     value: 0
                                 }
                             }
                             if ("zeroOrMin" === n) return "y" === t ? {
                                 field: {
@@ -7948,68 +8034,68 @@
                         case "mid":
                             return {
                                 ...e[Ye(i)], mult: .5
                             }
                     }
                 }
             }
-            const Uu = {
+            const $u = {
                     left: "x",
                     center: "xc",
                     right: "x2"
                 },
-                qu = {
+                Yu = {
                     top: "y",
                     middle: "yc",
                     bottom: "y2"
                 };
 
-            function Wu(t, e, n) {
+            function Vu(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "middle";
-                if ("radius" === t || "theta" === t) return $e(t);
+                if ("radius" === t || "theta" === t) return Ze(t);
                 const r = "x" === t ? "align" : "baseline",
                     o = ki(r, e, n);
                 let a;
                 return li(o) ? (dr(function(t) {
                     return "The ".concat(t, " for range marks cannot be an expression")
-                }(r)), a = void 0) : a = o, "x" === t ? Uu[a || ("top" === i ? "left" : "center")] : qu[a || i]
+                }(r)), a = void 0) : a = o, "x" === t ? $u[a || ("top" === i ? "left" : "center")] : Yu[a || i]
             }
 
-            function Hu(t, e, n) {
+            function Ku(t, e, n) {
                 let {
                     defaultPos: i,
                     defaultPos2: r,
                     range: o
                 } = n;
-                return o ? Xu(t, e, {
+                return o ? Qu(t, e, {
                     defaultPos: i,
                     defaultPos2: r
-                }) : Bu(t, e, {
+                }) : Ju(t, e, {
                     defaultPos: i
                 })
             }
 
-            function Xu(t, e, n) {
+            function Qu(t, e, n) {
                 let {
                     defaultPos: i,
                     defaultPos2: r
                 } = n;
                 const {
                     markDef: o,
                     config: a
-                } = e, s = Ze(t), c = Ye(t), l = function(t, e, n) {
+                } = e, s = $e(t), c = Ye(t), l = function(t, e, n) {
                     const {
                         encoding: i,
                         mark: r,
                         markDef: o,
                         stack: a,
                         config: s
-                    } = t, c = Ge(n), l = Ye(n), u = $e(n), f = i[c], d = t.scaleName(c), h = t.getScaleComponent(c), {
+                    } = t, c = Je(n), l = Ye(n), u = Ze(n), f = i[c], d = t.scaleName(c), h = t.getScaleComponent(c), {
                         offset: p
-                    } = ju(n in i || n in o ? {
+                    } = Gu(n in i || n in o ? {
                         channel: n,
                         markDef: o,
                         encoding: i,
                         model: t
                     } : {
                         channel: c,
                         markDef: o,
@@ -8038,20 +8124,20 @@
                             config: o,
                             scaleName: a,
                             scale: s,
                             stack: c,
                             offset: l,
                             defaultRef: u
                         } = t;
-                        if (Ba(n) && c && e.charAt(0) === c.fieldChannel.charAt(0)) return Qo(n, a, {
+                        if (Ha(n) && c && e.charAt(0) === c.fieldChannel.charAt(0)) return ra(n, a, {
                             suffix: "start"
                         }, {
                             offset: l
                         });
-                        return Yo({
+                        return ea({
                             channel: e,
                             channelDef: i,
                             scaleName: a,
                             scale: s,
                             stack: c,
                             markDef: r,
                             config: o,
@@ -8069,130 +8155,130 @@
                         stack: a,
                         offset: p,
                         defaultRef: void 0
                     });
                     if (void 0 !== m) return {
                         [u]: m
                     };
-                    return Ju(n, o) || Ju(n, {
-                        [n]: Di(n, o, s.style),
-                        [l]: Di(l, o, s.style)
-                    }) || Ju(n, s[r]) || Ju(n, s.mark) || {
-                        [u]: Iu({
+                    return tf(n, o) || tf(n, {
+                        [n]: Ai(n, o, s.style),
+                        [l]: Ai(l, o, s.style)
+                    }) || tf(n, s[r]) || tf(n, s.mark) || {
+                        [u]: Zu({
                             model: t,
                             defaultPos: e,
                             channel: n,
                             scaleName: d,
                             scale: h
                         })()
                     }
                 }(e, r, s);
                 return {
-                    ...Bu(t, e, {
+                    ...Ju(t, e, {
                         defaultPos: i,
-                        vgChannel: l[c] ? Wu(t, o, a) : $e(t)
+                        vgChannel: l[c] ? Vu(t, o, a) : Ze(t)
                     }),
                     ...l
                 }
             }
 
-            function Ju(t, e) {
+            function tf(t, e) {
                 const n = Ye(t),
-                    i = $e(t);
+                    i = Ze(t);
                 if (void 0 !== e[i]) return {
-                    [i]: na(t, e[i])
+                    [i]: sa(t, e[i])
                 };
                 if (void 0 !== e[t]) return {
-                    [i]: na(t, e[t])
+                    [i]: sa(t, e[t])
                 };
                 if (e[n]) {
                     const i = e[n];
-                    if (!Jo(i)) return {
-                        [n]: na(t, i)
+                    if (!Vo(i)) return {
+                        [n]: sa(t, i)
                     };
                     dr(function(t) {
                         return "Position range does not support relative band size for ".concat(t, ".")
                     }(n))
                 }
             }
 
-            function Gu(t, e) {
+            function ef(t, e) {
                 var n, i;
                 const {
                     config: r,
                     encoding: o,
                     markDef: a
-                } = t, s = a.type, c = Ze(e), l = Ye(e), u = o[e], f = o[c], d = t.getScaleComponent(e), h = d ? d.get("type") : void 0, p = a.orient, m = null !== (n = null !== (i = o[l]) && void 0 !== i ? i : o.size) && void 0 !== n ? n : ki("size", a, r, {
+                } = t, s = a.type, c = $e(e), l = Ye(e), u = o[e], f = o[c], d = t.getScaleComponent(e), h = d ? d.get("type") : void 0, p = a.orient, m = null !== (n = null !== (i = o[l]) && void 0 !== i ? i : o.size) && void 0 !== n ? n : ki("size", a, r, {
                     vgChannel: l
                 }), g = Ve(e), v = "bar" === s && ("x" === e ? "vertical" === p : "horizontal" === p);
-                return !Na(u) || !(ti(u.bin) || ei(u.bin) || u.timeUnit && !f) || m && !Jo(m) || o[g] || so(h) ? (Ba(u) && so(h) || v) && !f ? function(t, e, n) {
+                return !Ba(u) || !(ti(u.bin) || ei(u.bin) || u.timeUnit && !f) || m && !Vo(m) || o[g] || ho(h) ? (Ha(u) && ho(h) || v) && !f ? function(t, e, n) {
                     const {
                         markDef: i,
                         encoding: r,
                         config: o,
                         stack: a
-                    } = n, s = i.orient, c = n.scaleName(e), l = n.getScaleComponent(e), u = Ye(e), f = Ze(e), d = Ve(e), h = n.scaleName(d), p = n.getScaleComponent(Ke(e)), m = "horizontal" === s && "y" === e || "vertical" === s && "x" === e;
+                    } = n, s = i.orient, c = n.scaleName(e), l = n.getScaleComponent(e), u = Ye(e), f = $e(e), d = Ve(e), h = n.scaleName(d), p = n.getScaleComponent(Ke(e)), m = "horizontal" === s && "y" === e || "vertical" === s && "x" === e;
                     let g;
-                    (r.size || i.size) && (m ? g = Ru("size", n, {
+                    (r.size || i.size) && (m ? g = Wu("size", n, {
                         vgChannel: u,
                         defaultRef: yi(i.size)
                     }) : dr(function(t) {
                         return 'Cannot apply size to non-oriented mark "'.concat(t, '".')
                     }(i.type)));
                     const v = !!g,
-                        y = Sa({
+                        y = Ta({
                             channel: e,
                             fieldDef: t,
                             markDef: i,
                             config: o,
                             scaleType: null === l || void 0 === l ? void 0 : l.get("type"),
                             useVlSizeChannel: m
                         });
                     g = g || {
-                        [u]: $u(u, h || c, p || l, o, y, !!t, i.type)
+                        [u]: nf(u, h || c, p || l, o, y, !!t, i.type)
                     };
-                    const b = "band" === (null === l || void 0 === l ? void 0 : l.get("type")) && Jo(y) && !v ? "top" : "middle",
-                        x = Wu(e, i, o, b),
+                    const b = "band" === (null === l || void 0 === l ? void 0 : l.get("type")) && Vo(y) && !v ? "top" : "middle",
+                        x = Vu(e, i, o, b),
                         _ = "xc" === x || "yc" === x,
                         {
                             offset: w,
                             offsetType: k
-                        } = ju({
+                        } = Gu({
                             channel: e,
                             markDef: i,
                             encoding: r,
                             model: n,
                             bandPosition: _ ? .5 : 0
                         }),
-                        E = Yo({
+                        E = ea({
                             channel: e,
                             channelDef: t,
                             markDef: i,
                             config: o,
                             scaleName: c,
                             scale: l,
                             stack: a,
                             offset: w,
-                            defaultRef: Iu({
+                            defaultRef: Zu({
                                 model: n,
                                 defaultPos: "mid",
                                 channel: e,
                                 scaleName: c,
                                 scale: l
                             }),
                             bandPosition: _ ? "encoding" === k ? 0 : .5 : li(y) ? {
                                 signal: "(1-".concat(y, ")/2")
-                            } : Jo(y) ? (1 - y.band) / 2 : 0
+                            } : Vo(y) ? (1 - y.band) / 2 : 0
                         });
                     if (u) return {
                         [x]: E,
                         ...g
                     };
                     {
-                        const t = $e(f),
+                        const t = Ze(f),
                             e = g[u],
                             n = w ? {
                                 ...e,
                                 offset: w
                             } : e;
                         return {
                             [x]: E,
@@ -8201,105 +8287,133 @@
                                 offset: n
                             }] : {
                                 ...E,
                                 offset: n
                             }
                         }
                     }
-                }(u, e, t) : Xu(e, t, {
+                }(u, e, t) : Qu(e, t, {
                     defaultPos: "zeroOrMax",
                     defaultPos2: "zeroOrMin"
                 }) : function(t) {
                     var e, n, i;
                     let {
                         fieldDef: r,
                         fieldDef2: o,
                         channel: a,
                         model: s
                     } = t;
                     const {
                         config: c,
                         markDef: l,
                         encoding: u
-                    } = s, f = s.getScaleComponent(a), d = s.scaleName(a), h = f ? f.get("type") : void 0, p = f.get("reverse"), m = Sa({
+                    } = s, f = s.getScaleComponent(a), d = s.scaleName(a), h = f ? f.get("type") : void 0, p = f.get("reverse"), m = Ta({
                         channel: a,
                         fieldDef: r,
                         markDef: l,
                         config: c,
                         scaleType: h
-                    }), g = null === (e = s.component.axes[a]) || void 0 === e ? void 0 : e[0], v = null !== (n = null === g || void 0 === g ? void 0 : g.get("translate")) && void 0 !== n ? n : .5, y = xn(a) && null !== (i = ki("binSpacing", l, c)) && void 0 !== i ? i : 0, b = Ze(a), x = $e(a), _ = $e(b), {
-                        offset: w
-                    } = ju({
+                    }), g = null === (e = s.component.axes[a]) || void 0 === e ? void 0 : e[0], v = null !== (n = null === g || void 0 === g ? void 0 : g.get("translate")) && void 0 !== n ? n : .5, y = xn(a) && null !== (i = ki("binSpacing", l, c)) && void 0 !== i ? i : 0, b = $e(a), x = Ze(a), _ = Ze(b), w = Ei("minBandSize", l, c), {
+                        offset: k
+                    } = Gu({
                         channel: a,
                         markDef: l,
                         encoding: u,
                         model: s,
                         bandPosition: 0
-                    }), k = li(m) ? {
+                    }), {
+                        offset: E
+                    } = Gu({
+                        channel: b,
+                        markDef: l,
+                        encoding: u,
+                        model: s,
+                        bandPosition: 0
+                    }), A = function(t) {
+                        let {
+                            scaleName: e,
+                            fieldDef: n
+                        } = t;
+                        const i = Ka(n, {
+                                expr: "datum"
+                            }),
+                            r = Ka(n, {
+                                expr: "datum",
+                                suffix: "end"
+                            });
+                        return 'abs(scale("'.concat(e, '", ').concat(r, ') - scale("').concat(e, '", ').concat(i, "))")
+                    }({
+                        fieldDef: r,
+                        scaleName: d
+                    }), D = rf(a, y, p, v, k, w, A), S = rf(b, y, p, v, null !== E && void 0 !== E ? E : k, w, A), C = li(m) ? {
                         signal: "(1-".concat(m.signal, ")/2")
-                    } : Jo(m) ? (1 - m.band) / 2 : .5;
+                    } : Vo(m) ? (1 - m.band) / 2 : .5;
                     if (ti(r.bin) || r.timeUnit) return {
-                        [_]: Yu({
+                        [_]: of({
                             fieldDef: r,
                             scaleName: d,
-                            bandPosition: k,
-                            offset: Zu(b, y, p, v, w)
+                            bandPosition: C,
+                            offset: S
                         }),
-                        [x]: Yu({
+                        [x]: of({
                             fieldDef: r,
                             scaleName: d,
-                            bandPosition: li(k) ? {
-                                signal: "1-".concat(k.signal)
-                            } : 1 - k,
-                            offset: Zu(a, y, p, v, w)
+                            bandPosition: li(C) ? {
+                                signal: "1-".concat(C.signal)
+                            } : 1 - C,
+                            offset: D
                         })
                     };
                     if (ei(r.bin)) {
-                        const t = Qo(r, d, {}, {
-                            offset: Zu(b, y, p, v, w)
+                        const t = ra(r, d, {}, {
+                            offset: S
                         });
-                        if (Na(o)) return {
+                        if (Ba(o)) return {
                             [_]: t,
-                            [x]: Qo(o, d, {}, {
-                                offset: Zu(a, y, p, v, w)
+                            [x]: ra(o, d, {}, {
+                                offset: D
                             })
                         };
                         if (ni(r.bin) && r.bin.step) return {
                             [_]: t,
                             [x]: {
-                                signal: 'scale("'.concat(d, '", ').concat(Ga(r, {
+                                signal: 'scale("'.concat(d, '", ').concat(Ka(r, {
                                     expr: "datum"
                                 }), " + ").concat(r.bin.step, ")"),
-                                offset: Zu(a, y, p, v, w)
+                                offset: D
                             }
                         }
                     }
                     return void dr(cr(b))
                 }({
                     fieldDef: u,
                     fieldDef2: f,
                     channel: e,
                     model: t
                 })
             }
 
-            function $u(t, e, n, i, r, o, a) {
-                if (Jo(r)) {
+            function nf(t, e, n, i, r, o, a) {
+                if (Vo(r)) {
                     if (!n) return {
                         mult: r.band,
                         field: {
                             group: t
                         }
                     };
                     {
                         const t = n.get("type");
                         if ("band" === t) {
                             let t = "bandwidth('".concat(e, "')");
-                            return 1 !== r.band && (t = "".concat(r.band, " * ").concat(t)), {
-                                signal: "max(0.25, ".concat(t, ")")
+                            1 !== r.band && (t = "".concat(r.band, " * ").concat(t));
+                            const n = Ei("minBandSize", {
+                                type: a
+                            }, i);
+                            return {
+                                signal: n ? "max(".concat(xi(n), ", ").concat(t, ")") : t
                             }
                         }
                         1 !== r.band && (dr(function(t) {
                             return "Cannot use the relative band size with ".concat(t, " scale.")
                         }(t)), r = void 0)
                     }
                 } else {
@@ -8315,108 +8429,109 @@
                     }
                 }
                 if (!o) {
                     const {
                         bandPaddingInner: e,
                         barBandPaddingInner: n,
                         rectBandPaddingInner: r
-                    } = i.scale, o = zt(e, "bar" === a ? n : r);
+                    } = i.scale, o = Rt(e, "bar" === a ? n : r);
                     if (li(o)) return {
                         signal: "(1 - (".concat(o.signal, ")) * ").concat(t)
                     };
                     if ((0, U.hj)(o)) return {
                         signal: "".concat(1 - o, " * ").concat(t)
-                    };
-                    if (oi(o)) return {
-                        signal: "(1 - (".concat(o.expr, ")) * ").concat(t)
                     }
                 }
                 return {
-                    value: kc(i.view, t) - 2
+                    value: Cc(i.view, t) - 2
                 }
             }
 
-            function Zu(t, e, n, i, r) {
-                if (De(t)) return 0;
-                const o = "x" === t || "y2" === t ? -e / 2 : e / 2;
-                if (li(n) || li(r) || li(i)) {
+            function rf(t, e, n, i, r, o, a) {
+                if (Ae(t)) return 0;
+                const s = "x" === t || "y2" === t,
+                    c = s ? -e / 2 : e / 2;
+                if (li(n) || li(r) || li(i) || o) {
                     const t = xi(n),
                         e = xi(r),
-                        a = xi(i);
+                        l = xi(i),
+                        u = xi(o),
+                        f = s ? "" : "-",
+                        d = o ? "(".concat(a, " < ").concat(u, " ? ").concat(f, "0.5 * (").concat(u, " - (").concat(a, ")) : ").concat(c, ")") : c;
                     return {
-                        signal: (a ? "".concat(a, " + ") : "") + (t ? "(".concat(t, " ? -1 : 1) * ") : "") + (e ? "(".concat(e, " + ").concat(o, ")") : o)
+                        signal: (l ? "".concat(l, " + ") : "") + (t ? "(".concat(t, " ? -1 : 1) * ") : "") + (e ? "(".concat(e, " + ").concat(d, ")") : d)
                     }
                 }
-                return r = r || 0, i + (n ? -r - o : +r + o)
+                return r = r || 0, i + (n ? -r - c : +r + c)
             }
 
-            function Yu(t) {
+            function of(t) {
                 let {
                     fieldDef: e,
                     scaleName: n,
                     bandPosition: i,
                     offset: r
                 } = t;
-                return ta({
+                return oa({
                     scaleName: n,
                     fieldOrDatumDef: e,
                     bandPosition: i,
                     offset: r
                 })
             }
-            const Vu = new Set(["aria", "width", "height"]);
+            const af = new Set(["aria", "width", "height"]);
 
-            function Ku(t, e) {
+            function sf(t, e) {
                 const {
                     fill: n,
                     stroke: i
-                } = "include" === e.color ? Pu(t) : {};
+                } = "include" === e.color ? Hu(t) : {};
                 return {
-                    ...tf(t.markDef, e),
-                    ...Qu(t, "fill", n),
-                    ...Qu(t, "stroke", i),
-                    ...Ru("opacity", t),
-                    ...Ru("fillOpacity", t),
-                    ...Ru("strokeOpacity", t),
-                    ...Ru("strokeWidth", t),
-                    ...Ru("strokeDash", t),
+                    ...lf(t.markDef, e),
+                    ...cf(t, "fill", n),
+                    ...cf(t, "stroke", i),
+                    ...Wu("opacity", t),
+                    ...Wu("fillOpacity", t),
+                    ...Wu("strokeOpacity", t),
+                    ...Wu("strokeWidth", t),
+                    ...Wu("strokeDash", t),
+                    ...Xu(t),
                     ...Lu(t),
-                    ...Fu(t),
-                    ...Su(t, "href"),
-                    ...Tu(t)
+                    ...zu(t, "href"),
+                    ...ju(t)
                 }
             }
 
-            function Qu(t, e, n) {
+            function cf(t, e, n) {
                 const {
                     config: i,
                     mark: r,
                     markDef: o
                 } = t;
-                if ("hide" === ki("invalid", o, i) && n && !Bo(r)) {
+                if ("hide" === ki("invalid", o, i) && n && !Ho(r)) {
                     const i = function(t, e) {
                         let {
                             invalid: n = !1,
                             channels: i
                         } = e;
                         const r = i.reduce(((e, n) => {
                                 const i = t.getScaleComponent(n);
                                 if (i) {
                                     const r = i.get("type"),
                                         o = t.vgField(n, {
                                             expr: "datum"
                                         });
-                                    o && co(r) && (e[o] = !0)
+                                    o && po(r) && (e[o] = !0)
                                 }
                                 return e
                             }), {}),
                             o = bt(r);
                         if (o.length > 0) {
                             const t = n ? "||" : "&&";
-                            return o.map((t => Ko(t, n))).join(" ".concat(t, " "))
+                            return o.map((t => ia(t, n))).join(" ".concat(t, " "))
                         }
                         return
                     }(t, {
                         invalid: !0,
                         channels: Ln
                     });
                     if (i) return {
@@ -8427,19 +8542,19 @@
                     }
                 }
                 return n ? {
                     [e]: n
                 } : {}
             }
 
-            function tf(t, e) {
-                return di.reduce(((n, i) => (Vu.has(i) || void 0 === t[i] || "ignore" === e[i] || (n[i] = yi(t[i])), n)), {})
+            function lf(t, e) {
+                return di.reduce(((n, i) => (af.has(i) || void 0 === t[i] || "ignore" === e[i] || (n[i] = yi(t[i])), n)), {})
             }
 
-            function ef(t) {
+            function uf(t) {
                 const {
                     config: e,
                     markDef: n
                 } = t;
                 if (ki("invalid", n, e)) {
                     const e = function(t, e) {
                         let {
@@ -8451,56 +8566,56 @@
                                 if (i) {
                                     var r;
                                     const o = i.get("type"),
                                         a = t.vgField(n, {
                                             expr: "datum",
                                             binSuffix: null !== (r = t.stack) && void 0 !== r && r.impute ? "mid" : void 0
                                         });
-                                    a && co(o) && (e[a] = !0)
+                                    a && po(o) && (e[a] = !0)
                                 }
                                 return e
                             }), {}),
                             o = bt(r);
                         if (o.length > 0) {
                             const t = n ? "||" : "&&";
-                            return o.map((t => Ko(t, n))).join(" ".concat(t, " "))
+                            return o.map((t => ia(t, n))).join(" ".concat(t, " "))
                         }
                         return
                     }(t, {
                         channels: bn
                     });
                     if (e) return {
                         defined: {
                             signal: e
                         }
                     }
                 }
                 return {}
             }
 
-            function nf(t, e) {
+            function ff(t, e) {
                 if (void 0 !== e) return {
                     [t]: yi(e)
                 }
             }
-            const rf = "voronoi",
-                of = {
+            const df = "voronoi",
+                hf = {
                     defined: t => "point" === t.type && t.nearest,
                     parse: (t, e) => {
                         if (e.events)
-                            for (const n of e.events) n.markname = t.getName(rf)
+                            for (const n of e.events) n.markname = t.getName(df)
                     },
                     marks: (t, e, n) => {
                         const {
                             x: i,
                             y: r
                         } = e.project.hasChannel, o = t.mark;
-                        if (Bo(o)) return dr('The "nearest" transform is not supported for '.concat(o, " marks.")), n;
+                        if (Ho(o)) return dr('The "nearest" transform is not supported for '.concat(o, " marks.")), n;
                         const a = {
-                            name: t.getName(rf),
+                            name: t.getName(df),
                             type: "path",
                             interactive: !0,
                             from: {
                                 data: t.getName("marks")
                             },
                             encode: {
                                 update: {
@@ -8512,15 +8627,15 @@
                                     },
                                     stroke: {
                                         value: "transparent"
                                     },
                                     isVoronoi: {
                                         value: !0
                                     },
-                                    ...Fu(t, {
+                                    ...Lu(t, {
                                         reactiveGeom: !0
                                     })
                                 }
                             },
                             transform: [{
                                 type: "voronoi",
                                 x: {
@@ -8533,81 +8648,81 @@
                             }]
                         };
                         let s = 0,
                             c = !1;
                         return n.forEach(((e, n) => {
                             var i;
                             const r = null !== (i = e.name) && void 0 !== i ? i : "";
-                            r === t.component.mark[0].name ? s = n : r.indexOf(rf) >= 0 && (c = !0)
+                            r === t.component.mark[0].name ? s = n : r.indexOf(df) >= 0 && (c = !0)
                         })), c || n.splice(s + 1, 0, a), n
                     }
                 },
-                af = of,
-                sf = {
-                    defined: t => "point" === t.type && "global" === t.resolve && t.bind && "scales" !== t.bind && !fc(t.bind),
-                    parse: (t, e, n) => Cf(e, n),
+                pf = hf,
+                mf = {
+                    defined: t => "point" === t.type && "global" === t.resolve && t.bind && "scales" !== t.bind && !gc(t.bind),
+                    parse: (t, e, n) => Pf(e, n),
                     topLevelSignals: (t, e, n) => {
                         const i = e.name,
                             r = e.project,
                             o = e.bind,
                             a = e.init && e.init[0],
-                            s = af.defined(e) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
+                            s = pf.defined(e) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
                         return r.items.forEach(((t, r) => {
                             const c = kt("".concat(i, "_").concat(t.field));
                             var l, u;
                             n.filter((t => t.name === c)).length || n.unshift({
                                 name: c,
                                 ...a ? {
-                                    init: nu(a[r])
+                                    init: cu(a[r])
                                 } : {
                                     value: null
                                 },
                                 on: e.events ? [{
                                     events: e.events,
                                     update: "datum && item().mark.marktype !== 'group' ? ".concat(s, "[").concat((0, U.m8)(t.field), "] : null")
                                 }] : [],
                                 bind: null !== (l = null !== (u = o[t.field]) && void 0 !== u ? u : o[t.channel]) && void 0 !== l ? l : o
                             })
                         })), n
                     },
                     signals: (t, e, n) => {
                         const i = e.name,
                             r = e.project,
-                            o = n.filter((t => t.name === i + wf))[0],
-                            a = i + uu,
+                            o = n.filter((t => t.name === i + Ff))[0],
+                            a = i + yu,
                             s = r.items.map((t => kt("".concat(i, "_").concat(t.field)))),
                             c = s.map((t => "".concat(t, " !== null"))).join(" && ");
                         return s.length && (o.update = "".concat(c, " ? {fields: ").concat(a, ", values: [").concat(s.join(", "), "]} : null")), delete o.value, delete o.on, n
                     }
                 },
-                cf = sf,
-                lf = "_toggle",
-                uf = {
+                gf = mf,
+                vf = "_toggle",
+                yf = {
                     defined: t => "point" === t.type && !!t.toggle,
                     signals: (t, e, n) => n.concat({
-                        name: e.name + lf,
+                        name: e.name + vf,
                         value: !1,
                         on: [{
                             events: e.events,
                             update: e.toggle
                         }]
                     }),
                     modifyExpr: (t, e) => {
-                        const n = e.name + wf,
-                            i = e.name + lf;
-                        return "".concat(i, " ? null : ").concat(n, ", ") + ("global" === e.resolve ? "".concat(i, " ? null : true, ") : "".concat(i, " ? null : {unit: ").concat(Af(t), "}, ")) + "".concat(i, " ? ").concat(n, " : null")
+                        const n = e.name + Ff,
+                            i = e.name + vf;
+                        return "".concat(i, " ? null : ").concat(n, ", ") + ("global" === e.resolve ? "".concat(i, " ? null : true, ") : "".concat(i, " ? null : {unit: ").concat(Rf(t), "}, ")) + "".concat(i, " ? ").concat(n, " : null")
                     }
                 },
-                ff = {
+                bf = {
                     defined: t => void 0 !== t.clear && !1 !== t.clear,
                     parse: (t, e) => {
-                        e.clear && (e.clear = (0, U.HD)(e.clear) ? (0, tu.r)(e.clear, "view") : e.clear)
+                        e.clear && (e.clear = (0, U.HD)(e.clear) ? (0, au.r)(e.clear, "view") : e.clear)
                     },
                     topLevelSignals: (t, e, n) => {
-                        if (cf.defined(e))
+                        if (gf.defined(e))
                             for (const i of e.project.items) {
                                 const t = n.findIndex((t => t.name === kt("".concat(e.name, "_").concat(i.field)))); - 1 !== t && n[t].on.push({
                                     events: e.clear,
                                     update: "null"
                                 })
                             }
                         return n
@@ -8622,52 +8737,52 @@
                         if ("interval" === e.type)
                             for (const r of e.project.items) {
                                 const t = n.findIndex((t => t.name === r.signals.visual));
                                 if (i(t, "[0, 0]"), -1 === t) {
                                     i(n.findIndex((t => t.name === r.signals.data)), "null")
                                 }
                             } else {
-                                let t = n.findIndex((t => t.name === e.name + wf));
-                                i(t, "null"), uf.defined(e) && (t = n.findIndex((t => t.name === e.name + lf)), i(t, "false"))
+                                let t = n.findIndex((t => t.name === e.name + Ff));
+                                i(t, "null"), yf.defined(e) && (t = n.findIndex((t => t.name === e.name + vf)), i(t, "false"))
                             }
                         return n
                     }
                 },
-                df = {
+                xf = {
                     defined: t => {
-                        const e = "global" === t.resolve && t.bind && fc(t.bind),
-                            n = 1 === t.project.items.length && t.project.items[0].field !== lc;
+                        const e = "global" === t.resolve && t.bind && gc(t.bind),
+                            n = 1 === t.project.items.length && t.project.items[0].field !== pc;
                         return e && !n && dr("Legend bindings are only supported for selections over an individual field or encoding channel."), e && n
                     },
                     parse: (t, e, n) => {
                         const i = tt(n);
                         if (i.select = (0, U.HD)(i.select) ? {
                                 type: i.select,
                                 toggle: e.toggle
                             } : {
                                 ...i.select,
                                 toggle: e.toggle
-                            }, Cf(e, i), (0, B.isObject)(n.select) && (n.select.on || n.select.clear)) {
+                            }, Pf(e, i), (0, I.isObject)(n.select) && (n.select.on || n.select.clear)) {
                             const t = 'event.item && indexof(event.item.mark.role, "legend") < 0';
                             for (const n of e.events) {
                                 var r;
                                 n.filter = (0, U.IX)(null !== (r = n.filter) && void 0 !== r ? r : []), n.filter.includes(t) || n.filter.push(t)
                             }
                         }
-                        const o = dc(e.bind) ? e.bind.legend : "click",
-                            a = (0, U.HD)(o) ? (0, tu.r)(o, "view") : (0, U.IX)(o);
+                        const o = vc(e.bind) ? e.bind.legend : "click",
+                            a = (0, U.HD)(o) ? (0, au.r)(o, "view") : (0, U.IX)(o);
                         e.bind = {
                             legend: {
                                 merge: a
                             }
                         }
                     },
                     topLevelSignals: (t, e, n) => {
                         const i = e.name,
-                            r = dc(e.bind) && e.bind.legend,
+                            r = vc(e.bind) && e.bind.legend,
                             o = t => e => {
                                 const n = tt(e);
                                 return n.markname = t, n
                             };
                         for (const a of e.project.items) {
                             if (!a.hasLegend) continue;
                             const t = "".concat(kt(a.field), "_legend"),
@@ -8692,71 +8807,71 @@
                             }
                         }
                         return n
                     },
                     signals: (t, e, n) => {
                         const i = e.name,
                             r = e.project,
-                            o = n.find((t => t.name === i + wf)),
-                            a = i + uu,
+                            o = n.find((t => t.name === i + Ff)),
+                            a = i + yu,
                             s = r.items.filter((t => t.hasLegend)).map((t => kt("".concat(i, "_").concat(kt(t.field), "_legend")))),
                             c = s.map((t => "".concat(t, " !== null"))).join(" && "),
                             l = "".concat(c, " ? {fields: ").concat(a, ", values: [").concat(s.join(", "), "]} : null");
                         e.events && s.length > 0 ? o.on.push({
                             events: s.map((t => ({
                                 signal: t
                             }))),
                             update: l
                         }) : s.length > 0 && (o.update = l, delete o.value, delete o.on);
-                        const u = n.find((t => t.name === i + lf)),
-                            f = dc(e.bind) && e.bind.legend;
+                        const u = n.find((t => t.name === i + vf)),
+                            f = vc(e.bind) && e.bind.legend;
                         return u && (e.events ? u.on.push({
                             ...u.on[0],
                             events: f
                         }) : u.on[0].events = f), n
                     }
                 };
-            const hf = "_translate_anchor",
-                pf = "_translate_delta",
-                mf = {
+            const _f = "_translate_anchor",
+                wf = "_translate_delta",
+                kf = {
                     defined: t => "interval" === t.type && t.translate,
                     signals: (t, e, n) => {
                         const i = e.name,
-                            r = mu.defined(e),
-                            o = i + hf,
+                            r = ku.defined(e),
+                            o = i + _f,
                             {
                                 x: a,
                                 y: s
                             } = e.project.hasChannel;
-                        let c = (0, tu.r)(e.translate, "scope");
-                        return r || (c = c.map((t => (t.between[0].markname = i + yu, t)))), n.push({
+                        let c = (0, au.r)(e.translate, "scope");
+                        return r || (c = c.map((t => (t.between[0].markname = i + Du, t)))), n.push({
                             name: o,
                             value: {},
                             on: [{
                                 events: c.map((t => t.between[0])),
-                                update: "{x: x(unit), y: y(unit)" + (void 0 !== a ? ", extent_x: ".concat(r ? gu(t, Xt) : "slice(".concat(a.signals.visual, ")")) : "") + (void 0 !== s ? ", extent_y: ".concat(r ? gu(t, Jt) : "slice(".concat(s.signals.visual, ")")) : "") + "}"
+                                update: "{x: x(unit), y: y(unit)" + (void 0 !== a ? ", extent_x: ".concat(r ? Eu(t, Xt) : "slice(".concat(a.signals.visual, ")")) : "") + (void 0 !== s ? ", extent_y: ".concat(r ? Eu(t, Gt) : "slice(".concat(s.signals.visual, ")")) : "") + "}"
                             }]
                         }, {
-                            name: i + pf,
+                            name: i + wf,
                             value: {},
                             on: [{
                                 events: c,
                                 update: "{x: ".concat(o, ".x - x(unit), y: ").concat(o, ".y - y(unit)}")
                             }]
-                        }), void 0 !== a && gf(t, e, a, "width", n), void 0 !== s && gf(t, e, s, "height", n), n
+                        }), void 0 !== a && Ef(t, e, a, "width", n), void 0 !== s && Ef(t, e, s, "height", n), n
                     }
                 };
 
-            function gf(t, e, n, i, r) {
+            function Ef(t, e, n, i, r) {
                 var o, a;
                 const s = e.name,
-                    c = s + hf,
-                    l = s + pf,
+                    c = s + _f,
+                    l = s + wf,
                     u = n.channel,
-                    f = mu.defined(e),
+                    f = ku.defined(e),
                     d = r.filter((t => t.name === n.signals[f ? "data" : "visual"]))[0],
                     h = t.getSizeSignalRef(i).signal,
                     p = t.getScaleComponent(u),
                     m = p && p.get("type"),
                     g = p && p.get("reverse"),
                     v = f ? u === Xt ? g ? "" : "-" : g ? "-" : "" : "",
                     y = "".concat(c, ".extent_").concat(u),
@@ -8767,126 +8882,126 @@
                 d.on.push({
                     events: {
                         signal: l
                     },
                     update: f ? w : "clampRange(".concat(w, ", 0, ").concat(h, ")")
                 })
             }
-            const vf = "_zoom_anchor",
-                yf = "_zoom_delta",
-                bf = {
+            const Af = "_zoom_anchor",
+                Df = "_zoom_delta",
+                Sf = {
                     defined: t => "interval" === t.type && t.zoom,
                     signals: (t, e, n) => {
                         const i = e.name,
-                            r = mu.defined(e),
-                            o = i + yf,
+                            r = ku.defined(e),
+                            o = i + Df,
                             {
                                 x: a,
                                 y: s
                             } = e.project.hasChannel,
                             c = (0, U.m8)(t.scaleName(Xt)),
-                            l = (0, U.m8)(t.scaleName(Jt));
-                        let u = (0, tu.r)(e.zoom, "scope");
-                        return r || (u = u.map((t => (t.markname = i + yu, t)))), n.push({
-                            name: i + vf,
+                            l = (0, U.m8)(t.scaleName(Gt));
+                        let u = (0, au.r)(e.zoom, "scope");
+                        return r || (u = u.map((t => (t.markname = i + Du, t)))), n.push({
+                            name: i + Af,
                             on: [{
                                 events: u,
                                 update: r ? "{" + [c ? "x: invert(".concat(c, ", x(unit))") : "", l ? "y: invert(".concat(l, ", y(unit))") : ""].filter((t => t)).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
                             }]
                         }, {
                             name: o,
                             on: [{
                                 events: u,
                                 force: !0,
                                 update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
                             }]
-                        }), void 0 !== a && xf(t, e, a, "width", n), void 0 !== s && xf(t, e, s, "height", n), n
+                        }), void 0 !== a && Cf(t, e, a, "width", n), void 0 !== s && Cf(t, e, s, "height", n), n
                     }
                 };
 
-            function xf(t, e, n, i, r) {
+            function Cf(t, e, n, i, r) {
                 var o, a;
                 const s = e.name,
                     c = n.channel,
-                    l = mu.defined(e),
+                    l = ku.defined(e),
                     u = r.filter((t => t.name === n.signals[l ? "data" : "visual"]))[0],
                     f = t.getSizeSignalRef(i).signal,
                     d = t.getScaleComponent(c),
                     h = d && d.get("type"),
-                    p = l ? gu(t, c) : u.name,
-                    m = s + yf,
-                    g = "".concat(s).concat(vf, ".").concat(c),
+                    p = l ? Eu(t, c) : u.name,
+                    m = s + Df,
+                    g = "".concat(s).concat(Af, ".").concat(c),
                     v = l && d ? "log" === h ? "zoomLog" : "symlog" === h ? "zoomSymlog" : "pow" === h ? "zoomPow" : "zoomLinear" : "zoomLinear",
                     y = l ? "pow" === h ? ", ".concat(null !== (o = d.get("exponent")) && void 0 !== o ? o : 1) : "symlog" === h ? ", ".concat(null !== (a = d.get("constant")) && void 0 !== a ? a : 1) : "" : "",
                     b = "".concat(v, "(").concat(p, ", ").concat(g, ", ").concat(m).concat(y, ")");
                 u.on.push({
                     events: {
                         signal: m
                     },
                     update: l ? b : "clampRange(".concat(b, ", 0, ").concat(f, ")")
                 })
             }
-            const _f = "_store",
-                wf = "_tuple",
-                kf = "_modify",
-                Ef = "vlSelectionResolve",
-                Df = [Du, ku, hu, uf, cf, mu, df, ff, mf, bf, af];
+            const Mf = "_store",
+                Ff = "_tuple",
+                Of = "_modify",
+                Tf = "vlSelectionResolve",
+                Nf = [Nu, Ou, _u, yf, gf, ku, xf, bf, kf, Sf, pf];
 
-            function Af(t) {
+            function Rf(t) {
                 let {
                     escape: e
                 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                     escape: !0
                 }, n = e ? (0, U.m8)(t.name) : t.name;
                 const i = function(t) {
                     let e = t.parent;
-                    for (; e && !dp(e);) e = e.parent;
+                    for (; e && !xp(e);) e = e.parent;
                     return e
                 }(t);
                 if (i) {
                     const {
                         facet: t
                     } = i;
                     for (const e of Ne) t[e] && (n += " + '__facet_".concat(e, "_' + (facet[").concat((0, U.m8)(i.vgField(e)), "])"))
                 }
                 return n
             }
 
-            function Sf(t) {
+            function zf(t) {
                 var e;
                 return xt(null !== (e = t.component.selection) && void 0 !== e ? e : {}).reduce(((t, e) => t || e.project.hasSelectionId), !1)
             }
 
-            function Cf(t, e) {
-                !(0, B.isString)(e.select) && e.select.on || delete t.events, !(0, B.isString)(e.select) && e.select.clear || delete t.clear, !(0, B.isString)(e.select) && e.select.toggle || delete t.toggle
+            function Pf(t, e) {
+                !(0, I.isString)(e.select) && e.select.on || delete t.events, !(0, I.isString)(e.select) && e.select.clear || delete t.clear, !(0, I.isString)(e.select) && e.select.toggle || delete t.toggle
             }
-            var Ff = n(88120);
+            var Lf = n(88120);
 
-            function Mf(t) {
+            function Bf(t) {
                 const e = [];
-                return "Identifier" === t.type ? [t.name] : "Literal" === t.type ? [t.value] : ("MemberExpression" === t.type && (e.push(...Mf(t.object)), e.push(...Mf(t.property))), e)
+                return "Identifier" === t.type ? [t.name] : "Literal" === t.type ? [t.value] : ("MemberExpression" === t.type && (e.push(...Bf(t.object)), e.push(...Bf(t.property))), e)
             }
 
-            function Of(t) {
-                return "MemberExpression" === t.object.type ? Of(t.object) : "datum" === t.object.name
+            function If(t) {
+                return "MemberExpression" === t.object.type ? If(t.object) : "datum" === t.object.name
             }
 
-            function Tf(t) {
-                const e = (0, Ff.BJ)(t),
+            function jf(t) {
+                const e = (0, Lf.BJ)(t),
                     n = new Set;
                 return e.visit((t => {
-                    "MemberExpression" === t.type && Of(t) && n.add(Mf(t).slice(1).join("."))
+                    "MemberExpression" === t.type && If(t) && n.add(Bf(t).slice(1).join("."))
                 })), n
             }
-            class Nf extends su {
+            class Uf extends hu {
                 clone() {
-                    return new Nf(null, this.model, tt(this.filter))
+                    return new Uf(null, this.model, tt(this.filter))
                 }
                 constructor(t, e, n) {
-                    super(t), this.model = e, this.filter = n, this.expr = Pf(this.model, this.filter, this), this._dependentFields = Tf(this.expr)
+                    super(t), this.model = e, this.filter = n, this.expr = Hf(this.model, this.filter, this), this._dependentFields = jf(this.expr)
                 }
                 dependentFields() {
                     return this._dependentFields
                 }
                 producedFields() {
                     return new Set
                 }
@@ -8897,19 +9012,19 @@
                     }
                 }
                 hash() {
                     return "Filter ".concat(this.expr)
                 }
             }
 
-            function zf(t, e, n) {
+            function qf(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "datum";
                 const r = (0, U.HD)(e) ? e : e.param,
                     o = kt(r),
-                    a = (0, U.m8)(o + _f);
+                    a = (0, U.m8)(o + Mf);
                 let s;
                 try {
                     s = t.getSelectionComponent(o, r)
                 } catch (d) {
                     return "!!".concat(o)
                 }
                 if (s.project.timeUnit) {
@@ -8920,101 +9035,101 @@
                 const c = s.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(",
                     l = "global" === s.resolve ? ")" : ", ".concat((0, U.m8)(s.resolve), ")"),
                     u = "".concat(c).concat(a, ", ").concat(i).concat(l),
                     f = "length(data(".concat(a, "))");
                 return !1 === e.empty ? "".concat(f, " && ").concat(u) : "!".concat(f, " || ").concat(u)
             }
 
-            function Rf(t, e, n) {
+            function Wf(t, e, n) {
                 const i = kt(e),
                     r = n.encoding;
                 let o, a = n.field;
                 try {
                     o = t.getSelectionComponent(i, e)
                 } catch (s) {
                     return i
                 }
                 if (r || a) {
                     if (r && !a) {
                         const t = o.project.items.filter((t => t.channel === r));
                         !t.length || t.length > 1 ? (a = o.project.items[0].field, dr((t.length ? "Multiple " : "No ") + "matching ".concat((0, U.m8)(r), " encoding found for selection ").concat((0, U.m8)(n.param), ". ") + 'Using "field": '.concat((0, U.m8)(a), "."))) : a = t[0].field
                     }
                 } else a = o.project.items[0].field, o.project.items.length > 1 && dr('A "field" or "encoding" must be specified when using a selection as a scale domain. ' + 'Using "field": '.concat((0, U.m8)(a), "."));
-                return "".concat(o.name, "[").concat((0, U.m8)(Mt(a)), "]")
+                return "".concat(o.name, "[").concat((0, U.m8)(Ft(a)), "]")
             }
 
-            function Pf(t, e, n) {
+            function Hf(t, e, n) {
                 return Et(e, (e => (0, U.HD)(e) ? e : function(t) {
                     return null === t || void 0 === t ? void 0 : t.param
-                }(e) ? zf(t, e, n) : Br(e)))
+                }(e) ? qf(t, e, n) : Hr(e)))
             }
 
-            function Lf(t, e, n, i) {
+            function Xf(t, e, n, i) {
                 var r, o, a, s, c;
                 null !== (r = t.encode) && void 0 !== r || (t.encode = {}), null !== (o = (s = t.encode)[e]) && void 0 !== o || (s[e] = {}), null !== (a = (c = t.encode[e]).update) && void 0 !== a || (c.update = {}), t.encode[e].update[n] = i
             }
 
-            function jf(t, e, n) {
+            function Gf(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                     header: !1
                 };
                 const {
                     disable: r,
                     orient: o,
                     scale: a,
                     labelExpr: s,
                     title: c,
                     zindex: l,
                     ...u
                 } = t.combine();
                 if (!r) {
                     for (const t in u) {
-                        const n = gs[t],
+                        const n = _s[t],
                             i = u[t];
                         if (n && n !== e && "both" !== n) delete u[t];
-                        else if (ps(i)) {
+                        else if (bs(i)) {
                             const {
                                 condition: e,
                                 ...n
-                            } = i, r = (0, U.IX)(e), o = hs[t];
+                            } = i, r = (0, U.IX)(e), o = ys[t];
                             if (o) {
                                 const {
                                     vgProp: e,
                                     part: i
                                 } = o;
-                                Lf(u, i, e, [...r.map((t => {
+                                Xf(u, i, e, [...r.map((t => {
                                     const {
                                         test: e,
                                         ...n
                                     } = t;
                                     return {
-                                        test: Pf(null, e),
+                                        test: Hf(null, e),
                                         ...n
                                     }
                                 })), n]), delete u[t]
                             } else if (null === o) {
                                 const e = {
                                     signal: r.map((t => {
                                         const {
                                             test: e,
                                             ...n
                                         } = t;
-                                        return "".concat(Pf(null, e), " ? ").concat(bi(n), " : ")
+                                        return "".concat(Hf(null, e), " ? ").concat(bi(n), " : ")
                                     })).join("") + bi(n)
                                 };
                                 u[t] = e
                             }
                         } else if (li(i)) {
-                            const e = hs[t];
+                            const e = ys[t];
                             if (e) {
                                 const {
                                     vgProp: n,
                                     part: r
                                 } = e;
-                                Lf(u, r, n, i), delete u[t]
+                                Xf(u, r, n, i), delete u[t]
                             }
                         }
                         st(["labelAlign", "labelBaseline"], t) && null === u[t] && delete u[t]
                     }
                     if ("grid" === e) {
                         if (!u.grid) return;
                         if (u.encode) {
@@ -9033,50 +9148,50 @@
                             ...u,
                             domain: !1,
                             labels: !1,
                             aria: !1,
                             maxExtent: 0,
                             minExtent: 0,
                             ticks: !1,
-                            zindex: zt(l, 0)
+                            zindex: Rt(l, 0)
                         }
                     } {
                         if (!i.header && t.mainExtracted) return;
                         if (void 0 !== s) {
                             var f, d;
                             let t = s;
-                            null !== (f = u.encode) && void 0 !== f && null !== (d = f.labels) && void 0 !== d && d.update && li(u.encode.labels.update.text) && (t = Ot(s, "datum.label", u.encode.labels.update.text.signal)), Lf(u, "labels", "text", {
+                            null !== (f = u.encode) && void 0 !== f && null !== (d = f.labels) && void 0 !== d && d.update && li(u.encode.labels.update.text) && (t = Ot(s, "datum.label", u.encode.labels.update.text.signal)), Xf(u, "labels", "text", {
                                 signal: t
                             })
                         }
                         if (null === u.labelAlign && delete u.labelAlign, u.encode) {
-                            for (const e of ms) t.hasAxisPart(e) || delete u.encode[e];
+                            for (const e of xs) t.hasAxisPart(e) || delete u.encode[e];
                             yt(u.encode) && delete u.encode
                         }
                         const e = function(t, e) {
-                            if (t) return (0, U.kJ)(t) && !ci(t) ? t.map((t => ts(t, e))).join(", ") : t
+                            if (t) return (0, U.kJ)(t) && !ci(t) ? t.map((t => os(t, e))).join(", ") : t
                         }(c, n);
                         return {
                             scale: a,
                             orient: o,
                             grid: !1,
                             ...e ? {
                                 title: e
                             } : {},
                             ...u,
                             ...!1 === n.aria ? {
                                 aria: !1
                             } : {},
-                            zindex: zt(l, 0)
+                            zindex: Rt(l, 0)
                         }
                     }
                 }
             }
 
-            function Bf(t) {
+            function Jf(t) {
                 const {
                     axes: e
                 } = t.component, n = [];
                 for (const i of bn)
                     if (e[i])
                         for (const r of e[i])
                             if (!r.get("disable") && !r.get("gridScale")) {
@@ -9085,15 +9200,15 @@
                                 e !== r && n.push({
                                     name: e,
                                     update: r
                                 })
                             } return n
             }
 
-            function If(t, e, n, i) {
+            function Zf(t, e, n, i) {
                 return Object.assign.apply(null, [{}, ...t.map((t => {
                     if ("axisOrient" === t) {
                         const t = "x" === n ? "bottom" : "left",
                             r = e["x" === n ? "axisBottom" : "axisLeft"] || {},
                             o = e["x" === n ? "axisTop" : "axisRight"] || {},
                             a = new Set([...bt(r), ...bt(o)]),
                             s = {};
@@ -9102,44 +9217,44 @@
                         };
                         return s
                     }
                     return e[t]
                 }))])
             }
 
-            function Uf(t, e) {
+            function $f(t, e) {
                 const n = [{}];
                 for (const r of t) {
                     var i;
                     let t = null === (i = e[r]) || void 0 === i ? void 0 : i.style;
                     if (t) {
                         t = (0, U.IX)(t);
                         for (const i of t) n.push(e.style[i])
                     }
                 }
                 return Object.assign.apply(null, n)
             }
 
-            function qf(t, e, n) {
+            function Yf(t, e, n) {
                 let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
-                const r = Ai(t, n, e);
+                const r = Di(t, n, e);
                 if (void 0 !== r) return {
                     configFrom: "style",
                     configValue: r
                 };
                 for (const a of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
                     var o;
                     if (void 0 !== (null === (o = i[a]) || void 0 === o ? void 0 : o[t])) return {
                         configFrom: a,
                         configValue: i[a][t]
                     }
                 }
                 return {}
             }
-            const Wf = {
+            const Vf = {
                 scale: t => {
                     let {
                         model: e,
                         channel: n
                     } = t;
                     return e.scaleName(n)
                 },
@@ -9159,15 +9274,15 @@
                     var e;
                     let {
                         fieldOrDatumDef: n,
                         axis: i,
                         scaleType: r
                     } = t;
                     return null !== (e = i.grid) && void 0 !== e ? e : function(t, e) {
-                        return !so(t) && Na(e) && !ti(null === e || void 0 === e ? void 0 : e.bin) && !ei(null === e || void 0 === e ? void 0 : e.bin)
+                        return !ho(t) && Ba(e) && !ti(null === e || void 0 === e ? void 0 : e.bin) && !ei(null === e || void 0 === e ? void 0 : e.bin)
                     }(r, n)
                 },
                 gridScale: t => {
                     let {
                         model: e,
                         channel: n
                     } = t;
@@ -9180,30 +9295,30 @@
                 labelAlign: t => {
                     let {
                         axis: e,
                         labelAngle: n,
                         orient: i,
                         channel: r
                     } = t;
-                    return e.labelAlign || Jf(n, i, r)
+                    return e.labelAlign || td(n, i, r)
                 },
                 labelAngle: t => {
                     let {
                         labelAngle: e
                     } = t;
                     return e
                 },
                 labelBaseline: t => {
                     let {
                         axis: e,
                         labelAngle: n,
                         orient: i,
                         channel: r
                     } = t;
-                    return e.labelBaseline || Xf(n, i, r)
+                    return e.labelBaseline || Qf(n, i, r)
                 },
                 labelFlush: t => {
                     var e;
                     let {
                         axis: n,
                         fieldOrDatumDef: i,
                         channel: r
@@ -9219,15 +9334,15 @@
                         axis: n,
                         fieldOrDatumDef: i,
                         scaleType: r
                     } = t;
                     return null !== (e = n.labelOverlap) && void 0 !== e ? e : function(t, e, n, i) {
                         if (n && !(0, U.Kn)(i) || "nominal" !== t && "ordinal" !== t) return "log" !== e && "symlog" !== e || "greedy";
                         return
-                    }(i.type, r, Na(i) && !!i.timeUnit, Na(i) ? i.sort : void 0)
+                    }(i.type, r, Ba(i) && !!i.timeUnit, Ba(i) ? i.sort : void 0)
                 },
                 orient: t => {
                     let {
                         orient: e
                     } = t;
                     return e
                 },
@@ -9245,21 +9360,21 @@
                     return null !== (e = r.tickCount) && void 0 !== e ? e : function(t) {
                         let {
                             fieldOrDatumDef: e,
                             scaleType: n,
                             size: i,
                             values: r
                         } = t;
-                        if (!r && !so(n) && "log" !== n) {
-                            if (Na(e)) {
+                        if (!r && !ho(n) && "log" !== n) {
+                            if (Ba(e)) {
                                 var o;
                                 if (ti(e.bin)) return {
                                     signal: "ceil(".concat(i.signal, "/10)")
                                 };
-                                if (e.timeUnit && st(["month", "hours", "day", "quarter"], null === (o = Cr(e.timeUnit)) || void 0 === o ? void 0 : o.unit)) return
+                                if (e.timeUnit && st(["month", "hours", "day", "quarter"], null === (o = Or(e.timeUnit)) || void 0 === o ? void 0 : o.unit)) return
                             }
                             return {
                                 signal: "ceil(".concat(i.signal, "/40)")
                             }
                         }
                         return
                     }({
@@ -9271,76 +9386,76 @@
                 },
                 tickMinStep: function(t) {
                     let {
                         format: e,
                         fieldOrDatumDef: n
                     } = t;
                     if ("d" === e) return 1;
-                    if (Na(n)) {
+                    if (Ba(n)) {
                         const {
                             timeUnit: t
                         } = n;
                         if (t) {
-                            const e = Fr(t);
+                            const e = Tr(t);
                             if (e) return {
                                 signal: e
                             }
                         }
                     }
                     return
                 },
                 title: t => {
                     let {
                         axis: e,
                         model: n,
                         channel: i
                     } = t;
                     if (void 0 !== e.title) return e.title;
-                    const r = Gf(n, i);
+                    const r = ed(n, i);
                     if (void 0 !== r) return r;
                     const o = n.typedFieldDef(i),
                         a = "x" === i ? "x2" : "y2",
                         s = n.fieldDef(a);
-                    return Ci(o ? [Ea(o)] : [], Na(s) ? [Ea(s)] : [])
+                    return Ci(o ? [Ma(o)] : [], Ba(s) ? [Ma(s)] : [])
                 },
                 values: t => {
                     let {
                         axis: e,
                         fieldOrDatumDef: n
                     } = t;
                     return function(t, e) {
                         const n = t.values;
-                        if ((0, U.kJ)(n)) return fs(e, n);
+                        if ((0, U.kJ)(n)) return gs(e, n);
                         if (li(n)) return n;
                         return
                     }(e, n)
                 },
                 zindex: t => {
                     var e;
                     let {
                         axis: n,
                         fieldOrDatumDef: i,
                         mark: r
                     } = t;
                     return null !== (e = n.zindex) && void 0 !== e ? e : function(t, e) {
-                        if ("rect" === t && $a(e)) return 1;
+                        if ("rect" === t && Qa(e)) return 1;
                         return 0
                     }(r, i)
                 }
             };
 
-            function Hf(t) {
+            function Kf(t) {
                 return "(((".concat(t.signal, " % 360) + 360) % 360)")
             }
 
-            function Xf(t, e, n, i) {
+            function Qf(t, e, n, i) {
                 if (void 0 !== t) {
                     if ("x" === n) {
                         if (li(t)) {
-                            const n = Hf(t),
+                            const n = Kf(t),
                                 i = li(e) ? "(".concat(e.signal, ' === "top")') : "top" === e;
                             return {
                                 signal: "(45 < ".concat(n, " && ").concat(n, " < 135) || (225 < ").concat(n, " && ").concat(n, ' < 315) ? "middle" :') + "(".concat(n, " <= 45 || 315 <= ").concat(n, ") === ").concat(i, ' ? "bottom" : "top"')
                             }
                         }
                         if (45 < t && t < 135 || 225 < t && t < 315) return "middle";
                         if (li(e)) {
@@ -9348,15 +9463,15 @@
                             return {
                                 signal: "".concat(e.signal, " ").concat(n, ' "top" ? "bottom" : "top"')
                             }
                         }
                         return (t <= 45 || 315 <= t) === ("top" === e) ? "bottom" : "top"
                     }
                     if (li(t)) {
-                        const n = Hf(t),
+                        const n = Kf(t),
                             r = li(e) ? "(".concat(e.signal, ' === "left")') : "left" === e,
                             o = i ? '"middle"' : "null";
                         return {
                             signal: "".concat(n, " <= 45 || 315 <= ").concat(n, " || (135 <= ").concat(n, " && ").concat(n, " <= 225) ? ").concat(o, " : (45 <= ").concat(n, " && ").concat(n, " <= 135) === ").concat(r, ' ? "top" : "bottom"')
                         }
                     }
                     if (t <= 45 || 315 <= t || 135 <= t && t <= 225) return i ? "middle" : null;
@@ -9366,21 +9481,21 @@
                             signal: "".concat(e.signal, " ").concat(n, ' "left" ? "top" : "bottom"')
                         }
                     }
                     return (45 <= t && t <= 135) === ("left" === e) ? "top" : "bottom"
                 }
             }
 
-            function Jf(t, e, n) {
+            function td(t, e, n) {
                 if (void 0 === t) return;
                 const i = "x" === n,
                     r = i ? 0 : 90,
                     o = i ? "bottom" : "left";
                 if (li(t)) {
-                    const n = Hf(t),
+                    const n = Kf(t),
                         a = li(e) ? "(".concat(e.signal, ' === "').concat(o, '")') : e === o;
                     return {
                         signal: "(".concat(r ? "(".concat(n, " + 90)") : n, " % 180 === 0) ? ").concat(i ? null : '"center"', " :") + "(".concat(r, " < ").concat(n, " && ").concat(n, " < ").concat(180 + r, ") === ").concat(a, ' ? "left" : "right"')
                     }
                 }
                 if ((t + r) % 180 === 0) return i ? null : "center";
                 if (li(e)) {
@@ -9389,43 +9504,43 @@
                     return {
                         signal: "".concat(i, ' ? "left" : "right"')
                     }
                 }
                 return (r < t && t < 180 + r) === (e === o) ? "left" : "right"
             }
 
-            function Gf(t, e) {
+            function ed(t, e) {
                 const n = "x" === e ? "x2" : "y2",
                     i = t.fieldDef(e),
                     r = t.fieldDef(n),
                     o = i ? i.title : void 0,
                     a = r ? r.title : void 0;
-                return o && a ? Fi(o, a) : o || (a || (void 0 !== o ? o : void 0 !== a ? a : void 0))
+                return o && a ? Mi(o, a) : o || (a || (void 0 !== o ? o : void 0 !== a ? a : void 0))
             }
-            class $f extends su {
+            class nd extends hu {
                 clone() {
-                    return new $f(null, tt(this.transform))
+                    return new nd(null, tt(this.transform))
                 }
                 constructor(t, e) {
-                    super(t), this.transform = e, this._dependentFields = Tf(this.transform.calculate)
+                    super(t), this.transform = e, this._dependentFields = jf(this.transform.calculate)
                 }
                 static parseAllForSortIndex(t, e) {
                     return e.forEachFieldDef(((e, n) => {
-                        if (qa(e) && xa(e.sort)) {
+                        if (Ja(e) && Aa(e.sort)) {
                             const {
                                 field: i,
                                 timeUnit: r
-                            } = e, o = e.sort, a = o.map(((t, e) => "".concat(Br({
+                            } = e, o = e.sort, a = o.map(((t, e) => "".concat(Hr({
                                 field: i,
                                 timeUnit: r,
                                 equal: t
                             }), " ? ").concat(e, " : "))).join("") + o.length;
-                            t = new $f(t, {
+                            t = new nd(t, {
                                 calculate: a,
-                                as: Zf(e, n, {
+                                as: id(e, n, {
                                     forAs: !0
                                 })
                             })
                         }
                     })), t
                 }
                 producedFields() {
@@ -9442,187 +9557,187 @@
                     }
                 }
                 hash() {
                     return "Calculate ".concat(ot(this.transform))
                 }
             }
 
-            function Zf(t, e, n) {
-                return Ga(t, {
+            function id(t, e, n) {
+                return Ka(t, {
                     prefix: e,
                     suffix: "sort_index",
                     ...null !== n && void 0 !== n ? n : {}
                 })
             }
 
-            function Yf(t, e) {
+            function rd(t, e) {
                 return st(["top", "bottom"], e) ? "column" : st(["left", "right"], e) || "row" === t ? "row" : "column"
             }
 
-            function Vf(t, e, n, i) {
+            function od(t, e, n, i) {
                 const r = "row" === i ? n.headerRow : "column" === i ? n.headerColumn : n.headerFacet;
-                return zt((e || {})[t], r[t], n.header[t])
+                return Rt((e || {})[t], r[t], n.header[t])
             }
 
-            function Kf(t, e, n, i) {
+            function ad(t, e, n, i) {
                 const r = {};
                 for (const o of t) {
-                    const t = Vf(o, e || {}, n, i);
+                    const t = od(o, e || {}, n, i);
                     void 0 !== t && (r[o] = t)
                 }
                 return r
             }
-            const Qf = ["row", "column"],
-                td = ["header", "footer"];
+            const sd = ["row", "column"],
+                cd = ["header", "footer"];
 
-            function ed(t, e) {
+            function ld(t, e) {
                 const n = t.component.layoutHeaders[e].title,
                     i = t.config ? t.config : void 0,
                     r = t.component.layoutHeaders[e].facetFieldDef ? t.component.layoutHeaders[e].facetFieldDef : void 0,
                     {
                         titleAnchor: o,
                         titleAngle: a,
                         titleOrient: s
-                    } = Kf(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, e),
-                    c = Yf(e, s),
-                    l = It(a);
+                    } = ad(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, e),
+                    c = rd(e, s),
+                    l = jt(a);
                 return {
                     name: "".concat(e, "-title"),
                     type: "group",
                     role: "".concat(c, "-title"),
                     title: {
                         text: n,
                         ..."row" === e ? {
                             orient: "left"
                         } : {},
                         style: "guide-title",
-                        ...id(l, c),
-                        ...nd(c, l, o),
-                        ...ud(i, r, e, rc, nc)
+                        ...fd(l, c),
+                        ...ud(c, l, o),
+                        ...yd(i, r, e, lc, sc)
                     }
                 }
             }
 
-            function nd(t, e) {
+            function ud(t, e) {
                 switch (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "middle") {
                     case "start":
                         return {
                             align: "left"
                         };
                     case "end":
                         return {
                             align: "right"
                         }
                 }
-                const n = Jf(e, "row" === t ? "left" : "top", "row" === t ? "y" : "x");
+                const n = td(e, "row" === t ? "left" : "top", "row" === t ? "y" : "x");
                 return n ? {
                     align: n
                 } : {}
             }
 
-            function id(t, e) {
-                const n = Xf(t, "row" === e ? "left" : "top", "row" === e ? "y" : "x", !0);
+            function fd(t, e) {
+                const n = Qf(t, "row" === e ? "left" : "top", "row" === e ? "y" : "x", !0);
                 return n ? {
                     baseline: n
                 } : {}
             }
 
-            function rd(t, e) {
+            function dd(t, e) {
                 const n = t.component.layoutHeaders[e],
                     i = [];
-                for (const r of td)
+                for (const r of cd)
                     if (n[r])
                         for (const o of n[r]) {
-                            const a = sd(t, e, r, n, o);
+                            const a = md(t, e, r, n, o);
                             null != a && i.push(a)
                         }
                 return i
             }
 
-            function od(t, e) {
+            function hd(t, e) {
                 const {
                     sort: n
                 } = t;
                 var i;
-                return ba(n) ? {
-                    field: Ga(n, {
+                return Ea(n) ? {
+                    field: Ka(n, {
                         expr: "datum"
                     }),
                     order: null !== (i = n.order) && void 0 !== i ? i : "ascending"
                 } : (0, U.kJ)(n) ? {
-                    field: Zf(t, e, {
+                    field: id(t, e, {
                         expr: "datum"
                     }),
                     order: "ascending"
                 } : {
-                    field: Ga(t, {
+                    field: Ka(t, {
                         expr: "datum"
                     }),
                     order: null !== n && void 0 !== n ? n : "ascending"
                 }
             }
 
-            function ad(t, e, n) {
+            function pd(t, e, n) {
                 const {
                     format: i,
                     formatType: r,
                     labelAngle: o,
                     labelAnchor: a,
                     labelOrient: s,
                     labelExpr: c
-                } = Kf(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], t.header, n, e), l = aa({
+                } = ad(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], t.header, n, e), l = fa({
                     fieldOrDatumDef: t,
                     format: i,
                     formatType: r,
                     expr: "parent",
                     config: n
-                }).signal, u = Yf(e, s);
+                }).signal, u = rd(e, s);
                 return {
                     text: {
-                        signal: c ? Ot(Ot(c, "datum.label", l), "datum.value", Ga(t, {
+                        signal: c ? Ot(Ot(c, "datum.label", l), "datum.value", Ka(t, {
                             expr: "parent"
                         })) : l
                     },
                     ..."row" === e ? {
                         orient: "left"
                     } : {},
                     style: "guide-label",
                     frame: "group",
-                    ...id(o, u),
-                    ...nd(u, o, a),
-                    ...ud(n, t, e, oc, ic)
+                    ...fd(o, u),
+                    ...ud(u, o, a),
+                    ...yd(n, t, e, uc, cc)
                 }
             }
 
-            function sd(t, e, n, i, r) {
+            function md(t, e, n, i, r) {
                 if (r) {
                     let o = null;
                     const {
                         facetFieldDef: a
                     } = i, s = t.config ? t.config : void 0;
                     if (a && r.labels) {
                         const {
                             labelOrient: t
-                        } = Kf(["labelOrient"], a.header, s, e);
-                        ("row" === e && !st(["top", "bottom"], t) || "column" === e && !st(["left", "right"], t)) && (o = ad(a, e, s))
+                        } = ad(["labelOrient"], a.header, s, e);
+                        ("row" === e && !st(["top", "bottom"], t) || "column" === e && !st(["left", "right"], t)) && (o = pd(a, e, s))
                     }
-                    const c = dp(t) && !_a(t.facet),
+                    const c = xp(t) && !Da(t.facet),
                         l = r.axes,
                         u = (null === l || void 0 === l ? void 0 : l.length) > 0;
                     if (o || u) {
                         const s = "row" === e ? "height" : "width";
                         return {
                             name: t.getName("".concat(e, "_").concat(n)),
                             type: "group",
                             role: "".concat(e, "-").concat(n),
                             ...i.facetFieldDef ? {
                                 from: {
                                     data: t.getName("".concat(e, "_domain"))
                                 },
-                                sort: od(a, e)
+                                sort: hd(a, e)
                             } : {},
                             ...u && c ? {
                                 from: {
                                     data: t.getName("facet_domain_".concat(e))
                                 }
                             } : {},
                             ...o ? {
@@ -9639,70 +9754,70 @@
                                 axes: l
                             } : {}
                         }
                     }
                 }
                 return null
             }
-            const cd = {
+            const gd = {
                 column: {
                     start: 0,
                     end: 1
                 },
                 row: {
                     start: 1,
                     end: 0
                 }
             };
 
-            function ld(t, e) {
-                return cd[e][t]
+            function vd(t, e) {
+                return gd[e][t]
             }
 
-            function ud(t, e, n, i, r) {
+            function yd(t, e, n, i, r) {
                 const o = {};
                 for (const a of i) {
                     if (!r[a]) continue;
-                    const i = Vf(a, null === e || void 0 === e ? void 0 : e.header, t, n);
+                    const i = od(a, null === e || void 0 === e ? void 0 : e.header, t, n);
                     void 0 !== i && (o[r[a]] = i)
                 }
                 return o
             }
 
-            function fd(t) {
-                return [...dd(t, "width"), ...dd(t, "height"), ...dd(t, "childWidth"), ...dd(t, "childHeight")]
+            function bd(t) {
+                return [...xd(t, "width"), ...xd(t, "height"), ...xd(t, "childWidth"), ...xd(t, "childHeight")]
             }
 
-            function dd(t, e) {
+            function xd(t, e) {
                 const n = "width" === e ? "x" : "y",
                     i = t.component.layoutSize.get(e);
                 if (!i || "merged" === i) return [];
                 const r = t.getSizeSignalRef(e).signal;
                 if ("step" === i) {
                     const e = t.getScaleComponent(n);
                     if (e) {
                         const i = e.get("type"),
                             o = e.get("range");
-                        if (so(i) && ui(o)) {
+                        if (ho(i) && ui(o)) {
                             const i = t.scaleName(n);
-                            if (dp(t.parent)) {
-                                if ("independent" === t.parent.component.resolve.scale[n]) return [hd(i, o)]
+                            if (xp(t.parent)) {
+                                if ("independent" === t.parent.component.resolve.scale[n]) return [_d(i, o)]
                             }
-                            return [hd(i, o), {
+                            return [_d(i, o), {
                                 name: r,
-                                update: pd(i, e, "domain('".concat(i, "').length"))
+                                update: wd(i, e, "domain('".concat(i, "').length"))
                             }]
                         }
                     }
                     throw new Error("layout size is step although width/height is not step.")
                 }
                 if ("container" == i) {
                     const e = r.endsWith("width"),
                         n = e ? "containerSize()[0]" : "containerSize()[1]",
-                        i = wc(t.config.view, e ? "width" : "height"),
+                        i = Sc(t.config.view, e ? "width" : "height"),
                         o = "isFinite(".concat(n, ") ? ").concat(n, " : ").concat(i);
                     return [{
                         name: r,
                         init: o,
                         on: [{
                             update: o,
                             events: "window:resize"
@@ -9711,78 +9826,78 @@
                 }
                 return [{
                     name: r,
                     value: i
                 }]
             }
 
-            function hd(t, e) {
+            function _d(t, e) {
                 const n = "".concat(t, "_step");
                 return li(e.step) ? {
                     name: n,
                     update: e.step.signal
                 } : {
                     name: n,
                     value: e.step
                 }
             }
 
-            function pd(t, e, n) {
+            function wd(t, e, n) {
                 const i = e.get("type"),
                     r = e.get("padding"),
-                    o = zt(e.get("paddingOuter"), r);
+                    o = Rt(e.get("paddingOuter"), r);
                 let a = e.get("paddingInner");
                 return a = "band" === i ? void 0 !== a ? a : r : 1, "bandspace(".concat(n, ", ").concat(xi(a), ", ").concat(xi(o), ") * ").concat(t, "_step")
             }
 
-            function md(t) {
+            function kd(t) {
                 return "childWidth" === t ? "width" : "childHeight" === t ? "height" : t
             }
 
-            function gd(t, e) {
+            function Ed(t, e) {
                 return bt(t).reduce(((n, i) => {
                     const r = t[i];
                     return {
                         ...n,
-                        ...Au(e, r, i, (t => yi(t.value)))
+                        ...Ru(e, r, i, (t => yi(t.value)))
                     }
                 }), {})
             }
 
-            function vd(t, e) {
-                if (dp(e)) return "theta" === t ? "independent" : "shared";
-                if (pp(e)) return "shared";
-                if (hp(e)) return xn(t) || "theta" === t || "radius" === t ? "independent" : "shared";
+            function Ad(t, e) {
+                if (xp(e)) return "theta" === t ? "independent" : "shared";
+                if (wp(e)) return "shared";
+                if (_p(e)) return xn(t) || "theta" === t || "radius" === t ? "independent" : "shared";
                 throw new Error("invalid model type for resolve")
             }
 
-            function yd(t, e) {
+            function Dd(t, e) {
                 const n = t.scale[e],
                     i = xn(e) ? "axis" : "legend";
                 return "independent" === n ? ("shared" === t[i][e] && dr(function(t) {
                     return 'Setting the scale to be independent for "'.concat(t, '" means we also have to set the guide (axis or legend) to be independent.')
                 }(e)), "independent") : t[i][e] || "shared"
             }
-            const bd = {
-                    ...cc,
+            const Sd = {
+                    ...hc,
                     disable: 1,
                     labelExpr: 1,
                     selections: 1,
                     opacity: 1,
                     shape: 1,
                     stroke: 1,
                     fill: 1,
                     size: 1,
                     strokeWidth: 1,
                     strokeDash: 1,
                     encode: 1
                 },
-                xd = bt(bd);
-            class _d extends Bl {}
-            const wd = {
+                Cd = bt(Sd);
+            class Md extends Xl {}
+            const Fd = {
                 symbols: function(t, e) {
                     var n, i, r, o;
                     let {
                         fieldOrDatumDef: a,
                         model: s,
                         channel: c,
                         legendCmpt: l,
@@ -9792,46 +9907,46 @@
                     const {
                         markDef: f,
                         encoding: d,
                         config: h,
                         mark: p
                     } = s, m = f.filled && "trail" !== p;
                     let g = {
-                        ..._i({}, s, Wo),
-                        ...Pu(s, {
+                        ..._i({}, s, Zo),
+                        ...Hu(s, {
                             filled: m
                         })
                     };
                     const v = null !== (n = l.get("symbolOpacity")) && void 0 !== n ? n : h.legend.symbolOpacity,
                         y = null !== (i = l.get("symbolFillColor")) && void 0 !== i ? i : h.legend.symbolFillColor,
                         b = null !== (r = l.get("symbolStrokeColor")) && void 0 !== r ? r : h.legend.symbolStrokeColor,
-                        x = void 0 === v ? null !== (o = kd(d.opacity)) && void 0 !== o ? o : f.opacity : void 0;
+                        x = void 0 === v ? null !== (o = Od(d.opacity)) && void 0 !== o ? o : f.opacity : void 0;
                     if (g.fill) {
                         var _;
                         if ("fill" === c || m && c === oe) delete g.fill;
                         else if (g.fill.field)
                             if (y) delete g.fill;
                             else g.fill = yi(null !== (_ = h.legend.symbolBaseFillColor) && void 0 !== _ ? _ : "black"), g.fillOpacity = yi(null !== x && void 0 !== x ? x : 1);
                         else if ((0, U.kJ)(g.fill)) {
                             var w, k, E;
-                            const t = null !== (w = null !== (k = Ed(null !== (E = d.fill) && void 0 !== E ? E : d.color)) && void 0 !== k ? k : f.fill) && void 0 !== w ? w : m && f.color;
+                            const t = null !== (w = null !== (k = Td(null !== (E = d.fill) && void 0 !== E ? E : d.color)) && void 0 !== k ? k : f.fill) && void 0 !== w ? w : m && f.color;
                             t && (g.fill = yi(t))
                         }
                     }
                     if (g.stroke)
                         if ("stroke" === c || !m && c === oe) delete g.stroke;
                         else if (g.stroke.field || b) delete g.stroke;
                     else if ((0, U.kJ)(g.stroke)) {
-                        const t = zt(Ed(d.stroke || d.color), f.stroke, m ? f.color : void 0);
+                        const t = Rt(Td(d.stroke || d.color), f.stroke, m ? f.color : void 0);
                         t && (g.stroke = {
                             value: t
                         })
                     }
                     if (c !== fe) {
-                        const t = Na(a) && Ad(s, l, a);
+                        const t = Ba(a) && Rd(s, l, a);
                         t ? g.opacity = [{
                             test: t,
                             ...yi(null !== x && void 0 !== x ? x : 1)
                         }, yi(h.legend.unselectedOpacity)] : x && (g.opacity = yi(x))
                     }
                     return g = {
                         ...g,
@@ -9848,15 +9963,15 @@
                     if ("gradient" !== r) return;
                     const {
                         config: a,
                         markDef: s,
                         encoding: c
                     } = i;
                     let l = {};
-                    const u = void 0 === (null !== (n = o.get("gradientOpacity")) && void 0 !== n ? n : a.legend.gradientOpacity) ? kd(c.opacity) || s.opacity : void 0;
+                    const u = void 0 === (null !== (n = o.get("gradientOpacity")) && void 0 !== n ? n : a.legend.gradientOpacity) ? Od(c.opacity) || s.opacity : void 0;
                     u && (l.opacity = yi(u));
                     return l = {
                         ...l,
                         ...t
                     }, yt(l) ? void 0 : l
                 },
                 labels: function(t, e) {
@@ -9864,39 +9979,39 @@
                         fieldOrDatumDef: n,
                         model: i,
                         channel: r,
                         legendCmpt: o
                     } = e;
                     const a = i.legend(r) || {},
                         s = i.config,
-                        c = Na(n) ? Ad(i, o, n) : void 0,
+                        c = Ba(n) ? Rd(i, o, n) : void 0,
                         l = c ? [{
                             test: c,
                             value: 1
                         }, {
                             value: s.legend.unselectedOpacity
                         }] : void 0,
                         {
                             format: u,
                             formatType: f
                         } = a;
                     let d;
-                    ia(f) ? d = ca({
+                    ca(f) ? d = ha({
                         fieldOrDatumDef: n,
                         field: "datum.value",
                         format: u,
                         formatType: f,
                         config: s
-                    }) : void 0 === u && void 0 === f && s.customFormatTypes && ("quantitative" === n.type && s.numberFormatType ? d = ca({
+                    }) : void 0 === u && void 0 === f && s.customFormatTypes && ("quantitative" === n.type && s.numberFormatType ? d = ha({
                         fieldOrDatumDef: n,
                         field: "datum.value",
                         format: s.numberFormat,
                         formatType: s.numberFormatType,
                         config: s
-                    }) : "temporal" === n.type && s.timeFormatType && Na(n) && void 0 === n.timeUnit && (d = ca({
+                    }) : "temporal" === n.type && s.timeFormatType && Ba(n) && void 0 === n.timeUnit && (d = ha({
                         fieldOrDatumDef: n,
                         field: "datum.value",
                         format: s.timeFormat,
                         formatType: s.timeFormatType,
                         config: s
                     })));
                     const h = {
@@ -9920,39 +10035,39 @@
                         fill: {
                             value: "transparent"
                         }
                     } : t
                 }
             };
 
-            function kd(t) {
-                return Dd(t, ((t, e) => Math.max(t, e.value)))
+            function Od(t) {
+                return Nd(t, ((t, e) => Math.max(t, e.value)))
             }
 
-            function Ed(t) {
-                return Dd(t, ((t, e) => zt(t, e.value)))
+            function Td(t) {
+                return Nd(t, ((t, e) => Rt(t, e.value)))
             }
 
-            function Dd(t, e) {
+            function Nd(t, e) {
                 return function(t) {
                     const e = null === t || void 0 === t ? void 0 : t.condition;
-                    return !!e && ((0, U.kJ)(e) || Ua(e))
-                }(t) ? (0, U.IX)(t.condition).reduce(e, t.value) : Ua(t) ? t.value : void 0
+                    return !!e && ((0, U.kJ)(e) || Ga(e))
+                }(t) ? (0, U.IX)(t.condition).reduce(e, t.value) : Ga(t) ? t.value : void 0
             }
 
-            function Ad(t, e, n) {
+            function Rd(t, e, n) {
                 const i = e.get("selections");
                 if (null === i || void 0 === i || !i.length) return;
                 const r = (0, U.m8)(n.field);
                 return i.map((t => {
-                    const e = (0, U.m8)(kt(t) + _f);
+                    const e = (0, U.m8)(kt(t) + Mf);
                     return "(!length(data(".concat(e, ")) || (").concat(t, "[").concat(r, "] && indexof(").concat(t, "[").concat(r, "], datum.value) >= 0))")
                 })).join(" || ")
             }
-            const Sd = {
+            const zd = {
                 direction: t => {
                     let {
                         direction: e
                     } = t;
                     return e
                 },
                 format: t => {
@@ -9961,26 +10076,26 @@
                         legend: n,
                         config: i
                     } = t;
                     const {
                         format: r,
                         formatType: o
                     } = n;
-                    return la(e, e.type, r, o, i, !1)
+                    return pa(e, e.type, r, o, i, !1)
                 },
                 formatType: t => {
                     let {
                         legend: e,
                         fieldOrDatumDef: n,
                         scaleType: i
                     } = t;
                     const {
                         formatType: r
                     } = e;
-                    return ua(r, n, i)
+                    return ma(r, n, i)
                 },
                 gradientLength: t => {
                     var e, n;
                     const {
                         legend: i,
                         legendConfig: r
                     } = t;
@@ -9994,15 +10109,15 @@
                         } = t;
                         const {
                             gradientHorizontalMaxLength: a,
                             gradientHorizontalMinLength: s,
                             gradientVerticalMaxLength: c,
                             gradientVerticalMinLength: l
                         } = e;
-                        if (lo(o)) return "horizontal" === i ? "top" === r || "bottom" === r ? Md(n, "width", s, a) : s : Md(n, "height", l, c);
+                        if (mo(o)) return "horizontal" === i ? "top" === r || "bottom" === r ? Bd(n, "width", s, a) : s : Bd(n, "height", l, c);
                         return
                     }(t)
                 },
                 labelOverlap: t => {
                     var e, n;
                     let {
                         legend: i,
@@ -10021,15 +10136,15 @@
                         markDef: i,
                         channel: r,
                         encoding: o
                     } = t;
                     return null !== (e = n.symbolType) && void 0 !== e ? e : function(t, e, n, i) {
                         if ("shape" !== e) {
                             var r;
-                            const t = null !== (r = Ed(n)) && void 0 !== r ? r : i;
+                            const t = null !== (r = Td(n)) && void 0 !== r ? r : i;
                             if (t) return t
                         }
                         switch (t) {
                             case "bar":
                             case "rect":
                             case "image":
                             case "square":
@@ -10050,62 +10165,62 @@
                     }(i.type, r, o.shape, i.shape)
                 },
                 title: t => {
                     let {
                         fieldOrDatumDef: e,
                         config: n
                     } = t;
-                    return Ka(e, n, {
+                    return is(e, n, {
                         allowDisabling: !0
                     })
                 },
                 type: t => {
                     let {
                         legendType: e,
                         scaleType: n,
                         channel: i
                     } = t;
-                    if (Oe(i) && lo(n)) {
+                    if (Oe(i) && mo(n)) {
                         if ("gradient" === e) return
                     } else if ("symbol" === e) return;
                     return e
                 },
                 values: t => {
                     let {
                         fieldOrDatumDef: e,
                         legend: n
                     } = t;
                     return function(t, e) {
                         const n = t.values;
-                        if ((0, U.kJ)(n)) return fs(e, n);
+                        if ((0, U.kJ)(n)) return gs(e, n);
                         if (li(n)) return n;
                         return
                     }(n, e)
                 }
             };
 
-            function Cd(t) {
+            function Pd(t) {
                 const {
                     legend: e
                 } = t;
-                return zt(e.type, function(t) {
+                return Rt(e.type, function(t) {
                     let {
                         channel: e,
                         timeUnit: n,
                         scaleType: i
                     } = t;
                     if (Oe(e)) {
                         if (st(["quarter", "month", "day"], n)) return "symbol";
-                        if (lo(i)) return "gradient"
+                        if (mo(i)) return "gradient"
                     }
                     return "symbol"
                 }(t))
             }
 
-            function Fd(t) {
+            function Ld(t) {
                 var e, n;
                 let {
                     legendConfig: i,
                     legendType: r,
                     orient: o,
                     legend: a
                 } = t;
@@ -10121,67 +10236,67 @@
                             return;
                         default:
                             return "gradient" === e ? "horizontal" : void 0
                     }
                 }(o, r)
             }
 
-            function Md(t, e, n, i) {
+            function Bd(t, e, n, i) {
                 const r = t.getSizeSignalRef(e).signal;
                 return {
                     signal: "clamp(".concat(r, ", ").concat(n, ", ").concat(i, ")")
                 }
             }
 
-            function Od(t) {
-                const e = fp(t) ? function(t) {
+            function Id(t) {
+                const e = bp(t) ? function(t) {
                     const {
                         encoding: e
                     } = t, n = {};
-                    for (const i of [oe, ...sc]) {
-                        const r = is(e[i]);
-                        r && t.getScaleComponent(i) && (i === ce && Na(r) && r.type === Zr || (n[i] = Nd(t, i)))
+                    for (const i of [oe, ...dc]) {
+                        const r = cs(e[i]);
+                        r && t.getScaleComponent(i) && (i === ce && Ba(r) && r.type === to || (n[i] = Ud(t, i)))
                     }
                     return n
                 }(t) : function(t) {
                     const {
                         legends: e,
                         resolve: n
                     } = t.component;
                     for (const i of t.children) {
-                        Od(i);
-                        for (const r of bt(i.component.legends)) n.legend[r] = yd(t.component.resolve, r), "shared" === n.legend[r] && (e[r] = zd(e[r], i.component.legends[r]), e[r] || (n.legend[r] = "independent", delete e[r]))
+                        Id(i);
+                        for (const r of bt(i.component.legends)) n.legend[r] = Dd(t.component.resolve, r), "shared" === n.legend[r] && (e[r] = qd(e[r], i.component.legends[r]), e[r] || (n.legend[r] = "independent", delete e[r]))
                     }
                     for (const i of bt(e))
                         for (const e of t.children) e.component.legends[i] && "shared" === n.legend[i] && delete e.component.legends[i];
                     return e
                 }(t);
                 return t.component.legends = e, e
             }
 
-            function Td(t, e, n, i) {
+            function jd(t, e, n, i) {
                 switch (e) {
                     case "disable":
                         return void 0 !== n;
                     case "values":
                         return !(null === n || void 0 === n || !n.values);
                     case "title":
                         if ("title" === e && t === (null === i || void 0 === i ? void 0 : i.title)) return !0
                 }
                 return t === (n || {})[e]
             }
 
-            function Nd(t, e) {
+            function Ud(t, e) {
                 var n, i, r;
                 let o = t.legend(e);
                 const {
                     markDef: a,
                     encoding: s,
                     config: c
-                } = t, l = c.legend, u = new _d({}, function(t, e) {
+                } = t, l = c.legend, u = new Md({}, function(t, e) {
                     const n = t.scaleName(e);
                     if ("trail" === t.mark) {
                         if ("color" === e) return {
                             stroke: n
                         };
                         if ("size" === e) return {
                             strokeWidth: n
@@ -10197,29 +10312,29 @@
                 }(t, e));
                 ! function(t, e, n) {
                     var i;
                     const r = null === (i = t.fieldDef(e)) || void 0 === i ? void 0 : i.field;
                     for (const c of xt(null !== (o = t.component.selection) && void 0 !== o ? o : {})) {
                         var o, a;
                         const t = null !== (a = c.project.hasField[r]) && void 0 !== a ? a : c.project.hasChannel[e];
-                        if (t && df.defined(c)) {
+                        if (t && xf.defined(c)) {
                             var s;
                             const e = null !== (s = n.get("selections")) && void 0 !== s ? s : [];
                             e.push(c.name), n.set("selections", e, !1), t.hasLegend = !0
                         }
                     }
                 }(t, e, u);
                 const f = void 0 !== o ? !o : l.disable;
                 if (u.set("disable", f, void 0 !== o), f) return u;
                 o = o || {};
                 const d = t.getScaleComponent(e).get("type"),
-                    h = is(s[e]),
-                    p = Na(h) ? null === (n = Cr(h.timeUnit)) || void 0 === n ? void 0 : n.unit : void 0,
+                    h = cs(s[e]),
+                    p = Ba(h) ? null === (n = Or(h.timeUnit)) || void 0 === n ? void 0 : n.unit : void 0,
                     m = o.orient || c.legend.orient || "right",
-                    g = Cd({
+                    g = Pd({
                         legend: o,
                         channel: e,
                         timeUnit: p,
                         scaleType: d
                     }),
                     v = {
                         legend: o,
@@ -10229,26 +10344,26 @@
                         encoding: s,
                         fieldOrDatumDef: h,
                         legendConfig: l,
                         config: c,
                         scaleType: d,
                         orient: m,
                         legendType: g,
-                        direction: Fd({
+                        direction: Ld({
                             legend: o,
                             legendType: g,
                             orient: m,
                             legendConfig: l
                         })
                     };
-                for (const E of xd) {
+                for (const E of Cd) {
                     if ("gradient" === g && E.startsWith("symbol") || "symbol" === g && E.startsWith("gradient")) continue;
-                    const n = E in Sd ? Sd[E](v) : o[E];
+                    const n = E in zd ? zd[E](v) : o[E];
                     if (void 0 !== n) {
-                        const i = Td(n, E, o, t.fieldDef(e));
+                        const i = jd(n, E, o, t.fieldDef(e));
                         (i || void 0 === c.legend[E]) && u.set(E, n, i)
                     }
                 }
                 const y = null !== (i = null === (r = o) || void 0 === r ? void 0 : r.encoding) && void 0 !== i ? i : {},
                     b = u.get("selections"),
                     x = {},
                     _ = {
@@ -10256,69 +10371,69 @@
                         model: t,
                         channel: e,
                         legendCmpt: u,
                         legendType: g
                     };
                 for (const E of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
                     var w;
-                    const e = gd(null !== (w = y[E]) && void 0 !== w ? w : {}, t),
-                        n = E in wd ? wd[E](e, _) : e;
+                    const e = Ed(null !== (w = y[E]) && void 0 !== w ? w : {}, t),
+                        n = E in Fd ? Fd[E](e, _) : e;
                     void 0 === n || yt(n) || (x[E] = {
-                        ...null !== b && void 0 !== b && b.length && Na(h) ? {
+                        ...null !== b && void 0 !== b && b.length && Ba(h) ? {
                             name: "".concat(kt(h.field), "_legend_").concat(E)
                         } : {},
                         ...null !== b && void 0 !== b && b.length ? {
                             interactive: !!b
                         } : {},
                         update: n
                     })
                 }
                 var k;
                 yt(x) || u.set("encode", x, !(null === (k = o) || void 0 === k || !k.encoding));
                 return u
             }
 
-            function zd(t, e) {
+            function qd(t, e) {
                 if (!t) return e.clone();
                 const n = t.getWithExplicit("orient"),
                     i = e.getWithExplicit("orient");
                 if (n.explicit && i.explicit && n.value !== i.value) return;
                 let r = !1;
-                for (const l of xd) {
-                    const n = Hl(t.getWithExplicit(l), e.getWithExplicit(l), l, "legend", ((t, e) => {
+                for (const l of Cd) {
+                    const n = Yl(t.getWithExplicit(l), e.getWithExplicit(l), l, "legend", ((t, e) => {
                         switch (l) {
                             case "symbolType":
-                                return Rd(t, e);
+                                return Wd(t, e);
                             case "title":
-                                return Mi(t, e);
+                                return Fi(t, e);
                             case "type":
-                                return r = !0, Ul("symbol")
+                                return r = !0, Jl("symbol")
                         }
-                        return Wl(t, e, l, "legend")
+                        return $l(t, e, l, "legend")
                     }));
                     t.setWithExplicit(l, n)
                 }
                 var o, a, s, c;
-                r && (null !== (o = t.implicit) && void 0 !== o && null !== (a = o.encode) && void 0 !== a && a.gradient && Dt(t.implicit, ["encode", "gradient"]), null !== (s = t.explicit) && void 0 !== s && null !== (c = s.encode) && void 0 !== c && c.gradient && Dt(t.explicit, ["encode", "gradient"]));
+                r && (null !== (o = t.implicit) && void 0 !== o && null !== (a = o.encode) && void 0 !== a && a.gradient && At(t.implicit, ["encode", "gradient"]), null !== (s = t.explicit) && void 0 !== s && null !== (c = s.encode) && void 0 !== c && c.gradient && At(t.explicit, ["encode", "gradient"]));
                 return t
             }
 
-            function Rd(t, e) {
+            function Wd(t, e) {
                 return "circle" === e.value ? e : t
             }
 
-            function Pd(t) {
+            function Hd(t) {
                 const e = t.component.legends,
                     n = {};
                 for (const i of bt(e)) {
                     const r = t.getScaleComponent(i),
                         o = rt(r.get("domains"));
                     if (n[o])
                         for (const t of n[o]) {
-                            zd(t, e[i]) || n[o].push(e[i])
+                            qd(t, e[i]) || n[o].push(e[i])
                         } else n[o] = [e[i].clone()]
                 }
                 return xt(n).flat().map((e => function(t, e) {
                     var n;
                     const {
                         disable: i,
                         labelExpr: r,
@@ -10328,15 +10443,15 @@
                     if (i) return;
                     !1 === e.aria && void 0 == a.aria && (a.aria = !1);
                     if (null !== (n = a.encode) && void 0 !== n && n.symbols) {
                         const t = a.encode.symbols.update;
                         !t.fill || "transparent" === t.fill.value || t.stroke || a.stroke || (t.stroke = {
                             value: "transparent"
                         });
-                        for (const e of sc) a[e] && delete t[e]
+                        for (const e of dc) a[e] && delete t[e]
                     }
                     a.title || delete a.title;
                     if (void 0 !== r) {
                         var s, c;
                         let t = r;
                         null !== (s = a.encode) && void 0 !== s && null !== (c = s.labels) && void 0 !== c && c.update && li(a.encode.labels.update.text) && (t = Ot(r, "datum.label", a.encode.labels.update.text.signal)),
                             function(t, e, n, i) {
@@ -10346,21 +10461,21 @@
                                 signal: t
                             })
                     }
                     return a
                 }(e, t.config))).filter((t => void 0 !== t))
             }
 
-            function Ld(t) {
-                return pp(t) || hp(t) ? function(t) {
-                    return t.children.reduce(((t, e) => t.concat(e.assembleProjections())), jd(t))
-                }(t) : jd(t)
+            function Xd(t) {
+                return wp(t) || _p(t) ? function(t) {
+                    return t.children.reduce(((t, e) => t.concat(e.assembleProjections())), Gd(t))
+                }(t) : Gd(t)
             }
 
-            function jd(t) {
+            function Gd(t) {
                 const e = t.component.projection;
                 if (!e || e.merged) return [];
                 const n = e.combine(),
                     {
                         name: i
                     } = n;
                 if (e.data) {
@@ -10385,69 +10500,69 @@
                     name: i,
                     translate: {
                         signal: "[width / 2, height / 2]"
                     },
                     ...n
                 }]
             }
-            const Bd = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
-            class Id extends Bl {
+            const Jd = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
+            class Zd extends Xl {
                 constructor(t, e, n, i) {
                     super({
                         ...e
                     }, {
                         name: t
                     }), this.specifiedProjection = e, this.size = n, this.data = i, this.merged = !1
                 }
                 get isFit() {
                     return !!this.data
                 }
             }
 
-            function Ud(t) {
-                t.component.projection = fp(t) ? function(t) {
+            function $d(t) {
+                t.component.projection = bp(t) ? function(t) {
                     if (t.hasProjection) {
                         var e;
                         const n = ai(t.specifiedProjection),
                             i = !(n && (null != n.scale || null != n.translate)),
                             r = i ? [t.getSizeSignalRef("width"), t.getSizeSignalRef("height")] : void 0,
                             o = i ? function(t) {
                                 const e = [],
                                     {
                                         encoding: n
                                     } = t;
                                 for (const i of [
                                         [ne, ee],
                                         [re, ie]
-                                    ])(is(n[i[0]]) || is(n[i[1]])) && e.push({
+                                    ])(cs(n[i[0]]) || cs(n[i[1]])) && e.push({
                                     signal: t.getName("geojson_".concat(e.length))
                                 });
-                                t.channelHasField(ce) && t.typedFieldDef(ce).type === Zr && e.push({
+                                t.channelHasField(ce) && t.typedFieldDef(ce).type === to && e.push({
                                     signal: t.getName("geojson_".concat(e.length))
                                 });
-                                0 === e.length && e.push(t.requestDataName(Ql.Main));
+                                0 === e.length && e.push(t.requestDataName(ou.Main));
                                 return e
                             }(t) : void 0,
-                            a = new Id(t.projectionName(!0), {
+                            a = new Zd(t.projectionName(!0), {
                                 ...null !== (e = ai(t.config.projection)) && void 0 !== e ? e : {},
                                 ...null !== n && void 0 !== n ? n : {}
                             }, r, o);
                         return a.get("type") || a.set("type", "equalEarth", !1), a
                     }
                     return
                 }(t) : function(t) {
                     if (0 === t.children.length) return;
                     let e;
-                    for (const i of t.children) Ud(i);
+                    for (const i of t.children) $d(i);
                     const n = lt(t.children, (t => {
                         const n = t.component.projection;
                         if (n) {
                             if (e) {
                                 const t = function(t, e) {
-                                    const n = lt(Bd, (n => !(0, U.nr)(t.explicit, n) && !(0, U.nr)(e.explicit, n) || !!((0, U.nr)(t.explicit, n) && (0, U.nr)(e.explicit, n) && Q(t.get(n), e.get(n)))));
+                                    const n = lt(Jd, (n => !(0, U.nr)(t.explicit, n) && !(0, U.nr)(e.explicit, n) || !!((0, U.nr)(t.explicit, n) && (0, U.nr)(e.explicit, n) && Q(t.get(n), e.get(n)))));
                                     if (Q(t.size, e.size)) {
                                         if (n) return t;
                                         if (Q(t.explicit, {})) return e;
                                         if (Q(e.explicit, {})) return t
                                     }
                                     return null
                                 }(e, n);
@@ -10455,83 +10570,83 @@
                             }
                             return e = n, !0
                         }
                         return !0
                     }));
                     if (e && n) {
                         const n = t.projectionName(!0),
-                            i = new Id(n, e.specifiedProjection, e.size, tt(e.data));
+                            i = new Zd(n, e.specifiedProjection, e.size, tt(e.data));
                         for (const e of t.children) {
                             const t = e.component.projection;
                             t && (t.isFit && i.data.push(...e.component.projection.data), e.renameProjection(t.get("name"), n), t.merged = !0)
                         }
                         return i
                     }
                     return
                 }(t)
             }
 
-            function qd(t, e, n, i) {
-                if (ds(e, n)) {
+            function Yd(t, e, n, i) {
+                if (vs(e, n)) {
                     var r, o;
-                    const a = fp(t) && null !== (r = null !== (o = t.axis(n)) && void 0 !== o ? o : t.legend(n)) && void 0 !== r ? r : {},
-                        s = Ga(e, {
+                    const a = bp(t) && null !== (r = null !== (o = t.axis(n)) && void 0 !== o ? o : t.legend(n)) && void 0 !== r ? r : {},
+                        s = Ka(e, {
                             expr: "datum"
                         }),
-                        c = Ga(e, {
+                        c = Ka(e, {
                             expr: "datum",
                             binSuffix: "end"
                         });
                     return {
-                        formulaAs: Ga(e, {
+                        formulaAs: Ka(e, {
                             binSuffix: "range",
                             forAs: !0
                         }),
-                        formula: pa(s, c, a.format, a.formatType, i)
+                        formula: ba(s, c, a.format, a.formatType, i)
                     }
                 }
                 return {}
             }
 
-            function Wd(t, e) {
+            function Vd(t, e) {
                 return "".concat(Qn(t), "_").concat(e)
             }
 
-            function Hd(t, e, n) {
+            function Kd(t, e, n) {
                 var i;
-                const r = Wd(null !== (i = ss(n, void 0)) && void 0 !== i ? i : {}, e);
+                const r = Vd(null !== (i = ds(n, void 0)) && void 0 !== i ? i : {}, e);
                 return t.getName("".concat(r, "_bins"))
             }
 
-            function Xd(t, e, n) {
+            function Qd(t, e, n) {
                 let i, r;
                 i = function(t) {
                     return "as" in t
-                }(t) ? (0, U.HD)(t.as) ? [t.as, "".concat(t.as, "_end")] : [t.as[0], t.as[1]] : [Ga(t, {
+                }(t) ? (0, U.HD)(t.as) ? [t.as, "".concat(t.as, "_end")] : [t.as[0], t.as[1]] : [Ka(t, {
                     forAs: !0
-                }), Ga(t, {
+                }), Ka(t, {
                     binSuffix: "end",
                     forAs: !0
                 })];
                 const o = {
-                        ...ss(e, void 0)
+                        ...ds(e, void 0)
                     },
-                    a = Wd(o, t.field),
+                    a = Vd(o, t.field),
                     {
                         signal: s,
                         extentSignal: c
                     } = function(t, e) {
                         return {
                             signal: t.getName("".concat(e, "_bins")),
                             extentSignal: t.getName("".concat(e, "_extent"))
                         }
                     }(n, a);
                 if (ii(o.extent)) {
                     const t = o.extent;
-                    r = Rf(n, t.param, t), delete o.extent
+                    r = Wf(n, t.param, t), delete o.extent
                 }
                 return {
                     key: a,
                     binComponent: {
                         bin: o,
                         field: t.field,
                         as: [i],
@@ -10543,44 +10658,44 @@
                         } : {},
                         ...r ? {
                             span: r
                         } : {}
                     }
                 }
             }
-            class Jd extends su {
+            class th extends hu {
                 clone() {
-                    return new Jd(null, tt(this.bins))
+                    return new th(null, tt(this.bins))
                 }
                 constructor(t, e) {
                     super(t), this.bins = e
                 }
                 static makeFromEncoding(t, e) {
                     const n = e.reduceFieldDef(((t, n, i) => {
-                        if (Ia(n) && ti(n.bin)) {
+                        if (Xa(n) && ti(n.bin)) {
                             const {
                                 key: r,
                                 binComponent: o
-                            } = Xd(n, n.bin, e);
+                            } = Qd(n, n.bin, e);
                             t[r] = {
                                 ...o,
                                 ...t[r],
-                                ...qd(e, n, i, e.config)
+                                ...Yd(e, n, i, e.config)
                             }
                         }
                         return t
                     }), {});
-                    return yt(n) ? null : new Jd(t, n)
+                    return yt(n) ? null : new th(t, n)
                 }
                 static makeFromTransform(t, e, n) {
                     const {
                         key: i,
                         binComponent: r
-                    } = Xd(e, e.bin, n);
-                    return new Jd(t, {
+                    } = Qd(e, e.bin, n);
+                    return new th(t, {
                         [i]: r
                     })
                 }
                 merge(t, e) {
                     for (const n of bt(t.bins)) n in this.bins ? (e(t.bins[n].signal, this.bins[n].signal), this.bins[n].as = dt([...this.bins[n].as, ...t.bins[n].as], ot)) : this.bins[n] = t.bins[n];
                     for (const n of t.children) t.removeChild(n), n.parent = this;
                     t.remove()
@@ -10600,15 +10715,15 @@
                             [n, ...i] = t.as,
                             {
                                 extent: r,
                                 ...o
                             } = t.bin,
                             a = {
                                 type: "bin",
-                                field: Mt(t.field),
+                                field: Ft(t.field),
                                 as: n,
                                 signal: t.signal,
                                 ...ii(r) ? {
                                     extent: null
                                 } : {
                                     extent: r
                                 },
@@ -10617,23 +10732,23 @@
                                         signal: "span(".concat(t.span, ")")
                                     }
                                 } : {},
                                 ...o
                             };
                         !r && t.extentSignal && (e.push({
                             type: "extent",
-                            field: Mt(t.field),
+                            field: Ft(t.field),
                             signal: t.extentSignal
                         }), a.extent = {
                             signal: t.extentSignal
                         }), e.push(a);
                         for (const s of i)
                             for (let t = 0; t < 2; t++) e.push({
                                 type: "formula",
-                                expr: Ga({
+                                expr: Ka({
                                     field: n[t]
                                 }, {
                                     expr: "datum"
                                 }),
                                 as: s[t]
                             });
                         return t.formula && e.push({
@@ -10641,33 +10756,33 @@
                             expr: t.formula,
                             as: t.formulaAs
                         }), e
                     }))
                 }
             }
 
-            function Gd(t, e, n, i) {
+            function eh(t, e, n, i) {
                 var r;
-                const o = fp(i) ? i.encoding[Ze(e)] : void 0;
-                if (Ia(n) && fp(i) && Ca(n, o, i.markDef, i.config)) t.add(Ga(n, {})), t.add(Ga(n, {
+                const o = bp(i) ? i.encoding[$e(e)] : void 0;
+                if (Xa(n) && bp(i) && Na(n, o, i.markDef, i.config)) t.add(Ka(n, {})), t.add(Ka(n, {
                     suffix: "end"
-                })), n.bin && ds(n, e) && t.add(Ga(n, {
+                })), n.bin && vs(n, e) && t.add(Ka(n, {
                     binSuffix: "range"
                 }));
                 else if (Ce(e)) {
                     const n = Se(e);
                     t.add(i.getName(n))
-                } else t.add(Ga(n));
-                return qa(n) && function(t) {
-                    return (0, B.isObject)(t) && "field" in t
+                } else t.add(Ka(n));
+                return Ja(n) && function(t) {
+                    return (0, I.isObject)(t) && "field" in t
                 }(null === (r = n.scale) || void 0 === r ? void 0 : r.range) && t.add(n.scale.range.field), t
             }
-            class $d extends su {
+            class nh extends hu {
                 clone() {
-                    return new $d(null, new Set(this.dimensions), tt(this.measures))
+                    return new nh(null, new Set(this.dimensions), tt(this.measures))
                 }
                 constructor(t, e, n) {
                     super(t), this.dimensions = e, this.measures = n
                 }
                 get groupBy() {
                     return this.dimensions
                 }
@@ -10682,73 +10797,73 @@
                         const {
                             aggregate: o,
                             field: a
                         } = t;
                         if (o)
                             if ("count" === o) {
                                 var s;
-                                null !== (s = i["*"]) && void 0 !== s || (i["*"] = {}), i["*"].count = new Set([Ga(t, {
+                                null !== (s = i["*"]) && void 0 !== s || (i["*"] = {}), i["*"].count = new Set([Ka(t, {
                                     forAs: !0
                                 })])
                             } else {
-                                if (Jn(o) || Gn(o)) {
+                                if (Gn(o) || Jn(o)) {
                                     var c;
-                                    const t = Jn(o) ? "argmin" : "argmax",
+                                    const t = Gn(o) ? "argmin" : "argmax",
                                         e = o[t];
-                                    null !== (c = i[e]) && void 0 !== c || (i[e] = {}), i[e][t] = new Set([Ga({
+                                    null !== (c = i[e]) && void 0 !== c || (i[e] = {}), i[e][t] = new Set([Ka({
                                         op: t,
                                         field: e
                                     }, {
                                         forAs: !0
                                     })])
                                 } else {
                                     var l;
-                                    null !== (l = i[a]) && void 0 !== l || (i[a] = {}), i[a][o] = new Set([Ga(t, {
+                                    null !== (l = i[a]) && void 0 !== l || (i[a] = {}), i[a][o] = new Set([Ka(t, {
                                         forAs: !0
                                     })])
                                 }
                                 var u;
-                                if (jn(n) && "unaggregated" === e.scaleDomain(n)) null !== (u = i[a]) && void 0 !== u || (i[a] = {}), i[a].min = new Set([Ga({
+                                if (Bn(n) && "unaggregated" === e.scaleDomain(n)) null !== (u = i[a]) && void 0 !== u || (i[a] = {}), i[a].min = new Set([Ka({
                                     field: a,
                                     aggregate: "min"
                                 }, {
                                     forAs: !0
-                                })]), i[a].max = new Set([Ga({
+                                })]), i[a].max = new Set([Ka({
                                     field: a,
                                     aggregate: "max"
                                 }, {
                                     forAs: !0
                                 })])
                             }
-                        else Gd(r, n, t, e)
-                    })), r.size + bt(i).length === 0 ? null : new $d(t, r, i)) : null
+                        else eh(r, n, t, e)
+                    })), r.size + bt(i).length === 0 ? null : new nh(t, r, i)) : null
                 }
                 static makeFromTransform(t, e) {
                     const n = new Set,
                         i = {};
                     for (const s of e.aggregate) {
                         const {
                             op: t,
                             field: e,
                             as: n
                         } = s;
                         var r, o;
                         if (t)
-                            if ("count" === t) null !== (r = i["*"]) && void 0 !== r || (i["*"] = {}), i["*"].count = new Set([n || Ga(s, {
+                            if ("count" === t) null !== (r = i["*"]) && void 0 !== r || (i["*"] = {}), i["*"].count = new Set([n || Ka(s, {
                                 forAs: !0
                             })]);
-                            else null !== (o = i[e]) && void 0 !== o || (i[e] = {}), i[e][t] = new Set([n || Ga(s, {
+                            else null !== (o = i[e]) && void 0 !== o || (i[e] = {}), i[e][t] = new Set([n || Ka(s, {
                                 forAs: !0
                             })])
                     }
                     for (const s of null !== (a = e.groupby) && void 0 !== a ? a : []) {
                         var a;
                         n.add(s)
                     }
-                    return n.size + bt(i).length === 0 ? null : new $d(t, n, i)
+                    return n.size + bt(i).length === 0 ? null : new nh(t, n, i)
                 }
                 merge(t) {
                     return pt(this.dimensions, t.dimensions) ? (function(t, e) {
                         for (const i of bt(e)) {
                             const r = e[i];
                             for (const e of bt(r)) {
                                 var n;
@@ -10784,43 +10899,43 @@
                 }
                 assemble() {
                     const t = [],
                         e = [],
                         n = [];
                     for (const i of bt(this.measures))
                         for (const r of bt(this.measures[i]))
-                            for (const o of this.measures[i][r]) n.push(o), t.push(r), e.push("*" === i ? null : Mt(i));
+                            for (const o of this.measures[i][r]) n.push(o), t.push(r), e.push("*" === i ? null : Ft(i));
                     return {
                         type: "aggregate",
-                        groupby: [...this.dimensions].map(Mt),
+                        groupby: [...this.dimensions].map(Ft),
                         ops: t,
                         fields: e,
                         as: n
                     }
                 }
             }
-            class Zd extends su {
+            class ih extends hu {
                 constructor(t, e, n, i) {
                     super(t), this.model = e, this.name = n, this.data = i;
                     for (const r of Ne) {
                         const t = e.facet[r];
                         if (t) {
                             const {
                                 bin: n,
                                 sort: i
                             } = t;
                             this[r] = {
                                 name: e.getName("".concat(r, "_domain")),
-                                fields: [Ga(t), ...ti(n) ? [Ga(t, {
+                                fields: [Ka(t), ...ti(n) ? [Ka(t, {
                                     binSuffix: "end"
                                 })] : []],
-                                ...ba(i) ? {
+                                ...Ea(i) ? {
                                     sortField: i
                                 } : (0, U.kJ)(i) ? {
-                                    sortIndexField: Zf(t, r)
+                                    sortIndexField: id(t, r)
                                 } : {}
                             }
                         }
                     }
                     this.childModel = e.child
                 }
                 hash() {
@@ -10850,16 +10965,16 @@
                 getChildIndependentFieldsWithStep() {
                     const t = {};
                     for (const e of bn) {
                         const n = this.childModel.component.scales[e];
                         if (n && !n.merged) {
                             const i = n.get("type"),
                                 r = n.get("range");
-                            if (so(i) && ui(r)) {
-                                const n = qh(Wh(this.childModel, e));
+                            if (ho(i) && ui(r)) {
+                                const n = Yh(Vh(this.childModel, e));
                                 n ? t[e] = n : dr(Pi(e))
                             }
                         }
                     }
                     return t
                 }
                 assembleRowColumnHeaderData(t, e, n) {
@@ -10874,18 +10989,18 @@
                     i && n && n[i] && (e ? (r.push("distinct_".concat(n[i])), o.push("max")) : (r.push(n[i]), o.push("distinct")), a.push("distinct_".concat(n[i])));
                     const {
                         sortField: s,
                         sortIndexField: c
                     } = this[t];
                     if (s) {
                         const {
-                            op: t = ma,
+                            op: t = xa,
                             field: e
                         } = s;
-                        r.push(e), o.push(t), a.push(Ga(s, {
+                        r.push(e), o.push(t), a.push(Ka(s, {
                             forAs: !0
                         }))
                     } else c && (r.push(c), o.push("max"), a.push(c));
                     return {
                         name: this[t].name,
                         source: null !== e && void 0 !== e ? e : this.data,
                         transform: [{
@@ -10901,16 +11016,16 @@
                 }
                 assembleFacetHeaderData(t) {
                     const {
                         columns: e
                     } = this.model.layout, {
                         layoutHeaders: n
                     } = this.model.component, i = [], r = {};
-                    for (const l of Qf) {
-                        for (const t of td) {
+                    for (const l of sd) {
+                        for (const t of cd) {
                             var o;
                             const e = null !== (o = n[l] && n[l][t]) && void 0 !== o ? o : [];
                             for (const t of e) {
                                 var a;
                                 if ((null === (a = t.axes) || void 0 === a ? void 0 : a.length) > 0) {
                                     r[l] = !0;
                                     break
@@ -10972,101 +11087,101 @@
                         const e = this.assembleFacetHeaderData(n);
                         e && t.push(...e)
                     }
                     return t
                 }
             }
 
-            function Yd(t) {
+            function rh(t) {
                 return t.startsWith("'") && t.endsWith("'") || t.startsWith('"') && t.endsWith('"') ? t.slice(1, -1) : t
             }
 
-            function Vd(t) {
+            function oh(t) {
                 const e = {};
                 return V(t.filter, (t => {
-                    if (Lr(t)) {
+                    if (qr(t)) {
                         let i = null;
-                        if (Mr(t)) i = gi(t.equal);
-                        else if (Tr(t)) i = gi(t.lte);
-                        else if (Or(t)) i = gi(t.lt);
-                        else if (Nr(t)) i = gi(t.gt);
-                        else if (zr(t)) i = gi(t.gte);
-                        else if (Rr(t)) i = t.range[0];
-                        else if (Pr(t)) {
+                        if (zr(t)) i = gi(t.equal);
+                        else if (Lr(t)) i = gi(t.lte);
+                        else if (Pr(t)) i = gi(t.lt);
+                        else if (Br(t)) i = gi(t.gt);
+                        else if (Ir(t)) i = gi(t.gte);
+                        else if (jr(t)) i = t.range[0];
+                        else if (Ur(t)) {
                             var n;
                             i = (null !== (n = t.oneOf) && void 0 !== n ? n : t.in)[0]
                         }
                         i && (hr(i) ? e[t.field] = "date" : (0, U.hj)(i) ? e[t.field] = "number" : (0, U.HD)(i) && (e[t.field] = "string")), t.timeUnit && (e[t.field] = "date")
                     }
                 })), e
             }
 
-            function Kd(t) {
+            function ah(t) {
                 const e = {};
 
                 function n(t) {
                     var n;
-                    ls(t) ? e[t.field] = "date" : "quantitative" === t.type && (n = t.aggregate, (0, U.HD)(n) && st(["min", "max"], n)) ? e[t.field] = "number" : Nt(t.field) > 1 ? t.field in e || (e[t.field] = "flatten") : qa(t) && ba(t.sort) && Nt(t.sort.field) > 1 && (t.sort.field in e || (e[t.sort.field] = "flatten"))
+                    ps(t) ? e[t.field] = "date" : "quantitative" === t.type && (n = t.aggregate, (0, U.HD)(n) && st(["min", "max"], n)) ? e[t.field] = "number" : Nt(t.field) > 1 ? t.field in e || (e[t.field] = "flatten") : Ja(t) && Ea(t.sort) && Nt(t.sort.field) > 1 && (t.sort.field in e || (e[t.sort.field] = "flatten"))
                 }
-                if ((fp(t) || dp(t)) && t.forEachFieldDef(((e, i) => {
-                        if (Ia(e)) n(e);
+                if ((bp(t) || xp(t)) && t.forEachFieldDef(((e, i) => {
+                        if (Xa(e)) n(e);
                         else {
-                            const r = Ge(i),
+                            const r = Je(i),
                                 o = t.fieldDef(r);
                             n({
                                 ...e,
                                 type: o.type
                             })
                         }
-                    })), fp(t)) {
+                    })), bp(t)) {
                     const {
                         mark: n,
                         markDef: i,
                         encoding: r
                     } = t;
-                    if (Bo(n) && !t.encoding.order) {
+                    if (Ho(n) && !t.encoding.order) {
                         const t = r["horizontal" === i.orient ? "y" : "x"];
-                        Na(t) && "quantitative" === t.type && !(t.field in e) && (e[t.field] = "number")
+                        Ba(t) && "quantitative" === t.type && !(t.field in e) && (e[t.field] = "number")
                     }
                 }
                 return e
             }
-            class Qd extends su {
+            class sh extends hu {
                 clone() {
-                    return new Qd(null, tt(this._parse))
+                    return new sh(null, tt(this._parse))
                 }
                 constructor(t, e) {
                     super(t), this._parse = e
                 }
                 hash() {
                     return "Parse ".concat(ot(this._parse))
                 }
                 static makeExplicit(t, e, n) {
                     var i;
                     let r = {};
                     const o = e.data;
-                    return !Zl(o) && null !== o && void 0 !== o && null !== (i = o.format) && void 0 !== i && i.parse && (r = o.format.parse), this.makeWithAncestors(t, r, {}, n)
+                    return !eu(o) && null !== o && void 0 !== o && null !== (i = o.format) && void 0 !== i && i.parse && (r = o.format.parse), this.makeWithAncestors(t, r, {}, n)
                 }
                 static makeWithAncestors(t, e, n, i) {
                     for (const a of bt(n)) {
                         const t = i.getWithExplicit(a);
                         void 0 !== t.value && (t.explicit || t.value === n[a] || "derived" === t.value || "flatten" === n[a] ? delete n[a] : dr(qi(a, n[a], t.value)))
                     }
                     for (const a of bt(e)) {
                         const t = i.get(a);
                         void 0 !== t && (t === e[a] ? delete e[a] : dr(qi(a, e[a], t)))
                     }
-                    const r = new Bl(e, n);
+                    const r = new Xl(e, n);
                     i.copyAll(r);
                     const o = {};
                     for (const a of bt(r.combine())) {
                         const t = r.get(a);
                         null !== t && (o[a] = t)
                     }
-                    return 0 === bt(o).length || i.parseNothing ? null : new Qd(t, o)
+                    return 0 === bt(o).length || i.parseNothing ? null : new sh(t, o)
                 }
                 get parse() {
                     return this._parse
                 }
                 merge(t) {
                     this._parse = {
                         ...this._parse,
@@ -11094,58 +11209,58 @@
                             const n = St(t);
                             if ("number" === e) return "toNumber(".concat(n, ")");
                             if ("boolean" === e) return "toBoolean(".concat(n, ")");
                             if ("string" === e) return "toString(".concat(n, ")");
                             if ("date" === e) return "toDate(".concat(n, ")");
                             if ("flatten" === e) return n;
                             if (e.startsWith("date:")) {
-                                const t = Yd(e.slice(5, e.length));
+                                const t = rh(e.slice(5, e.length));
                                 return "timeParse(".concat(n, ",'").concat(t, "')")
                             }
                             if (e.startsWith("utc:")) {
-                                const t = Yd(e.slice(4, e.length));
+                                const t = rh(e.slice(4, e.length));
                                 return "utcParse(".concat(n, ",'").concat(t, "')")
                             }
                             return dr('Unrecognized parse "'.concat(e, '".')), null
                         }(t, this._parse[t]);
                         if (!e) return null;
                         return {
                             type: "formula",
                             expr: e,
                             as: Tt(t)
                         }
                     })).filter((t => null !== t))
                 }
             }
-            class th extends su {
+            class ch extends hu {
                 clone() {
-                    return new th(null)
+                    return new ch(null)
                 }
                 constructor(t) {
                     super(t)
                 }
                 dependentFields() {
                     return new Set
                 }
                 producedFields() {
-                    return new Set([lc])
+                    return new Set([pc])
                 }
                 hash() {
                     return "Identifier"
                 }
                 assemble() {
                     return {
                         type: "identifier",
-                        as: lc
+                        as: pc
                     }
                 }
             }
-            class eh extends su {
+            class lh extends hu {
                 clone() {
-                    return new eh(null, this.params)
+                    return new lh(null, this.params)
                 }
                 constructor(t, e) {
                     super(t), this.params = e
                 }
                 dependentFields() {
                     return new Set
                 }
@@ -11156,17 +11271,17 @@
                 assemble() {
                     return {
                         type: "graticule",
                         ...!0 === this.params ? {} : this.params
                     }
                 }
             }
-            class nh extends su {
+            class uh extends hu {
                 clone() {
-                    return new nh(null, this.params)
+                    return new uh(null, this.params)
                 }
                 constructor(t, e) {
                     super(t), this.params = e
                 }
                 dependentFields() {
                     return new Set
                 }
@@ -11180,38 +11295,38 @@
                 assemble() {
                     return {
                         type: "sequence",
                         ...this.params
                     }
                 }
             }
-            class ih extends su {
+            class fh extends hu {
                 constructor(t) {
                     var e;
                     let n;
                     if (super(null), null !== (e = t) && void 0 !== e || (t = {
                             name: "source"
-                        }), Zl(t) || (n = t.format ? {
+                        }), eu(t) || (n = t.format ? {
                             ...it(t.format, ["parse"])
-                        } : {}), Gl(t)) this._data = {
+                        } : {}), Ql(t)) this._data = {
                         values: t.values
                     };
-                    else if (Jl(t)) {
+                    else if (Kl(t)) {
                         if (this._data = {
                                 url: t.url
                             }, !n.type) {
                             let e = /(?:\.([^.]+))?$/.exec(t.url)[1];
                             st(["json", "csv", "tsv", "dsv", "topojson"], e) || (e = "json"), n.type = e
                         }
-                    } else Vl(t) ? this._data = {
+                    } else iu(t) ? this._data = {
                         values: [{
                             type: "Sphere"
                         }]
-                    } : ($l(t) || Zl(t)) && (this._data = {});
-                    this._generator = Zl(t), t.name && (this._name = t.name), n && !yt(n) && (this._data.format = n)
+                    } : (tu(t) || eu(t)) && (this._data = {});
+                    this._generator = eu(t), t.name && (this._name = t.name), n && !yt(n) && (this._data.format = n)
                 }
                 dependentFields() {
                     return new Set
                 }
                 producedFields() {}
                 get data() {
                     return this._data
@@ -11241,209 +11356,209 @@
                     return {
                         name: this._name,
                         ...this._data,
                         transform: []
                     }
                 }
             }
-            var rh, oh = function(t, e, n, i, r) {
+            var dh, hh = function(t, e, n, i, r) {
                     if ("m" === i) throw new TypeError("Private method is not writable");
                     if ("a" === i && !r) throw new TypeError("Private accessor was defined without a setter");
                     if ("function" === typeof e ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                     return "a" === i ? r.call(t, n) : r ? r.value = n : e.set(t, n), n
                 },
-                ah = function(t, e, n, i) {
+                ph = function(t, e, n, i) {
                     if ("a" === n && !i) throw new TypeError("Private accessor was defined without a getter");
                     if ("function" === typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                     return "m" === n ? i : "a" === n ? i.call(t) : i ? i.value : e.get(t)
                 };
 
-            function sh(t) {
-                return t instanceof ih || t instanceof eh || t instanceof nh
+            function mh(t) {
+                return t instanceof fh || t instanceof lh || t instanceof uh
             }
-            class ch {
+            class gh {
                 constructor() {
-                    rh.set(this, void 0), oh(this, rh, !1, "f")
+                    dh.set(this, void 0), hh(this, dh, !1, "f")
                 }
                 setModified() {
-                    oh(this, rh, !0, "f")
+                    hh(this, dh, !0, "f")
                 }
                 get modifiedFlag() {
-                    return ah(this, rh, "f")
+                    return ph(this, dh, "f")
                 }
             }
-            rh = new WeakMap;
-            class lh extends ch {
+            dh = new WeakMap;
+            class vh extends gh {
                 getNodeDepths(t, e, n) {
                     n.set(t, e);
                     for (const i of t.children) this.getNodeDepths(i, e + 1, n);
                     return n
                 }
                 optimize(t) {
                     const e = [...this.getNodeDepths(t, 0, new Map).entries()].sort(((t, e) => e[1] - t[1]));
                     for (const n of e) this.run(n[0]);
                     return this.modifiedFlag
                 }
             }
-            class uh extends ch {
+            class yh extends gh {
                 optimize(t) {
                     this.run(t);
                     for (const e of t.children) this.optimize(e);
                     return this.modifiedFlag
                 }
             }
-            class fh extends uh {
+            class bh extends yh {
                 mergeNodes(t, e) {
                     const n = e.shift();
                     for (const i of e) t.removeChild(i), i.parent = n, i.remove()
                 }
                 run(t) {
                     const e = t.children.map((t => t.hash())),
                         n = {};
                     for (let i = 0; i < e.length; i++) void 0 === n[e[i]] ? n[e[i]] = [t.children[i]] : n[e[i]].push(t.children[i]);
                     for (const i of bt(n)) n[i].length > 1 && (this.setModified(), this.mergeNodes(t, n[i]))
                 }
             }
-            class dh extends uh {
+            class xh extends yh {
                 constructor(t) {
-                    super(), this.requiresSelectionId = t && Sf(t)
+                    super(), this.requiresSelectionId = t && zf(t)
                 }
                 run(t) {
-                    t instanceof th && (this.requiresSelectionId && (sh(t.parent) || t.parent instanceof $d || t.parent instanceof Qd) || (this.setModified(), t.remove()))
+                    t instanceof ch && (this.requiresSelectionId && (mh(t.parent) || t.parent instanceof nh || t.parent instanceof sh) || (this.setModified(), t.remove()))
                 }
             }
-            class hh extends ch {
+            class _h extends gh {
                 optimize(t) {
                     return this.run(t, new Set), this.modifiedFlag
                 }
                 run(t, e) {
                     let n = new Set;
-                    t instanceof lu && (n = t.producedFields(), mt(n, e) && (this.setModified(), t.removeFormulas(e), 0 === t.producedFields.length && t.remove()));
+                    t instanceof vu && (n = t.producedFields(), mt(n, e) && (this.setModified(), t.removeFormulas(e), 0 === t.producedFields.length && t.remove()));
                     for (const i of t.children) this.run(i, new Set([...e, ...n]))
                 }
             }
-            class ph extends uh {
+            class wh extends yh {
                 constructor() {
                     super()
                 }
                 run(t) {
-                    t instanceof cu && !t.isRequired() && (this.setModified(), t.remove())
+                    t instanceof pu && !t.isRequired() && (this.setModified(), t.remove())
                 }
             }
-            class mh extends lh {
+            class kh extends vh {
                 run(t) {
-                    if (!sh(t) && !(t.numChildren() > 1))
+                    if (!mh(t) && !(t.numChildren() > 1))
                         for (const e of t.children)
-                            if (e instanceof Qd)
-                                if (t instanceof Qd) this.setModified(), t.merge(e);
+                            if (e instanceof sh)
+                                if (t instanceof sh) this.setModified(), t.merge(e);
                                 else {
                                     if (vt(t.producedFields(), e.dependentFields())) continue;
                                     this.setModified(), e.swapWithParent()
                                 }
                 }
             }
-            class gh extends lh {
+            class Eh extends vh {
                 run(t) {
                     const e = [...t.children],
-                        n = t.children.filter((t => t instanceof Qd));
+                        n = t.children.filter((t => t instanceof sh));
                     if (t.numChildren() > 1 && n.length >= 1) {
                         const i = {},
                             r = new Set;
                         for (const t of n) {
                             const e = t.parse;
                             for (const t of bt(e)) t in i ? i[t] !== e[t] && r.add(t) : i[t] = e[t]
                         }
                         for (const t of r) delete i[t];
                         if (!yt(i)) {
                             this.setModified();
-                            const n = new Qd(t, i);
+                            const n = new sh(t, i);
                             for (const r of e) {
-                                if (r instanceof Qd)
+                                if (r instanceof sh)
                                     for (const t of bt(i)) delete r.parse[t];
-                                t.removeChild(r), r.parent = n, r instanceof Qd && 0 === bt(r.parse).length && r.remove()
+                                t.removeChild(r), r.parent = n, r instanceof sh && 0 === bt(r.parse).length && r.remove()
                             }
                         }
                     }
                 }
             }
-            class vh extends lh {
+            class Ah extends vh {
                 run(t) {
-                    t instanceof cu || t.numChildren() > 0 || t instanceof Zd || t instanceof ih || (this.setModified(), t.remove())
+                    t instanceof pu || t.numChildren() > 0 || t instanceof ih || t instanceof fh || (this.setModified(), t.remove())
                 }
             }
-            class yh extends lh {
+            class Dh extends vh {
                 run(t) {
-                    const e = t.children.filter((t => t instanceof lu)),
+                    const e = t.children.filter((t => t instanceof vu)),
                         n = e.pop();
                     for (const i of e) this.setModified(), n.merge(i)
                 }
             }
-            class bh extends lh {
+            class Sh extends vh {
                 run(t) {
-                    const e = t.children.filter((t => t instanceof $d)),
+                    const e = t.children.filter((t => t instanceof nh)),
                         n = {};
                     for (const i of e) {
                         const t = ot(i.groupBy);
                         t in n || (n[t] = []), n[t].push(i)
                     }
                     for (const i of bt(n)) {
                         const e = n[i];
                         if (e.length > 1) {
                             const n = e.pop();
                             for (const i of e) n.merge(i) && (t.removeChild(i), i.parent = n, i.remove(), this.setModified())
                         }
                     }
                 }
             }
-            class xh extends lh {
+            class Ch extends vh {
                 constructor(t) {
                     super(), this.model = t
                 }
                 run(t) {
-                    const e = !(sh(t) || t instanceof Nf || t instanceof Qd || t instanceof th),
+                    const e = !(mh(t) || t instanceof Uf || t instanceof sh || t instanceof ch),
                         n = [],
                         i = [];
-                    for (const r of t.children) r instanceof Jd && (e && !vt(t.producedFields(), r.dependentFields()) ? n.push(r) : i.push(r));
+                    for (const r of t.children) r instanceof th && (e && !vt(t.producedFields(), r.dependentFields()) ? n.push(r) : i.push(r));
                     if (n.length > 0) {
                         const e = n.pop();
                         for (const t of n) e.merge(t, this.model.renameSignal.bind(this.model));
-                        this.setModified(), t instanceof Jd ? t.merge(e, this.model.renameSignal.bind(this.model)) : e.swapWithParent()
+                        this.setModified(), t instanceof th ? t.merge(e, this.model.renameSignal.bind(this.model)) : e.swapWithParent()
                     }
                     if (i.length > 1) {
                         const t = i.pop();
                         for (const e of i) t.merge(e, this.model.renameSignal.bind(this.model));
                         this.setModified()
                     }
                 }
             }
-            class _h extends lh {
+            class Mh extends vh {
                 run(t) {
                     const e = [...t.children];
-                    if (!ct(e, (t => t instanceof cu)) || t.numChildren() <= 1) return;
+                    if (!ct(e, (t => t instanceof pu)) || t.numChildren() <= 1) return;
                     const n = [];
                     let i;
                     for (const r of e)
-                        if (r instanceof cu) {
+                        if (r instanceof pu) {
                             let e = r;
                             for (; 1 === e.numChildren();) {
                                 const [t] = e.children;
-                                if (!(t instanceof cu)) break;
+                                if (!(t instanceof pu)) break;
                                 e = t
                             }
                             n.push(...e.children), i ? (t.removeChild(r), r.parent = i.parent, i.parent.removeChild(i), i.parent = e, this.setModified()) : i = e
                         } else n.push(r);
                     if (n.length) {
                         this.setModified();
                         for (const t of n) t.parent.removeChild(t), t.parent = i
                     }
                 }
             }
-            class wh extends su {
+            class Fh extends hu {
                 clone() {
-                    return new wh(null, tt(this.transform))
+                    return new Fh(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     super(t), this.transform = e
                 }
                 addDimensions(t) {
                     this.transform.groupby = dt(this.transform.groupby.concat(t), (t => t))
                 }
@@ -11452,15 +11567,15 @@
                     return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((t => t.field)).filter((t => void 0 !== t)).forEach(t.add, t), t
                 }
                 producedFields() {
                     return new Set(this.transform.joinaggregate.map(this.getDefaultName))
                 }
                 getDefaultName(t) {
                     var e;
-                    return null !== (e = t.as) && void 0 !== e ? e : Ga(t)
+                    return null !== (e = t.as) && void 0 !== e ? e : Ka(t)
                 }
                 hash() {
                     return "JoinAggregateTransform ".concat(ot(this.transform))
                 }
                 assemble() {
                     const t = [],
                         e = [],
@@ -11474,38 +11589,38 @@
                         fields: t,
                         ...void 0 !== i ? {
                             groupby: i
                         } : {}
                     }
                 }
             }
-            class kh extends su {
+            class Oh extends hu {
                 clone() {
-                    return new kh(null, tt(this._stack))
+                    return new Oh(null, tt(this._stack))
                 }
                 constructor(t, e) {
                     super(t), this._stack = e
                 }
                 static makeFromTransform(t, e) {
                     const {
                         stack: n,
                         groupby: i,
                         as: r,
                         offset: o = "zero"
                     } = e, a = [], s = [];
                     if (void 0 !== e.sort)
-                        for (const u of e.sort) a.push(u.field), s.push(zt(u.order, "ascending"));
+                        for (const u of e.sort) a.push(u.field), s.push(Rt(u.order, "ascending"));
                     const c = {
                         field: a,
                         order: s
                     };
                     let l;
                     return l = function(t) {
                         return (0, U.kJ)(t) && t.every((t => (0, U.HD)(t))) && t.length > 1
-                    }(r) ? r : (0, U.HD)(r) ? [r, "".concat(r, "_end")] : ["".concat(e.stack, "_start"), "".concat(e.stack, "_end")], new kh(t, {
+                    }(r) ? r : (0, U.HD)(r) ? [r, "".concat(r, "_end")] : ["".concat(e.stack, "_start"), "".concat(e.stack, "_end")], new Oh(t, {
                         dimensionFieldDefs: [],
                         stackField: n,
                         groupby: i,
                         offset: o,
                         sort: c,
                         facetby: [],
                         as: l
@@ -11518,30 +11633,30 @@
                         } = e;
                     if (!n) return null;
                     const {
                         groupbyChannels: r,
                         fieldChannel: o,
                         offset: a,
                         impute: s
-                    } = n, c = r.map((t => ns(i[t]))).filter((t => !!t)), l = function(t) {
+                    } = n, c = r.map((t => ss(i[t]))).filter((t => !!t)), l = function(t) {
                         return t.stack.stackBy.reduce(((t, e) => {
-                            const n = Ga(e.fieldDef);
+                            const n = Ka(e.fieldDef);
                             return n && t.push(n), t
                         }), [])
                     }(e), u = e.encoding.order;
                     let f;
-                    if ((0, U.kJ)(u) || Na(u)) f = Si(u);
+                    if ((0, U.kJ)(u) || Ba(u)) f = Si(u);
                     else {
-                        const t = Fa(u) ? u.sort : "y" === o ? "descending" : "ascending";
+                        const t = Ra(u) ? u.sort : "y" === o ? "descending" : "ascending";
                         f = l.reduce(((e, n) => (e.field.push(n), e.order.push(t), e)), {
                             field: [],
                             order: []
                         })
                     }
-                    return new kh(t, {
+                    return new Oh(t, {
                         dimensionFieldDefs: c,
                         stackField: e.vgField(o),
                         facetby: [],
                         stackby: l,
                         sort: f,
                         offset: a,
                         impute: s,
@@ -11572,19 +11687,19 @@
                 }
                 getGroupbyFields() {
                     const {
                         dimensionFieldDefs: t,
                         impute: e,
                         groupby: n
                     } = this._stack;
-                    return t.length > 0 ? t.map((t => t.bin ? e ? [Ga(t, {
+                    return t.length > 0 ? t.map((t => t.bin ? e ? [Ka(t, {
                         binSuffix: "mid"
-                    })] : [Ga(t, {}), Ga(t, {
+                    })] : [Ka(t, {}), Ka(t, {
                         binSuffix: "end"
-                    })] : [Ga(t)])).flat() : null !== n && void 0 !== n ? n : []
+                    })] : [Ka(t)])).flat() : null !== n && void 0 !== n ? n : []
                 }
                 assemble() {
                     const t = [],
                         {
                             facetby: e,
                             dimensionFieldDefs: n,
                             stackField: i,
@@ -11597,35 +11712,35 @@
                     if (s)
                         for (const l of n) {
                             const {
                                 bandPosition: n = .5,
                                 bin: o
                             } = l;
                             if (o) {
-                                const e = Ga(l, {
+                                const e = Ka(l, {
                                         expr: "datum"
                                     }),
-                                    i = Ga(l, {
+                                    i = Ka(l, {
                                         expr: "datum",
                                         binSuffix: "end"
                                     });
                                 t.push({
                                     type: "formula",
                                     expr: "".concat(n, "*").concat(e, "+").concat(1 - n, "*").concat(i),
-                                    as: Ga(l, {
+                                    as: Ka(l, {
                                         binSuffix: "mid",
                                         forAs: !0
                                     })
                                 })
                             }
                             t.push({
                                 type: "impute",
                                 field: i,
                                 groupby: [...r, ...e],
-                                key: Ga(l, {
+                                key: Ka(l, {
                                     binSuffix: "mid"
                                 }),
                                 method: "value",
                                 value: 0
                             })
                         }
                     return t.push({
@@ -11634,17 +11749,17 @@
                         field: i,
                         sort: o,
                         as: c,
                         offset: a
                     }), t
                 }
             }
-            class Eh extends su {
+            class Th extends hu {
                 clone() {
-                    return new Eh(null, tt(this.transform))
+                    return new Th(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     super(t), this.transform = e
                 }
                 addDimensions(t) {
                     this.transform.groupby = dt(this.transform.groupby.concat(t), (t => t))
                 }
@@ -11654,28 +11769,28 @@
                     return (null !== (t = this.transform.groupby) && void 0 !== t ? t : []).forEach(n.add, n), (null !== (e = this.transform.sort) && void 0 !== e ? e : []).forEach((t => n.add(t.field))), this.transform.window.map((t => t.field)).filter((t => void 0 !== t)).forEach(n.add, n), n
                 }
                 producedFields() {
                     return new Set(this.transform.window.map(this.getDefaultName))
                 }
                 getDefaultName(t) {
                     var e;
-                    return null !== (e = t.as) && void 0 !== e ? e : Ga(t)
+                    return null !== (e = t.as) && void 0 !== e ? e : Ka(t)
                 }
                 hash() {
                     return "WindowTransform ".concat(ot(this.transform))
                 }
                 assemble() {
                     const t = [],
                         e = [],
                         n = [],
                         i = [];
                     for (const f of this.transform.window) e.push(f.op), n.push(this.getDefaultName(f)), i.push(void 0 === f.param ? null : f.param), t.push(void 0 === f.field ? null : f.field);
                     const r = this.transform.frame,
                         o = this.transform.groupby;
-                    if (r && null === r[0] && null === r[1] && e.every((t => $n(t)))) return {
+                    if (r && null === r[0] && null === r[1] && e.every((t => Zn(t)))) return {
                         type: "joinaggregate",
                         as: n,
                         ops: e,
                         fields: t,
                         ...void 0 !== o ? {
                             groupby: o
                         } : {}
@@ -11708,329 +11823,329 @@
                         ...void 0 !== r ? {
                             frame: r
                         } : {}
                     }
                 }
             }
 
-            function Dh(t) {
-                if (t instanceof Zd)
-                    if (1 !== t.numChildren() || t.children[0] instanceof cu) {
+            function Nh(t) {
+                if (t instanceof ih)
+                    if (1 !== t.numChildren() || t.children[0] instanceof pu) {
                         const n = t.model.component.data.main;
-                        Ah(n);
+                        Rh(n);
                         const i = (e = t, function t(n) {
-                                if (!(n instanceof Zd)) {
+                                if (!(n instanceof ih)) {
                                     const i = n.clone();
-                                    if (i instanceof cu) {
-                                        const t = Sh + i.getSource();
+                                    if (i instanceof pu) {
+                                        const t = zh + i.getSource();
                                         i.setSource(t), e.model.component.data.outputNodes[t] = i
-                                    } else(i instanceof $d || i instanceof kh || i instanceof Eh || i instanceof wh) && i.addDimensions(e.fields);
+                                    } else(i instanceof nh || i instanceof Oh || i instanceof Th || i instanceof Fh) && i.addDimensions(e.fields);
                                     for (const e of n.children.flatMap(t)) e.parent = i;
                                     return [i]
                                 }
                                 return n.children.flatMap(t)
                             }),
                             r = t.children.map(i).flat();
                         for (const t of r) t.parent = n
                     } else {
                         const e = t.children[0];
-                        (e instanceof $d || e instanceof kh || e instanceof Eh || e instanceof wh) && e.addDimensions(t.fields), e.swapWithParent(), Dh(t)
+                        (e instanceof nh || e instanceof Oh || e instanceof Th || e instanceof Fh) && e.addDimensions(t.fields), e.swapWithParent(), Nh(t)
                     }
-                else t.children.map(Dh);
+                else t.children.map(Nh);
                 var e
             }
 
-            function Ah(t) {
-                if (t instanceof cu && t.type === Ql.Main && 1 === t.numChildren()) {
+            function Rh(t) {
+                if (t instanceof pu && t.type === ou.Main && 1 === t.numChildren()) {
                     const e = t.children[0];
-                    e instanceof Zd || (e.swapWithParent(), Ah(t))
+                    e instanceof ih || (e.swapWithParent(), Rh(t))
                 }
             }
-            const Sh = "scale_",
-                Ch = 5;
+            const zh = "scale_",
+                Ph = 5;
 
-            function Fh(t) {
+            function Lh(t) {
                 for (const e of t) {
                     for (const t of e.children)
                         if (t.parent !== e) return !1;
-                    if (!Fh(e.children)) return !1
+                    if (!Lh(e.children)) return !1
                 }
                 return !0
             }
 
-            function Mh(t, e) {
+            function Bh(t, e) {
                 let n = !1;
                 for (const i of e) n = t.optimize(i) || n;
                 return n
             }
 
-            function Oh(t, e, n) {
+            function Ih(t, e, n) {
                 let i = t.sources,
                     r = !1;
-                return r = Mh(new ph, i) || r, r = Mh(new dh(e), i) || r, i = i.filter((t => t.numChildren() > 0)), r = Mh(new vh, i) || r, i = i.filter((t => t.numChildren() > 0)), n || (r = Mh(new mh, i) || r, r = Mh(new xh(e), i) || r, r = Mh(new hh, i) || r, r = Mh(new gh, i) || r, r = Mh(new bh, i) || r, r = Mh(new yh, i) || r, r = Mh(new fh, i) || r, r = Mh(new _h, i) || r), t.sources = i, r
+                return r = Bh(new wh, i) || r, r = Bh(new xh(e), i) || r, i = i.filter((t => t.numChildren() > 0)), r = Bh(new Ah, i) || r, i = i.filter((t => t.numChildren() > 0)), n || (r = Bh(new kh, i) || r, r = Bh(new Ch(e), i) || r, r = Bh(new _h, i) || r, r = Bh(new Eh, i) || r, r = Bh(new Sh, i) || r, r = Bh(new Dh, i) || r, r = Bh(new bh, i) || r, r = Bh(new Mh, i) || r), t.sources = i, r
             }
-            class Th {
+            class jh {
                 constructor(t) {
                     Object.defineProperty(this, "signal", {
                         enumerable: !0,
                         get: t
                     })
                 }
                 static fromName(t, e) {
-                    return new Th((() => t(e)))
+                    return new jh((() => t(e)))
                 }
             }
 
-            function Nh(t) {
-                fp(t) ? function(t) {
+            function Uh(t) {
+                bp(t) ? function(t) {
                     const e = t.component.scales;
                     for (const n of bt(e)) {
-                        const i = zh(t, n);
-                        if (e[n].setWithExplicit("domains", i), jh(t, n), t.component.data.isFaceted) {
+                        const i = qh(t, n);
+                        if (e[n].setWithExplicit("domains", i), Gh(t, n), t.component.data.isFaceted) {
                             let e = t;
-                            for (; !dp(e) && e.parent;) e = e.parent;
+                            for (; !xp(e) && e.parent;) e = e.parent;
                             if ("shared" === e.component.resolve.scale[n])
-                                for (const t of i.value) fi(t) && (t.data = Sh + t.data.replace(Sh, ""))
+                                for (const t of i.value) fi(t) && (t.data = zh + t.data.replace(zh, ""))
                         }
                     }
                 }(t) : function(t) {
-                    for (const n of t.children) Nh(n);
+                    for (const n of t.children) Uh(n);
                     const e = t.component.scales;
                     for (const n of bt(e)) {
                         let i, r = null;
                         for (const e of t.children) {
                             const t = e.component.scales[n];
                             if (t) {
-                                i = void 0 === i ? t.getWithExplicit("domains") : Hl(i, t.getWithExplicit("domains"), "domains", "scale", Ih);
+                                i = void 0 === i ? t.getWithExplicit("domains") : Yl(i, t.getWithExplicit("domains"), "domains", "scale", Zh);
                                 const e = t.get("selectionExtent");
-                                r && e && r.param !== e.param && dr(Ii), r = e
+                                r && e && r.param !== e.param && dr(ji), r = e
                             }
                         }
                         e[n].setWithExplicit("domains", i), r && e[n].set("selectionExtent", r, !0)
                     }
                 }(t)
             }
 
-            function zh(t, e) {
+            function qh(t, e) {
                 const n = t.getScaleComponent(e).get("type"),
                     {
                         encoding: i
                     } = t,
                     r = function(t, e, n, i) {
                         if ("unaggregated" === t) {
                             const {
                                 valid: t,
                                 reason: i
-                            } = Bh(e, n);
+                            } = Jh(e, n);
                             if (!t) return void dr(i)
                         } else if (void 0 === t && i.useUnaggregatedDomain) {
                             const {
                                 valid: t
-                            } = Bh(e, n);
+                            } = Jh(e, n);
                             if (t) return "unaggregated"
                         }
                         return t
                     }(t.scaleDomain(e), t.typedFieldDef(e), n, t.config.scale);
                 return r !== t.scaleDomain(e) && (t.specifiedScales[e] = {
                     ...t.specifiedScales[e],
                     domain: r
-                }), "x" === e && is(i.x2) ? is(i.x) ? Hl(Ph(n, r, t, "x"), Ph(n, r, t, "x2"), "domain", "scale", Ih) : Ph(n, r, t, "x2") : "y" === e && is(i.y2) ? is(i.y) ? Hl(Ph(n, r, t, "y"), Ph(n, r, t, "y2"), "domain", "scale", Ih) : Ph(n, r, t, "y2") : Ph(n, r, t, e)
+                }), "x" === e && cs(i.x2) ? cs(i.x) ? Yl(Hh(n, r, t, "x"), Hh(n, r, t, "x2"), "domain", "scale", Zh) : Hh(n, r, t, "x2") : "y" === e && cs(i.y2) ? cs(i.y) ? Yl(Hh(n, r, t, "y"), Hh(n, r, t, "y2"), "domain", "scale", Zh) : Hh(n, r, t, "y2") : Hh(n, r, t, e)
             }
 
-            function Rh(t, e, n) {
+            function Wh(t, e, n) {
                 var i;
-                const r = null === (i = Cr(n)) || void 0 === i ? void 0 : i.unit;
+                const r = null === (i = Or(n)) || void 0 === i ? void 0 : i.unit;
                 return "temporal" === e || r ? function(t, e, n) {
                     return t.map((t => {
-                        const i = us(t, {
+                        const i = ms(t, {
                             timeUnit: n,
                             type: e
                         });
                         return {
                             signal: "{data: ".concat(i, "}")
                         }
                     }))
                 }(t, e, r) : [t]
             }
 
-            function Ph(t, e, n, i) {
+            function Hh(t, e, n, i) {
                 const {
                     encoding: r
-                } = n, o = is(r[i]), {
+                } = n, o = cs(r[i]), {
                     type: a
                 } = o, s = o.timeUnit;
                 if (function(t) {
                         return null === t || void 0 === t ? void 0 : t.unionWith
                     }(e)) {
-                    const r = Ph(t, void 0, n, i);
-                    return Il([...Rh(e.unionWith, a, s), ...r.value])
+                    const r = Hh(t, void 0, n, i);
+                    return Gl([...Wh(e.unionWith, a, s), ...r.value])
                 }
-                if (li(e)) return Il([e]);
-                if (e && "unaggregated" !== e && !fo(e)) return Il(Rh(e, a, s));
+                if (li(e)) return Gl([e]);
+                if (e && "unaggregated" !== e && !vo(e)) return Gl(Wh(e, a, s));
                 const c = n.stack;
                 if (c && i === c.fieldChannel) {
-                    if ("normalize" === c.offset) return Ul([
+                    if ("normalize" === c.offset) return Jl([
                         [0, 1]
                     ]);
-                    const t = n.requestDataName(Ql.Main);
-                    return Ul([{
+                    const t = n.requestDataName(ou.Main);
+                    return Jl([{
                         data: t,
                         field: n.vgField(i, {
                             suffix: "start"
                         })
                     }, {
                         data: t,
                         field: n.vgField(i, {
                             suffix: "end"
                         })
                     }])
                 }
-                const l = jn(i) && Na(o) ? function(t, e, n) {
-                    if (!so(n)) return;
+                const l = Bn(i) && Ba(o) ? function(t, e, n) {
+                    if (!ho(n)) return;
                     const i = t.fieldDef(e),
                         r = i.sort;
-                    if (xa(r)) return {
+                    if (Aa(r)) return {
                         op: "min",
-                        field: Zf(i, e),
+                        field: id(i, e),
                         order: "ascending"
                     };
                     const {
                         stack: o
                     } = t, a = o ? new Set([...o.groupbyFields, ...o.stackBy.map((t => t.fieldDef.field))]) : void 0;
-                    if (ba(r)) {
-                        return Lh(r, o && !a.has(r.field))
+                    if (Ea(r)) {
+                        return Xh(r, o && !a.has(r.field))
                     }
-                    if (ya(r)) {
+                    if (ka(r)) {
                         const {
                             encoding: e,
                             order: n
                         } = r, i = t.fieldDef(e), {
                             aggregate: s,
                             field: c
                         } = i, l = o && !a.has(c);
-                        if (Jn(s) || Gn(s)) return Lh({
-                            field: Ga(i),
+                        if (Gn(s) || Jn(s)) return Xh({
+                            field: Ka(i),
                             order: n
                         }, l);
-                        if ($n(s) || !s) return Lh({
+                        if (Zn(s) || !s) return Xh({
                             op: s,
                             field: c,
                             order: n
                         }, l)
                     } else {
                         if ("descending" === r) return {
                             op: "min",
                             field: t.vgField(e),
                             order: "descending"
                         };
                         if (st(["ascending", void 0], r)) return !0
                     }
                     return
                 }(n, i, t) : void 0;
-                if (Ra(o)) {
-                    return Ul(Rh([o.datum], a, s))
+                if (ja(o)) {
+                    return Jl(Wh([o.datum], a, s))
                 }
                 const u = o;
                 if ("unaggregated" === e) {
-                    const t = n.requestDataName(Ql.Main),
+                    const t = n.requestDataName(ou.Main),
                         {
                             field: e
                         } = o;
-                    return Ul([{
+                    return Jl([{
                         data: t,
-                        field: Ga({
+                        field: Ka({
                             field: e,
                             aggregate: "min"
                         })
                     }, {
                         data: t,
-                        field: Ga({
+                        field: Ka({
                             field: e,
                             aggregate: "max"
                         })
                     }])
                 }
                 if (ti(u.bin)) {
-                    if (so(t)) return Ul("bin-ordinal" === t ? [] : [{
-                        data: wt(l) ? n.requestDataName(Ql.Main) : n.requestDataName(Ql.Raw),
-                        field: n.vgField(i, ds(u, i) ? {
+                    if (ho(t)) return Jl("bin-ordinal" === t ? [] : [{
+                        data: wt(l) ? n.requestDataName(ou.Main) : n.requestDataName(ou.Raw),
+                        field: n.vgField(i, vs(u, i) ? {
                             binSuffix: "range"
                         } : {}),
                         sort: !0 !== l && (0, U.Kn)(l) ? l : {
                             field: n.vgField(i, {}),
                             op: "min"
                         }
                     }]);
                     {
                         const {
                             bin: t
                         } = u;
                         if (ti(t)) {
-                            const e = Hd(n, u.field, t);
-                            return Ul([new Th((() => {
+                            const e = Kd(n, u.field, t);
+                            return Jl([new jh((() => {
                                 const t = n.getSignalName(e);
                                 return "[".concat(t, ".start, ").concat(t, ".stop]")
                             }))])
                         }
-                        return Ul([{
-                            data: n.requestDataName(Ql.Main),
+                        return Jl([{
+                            data: n.requestDataName(ou.Main),
                             field: n.vgField(i, {})
                         }])
                     }
                 }
-                if (u.timeUnit && st(["time", "utc"], t) && Ca(u, fp(n) ? n.encoding[Ze(i)] : void 0, n.markDef, n.config)) {
-                    const t = n.requestDataName(Ql.Main);
-                    return Ul([{
+                if (u.timeUnit && st(["time", "utc"], t) && Na(u, bp(n) ? n.encoding[$e(i)] : void 0, n.markDef, n.config)) {
+                    const t = n.requestDataName(ou.Main);
+                    return Jl([{
                         data: t,
                         field: n.vgField(i)
                     }, {
                         data: t,
                         field: n.vgField(i, {
                             suffix: "end"
                         })
                     }])
                 }
-                return Ul(l ? [{
-                    data: wt(l) ? n.requestDataName(Ql.Main) : n.requestDataName(Ql.Raw),
+                return Jl(l ? [{
+                    data: wt(l) ? n.requestDataName(ou.Main) : n.requestDataName(ou.Raw),
                     field: n.vgField(i),
                     sort: l
                 }] : [{
-                    data: n.requestDataName(Ql.Main),
+                    data: n.requestDataName(ou.Main),
                     field: n.vgField(i)
                 }])
             }
 
-            function Lh(t, e) {
+            function Xh(t, e) {
                 const {
                     op: n,
                     field: i,
                     order: r
                 } = t;
                 return {
-                    op: null !== n && void 0 !== n ? n : e ? "sum" : ma,
+                    op: null !== n && void 0 !== n ? n : e ? "sum" : xa,
                     ...i ? {
-                        field: Mt(i)
+                        field: Ft(i)
                     } : {},
                     ...r ? {
                         order: r
                     } : {}
                 }
             }
 
-            function jh(t, e) {
+            function Gh(t, e) {
                 var n;
                 const i = t.component.scales[e],
                     r = t.specifiedScales[e].domain,
                     o = null === (n = t.fieldDef(e)) || void 0 === n ? void 0 : n.bin,
-                    a = fo(r) && r,
+                    a = vo(r) && r,
                     s = ni(o) && ii(o.extent) && o.extent;
                 (a || s) && i.set("selectionExtent", null !== a && void 0 !== a ? a : s, !0)
             }
 
-            function Bh(t, e) {
+            function Jh(t, e) {
                 const {
                     aggregate: n,
                     type: i
                 } = t;
                 return n ? (0, U.HD)(n) && !Kn.has(n) ? {
                     valid: !1,
                     reason: er(n)
@@ -12041,24 +12156,24 @@
                     valid: !0
                 } : {
                     valid: !1,
                     reason: tr(t)
                 }
             }
 
-            function Ih(t, e, n, i) {
+            function Zh(t, e, n, i) {
                 return t.explicit && e.explicit && dr(function(t, e, n, i) {
                     return "Conflicting ".concat(e.toString(), ' property "').concat(t.toString(), '" (').concat(rt(n), " and ").concat(rt(i), "). Using the union of the two domains.")
                 }(n, i, t.value, e.value)), {
                     explicit: t.explicit,
                     value: [...t.value, ...e.value]
                 }
             }
 
-            function Uh(t) {
+            function $h(t) {
                 const e = dt(t.map((t => {
                         if (fi(t)) {
                             const {
                                 sort: e,
                                 ...n
                             } = t;
                             return n
@@ -12112,15 +12227,15 @@
                     fields: e,
                     ...r ? {
                         sort: r
                     } : {}
                 }
             }
 
-            function qh(t) {
+            function Yh(t) {
                 if (fi(t) && (0, U.HD)(t.field)) return t.field;
                 if (function(t) {
                         return !(0, U.kJ)(t) && "fields" in t && !("data" in t)
                     }(t)) {
                     let e;
                     for (const n of t.fields)
                         if (fi(n) && (0, U.HD)(n.field))
@@ -12134,24 +12249,24 @@
                     }(t)) {
                     dr("Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.");
                     const e = t.fields[0];
                     return (0, U.HD)(e) ? e : void 0
                 }
             }
 
-            function Wh(t, e) {
+            function Vh(t, e) {
                 const n = t.component.scales[e].get("domains").map((e => (fi(e) && (e.data = t.lookupDataSource(e.data)), e)));
-                return Uh(n)
+                return $h(n)
             }
 
-            function Hh(t) {
-                return pp(t) || hp(t) ? t.children.reduce(((t, e) => t.concat(Hh(e))), Xh(t)) : Xh(t)
+            function Kh(t) {
+                return wp(t) || _p(t) ? t.children.reduce(((t, e) => t.concat(Kh(e))), Qh(t)) : Qh(t)
             }
 
-            function Xh(t) {
+            function Qh(t) {
                 return bt(t.component.scales).reduce(((e, n) => {
                     const i = t.component.scales[n];
                     if (i.merged) return e;
                     const r = i.combine(),
                         {
                             name: o,
                             type: a,
@@ -12170,19 +12285,19 @@
                                 }
                             } else if ((0, U.Kn)(t) && fi(t)) return {
                                 ...t,
                                 data: i.lookupDataSource(t.data)
                             };
                             return t
                         }(r.range, o, n, t),
-                        h = Wh(t, n),
+                        h = Vh(t, n),
                         p = s ? function(t, e, n, i) {
-                            const r = Rf(t, e.param, e);
+                            const r = Wf(t, e.param, e);
                             return {
-                                signal: co(n.get("type")) && (0, U.kJ)(i) && i[0] > i[1] ? "isValid(".concat(r, ") && reverse(").concat(r, ")") : r
+                                signal: po(n.get("type")) && (0, U.kJ)(i) && i[0] > i[1] ? "isValid(".concat(r, ") && reverse(").concat(r, ")") : r
                             }
                         }(t, s, i, h) : null;
                     return e.push({
                         name: o,
                         type: a,
                         ...h ? {
                             domain: h
@@ -12194,153 +12309,153 @@
                         ...void 0 !== u ? {
                             reverse: u
                         } : {},
                         ...f
                     }), e
                 }), [])
             }
-            class Jh extends Bl {
+            class tp extends Xl {
                 constructor(t, e) {
                     super({}, {
                         name: t
                     }), this.merged = !1, this.setWithExplicit("type", e)
                 }
                 domainDefinitelyIncludesZero() {
                     return !1 !== this.get("zero") || ct(this.get("domains"), (t => (0, U.kJ)(t) && 2 === t.length && t[0] <= 0 && t[1] >= 0))
                 }
             }
-            const Gh = ["range", "scheme"];
+            const ep = ["range", "scheme"];
 
-            function $h(t, e) {
+            function np(t, e) {
                 const n = t.fieldDef(e);
                 if (null !== n && void 0 !== n && n.bin) {
                     const {
                         bin: i,
                         field: r
                     } = n, o = Ye(e), a = t.getName(o);
-                    if ((0, U.Kn)(i) && i.binned && void 0 !== i.step) return new Th((() => {
+                    if ((0, U.Kn)(i) && i.binned && void 0 !== i.step) return new jh((() => {
                         const n = t.scaleName(e),
                             r = '(domain("'.concat(n, '")[1] - domain("').concat(n, '")[0]) / ').concat(i.step);
                         return "".concat(t.getSignalName(a), " / (").concat(r, ")")
                     }));
                     if (ti(i)) {
-                        const e = Hd(t, r, i);
-                        return new Th((() => {
+                        const e = Kd(t, r, i);
+                        return new jh((() => {
                             const n = t.getSignalName(e),
                                 i = "(".concat(n, ".stop - ").concat(n, ".start) / ").concat(n, ".step");
                             return "".concat(t.getSignalName(a), " / (").concat(i, ")")
                         }))
                     }
                 }
             }
 
-            function Zh(t, e) {
+            function ip(t, e) {
                 const n = e.specifiedScales[t],
                     {
                         size: i
                     } = e,
                     r = e.getScaleComponent(t).get("type");
-                for (const u of Gh)
+                for (const u of ep)
                     if (void 0 !== n[u]) {
-                        const i = wo(r, u),
-                            o = ko(t, u);
+                        const i = So(r, u),
+                            o = Co(t, u);
                         if (i)
                             if (o) dr(o);
                             else switch (u) {
                                 case "range": {
                                     const i = n.range;
                                     if ((0, U.kJ)(i)) {
-                                        if (xn(t)) return Il(i.map((t => {
+                                        if (xn(t)) return Gl(i.map((t => {
                                             if ("width" === t || "height" === t) {
                                                 const n = e.getName(t),
                                                     i = e.getSignalName.bind(e);
-                                                return Th.fromName(i, n)
+                                                return jh.fromName(i, n)
                                             }
                                             return t
                                         })))
-                                    } else if ((0, U.Kn)(i)) return Il({
-                                        data: e.requestDataName(Ql.Main),
+                                    } else if ((0, U.Kn)(i)) return Gl({
+                                        data: e.requestDataName(ou.Main),
                                         field: i.field,
                                         sort: {
                                             op: "min",
                                             field: e.vgField(t)
                                         }
                                     });
-                                    return Il(i)
+                                    return Gl(i)
                                 }
                                 case "scheme":
-                                    return Il(Yh(n[u]))
+                                    return Gl(rp(n[u]))
                             } else dr(ir(r, u, t))
                     } const o = t === Xt || "xOffset" === t ? "width" : "height",
                     a = i[o];
-                if (bc(a))
+                if (Ec(a))
                     if (xn(t))
-                        if (so(r)) {
-                            const n = Vh(a, e, t);
-                            if (n) return Il({
+                        if (ho(r)) {
+                            const n = op(a, e, t);
+                            if (n) return Gl({
                                 step: n
                             })
                         } else dr(rr(o));
-                else if (Dn(t)) {
-                    const n = t === Zt ? "x" : "y";
+                else if (An(t)) {
+                    const n = t === $t ? "x" : "y";
                     if ("band" === e.getScaleComponent(n).get("type")) {
-                        const t = Kh(a, r);
-                        if (t) return Il(t)
+                        const t = ap(a, r);
+                        if (t) return Gl(t)
                     }
                 }
                 const {
                     rangeMin: s,
                     rangeMax: c
                 } = n, l = function(t, e) {
                     const {
                         size: n,
                         config: i,
                         mark: r,
                         encoding: o
                     } = e, a = e.getSignalName.bind(e), {
                         type: s
-                    } = is(o[t]), c = e.getScaleComponent(t), l = c.get("type"), {
+                    } = cs(o[t]), c = e.getScaleComponent(t), l = c.get("type"), {
                         domain: u,
                         domainMid: f
                     } = e.specifiedScales[t];
                     switch (t) {
                         case Xt:
-                        case Jt: {
+                        case Gt: {
                             if (st(["point", "band"], l)) {
-                                const r = Qh(t, n, i.view);
-                                if (bc(r)) {
+                                const r = sp(t, n, i.view);
+                                if (Ec(r)) {
                                     return {
-                                        step: Vh(r, e, t)
+                                        step: op(r, e, t)
                                     }
                                 }
                             }
                             const r = Ye(t),
                                 o = e.getName(r);
-                            return t === Jt && co(l) ? [Th.fromName(a, o), 0] : [0, Th.fromName(a, o)]
+                            return t === Gt && po(l) ? [jh.fromName(a, o), 0] : [0, jh.fromName(a, o)]
                         }
-                        case Zt:
+                        case $t:
                         case Yt:
                             return function(t, e, n) {
-                                const i = t === Zt ? "x" : "y",
+                                const i = t === $t ? "x" : "y",
                                     r = e.getScaleComponent(i),
                                     o = r.get("type"),
                                     a = e.scaleName(i);
                                 if ("band" === o) {
-                                    const t = Qh(i, e.size, e.config.view);
-                                    if (bc(t)) {
-                                        const e = Kh(t, n);
+                                    const t = sp(i, e.size, e.config.view);
+                                    if (Ec(t)) {
+                                        const e = ap(t, n);
                                         if (e) return e
                                     }
                                     return [0, {
                                         signal: "bandwidth('".concat(a, "')")
                                     }]
                                 } {
                                     const n = e.encoding[i];
-                                    if (Na(n) && n.timeUnit) {
-                                        const t = Fr(n.timeUnit, (t => "scale('".concat(a, "', ").concat(t, ")"))),
+                                    if (Ba(n) && n.timeUnit) {
+                                        const t = Tr(n.timeUnit, (t => "scale('".concat(a, "', ").concat(t, ")"))),
                                             i = e.config.scale.bandWithNestedOffsetPaddingInner;
                                         if (i) {
                                             const e = li(i) ? "".concat(i.signal, "/2") : "".concat(i / 2),
                                                 n = li(i) ? "(1 - ".concat(i.signal, "/2)") : "".concat(1 - i / 2);
                                             return [{
                                                 signal: "".concat(e, " * (").concat(t, ")")
                                             }, {
@@ -12351,51 +12466,51 @@
                                             signal: t
                                         }]
                                     }
                                     return et("Cannot use ".concat(t, " scale if ").concat(i, " scale is not discrete."))
                                 }
                             }(t, e, l);
                         case le: {
-                            const o = tp(r, e.component.scales[t].get("zero"), i),
+                            const o = cp(r, e.component.scales[t].get("zero"), i),
                                 a = function(t, e, n, i) {
                                     const r = {
-                                        x: $h(n, "x"),
-                                        y: $h(n, "y")
+                                        x: np(n, "x"),
+                                        y: np(n, "y")
                                     };
                                     switch (t) {
                                         case "bar":
                                         case "tick": {
                                             if (void 0 !== i.scale.maxBandSize) return i.scale.maxBandSize;
-                                            const t = np(e, r, i.view);
-                                            return (0, U.hj)(t) ? t - 1 : new Th((() => "".concat(t.signal, " - 1")))
+                                            const t = up(e, r, i.view);
+                                            return (0, U.hj)(t) ? t - 1 : new jh((() => "".concat(t.signal, " - 1")))
                                         }
                                         case "line":
                                         case "trail":
                                         case "rule":
                                             return i.scale.maxStrokeWidth;
                                         case "text":
                                             return i.scale.maxFontSize;
                                         case "point":
                                         case "square":
                                         case "circle": {
                                             if (i.scale.maxSize) return i.scale.maxSize;
-                                            const t = np(e, r, i.view);
-                                            return (0, U.hj)(t) ? Math.pow(ep * t, 2) : new Th((() => "pow(".concat(ep, " * ").concat(t.signal, ", 2)")))
+                                            const t = up(e, r, i.view);
+                                            return (0, U.hj)(t) ? Math.pow(lp * t, 2) : new jh((() => "pow(".concat(lp, " * ").concat(t.signal, ", 2)")))
                                         }
                                     }
-                                    throw new Error(Zi("size", t))
+                                    throw new Error($i("size", t))
                                 }(r, n, e, i);
-                            return uo(l) ? function(t, e, n) {
+                            return go(l) ? function(t, e, n) {
                                 const i = () => {
                                     const i = xi(e),
                                         r = xi(t),
                                         o = "(".concat(i, " - ").concat(r, ") / (").concat(n, " - 1)");
                                     return "sequence(".concat(r, ", ").concat(i, " + ").concat(o, ", ").concat(o, ")")
                                 };
-                                return li(e) ? new Th(i) : {
+                                return li(e) ? new jh(i) : {
                                     signal: i()
                                 }
                             }(o, a, function(t, e, n, i) {
                                 switch (t) {
                                     case "quantile":
                                         return e.scale.quantileCount;
                                     case "quantize":
@@ -12408,15 +12523,15 @@
                             }(l, i, u, t)) : [o, a]
                         }
                         case Qt:
                             return [0, 2 * Math.PI];
                         case ue:
                             return [0, 360];
                         case Vt:
-                            return [0, new Th((() => {
+                            return [0, new jh((() => {
                                 const t = e.getSignalName("width"),
                                     n = e.getSignalName("height");
                                 return "min(".concat(t, ",").concat(n, ")/2")
                             }))];
                         case pe:
                             return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
                         case me:
@@ -12435,36 +12550,36 @@
                             return "ordinal" === l ? "nominal" === s ? "category" : "ordinal" : void 0 !== f ? "diverging" : "rect" === r || "geoshape" === r ? "heatmap" : "ramp";
                         case fe:
                         case de:
                         case he:
                             return [i.scale.minOpacity, i.scale.maxOpacity]
                     }
                 }(t, e);
-                return (void 0 !== s || void 0 !== c) && wo(r, "rangeMin") && (0, U.kJ)(l) && 2 === l.length ? Il([null !== s && void 0 !== s ? s : l[0], null !== c && void 0 !== c ? c : l[1]]) : Ul(l)
+                return (void 0 !== s || void 0 !== c) && So(r, "rangeMin") && (0, U.kJ)(l) && 2 === l.length ? Gl([null !== s && void 0 !== s ? s : l[0], null !== c && void 0 !== c ? c : l[1]]) : Jl(l)
             }
 
-            function Yh(t) {
+            function rp(t) {
                 return function(t) {
                     return !(0, U.HD)(t) && !!t.name
                 }(t) ? {
                     scheme: t.name,
                     ...it(t, ["name"])
                 } : {
                     scheme: t
                 }
             }
 
-            function Vh(t, e, n) {
+            function op(t, e, n) {
                 const {
                     encoding: i
                 } = e, r = e.getScaleComponent(n), o = Ke(n), a = i[o];
-                if ("offset" === yc({
+                if ("offset" === kc({
                         step: t,
-                        offsetIsDiscrete: Ba(a) && Hr(a.type)
-                    }) && Es(i, o)) {
+                        offsetIsDiscrete: Ha(a) && $r(a.type)
+                    }) && Ms(i, o)) {
                     var s;
                     const n = e.getScaleComponent(o),
                         i = e.scaleName(o);
                     let a = "domain('".concat(i, "').length");
                     if ("band" === n.get("type")) {
                         var c, l, u, f;
                         const t = null !== (c = null !== (l = n.get("paddingInner")) && void 0 !== l ? l : n.get("padding")) && void 0 !== c ? c : 0,
@@ -12476,32 +12591,32 @@
                         signal: "".concat(t.step, " * ").concat(a, " / (1-").concat((d = h, li(d) ? d.signal : (0, U.m8)(d)), ")")
                     }
                 }
                 return t.step;
                 var d
             }
 
-            function Kh(t, e) {
-                if ("offset" === yc({
+            function ap(t, e) {
+                if ("offset" === kc({
                         step: t,
-                        offsetIsDiscrete: so(e)
+                        offsetIsDiscrete: ho(e)
                     })) return {
                     step: t.step
                 }
             }
 
-            function Qh(t, e, n) {
+            function sp(t, e, n) {
                 const i = t === Xt ? "width" : "height",
                     r = e[i];
-                return r || Ec(n, i)
+                return r || Mc(n, i)
             }
 
-            function tp(t, e, n) {
+            function cp(t, e, n) {
                 if (e) return li(e) ? {
-                    signal: "".concat(e.signal, " ? 0 : ").concat(tp(t, !1, n))
+                    signal: "".concat(e.signal, " ? 0 : ").concat(cp(t, !1, n))
                 } : 0;
                 switch (t) {
                     case "bar":
                     case "tick":
                         return n.scale.minBandSize;
                     case "line":
                     case "trail":
@@ -12510,96 +12625,96 @@
                     case "text":
                         return n.scale.minFontSize;
                     case "point":
                     case "square":
                     case "circle":
                         return n.scale.minSize
                 }
-                throw new Error(Zi("size", t))
+                throw new Error($i("size", t))
             }
-            const ep = .95;
+            const lp = .95;
 
-            function np(t, e, n) {
-                const i = bc(t.width) ? t.width.step : kc(n, "width"),
-                    r = bc(t.height) ? t.height.step : kc(n, "height");
-                return e.x || e.y ? new Th((() => {
+            function up(t, e, n) {
+                const i = Ec(t.width) ? t.width.step : Cc(n, "width"),
+                    r = Ec(t.height) ? t.height.step : Cc(n, "height");
+                return e.x || e.y ? new jh((() => {
                     const t = [e.x ? e.x.signal : i, e.y ? e.y.signal : r];
                     return "min(".concat(t.join(", "), ")")
                 })) : Math.min(i, r)
             }
 
-            function ip(t, e) {
-                fp(t) ? function(t, e) {
+            function fp(t, e) {
+                bp(t) ? function(t, e) {
                     const n = t.component.scales,
                         {
                             config: i,
                             encoding: r,
                             markDef: o,
                             specifiedScales: a
                         } = t;
                     for (const s of bt(n)) {
                         const c = a[s],
                             l = n[s],
                             u = t.getScaleComponent(s),
-                            f = is(r[s]),
+                            f = cs(r[s]),
                             d = c[e],
                             h = u.get("type"),
                             p = u.get("padding"),
                             m = u.get("paddingInner"),
-                            g = wo(h, e),
-                            v = ko(s, e);
+                            g = So(h, e),
+                            v = Co(s, e);
                         if (void 0 !== d && (g ? v && dr(v) : dr(ir(h, e, s))), g && void 0 === v)
                             if (void 0 !== d) {
                                 const t = f.timeUnit,
                                     n = f.type;
                                 switch (e) {
                                     case "domainMax":
                                     case "domainMin":
                                         hr(c[e]) || "temporal" === n || t ? l.set(e, {
-                                            signal: us(c[e], {
+                                            signal: ms(c[e], {
                                                 type: n,
                                                 timeUnit: t
                                             })
                                         }, !0) : l.set(e, c[e], !0);
                                         break;
                                     default:
                                         l.copyKeyFromObject(e, c)
                                 }
                             } else {
-                                const n = e in rp ? rp[e]({
+                                const n = e in dp ? dp[e]({
                                     model: t,
                                     channel: s,
                                     fieldOrDatumDef: f,
                                     scaleType: h,
                                     scalePadding: p,
                                     scalePaddingInner: m,
                                     domain: c.domain,
                                     domainMin: c.domainMin,
                                     domainMax: c.domainMax,
                                     markDef: o,
                                     config: i,
-                                    hasNestedOffsetScale: Ds(r, s),
-                                    hasSecondaryRangeChannel: !!r[Ze(s)]
+                                    hasNestedOffsetScale: Fs(r, s),
+                                    hasSecondaryRangeChannel: !!r[$e(s)]
                                 }) : i.scale[e];
                                 void 0 !== n && l.set(e, n, !1)
                             }
                     }
-                }(t, e) : ap(t, e)
+                }(t, e) : pp(t, e)
             }
-            const rp = {
+            const dp = {
                 bins: t => {
                     let {
                         model: e,
                         fieldOrDatumDef: n
                     } = t;
-                    return Na(n) ? function(t, e) {
+                    return Ba(n) ? function(t, e) {
                         const n = e.bin;
                         if (ti(n)) {
-                            const i = Hd(t, e.field, n);
-                            return new Th((() => t.getSignalName(i)))
+                            const i = Kd(t, e.field, n);
+                            return new jh((() => t.getSignalName(i)))
                         }
                         if (ei(n) && ni(n) && void 0 !== n.step) return {
                             step: n.step
                         };
                         return
                     }(e, n) : void 0
                 },
@@ -12620,37 +12735,37 @@
                         domain: i,
                         domainMin: r,
                         domainMax: o,
                         fieldOrDatumDef: a
                     } = t;
                     return function(t, e, n, i, r, o) {
                         var a;
-                        if (null !== (a = ns(o)) && void 0 !== a && a.bin || (0, U.kJ)(n) || null != r || null != i || st([Yr.TIME, Yr.UTC], t)) return;
+                        if (null !== (a = ss(o)) && void 0 !== a && a.bin || (0, U.kJ)(n) || null != r || null != i || st([eo.TIME, eo.UTC], t)) return;
                         return !!xn(e) || void 0
                     }(e, n, i, r, o, a)
                 },
                 padding: t => {
                     let {
                         channel: e,
                         scaleType: n,
                         fieldOrDatumDef: i,
                         markDef: r,
                         config: o
                     } = t;
                     return function(t, e, n, i, r, o) {
                         if (xn(t)) {
-                            if (lo(e)) {
+                            if (mo(e)) {
                                 if (void 0 !== n.continuousPadding) return n.continuousPadding;
                                 const {
                                     type: e,
                                     orient: a
                                 } = r;
-                                if ("bar" === e && (!Na(i) || !i.bin && !i.timeUnit) && ("vertical" === a && "x" === t || "horizontal" === a && "y" === t)) return o.continuousBandSize
+                                if ("bar" === e && (!Ba(i) || !i.bin && !i.timeUnit) && ("vertical" === a && "x" === t || "horizontal" === a && "y" === t)) return o.continuousBandSize
                             }
-                            if (e === Yr.POINT) return n.pointPadding
+                            if (e === eo.POINT) return n.pointPadding
                         }
                         return
                     }(e, n, o.scale, i, r, o.bar)
                 },
                 paddingInner: t => {
                     let {
                         scalePadding: e,
@@ -12666,17 +12781,17 @@
                         if (xn(e)) {
                             const {
                                 bandPaddingInner: t,
                                 barBandPaddingInner: e,
                                 rectBandPaddingInner: i,
                                 bandWithNestedOffsetPaddingInner: a
                             } = r;
-                            return o ? a : zt(t, "bar" === n ? e : i)
+                            return o ? a : Rt(t, "bar" === n ? e : i)
                         }
-                        if (Dn(e) && i === Yr.BAND) return r.offsetBandPaddingInner;
+                        if (An(e) && i === eo.BAND) return r.offsetBandPaddingInner;
                         return
                     }(e, n, i.type, r, o.scale, a)
                 },
                 paddingOuter: t => {
                     let {
                         scalePadding: e,
                         channel: n,
@@ -12690,214 +12805,214 @@
                         if (void 0 !== t) return;
                         if (xn(e)) {
                             const {
                                 bandPaddingOuter: t,
                                 bandWithNestedOffsetPaddingOuter: e
                             } = r;
                             if (o) return e;
-                            if (n === Yr.BAND) return zt(t, li(i) ? {
+                            if (n === eo.BAND) return Rt(t, li(i) ? {
                                 signal: "".concat(i.signal, "/2")
                             } : i / 2)
-                        } else if (Dn(e)) {
-                            if (n === Yr.POINT) return .5;
-                            if (n === Yr.BAND) return r.offsetBandPaddingOuter
+                        } else if (An(e)) {
+                            if (n === eo.POINT) return .5;
+                            if (n === eo.BAND) return r.offsetBandPaddingOuter
                         }
                         return
                     }(e, n, i, r, o.scale, a)
                 },
                 reverse: t => {
                     let {
                         fieldOrDatumDef: e,
                         scaleType: n,
                         channel: i,
                         config: r
                     } = t;
                     return function(t, e, n, i) {
-                        if ("x" === n && void 0 !== i.xReverse) return co(t) && "descending" === e ? li(i.xReverse) ? {
+                        if ("x" === n && void 0 !== i.xReverse) return po(t) && "descending" === e ? li(i.xReverse) ? {
                             signal: "!".concat(i.xReverse.signal)
                         } : !i.xReverse : i.xReverse;
-                        if (co(t) && "descending" === e) return !0;
+                        if (po(t) && "descending" === e) return !0;
                         return
-                    }(n, Na(e) ? e.sort : void 0, i, r.scale)
+                    }(n, Ba(e) ? e.sort : void 0, i, r.scale)
                 },
                 zero: t => {
                     let {
                         channel: e,
                         fieldOrDatumDef: n,
                         domain: i,
                         markDef: r,
                         scaleType: o,
                         config: a,
                         hasSecondaryRangeChannel: s
                     } = t;
                     return function(t, e, n, i, r, o, a) {
-                        if (n && "unaggregated" !== n && co(r)) {
+                        if (n && "unaggregated" !== n && po(r)) {
                             if ((0, U.kJ)(n)) {
                                 const t = n[0],
                                     e = n[n.length - 1];
                                 if (t <= 0 && e >= 0) return !0
                             }
                             return !1
                         }
-                        if ("size" === t && "quantitative" === e.type && !uo(r)) return !0;
-                        if ((!Na(e) || !e.bin) && st([...bn, ...wn], t)) {
+                        if ("size" === t && "quantitative" === e.type && !go(r)) return !0;
+                        if ((!Ba(e) || !e.bin) && st([...bn, ...wn], t)) {
                             const {
                                 orient: e,
                                 type: n
                             } = i;
                             return (!st(["bar", "area", "line", "trail"], n) || !("horizontal" === e && "y" === t || "vertical" === e && "x" === t)) && (!(!st(["bar", "area"], n) || a) || (null === o || void 0 === o ? void 0 : o.zero))
                         }
                         return !1
                     }(e, n, i, r, o, a.scale, s)
                 }
             };
 
-            function op(t) {
-                fp(t) ? function(t) {
+            function hp(t) {
+                bp(t) ? function(t) {
                     const e = t.component.scales;
                     for (const n of Ln) {
                         const i = e[n];
                         if (!i) continue;
-                        const r = Zh(n, t);
+                        const r = ip(n, t);
                         i.setWithExplicit("range", r)
                     }
-                }(t) : ap(t, "range")
+                }(t) : pp(t, "range")
             }
 
-            function ap(t, e) {
+            function pp(t, e) {
                 const n = t.component.scales;
-                for (const i of t.children) "range" === e ? op(i) : ip(i, e);
+                for (const i of t.children) "range" === e ? hp(i) : fp(i, e);
                 for (const i of bt(n)) {
                     let r;
                     for (const n of t.children) {
                         const t = n.component.scales[i];
                         if (t) {
-                            r = Hl(r, t.getWithExplicit(e), e, "scale", ql(((t, n) => "range" === e && t.step && n.step ? t.step - n.step : 0)))
+                            r = Yl(r, t.getWithExplicit(e), e, "scale", Zl(((t, n) => "range" === e && t.step && n.step ? t.step - n.step : 0)))
                         }
                     }
                     n[i].setWithExplicit(e, r)
                 }
             }
 
-            function sp(t, e, n, i) {
+            function mp(t, e, n, i) {
                 const r = function(t, e, n, i) {
                         switch (e.type) {
                             case "nominal":
                             case "ordinal":
                                 var r;
                                 if (Oe(t) || "discrete" === Wn(t)) return "shape" === t && "ordinal" === e.type && dr(Qi(t, "ordinal")), "ordinal";
-                                if (xn(t) || Dn(t)) {
+                                if (xn(t) || An(t)) {
                                     if (st(["rect", "bar", "image", "rule"], n.type)) return "band";
                                     if (i) return "band"
                                 } else if ("arc" === n.type && t in _n) return "band";
-                                return Jo(n[Ye(t)]) || Wa(e) && null !== (r = e.axis) && void 0 !== r && r.tickBand ? "band" : "point";
+                                return Vo(n[Ye(t)]) || Za(e) && null !== (r = e.axis) && void 0 !== r && r.tickBand ? "band" : "point";
                             case "temporal":
-                                return Oe(t) ? "time" : "discrete" === Wn(t) ? (dr(Qi(t, "temporal")), "ordinal") : Na(e) && e.timeUnit && Cr(e.timeUnit).utc ? "utc" : "time";
+                                return Oe(t) ? "time" : "discrete" === Wn(t) ? (dr(Qi(t, "temporal")), "ordinal") : Ba(e) && e.timeUnit && Or(e.timeUnit).utc ? "utc" : "time";
                             case "quantitative":
-                                return Oe(t) ? Na(e) && ti(e.bin) ? "bin-ordinal" : "linear" : "discrete" === Wn(t) ? (dr(Qi(t, "quantitative")), "ordinal") : "linear";
+                                return Oe(t) ? Ba(e) && ti(e.bin) ? "bin-ordinal" : "linear" : "discrete" === Wn(t) ? (dr(Qi(t, "quantitative")), "ordinal") : "linear";
                             case "geojson":
                                 return
                         }
-                        throw new Error(Ji(e.type))
+                        throw new Error(Gi(e.type))
                     }(e, n, i, arguments.length > 4 && void 0 !== arguments[4] && arguments[4]),
                     {
                         type: o
                     } = t;
-                return jn(e) ? void 0 !== o ? function(t, e) {
+                return Bn(e) ? void 0 !== o ? function(t, e) {
                     let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
-                    if (!jn(t)) return !1;
+                    if (!Bn(t)) return !1;
                     switch (t) {
                         case Xt:
-                        case Jt:
-                        case Zt:
+                        case Gt:
+                        case $t:
                         case Yt:
                         case Qt:
                         case Vt:
-                            return !!lo(e) || "band" === e || "point" === e && !n;
+                            return !!mo(e) || "band" === e || "point" === e && !n;
                         case le:
                         case pe:
                         case fe:
                         case de:
                         case he:
                         case ue:
-                            return lo(e) || uo(e) || st(["band", "point", "ordinal"], e);
+                            return mo(e) || go(e) || st(["band", "point", "ordinal"], e);
                         case oe:
                         case ae:
                         case se:
                             return "band" !== e;
                         case me:
                         case ce:
-                            return "ordinal" === e || uo(e)
+                            return "ordinal" === e || go(e)
                     }
-                }(e, o) ? Na(n) && (a = o, s = n.type, !(st([Jr, $r], s) ? void 0 === a || so(a) : s === Gr ? st([Yr.TIME, Yr.UTC, void 0], a) : s !== Xr || io(a) || uo(a) || void 0 === a)) ? (dr(function(t, e) {
+                }(e, o) ? Ba(n) && (a = o, s = n.type, !(st([Vr, Qr], s) ? void 0 === a || ho(a) : s === Kr ? st([eo.TIME, eo.UTC, void 0], a) : s !== Yr || co(a) || go(a) || void 0 === a)) ? (dr(function(t, e) {
                     return 'FieldDef does not work with "'.concat(t, '" scale. We are using "').concat(e, '" scale instead.')
                 }(o, r)), r) : o : (dr(function(t, e, n) {
                     return 'Channel "'.concat(t, '" does not work with "').concat(e, '" scale. We are using "').concat(n, '" scale instead.')
                 }(e, o, r)), r) : r : null;
                 var a, s
             }
 
-            function cp(t) {
-                fp(t) ? t.component.scales = function(t) {
+            function gp(t) {
+                bp(t) ? t.component.scales = function(t) {
                     const {
                         encoding: e,
                         mark: n,
                         markDef: i
                     } = t, r = {};
                     for (const a of Ln) {
-                        const s = is(e[a]);
-                        if (s && n === jo && a === ce && s.type === Zr) continue;
+                        const s = cs(e[a]);
+                        if (s && n === Wo && a === ce && s.type === to) continue;
                         let c = s && s.scale;
-                        if (Dn(a)) {
-                            if (!Ds(e, Qe(a))) {
+                        if (An(a)) {
+                            if (!Fs(e, Qe(a))) {
                                 c && dr(Yi(a));
                                 continue
                             }
                         }
                         if (s && null !== c && !1 !== c) {
                             var o;
                             null !== (o = c) && void 0 !== o || (c = {});
-                            const n = sp(c, a, s, i, Ds(e, a));
-                            r[a] = new Jh(t.scaleName("".concat(a), !0), {
+                            const n = mp(c, a, s, i, Fs(e, a));
+                            r[a] = new tp(t.scaleName("".concat(a), !0), {
                                 value: n,
                                 explicit: c.type === n
                             })
                         }
                     }
                     return r
                 }(t) : t.component.scales = function(t) {
                     var e;
                     const n = t.component.scales = {},
                         i = {},
                         r = t.component.resolve;
                     for (const a of t.children) {
-                        cp(a);
+                        gp(a);
                         for (const n of bt(a.component.scales)) {
                             var o;
-                            if (null !== (o = (e = r.scale)[n]) && void 0 !== o || (e[n] = vd(n, t)), "shared" === r.scale[n]) {
+                            if (null !== (o = (e = r.scale)[n]) && void 0 !== o || (e[n] = Ad(n, t)), "shared" === r.scale[n]) {
                                 const t = i[n],
                                     e = a.component.scales[n].getWithExplicit("type");
-                                t ? Kr(t.value, e.value) ? i[n] = Hl(t, e, "type", "scale", lp) : (r.scale[n] = "independent", delete i[n]) : i[n] = e
+                                t ? io(t.value, e.value) ? i[n] = Yl(t, e, "type", "scale", vp) : (r.scale[n] = "independent", delete i[n]) : i[n] = e
                             }
                         }
                     }
                     for (const a of bt(i)) {
                         const e = t.scaleName(a, !0),
                             r = i[a];
-                        n[a] = new Jh(e, r);
+                        n[a] = new tp(e, r);
                         for (const n of t.children) {
                             const t = n.component.scales[a];
                             t && (n.renameScale(t.get("name"), e), t.merged = !0)
                         }
                     }
                     return n
                 }(t)
             }
-            const lp = ql(((t, e) => to(t) - to(e)));
-            class up {
+            const vp = Zl(((t, e) => oo(t) - oo(e)));
+            class yp {
                 constructor() {
                     this.nameMap = {}
                 }
                 rename(t, e) {
                     this.nameMap[t] = e
                 }
                 has(t) {
@@ -12905,48 +13020,48 @@
                 }
                 get(t) {
                     for (; this.nameMap[t] && t !== this.nameMap[t];) t = this.nameMap[t];
                     return t
                 }
             }
 
-            function fp(t) {
+            function bp(t) {
                 return "unit" === (null === t || void 0 === t ? void 0 : t.type)
             }
 
-            function dp(t) {
+            function xp(t) {
                 return "facet" === (null === t || void 0 === t ? void 0 : t.type)
             }
 
-            function hp(t) {
+            function _p(t) {
                 return "concat" === (null === t || void 0 === t ? void 0 : t.type)
             }
 
-            function pp(t) {
+            function wp(t) {
                 return "layer" === (null === t || void 0 === t ? void 0 : t.type)
             }
-            class mp {
+            class kp {
                 constructor(t, e, n, i, r, o, a) {
                     var s, c;
                     this.type = e, this.parent = n, this.config = r, this.correctDataNames = t => {
                         var e, n, i;
                         return null !== (e = t.from) && void 0 !== e && e.data && (t.from.data = this.lookupDataSource(t.from.data)), null !== (n = t.from) && void 0 !== n && null !== (i = n.facet) && void 0 !== i && i.data && (t.from.facet.data = this.lookupDataSource(t.from.facet.data)), t
                     }, this.parent = n, this.config = r, this.view = ai(a), this.name = null !== (s = t.name) && void 0 !== s ? s : i, this.title = ci(t.title) ? {
                         text: t.title
-                    } : t.title ? ai(t.title) : void 0, this.scaleNameMap = n ? n.scaleNameMap : new up, this.projectionNameMap = n ? n.projectionNameMap : new up, this.signalNameMap = n ? n.signalNameMap : new up, this.data = t.data, this.description = t.description, this.transforms = (null !== (c = t.transform) && void 0 !== c ? c : []).map((t => sl(t) ? {
-                        filter: K(t.filter, Ur)
+                    } : t.title ? ai(t.title) : void 0, this.scaleNameMap = n ? n.scaleNameMap : new yp, this.projectionNameMap = n ? n.projectionNameMap : new yp, this.signalNameMap = n ? n.signalNameMap : new yp, this.data = t.data, this.description = t.description, this.transforms = (null !== (c = t.transform) && void 0 !== c ? c : []).map((t => dl(t) ? {
+                        filter: K(t.filter, Gr)
                     } : t)), this.layout = "layer" === e || "unit" === e ? {} : function(t, e, n) {
                         const i = n[e],
                             r = {},
                             {
                                 spacing: o,
                                 columns: a
                             } = i;
-                        void 0 !== o && (r.spacing = o), void 0 !== a && (ka(t) && !_a(t.facet) || mc(t)) && (r.columns = a), gc(t) && (r.columns = 1);
-                        for (const l of _c)
+                        void 0 !== o && (r.spacing = o), void 0 !== a && (Ca(t) && !Da(t.facet) || xc(t)) && (r.columns = a), _c(t) && (r.columns = 1);
+                        for (const l of Dc)
                             if (void 0 !== t[l])
                                 if ("spacing" === l) {
                                     var s, c;
                                     const e = t[l];
                                     r[l] = (0, U.hj)(e) ? e : {
                                         row: null !== (s = e.row) && void 0 !== s ? s : o,
                                         column: null !== (c = e.column) && void 0 !== c ? c : o
@@ -12954,17 +13069,17 @@
                                 } else r[l] = t[l];
                         return r
                     }(t, e, r), this.component = {
                         data: {
                             sources: n ? n.component.data.sources : [],
                             outputNodes: n ? n.component.data.outputNodes : {},
                             outputNodeRefCounts: n ? n.component.data.outputNodeRefCounts : {},
-                            isFaceted: ka(t) || (null === n || void 0 === n ? void 0 : n.component.data.isFaceted) && void 0 === t.data
+                            isFaceted: Ca(t) || (null === n || void 0 === n ? void 0 : n.component.data.isFaceted) && void 0 === t.data
                         },
-                        layoutSize: new Bl,
+                        layoutSize: new Xl,
                         layoutHeaders: {
                             row: {},
                             column: {},
                             facet: {}
                         },
                         mark: null,
                         resolve: {
@@ -12990,27 +13105,27 @@
                     this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup()
                 }
                 parseScale() {
                     ! function(t) {
                         let {
                             ignoreRange: e
                         } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
-                        cp(t), Nh(t);
-                        for (const n of _o) ip(t, n);
-                        e || op(t)
+                        gp(t), Uh(t);
+                        for (const n of Do) fp(t, n);
+                        e || hp(t)
                     }(this)
                 }
                 parseProjection() {
-                    Ud(this)
+                    $d(this)
                 }
                 renameTopLevelLayoutSizeSignal() {
                     "width" !== this.getName("width") && this.renameSignal(this.getName("width"), "width"), "height" !== this.getName("height") && this.renameSignal(this.getName("height"), "height")
                 }
                 parseLegends() {
-                    Od(this)
+                    Id(this)
                 }
                 assembleEncodeFromView(t) {
                     const {
                         style: e,
                         ...n
                     } = t, i = {};
                     for (const r of bt(n)) {
@@ -13041,15 +13156,15 @@
                         const n = {};
                         for (const i of Ne) {
                             const r = t[i];
                             if (null !== r && void 0 !== r && r.facetFieldDef) {
                                 const {
                                     titleAnchor: t,
                                     titleOrient: o
-                                } = Kf(["titleAnchor", "titleOrient"], r.facetFieldDef.header, e, i), a = Yf(i, o), s = ld(t, a);
+                                } = ad(["titleAnchor", "titleOrient"], r.facetFieldDef.header, e, i), a = rd(i, o), s = vd(t, a);
                                 void 0 !== s && (n[a] = s)
                             }
                         }
                         return yt(n) ? void 0 : n
                     }(n.layoutHeaders, i);
                     return {
                         padding: t,
@@ -13064,32 +13179,32 @@
                     return {}
                 }
                 assembleHeaderMarks() {
                     const {
                         layoutHeaders: t
                     } = this.component;
                     let e = [];
-                    for (const n of Ne) t[n].title && e.push(ed(this, n));
-                    for (const n of Qf) e = e.concat(rd(this, n));
+                    for (const n of Ne) t[n].title && e.push(ld(this, n));
+                    for (const n of sd) e = e.concat(dd(this, n));
                     return e
                 }
                 assembleAxes() {
                     return function(t, e) {
                         const {
                             x: n = [],
                             y: i = []
                         } = t;
-                        return [...n.map((t => jf(t, "grid", e))), ...i.map((t => jf(t, "grid", e))), ...n.map((t => jf(t, "main", e))), ...i.map((t => jf(t, "main", e)))].filter((t => t))
+                        return [...n.map((t => Gf(t, "grid", e))), ...i.map((t => Gf(t, "grid", e))), ...n.map((t => Gf(t, "main", e))), ...i.map((t => Gf(t, "main", e)))].filter((t => t))
                     }(this.component.axes, this.config)
                 }
                 assembleLegends() {
-                    return Pd(this)
+                    return Hd(this)
                 }
                 assembleProjections() {
-                    return Ld(this)
+                    return Xd(this)
                 }
                 assembleTitle() {
                     var t;
                     const {
                         encoding: e,
                         ...n
                     } = null !== (t = this.title) && void 0 !== t ? t : {}, i = {
@@ -13111,45 +13226,45 @@
                 }
                 assembleGroup() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                     const e = {};
                     t = t.concat(this.assembleSignals()), t.length > 0 && (e.signals = t);
                     const n = this.assembleLayout();
                     n && (e.layout = n), e.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
-                    const i = !this.parent || dp(this.parent) ? Hh(this) : [];
+                    const i = !this.parent || xp(this.parent) ? Kh(this) : [];
                     i.length > 0 && (e.scales = i);
                     const r = this.assembleAxes();
                     r.length > 0 && (e.axes = r);
                     const o = this.assembleLegends();
                     return o.length > 0 && (e.legends = o), e
                 }
                 getName(t) {
                     return kt((this.name ? "".concat(this.name, "_") : "") + t)
                 }
                 getDataName(t) {
-                    return this.getName(Ql[t].toLowerCase())
+                    return this.getName(ou[t].toLowerCase())
                 }
                 requestDataName(t) {
                     const e = this.getDataName(t),
                         n = this.component.data.outputNodeRefCounts;
                     return n[e] = (n[e] || 0) + 1, e
                 }
                 getSizeSignalRef(t) {
-                    if (dp(this.parent)) {
-                        const e = kn(md(t)),
+                    if (xp(this.parent)) {
+                        const e = kn(kd(t)),
                             n = this.component.scales[e];
                         if (n && !n.merged) {
                             const t = n.get("type"),
                                 i = n.get("range");
-                            if (so(t) && ui(i)) {
+                            if (ho(t) && ui(i)) {
                                 const t = n.get("name"),
-                                    i = qh(Wh(this, e));
+                                    i = Yh(Vh(this, e));
                                 if (i) {
                                     return {
-                                        signal: pd(t, n, Ga({
+                                        signal: wd(t, n, Ka({
                                             aggregate: "distinct",
                                             field: i
                                         }, {
                                             expr: "datum"
                                         }))
                                     }
                                 }
@@ -13174,15 +13289,15 @@
                 renameScale(t, e) {
                     this.scaleNameMap.rename(t, e)
                 }
                 renameProjection(t, e) {
                     this.projectionNameMap.rename(t, e)
                 }
                 scaleName(t, e) {
-                    return e ? this.getName(t) : He(t) && jn(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t)) ? this.scaleNameMap.get(this.getName(t)) : void 0
+                    return e ? this.getName(t) : He(t) && Bn(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t)) ? this.scaleNameMap.get(this.getName(t)) : void 0
                 }
                 projectionName(t) {
                     return t ? this.getName("projection") : this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")) ? this.projectionNameMap.get(this.getName("projection")) : void 0
                 }
                 getScaleComponent(t) {
                     if (!this.component.scales) throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
                     const e = this.component.scales[t];
@@ -13194,41 +13309,41 @@
                     return n
                 }
                 hasAxisOrientSignalRef() {
                     var t, e;
                     return (null === (t = this.component.axes.x) || void 0 === t ? void 0 : t.some((t => t.hasOrientSignalRef()))) || (null === (e = this.component.axes.y) || void 0 === e ? void 0 : e.some((t => t.hasOrientSignalRef())))
                 }
             }
-            class gp extends mp {
+            class Ep extends kp {
                 vgField(t) {
                     let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                     const n = this.fieldDef(t);
-                    if (n) return Ga(n, e)
+                    if (n) return Ka(n, e)
                 }
                 reduceFieldDef(t, e) {
                     return function(t, e, n, i) {
                         return t ? bt(t).reduce(((n, r) => {
                             const o = t[r];
                             return (0, U.kJ)(o) ? o.reduce(((t, n) => e.call(i, t, n, r)), n) : e.call(i, n, o, r)
                         }), n) : n
                     }(this.getMapping(), ((e, n, i) => {
-                        const r = ns(n);
+                        const r = ss(n);
                         return r ? t(e, r, i) : e
                     }), e)
                 }
                 forEachFieldDef(t, e) {
-                    Ms(this.getMapping(), ((e, n) => {
-                        const i = ns(e);
+                    zs(this.getMapping(), ((e, n) => {
+                        const i = ss(e);
                         i && t(i, n)
                     }), e)
                 }
             }
-            class vp extends su {
+            class Ap extends hu {
                 clone() {
-                    return new vp(null, tt(this.transform))
+                    return new Ap(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     var n, i, r;
                     super(t), this.transform = e, this.transform = tt(e);
                     const o = null !== (n = this.transform.as) && void 0 !== n ? n : [void 0, void 0];
                     this.transform.as = [null !== (i = o[0]) && void 0 !== i ? i : "value", null !== (r = o[1]) && void 0 !== r ? r : "density"], e.groupby && null == e.minsteps && null == e.maxsteps && null == e.steps && (this.transform.steps = 200)
                 }
@@ -13250,65 +13365,93 @@
                     return {
                         type: "kde",
                         field: t,
                         ...e
                     }
                 }
             }
-            class yp extends su {
+            class Dp extends hu {
+                clone() {
+                    return new Dp(null, tt(this.transform))
+                }
+                constructor(t, e) {
+                    super(t), this.transform = e, this.transform = tt(e)
+                }
+                dependentFields() {
+                    return new Set([this.transform.extent])
+                }
+                producedFields() {
+                    return new Set([])
+                }
+                hash() {
+                    return "ExtentTransform ".concat(ot(this.transform))
+                }
+                assemble() {
+                    const {
+                        extent: t,
+                        param: e
+                    } = this.transform;
+                    return {
+                        type: "extent",
+                        field: t,
+                        signal: e
+                    }
+                }
+            }
+            class Sp extends hu {
                 clone() {
-                    return new yp(null, {
+                    return new Sp(null, {
                         ...this.filter
                     })
                 }
                 constructor(t, e) {
                     super(t), this.filter = e
                 }
                 static make(t, e) {
                     const {
                         config: n,
                         mark: i,
                         markDef: r
                     } = e;
                     if ("filter" !== ki("invalid", r, n)) return null;
                     const o = e.reduceFieldDef(((t, n, r) => {
-                        const o = jn(r) && e.getScaleComponent(r);
+                        const o = Bn(r) && e.getScaleComponent(r);
                         if (o) {
-                            co(o.get("type")) && "count" !== n.aggregate && !Bo(i) && (t[n.field] = n)
+                            po(o.get("type")) && "count" !== n.aggregate && !Ho(i) && (t[n.field] = n)
                         }
                         return t
                     }), {});
-                    return bt(o).length ? new yp(t, o) : null
+                    return bt(o).length ? new Sp(t, o) : null
                 }
                 dependentFields() {
                     return new Set(bt(this.filter))
                 }
                 producedFields() {
                     return new Set
                 }
                 hash() {
                     return "FilterInvalid ".concat(ot(this.filter))
                 }
                 assemble() {
                     const t = bt(this.filter).reduce(((t, e) => {
                         const n = this.filter[e],
-                            i = Ga(n, {
+                            i = Ka(n, {
                                 expr: "datum"
                             });
                         return null !== n && ("temporal" === n.type ? t.push("(isDate(".concat(i, ") || (isValid(").concat(i, ") && isFinite(+").concat(i, ")))")) : "quantitative" === n.type && (t.push("isValid(".concat(i, ")")), t.push("isFinite(+".concat(i, ")")))), t
                     }), []);
                     return t.length > 0 ? {
                         type: "filter",
                         expr: t.join(" && ")
                     } : null
                 }
             }
-            class bp extends su {
+            class Cp extends hu {
                 clone() {
-                    return new bp(this.parent, tt(this.transform))
+                    return new Cp(this.parent, tt(this.transform))
                 }
                 constructor(t, e) {
                     super(t), this.transform = e, this.transform = tt(e);
                     const {
                         flatten: n,
                         as: i = []
                     } = this.transform;
@@ -13334,17 +13477,17 @@
                     return {
                         type: "flatten",
                         fields: t,
                         as: e
                     }
                 }
             }
-            class xp extends su {
+            class Mp extends hu {
                 clone() {
-                    return new xp(null, tt(this.transform))
+                    return new Mp(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     var n, i, r;
                     super(t), this.transform = e, this.transform = tt(e);
                     const o = null !== (n = this.transform.as) && void 0 !== n ? n : [void 0, void 0];
                     this.transform.as = [null !== (i = o[0]) && void 0 !== i ? i : "key", null !== (r = o[1]) && void 0 !== r ? r : "value"]
                 }
@@ -13365,38 +13508,38 @@
                     return {
                         type: "fold",
                         fields: t,
                         as: e
                     }
                 }
             }
-            class _p extends su {
+            class Fp extends hu {
                 clone() {
-                    return new _p(null, tt(this.fields), this.geojson, this.signal)
+                    return new Fp(null, tt(this.fields), this.geojson, this.signal)
                 }
                 static parseAll(t, e) {
                     if (e.component.projection && !e.component.projection.isFit) return t;
                     let n = 0;
                     for (const i of [
                             [ne, ee],
                             [re, ie]
                         ]) {
                         const r = i.map((t => {
-                            const n = is(e.encoding[t]);
-                            return Na(n) ? n.field : Ra(n) ? {
+                            const n = cs(e.encoding[t]);
+                            return Ba(n) ? n.field : ja(n) ? {
                                 expr: "".concat(n.datum)
-                            } : Ua(n) ? {
+                            } : Ga(n) ? {
                                 expr: "".concat(n.value)
                             } : void 0
                         }));
-                        (r[0] || r[1]) && (t = new _p(t, r, null, e.getName("geojson_".concat(n++))))
+                        (r[0] || r[1]) && (t = new Fp(t, r, null, e.getName("geojson_".concat(n++))))
                     }
                     if (e.channelHasField(ce)) {
                         const i = e.typedFieldDef(ce);
-                        i.type === Zr && (t = new _p(t, null, i.field, e.getName("geojson_".concat(n++))))
+                        i.type === to && (t = new Fp(t, null, i.field, e.getName("geojson_".concat(n++))))
                     }
                     return t
                 }
                 constructor(t, e, n, i) {
                     super(t), this.fields = e, this.geojson = n, this.signal = i
                 }
                 dependentFields() {
@@ -13422,37 +13565,37 @@
                         ...this.geojson ? {
                             geojson: this.geojson
                         } : {},
                         signal: this.signal
                     }]
                 }
             }
-            class wp extends su {
+            class Op extends hu {
                 clone() {
-                    return new wp(null, this.projection, tt(this.fields), tt(this.as))
+                    return new Op(null, this.projection, tt(this.fields), tt(this.as))
                 }
                 constructor(t, e, n, i) {
                     super(t), this.projection = e, this.fields = n, this.as = i
                 }
                 static parseAll(t, e) {
                     if (!e.projectionName()) return t;
                     for (const n of [
                             [ne, ee],
                             [re, ie]
                         ]) {
                         const i = n.map((t => {
-                                const n = is(e.encoding[t]);
-                                return Na(n) ? n.field : Ra(n) ? {
+                                const n = cs(e.encoding[t]);
+                                return Ba(n) ? n.field : ja(n) ? {
                                     expr: "".concat(n.datum)
-                                } : Ua(n) ? {
+                                } : Ga(n) ? {
                                     expr: "".concat(n.value)
                                 } : void 0
                             })),
                             r = n[0] === re ? "2" : "";
-                        (i[0] || i[1]) && (t = new wp(t, e.projectionName(), i, [e.getName("x".concat(r)), e.getName("y".concat(r))]))
+                        (i[0] || i[1]) && (t = new Op(t, e.projectionName(), i, [e.getName("x".concat(r)), e.getName("y".concat(r))]))
                     }
                     return t
                 }
                 dependentFields() {
                     return new Set(this.fields.filter(U.HD))
                 }
                 producedFields() {
@@ -13466,17 +13609,17 @@
                         type: "geopoint",
                         projection: this.projection,
                         fields: this.fields,
                         as: this.as
                     }
                 }
             }
-            class kp extends su {
+            class Tp extends hu {
                 clone() {
-                    return new kp(null, tt(this.transform))
+                    return new Tp(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     super(t), this.transform = e
                 }
                 dependentFields() {
                     var t;
                     return new Set([this.transform.impute, this.transform.key, ...null !== (t = this.transform.groupby) && void 0 !== t ? t : []])
@@ -13491,32 +13634,32 @@
                         step: i
                     } = t, r = [e, n, ...i ? [i] : []].join(",");
                     return {
                         signal: "sequence(".concat(r, ")")
                     }
                 }
                 static makeFromTransform(t, e) {
-                    return new kp(t, e)
+                    return new Tp(t, e)
                 }
                 static makeFromEncoding(t, e) {
                     const n = e.encoding,
                         i = n.x,
                         r = n.y;
-                    if (Na(i) && Na(r)) {
+                    if (Ba(i) && Ba(r)) {
                         const o = i.impute ? i : r.impute ? r : void 0;
                         if (void 0 === o) return;
                         const a = i.impute ? r : r.impute ? i : void 0,
                             {
                                 method: s,
                                 value: c,
                                 frame: l,
                                 keyvals: u
                             } = o.impute,
-                            f = Os(e.mark, n);
-                        return new kp(t, {
+                            f = Ps(e.mark, n);
+                        return new Tp(t, {
                             impute: o.field,
                             key: a.field,
                             ...s ? {
                                 method: s
                             } : {},
                             ...void 0 !== c ? {
                                 value: c
@@ -13547,15 +13690,15 @@
                         value: o,
                         frame: a = [null, null]
                     } = this.transform, s = {
                         type: "impute",
                         field: t,
                         key: e,
                         ...n ? {
-                            keyvals: cl(n) ? this.processSequence(n) : n
+                            keyvals: hl(n) ? this.processSequence(n) : n
                         } : {},
                         method: "value",
                         ...r ? {
                             groupby: r
                         } : {},
                         value: i && "value" !== i ? null : o
                     };
@@ -13575,17 +13718,17 @@
                             expr: "datum.".concat(t, " === null ? datum.imputed_").concat(t, "_value : datum.").concat(t),
                             as: t
                         }]
                     }
                     return [s]
                 }
             }
-            class Ep extends su {
+            class Np extends hu {
                 clone() {
-                    return new Ep(null, tt(this.transform))
+                    return new Np(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     var n, i, r;
                     super(t), this.transform = e, this.transform = tt(e);
                     const o = null !== (n = this.transform.as) && void 0 !== n ? n : [void 0, void 0];
                     this.transform.as = [null !== (i = o[0]) && void 0 !== i ? i : e.on, null !== (r = o[1]) && void 0 !== r ? r : e.loess]
                 }
@@ -13609,34 +13752,34 @@
                         type: "loess",
                         x: e,
                         y: t,
                         ...n
                     }
                 }
             }
-            class Dp extends su {
+            class Rp extends hu {
                 clone() {
-                    return new Dp(null, tt(this.transform), this.secondary)
+                    return new Rp(null, tt(this.transform), this.secondary)
                 }
                 constructor(t, e, n) {
                     super(t), this.transform = e, this.secondary = n
                 }
                 static make(t, e, n, i) {
                     const r = e.component.data.sources,
                         {
                             from: o
                         } = n;
                     let a = null;
                     if (function(t) {
                             return "data" in t
                         }(o)) {
-                        let t = Ip(o.data, r);
-                        t || (t = new ih(o.data), r.push(t));
+                        let t = $p(o.data, r);
+                        t || (t = new fh(o.data), r.push(t));
                         const n = e.getName("lookup_".concat(i));
-                        a = new cu(t, n, Ql.Lookup, e.component.data.outputNodeRefCounts), e.component.data.outputNodes[n] = a
+                        a = new pu(t, n, ou.Lookup, e.component.data.outputNodeRefCounts), e.component.data.outputNodes[n] = a
                     } else if (function(t) {
                             return "param" in t
                         }(o)) {
                         const t = o.param;
                         let i;
                         n = {
                             as: t,
@@ -13647,15 +13790,15 @@
                         } catch (s) {
                             throw new Error('Lookups can only be performed on selection parameters. "'.concat(t, '" is a variable parameter.'))
                         }
                         if (a = i.materialized, !a) throw new Error(function(t) {
                             return 'Cannot define and lookup the "'.concat(t, '" selection in the same view. ') + "Try moving the lookup into a second, layered view?"
                         }(t))
                     }
-                    return new Dp(t, n, a.getSource())
+                    return new Rp(t, n, a.getSource())
                 }
                 dependentFields() {
                     return new Set([this.transform.lookup])
                 }
                 producedFields() {
                     return new Set(this.transform.as ? (0, U.IX)(this.transform.as) : this.transform.from.fields)
                 }
@@ -13687,17 +13830,17 @@
                         ...t,
                         ...this.transform.default ? {
                             default: this.transform.default
                         } : {}
                     }
                 }
             }
-            class Ap extends su {
+            class zp extends hu {
                 clone() {
-                    return new Ap(null, tt(this.transform))
+                    return new zp(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     var n, i, r;
                     super(t), this.transform = e, this.transform = tt(e);
                     const o = null !== (n = this.transform.as) && void 0 !== n ? n : [void 0, void 0];
                     this.transform.as = [null !== (i = o[0]) && void 0 !== i ? i : "prob", null !== (r = o[1]) && void 0 !== r ? r : "value"]
                 }
@@ -13719,17 +13862,17 @@
                     return {
                         type: "quantile",
                         field: t,
                         ...e
                     }
                 }
             }
-            class Sp extends su {
+            class Pp extends hu {
                 clone() {
-                    return new Sp(null, tt(this.transform))
+                    return new Pp(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     var n, i, r;
                     super(t), this.transform = e, this.transform = tt(e);
                     const o = null !== (n = this.transform.as) && void 0 !== n ? n : [void 0, void 0];
                     this.transform.as = [null !== (i = o[0]) && void 0 !== i ? i : e.on, null !== (r = o[1]) && void 0 !== r ? r : e.regression]
                 }
@@ -13753,17 +13896,17 @@
                         type: "regression",
                         x: e,
                         y: t,
                         ...n
                     }
                 }
             }
-            class Cp extends su {
+            class Lp extends hu {
                 clone() {
-                    return new Cp(null, tt(this.transform))
+                    return new Lp(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     super(t), this.transform = e
                 }
                 addDimensions(t) {
                     var e;
                     this.transform.groupby = dt((null !== (e = this.transform.groupby) && void 0 !== e ? e : []).concat(t), (t => t))
@@ -13796,17 +13939,17 @@
                         } : {},
                         ...void 0 !== n ? {
                             groupby: n
                         } : {}
                     }
                 }
             }
-            class Fp extends su {
+            class Bp extends hu {
                 clone() {
-                    return new Fp(null, tt(this.transform))
+                    return new Bp(null, tt(this.transform))
                 }
                 constructor(t, e) {
                     super(t), this.transform = e
                 }
                 dependentFields() {
                     return new Set
                 }
@@ -13820,44 +13963,44 @@
                     return {
                         type: "sample",
                         size: this.transform.sample
                     }
                 }
             }
 
-            function Mp(t) {
+            function Ip(t) {
                 let e = 0;
                 return function n(i, r) {
-                    if (i instanceof ih && !i.isGenerator && !Jl(i.data)) {
+                    if (i instanceof fh && !i.isGenerator && !Kl(i.data)) {
                         t.push(r);
                         r = {
                             name: null,
                             source: r.name,
                             transform: []
                         }
                     }
                     var o;
-                    if (i instanceof Qd && (i.parent instanceof ih && !r.source ? (r.format = {
+                    if (i instanceof sh && (i.parent instanceof fh && !r.source ? (r.format = {
                             ...null !== (o = r.format) && void 0 !== o ? o : {},
                             parse: i.assembleFormatParse()
-                        }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof Zd) return r.name || (r.name = "data_".concat(e++)), !r.source || r.transform.length > 0 ? (t.push(r), i.data = r.name) : i.data = r.source, void t.push(...i.assemble());
-                    if ((i instanceof eh || i instanceof nh || i instanceof yp || i instanceof Nf || i instanceof $f || i instanceof wp || i instanceof $d || i instanceof Dp || i instanceof Eh || i instanceof wh || i instanceof xp || i instanceof bp || i instanceof vp || i instanceof Ep || i instanceof Ap || i instanceof Sp || i instanceof th || i instanceof Fp || i instanceof Cp) && r.transform.push(i.assemble()), (i instanceof Jd || i instanceof lu || i instanceof kp || i instanceof kh || i instanceof _p) && r.transform.push(...i.assemble()), i instanceof cu)
+                        }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof ih) return r.name || (r.name = "data_".concat(e++)), !r.source || r.transform.length > 0 ? (t.push(r), i.data = r.name) : i.data = r.source, void t.push(...i.assemble());
+                    if ((i instanceof lh || i instanceof uh || i instanceof Sp || i instanceof Uf || i instanceof nd || i instanceof Op || i instanceof nh || i instanceof Rp || i instanceof Th || i instanceof Fh || i instanceof Mp || i instanceof Cp || i instanceof Ap || i instanceof Np || i instanceof zp || i instanceof Pp || i instanceof ch || i instanceof Bp || i instanceof Lp || i instanceof Dp) && r.transform.push(i.assemble()), (i instanceof th || i instanceof vu || i instanceof Tp || i instanceof Oh || i instanceof Fp) && r.transform.push(...i.assemble()), i instanceof pu)
                         if (r.source && 0 === r.transform.length) i.setSource(r.source);
-                        else if (i.parent instanceof cu) i.setSource(r.name);
+                        else if (i.parent instanceof pu) i.setSource(r.name);
                     else if (r.name || (r.name = "data_".concat(e++)), i.setSource(r.name), 1 === i.numChildren()) {
                         t.push(r);
                         r = {
                             name: null,
                             source: r.name,
                             transform: []
                         }
                     }
                     switch (i.numChildren()) {
                         case 0:
-                            i instanceof cu && (!r.source || r.transform.length > 0) && t.push(r);
+                            i instanceof pu && (!r.source || r.transform.length > 0) && t.push(r);
                             break;
                         case 1:
                             n(i.children[0], r);
                             break;
                         default: {
                             r.name || (r.name = "data_".concat(e++));
                             let o = r.name;
@@ -13871,216 +14014,216 @@
                             }
                             break
                         }
                     }
                 }
             }
 
-            function Op(t) {
+            function jp(t) {
                 return "top" === t || "left" === t || li(t) ? "header" : "footer"
             }
 
-            function Tp(t, e) {
+            function Up(t, e) {
                 const {
                     facet: n,
                     config: i,
                     child: r,
                     component: o
                 } = t;
                 if (t.channelHasField(e)) {
                     var a;
                     const s = n[e],
-                        c = Vf("title", null, i, e);
-                    let l = Ka(s, i, {
+                        c = od("title", null, i, e);
+                    let l = is(s, i, {
                         allowDisabling: !0,
                         includeDefault: void 0 === c || !!c
                     });
                     r.component.layoutHeaders[e].title && (l = (0, U.kJ)(l) ? l.join(", ") : l, l += " / ".concat(r.component.layoutHeaders[e].title), r.component.layoutHeaders[e].title = null);
-                    const u = Vf("labelOrient", s.header, i, e),
-                        f = null !== s.header && zt(null === (a = s.header) || void 0 === a ? void 0 : a.labels, i.header.labels, !0),
+                    const u = od("labelOrient", s.header, i, e),
+                        f = null !== s.header && Rt(null === (a = s.header) || void 0 === a ? void 0 : a.labels, i.header.labels, !0),
                         d = st(["bottom", "right"], u) ? "footer" : "header";
                     o.layoutHeaders[e] = {
                         title: null !== s.header ? l : null,
                         facetFieldDef: s,
-                        [d]: "facet" === e ? [] : [Np(t, e, f)]
+                        [d]: "facet" === e ? [] : [qp(t, e, f)]
                     }
                 }
             }
 
-            function Np(t, e, n) {
+            function qp(t, e, n) {
                 const i = "row" === e ? "height" : "width";
                 return {
                     labels: n,
                     sizeSignal: t.child.component.layoutSize.get(i) ? t.child.getSizeSignalRef(i) : void 0,
                     axes: []
                 }
             }
 
-            function zp(t, e) {
+            function Wp(t, e) {
                 const {
                     child: n
                 } = t;
                 if (n.component.axes[e]) {
                     const {
                         layoutHeaders: r,
                         resolve: o
                     } = t.component;
-                    if (o.axis[e] = yd(o, e), "shared" === o.axis[e]) {
+                    if (o.axis[e] = Dd(o, e), "shared" === o.axis[e]) {
                         const o = "x" === e ? "column" : "row",
                             a = r[o];
                         for (const r of n.component.axes[e]) {
                             var i;
-                            const e = Op(r.get("orient"));
-                            null !== (i = a[e]) && void 0 !== i || (a[e] = [Np(t, o, !1)]);
-                            const n = jf(r, "main", t.config, {
+                            const e = jp(r.get("orient"));
+                            null !== (i = a[e]) && void 0 !== i || (a[e] = [qp(t, o, !1)]);
+                            const n = Gf(r, "main", t.config, {
                                 header: !0
                             });
                             n && a[e][0].axes.push(n), r.mainExtracted = !0
                         }
                     }
                 }
             }
 
-            function Rp(t) {
+            function Hp(t) {
                 for (const e of t.children) e.parseLayoutSize()
             }
 
-            function Pp(t, e) {
-                const n = md(e),
+            function Xp(t, e) {
+                const n = kd(e),
                     i = kn(n),
                     r = t.component.resolve,
                     o = t.component.layoutSize;
                 let a;
                 for (const c of t.children) {
                     var s;
                     const e = c.component.layoutSize.getWithExplicit(n),
-                        o = null !== (s = r.scale[i]) && void 0 !== s ? s : vd(i, t);
+                        o = null !== (s = r.scale[i]) && void 0 !== s ? s : Ad(i, t);
                     if ("independent" === o && "step" === e.value) {
                         a = void 0;
                         break
                     }
                     if (a) {
                         if ("independent" === o && a.value !== e.value) {
                             a = void 0;
                             break
                         }
-                        a = Hl(a, e, n, "")
+                        a = Yl(a, e, n, "")
                     } else a = e
                 }
                 if (a) {
                     for (const i of t.children) t.renameSignal(i.getName(n), t.getName(e)), i.component.layoutSize.set(n, "merged", !1);
                     o.setWithExplicit(e, a)
                 } else o.setWithExplicit(e, {
                     explicit: !1,
                     value: void 0
                 })
             }
 
-            function Lp(t, e) {
+            function Gp(t, e) {
                 const n = "width" === e ? "x" : "y",
                     i = t.config,
                     r = t.getScaleComponent(n);
                 if (r) {
                     const t = r.get("type"),
                         n = r.get("range");
-                    if (so(t)) {
-                        const t = Ec(i.view, e);
-                        return ui(n) || bc(t) ? "step" : t
+                    if (ho(t)) {
+                        const t = Mc(i.view, e);
+                        return ui(n) || Ec(t) ? "step" : t
                     }
-                    return wc(i.view, e)
+                    return Sc(i.view, e)
                 }
-                if (t.hasProjection || "arc" === t.mark) return wc(i.view, e);
+                if (t.hasProjection || "arc" === t.mark) return Sc(i.view, e);
                 {
-                    const t = Ec(i.view, e);
-                    return bc(t) ? t.step : t
+                    const t = Mc(i.view, e);
+                    return Ec(t) ? t.step : t
                 }
             }
 
-            function jp(t, e, n) {
-                return Ga(e, {
-                    suffix: "by_".concat(Ga(t)),
+            function Jp(t, e, n) {
+                return Ka(e, {
+                    suffix: "by_".concat(Ka(t)),
                     ...null !== n && void 0 !== n ? n : {}
                 })
             }
-            class Bp extends gp {
+            class Zp extends Ep {
                 constructor(t, e, n, i) {
-                    super(t, "facet", e, n, i, t.resolve), this.child = hm(t.spec, this, this.getName("child"), void 0, i), this.children = [this.child], this.facet = this.initFacet(t.facet)
+                    super(t, "facet", e, n, i, t.resolve), this.child = wm(t.spec, this, this.getName("child"), void 0, i), this.children = [this.child], this.facet = this.initFacet(t.facet)
                 }
                 initFacet(t) {
-                    if (!_a(t)) return {
+                    if (!Da(t)) return {
                         facet: this.initFacetFieldDef(t, "facet")
                     };
                     const e = bt(t),
                         n = {};
                     for (const i of e) {
                         if (![qt, Wt].includes(i)) {
-                            dr(Zi(i, "facet"));
+                            dr($i(i, "facet"));
                             break
                         }
                         const e = t[i];
                         if (void 0 === e.field) {
-                            dr($i(e, i));
+                            dr(Zi(e, i));
                             break
                         }
                         n[i] = this.initFacetFieldDef(e, i)
                     }
                     return n
                 }
                 initFacetFieldDef(t, e) {
-                    const n = as(t, e);
+                    const n = fs(t, e);
                     return n.header ? n.header = ai(n.header) : null === n.header && (n.header = null), n
                 }
                 channelHasField(t) {
                     return !!this.facet[t]
                 }
                 fieldDef(t) {
                     return this.facet[t]
                 }
                 parseData() {
-                    this.component.data = Up(this), this.child.parseData()
+                    this.component.data = Yp(this), this.child.parseData()
                 }
                 parseLayoutSize() {
-                    Rp(this)
+                    Hp(this)
                 }
                 parseSelections() {
                     this.child.parseSelections(), this.component.selection = this.child.component.selection
                 }
                 parseMarkGroup() {
                     this.child.parseMarkGroup()
                 }
                 parseAxesAndHeaders() {
                     this.child.parseAxesAndHeaders(),
                         function(t) {
-                            for (const e of Ne) Tp(t, e);
-                            zp(t, "x"), zp(t, "y")
+                            for (const e of Ne) Up(t, e);
+                            Wp(t, "x"), Wp(t, "y")
                         }(this)
                 }
                 assembleSelectionTopLevelSignals(t) {
                     return this.child.assembleSelectionTopLevelSignals(t)
                 }
                 assembleSignals() {
                     return this.child.assembleSignals(), []
                 }
                 assembleSelectionData(t) {
                     return this.child.assembleSelectionData(t)
                 }
                 getHeaderLayoutMixins() {
                     const t = {};
                     for (const r of Ne)
-                        for (const o of td) {
+                        for (const o of cd) {
                             const a = this.component.layoutHeaders[r],
                                 s = a[o],
                                 {
                                     facetFieldDef: c
                                 } = a;
                             if (c) {
-                                const n = Vf("titleOrient", c.header, this.config, r);
+                                const n = od("titleOrient", c.header, this.config, r);
                                 if (["right", "bottom"].includes(n)) {
                                     var e;
-                                    const i = Yf(r, n);
+                                    const i = rd(r, n);
                                     null !== (e = t.titleAnchor) && void 0 !== e || (t.titleAnchor = {}), t.titleAnchor[i] = "end"
                                 }
                             }
                             if (null !== s && void 0 !== s && s[0]) {
                                 const e = "row" === r ? "height" : "width",
                                     s = "header" === o ? "headerBand" : "footerBand";
                                 var n, i;
@@ -14105,55 +14248,55 @@
                         align: i
                     }
                 }
                 assembleLayoutSignals() {
                     return this.child.assembleLayoutSignals()
                 }
                 columnDistinctSignal() {
-                    if (!(this.parent && this.parent instanceof Bp)) {
+                    if (!(this.parent && this.parent instanceof Zp)) {
                         const t = this.getName("column_domain");
                         return {
                             signal: "length(data('".concat(t, "'))")
                         }
                     }
                 }
                 assembleGroupStyle() {}
                 assembleGroup(t) {
-                    return this.parent && this.parent instanceof Bp ? {
+                    return this.parent && this.parent instanceof Zp ? {
                         ...this.channelHasField("column") ? {
                             encode: {
                                 update: {
                                     columns: {
-                                        field: Ga(this.facet.column, {
+                                        field: Ka(this.facet.column, {
                                             prefix: "distinct"
                                         })
                                     }
                                 }
                             }
                         } : {},
                         ...super.assembleGroup(t)
                     } : super.assembleGroup(t)
                 }
                 getCardinalityAggregateForChild() {
                     const t = [],
                         e = [],
                         n = [];
-                    if (this.child instanceof Bp) {
+                    if (this.child instanceof Zp) {
                         if (this.child.channelHasField("column")) {
-                            const i = Ga(this.child.facet.column);
+                            const i = Ka(this.child.facet.column);
                             t.push(i), e.push("distinct"), n.push("distinct_".concat(i))
                         }
                     } else
                         for (const i of bn) {
                             const r = this.child.component.scales[i];
                             if (r && !r.merged) {
                                 const o = r.get("type"),
                                     a = r.get("range");
-                                if (so(o) && ui(a)) {
-                                    const r = qh(Wh(this.child, i));
+                                if (ho(o) && ui(a)) {
+                                    const r = Yh(Vh(this.child, i));
                                     r ? (t.push(r), e.push("distinct"), n.push("distinct_".concat(r))) : dr(Pi(i))
                                 }
                             }
                         }
                     return {
                         fields: t,
                         ops: e,
@@ -14171,29 +14314,29 @@
                         fields: r,
                         ops: o,
                         as: a
                     } = this.getCardinalityAggregateForChild(), s = [];
                     for (const l of Ne) {
                         const t = this.facet[l];
                         if (t) {
-                            s.push(Ga(t));
+                            s.push(Ka(t));
                             const {
                                 bin: e,
                                 sort: c
                             } = t;
-                            if (ti(e) && s.push(Ga(t, {
+                            if (ti(e) && s.push(Ka(t, {
                                     binSuffix: "end"
-                                })), ba(c)) {
+                                })), Ea(c)) {
                                 const {
                                     field: e,
-                                    op: s = ma
-                                } = c, l = jp(t, c);
+                                    op: s = xa
+                                } = c, l = Jp(t, c);
                                 n && i ? (r.push(l), o.push("max"), a.push(l)) : (r.push(e), o.push(s), a.push(l))
                             } else if ((0, U.kJ)(c)) {
-                                const e = Zf(t, l);
+                                const e = id(t, l);
                                 r.push(e), o.push("max"), a.push(e)
                             }
                         }
                     }
                     const c = !!n && !!i;
                     return {
                         name: t,
@@ -14213,57 +14356,57 @@
                         } : {}
                     }
                 }
                 facetSortFields(t) {
                     const {
                         facet: e
                     } = this, n = e[t];
-                    return n ? ba(n.sort) ? [jp(n, n.sort, {
+                    return n ? Ea(n.sort) ? [Jp(n, n.sort, {
                         expr: "datum"
-                    })] : (0, U.kJ)(n.sort) ? [Zf(n, t, {
+                    })] : (0, U.kJ)(n.sort) ? [id(n, t, {
                         expr: "datum"
-                    })] : [Ga(n, {
+                    })] : [Ka(n, {
                         expr: "datum"
                     })] : []
                 }
                 facetSortOrder(t) {
                     const {
                         facet: e
                     } = this, n = e[t];
                     if (n) {
                         const {
                             sort: t
                         } = n;
-                        return [(ba(t) ? t.order : !(0, U.kJ)(t) && t) || "ascending"]
+                        return [(Ea(t) ? t.order : !(0, U.kJ)(t) && t) || "ascending"]
                     }
                     return []
                 }
                 assembleLabelTitle() {
                     const {
                         facet: t,
                         config: e
                     } = this;
-                    if (t.facet) return ad(t.facet, "facet", e);
+                    if (t.facet) return pd(t.facet, "facet", e);
                     const n = {
                         row: ["top", "bottom"],
                         column: ["left", "right"]
                     };
-                    for (const r of Qf)
+                    for (const r of sd)
                         if (t[r]) {
                             var i;
-                            const o = Vf("labelOrient", null === (i = t[r]) || void 0 === i ? void 0 : i.header, e, r);
-                            if (n[r].includes(o)) return ad(t[r], r, e)
+                            const o = od("labelOrient", null === (i = t[r]) || void 0 === i ? void 0 : i.header, e, r);
+                            if (n[r].includes(o)) return pd(t[r], r, e)
                         }
                 }
                 assembleMarks() {
                     const {
                         child: t
                     } = this, e = function(t) {
                         const e = [],
-                            n = Mp(e);
+                            n = Ip(e);
                         for (const i of t.children) n(i, {
                             source: t.name,
                             name: null,
                             transform: []
                         });
                         return e
                     }(this.component.data.facetRoot), n = t.assembleGroupEncodeEntry(!1), i = this.assembleLabelTitle() || t.assembleTitle(), r = t.assembleGroupStyle();
@@ -14287,198 +14430,199 @@
                             data: e
                         } : {},
                         ...n ? {
                             encode: {
                                 update: n
                             }
                         } : {},
-                        ...t.assembleGroup(ru(this, []))
+                        ...t.assembleGroup(uu(this, []))
                     }]
                 }
                 getMapping() {
                     return this.facet
                 }
             }
 
-            function Ip(t, e) {
+            function $p(t, e) {
                 for (const a of e) {
                     var n, i, r, o;
                     const e = a.data;
                     if (t.name && a.hasName() && t.name !== a.dataName) continue;
                     const s = null === (n = t.format) || void 0 === n ? void 0 : n.mesh,
                         c = null === (i = e.format) || void 0 === i ? void 0 : i.feature;
                     if (s && c) continue;
                     const l = null === (r = t.format) || void 0 === r ? void 0 : r.feature;
                     if ((l || c) && l !== c) continue;
                     const u = null === (o = e.format) || void 0 === o ? void 0 : o.mesh;
                     if (!s && !u || s === u)
-                        if (Gl(t) && Gl(e)) {
+                        if (Ql(t) && Ql(e)) {
                             if (Q(t.values, e.values)) return a
-                        } else if (Jl(t) && Jl(e)) {
+                        } else if (Kl(t) && Kl(e)) {
                         if (t.url === e.url) return a
-                    } else if ($l(t) && t.name === a.dataName) return a
+                    } else if (tu(t) && t.name === a.dataName) return a
                 }
                 return null
             }
 
-            function Up(t) {
+            function Yp(t) {
                 var e, n, i;
                 let r = function(t, e) {
                     if (t.data || !t.parent) {
                         if (null === t.data) {
-                            const t = new ih({
+                            const t = new fh({
                                 values: []
                             });
                             return e.push(t), t
                         }
-                        const n = Ip(t.data, e);
-                        if (n) return Zl(t.data) || (n.data.format = ut({}, t.data.format, n.data.format)), !n.hasName() && t.data.name && (n.dataName = t.data.name), n;
+                        const n = $p(t.data, e);
+                        if (n) return eu(t.data) || (n.data.format = ut({}, t.data.format, n.data.format)), !n.hasName() && t.data.name && (n.dataName = t.data.name), n;
                         {
-                            const n = new ih(t.data);
+                            const n = new fh(t.data);
                             return e.push(n), n
                         }
                     }
                     return t.parent.component.data.facetRoot ? t.parent.component.data.facetRoot : t.parent.component.data.main
                 }(t, t.component.data.sources);
                 const {
                     outputNodes: o,
                     outputNodeRefCounts: a
-                } = t.component.data, s = t.data, c = !(s && (Zl(s) || Jl(s) || Gl(s))) && t.parent ? t.parent.component.data.ancestorParse.clone() : new Xl;
-                Zl(s) ? (Yl(s) ? r = new nh(r, s.sequence) : Kl(s) && (r = new eh(r, s.graticule)), c.parseNothing = !0) : null === (null === s || void 0 === s || null === (e = s.format) || void 0 === e ? void 0 : e.parse) && (c.parseNothing = !0), r = null !== (n = Qd.makeExplicit(r, t, c)) && void 0 !== n ? n : r, r = new th(r);
-                const l = t.parent && pp(t.parent);
+                } = t.component.data, s = t.data, c = !(s && (eu(s) || Kl(s) || Ql(s))) && t.parent ? t.parent.component.data.ancestorParse.clone() : new Vl;
+                eu(s) ? (nu(s) ? r = new uh(r, s.sequence) : ru(s) && (r = new lh(r, s.graticule)), c.parseNothing = !0) : null === (null === s || void 0 === s || null === (e = s.format) || void 0 === e ? void 0 : e.parse) && (c.parseNothing = !0), r = null !== (n = sh.makeExplicit(r, t, c)) && void 0 !== n ? n : r, r = new ch(r);
+                const l = t.parent && wp(t.parent);
                 var u;
-                (fp(t) || dp(t)) && (l && (r = null !== (u = Jd.makeFromEncoding(r, t)) && void 0 !== u ? u : r));
+                (bp(t) || xp(t)) && (l && (r = null !== (u = th.makeFromEncoding(r, t)) && void 0 !== u ? u : r));
                 t.transforms.length > 0 && (r = function(t, e, n) {
                     let i = 0;
                     for (const a of e.transforms) {
                         let s, c;
-                        if (bl(a)) c = t = new $f(t, a), s = "derived";
-                        else if (sl(a)) {
+                        if (El(a)) c = t = new nd(t, a), s = "derived";
+                        else if (dl(a)) {
                             var r;
-                            const i = Vd(a);
-                            c = t = null !== (r = Qd.makeWithAncestors(t, {}, i, n)) && void 0 !== r ? r : t, t = new Nf(t, e, a.filter)
-                        } else if (xl(a)) c = t = Jd.makeFromTransform(t, a, e), s = "number";
-                        else if (wl(a)) s = "date", void 0 === n.getWithExplicit(a.field).value && (t = new Qd(t, {
+                            const i = oh(a);
+                            c = t = null !== (r = sh.makeWithAncestors(t, {}, i, n)) && void 0 !== r ? r : t, t = new Uf(t, e, a.filter)
+                        } else if (Al(a)) c = t = th.makeFromTransform(t, a, e), s = "number";
+                        else if (Sl(a)) s = "date", void 0 === n.getWithExplicit(a.field).value && (t = new sh(t, {
                             [a.field]: s
-                        }), n.set(a.field, s, !1)), c = t = lu.makeFromTransform(t, a);
-                        else if (kl(a)) c = t = $d.makeFromTransform(t, a), s = "number", Sf(e) && (t = new th(t));
-                        else if (ll(a)) c = t = Dp.make(t, e, a, i++), s = "derived";
-                        else if (gl(a)) c = t = new Eh(t, a), s = "number";
-                        else if (vl(a)) c = t = new wh(t, a), s = "number";
-                        else if (El(a)) c = t = kh.makeFromTransform(t, a), s = "derived";
-                        else if (Dl(a)) c = t = new xp(t, a), s = "derived";
-                        else if (yl(a)) c = t = new bp(t, a), s = "derived";
-                        else if (ul(a)) c = t = new Cp(t, a), s = "derived";
-                        else if (ml(a)) t = new Fp(t, a);
-                        else if (_l(a)) c = t = kp.makeFromTransform(t, a), s = "derived";
-                        else if (fl(a)) c = t = new vp(t, a), s = "derived";
-                        else if (dl(a)) c = t = new Ap(t, a), s = "derived";
-                        else if (hl(a)) c = t = new Sp(t, a), s = "derived";
+                        }), n.set(a.field, s, !1)), c = t = vu.makeFromTransform(t, a);
+                        else if (Cl(a)) c = t = nh.makeFromTransform(t, a), s = "number", zf(e) && (t = new ch(t));
+                        else if (pl(a)) c = t = Rp.make(t, e, a, i++), s = "derived";
+                        else if (_l(a)) c = t = new Th(t, a), s = "number";
+                        else if (wl(a)) c = t = new Fh(t, a), s = "number";
+                        else if (Ml(a)) c = t = Oh.makeFromTransform(t, a), s = "derived";
+                        else if (Fl(a)) c = t = new Mp(t, a), s = "derived";
+                        else if (Ol(a)) c = t = new Dp(t, a), s = "derived";
+                        else if (kl(a)) c = t = new Cp(t, a), s = "derived";
+                        else if (ml(a)) c = t = new Lp(t, a), s = "derived";
+                        else if (xl(a)) t = new Bp(t, a);
+                        else if (Dl(a)) c = t = Tp.makeFromTransform(t, a), s = "derived";
+                        else if (gl(a)) c = t = new Ap(t, a), s = "derived";
+                        else if (vl(a)) c = t = new zp(t, a), s = "derived";
+                        else if (yl(a)) c = t = new Pp(t, a), s = "derived";
                         else {
-                            if (!pl(a)) {
+                            if (!bl(a)) {
                                 dr("Ignoring an invalid transform: ".concat(rt(a), "."));
                                 continue
                             }
-                            c = t = new Ep(t, a), s = "derived"
+                            c = t = new Np(t, a), s = "derived"
                         }
                         if (c && void 0 !== s)
                             for (const t of null !== (o = c.producedFields()) && void 0 !== o ? o : []) {
                                 var o;
                                 n.set(t, s, !1)
                             }
                     }
                     return t
                 }(r, t, c));
                 const f = function(t) {
                         const e = {};
-                        if (fp(t) && t.component.selection)
+                        if (bp(t) && t.component.selection)
                             for (const n of bt(t.component.selection)) {
                                 const i = t.component.selection[n];
                                 for (const t of i.project.items) !t.channel && Nt(t.field) > 1 && (e[t.field] = "flatten")
                             }
                         return e
                     }(t),
-                    d = Kd(t);
-                if (r = null !== (i = Qd.makeWithAncestors(r, {}, {
+                    d = ah(t);
+                if (r = null !== (i = sh.makeWithAncestors(r, {}, {
                         ...f,
                         ...d
-                    }, c)) && void 0 !== i ? i : r, fp(t) && (r = _p.parseAll(r, t), r = wp.parseAll(r, t)), fp(t) || dp(t)) {
+                    }, c)) && void 0 !== i ? i : r, bp(t) && (r = Fp.parseAll(r, t), r = Op.parseAll(r, t)), bp(t) || xp(t)) {
                     var h, p;
-                    if (!l) r = null !== (p = Jd.makeFromEncoding(r, t)) && void 0 !== p ? p : r;
-                    r = null !== (h = lu.makeFromEncoding(r, t)) && void 0 !== h ? h : r, r = $f.parseAllForSortIndex(r, t)
+                    if (!l) r = null !== (p = th.makeFromEncoding(r, t)) && void 0 !== p ? p : r;
+                    r = null !== (h = vu.makeFromEncoding(r, t)) && void 0 !== h ? h : r, r = nd.parseAllForSortIndex(r, t)
                 }
-                const m = t.getDataName(Ql.Raw),
-                    g = new cu(r, m, Ql.Raw, a);
-                if (o[m] = g, r = g, fp(t)) {
+                const m = t.getDataName(ou.Raw),
+                    g = new pu(r, m, ou.Raw, a);
+                if (o[m] = g, r = g, bp(t)) {
                     var v, y;
-                    const e = $d.makeFromEncoding(r, t);
-                    e && (r = e, Sf(t) && (r = new th(r))), r = null !== (v = kp.makeFromEncoding(r, t)) && void 0 !== v ? v : r, r = null !== (y = kh.makeFromEncoding(r, t)) && void 0 !== y ? y : r
+                    const e = nh.makeFromEncoding(r, t);
+                    e && (r = e, zf(t) && (r = new ch(r))), r = null !== (v = Tp.makeFromEncoding(r, t)) && void 0 !== v ? v : r, r = null !== (y = Oh.makeFromEncoding(r, t)) && void 0 !== y ? y : r
                 }
                 var b;
-                fp(t) && (r = null !== (b = yp.make(r, t)) && void 0 !== b ? b : r);
-                const x = t.getDataName(Ql.Main),
-                    _ = new cu(r, x, Ql.Main, a);
-                o[x] = _, r = _, fp(t) && function(t, e) {
+                bp(t) && (r = null !== (b = Sp.make(r, t)) && void 0 !== b ? b : r);
+                const x = t.getDataName(ou.Main),
+                    _ = new pu(r, x, ou.Main, a);
+                o[x] = _, r = _, bp(t) && function(t, e) {
                     for (const [i, r] of _t(null !== (n = t.component.selection) && void 0 !== n ? n : {})) {
                         var n;
                         const o = t.getName("lookup_".concat(i));
-                        t.component.data.outputNodes[o] = r.materialized = new cu(new Nf(e, t, {
+                        t.component.data.outputNodes[o] = r.materialized = new pu(new Uf(e, t, {
                             param: i
-                        }), o, Ql.Lookup, t.component.data.outputNodeRefCounts)
+                        }), o, ou.Lookup, t.component.data.outputNodeRefCounts)
                     }
                 }(t, _);
                 let w = null;
-                if (dp(t)) {
+                if (xp(t)) {
                     var k;
                     const e = t.getName("facet");
                     r = null !== (k = function(t, e) {
                         const {
                             row: n,
                             column: i
                         } = e;
                         if (n && i) {
                             let e = null;
                             for (const r of [n, i])
-                                if (ba(r.sort)) {
+                                if (Ea(r.sort)) {
                                     const {
                                         field: n,
-                                        op: i = ma
+                                        op: i = xa
                                     } = r.sort;
-                                    t = e = new wh(t, {
+                                    t = e = new Fh(t, {
                                         joinaggregate: [{
                                             op: i,
                                             field: n,
-                                            as: jp(r, r.sort, {
+                                            as: Jp(r, r.sort, {
                                                 forAs: !0
                                             })
                                         }],
-                                        groupby: [Ga(r)]
+                                        groupby: [Ka(r)]
                                     })
                                 } return e
                         }
                         return null
-                    }(r, t.facet)) && void 0 !== k ? k : r, w = new Zd(r, t, e, _.getSource()), o[e] = w
+                    }(r, t.facet)) && void 0 !== k ? k : r, w = new ih(r, t, e, _.getSource()), o[e] = w
                 }
                 return {
                     ...t.component.data,
                     outputNodes: o,
                     outputNodeRefCounts: a,
                     raw: g,
                     main: _,
                     facetRoot: w,
                     ancestorParse: c
                 }
             }
-            class qp extends mp {
+            class Vp extends kp {
                 constructor(t, e, n, i) {
                     var r, o, a, s;
-                    super(t, "concat", e, n, i, t.resolve), "shared" !== (null === (r = t.resolve) || void 0 === r || null === (o = r.axis) || void 0 === o ? void 0 : o.x) && "shared" !== (null === (a = t.resolve) || void 0 === a || null === (s = a.axis) || void 0 === s ? void 0 : s.y) || dr("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415)."), this.children = this.getChildren(t).map(((t, e) => hm(t, this, this.getName("concat_".concat(e)), void 0, i)))
+                    super(t, "concat", e, n, i, t.resolve), "shared" !== (null === (r = t.resolve) || void 0 === r || null === (o = r.axis) || void 0 === o ? void 0 : o.x) && "shared" !== (null === (a = t.resolve) || void 0 === a || null === (s = a.axis) || void 0 === s ? void 0 : s.y) || dr("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415)."), this.children = this.getChildren(t).map(((t, e) => wm(t, this, this.getName("concat_".concat(e)), void 0, i)))
                 }
                 parseData() {
-                    this.component.data = Up(this);
+                    this.component.data = Yp(this);
                     for (const t of this.children) t.parseData()
                 }
                 parseSelections() {
                     this.component.selection = {};
                     for (const t of this.children) {
                         t.parseSelections();
                         for (const e of bt(t.component.selection)) this.component.selection[e] = t.component.selection[e]
@@ -14487,35 +14631,35 @@
                 parseMarkGroup() {
                     for (const t of this.children) t.parseMarkGroup()
                 }
                 parseAxesAndHeaders() {
                     for (const t of this.children) t.parseAxesAndHeaders()
                 }
                 getChildren(t) {
-                    return gc(t) ? t.vconcat : vc(t) ? t.hconcat : t.concat
+                    return _c(t) ? t.vconcat : wc(t) ? t.hconcat : t.concat
                 }
                 parseLayoutSize() {
                     ! function(t) {
-                        Rp(t);
+                        Hp(t);
                         const e = 1 === t.layout.columns ? "width" : "childWidth",
                             n = void 0 === t.layout.columns ? "height" : "childHeight";
-                        Pp(t, e), Pp(t, n)
+                        Xp(t, e), Xp(t, n)
                     }(this)
                 }
                 parseAxisGroup() {
                     return null
                 }
                 assembleSelectionTopLevelSignals(t) {
                     return this.children.reduce(((t, e) => e.assembleSelectionTopLevelSignals(t)), t)
                 }
                 assembleSignals() {
                     return this.children.forEach((t => t.assembleSignals())), []
                 }
                 assembleLayoutSignals() {
-                    const t = fd(this);
+                    const t = bd(this);
                     for (const e of this.children) t.push(...e.assembleLayoutSignals());
                     return t
                 }
                 assembleSelectionData(t) {
                     return this.children.reduce(((t, e) => e.assembleSelectionData(t)), t)
                 }
                 assembleMarks() {
@@ -14549,218 +14693,218 @@
                             columns: t
                         } : {},
                         bounds: "full",
                         align: "each"
                     }
                 }
             }
-            const Wp = {
+            const Kp = {
                     disable: 1,
                     gridScale: 1,
                     scale: 1,
-                    ...vs,
+                    ...ws,
                     labelExpr: 1,
                     encode: 1
                 },
-                Hp = bt(Wp);
-            class Xp extends Bl {
+                Qp = bt(Kp);
+            class tm extends Xl {
                 constructor() {
                     let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                         e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                         n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                     super(), this.explicit = t, this.implicit = e, this.mainExtracted = n
                 }
                 clone() {
-                    return new Xp(tt(this.explicit), tt(this.implicit), this.mainExtracted)
+                    return new tm(tt(this.explicit), tt(this.implicit), this.mainExtracted)
                 }
                 hasAxisPart(t) {
                     return "axis" === t || ("grid" === t || "title" === t ? !!this.get(t) : !(!1 === (e = this.get(t)) || null === e));
                     var e
                 }
                 hasOrientSignalRef() {
                     return li(this.explicit.orient)
                 }
             }
-            const Jp = {
+            const em = {
                 bottom: "top",
                 top: "bottom",
                 left: "right",
                 right: "left"
             };
 
-            function Gp(t, e) {
+            function nm(t, e) {
                 if (!t) return e.map((t => t.clone()));
                 {
                     if (t.length !== e.length) return;
                     const n = t.length;
                     for (let i = 0; i < n; i++) {
                         const n = t[i],
                             r = e[i];
                         if (!!n !== !!r) return;
                         if (n && r) {
                             const e = n.getWithExplicit("orient"),
                                 o = r.getWithExplicit("orient");
                             if (e.explicit && o.explicit && e.value !== o.value) return;
-                            t[i] = $p(n, r)
+                            t[i] = im(n, r)
                         }
                     }
                 }
                 return t
             }
 
-            function $p(t, e) {
-                for (const n of Hp) {
-                    const i = Hl(t.getWithExplicit(n), e.getWithExplicit(n), n, "axis", ((t, e) => {
+            function im(t, e) {
+                for (const n of Qp) {
+                    const i = Yl(t.getWithExplicit(n), e.getWithExplicit(n), n, "axis", ((t, e) => {
                         switch (n) {
                             case "title":
-                                return Mi(t, e);
+                                return Fi(t, e);
                             case "gridScale":
                                 return {
-                                    explicit: t.explicit, value: zt(t.value, e.value)
+                                    explicit: t.explicit, value: Rt(t.value, e.value)
                                 }
                         }
-                        return Wl(t, e, n, "axis")
+                        return $l(t, e, n, "axis")
                     }));
                     t.setWithExplicit(n, i)
                 }
                 return t
             }
 
-            function Zp(t, e, n, i, r) {
+            function rm(t, e, n, i, r) {
                 if ("disable" === e) return void 0 !== n;
                 switch (n = n || {}, e) {
                     case "titleAngle":
                     case "labelAngle":
-                        return t === (li(n.labelAngle) ? n.labelAngle : It(n.labelAngle));
+                        return t === (li(n.labelAngle) ? n.labelAngle : jt(n.labelAngle));
                     case "values":
                         return !!n.values;
                     case "encode":
                         return !!n.encoding || !!n.labelAngle;
                     case "title":
-                        if (t === Gf(i, r)) return !0
+                        if (t === ed(i, r)) return !0
                 }
                 return t === n[e]
             }
-            const Yp = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);
+            const om = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);
 
-            function Vp(t, e) {
+            function am(t, e) {
                 var n, i, r, o, a;
                 let s = e.axis(t);
-                const c = new Xp,
-                    l = is(e.encoding[t]),
+                const c = new tm,
+                    l = cs(e.encoding[t]),
                     {
                         mark: u,
                         config: f
                     } = e,
                     d = (null === (n = s) || void 0 === n ? void 0 : n.orient) || (null === (i = f["x" === t ? "axisX" : "axisY"]) || void 0 === i ? void 0 : i.orient) || (null === (r = f.axis) || void 0 === r ? void 0 : r.orient) || function(t) {
                         return "x" === t ? "bottom" : "left"
                     }(t),
                     h = e.getScaleComponent(t).get("type"),
                     p = function(t, e, n, i) {
-                        const r = "band" === e ? ["axisDiscrete", "axisBand"] : "point" === e ? ["axisDiscrete", "axisPoint"] : io(e) ? ["axisQuantitative"] : "time" === e || "utc" === e ? ["axisTemporal"] : [],
+                        const r = "band" === e ? ["axisDiscrete", "axisBand"] : "point" === e ? ["axisDiscrete", "axisPoint"] : co(e) ? ["axisQuantitative"] : "time" === e || "utc" === e ? ["axisTemporal"] : [],
                             o = "x" === t ? "axisX" : "axisY",
-                            a = li(n) ? "axisOrient" : "axis".concat(At(n)),
+                            a = li(n) ? "axisOrient" : "axis".concat(Dt(n)),
                             s = [...r, ...r.map((t => o + t.substr(4)))],
                             c = ["axis", a, o];
                         return {
-                            vlOnlyAxisConfig: If(s, i, t, n),
-                            vgAxisConfig: If(c, i, t, n),
-                            axisConfigStyle: Uf([...c, ...s], i)
+                            vlOnlyAxisConfig: Zf(s, i, t, n),
+                            vgAxisConfig: Zf(c, i, t, n),
+                            axisConfigStyle: $f([...c, ...s], i)
                         }
                     }(t, h, d, e.config),
-                    m = void 0 !== s ? !s : qf("disable", f.style, null === (o = s) || void 0 === o ? void 0 : o.style, p).configValue;
+                    m = void 0 !== s ? !s : Yf("disable", f.style, null === (o = s) || void 0 === o ? void 0 : o.style, p).configValue;
                 if (c.set("disable", m, void 0 !== s), m) return c;
                 s = s || {};
                 const g = function(t, e, n, i, r) {
                         const o = null === e || void 0 === e ? void 0 : e.labelAngle;
-                        if (void 0 !== o) return li(o) ? o : It(o);
+                        if (void 0 !== o) return li(o) ? o : jt(o);
                         {
                             const {
                                 configValue: o
-                            } = qf("labelAngle", i, null === e || void 0 === e ? void 0 : e.style, r);
-                            return void 0 !== o ? It(o) : n !== Xt || !st([$r, Jr], t.type) || Na(t) && t.timeUnit ? void 0 : 270
+                            } = Yf("labelAngle", i, null === e || void 0 === e ? void 0 : e.style, r);
+                            return void 0 !== o ? jt(o) : n !== Xt || !st([Qr, Vr], t.type) || Ba(t) && t.timeUnit ? void 0 : 270
                         }
                     }(l, s, t, f.style, p),
-                    v = ua(s.formatType, l, h),
-                    y = la(l, l.type, s.format, s.formatType, f, !0),
+                    v = ma(s.formatType, l, h),
+                    y = pa(l, l.type, s.format, s.formatType, f, !0),
                     b = {
                         fieldOrDatumDef: l,
                         axis: s,
                         channel: t,
                         model: e,
                         scaleType: h,
                         orient: d,
                         labelAngle: g,
                         format: y,
                         formatType: v,
                         mark: u,
                         config: f
                     };
-                for (const w of Hp) {
-                    const n = w in Wf ? Wf[w](b) : bs(w) ? s[w] : void 0,
+                for (const w of Qp) {
+                    const n = w in Vf ? Vf[w](b) : Es(w) ? s[w] : void 0,
                         i = void 0 !== n,
-                        r = Zp(n, w, s, e, t);
+                        r = rm(n, w, s, e, t);
                     if (i && r) c.set(w, n, r);
                     else {
                         const {
                             configValue: t,
                             configFrom: e
-                        } = bs(w) && "values" !== w ? qf(w, f.style, s.style, p) : {}, o = void 0 !== t;
-                        i && !o ? c.set(w, n, r) : ("vgAxisConfig" !== e || Yp.has(w) && o || ps(t) || li(t)) && c.set(w, t, !1)
+                        } = Es(w) && "values" !== w ? Yf(w, f.style, s.style, p) : {}, o = void 0 !== t;
+                        i && !o ? c.set(w, n, r) : ("vgAxisConfig" !== e || om.has(w) && o || bs(t) || li(t)) && c.set(w, t, !1)
                     }
                 }
                 const x = null !== (a = s.encoding) && void 0 !== a ? a : {},
-                    _ = ms.reduce(((n, i) => {
+                    _ = xs.reduce(((n, i) => {
                         var r;
                         if (!c.hasAxisPart(i)) return n;
-                        const o = gd(null !== (r = x[i]) && void 0 !== r ? r : {}, e),
+                        const o = Ed(null !== (r = x[i]) && void 0 !== r ? r : {}, e),
                             a = "labels" === i ? function(t, e, n) {
                                 var i;
                                 const {
                                     encoding: r,
                                     config: o
-                                } = t, a = null !== (i = is(r[e])) && void 0 !== i ? i : is(r[Ze(e)]), s = t.axis(e) || {}, {
+                                } = t, a = null !== (i = cs(r[e])) && void 0 !== i ? i : cs(r[$e(e)]), s = t.axis(e) || {}, {
                                     format: c,
                                     formatType: l
                                 } = s;
-                                if (ia(l)) return {
-                                    text: ca({
+                                if (ca(l)) return {
+                                    text: ha({
                                         fieldOrDatumDef: a,
                                         field: "datum.value",
                                         format: c,
                                         formatType: l,
                                         config: o
                                     }),
                                     ...n
                                 };
                                 if (void 0 === c && void 0 === l && o.customFormatTypes) {
-                                    if ("quantitative" === za(a)) {
-                                        if (Wa(a) && "normalize" === a.stack && o.normalizedNumberFormatType) return {
-                                            text: ca({
+                                    if ("quantitative" === Ia(a)) {
+                                        if (Za(a) && "normalize" === a.stack && o.normalizedNumberFormatType) return {
+                                            text: ha({
                                                 fieldOrDatumDef: a,
                                                 field: "datum.value",
                                                 format: o.normalizedNumberFormat,
                                                 formatType: o.normalizedNumberFormatType,
                                                 config: o
                                             }),
                                             ...n
                                         };
                                         if (o.numberFormatType) return {
-                                            text: ca({
+                                            text: ha({
                                                 fieldOrDatumDef: a,
                                                 field: "datum.value",
                                                 format: o.numberFormat,
                                                 formatType: o.numberFormatType,
                                                 config: o
                                             }),
                                             ...n
                                         }
                                     }
-                                    if ("temporal" === za(a) && o.timeFormatType && Na(a) && !a.timeUnit) return {
-                                        text: ca({
+                                    if ("temporal" === Ia(a) && o.timeFormatType && Ba(a) && !a.timeUnit) return {
+                                        text: ha({
                                             fieldOrDatumDef: a,
                                             field: "datum.value",
                                             format: o.timeFormat,
                                             formatType: o.timeFormatType,
                                             config: o
                                         }),
                                         ...n
@@ -14771,278 +14915,278 @@
                         return void 0 === a || yt(a) || (n[i] = {
                             update: a
                         }), n
                     }), {});
                 return yt(_) || c.set("encode", _, !!s.encoding || void 0 !== s.labelAngle), c
             }
 
-            function Kp(t, e, n) {
+            function sm(t, e, n) {
                 const i = ai(t),
                     r = ki("orient", i, n);
                 var o, a;
                 if (i.orient = function(t, e, n) {
                         switch (t) {
-                            case Mo:
+                            case zo:
+                            case Uo:
+                            case qo:
+                            case Bo:
                             case Po:
-                            case Lo:
                             case No:
-                            case Oo:
-                            case Co:
                                 return
                         }
                         const {
                             x: i,
                             y: r,
                             x2: o,
                             y2: a
                         } = e;
                         switch (t) {
-                            case So:
-                                if (Na(i) && (ei(i.bin) || Na(r) && r.aggregate && !i.aggregate)) return "vertical";
-                                if (Na(r) && (ei(r.bin) || Na(i) && i.aggregate && !r.aggregate)) return "horizontal";
+                            case To:
+                                if (Ba(i) && (ei(i.bin) || Ba(r) && r.aggregate && !i.aggregate)) return "vertical";
+                                if (Ba(r) && (ei(r.bin) || Ba(i) && i.aggregate && !r.aggregate)) return "horizontal";
                                 if (a || o) {
                                     if (n) return n;
-                                    if (!o) return (Na(i) && i.type === Xr && !ti(i.bin) || ja(i)) && Na(r) && ei(r.bin) ? "horizontal" : "vertical";
-                                    if (!a) return (Na(r) && r.type === Xr && !ti(r.bin) || ja(r)) && Na(i) && ei(i.bin) ? "vertical" : "horizontal"
+                                    if (!o) return (Ba(i) && i.type === Yr && !ti(i.bin) || Wa(i)) && Ba(r) && ei(r.bin) ? "horizontal" : "vertical";
+                                    if (!a) return (Ba(r) && r.type === Yr && !ti(r.bin) || Wa(r)) && Ba(i) && ei(i.bin) ? "vertical" : "horizontal"
                                 }
-                            case To:
-                                if (o && (!Na(i) || !ei(i.bin)) && a && (!Na(r) || !ei(r.bin))) return;
-                            case Ao:
-                                if (a) return Na(r) && ei(r.bin) ? "horizontal" : "vertical";
-                                if (o) return Na(i) && ei(i.bin) ? "vertical" : "horizontal";
-                                if (t === To) {
+                            case Lo:
+                                if (o && (!Ba(i) || !ei(i.bin)) && a && (!Ba(r) || !ei(r.bin))) return;
+                            case Oo:
+                                if (a) return Ba(r) && ei(r.bin) ? "horizontal" : "vertical";
+                                if (o) return Ba(i) && ei(i.bin) ? "vertical" : "horizontal";
+                                if (t === Lo) {
                                     if (i && !r) return "vertical";
                                     if (r && !i) return "horizontal"
                                 }
-                            case Fo:
-                            case zo: {
-                                const e = La(i),
-                                    o = La(r);
+                            case Ro:
+                            case Io: {
+                                const e = qa(i),
+                                    o = qa(r);
                                 if (n) return n;
                                 if (e && !o) return "tick" !== t ? "horizontal" : "vertical";
                                 if (!e && o) return "tick" !== t ? "vertical" : "horizontal";
                                 if (e && o) return "vertical";
                                 {
-                                    const t = Ia(i) && i.type === Gr,
-                                        e = Ia(r) && r.type === Gr;
+                                    const t = Xa(i) && i.type === Kr,
+                                        e = Xa(r) && r.type === Kr;
                                     if (t && !e) return "vertical";
                                     if (!t && e) return "horizontal"
                                 }
                                 return
                             }
                         }
                         return "vertical"
                     }(i.type, e, r), void 0 !== r && r !== i.orient && dr((o = i.orient, a = r, 'Specified orient "'.concat(o, '" overridden with "').concat(a, '".'))), "bar" === i.type && i.orient) {
                     const t = ki("cornerRadiusEnd", i, n);
                     if (void 0 !== t) {
-                        const n = "horizontal" === i.orient && e.x2 || "vertical" === i.orient && e.y2 ? ["cornerRadius"] : Go[i.orient];
+                        const n = "horizontal" === i.orient && e.x2 || "vertical" === i.orient && e.y2 ? ["cornerRadius"] : Ko[i.orient];
                         for (const e of n) i[e] = t;
                         void 0 !== i.cornerRadiusEnd && delete i.cornerRadiusEnd
                     }
                 }
                 void 0 === ki("opacity", i, n) && (i.opacity = function(t, e) {
-                    if (st([Mo, zo, Po, Lo], t) && !As(e)) return .7;
+                    if (st([zo, Io, Uo, qo], t) && !Os(e)) return .7;
                     return
                 }(i.type, e));
                 return void 0 === ki("cursor", i, n) && (i.cursor = function(t, e, n) {
                     if (e.href || t.href || ki("href", t, n)) return "pointer";
                     return t.cursor
                 }(i, e, n)), i
             }
 
-            function Qp(t, e) {
+            function cm(t, e) {
                 const {
                     config: n
                 } = t;
                 return {
-                    ...Ku(t, {
+                    ...sf(t, {
                         align: "ignore",
                         baseline: "ignore",
                         color: "include",
                         size: "include",
                         orient: "ignore",
                         theta: "ignore"
                     }),
-                    ...Bu("x", t, {
+                    ...Ju("x", t, {
                         defaultPos: "mid"
                     }),
-                    ...Bu("y", t, {
+                    ...Ju("y", t, {
                         defaultPos: "mid"
                     }),
-                    ...Ru("size", t),
-                    ...Ru("angle", t),
-                    ...tm(t, n, e)
+                    ...Wu("size", t),
+                    ...Wu("angle", t),
+                    ...lm(t, n, e)
                 }
             }
 
-            function tm(t, e, n) {
+            function lm(t, e, n) {
                 return n ? {
                     shape: {
                         value: n
                     }
-                } : Ru("shape", t)
+                } : Wu("shape", t)
             }
-            const em = {
+            const um = {
                 vgMark: "rule",
                 encodeEntry: t => {
                     const {
                         markDef: e
                     } = t, n = e.orient;
                     return t.encoding.x || t.encoding.y || t.encoding.latitude || t.encoding.longitude ? {
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             orient: "ignore",
                             size: "ignore",
                             theta: "ignore"
                         }),
-                        ...Hu("x", t, {
+                        ...Ku("x", t, {
                             defaultPos: "horizontal" === n ? "zeroOrMax" : "mid",
                             defaultPos2: "zeroOrMin",
                             range: "vertical" !== n
                         }),
-                        ...Hu("y", t, {
+                        ...Ku("y", t, {
                             defaultPos: "vertical" === n ? "zeroOrMax" : "mid",
                             defaultPos2: "zeroOrMin",
                             range: "horizontal" !== n
                         }),
-                        ...Ru("size", t, {
+                        ...Wu("size", t, {
                             vgChannel: "strokeWidth"
                         })
                     } : {}
                 }
             };
 
-            function nm(t, e, n) {
+            function fm(t, e, n) {
                 if (void 0 === ki("align", t, n)) return "center"
             }
 
-            function im(t, e, n) {
+            function dm(t, e, n) {
                 if (void 0 === ki("baseline", t, n)) return "middle"
             }
-            const rm = {
+            const hm = {
                 vgMark: "rect",
                 encodeEntry: t => {
                     const {
                         config: e,
                         markDef: n
                     } = t, i = n.orient, r = "horizontal" === i ? "width" : "height", o = "horizontal" === i ? "height" : "width";
                     return {
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             orient: "ignore",
                             size: "ignore",
                             theta: "ignore"
                         }),
-                        ...Bu("x", t, {
+                        ...Ju("x", t, {
                             defaultPos: "mid",
                             vgChannel: "xc"
                         }),
-                        ...Bu("y", t, {
+                        ...Ju("y", t, {
                             defaultPos: "mid",
                             vgChannel: "yc"
                         }),
-                        ...Ru("size", t, {
-                            defaultValue: om(t),
+                        ...Wu("size", t, {
+                            defaultValue: pm(t),
                             vgChannel: r
                         }),
                         [o]: yi(ki("thickness", n, e))
                     }
                 }
             };
 
-            function om(t) {
+            function pm(t) {
                 var e;
                 const {
                     config: n,
                     markDef: i
                 } = t, {
                     orient: r
                 } = i, o = "horizontal" === r ? "width" : "height", a = t.getScaleComponent("horizontal" === r ? "x" : "y"), s = null !== (e = ki("size", i, n, {
                     vgChannel: o
                 })) && void 0 !== e ? e : n.tick.bandSize;
                 if (void 0 !== s) return s;
                 {
                     const t = a ? a.get("range") : void 0;
                     if (t && ui(t) && (0, U.hj)(t.step)) return 3 * t.step / 4;
-                    return 3 * kc(n.view, o) / 4
+                    return 3 * Cc(n.view, o) / 4
                 }
             }
-            const am = {
+            const mm = {
                 arc: {
                     vgMark: "arc",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             size: "ignore",
                             orient: "ignore",
                             theta: "ignore"
                         }),
-                        ...Bu("x", t, {
+                        ...Ju("x", t, {
                             defaultPos: "mid"
                         }),
-                        ...Bu("y", t, {
+                        ...Ju("y", t, {
                             defaultPos: "mid"
                         }),
-                        ...Gu(t, "radius"),
-                        ...Gu(t, "theta")
+                        ...ef(t, "radius"),
+                        ...ef(t, "theta")
                     })
                 },
                 area: {
                     vgMark: "area",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             orient: "include",
                             size: "ignore",
                             theta: "ignore"
                         }),
-                        ...Hu("x", t, {
+                        ...Ku("x", t, {
                             defaultPos: "zeroOrMin",
                             defaultPos2: "zeroOrMin",
                             range: "horizontal" === t.markDef.orient
                         }),
-                        ...Hu("y", t, {
+                        ...Ku("y", t, {
                             defaultPos: "zeroOrMin",
                             defaultPos2: "zeroOrMin",
                             range: "vertical" === t.markDef.orient
                         }),
-                        ...ef(t)
+                        ...uf(t)
                     })
                 },
                 bar: {
                     vgMark: "rect",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             orient: "ignore",
                             size: "ignore",
                             theta: "ignore"
                         }),
-                        ...Gu(t, "x"),
-                        ...Gu(t, "y")
+                        ...ef(t, "x"),
+                        ...ef(t, "y")
                     })
                 },
                 circle: {
                     vgMark: "symbol",
-                    encodeEntry: t => Qp(t, "circle")
+                    encodeEntry: t => cm(t, "circle")
                 },
                 geoshape: {
                     vgMark: "shape",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             size: "ignore",
                             orient: "ignore",
                             theta: "ignore"
                         })
@@ -15050,158 +15194,158 @@
                     postEncodingTransform: t => {
                         const {
                             encoding: e
                         } = t, n = e.shape;
                         return [{
                             type: "geoshape",
                             projection: t.projectionName(),
-                            ...n && Na(n) && n.type === Zr ? {
-                                field: Ga(n, {
+                            ...n && Ba(n) && n.type === to ? {
+                                field: Ka(n, {
                                     expr: "datum"
                                 })
                             } : {}
                         }]
                     }
                 },
                 image: {
                     vgMark: "image",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "ignore",
                             orient: "ignore",
                             size: "ignore",
                             theta: "ignore"
                         }),
-                        ...Gu(t, "x"),
-                        ...Gu(t, "y"),
-                        ...Su(t, "url")
+                        ...ef(t, "x"),
+                        ...ef(t, "y"),
+                        ...zu(t, "url")
                     })
                 },
                 line: {
                     vgMark: "line",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             size: "ignore",
                             orient: "ignore",
                             theta: "ignore"
                         }),
-                        ...Bu("x", t, {
+                        ...Ju("x", t, {
                             defaultPos: "mid"
                         }),
-                        ...Bu("y", t, {
+                        ...Ju("y", t, {
                             defaultPos: "mid"
                         }),
-                        ...Ru("size", t, {
+                        ...Wu("size", t, {
                             vgChannel: "strokeWidth"
                         }),
-                        ...ef(t)
+                        ...uf(t)
                     })
                 },
                 point: {
                     vgMark: "symbol",
-                    encodeEntry: t => Qp(t)
+                    encodeEntry: t => cm(t)
                 },
                 rect: {
                     vgMark: "rect",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             orient: "ignore",
                             size: "ignore",
                             theta: "ignore"
                         }),
-                        ...Gu(t, "x"),
-                        ...Gu(t, "y")
+                        ...ef(t, "x"),
+                        ...ef(t, "y")
                     })
                 },
-                rule: em,
+                rule: um,
                 square: {
                     vgMark: "symbol",
-                    encodeEntry: t => Qp(t, "square")
+                    encodeEntry: t => cm(t, "square")
                 },
                 text: {
                     vgMark: "text",
                     encodeEntry: t => {
                         const {
                             config: e,
                             encoding: n
                         } = t;
                         return {
-                            ...Ku(t, {
+                            ...sf(t, {
                                 align: "include",
                                 baseline: "include",
                                 color: "include",
                                 size: "ignore",
                                 orient: "ignore",
                                 theta: "include"
                             }),
-                            ...Bu("x", t, {
+                            ...Ju("x", t, {
                                 defaultPos: "mid"
                             }),
-                            ...Bu("y", t, {
+                            ...Ju("y", t, {
                                 defaultPos: "mid"
                             }),
-                            ...Su(t),
-                            ...Ru("size", t, {
+                            ...zu(t),
+                            ...Wu("size", t, {
                                 vgChannel: "fontSize"
                             }),
-                            ...Ru("angle", t),
-                            ...nf("align", nm(t.markDef, n, e)),
-                            ...nf("baseline", im(t.markDef, n, e)),
-                            ...Bu("radius", t, {
+                            ...Wu("angle", t),
+                            ...ff("align", fm(t.markDef, n, e)),
+                            ...ff("baseline", dm(t.markDef, n, e)),
+                            ...Ju("radius", t, {
                                 defaultPos: null
                             }),
-                            ...Bu("theta", t, {
+                            ...Ju("theta", t, {
                                 defaultPos: null
                             })
                         }
                     }
                 },
-                tick: rm,
+                tick: hm,
                 trail: {
                     vgMark: "trail",
                     encodeEntry: t => ({
-                        ...Ku(t, {
+                        ...sf(t, {
                             align: "ignore",
                             baseline: "ignore",
                             color: "include",
                             size: "include",
                             orient: "ignore",
                             theta: "ignore"
                         }),
-                        ...Bu("x", t, {
+                        ...Ju("x", t, {
                             defaultPos: "mid"
                         }),
-                        ...Bu("y", t, {
+                        ...Ju("y", t, {
                             defaultPos: "mid"
                         }),
-                        ...Ru("size", t),
-                        ...ef(t)
+                        ...Wu("size", t),
+                        ...uf(t)
                     })
                 }
             };
 
-            function sm(t) {
-                if (st([Fo, Ao, Ro], t.mark)) {
-                    const e = Os(t.mark, t.encoding);
+            function gm(t) {
+                if (st([Ro, Oo, jo], t.mark)) {
+                    const e = Ps(t.mark, t.encoding);
                     if (e.length > 0) return function(t, e) {
                         return [{
                             name: t.getName("pathgroup"),
                             type: "group",
                             from: {
                                 facet: {
-                                    name: cm + t.requestDataName(Ql.Main),
-                                    data: t.requestDataName(Ql.Main),
+                                    name: vm + t.requestDataName(ou.Main),
+                                    data: t.requestDataName(ou.Main),
                                     groupby: e
                                 }
                             },
                             encode: {
                                 update: {
                                     width: {
                                         field: {
@@ -15211,25 +15355,25 @@
                                     height: {
                                         field: {
                                             group: "height"
                                         }
                                     }
                                 }
                             },
-                            marks: um(t, {
-                                fromPrefix: cm
+                            marks: bm(t, {
+                                fromPrefix: vm
                             })
                         }]
                     }(t, e)
-                } else if (t.mark === So) {
+                } else if (t.mark === To) {
                     const e = pi.some((e => ki(e, t.markDef, t.config)));
                     if (t.stack && !t.fieldDef("size") && e) return function(t) {
                         var e;
-                        const [n] = um(t, {
-                            fromPrefix: lm
+                        const [n] = bm(t, {
+                            fromPrefix: ym
                         }), i = t.scaleName(t.stack.fieldChannel), r = function() {
                             let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                             return t.vgField(t.stack.fieldChannel, e)
                         }, o = (t, e) => {
                             const n = [r({
                                 prefix: "min",
                                 suffix: "start",
@@ -15317,16 +15461,16 @@
                                 value: 0
                             })
                         }
                         const c = [];
                         if ((null === (e = t.stack.groupbyChannels) || void 0 === e ? void 0 : e.length) > 0)
                             for (const l of t.stack.groupbyChannels) {
                                 const e = t.fieldDef(l),
-                                    n = Ga(e);
-                                n && c.push(n), (null !== e && void 0 !== e && e.bin || null !== e && void 0 !== e && e.timeUnit) && c.push(Ga(e, {
+                                    n = Ka(e);
+                                n && c.push(n), (null !== e && void 0 !== e && e.bin || null !== e && void 0 !== e && e.timeUnit) && c.push(Ka(e, {
                                     binSuffix: "end"
                                 }))
                             }
                         a = ["stroke", "strokeWidth", "strokeJoin", "strokeCap", "strokeDash", "strokeDashOffset", "strokeMiterLimit", "strokeOpacity"].reduce(((e, i) => {
                             if (n.encode.update[i]) return {
                                 ...e,
                                 [i]: n.encode.update[i]
@@ -15343,16 +15487,16 @@
                         }, a.strokeOffset = {
                             value: 0
                         });
                         return [{
                             type: "group",
                             from: {
                                 facet: {
-                                    data: t.requestDataName(Ql.Main),
-                                    name: lm + t.requestDataName(Ql.Main),
+                                    data: t.requestDataName(ou.Main),
+                                    name: ym + t.requestDataName(ou.Main),
                                     groupby: c,
                                     aggregate: {
                                         fields: [r({
                                             suffix: "start"
                                         }), r({
                                             suffix: "start"
                                         }), r({
@@ -15373,77 +15517,77 @@
                                     update: s
                                 },
                                 marks: [n]
                             }]
                         }]
                     }(t)
                 }
-                return um(t)
+                return bm(t)
             }
-            const cm = "faceted_path_";
-            const lm = "stack_group_";
+            const vm = "faceted_path_";
+            const ym = "stack_group_";
 
-            function um(t) {
+            function bm(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                     fromPrefix: ""
                 };
                 const {
                     mark: n,
                     markDef: i,
                     encoding: r,
                     config: o
-                } = t, a = zt(i.clip, function(t) {
+                } = t, a = Rt(i.clip, function(t) {
                     const e = t.getScaleComponent("x"),
                         n = t.getScaleComponent("y");
                     return !!(null !== e && void 0 !== e && e.get("selectionExtent") || null !== n && void 0 !== n && n.get("selectionExtent")) || void 0
                 }(t), function(t) {
                     const e = t.component.projection;
                     return !(!e || e.isFit) || void 0
                 }(t)), s = wi(i), c = r.key, l = function(t) {
                     const {
                         encoding: e,
                         stack: n,
                         mark: i,
                         markDef: r,
                         config: o
                     } = t, a = e.order;
-                    if (!(!(0, U.kJ)(a) && Ua(a) && at(a.value) || !a && at(ki("order", r, o)))) {
-                        if (((0, U.kJ)(a) || Na(a)) && !n) return Si(a, {
+                    if (!(!(0, U.kJ)(a) && Ga(a) && at(a.value) || !a && at(ki("order", r, o)))) {
+                        if (((0, U.kJ)(a) || Ba(a)) && !n) return Si(a, {
                             expr: "datum"
                         });
-                        if (Bo(i)) {
+                        if (Ho(i)) {
                             const n = "horizontal" === r.orient ? "y" : "x",
                                 i = e[n];
-                            if (Na(i)) {
+                            if (Ba(i)) {
                                 const e = i.sort;
                                 if ((0, U.kJ)(e)) return {
-                                    field: Ga(i, {
+                                    field: Ka(i, {
                                         prefix: n,
                                         suffix: "sort_index",
                                         expr: "datum"
                                     })
                                 };
-                                if (ba(e)) return {
-                                    field: Ga({
-                                        aggregate: As(t.encoding) ? e.op : void 0,
+                                if (Ea(e)) return {
+                                    field: Ka({
+                                        aggregate: Os(t.encoding) ? e.op : void 0,
                                         field: e.field
                                     }, {
                                         expr: "datum"
                                     })
                                 };
-                                if (ya(e)) return {
-                                    field: Ga(t.fieldDef(e.encoding), {
+                                if (ka(e)) return {
+                                    field: Ka(t.fieldDef(e.encoding), {
                                         expr: "datum"
                                     }),
                                     order: e.order
                                 };
                                 if (null === e) return;
                                 var s;
                                 return {
-                                    field: Ga(i, {
+                                    field: Ka(i, {
                                         binSuffix: null !== (s = t.stack) && void 0 !== s && s.impute ? "mid" : void 0,
                                         expr: "datum"
                                     })
                                 }
                             }
                         }
                     }
@@ -15452,18 +15596,18 @@
                     const e = bt(t.component.selection).length;
                     let n = e,
                         i = t.parent;
                     for (; i && 0 === n;) n = bt(i.component.selection).length, i = i.parent;
                     return n ? {
                         interactive: e > 0 || "geoshape" === t.mark || !!t.encoding.tooltip
                     } : null
-                }(t), f = ki("aria", i, o), d = am[n].postEncodingTransform ? am[n].postEncodingTransform(t) : null;
+                }(t), f = ki("aria", i, o), d = mm[n].postEncodingTransform ? mm[n].postEncodingTransform(t) : null;
                 return [{
                     name: t.getName("marks"),
-                    type: am[n].vgMark,
+                    type: mm[n].vgMark,
                     ...a ? {
                         clip: !0
                     } : {},
                     ...s ? {
                         style: s
                     } : {},
                     ...c ? {
@@ -15473,141 +15617,141 @@
                         sort: l
                     } : {},
                     ...u || {},
                     ...!1 === f ? {
                         aria: f
                     } : {},
                     from: {
-                        data: e.fromPrefix + t.requestDataName(Ql.Main)
+                        data: e.fromPrefix + t.requestDataName(ou.Main)
                     },
                     encode: {
-                        update: am[n].encodeEntry(t)
+                        update: mm[n].encodeEntry(t)
                     },
                     ...d ? {
                         transform: d
                     } : {}
                 }]
             }
-            class fm extends gp {
+            class xm extends Ep {
                 constructor(t, e, n) {
                     var i;
                     let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                         o = arguments.length > 4 ? arguments[4] : void 0;
-                    super(t, "unit", e, n, o, void 0, xc(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
-                    const a = qo(t.mark) ? {
+                    super(t, "unit", e, n, o, void 0, Ac(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
+                    const a = Jo(t.mark) ? {
                             ...t.mark
                         } : {
                             type: t.mark
                         },
                         s = a.type;
                     void 0 === a.filled && (a.filled = function(t, e, n) {
                         let {
                             graticule: i
                         } = n;
                         if (i) return !1;
                         const r = Ei("filled", t, e),
                             o = t.type;
-                        return zt(r, o !== Mo && o !== Fo && o !== To)
+                        return Rt(r, o !== zo && o !== Ro && o !== Lo)
                     }(a, o, {
-                        graticule: t.data && Kl(t.data)
+                        graticule: t.data && ru(t.data)
                     }));
                     const c = this.encoding = function(t, e, n, i) {
                         const r = {};
                         for (const a of bt(t)) He(a) || dr("".concat(o = a, "-encoding is dropped as ").concat(o, " is not a valid encoding channel."));
                         var o;
                         for (let a of tn) {
                             if (!t[a]) continue;
                             const o = t[a];
-                            if (Dn(a)) {
+                            if (An(a)) {
                                 const t = Qe(a),
                                     e = r[t];
-                                if (Na(e)) {
-                                    if (Wr(e.type) && Na(o) && !e.timeUnit) {
+                                if (Ba(e)) {
+                                    if (Zr(e.type) && Ba(o) && !e.timeUnit) {
                                         dr(Hi(t));
                                         continue
                                     }
                                 } else a = t, dr(Xi(t))
                             }
-                            if ("angle" !== a || "arc" !== e || t.theta || (dr("Arc marks uses theta channel rather than angle, replacing angle with theta."), a = Qt), Cs(t, a, e)) {
+                            if ("angle" !== a || "arc" !== e || t.theta || (dr("Arc marks uses theta channel rather than angle, replacing angle with theta."), a = Qt), Ns(t, a, e)) {
                                 if (a === le && "line" === e) {
-                                    const e = ns(t[a]);
+                                    const e = ss(t[a]);
                                     if (null !== e && void 0 !== e && e.aggregate) {
                                         dr("Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.");
                                         continue
                                     }
                                 }
-                                if (a === oe && (n ? "fill" in t : "stroke" in t)) dr(Gi("encoding", {
+                                if (a === oe && (n ? "fill" in t : "stroke" in t)) dr(Ji("encoding", {
                                     fill: "fill" in t,
                                     stroke: "stroke" in t
                                 }));
-                                else if (a === ye || a === ve && !(0, U.kJ)(o) && !Ua(o) || a === xe && (0, U.kJ)(o)) {
+                                else if (a === ye || a === ve && !(0, U.kJ)(o) && !Ga(o) || a === xe && (0, U.kJ)(o)) {
                                     if (o) {
                                         if (a === ve) {
                                             const e = t[a];
-                                            if (Fa(e)) {
+                                            if (Ra(e)) {
                                                 r[a] = e;
                                                 continue
                                             }
                                         }
-                                        r[a] = (0, U.IX)(o).reduce(((t, e) => (Na(e) ? t.push(as(e, a)) : dr($i(e, a)), t)), [])
+                                        r[a] = (0, U.IX)(o).reduce(((t, e) => (Ba(e) ? t.push(fs(e, a)) : dr(Zi(e, a)), t)), [])
                                     }
                                 } else {
                                     if (a === xe && null === o) r[a] = null;
-                                    else if (!Na(o) && !Ra(o) && !Ua(o) && !Ma(o) && !li(o)) {
-                                        dr($i(o, a));
+                                    else if (!Ba(o) && !ja(o) && !Ga(o) && !za(o) && !li(o)) {
+                                        dr(Zi(o, a));
                                         continue
                                     }
-                                    r[a] = rs(o, a, i)
+                                    r[a] = ls(o, a, i)
                                 }
-                            } else dr(Zi(a, e))
+                            } else dr($i(a, e))
                         }
                         return r
                     }(t.encoding || {}, s, a.filled, o);
-                    this.markDef = Kp(a, c, o), this.size = function(t) {
+                    this.markDef = sm(a, c, o), this.size = function(t) {
                         let {
                             encoding: e,
                             size: n
                         } = t;
                         for (const i of bn) {
                             const t = Ye(i);
-                            bc(n[t]) && Pa(e[i]) && (delete n[t], dr(rr(t)))
+                            Ec(n[t]) && Ua(e[i]) && (delete n[t], dr(rr(t)))
                         }
                         return n
                     }({
                         encoding: c,
-                        size: xc(t) ? {
+                        size: Ac(t) ? {
                             ...r,
                             ...t.width ? {
                                 width: t.width
                             } : {},
                             ...t.height ? {
                                 height: t.height
                             } : {}
                         } : r
-                    }), this.stack = Xc(this.markDef, c), this.specifiedScales = this.initScales(s, c), this.specifiedAxes = this.initAxes(c), this.specifiedLegends = this.initLegends(c), this.specifiedProjection = t.projection, this.selection = (null !== (i = t.params) && void 0 !== i ? i : []).filter((t => hc(t)))
+                    }), this.stack = Yc(this.markDef, c), this.specifiedScales = this.initScales(s, c), this.specifiedAxes = this.initAxes(c), this.specifiedLegends = this.initLegends(c), this.specifiedProjection = t.projection, this.selection = (null !== (i = t.params) && void 0 !== i ? i : []).filter((t => yc(t)))
                 }
                 get hasProjection() {
                     const {
                         encoding: t
-                    } = this, e = this.mark === jo, n = t && Fe.some((e => Ba(t[e])));
+                    } = this, e = this.mark === Wo, n = t && Me.some((e => Ha(t[e])));
                     return e || n
                 }
                 scaleDomain(t) {
                     const e = this.specifiedScales[t];
                     return e ? e.domain : void 0
                 }
                 axis(t) {
                     return this.specifiedAxes[t]
                 }
                 legend(t) {
                     return this.specifiedLegends[t]
                 }
                 initScales(t, e) {
                     return Ln.reduce(((t, n) => {
-                        const i = is(e[n]);
+                        const i = cs(e[n]);
                         var r;
                         i && (t[n] = this.initScale(null !== (r = i.scale) && void 0 !== r ? r : {}));
                         return t
                     }), {})
                 }
                 initScale(t) {
                     const {
@@ -15615,35 +15759,35 @@
                         range: n
                     } = t, i = ai(t);
                     return (0, U.kJ)(e) && (i.domain = e.map(gi)), (0, U.kJ)(n) && (i.range = n.map(gi)), i
                 }
                 initAxes(t) {
                     return bn.reduce(((e, n) => {
                         const i = t[n];
-                        if (Ba(i) || n === Xt && Ba(t.x2) || n === Jt && Ba(t.y2)) {
-                            const t = Ba(i) ? i.axis : void 0;
+                        if (Ha(i) || n === Xt && Ha(t.x2) || n === Gt && Ha(t.y2)) {
+                            const t = Ha(i) ? i.axis : void 0;
                             e[n] = t ? this.initAxis({
                                 ...t
                             }) : t
                         }
                         return e
                     }), {})
                 }
                 initAxis(t) {
                     const e = bt(t),
                         n = {};
                     for (const i of e) {
                         const e = t[i];
-                        n[i] = ps(e) ? mi(e) : gi(e)
+                        n[i] = bs(e) ? mi(e) : gi(e)
                     }
                     return n
                 }
                 initLegends(t) {
-                    return Rn.reduce(((e, n) => {
-                        const i = is(t[n]);
+                    return zn.reduce(((e, n) => {
+                        const i = cs(t[n]);
                         if (i && function(t) {
                                 switch (t) {
                                     case oe:
                                     case ae:
                                     case se:
                                     case le:
                                     case ce:
@@ -15660,29 +15804,29 @@
                             const t = i.legend;
                             e[n] = t ? ai(t) : t
                         }
                         return e
                     }), {})
                 }
                 parseData() {
-                    this.component.data = Up(this)
+                    this.component.data = Yp(this)
                 }
                 parseLayoutSize() {
                     ! function(t) {
                         const {
                             size: e,
                             component: n
                         } = t;
                         for (const i of bn) {
                             const r = Ye(i);
                             if (e[r]) {
                                 const t = e[r];
-                                n.layoutSize.set(r, bc(t) ? "step" : t, !0)
+                                n.layoutSize.set(r, Ec(t) ? "step" : t, !0)
                             } else {
-                                const e = Lp(t, r);
+                                const e = Gp(t, r);
                                 n.layoutSize.set(r, e, !1)
                             }
                         }
                     }(this)
                 }
                 parseSelections() {
                     this.component.selection = function(t, e) {
@@ -15706,152 +15850,152 @@
                             }
                             const u = n[e] = {
                                     ...c,
                                     name: e,
                                     type: s,
                                     init: o.value,
                                     bind: o.bind,
-                                    events: (0, U.HD)(c.on) ? (0, tu.r)(c.on, "scope") : (0, U.IX)(tt(c.on))
+                                    events: (0, U.HD)(c.on) ? (0, au.r)(c.on, "scope") : (0, U.IX)(tt(c.on))
                                 },
                                 f = tt(o);
-                            for (const n of Df) n.defined(u) && n.parse && n.parse(t, u, f)
+                            for (const n of Nf) n.defined(u) && n.parse && n.parse(t, u, f)
                         }
                         return n
                     }(this, this.selection)
                 }
                 parseMarkGroup() {
-                    this.component.mark = sm(this)
+                    this.component.mark = gm(this)
                 }
                 parseAxesAndHeaders() {
                     var t;
-                    this.component.axes = (t = this, bn.reduce(((e, n) => (t.component.scales[n] && (e[n] = [Vp(n, t)]), e)), {}))
+                    this.component.axes = (t = this, bn.reduce(((e, n) => (t.component.scales[n] && (e[n] = [am(n, t)]), e)), {}))
                 }
                 assembleSelectionTopLevelSignals(t) {
                     return function(t, e) {
                         let n = !1;
                         for (const r of xt(null !== (i = t.component.selection) && void 0 !== i ? i : {})) {
                             var i;
                             const o = r.name,
-                                a = (0, U.m8)(o + _f);
+                                a = (0, U.m8)(o + Mf);
                             if (0 === e.filter((t => t.name === o)).length) {
                                 const t = "global" === r.resolve ? "union" : r.resolve,
                                     n = "point" === r.type ? ", true, true)" : ")";
                                 e.push({
                                     name: r.name,
-                                    update: "".concat(Ef, "(").concat(a, ", ").concat((0, U.m8)(t)).concat(n)
+                                    update: "".concat(Tf, "(").concat(a, ", ").concat((0, U.m8)(t)).concat(n)
                                 })
                             }
                             n = !0;
-                            for (const n of Df) n.defined(r) && n.topLevelSignals && (e = n.topLevelSignals(t, r, e))
+                            for (const n of Nf) n.defined(r) && n.topLevelSignals && (e = n.topLevelSignals(t, r, e))
                         }
                         n && 0 === e.filter((t => "unit" === t.name)).length && e.unshift({
                             name: "unit",
                             value: {},
                             on: [{
                                 events: "mousemove",
                                 update: "isTuple(group()) ? group() : unit"
                             }]
                         });
-                        return au(e)
+                        return du(e)
                     }(this, t)
                 }
                 assembleSignals() {
-                    return [...Bf(this), ...iu(this, [])]
+                    return [...Jf(this), ...lu(this, [])]
                 }
                 assembleSelectionData(t) {
                     return function(t, e) {
                         const n = [...e],
-                            i = Af(t, {
+                            i = Rf(t, {
                                 escape: !1
                             });
                         for (const o of xt(null !== (r = t.component.selection) && void 0 !== r ? r : {})) {
                             var r;
                             const t = {
-                                name: o.name + _f
+                                name: o.name + Mf
                             };
                             if (o.project.hasSelectionId && (t.transform = [{
                                     type: "collect",
                                     sort: {
-                                        field: lc
+                                        field: pc
                                     }
                                 }]), o.init) {
-                                const e = o.project.items.map(eu);
+                                const e = o.project.items.map(su);
                                 t.values = o.project.hasSelectionId ? o.init.map((t => ({
                                     unit: i,
-                                    [lc]: nu(t, !1)[0]
+                                    [pc]: cu(t, !1)[0]
                                 }))) : o.init.map((t => ({
                                     unit: i,
                                     fields: e,
-                                    values: nu(t, !1)
+                                    values: cu(t, !1)
                                 })))
                             }
-                            n.filter((t => t.name === o.name + _f)).length || n.push(t)
+                            n.filter((t => t.name === o.name + Mf)).length || n.push(t)
                         }
                         return n
                     }(this, t)
                 }
                 assembleLayout() {
                     return null
                 }
                 assembleLayoutSignals() {
-                    return fd(this)
+                    return bd(this)
                 }
                 assembleMarks() {
                     var t;
                     let e = null !== (t = this.component.mark) && void 0 !== t ? t : [];
-                    return this.parent && pp(this.parent) || (e = ou(this, e)), e.map(this.correctDataNames)
+                    return this.parent && wp(this.parent) || (e = fu(this, e)), e.map(this.correctDataNames)
                 }
                 assembleGroupStyle() {
                     const {
                         style: t
                     } = this.view || {};
                     return void 0 !== t ? t : this.encoding.x || this.encoding.y ? "cell" : "view"
                 }
                 getMapping() {
                     return this.encoding
                 }
                 get mark() {
                     return this.markDef.type
                 }
                 channelHasField(t) {
-                    return ks(this.encoding, t)
+                    return Cs(this.encoding, t)
                 }
                 fieldDef(t) {
-                    return ns(this.encoding[t])
+                    return ss(this.encoding[t])
                 }
                 typedFieldDef(t) {
                     const e = this.fieldDef(t);
-                    return Ia(e) ? e : null
+                    return Xa(e) ? e : null
                 }
             }
-            class dm extends mp {
+            class _m extends kp {
                 constructor(t, e, n, i, r) {
                     super(t, "layer", e, n, r, t.resolve, t.view);
                     const o = {
                         ...i,
                         ...t.width ? {
                             width: t.width
                         } : {},
                         ...t.height ? {
                             height: t.height
                         } : {}
                     };
                     this.children = t.layer.map(((t, e) => {
-                        if (jc(t)) return new dm(t, this, this.getName("layer_".concat(e)), o, r);
-                        if (_s(t)) return new fm(t, this, this.getName("layer_".concat(e)), o, r);
+                        if (Wc(t)) return new _m(t, this, this.getName("layer_".concat(e)), o, r);
+                        if (Ds(t)) return new xm(t, this, this.getName("layer_".concat(e)), o, r);
                         throw new Error(Oi(t))
                     }))
                 }
                 parseData() {
-                    this.component.data = Up(this);
+                    this.component.data = Yp(this);
                     for (const t of this.children) t.parseData()
                 }
                 parseLayoutSize() {
                     var t;
-                    Rp(t = this), Pp(t, "width"), Pp(t, "height")
+                    Hp(t = this), Xp(t, "width"), Xp(t, "height")
                 }
                 parseSelections() {
                     this.component.selection = {};
                     for (const t of this.children) {
                         t.parseSelections();
                         for (const e of bt(t.component.selection)) this.component.selection[e] = t.component.selection[e]
                     }
@@ -15868,50 +16012,50 @@
                             top: 0,
                             bottom: 0,
                             right: 0,
                             left: 0
                         };
                         for (const o of t.children) {
                             o.parseAxesAndHeaders();
-                            for (const i of bt(o.component.axes)) n.axis[i] = yd(t.component.resolve, i), "shared" === n.axis[i] && (e[i] = Gp(e[i], o.component.axes[i]), e[i] || (n.axis[i] = "independent", delete e[i]))
+                            for (const i of bt(o.component.axes)) n.axis[i] = Dd(t.component.resolve, i), "shared" === n.axis[i] && (e[i] = nm(e[i], o.component.axes[i]), e[i] || (n.axis[i] = "independent", delete e[i]))
                         }
                         for (const o of bn) {
                             for (const a of t.children)
                                 if (a.component.axes[o]) {
                                     if ("independent" === n.axis[o]) {
                                         var r;
                                         e[o] = (null !== (r = e[o]) && void 0 !== r ? r : []).concat(a.component.axes[o]);
                                         for (const t of a.component.axes[o]) {
                                             const {
                                                 value: e,
                                                 explicit: n
                                             } = t.getWithExplicit("orient");
                                             if (!li(e)) {
                                                 if (i[e] > 0 && !n) {
-                                                    const n = Jp[e];
+                                                    const n = em[e];
                                                     i[e] > i[n] && t.set("orient", n, !1)
                                                 }
                                                 i[e]++
                                             }
                                         }
                                     }
                                     delete a.component.axes[o]
                                 } if ("independent" === n.axis[o] && e[o] && e[o].length > 1)
-                                for (const t of e[o]) t.get("grid") && !t.explicit.grid && (t.implicit.grid = !1)
+                                for (const [t, n] of(e[o] || []).entries()) t > 0 && n.get("grid") && !n.explicit.grid && (n.implicit.grid = !1)
                         }
                     }(this)
                 }
                 assembleSelectionTopLevelSignals(t) {
                     return this.children.reduce(((t, e) => e.assembleSelectionTopLevelSignals(t)), t)
                 }
                 assembleSignals() {
-                    return this.children.reduce(((t, e) => t.concat(e.assembleSignals())), Bf(this))
+                    return this.children.reduce(((t, e) => t.concat(e.assembleSignals())), Jf(this))
                 }
                 assembleLayoutSignals() {
-                    return this.children.reduce(((t, e) => t.concat(e.assembleLayoutSignals())), fd(this))
+                    return this.children.reduce(((t, e) => t.concat(e.assembleLayoutSignals())), bd(this))
                 }
                 assembleSelectionData(t) {
                     return this.children.reduce(((t, e) => e.assembleSelectionData(t)), t)
                 }
                 assembleGroupStyle() {
                     const t = new Set;
                     for (const n of this.children)
@@ -15926,58 +16070,58 @@
                         if (t = e.assembleTitle(), t) return t
                 }
                 assembleLayout() {
                     return null
                 }
                 assembleMarks() {
                     return function(t, e) {
-                        for (const n of t.children) fp(n) && (e = ou(n, e));
+                        for (const n of t.children) bp(n) && (e = fu(n, e));
                         return e
                     }(this, this.children.flatMap((t => t.assembleMarks())))
                 }
                 assembleLegends() {
-                    return this.children.reduce(((t, e) => t.concat(e.assembleLegends())), Pd(this))
+                    return this.children.reduce(((t, e) => t.concat(e.assembleLegends())), Hd(this))
                 }
             }
 
-            function hm(t, e, n, i, r) {
-                if (ka(t)) return new Bp(t, e, n, r);
-                if (jc(t)) return new dm(t, e, n, i, r);
-                if (_s(t)) return new fm(t, e, n, i, r);
+            function wm(t, e, n, i, r) {
+                if (Ca(t)) return new Zp(t, e, n, r);
+                if (Wc(t)) return new _m(t, e, n, i, r);
+                if (Ds(t)) return new xm(t, e, n, i, r);
                 if (function(t) {
-                        return gc(t) || vc(t) || mc(t)
-                    }(t)) return new qp(t, e, n, r);
+                        return _c(t) || wc(t) || xc(t)
+                    }(t)) return new Vp(t, e, n, r);
                 throw new Error(Oi(t))
             }
 
-            function pm(t) {
+            function km(t) {
                 let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                 var n;
-                e.logger && (n = e.logger, ur = n), e.fieldTitle && Va(e.fieldTitle);
+                e.logger && (n = e.logger, ur = n), e.fieldTitle && ns(e.fieldTitle);
                 try {
-                    const n = Tc((0, U.fE)(e.config, t.config)),
-                        i = Tl(t, n),
-                        r = hm(i, null, "", void 0, n);
+                    const n = Lc((0, U.fE)(e.config, t.config)),
+                        i = Bl(t, n),
+                        r = wm(i, null, "", void 0, n);
                     r.parse(),
                         function(t, e) {
-                            Fh(t.sources);
+                            Lh(t.sources);
                             let n = 0,
                                 i = 0;
-                            for (let r = 0; r < Ch && Oh(t, e, !0); r++) n++;
-                            t.sources.map(Dh);
-                            for (let r = 0; r < Ch && Oh(t, e, !1); r++) i++;
-                            Fh(t.sources), Math.max(n, i) === Ch && dr("Maximum optimization runs(".concat(Ch, ") reached."))
+                            for (let r = 0; r < Ph && Ih(t, e, !0); r++) n++;
+                            t.sources.map(Nh);
+                            for (let r = 0; r < Ph && Ih(t, e, !1); r++) i++;
+                            Lh(t.sources), Math.max(n, i) === Ph && dr("Maximum optimization runs(".concat(Ph, ") reached."))
                         }(r.component.data, r);
                     const o = function(t, e) {
                         let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                             i = arguments.length > 3 ? arguments[3] : void 0;
-                        const r = t.config ? Pc(t.config) : void 0,
+                        const r = t.config ? Uc(t.config) : void 0,
                             o = [].concat(t.assembleSelectionData([]), function(t, e) {
                                 const n = [],
-                                    i = Mp(n);
+                                    i = Ip(n);
                                 let r = 0;
                                 for (const c of t.sources) {
                                     c.hasName() || (c.dataName = "source_".concat(r++));
                                     const t = c.assemble();
                                     i(c, t)
                                 }
                                 for (const c of n) 0 === c.transform.length && delete c.transform;
@@ -16021,15 +16165,15 @@
                                     update: l
                                 }
                             } : {},
                             data: o,
                             ...a.length > 0 ? {
                                 projections: a
                             } : {},
-                            ...t.assembleGroup([...u, ...t.assembleSelectionTopLevelSignals([]), ...pc(f)]),
+                            ...t.assembleGroup([...u, ...t.assembleSelectionTopLevelSignals([]), ...bc(f)]),
                             ...r ? {
                                 config: r
                             } : {},
                             ...i ? {
                                 usermeta: i
                             } : {}
                         }
@@ -16038,100 +16182,100 @@
                             o = i.component.layoutSize.get("height");
                         void 0 === e ? (e = {
                             type: "pad"
                         }, i.hasAxisOrientSignalRef() && (e.resize = !0)) : (0, U.HD)(e) && (e = {
                             type: e
                         });
                         if (r && o && (a = e.type, "fit" === a || "fit-x" === a || "fit-y" === a))
-                            if ("step" === r && "step" === o) dr(Ri()), e.type = "pad";
+                            if ("step" === r && "step" === o) dr(zi()), e.type = "pad";
                             else if ("step" === r || "step" === o) {
                             const t = "step" === r ? "width" : "height";
-                            dr(Ri(kn(t)));
+                            dr(zi(kn(t)));
                             const n = "width" === t ? "height" : "width";
                             e.type = function(t) {
                                 return t ? "fit-".concat(kn(t)) : "fit"
                             }(n)
                         }
                         var a;
                         return {
                             ...1 === bt(e).length && e.type ? "pad" === e.type ? {} : {
                                 autosize: e.type
                             } : {
                                 autosize: e
                             },
-                            ...jl(n, !1),
-                            ...jl(t, !0)
+                            ...Hl(n, !1),
+                            ...Hl(t, !0)
                         }
                     }(t, i.autosize, n, r), t.datasets, t.usermeta);
                     return {
                         spec: o,
                         normalized: i
                     }
                 } finally {
-                    e.logger && fr(), e.fieldTitle && Va(Za)
+                    e.logger && fr(), e.fieldTitle && ns(ts)
                 }
             }
-            const mm = "5.9.3";
-            const gm = function(t) {
+            const Em = "5.14.0";
+            const Am = function(t) {
                 const [e, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(t).slice(1, 3);
                 return {
                     library: e,
                     version: n
                 }
             };
-            var vm = "2.14.0";
-            const ym = "#fff",
-                bm = "#888",
-                xm = {
+            var Dm = "2.14.0";
+            const Sm = "#fff",
+                Cm = "#888",
+                Mm = {
                     background: "#333",
                     view: {
-                        stroke: bm
+                        stroke: Cm
                     },
                     title: {
-                        color: ym,
-                        subtitleColor: ym
+                        color: Sm,
+                        subtitleColor: Sm
                     },
                     style: {
                         "guide-label": {
-                            fill: ym
+                            fill: Sm
                         },
                         "guide-title": {
-                            fill: ym
+                            fill: Sm
                         }
                     },
                     axis: {
-                        domainColor: ym,
-                        gridColor: bm,
-                        tickColor: ym
+                        domainColor: Sm,
+                        gridColor: Cm,
+                        tickColor: Sm
                     }
                 },
-                _m = "#4572a7",
-                wm = {
+                Fm = "#4572a7",
+                Om = {
                     background: "#fff",
                     arc: {
-                        fill: _m
+                        fill: Fm
                     },
                     area: {
-                        fill: _m
+                        fill: Fm
                     },
                     line: {
-                        stroke: _m,
+                        stroke: Fm,
                         strokeWidth: 2
                     },
                     path: {
-                        stroke: _m
+                        stroke: Fm
                     },
                     rect: {
-                        fill: _m
+                        fill: Fm
                     },
                     shape: {
-                        stroke: _m
+                        stroke: Fm
                     },
                     symbol: {
-                        fill: _m,
+                        fill: Fm,
                         strokeWidth: 1.5,
                         size: 50
                     },
                     axis: {
                         bandPosition: .5,
                         grid: !0,
                         gridColor: "#000000",
@@ -16151,116 +16295,116 @@
                         symbolSize: 50,
                         symbolType: "square"
                     },
                     range: {
                         category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
                     }
                 },
-                km = "#30a2da",
-                Em = "#cbcbcb",
-                Dm = "#f0f0f0",
-                Am = "#333",
-                Sm = {
+                Tm = "#30a2da",
+                Nm = "#cbcbcb",
+                Rm = "#f0f0f0",
+                zm = "#333",
+                Pm = {
                     arc: {
-                        fill: km
+                        fill: Tm
                     },
                     area: {
-                        fill: km
+                        fill: Tm
                     },
                     axis: {
-                        domainColor: Em,
+                        domainColor: Nm,
                         grid: !0,
-                        gridColor: Em,
+                        gridColor: Nm,
                         gridWidth: 1,
                         labelColor: "#999",
                         labelFontSize: 10,
                         titleColor: "#333",
-                        tickColor: Em,
+                        tickColor: Nm,
                         tickSize: 10,
                         titleFontSize: 14,
                         titlePadding: 10,
                         labelPadding: 4
                     },
                     axisBand: {
                         grid: !1
                     },
-                    background: Dm,
+                    background: Rm,
                     group: {
-                        fill: Dm
+                        fill: Rm
                     },
                     legend: {
-                        labelColor: Am,
+                        labelColor: zm,
                         labelFontSize: 11,
                         padding: 1,
                         symbolSize: 30,
                         symbolType: "square",
-                        titleColor: Am,
+                        titleColor: zm,
                         titleFontSize: 14,
                         titlePadding: 10
                     },
                     line: {
-                        stroke: km,
+                        stroke: Tm,
                         strokeWidth: 2
                     },
                     path: {
-                        stroke: km,
+                        stroke: Tm,
                         strokeWidth: .5
                     },
                     rect: {
-                        fill: km
+                        fill: Tm
                     },
                     range: {
                         category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
                         diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
                         heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
                     },
                     point: {
                         filled: !0,
                         shape: "circle"
                     },
                     shape: {
-                        stroke: km
+                        stroke: Tm
                     },
                     bar: {
                         binSpacing: 2,
-                        fill: km,
+                        fill: Tm,
                         stroke: null
                     },
                     title: {
                         anchor: "start",
                         fontSize: 24,
                         fontWeight: 600,
                         offset: 20
                     }
                 },
-                Cm = "#000",
-                Fm = {
+                Lm = "#000",
+                Bm = {
                     group: {
                         fill: "#e5e5e5"
                     },
                     arc: {
-                        fill: Cm
+                        fill: Lm
                     },
                     area: {
-                        fill: Cm
+                        fill: Lm
                     },
                     line: {
-                        stroke: Cm
+                        stroke: Lm
                     },
                     path: {
-                        stroke: Cm
+                        stroke: Lm
                     },
                     rect: {
-                        fill: Cm
+                        fill: Lm
                     },
                     shape: {
-                        stroke: Cm
+                        stroke: Lm
                     },
                     symbol: {
-                        fill: Cm,
+                        fill: Lm,
                         size: 40
                     },
                     axis: {
                         domain: !1,
                         grid: !0,
                         gridColor: "#FFFFFF",
                         gridOpacity: 1,
@@ -16276,63 +16420,63 @@
                         labelFontSize: 11,
                         symbolSize: 40
                     },
                     range: {
                         category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
                     }
                 },
-                Mm = "Benton Gothic, sans-serif",
-                Om = "#82c6df",
-                Tm = "Benton Gothic Bold, sans-serif",
-                Nm = "normal",
-                zm = {
+                Im = "Benton Gothic, sans-serif",
+                jm = "#82c6df",
+                Um = "Benton Gothic Bold, sans-serif",
+                qm = "normal",
+                Wm = {
                     "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
                     "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
                     "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
                     "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
                 },
-                Rm = {
+                Hm = {
                     background: "#ffffff",
                     title: {
                         anchor: "start",
                         color: "#000000",
-                        font: Tm,
+                        font: Um,
                         fontSize: 22,
                         fontWeight: "normal"
                     },
                     arc: {
-                        fill: Om
+                        fill: jm
                     },
                     area: {
-                        fill: Om
+                        fill: jm
                     },
                     line: {
-                        stroke: Om,
+                        stroke: jm,
                         strokeWidth: 2
                     },
                     path: {
-                        stroke: Om
+                        stroke: jm
                     },
                     rect: {
-                        fill: Om
+                        fill: jm
                     },
                     shape: {
-                        stroke: Om
+                        stroke: jm
                     },
                     symbol: {
-                        fill: Om,
+                        fill: jm,
                         size: 30
                     },
                     axis: {
-                        labelFont: Mm,
+                        labelFont: Im,
                         labelFontSize: 11.5,
                         labelFontWeight: "normal",
-                        titleFont: Tm,
+                        titleFont: Um,
                         titleFontSize: 13,
-                        titleFontWeight: Nm
+                        titleFontWeight: qm
                     },
                     axisX: {
                         labelAngle: 0,
                         labelPadding: 4,
                         tickSize: 3
                     },
                     axisY: {
@@ -16342,63 +16486,63 @@
                         tickSize: 2,
                         titleAlign: "left",
                         titleAngle: 0,
                         titleX: -45,
                         titleY: -11
                     },
                     legend: {
-                        labelFont: Mm,
+                        labelFont: Im,
                         labelFontSize: 11.5,
                         symbolType: "square",
-                        titleFont: Tm,
+                        titleFont: Um,
                         titleFontSize: 13,
-                        titleFontWeight: Nm
+                        titleFontWeight: qm
                     },
                     range: {
-                        category: zm["category-6"],
-                        diverging: zm["fireandice-6"],
-                        heatmap: zm["fire-7"],
-                        ordinal: zm["fire-7"],
-                        ramp: zm["fire-7"]
+                        category: Wm["category-6"],
+                        diverging: Wm["fireandice-6"],
+                        heatmap: Wm["fire-7"],
+                        ordinal: Wm["fire-7"],
+                        ramp: Wm["fire-7"]
                     }
                 },
-                Pm = "#ab5787",
-                Lm = "#979797",
-                jm = {
+                Xm = "#ab5787",
+                Gm = "#979797",
+                Jm = {
                     background: "#f9f9f9",
                     arc: {
-                        fill: Pm
+                        fill: Xm
                     },
                     area: {
-                        fill: Pm
+                        fill: Xm
                     },
                     line: {
-                        stroke: Pm
+                        stroke: Xm
                     },
                     path: {
-                        stroke: Pm
+                        stroke: Xm
                     },
                     rect: {
-                        fill: Pm
+                        fill: Xm
                     },
                     shape: {
-                        stroke: Pm
+                        stroke: Xm
                     },
                     symbol: {
-                        fill: Pm,
+                        fill: Xm,
                         size: 30
                     },
                     axis: {
-                        domainColor: Lm,
+                        domainColor: Gm,
                         domainWidth: .5,
                         gridWidth: .2,
-                        labelColor: Lm,
-                        tickColor: Lm,
+                        labelColor: Gm,
+                        tickColor: Gm,
                         tickWidth: .2,
-                        titleColor: Lm
+                        titleColor: Gm
                     },
                     axisBand: {
                         grid: !1
                     },
                     axisX: {
                         grid: !0,
                         tickSize: 10
@@ -16414,37 +16558,37 @@
                         symbolSize: 30,
                         symbolType: "square"
                     },
                     range: {
                         category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
                     }
                 },
-                Bm = "#3e5c69",
-                Im = {
+                Zm = "#3e5c69",
+                $m = {
                     background: "#fff",
                     arc: {
-                        fill: Bm
+                        fill: Zm
                     },
                     area: {
-                        fill: Bm
+                        fill: Zm
                     },
                     line: {
-                        stroke: Bm
+                        stroke: Zm
                     },
                     path: {
-                        stroke: Bm
+                        stroke: Zm
                     },
                     rect: {
-                        fill: Bm
+                        fill: Zm
                     },
                     shape: {
-                        stroke: Bm
+                        stroke: Zm
                     },
                     symbol: {
-                        fill: Bm
+                        fill: Zm
                     },
                     axis: {
                         domainWidth: .5,
                         grid: !0,
                         labelPadding: 2,
                         tickSize: 5,
                         tickWidth: .5,
@@ -16465,19 +16609,19 @@
                         padding: 1,
                         symbolType: "square"
                     },
                     range: {
                         category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
                     }
                 },
-                Um = "#1696d2",
-                qm = "#000000",
-                Wm = "Lato",
-                Hm = "Lato",
-                Xm = {
+                Ym = "#1696d2",
+                Vm = "#000000",
+                Km = "Lato",
+                Qm = "Lato",
+                tg = {
                     "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
                     "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
                     "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
                     "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
                     "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
                     "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
                     "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
@@ -16496,220 +16640,220 @@
                     "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
                     "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
                     "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
                     "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
                     "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
                     "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
                 },
-                Jm = {
+                eg = {
                     background: "#FFFFFF",
                     title: {
                         anchor: "start",
                         fontSize: 18,
-                        font: Wm
+                        font: Km
                     },
                     axisX: {
                         domain: !0,
-                        domainColor: qm,
+                        domainColor: Vm,
                         domainWidth: 1,
                         grid: !1,
                         labelFontSize: 12,
-                        labelFont: Hm,
+                        labelFont: Qm,
                         labelAngle: 0,
-                        tickColor: qm,
+                        tickColor: Vm,
                         tickSize: 5,
                         titleFontSize: 12,
                         titlePadding: 10,
-                        titleFont: Wm
+                        titleFont: Km
                     },
                     axisY: {
                         domain: !1,
                         domainWidth: 1,
                         grid: !0,
                         gridColor: "#DEDDDD",
                         gridWidth: 1,
                         labelFontSize: 12,
-                        labelFont: Hm,
+                        labelFont: Qm,
                         labelPadding: 8,
                         ticks: !1,
                         titleFontSize: 12,
                         titlePadding: 10,
-                        titleFont: Wm,
+                        titleFont: Km,
                         titleAngle: 0,
                         titleY: -10,
                         titleX: 18
                     },
                     legend: {
                         labelFontSize: 12,
-                        labelFont: Hm,
+                        labelFont: Qm,
                         symbolSize: 100,
                         titleFontSize: 12,
                         titlePadding: 10,
-                        titleFont: Wm,
+                        titleFont: Km,
                         orient: "right",
                         offset: 10
                     },
                     view: {
                         stroke: "transparent"
                     },
                     range: {
-                        category: Xm["six-groups-cat-1"],
-                        diverging: Xm["diverging-colors"],
-                        heatmap: Xm["diverging-colors"],
-                        ordinal: Xm["six-groups-seq"],
-                        ramp: Xm["shades-blue"]
+                        category: tg["six-groups-cat-1"],
+                        diverging: tg["diverging-colors"],
+                        heatmap: tg["diverging-colors"],
+                        ordinal: tg["six-groups-seq"],
+                        ramp: tg["shades-blue"]
                     },
                     area: {
-                        fill: Um
+                        fill: Ym
                     },
                     rect: {
-                        fill: Um
+                        fill: Ym
                     },
                     line: {
-                        color: Um,
-                        stroke: Um,
+                        color: Ym,
+                        stroke: Ym,
                         strokeWidth: 5
                     },
                     trail: {
-                        color: Um,
-                        stroke: Um,
+                        color: Ym,
+                        stroke: Ym,
                         strokeWidth: 0,
                         size: 1
                     },
                     path: {
-                        stroke: Um,
+                        stroke: Ym,
                         strokeWidth: .5
                     },
                     point: {
                         filled: !0
                     },
                     text: {
                         font: "Lato",
-                        color: Um,
+                        color: Ym,
                         fontSize: 11,
                         align: "center",
                         fontWeight: 400,
                         size: 11
                     },
                     style: {
                         bar: {
-                            fill: Um,
+                            fill: Ym,
                             stroke: null
                         }
                     },
                     arc: {
-                        fill: Um
+                        fill: Ym
                     },
                     shape: {
-                        stroke: Um
+                        stroke: Ym
                     },
                     symbol: {
-                        fill: Um,
+                        fill: Ym,
                         size: 30
                     }
                 },
-                Gm = "#3366CC",
-                $m = "#ccc",
-                Zm = "Arial, sans-serif",
-                Ym = {
+                ng = "#3366CC",
+                ig = "#ccc",
+                rg = "Arial, sans-serif",
+                og = {
                     arc: {
-                        fill: Gm
+                        fill: ng
                     },
                     area: {
-                        fill: Gm
+                        fill: ng
                     },
                     path: {
-                        stroke: Gm
+                        stroke: ng
                     },
                     rect: {
-                        fill: Gm
+                        fill: ng
                     },
                     shape: {
-                        stroke: Gm
+                        stroke: ng
                     },
                     symbol: {
-                        stroke: Gm
+                        stroke: ng
                     },
                     circle: {
-                        fill: Gm
+                        fill: ng
                     },
                     background: "#fff",
                     padding: {
                         top: 10,
                         right: 10,
                         bottom: 10,
                         left: 10
                     },
                     style: {
                         "guide-label": {
-                            font: Zm,
+                            font: rg,
                             fontSize: 12
                         },
                         "guide-title": {
-                            font: Zm,
+                            font: rg,
                             fontSize: 12
                         },
                         "group-title": {
-                            font: Zm,
+                            font: rg,
                             fontSize: 12
                         }
                     },
                     title: {
-                        font: Zm,
+                        font: rg,
                         fontSize: 14,
                         fontWeight: "bold",
                         dy: -3,
                         anchor: "start"
                     },
                     axis: {
-                        gridColor: $m,
-                        tickColor: $m,
+                        gridColor: ig,
+                        tickColor: ig,
                         domain: !1,
                         grid: !0
                     },
                     range: {
                         category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
                         heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
                     }
                 },
-                Vm = t => t * (1 / 3 + 1),
-                Km = Vm(9),
-                Qm = Vm(10),
-                tg = Vm(12),
-                eg = "Segoe UI",
-                ng = "wf_standard-font, helvetica, arial, sans-serif",
-                ig = "#252423",
-                rg = "#605E5C",
-                og = "transparent",
-                ag = "#118DFF",
-                sg = "#DEEFFF",
-                cg = [sg, ag],
-                lg = {
+                ag = t => t * (1 / 3 + 1),
+                sg = ag(9),
+                cg = ag(10),
+                lg = ag(12),
+                ug = "Segoe UI",
+                fg = "wf_standard-font, helvetica, arial, sans-serif",
+                dg = "#252423",
+                hg = "#605E5C",
+                pg = "transparent",
+                mg = "#118DFF",
+                gg = "#DEEFFF",
+                vg = [gg, mg],
+                yg = {
                     view: {
-                        stroke: og
+                        stroke: pg
                     },
-                    background: og,
-                    font: eg,
+                    background: pg,
+                    font: ug,
                     header: {
-                        titleFont: ng,
-                        titleFontSize: tg,
-                        titleColor: ig,
-                        labelFont: eg,
-                        labelFontSize: Qm,
-                        labelColor: rg
+                        titleFont: fg,
+                        titleFontSize: lg,
+                        titleColor: dg,
+                        labelFont: ug,
+                        labelFontSize: cg,
+                        labelColor: hg
                     },
                     axis: {
                         ticks: !1,
                         grid: !1,
                         domain: !1,
-                        labelColor: rg,
-                        labelFontSize: Km,
-                        titleFont: ng,
-                        titleColor: ig,
-                        titleFontSize: tg,
+                        labelColor: hg,
+                        labelFontSize: sg,
+                        titleFont: fg,
+                        titleColor: dg,
+                        titleFontSize: lg,
                         titleFontWeight: "normal"
                     },
                     axisQuantitative: {
                         tickCount: 3,
                         grid: !0,
                         gridColor: "#C8C6C4",
                         gridDash: [1, 5],
@@ -16721,76 +16865,76 @@
                     axisX: {
                         labelPadding: 5
                     },
                     axisY: {
                         labelPadding: 10
                     },
                     bar: {
-                        fill: ag
+                        fill: mg
                     },
                     line: {
-                        stroke: ag,
+                        stroke: mg,
                         strokeWidth: 3,
                         strokeCap: "round",
                         strokeJoin: "round"
                     },
                     text: {
-                        font: eg,
-                        fontSize: Km,
-                        fill: rg
+                        font: ug,
+                        fontSize: sg,
+                        fill: hg
                     },
                     arc: {
-                        fill: ag
+                        fill: mg
                     },
                     area: {
-                        fill: ag,
+                        fill: mg,
                         line: !0,
                         opacity: .6
                     },
                     path: {
-                        stroke: ag
+                        stroke: mg
                     },
                     rect: {
-                        fill: ag
+                        fill: mg
                     },
                     point: {
-                        fill: ag,
+                        fill: mg,
                         filled: !0,
                         size: 75
                     },
                     shape: {
-                        stroke: ag
+                        stroke: mg
                     },
                     symbol: {
-                        fill: ag,
+                        fill: mg,
                         strokeWidth: 1.5,
                         size: 50
                     },
                     legend: {
-                        titleFont: eg,
+                        titleFont: ug,
                         titleFontWeight: "bold",
-                        titleColor: rg,
-                        labelFont: eg,
-                        labelFontSize: Qm,
-                        labelColor: rg,
+                        titleColor: hg,
+                        labelFont: ug,
+                        labelFontSize: cg,
+                        labelColor: hg,
                         symbolType: "circle",
                         symbolSize: 75
                     },
                     range: {
-                        category: [ag, "#12239E", "#E66C37", "#6B007B", "#E044A7", "#744EC2", "#D9B300", "#D64550"],
-                        diverging: cg,
-                        heatmap: cg,
-                        ordinal: [sg, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", ag]
+                        category: [mg, "#12239E", "#E66C37", "#6B007B", "#E044A7", "#744EC2", "#D9B300", "#D64550"],
+                        diverging: vg,
+                        heatmap: vg,
+                        ordinal: [gg, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", mg]
                     }
                 },
-                ug = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif',
-                fg = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"],
-                dg = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
+                bg = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif',
+                xg = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"],
+                _g = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
 
-            function hg(t) {
+            function wg(t) {
                 let {
                     type: e,
                     background: n
                 } = t;
                 const i = "dark" === e ? "#161616" : "#ffffff",
                     r = "dark" === e ? "#f4f4f4" : "#161616",
                     o = "dark" === e ? "#d4bbff" : "#6929c4";
@@ -16825,133 +16969,134 @@
                         fill: i
                     },
                     title: {
                         color: r,
                         anchor: "start",
                         dy: -15,
                         fontSize: 16,
-                        font: ug,
+                        font: bg,
                         fontWeight: 600
                     },
                     axis: {
                         labelColor: r,
                         labelFontSize: 12,
                         grid: !0,
                         gridColor: "#525252",
                         titleColor: r,
                         labelAngle: 0
                     },
                     style: {
                         "guide-label": {
-                            font: ug,
+                            font: bg,
                             fill: r,
                             fontWeight: 400
                         },
                         "guide-title": {
-                            font: ug,
+                            font: bg,
                             fill: r,
                             fontWeight: 400
                         }
                     },
                     range: {
-                        category: "dark" === e ? fg : dg,
+                        category: "dark" === e ? xg : _g,
                         diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
                         heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
                     }
                 }
             }
-            const pg = hg({
+            const kg = wg({
                     type: "light",
                     background: "#ffffff"
                 }),
-                mg = hg({
+                Eg = wg({
                     type: "light",
                     background: "#f4f4f4"
                 }),
-                gg = hg({
+                Ag = wg({
                     type: "dark",
                     background: "#262626"
                 }),
-                vg = hg({
+                Dg = wg({
                     type: "dark",
                     background: "#161616"
                 }),
-                yg = vm;
+                Sg = Dm;
 
-            function bg(t, e) {
+            function Cg(t, e) {
                 return JSON.stringify(t, function(t) {
                     const e = [];
                     return function(n, i) {
                         if ("object" !== typeof i || null === i) return i;
                         const r = e.indexOf(this) + 1;
                         return e.length = r, e.length > t ? "[Object]" : e.indexOf(i) >= 0 ? "[Circular]" : (e.push(i), i)
                     }
                 }(e))
             }
-            const xg = "vg-tooltip-element",
-                _g = {
+            const Mg = "vg-tooltip-element",
+                Fg = {
                     offsetX: 10,
                     offsetY: 10,
-                    id: xg,
+                    id: Mg,
                     styleId: "vega-tooltip-style",
                     theme: "light",
                     disableDefaultStyle: !1,
                     sanitize: function(t) {
                         return String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;")
                     },
                     maxDepth: 2,
-                    formatTooltip: function(t, e, n) {
-                        if ((0, U.kJ)(t)) return "[".concat(t.map((t => e((0, U.HD)(t) ? t : bg(t, n)))).join(", "), "]");
+                    formatTooltip: function(t, e, n, i) {
+                        if ((0, U.kJ)(t)) return "[".concat(t.map((t => e((0, U.HD)(t) ? t : Cg(t, n)))).join(", "), "]");
                         if ((0, U.Kn)(t)) {
-                            let i = "";
+                            let r = "";
                             const {
-                                title: r,
-                                image: o,
-                                ...a
+                                title: o,
+                                image: a,
+                                ...s
                             } = t;
-                            r && (i += "<h2>".concat(e(r), "</h2>")), o && (i += '<img src="'.concat(e(o), '">'));
-                            const s = Object.keys(a);
-                            if (s.length > 0) {
-                                i += "<table>";
-                                for (const t of s) {
-                                    let r = a[t];
-                                    void 0 !== r && ((0, U.Kn)(r) && (r = bg(r, n)), i += '<tr><td class="key">'.concat(e(t), '</td><td class="value">').concat(e(r), "</td></tr>"))
+                            o && (r += "<h2>".concat(e(o), "</h2>")), a && (r += '<img src="'.concat(new URL(e(a), i || location.href).href, '">'));
+                            const c = Object.keys(s);
+                            if (c.length > 0) {
+                                r += "<table>";
+                                for (const t of c) {
+                                    let i = s[t];
+                                    void 0 !== i && ((0, U.Kn)(i) && (i = Cg(i, n)), r += '<tr><td class="key">'.concat(e(t), '</td><td class="value">').concat(e(i), "</td></tr>"))
                                 }
-                                i += "</table>"
+                                r += "</table>"
                             }
-                            return i || "{}"
+                            return r || "{}"
                         }
                         return e(t)
-                    }
+                    },
+                    baseURL: ""
                 };
-            class wg {
+            class Og {
                 constructor(t) {
                     this.options = {
-                        ..._g,
+                        ...Fg,
                         ...t
                     };
                     const e = this.options.id;
                     if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
                         const t = document.createElement("style");
                         t.setAttribute("id", this.options.styleId), t.innerHTML = function(t) {
                             if (!/^[A-Za-z]+[-:.\w]*$/.test(t)) throw new Error("Invalid HTML ID");
-                            return "#vg-tooltip-element {\n  visibility: hidden;\n  padding: 8px;\n  position: fixed;\n  z-index: 1000;\n  font-family: sans-serif;\n  font-size: 11px;\n  border-radius: 3px;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);\n  /* The default theme is the light theme. */\n  background-color: rgba(255, 255, 255, 0.95);\n  border: 1px solid #d9d9d9;\n  color: black;\n}\n#vg-tooltip-element.visible {\n  visibility: visible;\n}\n#vg-tooltip-element h2 {\n  margin-top: 0;\n  margin-bottom: 10px;\n  font-size: 13px;\n}\n#vg-tooltip-element table {\n  border-spacing: 0;\n}\n#vg-tooltip-element table tr {\n  border: none;\n}\n#vg-tooltip-element table tr td {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n#vg-tooltip-element table tr td.key {\n  color: #808080;\n  max-width: 150px;\n  text-align: right;\n  padding-right: 4px;\n}\n#vg-tooltip-element table tr td.value {\n  display: block;\n  max-width: 300px;\n  max-height: 7em;\n  text-align: left;\n}\n#vg-tooltip-element.dark-theme {\n  background-color: rgba(32, 32, 32, 0.9);\n  border: 1px solid #f5f5f5;\n  color: white;\n}\n#vg-tooltip-element.dark-theme td.key {\n  color: #bfbfbf;\n}\n".toString().replace(xg, t)
+                            return "#vg-tooltip-element {\n  visibility: hidden;\n  padding: 8px;\n  position: fixed;\n  z-index: 1000;\n  font-family: sans-serif;\n  font-size: 11px;\n  border-radius: 3px;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);\n  /* The default theme is the light theme. */\n  background-color: rgba(255, 255, 255, 0.95);\n  border: 1px solid #d9d9d9;\n  color: black;\n}\n#vg-tooltip-element.visible {\n  visibility: visible;\n}\n#vg-tooltip-element h2 {\n  margin-top: 0;\n  margin-bottom: 10px;\n  font-size: 13px;\n}\n#vg-tooltip-element table {\n  border-spacing: 0;\n}\n#vg-tooltip-element table tr {\n  border: none;\n}\n#vg-tooltip-element table tr td {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n#vg-tooltip-element table tr td.key {\n  color: #808080;\n  max-width: 150px;\n  text-align: right;\n  padding-right: 4px;\n}\n#vg-tooltip-element table tr td.value {\n  display: block;\n  max-width: 300px;\n  max-height: 7em;\n  text-align: left;\n}\n#vg-tooltip-element.dark-theme {\n  background-color: rgba(32, 32, 32, 0.9);\n  border: 1px solid #f5f5f5;\n  color: white;\n}\n#vg-tooltip-element.dark-theme td.key {\n  color: #bfbfbf;\n}\n".toString().replace(Mg, t)
                         }(e);
                         const n = document.head;
                         n.childNodes.length > 0 ? n.insertBefore(t, n.childNodes[0]) : n.appendChild(t)
                     }
                 }
                 tooltipHandler(t, e, n, i) {
                     if (this.el = document.getElementById(this.options.id), !this.el) {
                         var r;
                         this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip");
                         (null !== (r = document.fullscreenElement) && void 0 !== r ? r : document.body).appendChild(this.el)
                     }
                     if (null == i || "" === i) return void this.el.classList.remove("visible", "".concat(this.options.theme, "-theme"));
-                    this.el.innerHTML = this.options.formatTooltip(i, this.options.sanitize, this.options.maxDepth), this.el.classList.add("visible", "".concat(this.options.theme, "-theme"));
+                    this.el.innerHTML = this.options.formatTooltip(i, this.options.sanitize, this.options.maxDepth, this.options.baseURL), this.el.classList.add("visible", "".concat(this.options.theme, "-theme"));
                     const {
                         x: o,
                         y: a
                     } = function(t, e, n, i) {
                         let r = t.clientX + n;
                         r + e.width > window.innerWidth && (r = +t.clientX - n - e.width);
                         let o = t.clientY + i;
@@ -16959,349 +17104,318 @@
                             x: r,
                             y: o
                         }
                     }(e, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
                     this.el.style.top = "".concat(a, "px"), this.el.style.left = "".concat(o, "px")
                 }
             }
-            var kg, Eg, Dg;
-
-            function Ag(t) {
-                return Ag = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
-                    return typeof t
-                } : function(t) {
-                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
-                }, Ag(t)
-            }
+            var Tg, Ng, Rg;
 
-            function Sg(t) {
-                var e = function(t, e) {
-                    if ("object" !== Ag(t) || null === t) return t;
-                    var n = t[Symbol.toPrimitive];
-                    if (void 0 !== n) {
-                        var i = n.call(t, e || "default");
-                        if ("object" !== Ag(i)) return i;
-                        throw new TypeError("@@toPrimitive must return a primitive value.")
-                    }
-                    return ("string" === e ? String : Number)(t)
-                }(t, "string");
-                return "symbol" === Ag(e) ? e : String(e)
-            }
-
-            function Cg(t, e, n) {
-                return (e = Sg(e)) in t ? Object.defineProperty(t, e, {
-                    value: n,
-                    enumerable: !0,
-                    configurable: !0,
-                    writable: !0
-                }) : t[e] = n, t
-            }
-
-            function Fg(t) {
+            function zg(t) {
                 return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
             }
-            var Mg = Og;
+            var Pg = Lg;
 
-            function Og(t) {
+            function Lg(t) {
                 var e = this;
-                if (e instanceof Og || (e = new Og), e.tail = null, e.head = null, e.length = 0, t && "function" === typeof t.forEach) t.forEach((function(t) {
+                if (e instanceof Lg || (e = new Lg), e.tail = null, e.head = null, e.length = 0, t && "function" === typeof t.forEach) t.forEach((function(t) {
                     e.push(t)
                 }));
                 else if (arguments.length > 0)
                     for (var n = 0, i = arguments.length; n < i; n++) e.push(arguments[n]);
                 return e
             }
 
-            function Tg(t, e, n) {
-                var i = e === t.head ? new Rg(n, null, e, t) : new Rg(n, e, e.next, t);
+            function Bg(t, e, n) {
+                var i = e === t.head ? new Ug(n, null, e, t) : new Ug(n, e, e.next, t);
                 return null === i.next && (t.tail = i), null === i.prev && (t.head = i), t.length++, i
             }
 
-            function Ng(t, e) {
-                t.tail = new Rg(e, t.tail, null, t), t.head || (t.head = t.tail), t.length++
+            function Ig(t, e) {
+                t.tail = new Ug(e, t.tail, null, t), t.head || (t.head = t.tail), t.length++
             }
 
-            function zg(t, e) {
-                t.head = new Rg(e, null, t.head, t), t.tail || (t.tail = t.head), t.length++
+            function jg(t, e) {
+                t.head = new Ug(e, null, t.head, t), t.tail || (t.tail = t.head), t.length++
             }
 
-            function Rg(t, e, n, i) {
-                if (!(this instanceof Rg)) return new Rg(t, e, n, i);
+            function Ug(t, e, n, i) {
+                if (!(this instanceof Ug)) return new Ug(t, e, n, i);
                 this.list = i, this.value = t, e ? (e.next = this, this.prev = e) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null
             }
-            Og.Node = Rg, Og.create = Og, Og.prototype.removeNode = function(t) {
+            Lg.Node = Ug, Lg.create = Lg, Lg.prototype.removeNode = function(t) {
                 if (t.list !== this) throw new Error("removing node which does not belong to this list");
                 var e = t.next,
                     n = t.prev;
                 return e && (e.prev = n), n && (n.next = e), t === this.head && (this.head = e), t === this.tail && (this.tail = n), t.list.length--, t.next = null, t.prev = null, t.list = null, e
-            }, Og.prototype.unshiftNode = function(t) {
+            }, Lg.prototype.unshiftNode = function(t) {
                 if (t !== this.head) {
                     t.list && t.list.removeNode(t);
                     var e = this.head;
                     t.list = this, t.next = e, e && (e.prev = t), this.head = t, this.tail || (this.tail = t), this.length++
                 }
-            }, Og.prototype.pushNode = function(t) {
+            }, Lg.prototype.pushNode = function(t) {
                 if (t !== this.tail) {
                     t.list && t.list.removeNode(t);
                     var e = this.tail;
                     t.list = this, t.prev = e, e && (e.next = t), this.tail = t, this.head || (this.head = t), this.length++
                 }
-            }, Og.prototype.push = function() {
-                for (var t = 0, e = arguments.length; t < e; t++) Ng(this, arguments[t]);
+            }, Lg.prototype.push = function() {
+                for (var t = 0, e = arguments.length; t < e; t++) Ig(this, arguments[t]);
                 return this.length
-            }, Og.prototype.unshift = function() {
-                for (var t = 0, e = arguments.length; t < e; t++) zg(this, arguments[t]);
+            }, Lg.prototype.unshift = function() {
+                for (var t = 0, e = arguments.length; t < e; t++) jg(this, arguments[t]);
                 return this.length
-            }, Og.prototype.pop = function() {
+            }, Lg.prototype.pop = function() {
                 if (this.tail) {
                     var t = this.tail.value;
                     return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t
                 }
-            }, Og.prototype.shift = function() {
+            }, Lg.prototype.shift = function() {
                 if (this.head) {
                     var t = this.head.value;
                     return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t
                 }
-            }, Og.prototype.forEach = function(t, e) {
+            }, Lg.prototype.forEach = function(t, e) {
                 e = e || this;
                 for (var n = this.head, i = 0; null !== n; i++) t.call(e, n.value, i, this), n = n.next
-            }, Og.prototype.forEachReverse = function(t, e) {
+            }, Lg.prototype.forEachReverse = function(t, e) {
                 e = e || this;
                 for (var n = this.tail, i = this.length - 1; null !== n; i--) t.call(e, n.value, i, this), n = n.prev
-            }, Og.prototype.get = function(t) {
+            }, Lg.prototype.get = function(t) {
                 for (var e = 0, n = this.head; null !== n && e < t; e++) n = n.next;
                 if (e === t && null !== n) return n.value
-            }, Og.prototype.getReverse = function(t) {
+            }, Lg.prototype.getReverse = function(t) {
                 for (var e = 0, n = this.tail; null !== n && e < t; e++) n = n.prev;
                 if (e === t && null !== n) return n.value
-            }, Og.prototype.map = function(t, e) {
+            }, Lg.prototype.map = function(t, e) {
                 e = e || this;
-                for (var n = new Og, i = this.head; null !== i;) n.push(t.call(e, i.value, this)), i = i.next;
+                for (var n = new Lg, i = this.head; null !== i;) n.push(t.call(e, i.value, this)), i = i.next;
                 return n
-            }, Og.prototype.mapReverse = function(t, e) {
+            }, Lg.prototype.mapReverse = function(t, e) {
                 e = e || this;
-                for (var n = new Og, i = this.tail; null !== i;) n.push(t.call(e, i.value, this)), i = i.prev;
+                for (var n = new Lg, i = this.tail; null !== i;) n.push(t.call(e, i.value, this)), i = i.prev;
                 return n
-            }, Og.prototype.reduce = function(t, e) {
+            }, Lg.prototype.reduce = function(t, e) {
                 var n, i = this.head;
                 if (arguments.length > 1) n = e;
                 else {
                     if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
                     i = this.head.next, n = this.head.value
                 }
                 for (var r = 0; null !== i; r++) n = t(n, i.value, r), i = i.next;
                 return n
-            }, Og.prototype.reduceReverse = function(t, e) {
+            }, Lg.prototype.reduceReverse = function(t, e) {
                 var n, i = this.tail;
                 if (arguments.length > 1) n = e;
                 else {
                     if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
                     i = this.tail.prev, n = this.tail.value
                 }
                 for (var r = this.length - 1; null !== i; r--) n = t(n, i.value, r), i = i.prev;
                 return n
-            }, Og.prototype.toArray = function() {
+            }, Lg.prototype.toArray = function() {
                 for (var t = new Array(this.length), e = 0, n = this.head; null !== n; e++) t[e] = n.value, n = n.next;
                 return t
-            }, Og.prototype.toArrayReverse = function() {
+            }, Lg.prototype.toArrayReverse = function() {
                 for (var t = new Array(this.length), e = 0, n = this.tail; null !== n; e++) t[e] = n.value, n = n.prev;
                 return t
-            }, Og.prototype.slice = function(t, e) {
+            }, Lg.prototype.slice = function(t, e) {
                 (e = e || this.length) < 0 && (e += this.length), (t = t || 0) < 0 && (t += this.length);
-                var n = new Og;
+                var n = new Lg;
                 if (e < t || e < 0) return n;
                 t < 0 && (t = 0), e > this.length && (e = this.length);
                 for (var i = 0, r = this.head; null !== r && i < t; i++) r = r.next;
                 for (; null !== r && i < e; i++, r = r.next) n.push(r.value);
                 return n
-            }, Og.prototype.sliceReverse = function(t, e) {
+            }, Lg.prototype.sliceReverse = function(t, e) {
                 (e = e || this.length) < 0 && (e += this.length), (t = t || 0) < 0 && (t += this.length);
-                var n = new Og;
+                var n = new Lg;
                 if (e < t || e < 0) return n;
                 t < 0 && (t = 0), e > this.length && (e = this.length);
                 for (var i = this.length, r = this.tail; null !== r && i > e; i--) r = r.prev;
                 for (; null !== r && i > t; i--, r = r.prev) n.push(r.value);
                 return n
-            }, Og.prototype.splice = function(t, e) {
+            }, Lg.prototype.splice = function(t, e) {
                 t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
                 for (var n = 0, i = this.head; null !== i && n < t; n++) i = i.next;
                 var r = [];
                 for (n = 0; i && n < e; n++) r.push(i.value), i = this.removeNode(i);
                 null === i && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
-                for (n = 0; n < (arguments.length <= 2 ? 0 : arguments.length - 2); n++) i = Tg(this, i, n + 2 < 2 || arguments.length <= n + 2 ? void 0 : arguments[n + 2]);
+                for (n = 0; n < (arguments.length <= 2 ? 0 : arguments.length - 2); n++) i = Bg(this, i, n + 2 < 2 || arguments.length <= n + 2 ? void 0 : arguments[n + 2]);
                 return r
-            }, Og.prototype.reverse = function() {
+            }, Lg.prototype.reverse = function() {
                 for (var t = this.head, e = this.tail, n = t; null !== n; n = n.prev) {
                     var i = n.prev;
                     n.prev = n.next, n.next = i
                 }
                 return this.head = e, this.tail = t, this
             };
             try {
-                (Dg || (Dg = 1, Eg = function(t) {
+                (Rg || (Rg = 1, Ng = function(t) {
                     t.prototype[Symbol.iterator] = function*() {
                         for (let t = this.head; t; t = t.next) yield t.value
                     }
-                }), Eg)(Og)
-            } catch (sy) {}
-            const Pg = Mg,
-                Lg = Symbol("max"),
-                jg = Symbol("length"),
-                Bg = Symbol("lengthCalculator"),
-                Ig = Symbol("allowStale"),
-                Ug = Symbol("maxAge"),
-                qg = Symbol("dispose"),
-                Wg = Symbol("noDisposeOnSet"),
-                Hg = Symbol("lruList"),
-                Xg = Symbol("cache"),
-                Jg = Symbol("updateAgeOnGet"),
-                Gg = () => 1;
-            const $g = (t, e, n) => {
-                    const i = t[Xg].get(e);
+                }), Ng)(Lg)
+            } catch (dy) {}
+            const qg = Pg,
+                Wg = Symbol("max"),
+                Hg = Symbol("length"),
+                Xg = Symbol("lengthCalculator"),
+                Gg = Symbol("allowStale"),
+                Jg = Symbol("maxAge"),
+                Zg = Symbol("dispose"),
+                $g = Symbol("noDisposeOnSet"),
+                Yg = Symbol("lruList"),
+                Vg = Symbol("cache"),
+                Kg = Symbol("updateAgeOnGet"),
+                Qg = () => 1;
+            const tv = (t, e, n) => {
+                    const i = t[Vg].get(e);
                     if (i) {
                         const e = i.value;
-                        if (Zg(t, e)) {
-                            if (Vg(t, i), !t[Ig]) return
-                        } else n && (t[Jg] && (i.value.now = Date.now()), t[Hg].unshiftNode(i));
+                        if (ev(t, e)) {
+                            if (iv(t, i), !t[Gg]) return
+                        } else n && (t[Kg] && (i.value.now = Date.now()), t[Yg].unshiftNode(i));
                         return e.value
                     }
                 },
-                Zg = (t, e) => {
-                    if (!e || !e.maxAge && !t[Ug]) return !1;
+                ev = (t, e) => {
+                    if (!e || !e.maxAge && !t[Jg]) return !1;
                     const n = Date.now() - e.now;
-                    return e.maxAge ? n > e.maxAge : t[Ug] && n > t[Ug]
+                    return e.maxAge ? n > e.maxAge : t[Jg] && n > t[Jg]
                 },
-                Yg = t => {
-                    if (t[jg] > t[Lg])
-                        for (let e = t[Hg].tail; t[jg] > t[Lg] && null !== e;) {
+                nv = t => {
+                    if (t[Hg] > t[Wg])
+                        for (let e = t[Yg].tail; t[Hg] > t[Wg] && null !== e;) {
                             const n = e.prev;
-                            Vg(t, e), e = n
+                            iv(t, e), e = n
                         }
                 },
-                Vg = (t, e) => {
+                iv = (t, e) => {
                     if (e) {
                         const n = e.value;
-                        t[qg] && t[qg](n.key, n.value), t[jg] -= n.length, t[Xg].delete(n.key), t[Hg].removeNode(e)
+                        t[Zg] && t[Zg](n.key, n.value), t[Hg] -= n.length, t[Vg].delete(n.key), t[Yg].removeNode(e)
                     }
                 };
-            class Kg {
+            class rv {
                 constructor(t, e, n, i, r) {
                     this.key = t, this.value = e, this.length = n, this.now = i, this.maxAge = r || 0
                 }
             }
-            const Qg = (t, e, n, i) => {
+            const ov = (t, e, n, i) => {
                 let r = n.value;
-                Zg(t, r) && (Vg(t, n), t[Ig] || (r = void 0)), r && e.call(i, r.value, r.key, t)
+                ev(t, r) && (iv(t, n), t[Gg] || (r = void 0)), r && e.call(i, r.value, r.key, t)
             };
-            var tv = class {
+            var av = class {
                 constructor(t) {
                     if ("number" === typeof t && (t = {
                             max: t
                         }), t || (t = {}), t.max && ("number" !== typeof t.max || t.max < 0)) throw new TypeError("max must be a non-negative number");
-                    this[Lg] = t.max || 1 / 0;
-                    const e = t.length || Gg;
-                    if (this[Bg] = "function" !== typeof e ? Gg : e, this[Ig] = t.stale || !1, t.maxAge && "number" !== typeof t.maxAge) throw new TypeError("maxAge must be a number");
-                    this[Ug] = t.maxAge || 0, this[qg] = t.dispose, this[Wg] = t.noDisposeOnSet || !1, this[Jg] = t.updateAgeOnGet || !1, this.reset()
+                    this[Wg] = t.max || 1 / 0;
+                    const e = t.length || Qg;
+                    if (this[Xg] = "function" !== typeof e ? Qg : e, this[Gg] = t.stale || !1, t.maxAge && "number" !== typeof t.maxAge) throw new TypeError("maxAge must be a number");
+                    this[Jg] = t.maxAge || 0, this[Zg] = t.dispose, this[$g] = t.noDisposeOnSet || !1, this[Kg] = t.updateAgeOnGet || !1, this.reset()
                 }
                 set max(t) {
                     if ("number" !== typeof t || t < 0) throw new TypeError("max must be a non-negative number");
-                    this[Lg] = t || 1 / 0, Yg(this)
+                    this[Wg] = t || 1 / 0, nv(this)
                 }
                 get max() {
-                    return this[Lg]
+                    return this[Wg]
                 }
                 set allowStale(t) {
-                    this[Ig] = !!t
+                    this[Gg] = !!t
                 }
                 get allowStale() {
-                    return this[Ig]
+                    return this[Gg]
                 }
                 set maxAge(t) {
                     if ("number" !== typeof t) throw new TypeError("maxAge must be a non-negative number");
-                    this[Ug] = t, Yg(this)
+                    this[Jg] = t, nv(this)
                 }
                 get maxAge() {
-                    return this[Ug]
+                    return this[Jg]
                 }
                 set lengthCalculator(t) {
-                    "function" !== typeof t && (t = Gg), t !== this[Bg] && (this[Bg] = t, this[jg] = 0, this[Hg].forEach((t => {
-                        t.length = this[Bg](t.value, t.key), this[jg] += t.length
-                    }))), Yg(this)
+                    "function" !== typeof t && (t = Qg), t !== this[Xg] && (this[Xg] = t, this[Hg] = 0, this[Yg].forEach((t => {
+                        t.length = this[Xg](t.value, t.key), this[Hg] += t.length
+                    }))), nv(this)
                 }
                 get lengthCalculator() {
-                    return this[Bg]
+                    return this[Xg]
                 }
                 get length() {
-                    return this[jg]
+                    return this[Hg]
                 }
                 get itemCount() {
-                    return this[Hg].length
+                    return this[Yg].length
                 }
                 rforEach(t, e) {
                     e = e || this;
-                    for (let n = this[Hg].tail; null !== n;) {
+                    for (let n = this[Yg].tail; null !== n;) {
                         const i = n.prev;
-                        Qg(this, t, n, e), n = i
+                        ov(this, t, n, e), n = i
                     }
                 }
                 forEach(t, e) {
                     e = e || this;
-                    for (let n = this[Hg].head; null !== n;) {
+                    for (let n = this[Yg].head; null !== n;) {
                         const i = n.next;
-                        Qg(this, t, n, e), n = i
+                        ov(this, t, n, e), n = i
                     }
                 }
                 keys() {
-                    return this[Hg].toArray().map((t => t.key))
+                    return this[Yg].toArray().map((t => t.key))
                 }
                 values() {
-                    return this[Hg].toArray().map((t => t.value))
+                    return this[Yg].toArray().map((t => t.value))
                 }
                 reset() {
-                    this[qg] && this[Hg] && this[Hg].length && this[Hg].forEach((t => this[qg](t.key, t.value))), this[Xg] = new Map, this[Hg] = new Pg, this[jg] = 0
+                    this[Zg] && this[Yg] && this[Yg].length && this[Yg].forEach((t => this[Zg](t.key, t.value))), this[Vg] = new Map, this[Yg] = new qg, this[Hg] = 0
                 }
                 dump() {
-                    return this[Hg].map((t => !Zg(this, t) && {
+                    return this[Yg].map((t => !ev(this, t) && {
                         k: t.key,
                         v: t.value,
                         e: t.now + (t.maxAge || 0)
                     })).toArray().filter((t => t))
                 }
                 dumpLru() {
-                    return this[Hg]
+                    return this[Yg]
                 }
                 set(t, e, n) {
-                    if ((n = n || this[Ug]) && "number" !== typeof n) throw new TypeError("maxAge must be a number");
+                    if ((n = n || this[Jg]) && "number" !== typeof n) throw new TypeError("maxAge must be a number");
                     const i = n ? Date.now() : 0,
-                        r = this[Bg](e, t);
-                    if (this[Xg].has(t)) {
-                        if (r > this[Lg]) return Vg(this, this[Xg].get(t)), !1;
-                        const o = this[Xg].get(t).value;
-                        return this[qg] && (this[Wg] || this[qg](t, o.value)), o.now = i, o.maxAge = n, o.value = e, this[jg] += r - o.length, o.length = r, this.get(t), Yg(this), !0
+                        r = this[Xg](e, t);
+                    if (this[Vg].has(t)) {
+                        if (r > this[Wg]) return iv(this, this[Vg].get(t)), !1;
+                        const o = this[Vg].get(t).value;
+                        return this[Zg] && (this[$g] || this[Zg](t, o.value)), o.now = i, o.maxAge = n, o.value = e, this[Hg] += r - o.length, o.length = r, this.get(t), nv(this), !0
                     }
-                    const o = new Kg(t, e, r, i, n);
-                    return o.length > this[Lg] ? (this[qg] && this[qg](t, e), !1) : (this[jg] += o.length, this[Hg].unshift(o), this[Xg].set(t, this[Hg].head), Yg(this), !0)
+                    const o = new rv(t, e, r, i, n);
+                    return o.length > this[Wg] ? (this[Zg] && this[Zg](t, e), !1) : (this[Hg] += o.length, this[Yg].unshift(o), this[Vg].set(t, this[Yg].head), nv(this), !0)
                 }
                 has(t) {
-                    if (!this[Xg].has(t)) return !1;
-                    const e = this[Xg].get(t).value;
-                    return !Zg(this, e)
+                    if (!this[Vg].has(t)) return !1;
+                    const e = this[Vg].get(t).value;
+                    return !ev(this, e)
                 }
                 get(t) {
-                    return $g(this, t, !0)
+                    return tv(this, t, !0)
                 }
                 peek(t) {
-                    return $g(this, t, !1)
+                    return tv(this, t, !1)
                 }
                 pop() {
-                    const t = this[Hg].tail;
-                    return t ? (Vg(this, t), t.value) : null
+                    const t = this[Yg].tail;
+                    return t ? (iv(this, t), t.value) : null
                 }
                 del(t) {
-                    Vg(this, this[Xg].get(t))
+                    iv(this, this[Vg].get(t))
                 }
                 load(t) {
                     this.reset();
                     const e = Date.now();
                     for (let n = t.length - 1; n >= 0; n--) {
                         const i = t[n],
                             r = i.e || 0;
@@ -17309,36 +17423,36 @@
                         else {
                             const t = r - e;
                             t > 0 && this.set(i.k, i.v, t)
                         }
                     }
                 }
                 prune() {
-                    this[Xg].forEach(((t, e) => $g(this, e, !1)))
+                    this[Vg].forEach(((t, e) => tv(this, e, !1)))
                 }
             };
-            const ev = Object.freeze({
+            const sv = Object.freeze({
                     loose: !0
                 }),
-                nv = Object.freeze({});
-            var iv = t => t ? "object" !== typeof t ? ev : t : nv,
-                rv = {
+                cv = Object.freeze({});
+            var lv = t => t ? "object" !== typeof t ? sv : t : cv,
+                uv = {
                     exports: {}
                 };
-            var ov = {
+            var fv = {
                 MAX_LENGTH: 256,
                 MAX_SAFE_COMPONENT_LENGTH: 16,
                 MAX_SAFE_BUILD_LENGTH: 250,
                 MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
                 RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"],
                 SEMVER_SPEC_VERSION: "2.0.0",
                 FLAG_INCLUDE_PRERELEASE: 1,
                 FLAG_LOOSE: 2
             };
-            var av = "object" === typeof process && {
+            var dv = "object" === typeof process && {
                 NODE_ENV: "production",
                 PUBLIC_URL: ".",
                 WDS_SOCKET_HOST: void 0,
                 WDS_SOCKET_PATH: void 0,
                 WDS_SOCKET_PORT: void 0,
                 FAST_REFRESH: !0
             }.NODE_DEBUG && /\bsemver\b/i.test({
@@ -17353,15 +17467,15 @@
                 return console.error("SEMVER", ...e)
             } : () => {};
             ! function(t, e) {
                 const {
                     MAX_SAFE_COMPONENT_LENGTH: n,
                     MAX_SAFE_BUILD_LENGTH: i,
                     MAX_LENGTH: r
-                } = ov, o = av, a = (e = t.exports = {}).re = [], s = e.safeRe = [], c = e.src = [], l = e.t = {};
+                } = fv, o = dv, a = (e = t.exports = {}).re = [], s = e.safeRe = [], c = e.src = [], l = e.t = {};
                 let u = 0;
                 const f = "[a-zA-Z0-9-]",
                     d = [
                         ["\\s", 1],
                         ["\\d", r],
                         [f, i]
                     ],
@@ -17369,101 +17483,101 @@
                         const i = (t => {
                                 for (const [e, n] of d) t = t.split("".concat(e, "*")).join("".concat(e, "{0,").concat(n, "}")).split("".concat(e, "+")).join("".concat(e, "{1,").concat(n, "}"));
                                 return t
                             })(e),
                             r = u++;
                         o(t, r, e), l[t] = r, c[r] = e, a[r] = new RegExp(e, n ? "g" : void 0), s[r] = new RegExp(i, n ? "g" : void 0)
                     };
-                h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-]".concat(f, "*")), h("MAINVERSION", "(".concat(c[l.NUMERICIDENTIFIER], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIER], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIER], ")")), h("MAINVERSIONLOOSE", "(".concat(c[l.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIERLOOSE], ")")), h("PRERELEASEIDENTIFIER", "(?:".concat(c[l.NUMERICIDENTIFIER], "|").concat(c[l.NONNUMERICIDENTIFIER], ")")), h("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(c[l.NUMERICIDENTIFIERLOOSE], "|").concat(c[l.NONNUMERICIDENTIFIER], ")")), h("PRERELEASE", "(?:-(".concat(c[l.PRERELEASEIDENTIFIER], "(?:\\.").concat(c[l.PRERELEASEIDENTIFIER], ")*))")), h("PRERELEASELOOSE", "(?:-?(".concat(c[l.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(c[l.PRERELEASEIDENTIFIERLOOSE], ")*))")), h("BUILDIDENTIFIER", "".concat(f, "+")), h("BUILD", "(?:\\+(".concat(c[l.BUILDIDENTIFIER], "(?:\\.").concat(c[l.BUILDIDENTIFIER], ")*))")), h("FULLPLAIN", "v?".concat(c[l.MAINVERSION]).concat(c[l.PRERELEASE], "?").concat(c[l.BUILD], "?")), h("FULL", "^".concat(c[l.FULLPLAIN], "$")), h("LOOSEPLAIN", "[v=\\s]*".concat(c[l.MAINVERSIONLOOSE]).concat(c[l.PRERELEASELOOSE], "?").concat(c[l.BUILD], "?")), h("LOOSE", "^".concat(c[l.LOOSEPLAIN], "$")), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", "".concat(c[l.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), h("XRANGEIDENTIFIER", "".concat(c[l.NUMERICIDENTIFIER], "|x|X|\\*")), h("XRANGEPLAIN", "[v=\\s]*(".concat(c[l.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIER], ")") + "(?:".concat(c[l.PRERELEASE], ")?").concat(c[l.BUILD], "?") + ")?)?"), h("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(c[l.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(c[l.PRERELEASELOOSE], ")?").concat(c[l.BUILD], "?") + ")?)?"), h("XRANGE", "^".concat(c[l.GTLT], "\\s*").concat(c[l.XRANGEPLAIN], "$")), h("XRANGELOOSE", "^".concat(c[l.GTLT], "\\s*").concat(c[l.XRANGEPLAINLOOSE], "$")), h("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n, "})") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:$|[^\\d])"), h("COERCERTL", c[l.COERCE], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", "(\\s*)".concat(c[l.LONETILDE], "\\s+"), !0), e.tildeTrimReplace = "$1~", h("TILDE", "^".concat(c[l.LONETILDE]).concat(c[l.XRANGEPLAIN], "$")), h("TILDELOOSE", "^".concat(c[l.LONETILDE]).concat(c[l.XRANGEPLAINLOOSE], "$")), h("LONECARET", "(?:\\^)"), h("CARETTRIM", "(\\s*)".concat(c[l.LONECARET], "\\s+"), !0), e.caretTrimReplace = "$1^", h("CARET", "^".concat(c[l.LONECARET]).concat(c[l.XRANGEPLAIN], "$")), h("CARETLOOSE", "^".concat(c[l.LONECARET]).concat(c[l.XRANGEPLAINLOOSE], "$")), h("COMPARATORLOOSE", "^".concat(c[l.GTLT], "\\s*(").concat(c[l.LOOSEPLAIN], ")$|^$")), h("COMPARATOR", "^".concat(c[l.GTLT], "\\s*(").concat(c[l.FULLPLAIN], ")$|^$")), h("COMPARATORTRIM", "(\\s*)".concat(c[l.GTLT], "\\s*(").concat(c[l.LOOSEPLAIN], "|").concat(c[l.XRANGEPLAIN], ")"), !0), e.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", "^\\s*(".concat(c[l.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(c[l.XRANGEPLAIN], ")") + "\\s*$"), h("HYPHENRANGELOOSE", "^\\s*(".concat(c[l.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(c[l.XRANGEPLAINLOOSE], ")") + "\\s*$"), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
-            }(rv, rv.exports);
-            var sv = rv.exports;
-            const cv = /^[0-9]+$/,
-                lv = (t, e) => {
-                    const n = cv.test(t),
-                        i = cv.test(e);
+                h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-]".concat(f, "*")), h("MAINVERSION", "(".concat(c[l.NUMERICIDENTIFIER], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIER], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIER], ")")), h("MAINVERSIONLOOSE", "(".concat(c[l.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(c[l.NUMERICIDENTIFIERLOOSE], ")")), h("PRERELEASEIDENTIFIER", "(?:".concat(c[l.NUMERICIDENTIFIER], "|").concat(c[l.NONNUMERICIDENTIFIER], ")")), h("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(c[l.NUMERICIDENTIFIERLOOSE], "|").concat(c[l.NONNUMERICIDENTIFIER], ")")), h("PRERELEASE", "(?:-(".concat(c[l.PRERELEASEIDENTIFIER], "(?:\\.").concat(c[l.PRERELEASEIDENTIFIER], ")*))")), h("PRERELEASELOOSE", "(?:-?(".concat(c[l.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(c[l.PRERELEASEIDENTIFIERLOOSE], ")*))")), h("BUILDIDENTIFIER", "".concat(f, "+")), h("BUILD", "(?:\\+(".concat(c[l.BUILDIDENTIFIER], "(?:\\.").concat(c[l.BUILDIDENTIFIER], ")*))")), h("FULLPLAIN", "v?".concat(c[l.MAINVERSION]).concat(c[l.PRERELEASE], "?").concat(c[l.BUILD], "?")), h("FULL", "^".concat(c[l.FULLPLAIN], "$")), h("LOOSEPLAIN", "[v=\\s]*".concat(c[l.MAINVERSIONLOOSE]).concat(c[l.PRERELEASELOOSE], "?").concat(c[l.BUILD], "?")), h("LOOSE", "^".concat(c[l.LOOSEPLAIN], "$")), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", "".concat(c[l.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), h("XRANGEIDENTIFIER", "".concat(c[l.NUMERICIDENTIFIER], "|x|X|\\*")), h("XRANGEPLAIN", "[v=\\s]*(".concat(c[l.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIER], ")") + "(?:".concat(c[l.PRERELEASE], ")?").concat(c[l.BUILD], "?") + ")?)?"), h("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(c[l.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(c[l.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(c[l.PRERELEASELOOSE], ")?").concat(c[l.BUILD], "?") + ")?)?"), h("XRANGE", "^".concat(c[l.GTLT], "\\s*").concat(c[l.XRANGEPLAIN], "$")), h("XRANGELOOSE", "^".concat(c[l.GTLT], "\\s*").concat(c[l.XRANGEPLAINLOOSE], "$")), h("COERCEPLAIN", "".concat("(^|[^\\d])(\\d{1,").concat(n, "})") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:\\.(\\d{1,".concat(n, "}))?")), h("COERCE", "".concat(c[l.COERCEPLAIN], "(?:$|[^\\d])")), h("COERCEFULL", c[l.COERCEPLAIN] + "(?:".concat(c[l.PRERELEASE], ")?") + "(?:".concat(c[l.BUILD], ")?") + "(?:$|[^\\d])"), h("COERCERTL", c[l.COERCE], !0), h("COERCERTLFULL", c[l.COERCEFULL], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", "(\\s*)".concat(c[l.LONETILDE], "\\s+"), !0), e.tildeTrimReplace = "$1~", h("TILDE", "^".concat(c[l.LONETILDE]).concat(c[l.XRANGEPLAIN], "$")), h("TILDELOOSE", "^".concat(c[l.LONETILDE]).concat(c[l.XRANGEPLAINLOOSE], "$")), h("LONECARET", "(?:\\^)"), h("CARETTRIM", "(\\s*)".concat(c[l.LONECARET], "\\s+"), !0), e.caretTrimReplace = "$1^", h("CARET", "^".concat(c[l.LONECARET]).concat(c[l.XRANGEPLAIN], "$")), h("CARETLOOSE", "^".concat(c[l.LONECARET]).concat(c[l.XRANGEPLAINLOOSE], "$")), h("COMPARATORLOOSE", "^".concat(c[l.GTLT], "\\s*(").concat(c[l.LOOSEPLAIN], ")$|^$")), h("COMPARATOR", "^".concat(c[l.GTLT], "\\s*(").concat(c[l.FULLPLAIN], ")$|^$")), h("COMPARATORTRIM", "(\\s*)".concat(c[l.GTLT], "\\s*(").concat(c[l.LOOSEPLAIN], "|").concat(c[l.XRANGEPLAIN], ")"), !0), e.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", "^\\s*(".concat(c[l.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(c[l.XRANGEPLAIN], ")") + "\\s*$"), h("HYPHENRANGELOOSE", "^\\s*(".concat(c[l.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(c[l.XRANGEPLAINLOOSE], ")") + "\\s*$"), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
+            }(uv, uv.exports);
+            var hv = uv.exports;
+            const pv = /^[0-9]+$/,
+                mv = (t, e) => {
+                    const n = pv.test(t),
+                        i = pv.test(e);
                     return n && i && (t = +t, e = +e), t === e ? 0 : n && !i ? -1 : i && !n ? 1 : t < e ? -1 : 1
                 };
-            var uv = {
-                compareIdentifiers: lv,
-                rcompareIdentifiers: (t, e) => lv(e, t)
+            var gv = {
+                compareIdentifiers: mv,
+                rcompareIdentifiers: (t, e) => mv(e, t)
             };
-            const fv = av,
+            const vv = dv,
                 {
-                    MAX_LENGTH: dv,
-                    MAX_SAFE_INTEGER: hv
-                } = ov,
+                    MAX_LENGTH: yv,
+                    MAX_SAFE_INTEGER: bv
+                } = fv,
                 {
-                    safeRe: pv,
-                    t: mv
-                } = sv,
-                gv = iv,
+                    safeRe: xv,
+                    t: _v
+                } = hv,
+                wv = lv,
                 {
-                    compareIdentifiers: vv
-                } = uv;
-            var yv = class t {
+                    compareIdentifiers: kv
+                } = gv;
+            var Ev = class t {
                 constructor(e, n) {
-                    if (n = gv(n), e instanceof t) {
+                    if (n = wv(n), e instanceof t) {
                         if (e.loose === !!n.loose && e.includePrerelease === !!n.includePrerelease) return e;
                         e = e.version
                     } else if ("string" !== typeof e) throw new TypeError('Invalid version. Must be a string. Got type "'.concat(typeof e, '".'));
-                    if (e.length > dv) throw new TypeError("version is longer than ".concat(dv, " characters"));
-                    fv("SemVer", e, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
-                    const i = e.trim().match(n.loose ? pv[mv.LOOSE] : pv[mv.FULL]);
+                    if (e.length > yv) throw new TypeError("version is longer than ".concat(yv, " characters"));
+                    vv("SemVer", e, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
+                    const i = e.trim().match(n.loose ? xv[_v.LOOSE] : xv[_v.FULL]);
                     if (!i) throw new TypeError("Invalid Version: ".concat(e));
-                    if (this.raw = e, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > hv || this.major < 0) throw new TypeError("Invalid major version");
-                    if (this.minor > hv || this.minor < 0) throw new TypeError("Invalid minor version");
-                    if (this.patch > hv || this.patch < 0) throw new TypeError("Invalid patch version");
+                    if (this.raw = e, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > bv || this.major < 0) throw new TypeError("Invalid major version");
+                    if (this.minor > bv || this.minor < 0) throw new TypeError("Invalid minor version");
+                    if (this.patch > bv || this.patch < 0) throw new TypeError("Invalid patch version");
                     i[4] ? this.prerelease = i[4].split(".").map((t => {
                         if (/^[0-9]+$/.test(t)) {
                             const e = +t;
-                            if (e >= 0 && e < hv) return e
+                            if (e >= 0 && e < bv) return e
                         }
                         return t
                     })) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
                 }
                 format() {
                     return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version
                 }
                 toString() {
                     return this.version
                 }
                 compare(e) {
-                    if (fv("SemVer.compare", this.version, this.options, e), !(e instanceof t)) {
+                    if (vv("SemVer.compare", this.version, this.options, e), !(e instanceof t)) {
                         if ("string" === typeof e && e === this.version) return 0;
                         e = new t(e, this.options)
                     }
                     return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e)
                 }
                 compareMain(e) {
-                    return e instanceof t || (e = new t(e, this.options)), vv(this.major, e.major) || vv(this.minor, e.minor) || vv(this.patch, e.patch)
+                    return e instanceof t || (e = new t(e, this.options)), kv(this.major, e.major) || kv(this.minor, e.minor) || kv(this.patch, e.patch)
                 }
                 comparePre(e) {
                     if (e instanceof t || (e = new t(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
                     if (!this.prerelease.length && e.prerelease.length) return 1;
                     if (!this.prerelease.length && !e.prerelease.length) return 0;
                     let n = 0;
                     do {
                         const t = this.prerelease[n],
                             i = e.prerelease[n];
-                        if (fv("prerelease compare", n, t, i), void 0 === t && void 0 === i) return 0;
+                        if (vv("prerelease compare", n, t, i), void 0 === t && void 0 === i) return 0;
                         if (void 0 === i) return 1;
                         if (void 0 === t) return -1;
-                        if (t !== i) return vv(t, i)
+                        if (t !== i) return kv(t, i)
                     } while (++n)
                 }
                 compareBuild(e) {
                     e instanceof t || (e = new t(e, this.options));
                     let n = 0;
                     do {
                         const t = this.build[n],
                             i = e.build[n];
-                        if (fv("prerelease compare", n, t, i), void 0 === t && void 0 === i) return 0;
+                        if (vv("prerelease compare", n, t, i), void 0 === t && void 0 === i) return 0;
                         if (void 0 === i) return 1;
                         if (void 0 === t) return -1;
-                        if (t !== i) return vv(t, i)
+                        if (t !== i) return kv(t, i)
                     } while (++n)
                 }
                 inc(t, e, n) {
                     switch (t) {
                         case "premajor":
                             this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e, n);
                             break;
@@ -17495,66 +17609,66 @@
                                 if (-1 === i) {
                                     if (e === this.prerelease.join(".") && !1 === n) throw new Error("invalid increment argument: identifier already exists");
                                     this.prerelease.push(t)
                                 }
                             }
                             if (e) {
                                 let i = [e, t];
-                                !1 === n && (i = [e]), 0 === vv(this.prerelease[0], e) ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i
+                                !1 === n && (i = [e]), 0 === kv(this.prerelease[0], e) ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i
                             }
                             break
                         }
                         default:
                             throw new Error("invalid increment argument: ".concat(t))
                     }
                     return this.raw = this.format(), this.build.length && (this.raw += "+".concat(this.build.join("."))), this
                 }
             };
-            const bv = yv;
-            var xv = (t, e, n) => new bv(t, n).compare(new bv(e, n));
-            const _v = xv;
-            const wv = xv;
-            const kv = xv;
-            const Ev = xv;
-            const Dv = xv;
-            const Av = xv;
-            const Sv = (t, e, n) => 0 === _v(t, e, n),
-                Cv = (t, e, n) => 0 !== wv(t, e, n),
-                Fv = (t, e, n) => kv(t, e, n) > 0,
-                Mv = (t, e, n) => Ev(t, e, n) >= 0,
-                Ov = (t, e, n) => Dv(t, e, n) < 0,
-                Tv = (t, e, n) => Av(t, e, n) <= 0;
-            var Nv, zv, Rv, Pv, Lv = (t, e, n, i) => {
+            const Av = Ev;
+            var Dv = (t, e, n) => new Av(t, n).compare(new Av(e, n));
+            const Sv = Dv;
+            const Cv = Dv;
+            const Mv = Dv;
+            const Fv = Dv;
+            const Ov = Dv;
+            const Tv = Dv;
+            const Nv = (t, e, n) => 0 === Sv(t, e, n),
+                Rv = (t, e, n) => 0 !== Cv(t, e, n),
+                zv = (t, e, n) => Mv(t, e, n) > 0,
+                Pv = (t, e, n) => Fv(t, e, n) >= 0,
+                Lv = (t, e, n) => Ov(t, e, n) < 0,
+                Bv = (t, e, n) => Tv(t, e, n) <= 0;
+            var Iv, jv, Uv, qv, Wv = (t, e, n, i) => {
                 switch (e) {
                     case "===":
                         return "object" === typeof t && (t = t.version), "object" === typeof n && (n = n.version), t === n;
                     case "!==":
                         return "object" === typeof t && (t = t.version), "object" === typeof n && (n = n.version), t !== n;
                     case "":
                     case "=":
                     case "==":
-                        return Sv(t, n, i);
+                        return Nv(t, n, i);
                     case "!=":
-                        return Cv(t, n, i);
+                        return Rv(t, n, i);
                     case ">":
-                        return Fv(t, n, i);
+                        return zv(t, n, i);
                     case ">=":
-                        return Mv(t, n, i);
+                        return Pv(t, n, i);
                     case "<":
-                        return Ov(t, n, i);
+                        return Lv(t, n, i);
                     case "<=":
-                        return Tv(t, n, i);
+                        return Bv(t, n, i);
                     default:
                         throw new TypeError("Invalid operator: ".concat(e))
                 }
             };
 
-            function jv() {
-                if (Pv) return Rv;
-                Pv = 1;
+            function Hv() {
+                if (qv) return Uv;
+                qv = 1;
                 class t {
                     constructor(e, r) {
                         if (r = n(r), e instanceof t) return e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease ? e : new t(e.raw, r);
                         if (e instanceof i) return this.raw = e.value, this.set = [
                             [e]
                         ], this.format(), this;
                         if (this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease, this.raw = e.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((t => this.parseRange(t.trim()))).filter((t => t.length)), !this.set.length) throw new TypeError("Invalid SemVer Range: ".concat(this.raw));
@@ -17578,16 +17692,16 @@
                     }
                     parseRange(t) {
                         const n = ((this.options.includePrerelease && f) | (this.options.loose && d)) + ":" + t,
                             o = e.get(n);
                         if (o) return o;
                         const p = this.options.loose,
                             m = p ? a[s.HYPHENRANGELOOSE] : a[s.HYPHENRANGE];
-                        t = t.replace(m, A(this.options.includePrerelease)), r("hyphen replace", t), t = t.replace(a[s.COMPARATORTRIM], c), r("comparator trim", t), t = t.replace(a[s.TILDETRIM], l), r("tilde trim", t), t = t.replace(a[s.CARETTRIM], u), r("caret trim", t);
-                        let v = t.split(" ").map((t => g(t, this.options))).join(" ").split(/\s+/).map((t => D(t, this.options)));
+                        t = t.replace(m, D(this.options.includePrerelease)), r("hyphen replace", t), t = t.replace(a[s.COMPARATORTRIM], c), r("comparator trim", t), t = t.replace(a[s.TILDETRIM], l), r("tilde trim", t), t = t.replace(a[s.CARETTRIM], u), r("caret trim", t);
+                        let v = t.split(" ").map((t => g(t, this.options))).join(" ").split(/\s+/).map((t => A(t, this.options)));
                         p && (v = v.filter((t => (r("loose invalid filter", t, this.options), !!t.match(a[s.COMPARATORLOOSE]))))), r("range list", v);
                         const y = new Map,
                             b = v.map((t => new i(t, this.options)));
                         for (const e of b) {
                             if (h(e)) return [e];
                             y.set(e.value, e)
                         }
@@ -17599,30 +17713,30 @@
                         if (!(e instanceof t)) throw new TypeError("a Range is required");
                         return this.set.some((t => m(t, n) && e.set.some((e => m(e, n) && t.every((t => e.every((e => t.intersects(e, n)))))))))
                     }
                     test(t) {
                         if (!t) return !1;
                         if ("string" === typeof t) try {
                             t = new o(t, this.options)
-                        } catch (sy) {
+                        } catch (dy) {
                             return !1
                         }
                         for (let e = 0; e < this.set.length; e++)
                             if (S(this.set[e], t, this.options)) return !0;
                         return !1
                     }
                 }
-                Rv = t;
-                const e = new tv({
+                Uv = t;
+                const e = new av({
                         max: 1e3
                     }),
-                    n = iv,
+                    n = lv,
                     i = function() {
-                        if (zv) return Nv;
-                        zv = 1;
+                        if (jv) return Iv;
+                        jv = 1;
                         const t = Symbol("SemVer ANY");
                         class e {
                             static get ANY() {
                                 return t
                             }
                             constructor(i, r) {
                                 if (r = n(r), i instanceof e) {
@@ -17640,49 +17754,49 @@
                             toString() {
                                 return this.value
                             }
                             test(e) {
                                 if (a("Comparator.test", e, this.options.loose), this.semver === t || e === t) return !0;
                                 if ("string" === typeof e) try {
                                     e = new s(e, this.options)
-                                } catch (sy) {
+                                } catch (dy) {
                                     return !1
                                 }
                                 return o(e, this.operator, this.semver, this.options)
                             }
                             intersects(t, i) {
                                 if (!(t instanceof e)) throw new TypeError("a Comparator is required");
                                 return "" === this.operator ? "" === this.value || new c(t.value, i).test(this.value) : "" === t.operator ? "" === t.value || new c(this.value, i).test(t.semver) : (!(i = n(i)).includePrerelease || "<0.0.0-0" !== this.value && "<0.0.0-0" !== t.value) && !(!i.includePrerelease && (this.value.startsWith("<0.0.0") || t.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !t.operator.startsWith(">")) || !(!this.operator.startsWith("<") || !t.operator.startsWith("<")) || !(this.semver.version !== t.semver.version || !this.operator.includes("=") || !t.operator.includes("=")) || !!(o(this.semver, "<", t.semver, i) && this.operator.startsWith(">") && t.operator.startsWith("<")) || !!(o(this.semver, ">", t.semver, i) && this.operator.startsWith("<") && t.operator.startsWith(">")))
                             }
                         }
-                        Nv = e;
-                        const n = iv,
+                        Iv = e;
+                        const n = lv,
                             {
                                 safeRe: i,
                                 t: r
-                            } = sv,
-                            o = Lv,
-                            a = av,
-                            s = yv,
-                            c = jv();
-                        return Nv
+                            } = hv,
+                            o = Wv,
+                            a = dv,
+                            s = Ev,
+                            c = Hv();
+                        return Iv
                     }(),
-                    r = av,
-                    o = yv,
+                    r = dv,
+                    o = Ev,
                     {
                         safeRe: a,
                         t: s,
                         comparatorTrimReplace: c,
                         tildeTrimReplace: l,
                         caretTrimReplace: u
-                    } = sv,
+                    } = hv,
                     {
                         FLAG_INCLUDE_PRERELEASE: f,
                         FLAG_LOOSE: d
-                    } = ov,
+                    } = fv,
                     h = t => "<0.0.0-0" === t.value,
                     p = t => "" === t.value,
                     m = (t, e) => {
                         let n = !0;
                         const i = t.slice();
                         let r = i.pop();
                         for (; n && i.length;) n = i.every((t => r.intersects(t, e))), r = i.pop();
@@ -17718,149 +17832,133 @@
                                 u = l || v(a),
                                 f = u || v(s),
                                 d = f;
                             return "=" === i && d && (i = ""), c = e.includePrerelease ? "-0" : "", l ? n = ">" === i || "<" === i ? "<0.0.0-0" : "*" : i && d ? (u && (a = 0), s = 0, ">" === i ? (i = ">=", u ? (o = +o + 1, a = 0, s = 0) : (a = +a + 1, s = 0)) : "<=" === i && (i = "<", u ? o = +o + 1 : a = +a + 1), "<" === i && (c = "-0"), n = "".concat(i + o, ".").concat(a, ".").concat(s).concat(c)) : u ? n = ">=".concat(o, ".0.0").concat(c, " <").concat(+o + 1, ".0.0-0") : f && (n = ">=".concat(o, ".").concat(a, ".0").concat(c, " <").concat(o, ".").concat(+a + 1, ".0-0")), r("xRange return", n), n
                         }))
                     },
                     E = (t, e) => (r("replaceStars", t, e), t.trim().replace(a[s.STAR], "")),
-                    D = (t, e) => (r("replaceGTE0", t, e), t.trim().replace(a[e.includePrerelease ? s.GTE0PRE : s.GTE0], "")),
-                    A = t => (e, n, i, r, o, a, s, c, l, u, f, d, h) => (n = v(i) ? "" : v(r) ? ">=".concat(i, ".0.0").concat(t ? "-0" : "") : v(o) ? ">=".concat(i, ".").concat(r, ".0").concat(t ? "-0" : "") : a ? ">=".concat(n) : ">=".concat(n).concat(t ? "-0" : ""), c = v(l) ? "" : v(u) ? "<".concat(+l + 1, ".0.0-0") : v(f) ? "<".concat(l, ".").concat(+u + 1, ".0-0") : d ? "<=".concat(l, ".").concat(u, ".").concat(f, "-").concat(d) : t ? "<".concat(l, ".").concat(u, ".").concat(+f + 1, "-0") : "<=".concat(c), "".concat(n, " ").concat(c).trim()),
+                    A = (t, e) => (r("replaceGTE0", t, e), t.trim().replace(a[e.includePrerelease ? s.GTE0PRE : s.GTE0], "")),
+                    D = t => (e, n, i, r, o, a, s, c, l, u, f, d, h) => (n = v(i) ? "" : v(r) ? ">=".concat(i, ".0.0").concat(t ? "-0" : "") : v(o) ? ">=".concat(i, ".").concat(r, ".0").concat(t ? "-0" : "") : a ? ">=".concat(n) : ">=".concat(n).concat(t ? "-0" : ""), c = v(l) ? "" : v(u) ? "<".concat(+l + 1, ".0.0-0") : v(f) ? "<".concat(l, ".").concat(+u + 1, ".0-0") : d ? "<=".concat(l, ".").concat(u, ".").concat(f, "-").concat(d) : t ? "<".concat(l, ".").concat(u, ".").concat(+f + 1, "-0") : "<=".concat(c), "".concat(n, " ").concat(c).trim()),
                     S = (t, e, n) => {
                         for (let i = 0; i < t.length; i++)
                             if (!t[i].test(e)) return !1;
                         if (e.prerelease.length && !n.includePrerelease) {
                             for (let n = 0; n < t.length; n++)
                                 if (r(t[n].semver), t[n].semver !== i.ANY && t[n].semver.prerelease.length > 0) {
                                     const i = t[n].semver;
                                     if (i.major === e.major && i.minor === e.minor && i.patch === e.patch) return !0
                                 } return !1
                         }
                         return !0
                     };
-                return Rv
+                return Uv
             }
-            const Bv = jv();
-            var Iv = (t, e, n) => {
+            const Xv = Hv();
+            var Gv = (t, e, n) => {
                     try {
-                        e = new Bv(e, n)
-                    } catch (sy) {
+                        e = new Xv(e, n)
+                    } catch (dy) {
                         return !1
                     }
                     return e.test(t)
                 },
-                Uv = Fg(Iv);
-            var qv = '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n';
+                Jv = zg(Gv);
+            var Zv = '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n';
 
-            function Wv(t) {
+            function $v(t) {
                 for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
-                for (const r of n) Hv(t, r);
+                for (const r of n) Yv(t, r);
                 return t
             }
 
-            function Hv(t, e) {
-                for (const n of Object.keys(e))(0, B.writeConfig)(t, n, e[n], !0)
-            }
-
-            function Xv(t, e) {
-                var n = Object.keys(t);
-                if (Object.getOwnPropertySymbols) {
-                    var i = Object.getOwnPropertySymbols(t);
-                    e && (i = i.filter((function(e) {
-                        return Object.getOwnPropertyDescriptor(t, e).enumerable
-                    }))), n.push.apply(n, i)
-                }
-                return n
+            function Yv(t, e) {
+                for (const n of Object.keys(e))(0, I.writeConfig)(t, n, e[n], !0)
             }
-
-            function Jv(t) {
-                for (var e = 1; e < arguments.length; e++) {
-                    var n = null != arguments[e] ? arguments[e] : {};
-                    e % 2 ? Xv(Object(n), !0).forEach((function(e) {
-                        Cg(t, e, n[e])
-                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Xv(Object(n)).forEach((function(e) {
-                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
-                    }))
-                }
-                return t
-            }
-            const Gv = B;
-            let $v = o;
-            const Zv = "undefined" !== typeof window ? window : void 0;
-            void 0 === $v && null !== Zv && void 0 !== Zv && null !== (kg = Zv.vl) && void 0 !== kg && kg.compile && ($v = Zv.vl);
-            const Yv = {
+            const Vv = I;
+            let Kv = o;
+            const Qv = "undefined" !== typeof window ? window : void 0;
+            void 0 === Kv && null !== Qv && void 0 !== Qv && null !== (Tg = Qv.vl) && void 0 !== Tg && Tg.compile && (Kv = Qv.vl);
+            const ty = {
                     export: {
                         svg: !0,
                         png: !0
                     },
                     source: !0,
                     compiled: !0,
                     editor: !0
                 },
-                Vv = {
+                ey = {
                     CLICK_TO_VIEW_ACTIONS: "Click to view actions",
                     COMPILED_ACTION: "View Compiled Vega",
                     EDITOR_ACTION: "Open in Vega Editor",
                     PNG_ACTION: "Save as PNG",
                     SOURCE_ACTION: "View Source",
                     SVG_ACTION: "Save as SVG"
                 },
-                Kv = {
+                ny = {
                     vega: "Vega",
                     "vega-lite": "Vega-Lite"
                 },
-                Qv = {
-                    vega: Gv.version,
-                    "vega-lite": $v ? $v.version : "not available"
+                iy = {
+                    vega: Vv.version,
+                    "vega-lite": Kv ? Kv.version : "not available"
                 },
-                ty = {
+                ry = {
                     vega: t => t,
-                    "vega-lite": (t, e) => $v.compile(t, {
+                    "vega-lite": (t, e) => Kv.compile(t, {
                         config: e
                     }).spec
                 },
-                ey = '\n<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n  <circle r="2" cy="8" cx="2"></circle>\n  <circle r="2" cy="8" cx="8"></circle>\n  <circle r="2" cy="8" cx="14"></circle>\n</svg>',
-                ny = "chart-wrapper";
+                oy = '\n<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n  <circle r="2" cy="8" cx="2"></circle>\n  <circle r="2" cy="8" cx="8"></circle>\n  <circle r="2" cy="8" cx="14"></circle>\n</svg>',
+                ay = "chart-wrapper";
 
-            function iy(t, e, n, i) {
+            function sy(t, e, n, i) {
                 const r = "<html><head>".concat(e, '</head><body><pre><code class="json">'),
                     o = "</code></pre>".concat(n, "</body></html>"),
                     a = window.open("");
-                a.document.write(r + t + o), a.document.title = "".concat(Kv[i], " JSON Source")
+                a.document.write(r + t + o), a.document.title = "".concat(ny[i], " JSON Source")
             }
 
-            function ry(t) {
-                return (e = t) && "load" in e ? t : Gv.loader(t);
-                var e
+            function cy(t) {
+                return !(!t || !("load" in t))
+            }
+
+            function ly(t) {
+                return cy(t) ? t : Vv.loader(t)
             }
-            async function oy(t, e) {
+            async function uy(t, e) {
                 var n, i;
                 let r, o, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
-                (0, B.isString)(e) ? (o = ry(s.loader), r = JSON.parse(await o.load(e))) : r = e;
+                (0, I.isString)(e) ? (o = ly(s.loader), r = JSON.parse(await o.load(e))) : r = e;
                 const c = function(t) {
                         var e, n;
                         const i = null !== (e = null === (n = t.usermeta) || void 0 === n ? void 0 : n.embedOptions) && void 0 !== e ? e : {};
-                        return (0, B.isString)(i.defaultStyle) && (i.defaultStyle = !1), i
+                        return (0, I.isString)(i.defaultStyle) && (i.defaultStyle = !1), i
                     }(r),
                     l = c.loader;
                 var u;
-                o && !l || (o = ry(null !== (u = s.loader) && void 0 !== u ? u : l));
-                const f = await ay(c, o),
-                    d = await ay(s, o),
-                    h = Jv(Jv({}, Wv(d, f)), {}, {
-                        config: (0, B.mergeConfig)(null !== (n = d.config) && void 0 !== n ? n : {}, null !== (i = f.config) && void 0 !== i ? i : {})
-                    });
+                o && !l || (o = ly(null !== (u = s.loader) && void 0 !== u ? u : l));
+                const f = await fy(c, o),
+                    d = await fy(s, o),
+                    h = {
+                        ...$v(d, f),
+                        config: (0, I.mergeConfig)(null !== (n = d.config) && void 0 !== n ? n : {}, null !== (i = f.config) && void 0 !== i ? i : {})
+                    };
                 return await async function(t, e) {
                     var n, i, r, o, s, c, l;
                     let u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                         f = arguments.length > 3 ? arguments[3] : void 0;
-                    const d = u.theme ? (0, B.mergeConfig)(a[u.theme], null !== (n = u.config) && void 0 !== n ? n : {}) : u.config,
-                        h = (0, B.isBoolean)(u.actions) ? u.actions : Wv({}, Yv, null !== (i = u.actions) && void 0 !== i ? i : {}),
-                        p = Jv(Jv({}, Vv), u.i18n),
+                    const d = u.theme ? (0, I.mergeConfig)(a[u.theme], null !== (n = u.config) && void 0 !== n ? n : {}) : u.config,
+                        h = (0, I.isBoolean)(u.actions) ? u.actions : $v({}, ty, null !== (i = u.actions) && void 0 !== i ? i : {}),
+                        p = {
+                            ...ey,
+                            ...u.i18n
+                        },
                         m = null !== (r = u.renderer) && void 0 !== r ? r : "canvas",
-                        g = null !== (o = u.logLevel) && void 0 !== o ? o : Gv.Warn,
+                        g = null !== (o = u.logLevel) && void 0 !== o ? o : Vv.Warn,
                         v = null !== (s = u.downloadFileName) && void 0 !== s ? s : "visualization",
                         y = "string" === typeof t ? document.querySelector(t) : t;
                     if (!y) throw new Error("".concat(t, " does not exist"));
                     if (!1 !== u.defaultStyle) {
                         const t = "vega-embed-style",
                             {
                                 root: e,
@@ -17874,119 +17972,126 @@
                                 } : {
                                     root: document,
                                     rootContainer: null !== (e = document.head) && void 0 !== e ? e : document.body
                                 }
                             }(y);
                         if (!e.getElementById(t)) {
                             const e = document.createElement("style");
-                            e.id = t, e.innerHTML = void 0 === u.defaultStyle || !0 === u.defaultStyle ? qv.toString() : u.defaultStyle, n.appendChild(e)
+                            e.id = t, e.innerHTML = void 0 === u.defaultStyle || !0 === u.defaultStyle ? Zv.toString() : u.defaultStyle, n.appendChild(e)
                         }
                     }
                     const b = function(t, e) {
                         if (t.$schema) {
-                            const i = gm(t.$schema);
+                            const i = Am(t.$schema);
                             var n;
-                            e && e !== i.library && console.warn("The given visualization spec is written in ".concat(Kv[i.library], ", but mode argument sets ").concat(null !== (n = Kv[e]) && void 0 !== n ? n : e, "."));
+                            e && e !== i.library && console.warn("The given visualization spec is written in ".concat(ny[i.library], ", but mode argument sets ").concat(null !== (n = ny[e]) && void 0 !== n ? n : e, "."));
                             const r = i.library;
-                            return Uv(Qv[r], "^".concat(i.version.slice(1))) || console.warn("The input spec uses ".concat(Kv[r], " ").concat(i.version, ", but the current version of ").concat(Kv[r], " is v").concat(Qv[r], ".")), r
+                            return Jv(iy[r], "^".concat(i.version.slice(1))) || console.warn("The input spec uses ".concat(ny[r], " ").concat(i.version, ", but the current version of ").concat(ny[r], " is v").concat(iy[r], ".")), r
                         }
                         return "mark" in t || "encoding" in t || "layer" in t || "hconcat" in t || "vconcat" in t || "facet" in t || "repeat" in t ? "vega-lite" : "marks" in t || "signals" in t || "scales" in t || "axes" in t ? "vega" : null !== e && void 0 !== e ? e : "vega"
                     }(e, u.mode);
-                    let x = ty[b](e, d);
+                    let x = ry[b](e, d);
                     if ("vega-lite" === b && x.$schema) {
-                        const t = gm(x.$schema);
-                        Uv(Qv.vega, "^".concat(t.version.slice(1))) || console.warn("The compiled spec uses Vega ".concat(t.version, ", but current version is v").concat(Qv.vega, "."))
+                        const t = Am(x.$schema);
+                        Jv(iy.vega, "^".concat(t.version.slice(1))) || console.warn("The compiled spec uses Vega ".concat(t.version, ", but current version is v").concat(iy.vega, "."))
                     }
                     y.classList.add("vega-embed"), h && y.classList.add("has-actions");
                     y.innerHTML = "";
                     let _ = y;
                     if (h) {
                         const t = document.createElement("div");
-                        t.classList.add(ny), y.appendChild(t), _ = t
+                        t.classList.add(ay), y.appendChild(t), _ = t
                     }
                     const w = u.patch;
                     w && (x = w instanceof Function ? w(x) : E(x, w, !0, !1).newDocument);
-                    u.formatLocale && Gv.formatLocale(u.formatLocale);
-                    u.timeFormatLocale && Gv.timeFormatLocale(u.timeFormatLocale);
+                    u.formatLocale && Vv.formatLocale(u.formatLocale);
+                    u.timeFormatLocale && Vv.timeFormatLocale(u.timeFormatLocale);
                     if (u.expressionFunctions)
                         for (const a in u.expressionFunctions) {
                             const t = u.expressionFunctions[a];
-                            "fn" in t ? Gv.expressionFunction(a, t.fn, t.visitor) : t instanceof Function && Gv.expressionFunction(a, t)
+                            "fn" in t ? Vv.expressionFunction(a, t.fn, t.visitor) : t instanceof Function && Vv.expressionFunction(a, t)
                         }
                     const {
                         ast: k
-                    } = u, D = Gv.parse(x, "vega-lite" === b ? {} : d, {
+                    } = u, A = Vv.parse(x, "vega-lite" === b ? {} : d, {
                         ast: k
-                    }), A = new(u.viewClass || Gv.View)(D, Jv({
+                    }), D = new(u.viewClass || Vv.View)(A, {
                         loader: f,
                         logLevel: g,
-                        renderer: m
-                    }, k ? {
-                        expr: null !== (c = null !== (l = Gv.expressionInterpreter) && void 0 !== l ? l : u.expr) && void 0 !== c ? c : I.N
-                    } : {}));
-                    if (A.addSignalListener("autosize", ((t, e) => {
+                        renderer: m,
+                        ...k ? {
+                            expr: null !== (c = null !== (l = Vv.expressionInterpreter) && void 0 !== l ? l : u.expr) && void 0 !== c ? c : j.N
+                        } : {}
+                    });
+                    if (D.addSignalListener("autosize", ((t, e) => {
                             const {
                                 type: n
                             } = e;
                             "fit-x" == n ? (_.classList.add("fit-x"), _.classList.remove("fit-y")) : "fit-y" == n ? (_.classList.remove("fit-x"), _.classList.add("fit-y")) : "fit" == n ? _.classList.add("fit-x", "fit-y") : _.classList.remove("fit-x", "fit-y")
                         })), !1 !== u.tooltip) {
-                        const t = "function" === typeof u.tooltip ? u.tooltip : new wg(!0 === u.tooltip ? {} : u.tooltip).call;
-                        A.tooltip(t)
+                        const {
+                            loader: t,
+                            tooltip: e
+                        } = u, n = t && !cy(t) ? null === t || void 0 === t ? void 0 : t.baseURL : void 0, i = "function" === typeof e ? e : new Og({
+                            baseURL: n,
+                            ...!0 === e ? {} : e
+                        }).call;
+                        D.tooltip(i)
                     }
                     let S, {
                         hover: C
                     } = u;
                     void 0 === C && (C = "vega" === b);
                     if (C) {
                         const {
                             hoverSet: t,
                             updateSet: e
                         } = "boolean" === typeof C ? {} : C;
-                        A.hover(t, e)
+                        D.hover(t, e)
                     }
-                    u && (null != u.width && A.width(u.width), null != u.height && A.height(u.height), null != u.padding && A.padding(u.padding));
-                    if (await A.initialize(_, u.bind).runAsync(), !1 !== h) {
+                    u && (null != u.width && D.width(u.width), null != u.height && D.height(u.height), null != u.padding && D.padding(u.padding));
+                    if (await D.initialize(_, u.bind).runAsync(), !1 !== h) {
                         let t = y;
                         if (!1 !== u.defaultStyle || u.forceActionsMenu) {
                             const e = document.createElement("details");
                             e.title = p.CLICK_TO_VIEW_ACTIONS, y.append(e), t = e;
                             const n = document.createElement("summary");
-                            n.innerHTML = ey, e.append(n), S = t => {
+                            n.innerHTML = oy, e.append(n), S = t => {
                                 e.contains(t.target) || e.removeAttribute("open")
                             }, document.addEventListener("click", S)
                         }
                         const n = document.createElement("div");
                         if (t.append(n), n.classList.add("vega-actions"), !0 === h || !1 !== h.export)
                             for (const e of ["svg", "png"])
                                 if (!0 === h || !0 === h.export || h.export[e]) {
                                     const t = p["".concat(e.toUpperCase(), "_ACTION")],
                                         i = document.createElement("a"),
-                                        r = (0, B.isObject)(u.scaleFactor) ? u.scaleFactor[e] : u.scaleFactor;
+                                        r = (0, I.isObject)(u.scaleFactor) ? u.scaleFactor[e] : u.scaleFactor;
                                     i.text = t, i.href = "#", i.target = "_blank", i.download = "".concat(v, ".").concat(e), i.addEventListener("mousedown", (async function(t) {
                                         t.preventDefault();
-                                        const n = await A.toImageURL(e, r);
+                                        const n = await D.toImageURL(e, r);
                                         this.href = n
                                     })), n.append(i)
                                 } if (!0 === h || !1 !== h.source) {
                             const t = document.createElement("a");
                             t.text = p.SOURCE_ACTION, t.href = "#", t.addEventListener("click", (function(t) {
                                 var n, i;
-                                iy(j()(e), null !== (n = u.sourceHeader) && void 0 !== n ? n : "", null !== (i = u.sourceFooter) && void 0 !== i ? i : "", b), t.preventDefault()
+                                sy(B()(e), null !== (n = u.sourceHeader) && void 0 !== n ? n : "", null !== (i = u.sourceFooter) && void 0 !== i ? i : "", b), t.preventDefault()
                             })), n.append(t)
                         }
                         if ("vega-lite" === b && (!0 === h || !1 !== h.compiled)) {
                             const t = document.createElement("a");
                             t.text = p.COMPILED_ACTION, t.href = "#", t.addEventListener("click", (function(t) {
                                 var e, n;
-                                iy(j()(x), null !== (e = u.sourceHeader) && void 0 !== e ? e : "", null !== (n = u.sourceFooter) && void 0 !== n ? n : "", "vega"), t.preventDefault()
+                                sy(B()(x), null !== (e = u.sourceHeader) && void 0 !== e ? e : "", null !== (n = u.sourceFooter) && void 0 !== n ? n : "", "vega"), t.preventDefault()
                             })), n.append(t)
                         }
                         if (!0 === h || !1 !== h.editor) {
-                            var F;
-                            const t = null !== (F = u.editorUrl) && void 0 !== F ? F : "https://vega.github.io/editor/",
+                            var M;
+                            const t = null !== (M = u.editorUrl) && void 0 !== M ? M : "https://vega.github.io/editor/",
                                 i = document.createElement("a");
                             i.text = p.EDITOR_ACTION, i.href = "#", i.addEventListener("click", (function(n) {
                                 ! function(t, e, n) {
                                     const i = t.open(e),
                                         {
                                             origin: r
                                         } = new URL(e);
@@ -17996,41 +18101,45 @@
                                     }), !1), setTimeout((function t() {
                                         o <= 0 || (i.postMessage(n, r), setTimeout(t, 250), o -= 1)
                                     }), 250)
                                 }(window, t, {
                                     config: d,
                                     mode: b,
                                     renderer: m,
-                                    spec: j()(e)
+                                    spec: B()(e)
                                 }), n.preventDefault()
                             })), n.append(i)
                         }
                     }
 
-                    function M() {
-                        S && document.removeEventListener("click", S), A.finalize()
+                    function F() {
+                        S && document.removeEventListener("click", S), D.finalize()
                     }
                     return {
-                        view: A,
+                        view: D,
                         spec: e,
                         vgSpec: x,
-                        finalize: M,
+                        finalize: F,
                         embedOptions: u
                     }
                 }(t, r, h, o)
             }
-            async function ay(t, e) {
+            async function fy(t, e) {
                 var n;
-                const i = (0, B.isString)(t.config) ? JSON.parse(await e.load(t.config)) : null !== (n = t.config) && void 0 !== n ? n : {},
-                    r = (0, B.isString)(t.patch) ? JSON.parse(await e.load(t.patch)) : t.patch;
-                return Jv(Jv(Jv({}, t), r ? {
-                    patch: r
-                } : {}), i ? {
-                    config: i
-                } : {})
+                const i = (0, I.isString)(t.config) ? JSON.parse(await e.load(t.config)) : null !== (n = t.config) && void 0 !== n ? n : {},
+                    r = (0, I.isString)(t.patch) ? JSON.parse(await e.load(t.patch)) : t.patch;
+                return {
+                    ...t,
+                    ...r ? {
+                        patch: r
+                    } : {},
+                    ...i ? {
+                        config: i
+                    } : {}
+                }
             }
         },
         77155: (t, e, n) => {
             "use strict";
             n.d(e, {
                 r: () => g
             });
@@ -18149,18 +18258,18 @@
             }
         },
         88120: (t, e, n) => {
             "use strict";
             n.d(e, {
                 BJ: () => Ht,
                 Lt: () => c,
-                YP: () => Gt,
+                YP: () => Jt,
                 _G: () => Xt,
                 t$: () => r,
-                wk: () => Jt
+                wk: () => Gt
             });
             var i = n(15721);
             const r = "Literal",
                 o = "Property",
                 a = "ArrayExpression",
                 s = "BinaryExpression",
                 c = "CallExpression",
@@ -18203,40 +18312,40 @@
                     if (e[n].visit(t)) return 1
             };
             var x = 1,
                 _ = 2,
                 w = 3,
                 k = 4,
                 E = 5,
-                D = 6,
-                A = 7,
+                A = 6,
+                D = 7,
                 S = 8;
-            (m = {})[x] = "Boolean", m[_] = "<end>", m[w] = "Identifier", m[k] = "Keyword", m[E] = "Null", m[D] = "Numeric", m[A] = "Punctuator", m[S] = "String", m[9] = "RegularExpression";
+            (m = {})[x] = "Boolean", m[_] = "<end>", m[w] = "Identifier", m[k] = "Keyword", m[E] = "Null", m[A] = "Numeric", m[D] = "Punctuator", m[S] = "String", m[9] = "RegularExpression";
             var C = "ArrayExpression",
-                F = "BinaryExpression",
-                M = "CallExpression",
+                M = "BinaryExpression",
+                F = "CallExpression",
                 O = "ConditionalExpression",
                 T = "Identifier",
                 N = "Literal",
-                z = "LogicalExpression",
-                R = "MemberExpression",
+                R = "LogicalExpression",
+                z = "MemberExpression",
                 P = "ObjectExpression",
                 L = "Property",
-                j = "UnaryExpression",
-                B = "Unexpected token %0",
-                I = "Unexpected number",
+                B = "UnaryExpression",
+                I = "Unexpected token %0",
+                j = "Unexpected number",
                 U = "Unexpected string",
                 q = "Unexpected identifier",
                 W = "Unexpected reserved word",
                 H = "Unexpected end of input",
                 X = "Invalid regular expression",
-                J = "Invalid regular expression: missing /",
-                G = "Octal literals are not allowed in strict mode.",
-                $ = "Duplicate data property in object literal not allowed in strict mode",
-                Z = "ILLEGAL",
+                G = "Invalid regular expression: missing /",
+                J = "Octal literals are not allowed in strict mode.",
+                Z = "Duplicate data property in object literal not allowed in strict mode",
+                $ = "ILLEGAL",
                 Y = "Disabled.",
                 V = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
                 K = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
 
             function Q(t, e) {
                 if (!t) throw new Error("ASSERT: " + e)
             }
@@ -18319,27 +18428,27 @@
                     if (!it(t) && !rt(t)) break;
                     ++v
                 }
             }
 
             function lt(t) {
                 var e, n, i, r = 0;
-                for (n = "u" === t ? 4 : 2, e = 0; e < n; ++e) v < y && et(g[v]) ? (i = g[v++], r = 16 * r + "0123456789abcdef".indexOf(i.toLowerCase())) : Dt({}, B, Z);
+                for (n = "u" === t ? 4 : 2, e = 0; e < n; ++e) v < y && et(g[v]) ? (i = g[v++], r = 16 * r + "0123456789abcdef".indexOf(i.toLowerCase())) : At({}, I, $);
                 return String.fromCharCode(r)
             }
 
             function ut() {
                 var t, e, n, i;
-                for (e = 0, "}" === (t = g[v]) && Dt({}, B, Z); v < y && et(t = g[v++]);) e = 16 * e + "0123456789abcdef".indexOf(t.toLowerCase());
-                return (e > 1114111 || "}" !== t) && Dt({}, B, Z), e <= 65535 ? String.fromCharCode(e) : (n = 55296 + (e - 65536 >> 10), i = 56320 + (e - 65536 & 1023), String.fromCharCode(n, i))
+                for (e = 0, "}" === (t = g[v]) && At({}, I, $); v < y && et(t = g[v++]);) e = 16 * e + "0123456789abcdef".indexOf(t.toLowerCase());
+                return (e > 1114111 || "}" !== t) && At({}, I, $), e <= 65535 ? String.fromCharCode(e) : (n = 55296 + (e - 65536 >> 10), i = 56320 + (e - 65536 & 1023), String.fromCharCode(n, i))
             }
 
             function ft() {
                 var t, e;
-                for (t = g.charCodeAt(v++), e = String.fromCharCode(t), 92 === t && (117 !== g.charCodeAt(v) && Dt({}, B, Z), ++v, (t = lt("u")) && "\\" !== t && ot(t.charCodeAt(0)) || Dt({}, B, Z), e = t); v < y && at(t = g.charCodeAt(v));) ++v, e += String.fromCharCode(t), 92 === t && (e = e.substr(0, e.length - 1), 117 !== g.charCodeAt(v) && Dt({}, B, Z), ++v, (t = lt("u")) && "\\" !== t && at(t.charCodeAt(0)) || Dt({}, B, Z), e += t);
+                for (t = g.charCodeAt(v++), e = String.fromCharCode(t), 92 === t && (117 !== g.charCodeAt(v) && At({}, I, $), ++v, (t = lt("u")) && "\\" !== t && ot(t.charCodeAt(0)) || At({}, I, $), e = t); v < y && at(t = g.charCodeAt(v));) ++v, e += String.fromCharCode(t), 92 === t && (e = e.substr(0, e.length - 1), 117 !== g.charCodeAt(v) && At({}, I, $), ++v, (t = lt("u")) && "\\" !== t && at(t.charCodeAt(0)) || At({}, I, $), e += t);
                 return e
             }
 
             function dt() {
                 var t, e;
                 return t = v, e = 92 === g.charCodeAt(v) ? ft() : function() {
                     var t, e;
@@ -18371,15 +18480,15 @@
                     case 125:
                     case 91:
                     case 93:
                     case 58:
                     case 63:
                     case 126:
                         return ++v, {
-                            type: A,
+                            type: D,
                             value: String.fromCharCode(o),
                             start: r,
                             end: v
                         };
                     default:
                         if (61 === (t = g.charCodeAt(v + 1))) switch (o) {
                             case 43:
@@ -18389,135 +18498,135 @@
                             case 62:
                             case 94:
                             case 124:
                             case 37:
                             case 38:
                             case 42:
                                 return v += 2, {
-                                    type: A,
+                                    type: D,
                                     value: String.fromCharCode(o) + String.fromCharCode(t),
                                     start: r,
                                     end: v
                                 };
                             case 33:
                             case 61:
                                 return v += 2, 61 === g.charCodeAt(v) && ++v, {
-                                    type: A,
+                                    type: D,
                                     value: g.slice(r, v),
                                     start: r,
                                     end: v
                                 }
                         }
                 }
                 return ">>>=" === (i = g.substr(v, 4)) ? {
-                    type: A,
+                    type: D,
                     value: i,
                     start: r,
                     end: v += 4
                 } : ">>>" === (n = i.substr(0, 3)) || "<<=" === n || ">>=" === n ? {
-                    type: A,
+                    type: D,
                     value: n,
                     start: r,
                     end: v += 3
                 } : a === (e = n.substr(0, 2))[1] && "+-<>&|".indexOf(a) >= 0 || "=>" === e ? {
-                    type: A,
+                    type: D,
                     value: e,
                     start: r,
                     end: v += 2
-                } : ("//" === e && Dt({}, B, Z), "<>=!+-*%&|^/".indexOf(a) >= 0 ? (++v, {
-                    type: A,
+                } : ("//" === e && At({}, I, $), "<>=!+-*%&|^/".indexOf(a) >= 0 ? (++v, {
+                    type: D,
                     value: a,
                     start: r,
                     end: v
-                }) : void Dt({}, B, Z))
+                }) : void At({}, I, $))
             }
 
             function pt() {
                 var t, e, n;
                 if (Q(tt((n = g[v]).charCodeAt(0)) || "." === n, "Numeric literal must start with a decimal digit or a decimal point"), e = v, t = "", "." !== n) {
                     if (t = g[v++], n = g[v], "0" === t) {
                         if ("x" === n || "X" === n) return ++v,
                             function(t) {
                                 let e = "";
                                 for (; v < y && et(g[v]);) e += g[v++];
-                                return 0 === e.length && Dt({}, B, Z), ot(g.charCodeAt(v)) && Dt({}, B, Z), {
-                                    type: D,
+                                return 0 === e.length && At({}, I, $), ot(g.charCodeAt(v)) && At({}, I, $), {
+                                    type: A,
                                     value: parseInt("0x" + e, 16),
                                     start: t,
                                     end: v
                                 }
                             }(e);
                         if (nt(n)) return function(t) {
                             let e = "0" + g[v++];
                             for (; v < y && nt(g[v]);) e += g[v++];
-                            return (ot(g.charCodeAt(v)) || tt(g.charCodeAt(v))) && Dt({}, B, Z), {
-                                type: D,
+                            return (ot(g.charCodeAt(v)) || tt(g.charCodeAt(v))) && At({}, I, $), {
+                                type: A,
                                 value: parseInt(e, 8),
                                 octal: !0,
                                 start: t,
                                 end: v
                             }
                         }(e);
-                        n && tt(n.charCodeAt(0)) && Dt({}, B, Z)
+                        n && tt(n.charCodeAt(0)) && At({}, I, $)
                     }
                     for (; tt(g.charCodeAt(v));) t += g[v++];
                     n = g[v]
                 }
                 if ("." === n) {
                     for (t += g[v++]; tt(g.charCodeAt(v));) t += g[v++];
                     n = g[v]
                 }
                 if ("e" === n || "E" === n)
                     if (t += g[v++], "+" !== (n = g[v]) && "-" !== n || (t += g[v++]), tt(g.charCodeAt(v)))
                         for (; tt(g.charCodeAt(v));) t += g[v++];
-                    else Dt({}, B, Z);
-                return ot(g.charCodeAt(v)) && Dt({}, B, Z), {
-                    type: D,
+                    else At({}, I, $);
+                return ot(g.charCodeAt(v)) && At({}, I, $), {
+                    type: A,
                     value: parseFloat(t),
                     start: e,
                     end: v
                 }
             }
 
             function mt() {
                 var t, e, n, i;
                 return b = null, ct(), t = v, e = function() {
                     var t, e, n, i;
                     for (Q("/" === (t = g[v]), "Regular expression literal must start with a slash"), e = g[v++], n = !1, i = !1; v < y;)
-                        if (e += t = g[v++], "\\" === t) rt((t = g[v++]).charCodeAt(0)) && Dt({}, J), e += t;
-                        else if (rt(t.charCodeAt(0))) Dt({}, J);
+                        if (e += t = g[v++], "\\" === t) rt((t = g[v++]).charCodeAt(0)) && At({}, G), e += t;
+                        else if (rt(t.charCodeAt(0))) At({}, G);
                     else if (n) "]" === t && (n = !1);
                     else {
                         if ("/" === t) {
                             i = !0;
                             break
                         }
                         "[" === t && (n = !0)
                     }
-                    return i || Dt({}, J), {
+                    return i || At({}, G), {
                         value: e.substr(1, e.length - 2),
                         literal: e
                     }
                 }(), n = function() {
                     var t, e, n;
-                    for (e = "", n = ""; v < y && at((t = g[v]).charCodeAt(0));) ++v, "\\" === t && v < y ? Dt({}, B, Z) : (n += t, e += t);
-                    return n.search(/[^gimuy]/g) >= 0 && Dt({}, X, n), {
+                    for (e = "", n = ""; v < y && at((t = g[v]).charCodeAt(0));) ++v, "\\" === t && v < y ? At({}, I, $) : (n += t, e += t);
+                    return n.search(/[^gimuy]/g) >= 0 && At({}, X, n), {
                         value: n,
                         literal: e
                     }
                 }(), i = function(t, e) {
                     let n = t;
                     e.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, ((t, e) => {
                         if (parseInt(e, 16) <= 1114111) return "x";
-                        Dt({}, X)
+                        At({}, X)
                     })).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
                     try {
                         new RegExp(n)
                     } catch (i) {
-                        Dt({}, X)
+                        At({}, X)
                     }
                     try {
                         return new RegExp(t, e)
                     } catch (r) {
                         return null
                     }
                 }(e.value, n.value), {
@@ -18575,15 +18684,15 @@
                                 default:
                                     nt(n) ? (0 !== (i = "01234567".indexOf(n)) && (o = !0), v < y && nt(g[v]) && (o = !0, i = 8 * i + "01234567".indexOf(g[v++]), "0123".indexOf(n) >= 0 && v < y && nt(g[v]) && (i = 8 * i + "01234567".indexOf(g[v++]))), r += String.fromCharCode(i)) : r += n
                             } else {
                                 if (rt(n.charCodeAt(0))) break;
                                 r += n
                             }
                     }
-                    return "" !== t && Dt({}, B, Z), {
+                    return "" !== t && At({}, I, $), {
                         type: S,
                         value: r,
                         octal: o,
                         start: e,
                         end: v
                     }
                 }() : 46 === t ? tt(g.charCodeAt(v + 1)) ? pt() : ht() : tt(t) ? pt() : ht()
@@ -18596,116 +18705,116 @@
 
             function yt() {
                 const t = v;
                 b = gt(), v = t
             }
 
             function bt(t, e, n) {
-                const i = new p("||" === t || "&&" === t ? z : F);
+                const i = new p("||" === t || "&&" === t ? R : M);
                 return i.operator = t, i.left = e, i.right = n, i
             }
 
             function xt(t, e) {
-                const n = new p(M);
+                const n = new p(F);
                 return n.callee = t, n.arguments = e, n
             }
 
             function _t(t) {
                 const e = new p(T);
                 return e.name = t, e
             }
 
             function wt(t) {
                 const e = new p(N);
                 return e.value = t.value, e.raw = g.slice(t.start, t.end), t.regex && ("//" === e.raw && (e.raw = "/(?:)/"), e.regex = t.regex), e
             }
 
             function kt(t, e, n) {
-                const i = new p(R);
+                const i = new p(z);
                 return i.computed = "[" === t, i.object = e, i.property = n, i.computed || (n.member = !0), i
             }
 
             function Et(t, e, n) {
                 const i = new p(L);
                 return i.key = e, i.value = n, i.kind = t, i
             }
 
-            function Dt(t, e) {
+            function At(t, e) {
                 var n, i = Array.prototype.slice.call(arguments, 2),
                     r = e.replace(/%(\d)/g, ((t, e) => (Q(e < i.length, "Message reference must be in range"), i[e])));
                 throw (n = new Error(r)).index = v, n.description = r, n
             }
 
-            function At(t) {
-                t.type === _ && Dt(t, H), t.type === D && Dt(t, I), t.type === S && Dt(t, U), t.type === w && Dt(t, q), t.type === k && Dt(t, W), Dt(t, B, t.value)
+            function Dt(t) {
+                t.type === _ && At(t, H), t.type === A && At(t, j), t.type === S && At(t, U), t.type === w && At(t, q), t.type === k && At(t, W), At(t, I, t.value)
             }
 
             function St(t) {
                 const e = vt();
-                e.type === A && e.value === t || At(e)
+                e.type === D && e.value === t || Dt(e)
             }
 
             function Ct(t) {
-                return b.type === A && b.value === t
+                return b.type === D && b.value === t
             }
 
-            function Ft(t) {
+            function Mt(t) {
                 return b.type === k && b.value === t
             }
 
-            function Mt() {
+            function Ft() {
                 const t = [];
                 for (v = b.start, St("["); !Ct("]");) Ct(",") ? (vt(), t.push(null)) : (t.push(qt()), Ct("]") || St(","));
                 return vt(),
                     function(t) {
                         const e = new p(C);
                         return e.elements = t, e
                     }(t)
             }
 
             function Ot() {
                 v = b.start;
                 const t = vt();
-                return t.type === S || t.type === D ? (t.octal && Dt(t, G), wt(t)) : _t(t.value)
+                return t.type === S || t.type === A ? (t.octal && At(t, J), wt(t)) : _t(t.value)
             }
 
             function Tt() {
                 var t, e, n;
-                return v = b.start, (t = b).type === w ? (n = Ot(), St(":"), Et("init", n, qt())) : t.type !== _ && t.type !== A ? (e = Ot(), St(":"), Et("init", e, qt())) : void At(t)
+                return v = b.start, (t = b).type === w ? (n = Ot(), St(":"), Et("init", n, qt())) : t.type !== _ && t.type !== D ? (e = Ot(), St(":"), Et("init", e, qt())) : void Dt(t)
             }
 
             function Nt() {
                 var t, e, n = [],
                     i = {},
                     r = String;
-                for (v = b.start, St("{"); !Ct("}");) e = "$" + ((t = Tt()).key.type === T ? t.key.name : r(t.key.value)), Object.prototype.hasOwnProperty.call(i, e) ? Dt({}, $) : i[e] = !0, n.push(t), Ct("}") || St(",");
+                for (v = b.start, St("{"); !Ct("}");) e = "$" + ((t = Tt()).key.type === T ? t.key.name : r(t.key.value)), Object.prototype.hasOwnProperty.call(i, e) ? At({}, Z) : i[e] = !0, n.push(t), Ct("}") || St(",");
                 return St("}"),
                     function(t) {
                         const e = new p(P);
                         return e.properties = t, e
                     }(n)
             }
-            const zt = {
+            const Rt = {
                 if: 1
             };
 
-            function Rt() {
+            function zt() {
                 var t, e, n;
                 if (Ct("(")) return function() {
                     St("(");
                     const t = Wt();
                     return St(")"), t
                 }();
-                if (Ct("[")) return Mt();
+                if (Ct("[")) return Ft();
                 if (Ct("{")) return Nt();
-                if (t = b.type, v = b.start, t === w || zt[b.value]) n = _t(vt().value);
-                else if (t === S || t === D) b.octal && Dt(b, G), n = wt(vt());
+                if (t = b.type, v = b.start, t === w || Rt[b.value]) n = _t(vt().value);
+                else if (t === S || t === A) b.octal && At(b, J), n = wt(vt());
                 else {
                     if (t === k) throw new Error(Y);
-                    t === x ? ((e = vt()).value = "true" === e.value, n = wt(e)) : t === E ? ((e = vt()).value = null, n = wt(e)) : Ct("/") || Ct("/=") ? (n = wt(mt()), yt()) : At(vt())
+                    t === x ? ((e = vt()).value = "true" === e.value, n = wt(e)) : t === E ? ((e = vt()).value = null, n = wt(e)) : Ct("/") || Ct("/=") ? (n = wt(mt()), yt()) : Dt(vt())
                 }
                 return n
             }
 
             function Pt() {
                 const t = [];
                 if (St("("), !Ct(")"))
@@ -18714,59 +18823,59 @@
             }
 
             function Lt() {
                 v = b.start;
                 const t = vt();
                 return function(t) {
                     return t.type === w || t.type === k || t.type === x || t.type === E
-                }(t) || At(t), _t(t.value)
+                }(t) || Dt(t), _t(t.value)
             }
 
-            function jt() {
+            function Bt() {
                 St("[");
                 const t = Wt();
                 return St("]"), t
             }
 
-            function Bt() {
+            function It() {
                 const t = function() {
                     var t;
-                    for (t = Rt();;)
+                    for (t = zt();;)
                         if (Ct(".")) St("."), t = kt(".", t, Lt());
                         else if (Ct("(")) t = xt(t, Pt());
                     else {
                         if (!Ct("[")) break;
-                        t = kt("[", t, jt())
+                        t = kt("[", t, Bt())
                     }
                     return t
                 }();
-                if (b.type === A && (Ct("++") || Ct("--"))) throw new Error(Y);
+                if (b.type === D && (Ct("++") || Ct("--"))) throw new Error(Y);
                 return t
             }
 
-            function It() {
+            function jt() {
                 var t, e;
-                if (b.type !== A && b.type !== k) e = Bt();
+                if (b.type !== D && b.type !== k) e = It();
                 else {
                     if (Ct("++") || Ct("--")) throw new Error(Y);
-                    if (Ct("+") || Ct("-") || Ct("~") || Ct("!")) t = vt(), e = It(), e = function(t, e) {
-                        const n = new p(j);
+                    if (Ct("+") || Ct("-") || Ct("~") || Ct("!")) t = vt(), e = jt(), e = function(t, e) {
+                        const n = new p(B);
                         return n.operator = t, n.argument = e, n.prefix = !0, n
                     }(t.value, e);
                     else {
-                        if (Ft("delete") || Ft("void") || Ft("typeof")) throw new Error(Y);
-                        e = Bt()
+                        if (Mt("delete") || Mt("void") || Mt("typeof")) throw new Error(Y);
+                        e = It()
                     }
                 }
                 return e
             }
 
             function Ut(t) {
                 let e = 0;
-                if (t.type !== A && t.type !== k) return 0;
+                if (t.type !== D && t.type !== k) return 0;
                 switch (t.value) {
                     case "||":
                         e = 1;
                         break;
                     case "&&":
                         e = 2;
                         break;
@@ -18810,19 +18919,19 @@
                 return e
             }
 
             function qt() {
                 var t, e;
                 return t = function() {
                     var t, e, n, i, r, o, a, s, c, l;
-                    if (t = b, c = It(), 0 === (r = Ut(i = b))) return c;
-                    for (i.prec = r, vt(), e = [t, b], o = [c, i, a = It()];
+                    if (t = b, c = jt(), 0 === (r = Ut(i = b))) return c;
+                    for (i.prec = r, vt(), e = [t, b], o = [c, i, a = jt()];
                         (r = Ut(b)) > 0;) {
                         for (; o.length > 2 && r <= o[o.length - 2].prec;) a = o.pop(), s = o.pop().value, c = o.pop(), e.pop(), n = bt(s, c, a), o.push(n);
-                        (i = vt()).prec = r, o.push(i), e.push(b), n = It(), o.push(n)
+                        (i = vt()).prec = r, o.push(i), e.push(b), n = jt(), o.push(n)
                     }
                     for (n = o[l = o.length - 1], e.pop(); l > 1;) e.pop(), n = bt(o[l - 1].value, o[l - 2], n), l -= 2;
                     return n
                 }(), Ct("?") && (vt(), e = qt(), St(":"), t = function(t, e, n) {
                     const i = new p(O);
                     return i.test = t, i.consequent = e, i.alternate = n, i
                 }(t, e, qt())), t
@@ -18850,15 +18959,15 @@
                 PI: "Math.PI",
                 SQRT1_2: "Math.SQRT1_2",
                 SQRT2: "Math.SQRT2",
                 MIN_VALUE: "Number.MIN_VALUE",
                 MAX_VALUE: "Number.MAX_VALUE"
             };
 
-            function Jt(t) {
+            function Gt(t) {
                 function e(e, n, i) {
                     return r => function(e, n, i, r) {
                         let o = t(n[0]);
                         return i && (o = i + "(" + o + ")", 0 === i.lastIndexOf("new ", 0) && (o = "(" + o + ")")), o + "." + e + (r < 0 ? "" : 0 === r ? "()" : "(" + n.slice(1).map(t).join(",") + ")")
                     }(e, r, n, i)
                 }
                 const n = "new Date",
@@ -18926,19 +19035,19 @@
                         e.length < 3 && (0, i.vU)("Missing arguments to if function."), e.length > 3 && (0, i.vU)("Too many arguments to if function.");
                         const n = e.map(t);
                         return "(" + n[0] + "?" + n[1] + ":" + n[2] + ")"
                     }
                 }
             }
 
-            function Gt(t) {
+            function Jt(t) {
                 const e = (t = t || {}).allowed ? (0, i.Rg)(t.allowed) : {},
                     n = t.forbidden ? (0, i.Rg)(t.forbidden) : {},
                     r = t.constants || Xt,
-                    o = (t.functions || Jt)(d),
+                    o = (t.functions || Gt)(d),
                     a = t.globalvar,
                     s = t.fieldvar,
                     c = (0, i.mf)(a) ? a : t => "".concat(a, '["').concat(t, '"]');
                 let l = {},
                     u = {},
                     f = 0;
 
@@ -19215,79 +19324,79 @@
             }
 
             function a(t) {
                 return 1 === t.length ? s(t[0]) : c(t)
             }
             n.d(e, {
                 $G: () => Lt,
-                $m: () => At,
-                BB: () => Rt,
+                $m: () => Dt,
+                BB: () => zt,
                 Ds: () => at,
-                Dw: () => B,
+                Dw: () => I,
                 EP: () => f,
-                FP: () => jt,
+                FP: () => Bt,
                 HD: () => wt,
                 He: () => T,
                 Hq: () => b,
                 IX: () => Y,
                 J_: () => yt,
                 Jy: () => kt,
                 Kj: () => _t,
-                Kn: () => A,
-                N3: () => Z,
+                Kn: () => D,
+                N3: () => $,
                 Oj: () => o,
                 QA: () => U,
                 Rg: () => Pt,
                 TS: () => St,
                 TW: () => bt,
                 We: () => ct,
                 XW: () => mt,
                 Xr: () => ht,
                 ZE: () => i,
-                ZU: () => zt,
+                ZU: () => Rt,
                 Zw: () => q,
                 _k: () => u,
                 a9: () => ot,
                 ay: () => H,
                 bM: () => p,
-                bV: () => G,
+                bV: () => J,
                 cG: () => k,
                 dH: () => X,
                 dI: () => lt,
                 el: () => r,
                 fE: () => C,
                 fj: () => O,
                 hj: () => xt,
-                iL: () => F,
+                iL: () => M,
                 id: () => d,
                 j2: () => et,
                 jj: () => x,
                 jn: () => vt,
                 k: () => v,
                 kI: () => w,
-                kJ: () => D,
+                kJ: () => A,
                 kX: () => m,
                 kg: () => E,
                 l$: () => V,
                 l7: () => st,
                 m8: () => Ot,
-                mJ: () => I,
-                mK: () => J,
-                mS: () => $,
+                mJ: () => j,
+                mK: () => G,
+                mS: () => Z,
                 mf: () => K,
                 nr: () => ft,
                 qu: () => tt,
                 rx: () => Ct,
                 sw: () => Tt,
                 t7: () => Et,
                 u5: () => gt,
                 uU: () => _,
                 vU: () => l,
-                vk: () => Ft,
-                yP: () => Mt,
+                vk: () => Mt,
+                yP: () => Ft,
                 yR: () => h,
                 yb: () => g,
                 yl: () => pt
             });
             const s = t => function(e) {
                     return e[t]
                 },
@@ -19361,44 +19470,44 @@
                         return i >= w && n(e || "log", "INFO", arguments), this
                     },
                     debug() {
                         return i >= k && n(e || "log", "DEBUG", arguments), this
                     }
                 }
             }
-            var D = Array.isArray;
+            var A = Array.isArray;
 
-            function A(t) {
+            function D(t) {
                 return t === Object(t)
             }
             const S = t => "__proto__" !== t;
 
             function C() {
                 for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                 return e.reduce(((t, e) => {
                     for (const n in e)
-                        if ("signals" === n) t.signals = M(t.signals, e.signals);
+                        if ("signals" === n) t.signals = F(t.signals, e.signals);
                         else {
                             const i = "legend" === n ? {
                                 layout: 1
                             } : "style" === n || null;
-                            F(t, n, e[n], i)
+                            M(t, n, e[n], i)
                         } return t
                 }), {})
             }
 
-            function F(t, e, n, i) {
+            function M(t, e, n, i) {
                 if (!S(e)) return;
                 let r, o;
-                if (A(n) && !D(n))
-                    for (r in o = A(t[e]) ? t[e] : t[e] = {}, n) i && (!0 === i || i[r]) ? F(o, r, n[r]) : S(r) && (o[r] = n[r]);
+                if (D(n) && !A(n))
+                    for (r in o = D(t[e]) ? t[e] : t[e] = {}, n) i && (!0 === i || i[r]) ? M(o, r, n[r]) : S(r) && (o[r] = n[r]);
                 else t[e] = n
             }
 
-            function M(t, e) {
+            function F(t, e) {
                 if (null == t) return e;
                 const n = {},
                     i = [];
 
                 function r(t) {
                     n[t.name] || (n[t.name] = 1, i.push(t))
                 }
@@ -19409,41 +19518,41 @@
                 return t[t.length - 1]
             }
 
             function T(t) {
                 return null == t || "" === t ? null : +t
             }
             const N = t => e => t * Math.exp(e),
-                z = t => e => Math.log(t * e),
-                R = t => e => Math.sign(e) * Math.log1p(Math.abs(e / t)),
+                R = t => e => Math.log(t * e),
+                z = t => e => Math.sign(e) * Math.log1p(Math.abs(e / t)),
                 P = t => e => Math.sign(e) * Math.expm1(Math.abs(e)) * t,
                 L = t => e => e < 0 ? -Math.pow(-e, t) : Math.pow(e, t);
 
-            function j(t, e, n, i) {
+            function B(t, e, n, i) {
                 const r = n(t[0]),
                     o = n(O(t)),
                     a = (o - r) * e;
                 return [i(r - a), i(o - a)]
             }
 
-            function B(t, e) {
-                return j(t, e, T, h)
+            function I(t, e) {
+                return B(t, e, T, h)
             }
 
-            function I(t, e) {
+            function j(t, e) {
                 var n = Math.sign(t[0]);
-                return j(t, e, z(n), N(n))
+                return B(t, e, R(n), N(n))
             }
 
             function U(t, e, n) {
-                return j(t, e, L(n), L(1 / n))
+                return B(t, e, L(n), L(1 / n))
             }
 
             function q(t, e, n) {
-                return j(t, e, R(n), P(n))
+                return B(t, e, z(n), P(n))
             }
 
             function W(t, e, n, i, r) {
                 const o = i(t[0]),
                     a = i(O(t)),
                     s = null != e ? i(e) : (o + a) / 2;
                 return [r(s + (o - s) * n), r(s + (a - s) * n)]
@@ -19451,35 +19560,35 @@
 
             function H(t, e, n) {
                 return W(t, e, n, T, h)
             }
 
             function X(t, e, n) {
                 const i = Math.sign(t[0]);
-                return W(t, e, n, z(i), N(i))
+                return W(t, e, n, R(i), N(i))
             }
 
-            function J(t, e, n, i) {
+            function G(t, e, n, i) {
                 return W(t, e, n, L(i), L(1 / i))
             }
 
-            function G(t, e, n, i) {
-                return W(t, e, n, R(i), P(i))
+            function J(t, e, n, i) {
+                return W(t, e, n, z(i), P(i))
             }
 
-            function $(t) {
+            function Z(t) {
                 return 1 + ~~(new Date(t).getMonth() / 3)
             }
 
-            function Z(t) {
+            function $(t) {
                 return 1 + ~~(new Date(t).getUTCMonth() / 3)
             }
 
             function Y(t) {
-                return null != t ? D(t) ? t : [t] : []
+                return null != t ? A(t) ? t : [t] : []
             }
 
             function V(t, e, n) {
                 let i, r = t[0],
                     o = t[1];
                 return o < r && (i = o, o = r, r = i), i = o - r, i >= n - e ? [e, n] : [r = Math.min(Math.max(r, e), n - i), r + i]
             }
@@ -19685,19 +19794,19 @@
 
             function Et(t, e) {
                 const n = t[0],
                     i = O(t),
                     r = +e;
                 return r ? 1 === r ? i : n + r * (i - n) : n
             }
-            const Dt = 1e4;
+            const At = 1e4;
 
-            function At(t) {
+            function Dt(t) {
                 let e, n, i;
-                t = +t || Dt;
+                t = +t || At;
                 const r = () => {
                         e = {}, n = {}, i = 0
                     },
                     o = (r, o) => (++i > t && (n = e, e = {}, i = 1), e[r] = o);
                 return r(), {
                     clear: r,
                     has: t => ft(e, t) || ft(n, t),
@@ -19723,39 +19832,39 @@
 
             function Ct(t, e) {
                 let n = "";
                 for (; --e >= 0;) n += t;
                 return n
             }
 
-            function Ft(t, e, n, i) {
+            function Mt(t, e, n, i) {
                 const r = n || " ",
                     o = t + "",
                     a = e - o.length;
                 return a <= 0 ? o : "left" === i ? Ct(r, a) + o : "center" === i ? Ct(r, ~~(a / 2)) + o + Ct(r, Math.ceil(a / 2)) : o + Ct(r, a)
             }
 
-            function Mt(t) {
+            function Ft(t) {
                 return t && O(t) - t[0] || 0
             }
 
             function Ot(t) {
-                return D(t) ? "[" + t.map(Ot) + "]" : A(t) || wt(t) ? JSON.stringify(t).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : t
+                return A(t) ? "[" + t.map(Ot) + "]" : D(t) || wt(t) ? JSON.stringify(t).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : t
             }
 
             function Tt(t) {
                 return null == t || "" === t ? null : !(!t || "false" === t || "0" === t) && !!t
             }
             const Nt = t => xt(t) || yt(t) ? t : Date.parse(t);
 
-            function zt(t, e) {
+            function Rt(t, e) {
                 return e = e || Nt, null == t || "" === t ? null : e(t)
             }
 
-            function Rt(t) {
+            function zt(t) {
                 return null == t || "" === t ? null : t + ""
             }
 
             function Pt(t) {
                 const e = {},
                     n = t.length;
                 for (let i = 0; i < n; ++i) e[t[i]] = !0;
@@ -19766,249 +19875,252 @@
                 const r = null != i ? i : "\u2026",
                     o = t + "",
                     a = o.length,
                     s = Math.max(0, e - r.length);
                 return a <= e ? o : "left" === n ? r + o.slice(a - s) : "center" === n ? o.slice(0, Math.ceil(s / 2)) + r + o.slice(a - ~~(s / 2)) : o.slice(0, s) + r
             }
 
-            function jt(t, e, n) {
+            function Bt(t, e, n) {
                 if (t)
                     if (e) {
                         const i = t.length;
                         for (let r = 0; r < i; ++r) {
                             const i = e(t[r]);
                             i && n(i, r, t)
                         }
                     } else t.forEach(n)
             }
         },
-        91149: (t, e, n) => {
+        94206: (t, e, n) => {
             "use strict";
             n.r(e), n.d(e, {
-                Bounds: () => $d,
-                CanvasHandler: () => Am,
-                CanvasRenderer: () => Om,
-                DATE: () => Mt,
+                Bounds: () => pC,
+                CanvasHandler: () => YF,
+                CanvasRenderer: () => nO,
+                DATE: () => Ft,
                 DAY: () => Ot,
                 DAYOFYEAR: () => Tt,
                 Dataflow: () => Nr,
                 Debug: () => m.cG,
                 Error: () => m.jj,
                 EventStream: () => yr,
-                Gradient: () => Kf,
-                GroupItem: () => Yd,
+                Gradient: () => yS,
+                GroupItem: () => gC,
                 HOURS: () => Nt,
-                Handler: () => sm,
+                Handler: () => SF,
+                HybridHandler: () => $O,
+                HybridRenderer: () => JO,
                 Info: () => m.kI,
-                Item: () => Zd,
+                Item: () => mC,
                 MILLISECONDS: () => Pt,
-                MINUTES: () => zt,
+                MINUTES: () => Rt,
                 MONTH: () => Ct,
-                Marks: () => Xp,
+                Marks: () => fF,
                 MultiPulse: () => Cr,
                 None: () => m.Hq,
                 Operator: () => mr,
                 Parameters: () => dr,
                 Pulse: () => Er,
                 QUARTER: () => St,
-                RenderType: () => wg,
-                Renderer: () => lm,
-                ResourceLoader: () => Vd,
-                SECONDS: () => Rt,
-                SVGHandler: () => Nm,
-                SVGRenderer: () => og,
-                SVGStringRenderer: () => bg,
-                Scenegraph: () => Qp,
+                RenderType: () => QO,
+                Renderer: () => MF,
+                ResourceLoader: () => vC,
+                SECONDS: () => zt,
+                SVGHandler: () => rO,
+                SVGRenderer: () => FO,
+                SVGStringRenderer: () => HO,
+                Scenegraph: () => bF,
                 TIME_UNITS: () => Lt,
-                Transform: () => Rr,
-                View: () => kF,
-                WEEK: () => Ft,
+                Transform: () => zr,
+                View: () => sP,
+                WEEK: () => Mt,
                 Warn: () => m.uU,
-                YEAR: () => At,
+                YEAR: () => Dt,
                 accessor: () => m.ZE,
                 accessorFields: () => m.Oj,
                 accessorName: () => m.el,
                 array: () => m.IX,
                 ascending: () => m.j2,
-                bandwidthNRD: () => Jr,
-                bin: () => Gr,
+                bandwidthNRD: () => Gr,
+                bin: () => Jr,
                 bootstrapCI: () => Yr,
-                boundClip: () => Mg,
-                boundContext: () => yh,
-                boundItem: () => Jp,
-                boundMark: () => $p,
-                boundStroke: () => th,
+                boundClip: () => sT,
+                boundContext: () => BC,
+                boundItem: () => dF,
+                boundMark: () => pF,
+                boundStroke: () => xC,
                 changeset: () => ur,
                 clampRange: () => m.l$,
-                codegenExpression: () => EA.YP,
+                codegenExpression: () => sN.YP,
                 compare: () => m.qu,
                 constant: () => m.a9,
                 cumulativeLogNormal: () => fo,
                 cumulativeNormal: () => oo,
                 cumulativeUniform: () => yo,
                 dayofyear: () => Ht,
                 debounce: () => m.Ds,
                 defaultLocale: () => wi,
                 definition: () => Lr,
                 densityLogNormal: () => uo,
                 densityNormal: () => ro,
                 densityUniform: () => vo,
-                domChild: () => im,
-                domClear: () => rm,
-                domCreate: () => em,
-                domFind: () => nm,
+                domChild: () => kF,
+                domClear: () => EF,
+                domCreate: () => _F,
+                domFind: () => wF,
                 dotbin: () => Vr,
                 error: () => m.vU,
-                expressionFunction: () => bC,
+                expressionFunction: () => bL,
                 extend: () => m.l7,
                 extent: () => m.We,
                 extentIndex: () => m.dI,
                 falsy: () => m.k,
                 fastmap: () => m.Xr,
                 field: () => m.EP,
                 flush: () => m.yl,
-                font: () => Lp,
-                fontFamily: () => Pp,
-                fontSize: () => Op,
-                format: () => Ji,
+                font: () => iF,
+                fontFamily: () => nF,
+                fontSize: () => VM,
+                format: () => Gi,
                 formatLocale: () => pi,
-                formats: () => Gi,
+                formats: () => Ji,
                 hasOwnProperty: () => m.nr,
                 id: () => m.id,
                 identity: () => m.yR,
-                inferType: () => Bi,
-                inferTypes: () => Ii,
+                inferType: () => Ii,
+                inferTypes: () => ji,
                 ingest: () => rr,
                 inherits: () => m.XW,
                 inrange: () => m.u5,
-                interpolate: () => xf,
-                interpolateColors: () => vf,
-                interpolateRange: () => gf,
-                intersect: () => Dg,
-                intersectBoxLine: () => Fh,
-                intersectPath: () => Dh,
-                intersectPoint: () => Ah,
-                intersectRule: () => Ch,
+                interpolate: () => jT,
+                interpolateColors: () => BT,
+                interpolateRange: () => LT,
+                intersect: () => nT,
+                intersectBoxLine: () => $C,
+                intersectPath: () => XC,
+                intersectPoint: () => GC,
+                intersectRule: () => ZC,
                 isArray: () => m.kJ,
                 isBoolean: () => m.jn,
                 isDate: () => m.J_,
                 isFunction: () => m.mf,
                 isIterable: () => m.TW,
                 isNumber: () => m.hj,
                 isObject: () => m.Kn,
                 isRegExp: () => m.Kj,
                 isString: () => m.HD,
                 isTuple: () => er,
                 key: () => m.Jy,
                 lerp: () => m.t7,
-                lineHeight: () => Tp,
+                lineHeight: () => KM,
                 loader: () => Yi,
                 locale: () => _i,
                 logger: () => m.kg,
                 lruCache: () => m.$m,
-                markup: () => Vm,
+                markup: () => wO,
                 merge: () => m.TS,
                 mergeConfig: () => m.fE,
-                multiLineOffset: () => zp,
+                multiLineOffset: () => tF,
                 one: () => m.kX,
                 pad: () => m.vk,
                 panLinear: () => m.Dw,
                 panLog: () => m.mJ,
                 panPow: () => m.QA,
                 panSymlog: () => m.Zw,
-                parse: () => XN,
-                parseExpression: () => EA.BJ,
-                parseSelector: () => CF.r,
-                path: () => Mc,
-                pathCurves: () => td,
-                pathEqual: () => Ng,
-                pathParse: () => ad,
-                pathRectangle: () => Md,
-                pathRender: () => vd,
-                pathSymbols: () => _d,
-                pathTrail: () => Od,
+                parse: () => bq,
+                parseExpression: () => sN.BJ,
+                parseSelector: () => _L.r,
+                path: () => jc,
+                pathCurves: () => xS,
+                pathEqual: () => uT,
+                pathParse: () => DS,
+                pathRectangle: () => YS,
+                pathRender: () => LS,
+                pathSymbols: () => US,
+                pathTrail: () => VS,
                 peek: () => m.fj,
-                point: () => am,
-                projection: () => J_,
+                point: () => DF,
+                projection: () => Q_,
                 quantileLogNormal: () => ho,
                 quantileNormal: () => ao,
                 quantileUniform: () => bo,
                 quantiles: () => Hr,
-                quantizeInterpolator: () => yf,
+                quantizeInterpolator: () => IT,
                 quarter: () => m.mS,
                 quartiles: () => Xr,
-                random: () => $r,
+                random: () => Zr,
                 randomInteger: () => Qr,
                 randomKDE: () => co,
                 randomLCG: () => Kr,
                 randomLogNormal: () => po,
                 randomMixture: () => mo,
                 randomNormal: () => so,
                 randomUniform: () => xo,
-                read: () => Zi,
+                read: () => $i,
                 regressionConstant: () => _o,
                 regressionExp: () => Co,
-                regressionLinear: () => Ao,
-                regressionLoess: () => Ro,
+                regressionLinear: () => Do,
+                regressionLoess: () => zo,
                 regressionLog: () => So,
                 regressionPoly: () => Oo,
-                regressionPow: () => Fo,
-                regressionQuad: () => Mo,
-                renderModule: () => Eg,
+                regressionPow: () => Mo,
+                regressionQuad: () => Fo,
+                renderModule: () => eT,
                 repeat: () => m.rx,
                 resetDefaultLocale: () => ki,
-                resetSVGClipId: () => Jd,
-                resetSVGDefIds: () => zg,
-                responseType: () => $i,
-                runtimeContext: () => FC,
-                sampleCurve: () => Bo,
+                resetSVGClipId: () => dC,
+                resetSVGDefIds: () => fT,
+                responseType: () => Zi,
+                runtimeContext: () => hz,
+                sampleCurve: () => Io,
                 sampleLogNormal: () => lo,
                 sampleNormal: () => io,
                 sampleUniform: () => go,
-                scale: () => af,
-                sceneEqual: () => Tg,
-                sceneFromJSON: () => Vp,
-                scenePickVisit: () => Ih,
-                sceneToJSON: () => Yp,
-                sceneVisit: () => Bh,
-                sceneZOrder: () => jh,
-                scheme: () => Ef,
-                serializeXML: () => Km,
-                setRandom: () => Zr,
+                scale: () => PT,
+                sceneEqual: () => lT,
+                sceneFromJSON: () => vF,
+                scenePickVisit: () => aM,
+                sceneToJSON: () => gF,
+                sceneVisit: () => oM,
+                sceneZOrder: () => rM,
+                scheme: () => HT,
+                serializeXML: () => kO,
+                setHybridRendererOptions: () => GO,
+                setRandom: () => $r,
                 span: () => m.yP,
                 splitAccessPath: () => m._k,
                 stringValue: () => m.m8,
-                textMetrics: () => Dp,
-                timeBin: () => ze,
+                textMetrics: () => XM,
+                timeBin: () => Re,
                 timeFloor: () => ae,
                 timeFormatLocale: () => bi,
                 timeInterval: () => de,
                 timeOffset: () => me,
                 timeSequence: () => ye,
                 timeUnitSpecifier: () => Ut,
-                timeUnits: () => Bt,
+                timeUnits: () => It,
                 toBoolean: () => m.sw,
                 toDate: () => m.ZU,
                 toNumber: () => m.He,
                 toSet: () => m.Rg,
                 toString: () => m.BB,
-                transform: () => jr,
+                transform: () => Br,
                 transforms: () => Pr,
                 truncate: () => m.$G,
                 truthy: () => m.yb,
                 tupleid: () => nr,
                 typeParsers: () => Pi,
                 utcFloor: () => le,
                 utcInterval: () => he,
                 utcOffset: () => ge,
                 utcSequence: () => be,
                 utcdayofyear: () => Yt,
                 utcquarter: () => m.N3,
                 utcweek: () => Vt,
-                version: () => JN,
+                version: () => xq,
                 visitArray: () => m.FP,
                 week: () => Xt,
                 writeConfig: () => m.iL,
                 zero: () => m.bM,
                 zoomLinear: () => m.ay,
                 zoomLog: () => m.dH,
                 zoomPow: () => m.mK,
@@ -20022,144 +20134,144 @@
                 compare: () => la,
                 countpattern: () => fa,
                 cross: () => da,
                 density: () => ga,
                 dotbin: () => _a,
                 expression: () => wa,
                 extent: () => Ea,
-                facet: () => Aa,
+                facet: () => Da,
                 field: () => Sa,
-                filter: () => Fa,
-                flatten: () => Ma,
+                filter: () => Ma,
+                flatten: () => Fa,
                 fold: () => Oa,
                 formula: () => Ta,
                 generate: () => Na,
                 impute: () => Pa,
                 joinaggregate: () => La,
-                kde: () => ja,
-                key: () => Ba,
+                kde: () => Ba,
+                key: () => Ia,
                 load: () => Ua,
                 lookup: () => Wa,
                 multiextent: () => Ha,
-                multivalues: () => Ja,
-                params: () => $a,
-                pivot: () => Za,
+                multivalues: () => Ga,
+                params: () => Za,
+                pivot: () => $a,
                 prefacet: () => Ya,
                 project: () => Va,
                 proxy: () => Ka,
                 quantile: () => Qa,
                 relay: () => ts,
                 sample: () => es,
                 sequence: () => ns,
                 sieve: () => is,
-                subflow: () => Da,
+                subflow: () => Aa,
                 timeunit: () => rs,
                 tupleindex: () => as,
                 values: () => ss,
                 window: () => ds
             });
             var r = {};
             n.r(r), n.d(r, {
-                interpolate: () => dl.Z,
-                interpolateArray: () => Al.Z,
-                interpolateBasis: () => Sl.Z,
-                interpolateBasisClosed: () => Cl.Z,
-                interpolateCubehelix: () => Su,
-                interpolateCubehelixLong: () => Cu,
-                interpolateDate: () => Fl.Z,
-                interpolateDiscrete: () => Ml,
-                interpolateHcl: () => pu,
-                interpolateHclLong: () => mu,
-                interpolateHsl: () => Wl,
-                interpolateHslLong: () => Hl,
-                interpolateHue: () => Tl,
-                interpolateLab: () => du,
-                interpolateNumber: () => Nl.Z,
-                interpolateNumberArray: () => zl.Z,
-                interpolateObject: () => Rl.Z,
-                interpolateRgb: () => Il.ZP,
-                interpolateRgbBasis: () => Il.hD,
-                interpolateRgbBasisClosed: () => Il.YD,
-                interpolateRound: () => hl.Z,
-                interpolateString: () => Pl.Z,
-                interpolateTransformCss: () => Ll.Y,
-                interpolateTransformSvg: () => Ll.w,
-                interpolateZoom: () => Bl,
-                piecewise: () => yl,
-                quantize: () => Fu
+                interpolate: () => Cl.Z,
+                interpolateArray: () => $l.Z,
+                interpolateBasis: () => Yl.Z,
+                interpolateBasisClosed: () => Vl.Z,
+                interpolateCubehelix: () => Yu,
+                interpolateCubehelixLong: () => Vu,
+                interpolateDate: () => Kl.Z,
+                interpolateDiscrete: () => Ql,
+                interpolateHcl: () => Lu,
+                interpolateHclLong: () => Bu,
+                interpolateHsl: () => du,
+                interpolateHslLong: () => hu,
+                interpolateHue: () => eu,
+                interpolateLab: () => zu,
+                interpolateNumber: () => nu.Z,
+                interpolateNumberArray: () => iu.Z,
+                interpolateObject: () => ru.Z,
+                interpolateRgb: () => lu.ZP,
+                interpolateRgbBasis: () => lu.hD,
+                interpolateRgbBasisClosed: () => lu.YD,
+                interpolateRound: () => Ml.Z,
+                interpolateString: () => ou.Z,
+                interpolateTransformCss: () => au.Y,
+                interpolateTransformSvg: () => au.w,
+                interpolateZoom: () => cu,
+                piecewise: () => Ll,
+                quantize: () => Ku
             });
             var o = {};
             n.r(o), n.d(o, {
-                bound: () => yv,
-                identifier: () => _v,
-                mark: () => wv,
-                overlap: () => kv,
-                render: () => Mv,
-                viewlayout: () => Kv
+                bound: () => Av,
+                identifier: () => Cv,
+                mark: () => Mv,
+                overlap: () => Fv,
+                render: () => Lv,
+                viewlayout: () => oy
             });
             var a = {};
             n.r(a), n.d(a, {
-                axisticks: () => ty,
-                datajoin: () => ey,
-                encode: () => iy,
-                legendentries: () => ry,
-                linkpath: () => ly,
-                pie: () => py,
-                scale: () => yy,
-                sortitems: () => wy,
-                stack: () => Sy
+                axisticks: () => sy,
+                datajoin: () => cy,
+                encode: () => uy,
+                legendentries: () => fy,
+                linkpath: () => gy,
+                pie: () => _y,
+                scale: () => Ay,
+                sortitems: () => My,
+                stack: () => Ry
             });
             var s = {};
             n.r(s), n.d(s, {
-                contour: () => mw,
-                geojson: () => yw,
-                geopath: () => bw,
-                geopoint: () => xw,
-                geoshape: () => _w,
-                graticule: () => ww,
-                heatmap: () => kw,
-                isocontour: () => ow,
-                kde2d: () => dw,
-                projection: () => Dw
+                contour: () => ww,
+                geojson: () => Aw,
+                geopath: () => Dw,
+                geopoint: () => Sw,
+                geoshape: () => Cw,
+                graticule: () => Mw,
+                heatmap: () => Fw,
+                isocontour: () => dw,
+                kde2d: () => bw,
+                projection: () => Tw
             });
             var c = {};
             n.r(c), n.d(c, {
-                force: () => sk
+                force: () => pk
             });
             var l = {};
             n.r(l), n.d(l, {
-                nest: () => pE,
-                pack: () => xE,
-                partition: () => wE,
-                stratify: () => kE,
-                tree: () => AE,
-                treelinks: () => SE,
-                treemap: () => ME
+                nest: () => _E,
+                pack: () => SE,
+                partition: () => ME,
+                stratify: () => FE,
+                tree: () => NE,
+                treelinks: () => RE,
+                treemap: () => LE
             });
             var u = {};
             n.r(u), n.d(u, {
-                label: () => QE
+                label: () => aA
             });
             var f = {};
             n.r(f), n.d(f, {
-                loess: () => eD,
-                regression: () => iD
+                loess: () => cA,
+                regression: () => uA
             });
             var d = {};
             n.r(d), n.d(d, {
-                voronoi: () => PD
+                voronoi: () => WA
             });
             var h = {};
             n.r(h), n.d(h, {
-                wordcloud: () => KD
+                wordcloud: () => oD
             });
             var p = {};
             n.r(p), n.d(p, {
-                crossfilter: () => aA,
-                resolvefilter: () => sA
+                crossfilter: () => hD,
+                resolvefilter: () => pD
             });
             var m = n(15721),
                 g = {},
                 v = {},
                 y = 34,
                 b = 10,
                 x = 13;
@@ -20188,15 +20300,15 @@
                 var e, n = t.getUTCHours(),
                     i = t.getUTCMinutes(),
                     r = t.getUTCSeconds(),
                     o = t.getUTCMilliseconds();
                 return isNaN(t) ? "Invalid Date" : ((e = t.getUTCFullYear()) < 0 ? "-" + k(-e, 6) : e > 9999 ? "+" + k(e, 6) : k(e, 4)) + "-" + k(t.getUTCMonth() + 1, 2) + "-" + k(t.getUTCDate(), 2) + (o ? "T" + k(n, 2) + ":" + k(i, 2) + ":" + k(r, 2) + "." + k(o, 3) + "Z" : r ? "T" + k(n, 2) + ":" + k(i, 2) + ":" + k(r, 2) + "Z" : i || n ? "T" + k(n, 2) + ":" + k(i, 2) + "Z" : "")
             }
 
-            function D(t) {
+            function A(t) {
                 var e = new RegExp('["' + t + "\n\r]"),
                     n = t.charCodeAt(0);
 
                 function i(t, e) {
                     var i, r = [],
                         o = t.length,
                         a = 0,
@@ -20267,15 +20379,15 @@
                         return t.map(o).join("\n")
                     },
                     formatRow: o,
                     formatValue: a
                 }
             }
 
-            function A(t) {
+            function D(t) {
                 return t
             }
 
             function S(t, e) {
                 return "string" === typeof e && (e = t.objects[e]), "GeometryCollection" === e.type ? {
                     type: "FeatureCollection",
                     features: e.geometries.map((function(e) {
@@ -20284,15 +20396,15 @@
                 } : C(t, e)
             }
 
             function C(t, e) {
                 var n = e.id,
                     i = e.bbox,
                     r = null == e.properties ? {} : e.properties,
-                    o = F(t, e);
+                    o = M(t, e);
                 return null == n && null == i ? {
                     type: "Feature",
                     properties: r,
                     geometry: o
                 } : null == i ? {
                     type: "Feature",
                     id: n,
@@ -20303,17 +20415,17 @@
                     id: n,
                     bbox: i,
                     properties: r,
                     geometry: o
                 }
             }
 
-            function F(t, e) {
+            function M(t, e) {
                 var n = function(t) {
-                        if (null == t) return A;
+                        if (null == t) return D;
                         var e, n, i = t.scale[0],
                             r = t.scale[1],
                             o = t.translate[0],
                             a = t.translate[1];
                         return function(t, s) {
                             s || (e = n = 0);
                             var c = 2,
@@ -20381,15 +20493,15 @@
                     return {
                         type: i,
                         coordinates: n
                     }
                 }(e)
             }
 
-            function M(t, e) {
+            function F(t, e) {
                 var n = {},
                     i = {},
                     r = {},
                     o = [],
                     a = -1;
 
                 function s(t, e) {
@@ -20429,15 +20541,15 @@
                     else i[(n = [e]).start = s] = r[n.end = c] = n
                 })), s(r, i), s(i, r), e.forEach((function(t) {
                     n[t < 0 ? ~t : t] || o.push([t])
                 })), o
             }
 
             function O(t) {
-                return F(t, T.apply(this, arguments))
+                return M(t, T.apply(this, arguments))
             }
 
             function T(t, e, n) {
                 var i, r, o;
                 if (arguments.length > 1) i = function(t, e, n) {
                     var i, r = [],
                         o = [];
@@ -20484,25 +20596,25 @@
                         n(t[0].g, t[t.length - 1].g) && r.push(t[0].i)
                     }), r
                 }(0, e, n);
                 else
                     for (r = 0, i = new Array(o = t.arcs.length); r < o; ++r) i[r] = r;
                 return {
                     type: "MultiLineString",
-                    arcs: M(t, i)
+                    arcs: F(t, i)
                 }
             }
             var N = n(88747),
-                z = n(14547),
-                R = n(37012),
+                R = n(14547),
+                z = n(37012),
                 P = n(29641),
                 L = n(86790),
-                j = n(86425),
-                B = n(28159);
-            const I = new Date,
+                B = n(86425),
+                I = n(28159);
+            const j = new Date,
                 U = new Date;
 
             function q(t, e, n, i) {
                 function r(e) {
                     return t(e = 0 === arguments.length ? new Date : new Date(+e)), e
                 }
                 return r.floor = e => (t(e = new Date(+e)), e), r.ceil = n => (t(n = new Date(n - 1)), e(n, 1), t(n), n), r.round = t => {
@@ -20524,42 +20636,42 @@
                     if (t >= t)
                         if (i < 0)
                             for (; ++i <= 0;)
                                 for (; e(t, -1), !n(t););
                         else
                             for (; --i >= 0;)
                                 for (; e(t, 1), !n(t););
-                })), n && (r.count = (e, i) => (I.setTime(+e), U.setTime(+i), t(I), t(U), Math.floor(n(I, U))), r.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? r.filter(i ? e => i(e) % t === 0 : e => r.count(0, e) % t === 0) : r : null)), r
+                })), n && (r.count = (e, i) => (j.setTime(+e), U.setTime(+i), t(j), t(U), Math.floor(n(j, U))), r.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? r.filter(i ? e => i(e) % t === 0 : e => r.count(0, e) % t === 0) : r : null)), r
             }
             const W = 1e3,
                 H = 6e4,
                 X = 36e5,
-                J = 864e5,
-                G = 6048e5,
-                $ = 2592e6,
-                Z = 31536e6,
-                Y = q((t => t.setHours(0, 0, 0, 0)), ((t, e) => t.setDate(t.getDate() + e)), ((t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * H) / J), (t => t.getDate() - 1)),
+                G = 864e5,
+                J = 6048e5,
+                Z = 2592e6,
+                $ = 31536e6,
+                Y = q((t => t.setHours(0, 0, 0, 0)), ((t, e) => t.setDate(t.getDate() + e)), ((t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * H) / G), (t => t.getDate() - 1)),
                 V = (Y.range, q((t => {
                     t.setUTCHours(0, 0, 0, 0)
                 }), ((t, e) => {
                     t.setUTCDate(t.getUTCDate() + e)
-                }), ((t, e) => (e - t) / J), (t => t.getUTCDate() - 1))),
+                }), ((t, e) => (e - t) / G), (t => t.getUTCDate() - 1))),
                 K = (V.range, q((t => {
                     t.setUTCHours(0, 0, 0, 0)
                 }), ((t, e) => {
                     t.setUTCDate(t.getUTCDate() + e)
-                }), ((t, e) => (e - t) / J), (t => Math.floor(t / J))));
+                }), ((t, e) => (e - t) / G), (t => Math.floor(t / G))));
             K.range;
 
             function Q(t) {
                 return q((e => {
                     e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0)
                 }), ((t, e) => {
                     t.setDate(t.getDate() + 7 * e)
-                }), ((t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * H) / G))
+                }), ((t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * H) / J))
             }
             const tt = Q(0),
                 et = Q(1),
                 nt = Q(2),
                 it = Q(3),
                 rt = Q(4),
                 ot = Q(5),
@@ -20567,15 +20679,15 @@
             tt.range, et.range, nt.range, it.range, rt.range, ot.range, at.range;
 
             function st(t) {
                 return q((e => {
                     e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0)
                 }), ((t, e) => {
                     t.setUTCDate(t.getUTCDate() + 7 * e)
-                }), ((t, e) => (e - t) / G))
+                }), ((t, e) => (e - t) / J))
             }
             const ct = st(0),
                 lt = st(1),
                 ut = st(2),
                 ft = st(3),
                 dt = st(4),
                 ht = st(5),
@@ -20642,57 +20754,57 @@
                 }), ((t, e) => e - t)));
             Et.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? q((e => {
                 e.setTime(Math.floor(e / t) * t)
             }), ((e, n) => {
                 e.setTime(+e + n * t)
             }), ((e, n) => (n - e) / t)) : Et : null);
             Et.range;
-            var Dt = n(53619);
-            const At = "year",
+            var At = n(53619);
+            const Dt = "year",
                 St = "quarter",
                 Ct = "month",
-                Ft = "week",
-                Mt = "date",
+                Mt = "week",
+                Ft = "date",
                 Ot = "day",
                 Tt = "dayofyear",
                 Nt = "hours",
-                zt = "minutes",
-                Rt = "seconds",
+                Rt = "minutes",
+                zt = "seconds",
                 Pt = "milliseconds",
-                Lt = [At, St, Ct, Ft, Mt, Ot, Tt, Nt, zt, Rt, Pt],
-                jt = Lt.reduce(((t, e, n) => (t[e] = 1 + n, t)), {});
+                Lt = [Dt, St, Ct, Mt, Ft, Ot, Tt, Nt, Rt, zt, Pt],
+                Bt = Lt.reduce(((t, e, n) => (t[e] = 1 + n, t)), {});
 
-            function Bt(t) {
+            function It(t) {
                 const e = (0, m.IX)(t).slice(),
                     n = {};
                 e.length || (0, m.vU)("Missing time unit."), e.forEach((t => {
-                    (0, m.nr)(jt, t) ? n[t] = 1: (0, m.vU)("Invalid time unit: ".concat(t, "."))
+                    (0, m.nr)(Bt, t) ? n[t] = 1: (0, m.vU)("Invalid time unit: ".concat(t, "."))
                 }));
-                return (n[Ft] || n[Ot] ? 1 : 0) + (n[St] || n[Ct] || n[Mt] ? 1 : 0) + (n[Tt] ? 1 : 0) > 1 && (0, m.vU)("Incompatible time units: ".concat(t)), e.sort(((t, e) => jt[t] - jt[e])), e
+                return (n[Mt] || n[Ot] ? 1 : 0) + (n[St] || n[Ct] || n[Ft] ? 1 : 0) + (n[Tt] ? 1 : 0) > 1 && (0, m.vU)("Incompatible time units: ".concat(t)), e.sort(((t, e) => Bt[t] - Bt[e])), e
             }
-            const It = {
-                [At]: "%Y ",
+            const jt = {
+                [Dt]: "%Y ",
                 [St]: "Q%q ",
                 [Ct]: "%b ",
-                [Mt]: "%d ",
-                [Ft]: "W%U ",
+                [Ft]: "%d ",
+                [Mt]: "W%U ",
                 [Ot]: "%a ",
                 [Tt]: "%j ",
                 [Nt]: "%H:00",
-                [zt]: "00:%M",
-                [Rt]: ":%S",
+                [Rt]: "00:%M",
+                [zt]: ":%S",
                 [Pt]: ".%L",
-                ["".concat(At, "-").concat(Ct)]: "%Y-%m ",
-                ["".concat(At, "-").concat(Ct, "-").concat(Mt)]: "%Y-%m-%d ",
-                ["".concat(Nt, "-").concat(zt)]: "%H:%M"
+                ["".concat(Dt, "-").concat(Ct)]: "%Y-%m ",
+                ["".concat(Dt, "-").concat(Ct, "-").concat(Ft)]: "%Y-%m-%d ",
+                ["".concat(Nt, "-").concat(Rt)]: "%H:%M"
             };
 
             function Ut(t, e) {
-                const n = (0, m.l7)({}, It, e),
-                    i = Bt(t),
+                const n = (0, m.l7)({}, jt, e),
+                    i = It(t),
                     r = i.length;
                 let o, a, s = "",
                     c = 0;
                 for (c = 0; c < r;)
                     for (o = i.length; o > c; --o)
                         if (a = i.slice(c, o).join("-"), null != n[a]) {
                             s += n[a], c = o;
@@ -20702,34 +20814,34 @@
             const qt = new Date;
 
             function Wt(t) {
                 return qt.setFullYear(t), qt.setMonth(0), qt.setDate(1), qt.setHours(0, 0, 0, 0), qt
             }
 
             function Ht(t) {
-                return Jt(new Date(t))
+                return Gt(new Date(t))
             }
 
             function Xt(t) {
-                return Gt(new Date(t))
+                return Jt(new Date(t))
             }
 
-            function Jt(t) {
+            function Gt(t) {
                 return Y.count(Wt(t.getFullYear()) - 1, t)
             }
 
-            function Gt(t) {
+            function Jt(t) {
                 return tt.count(Wt(t.getFullYear()) - 1, t)
             }
 
-            function $t(t) {
+            function Zt(t) {
                 return Wt(t).getDay()
             }
 
-            function Zt(t, e, n, i, r, o, a) {
+            function $t(t, e, n, i, r, o, a) {
                 if (0 <= t && t < 100) {
                     const s = new Date(-1, e, n, i, r, o, a);
                     return s.setFullYear(t), s
                 }
                 return new Date(t, e, n, i, r, o, a)
             }
 
@@ -20768,99 +20880,99 @@
                     a = (0, m.fj)(t),
                     s = (t, e, r) => function(t, e, n, i) {
                         const r = n <= 1 ? t : i ? (e, r) => i + n * Math.floor((t(e, r) - i) / n) : (e, i) => n * Math.floor(t(e, i) / n);
                         return e ? (t, n) => e(r(t, n), n) : r
                     }(n[r = r || t], i[r], t === a && o, e),
                     c = new Date,
                     l = (0, m.Rg)(t),
-                    u = l[At] ? s(At) : (0, m.a9)(2012),
+                    u = l[Dt] ? s(Dt) : (0, m.a9)(2012),
                     f = l[Ct] ? s(Ct) : l[St] ? s(St) : m.bM,
-                    d = l[Ft] && l[Ot] ? s(Ot, 1, Ft + Ot) : l[Ft] ? s(Ft, 1) : l[Ot] ? s(Ot, 1) : l[Mt] ? s(Mt, 1) : l[Tt] ? s(Tt, 1) : m.kX,
+                    d = l[Mt] && l[Ot] ? s(Ot, 1, Mt + Ot) : l[Mt] ? s(Mt, 1) : l[Ot] ? s(Ot, 1) : l[Ft] ? s(Ft, 1) : l[Tt] ? s(Tt, 1) : m.kX,
                     h = l[Nt] ? s(Nt) : m.bM,
-                    p = l[zt] ? s(zt) : m.bM,
-                    g = l[Rt] ? s(Rt) : m.bM,
+                    p = l[Rt] ? s(Rt) : m.bM,
+                    g = l[zt] ? s(zt) : m.bM,
                     v = l[Pt] ? s(Pt) : m.bM;
                 return function(t) {
                     c.setTime(+t);
                     const e = u(c);
                     return r(e, f(c), d(c, e), h(c), p(c), g(c), v(c))
                 }
             }
 
             function ie(t, e, n) {
                 return e + 7 * t - (n + 6) % 7
             }
             const re = {
-                    [At]: t => t.getFullYear(),
+                    [Dt]: t => t.getFullYear(),
                     [St]: t => Math.floor(t.getMonth() / 3),
                     [Ct]: t => t.getMonth(),
-                    [Mt]: t => t.getDate(),
+                    [Ft]: t => t.getDate(),
                     [Nt]: t => t.getHours(),
-                    [zt]: t => t.getMinutes(),
-                    [Rt]: t => t.getSeconds(),
+                    [Rt]: t => t.getMinutes(),
+                    [zt]: t => t.getSeconds(),
                     [Pt]: t => t.getMilliseconds(),
-                    [Tt]: t => Jt(t),
-                    [Ft]: t => Gt(t),
-                    [Ft + Ot]: (t, e) => ie(Gt(t), t.getDay(), $t(e)),
-                    [Ot]: (t, e) => ie(1, t.getDay(), $t(e))
+                    [Tt]: t => Gt(t),
+                    [Mt]: t => Jt(t),
+                    [Mt + Ot]: (t, e) => ie(Jt(t), t.getDay(), Zt(e)),
+                    [Ot]: (t, e) => ie(1, t.getDay(), Zt(e))
                 },
                 oe = {
                     [St]: t => 3 * t,
-                    [Ft]: (t, e) => ie(t, 0, $t(e))
+                    [Mt]: (t, e) => ie(t, 0, Zt(e))
                 };
 
             function ae(t, e) {
-                return ne(t, e || 1, re, oe, Zt)
+                return ne(t, e || 1, re, oe, $t)
             }
             const se = {
-                    [At]: t => t.getUTCFullYear(),
+                    [Dt]: t => t.getUTCFullYear(),
                     [St]: t => Math.floor(t.getUTCMonth() / 3),
                     [Ct]: t => t.getUTCMonth(),
-                    [Mt]: t => t.getUTCDate(),
+                    [Ft]: t => t.getUTCDate(),
                     [Nt]: t => t.getUTCHours(),
-                    [zt]: t => t.getUTCMinutes(),
-                    [Rt]: t => t.getUTCSeconds(),
+                    [Rt]: t => t.getUTCMinutes(),
+                    [zt]: t => t.getUTCSeconds(),
                     [Pt]: t => t.getUTCMilliseconds(),
                     [Tt]: t => Kt(t),
-                    [Ft]: t => Qt(t),
+                    [Mt]: t => Qt(t),
                     [Ot]: (t, e) => ie(1, t.getUTCDay(), te(e)),
-                    [Ft + Ot]: (t, e) => ie(Qt(t), t.getUTCDay(), te(e))
+                    [Mt + Ot]: (t, e) => ie(Qt(t), t.getUTCDay(), te(e))
                 },
                 ce = {
                     [St]: t => 3 * t,
-                    [Ft]: (t, e) => ie(t, 0, te(e))
+                    [Mt]: (t, e) => ie(t, 0, te(e))
                 };
 
             function le(t, e) {
                 return ne(t, e || 1, se, ce, ee)
             }
             const ue = {
-                    [At]: mt,
+                    [Dt]: mt,
                     [St]: vt.every(3),
                     [Ct]: vt,
-                    [Ft]: tt,
-                    [Mt]: Y,
+                    [Mt]: tt,
+                    [Ft]: Y,
                     [Ot]: Y,
                     [Tt]: Y,
                     [Nt]: bt,
-                    [zt]: _t,
-                    [Rt]: kt,
+                    [Rt]: _t,
+                    [zt]: kt,
                     [Pt]: Et
                 },
                 fe = {
-                    [At]: gt,
+                    [Dt]: gt,
                     [St]: yt.every(3),
                     [Ct]: yt,
-                    [Ft]: ct,
-                    [Mt]: V,
+                    [Mt]: ct,
+                    [Ft]: V,
                     [Ot]: V,
                     [Tt]: V,
                     [Nt]: xt,
-                    [zt]: wt,
-                    [Rt]: kt,
+                    [Rt]: wt,
+                    [zt]: kt,
                     [Pt]: Et
                 };
 
             function de(t) {
                 return ue[t]
             }
 
@@ -20892,56 +21004,56 @@
                 return ve(he(t), e, n, i)
             }
             const xe = 1e3,
                 _e = 6e4,
                 we = 36e5,
                 ke = 864e5,
                 Ee = 2592e6,
-                De = 31536e6,
-                Ae = [At, Ct, Mt, Nt, zt, Rt, Pt],
-                Se = Ae.slice(0, -1),
+                Ae = 31536e6,
+                De = [Dt, Ct, Ft, Nt, Rt, zt, Pt],
+                Se = De.slice(0, -1),
                 Ce = Se.slice(0, -1),
-                Fe = Ce.slice(0, -1),
-                Me = Fe.slice(0, -1),
-                Oe = [At, Ct],
-                Te = [At],
+                Me = Ce.slice(0, -1),
+                Fe = Me.slice(0, -1),
+                Oe = [Dt, Ct],
+                Te = [Dt],
                 Ne = [
                     [Se, 1, xe],
                     [Se, 5, 5e3],
                     [Se, 15, 15e3],
                     [Se, 30, 3e4],
                     [Ce, 1, _e],
                     [Ce, 5, 3e5],
                     [Ce, 15, 9e5],
                     [Ce, 30, 18e5],
-                    [Fe, 1, we],
-                    [Fe, 3, 108e5],
-                    [Fe, 6, 216e5],
-                    [Fe, 12, 432e5],
-                    [Me, 1, ke],
+                    [Me, 1, we],
+                    [Me, 3, 108e5],
+                    [Me, 6, 216e5],
+                    [Me, 12, 432e5],
+                    [Fe, 1, ke],
                     [
-                        [At, Ft], 1, 6048e5
+                        [Dt, Mt], 1, 6048e5
                     ],
                     [Oe, 1, Ee],
                     [Oe, 3, 7776e6],
-                    [Te, 1, De]
+                    [Te, 1, Ae]
                 ];
 
-            function ze(t) {
+            function Re(t) {
                 const e = t.extent,
                     n = t.maxbins || 40,
                     i = Math.abs((0, m.yP)(e)) / n;
-                let r, o, a = (0, Dt.Z)((t => t[2])).right(Ne, i);
-                return a === Ne.length ? (r = Te, o = (0, N.ly)(e[0] / De, e[1] / De, n)) : a ? (a = Ne[i / Ne[a - 1][2] < Ne[a][2] / i ? a - 1 : a], r = a[0], o = a[1]) : (r = Ae, o = Math.max((0, N.ly)(e[0], e[1], n), 1)), {
+                let r, o, a = (0, At.Z)((t => t[2])).right(Ne, i);
+                return a === Ne.length ? (r = Te, o = (0, N.ly)(e[0] / Ae, e[1] / Ae, n)) : a ? (a = Ne[i / Ne[a - 1][2] < Ne[a][2] / i ? a - 1 : a], r = a[0], o = a[1]) : (r = De, o = Math.max((0, N.ly)(e[0], e[1], n), 1)), {
                     units: r,
                     step: o
                 }
             }
 
-            function Re(t) {
+            function ze(t) {
                 if (0 <= t.y && t.y < 100) {
                     var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
                     return e.setFullYear(t.y), e
                 }
                 return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L)
             }
 
@@ -20961,15 +21073,15 @@
                     H: 0,
                     M: 0,
                     S: 0,
                     L: 0
                 }
             }
 
-            function je(t) {
+            function Be(t) {
                 var e = t.dateTime,
                     n = t.date,
                     i = t.time,
                     r = t.periods,
                     o = t.days,
                     a = t.shortDays,
                     s = t.months,
@@ -20997,41 +21109,41 @@
                         B: function(t) {
                             return s[t.getMonth()]
                         },
                         c: null,
                         d: bn,
                         e: bn,
                         f: En,
-                        g: Rn,
+                        g: zn,
                         G: Ln,
                         H: xn,
                         I: _n,
                         j: wn,
                         L: kn,
-                        m: Dn,
-                        M: An,
+                        m: An,
+                        M: Dn,
                         p: function(t) {
                             return r[+(t.getHours() >= 12)]
                         },
                         q: function(t) {
                             return 1 + ~~(t.getMonth() / 3)
                         },
                         Q: ai,
                         s: si,
                         S: Sn,
                         u: Cn,
-                        U: Fn,
+                        U: Mn,
                         V: On,
                         w: Tn,
                         W: Nn,
                         x: null,
                         X: null,
-                        y: zn,
+                        y: Rn,
                         Y: Pn,
-                        Z: jn,
+                        Z: Bn,
                         "%": oi
                     },
                     x = {
                         a: function(t) {
                             return a[t.getUTCDay()]
                         },
                         A: function(t) {
@@ -21040,36 +21152,36 @@
                         b: function(t) {
                             return c[t.getUTCMonth()]
                         },
                         B: function(t) {
                             return s[t.getUTCMonth()]
                         },
                         c: null,
-                        d: Bn,
-                        e: Bn,
+                        d: In,
+                        e: In,
                         f: Hn,
                         g: ei,
                         G: ii,
-                        H: In,
+                        H: jn,
                         I: Un,
                         j: qn,
                         L: Wn,
                         m: Xn,
-                        M: Jn,
+                        M: Gn,
                         p: function(t) {
                             return r[+(t.getUTCHours() >= 12)]
                         },
                         q: function(t) {
                             return 1 + ~~(t.getUTCMonth() / 3)
                         },
                         Q: ai,
                         s: si,
-                        S: Gn,
-                        u: $n,
-                        U: Zn,
+                        S: Jn,
+                        u: Zn,
+                        U: $n,
                         V: Vn,
                         w: Kn,
                         W: Qn,
                         x: null,
                         X: null,
                         y: ti,
                         Y: ni,
@@ -21147,17 +21259,17 @@
                     return function(n) {
                         var i, r, o = Le(1900, void 0, 1);
                         if (E(o, t, n += "", 0) != n.length) return null;
                         if ("Q" in o) return new Date(o.Q);
                         if ("s" in o) return new Date(1e3 * o.s + ("L" in o ? o.L : 0));
                         if (e && !("Z" in o) && (o.Z = 0), "p" in o && (o.H = o.H % 12 + 12 * o.p), void 0 === o.m && (o.m = "q" in o ? o.q : 0), "V" in o) {
                             if (o.V < 1 || o.V > 53) return null;
-                            "w" in o || (o.w = 1), "Z" in o ? (r = (i = Pe(Le(o.y, 0, 1))).getUTCDay(), i = r > 4 || 0 === r ? lt.ceil(i) : lt(i), i = V.offset(i, 7 * (o.V - 1)), o.y = i.getUTCFullYear(), o.m = i.getUTCMonth(), o.d = i.getUTCDate() + (o.w + 6) % 7) : (r = (i = Re(Le(o.y, 0, 1))).getDay(), i = r > 4 || 0 === r ? et.ceil(i) : et(i), i = Y.offset(i, 7 * (o.V - 1)), o.y = i.getFullYear(), o.m = i.getMonth(), o.d = i.getDate() + (o.w + 6) % 7)
-                        } else("W" in o || "U" in o) && ("w" in o || (o.w = "u" in o ? o.u % 7 : "W" in o ? 1 : 0), r = "Z" in o ? Pe(Le(o.y, 0, 1)).getUTCDay() : Re(Le(o.y, 0, 1)).getDay(), o.m = 0, o.d = "W" in o ? (o.w + 6) % 7 + 7 * o.W - (r + 5) % 7 : o.w + 7 * o.U - (r + 6) % 7);
-                        return "Z" in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, Pe(o)) : Re(o)
+                            "w" in o || (o.w = 1), "Z" in o ? (r = (i = Pe(Le(o.y, 0, 1))).getUTCDay(), i = r > 4 || 0 === r ? lt.ceil(i) : lt(i), i = V.offset(i, 7 * (o.V - 1)), o.y = i.getUTCFullYear(), o.m = i.getUTCMonth(), o.d = i.getUTCDate() + (o.w + 6) % 7) : (r = (i = ze(Le(o.y, 0, 1))).getDay(), i = r > 4 || 0 === r ? et.ceil(i) : et(i), i = Y.offset(i, 7 * (o.V - 1)), o.y = i.getFullYear(), o.m = i.getMonth(), o.d = i.getDate() + (o.w + 6) % 7)
+                        } else("W" in o || "U" in o) && ("w" in o || (o.w = "u" in o ? o.u % 7 : "W" in o ? 1 : 0), r = "Z" in o ? Pe(Le(o.y, 0, 1)).getUTCDay() : ze(Le(o.y, 0, 1)).getDay(), o.m = 0, o.d = "W" in o ? (o.w + 6) % 7 + 7 * o.W - (r + 5) % 7 : o.w + 7 * o.U - (r + 6) % 7);
+                        return "Z" in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, Pe(o)) : ze(o)
                     }
                 }
 
                 function E(t, e, n, i) {
                     for (var r, o, a = 0, s = e.length, c = n.length; a < s;) {
                         if (i >= c) return -1;
                         if (37 === (r = e.charCodeAt(a++))) {
@@ -21189,36 +21301,36 @@
                         var e = k(t += "", !0);
                         return e.toString = function() {
                             return t
                         }, e
                     }
                 }
             }
-            var Be, Ie, Ue, qe, We, He = {
+            var Ie, je, Ue, qe, We, He = {
                     "-": "",
                     _: " ",
                     0: "0"
                 },
                 Xe = /^\s*\d+/,
-                Je = /^%/,
-                Ge = /[\\^$*+?|[\]().{}]/g;
+                Ge = /^%/,
+                Je = /[\\^$*+?|[\]().{}]/g;
 
-            function $e(t, e, n) {
+            function Ze(t, e, n) {
                 var i = t < 0 ? "-" : "",
                     r = (i ? -t : t) + "",
                     o = r.length;
                 return i + (o < n ? new Array(n - o + 1).join(e) + r : r)
             }
 
-            function Ze(t) {
-                return t.replace(Ge, "\\$&")
+            function $e(t) {
+                return t.replace(Je, "\\$&")
             }
 
             function Ye(t) {
-                return new RegExp("^(?:" + t.map(Ze).join("|") + ")", "i")
+                return new RegExp("^(?:" + t.map($e).join("|") + ")", "i")
             }
 
             function Ve(t) {
                 return new Map(t.map(((t, e) => [t.toLowerCase(), e])))
             }
 
             function Ke(t, e, n) {
@@ -21303,189 +21415,189 @@
 
             function mn(t, e, n) {
                 var i = Xe.exec(e.slice(n, n + 6));
                 return i ? (t.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1
             }
 
             function gn(t, e, n) {
-                var i = Je.exec(e.slice(n, n + 1));
+                var i = Ge.exec(e.slice(n, n + 1));
                 return i ? n + i[0].length : -1
             }
 
             function vn(t, e, n) {
                 var i = Xe.exec(e.slice(n));
                 return i ? (t.Q = +i[0], n + i[0].length) : -1
             }
 
             function yn(t, e, n) {
                 var i = Xe.exec(e.slice(n));
                 return i ? (t.s = +i[0], n + i[0].length) : -1
             }
 
             function bn(t, e) {
-                return $e(t.getDate(), e, 2)
+                return Ze(t.getDate(), e, 2)
             }
 
             function xn(t, e) {
-                return $e(t.getHours(), e, 2)
+                return Ze(t.getHours(), e, 2)
             }
 
             function _n(t, e) {
-                return $e(t.getHours() % 12 || 12, e, 2)
+                return Ze(t.getHours() % 12 || 12, e, 2)
             }
 
             function wn(t, e) {
-                return $e(1 + Y.count(mt(t), t), e, 3)
+                return Ze(1 + Y.count(mt(t), t), e, 3)
             }
 
             function kn(t, e) {
-                return $e(t.getMilliseconds(), e, 3)
+                return Ze(t.getMilliseconds(), e, 3)
             }
 
             function En(t, e) {
                 return kn(t, e) + "000"
             }
 
-            function Dn(t, e) {
-                return $e(t.getMonth() + 1, e, 2)
+            function An(t, e) {
+                return Ze(t.getMonth() + 1, e, 2)
             }
 
-            function An(t, e) {
-                return $e(t.getMinutes(), e, 2)
+            function Dn(t, e) {
+                return Ze(t.getMinutes(), e, 2)
             }
 
             function Sn(t, e) {
-                return $e(t.getSeconds(), e, 2)
+                return Ze(t.getSeconds(), e, 2)
             }
 
             function Cn(t) {
                 var e = t.getDay();
                 return 0 === e ? 7 : e
             }
 
-            function Fn(t, e) {
-                return $e(tt.count(mt(t) - 1, t), e, 2)
+            function Mn(t, e) {
+                return Ze(tt.count(mt(t) - 1, t), e, 2)
             }
 
-            function Mn(t) {
+            function Fn(t) {
                 var e = t.getDay();
                 return e >= 4 || 0 === e ? rt(t) : rt.ceil(t)
             }
 
             function On(t, e) {
-                return t = Mn(t), $e(rt.count(mt(t), t) + (4 === mt(t).getDay()), e, 2)
+                return t = Fn(t), Ze(rt.count(mt(t), t) + (4 === mt(t).getDay()), e, 2)
             }
 
             function Tn(t) {
                 return t.getDay()
             }
 
             function Nn(t, e) {
-                return $e(et.count(mt(t) - 1, t), e, 2)
+                return Ze(et.count(mt(t) - 1, t), e, 2)
             }
 
-            function zn(t, e) {
-                return $e(t.getFullYear() % 100, e, 2)
+            function Rn(t, e) {
+                return Ze(t.getFullYear() % 100, e, 2)
             }
 
-            function Rn(t, e) {
-                return $e((t = Mn(t)).getFullYear() % 100, e, 2)
+            function zn(t, e) {
+                return Ze((t = Fn(t)).getFullYear() % 100, e, 2)
             }
 
             function Pn(t, e) {
-                return $e(t.getFullYear() % 1e4, e, 4)
+                return Ze(t.getFullYear() % 1e4, e, 4)
             }
 
             function Ln(t, e) {
                 var n = t.getDay();
-                return $e((t = n >= 4 || 0 === n ? rt(t) : rt.ceil(t)).getFullYear() % 1e4, e, 4)
+                return Ze((t = n >= 4 || 0 === n ? rt(t) : rt.ceil(t)).getFullYear() % 1e4, e, 4)
             }
 
-            function jn(t) {
+            function Bn(t) {
                 var e = t.getTimezoneOffset();
-                return (e > 0 ? "-" : (e *= -1, "+")) + $e(e / 60 | 0, "0", 2) + $e(e % 60, "0", 2)
+                return (e > 0 ? "-" : (e *= -1, "+")) + Ze(e / 60 | 0, "0", 2) + Ze(e % 60, "0", 2)
             }
 
-            function Bn(t, e) {
-                return $e(t.getUTCDate(), e, 2)
+            function In(t, e) {
+                return Ze(t.getUTCDate(), e, 2)
             }
 
-            function In(t, e) {
-                return $e(t.getUTCHours(), e, 2)
+            function jn(t, e) {
+                return Ze(t.getUTCHours(), e, 2)
             }
 
             function Un(t, e) {
-                return $e(t.getUTCHours() % 12 || 12, e, 2)
+                return Ze(t.getUTCHours() % 12 || 12, e, 2)
             }
 
             function qn(t, e) {
-                return $e(1 + V.count(gt(t), t), e, 3)
+                return Ze(1 + V.count(gt(t), t), e, 3)
             }
 
             function Wn(t, e) {
-                return $e(t.getUTCMilliseconds(), e, 3)
+                return Ze(t.getUTCMilliseconds(), e, 3)
             }
 
             function Hn(t, e) {
                 return Wn(t, e) + "000"
             }
 
             function Xn(t, e) {
-                return $e(t.getUTCMonth() + 1, e, 2)
+                return Ze(t.getUTCMonth() + 1, e, 2)
             }
 
-            function Jn(t, e) {
-                return $e(t.getUTCMinutes(), e, 2)
+            function Gn(t, e) {
+                return Ze(t.getUTCMinutes(), e, 2)
             }
 
-            function Gn(t, e) {
-                return $e(t.getUTCSeconds(), e, 2)
+            function Jn(t, e) {
+                return Ze(t.getUTCSeconds(), e, 2)
             }
 
-            function $n(t) {
+            function Zn(t) {
                 var e = t.getUTCDay();
                 return 0 === e ? 7 : e
             }
 
-            function Zn(t, e) {
-                return $e(ct.count(gt(t) - 1, t), e, 2)
+            function $n(t, e) {
+                return Ze(ct.count(gt(t) - 1, t), e, 2)
             }
 
             function Yn(t) {
                 var e = t.getUTCDay();
                 return e >= 4 || 0 === e ? dt(t) : dt.ceil(t)
             }
 
             function Vn(t, e) {
-                return t = Yn(t), $e(dt.count(gt(t), t) + (4 === gt(t).getUTCDay()), e, 2)
+                return t = Yn(t), Ze(dt.count(gt(t), t) + (4 === gt(t).getUTCDay()), e, 2)
             }
 
             function Kn(t) {
                 return t.getUTCDay()
             }
 
             function Qn(t, e) {
-                return $e(lt.count(gt(t) - 1, t), e, 2)
+                return Ze(lt.count(gt(t) - 1, t), e, 2)
             }
 
             function ti(t, e) {
-                return $e(t.getUTCFullYear() % 100, e, 2)
+                return Ze(t.getUTCFullYear() % 100, e, 2)
             }
 
             function ei(t, e) {
-                return $e((t = Yn(t)).getUTCFullYear() % 100, e, 2)
+                return Ze((t = Yn(t)).getUTCFullYear() % 100, e, 2)
             }
 
             function ni(t, e) {
-                return $e(t.getUTCFullYear() % 1e4, e, 4)
+                return Ze(t.getUTCFullYear() % 1e4, e, 4)
             }
 
             function ii(t, e) {
                 var n = t.getUTCDay();
-                return $e((t = n >= 4 || 0 === n ? dt(t) : dt.ceil(t)).getUTCFullYear() % 1e4, e, 4)
+                return Ze((t = n >= 4 || 0 === n ? dt(t) : dt.ceil(t)).getUTCFullYear() % 1e4, e, 4)
             }
 
             function ri() {
                 return "+0000"
             }
 
             function oi() {
@@ -21508,15 +21620,15 @@
             function li(t) {
                 const e = ci(t.format),
                     n = t.formatPrefix;
                 return {
                     format: e,
                     formatPrefix: n,
                     formatFloat(t) {
-                        const n = (0, z.Z)(t || ",");
+                        const n = (0, R.Z)(t || ",");
                         if (null == n.precision) {
                             switch (n.precision = 12, n.type) {
                                 case "%":
                                     n.precision -= 2;
                                     break;
                                 case "e":
                                     n.precision -= 1
@@ -21539,21 +21651,21 @@
                                     } return e.slice(0, o) + a
                             }
                         }
                         return e(n);
                         var i, r
                     },
                     formatSpan(t, i, r, o) {
-                        o = (0, z.Z)(null == o ? ",f" : o);
+                        o = (0, R.Z)(null == o ? ",f" : o);
                         const a = (0, N.ly)(t, i, r),
                             s = Math.max(Math.abs(t), Math.abs(i));
                         let c;
                         if (null == o.precision) switch (o.type) {
                             case "s":
-                                return isNaN(c = (0, R.Z)(a, s)) || (o.precision = c), n(o, s);
+                                return isNaN(c = (0, z.Z)(a, s)) || (o.precision = c), n(o, s);
                             case "":
                             case "e":
                             case "g":
                             case "p":
                             case "r":
                                 isNaN(c = (0, P.Z)(a, s)) || (o.precision = c - ("e" === o.type));
                                 break;
@@ -21565,46 +21677,46 @@
                     }
                 }
             }
             let ui, fi;
 
             function di() {
                 return ui = li({
-                    format: j.WU,
-                    formatPrefix: j.jH
+                    format: B.WU,
+                    formatPrefix: B.jH
                 })
             }
 
             function hi(t) {
-                return li((0, B.Z)(t))
+                return li((0, I.Z)(t))
             }
 
             function pi(t) {
                 return arguments.length ? ui = hi(t) : ui
             }
 
             function mi(t, e, n) {
                 n = n || {}, (0, m.Kn)(n) || (0, m.vU)("Invalid time multi-format specifier: ".concat(n));
-                const i = e(Rt),
-                    r = e(zt),
+                const i = e(zt),
+                    r = e(Rt),
                     o = e(Nt),
-                    a = e(Mt),
-                    s = e(Ft),
+                    a = e(Ft),
+                    s = e(Mt),
                     c = e(Ct),
                     l = e(St),
-                    u = e(At),
+                    u = e(Dt),
                     f = t(n[Pt] || ".%L"),
-                    d = t(n[Rt] || ":%S"),
-                    h = t(n[zt] || "%I:%M"),
+                    d = t(n[zt] || ":%S"),
+                    h = t(n[Rt] || "%I:%M"),
                     p = t(n[Nt] || "%I %p"),
-                    g = t(n[Mt] || n[Ot] || "%a %d"),
-                    v = t(n[Ft] || "%b %d"),
+                    g = t(n[Ft] || n[Ot] || "%a %d"),
+                    v = t(n[Mt] || "%b %d"),
                     y = t(n[Ct] || "%B"),
                     b = t(n[St] || "%B"),
-                    x = t(n[At] || "%Y");
+                    x = t(n[Dt] || "%Y");
                 return t => (i(t) < t ? f : r(t) < t ? d : o(t) < t ? h : a(t) < t ? p : c(t) < t ? s(t) < t ? g : v : u(t) < t ? l(t) < t ? y : b : x)(t)
             }
 
             function gi(t) {
                 const e = ci(t.format),
                     n = ci(t.utcFormat);
                 return {
@@ -21613,29 +21725,29 @@
                     timeParse: ci(t.parse),
                     utcParse: ci(t.utcParse)
                 }
             }
 
             function vi() {
                 return fi = gi({
-                    format: Ie,
+                    format: je,
                     parse: Ue,
                     utcFormat: qe,
                     utcParse: We
                 })
             }
 
             function yi(t) {
-                return gi(je(t))
+                return gi(Be(t))
             }
 
             function bi(t) {
                 return arguments.length ? fi = yi(t) : fi
             }! function(t) {
-                Be = je(t), Ie = Be.format, Ue = Be.parse, qe = Be.utcFormat, We = Be.utcParse
+                Ie = Be(t), je = Ie.format, Ue = Ie.parse, qe = Ie.utcFormat, We = Ie.utcParse
             }({
                 dateTime: "%x, %X",
                 date: "%-m/%-d/%Y",
                 time: "%-I:%M:%S %p",
                 periods: ["AM", "PM"],
                 days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                 shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
@@ -21655,38 +21767,38 @@
                 return n && 2 !== n && (0, m.vU)("defaultLocale expects either zero or two arguments."), n ? xi(pi(t), bi(e)) : xi(pi(), bi())
             }
 
             function ki() {
                 return di(), vi(), wi()
             }
             const Ei = /^(data:|([A-Za-z]+:)?\/\/)/,
-                Di = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
-                Ai = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
+                Ai = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
+                Di = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
                 Si = "file://";
             async function Ci(t, e) {
                 const n = await this.sanitize(t, e),
                     i = n.href;
                 return n.localFile ? this.file(i) : this.http(i, e)
             }
-            async function Fi(t, e) {
+            async function Mi(t, e) {
                 e = (0, m.l7)({}, this.options, e);
                 const n = this.fileAccess,
                     i = {
                         href: null
                     };
                 let r, o, a;
-                const s = Di.test(t.replace(Ai, ""));
+                const s = Ai.test(t.replace(Di, ""));
                 null != t && "string" === typeof t && s || (0, m.vU)("Sanitize failure, invalid URI: " + (0, m.m8)(t));
                 const c = Ei.test(t);
                 return (a = e.baseURL) && !c && (t.startsWith("/") || a.endsWith("/") || (t = "/" + t), t = a + t), o = (r = t.startsWith(Si)) || "file" === e.mode || "http" !== e.mode && !c && n, r ? t = t.slice(Si.length) : t.startsWith("//") && ("file" === e.defaultProtocol ? (t = t.slice(2), o = !0) : t = (e.defaultProtocol || "http") + ":" + t), Object.defineProperty(i, "localFile", {
                     value: !!o
                 }), i.href = t, e.target && (i.target = e.target + ""), e.rel && (i.rel = e.rel + ""), "image" === e.context && e.crossOrigin && (i.crossOrigin = e.crossOrigin + ""), i
             }
 
-            function Mi(t) {
+            function Fi(t) {
                 return t ? e => new Promise(((n, i) => {
                     t.readFile(e, ((t, e) => {
                         t ? i(t) : n(e)
                     }))
                 })) : Oi
             }
             async function Oi() {
@@ -21700,54 +21812,54 @@
                         o = await t(e, i);
                     return o.ok ? (0, m.mf)(o[r]) ? o[r]() : o.text() : (0, m.vU)(o.status + "" + o.statusText)
                 }: Ni
             }
             async function Ni() {
                 (0, m.vU)("No HTTP fetch method available.")
             }
-            const zi = t => null != t && t === t,
-                Ri = t => !Number.isNaN(+t) && !(t instanceof Date),
+            const Ri = t => null != t && t === t,
+                zi = t => !Number.isNaN(+t) && !(t instanceof Date),
                 Pi = {
                     boolean: m.sw,
                     integer: m.He,
                     number: m.He,
                     date: m.ZU,
                     string: m.BB,
                     unknown: m.yR
                 },
-                Li = [t => "true" === t || "false" === t || !0 === t || !1 === t, t => Ri(t) && Number.isInteger(+t), Ri, t => !Number.isNaN(Date.parse(t))],
-                ji = ["boolean", "integer", "number", "date"];
+                Li = [t => "true" === t || "false" === t || !0 === t || !1 === t, t => zi(t) && Number.isInteger(+t), zi, t => !Number.isNaN(Date.parse(t))],
+                Bi = ["boolean", "integer", "number", "date"];
 
-            function Bi(t, e) {
+            function Ii(t, e) {
                 if (!t || !t.length) return "unknown";
                 const n = t.length,
                     i = Li.length,
                     r = Li.map(((t, e) => e + 1));
                 for (let o, a, s = 0, c = 0; s < n; ++s)
                     for (a = e ? t[s][e] : t[s], o = 0; o < i; ++o)
-                        if (r[o] && zi(a) && !Li[o](a) && (r[o] = 0, ++c, c === Li.length)) return "string";
-                return ji[r.reduce(((t, e) => 0 === t ? e : t), 0) - 1]
+                        if (r[o] && Ri(a) && !Li[o](a) && (r[o] = 0, ++c, c === Li.length)) return "string";
+                return Bi[r.reduce(((t, e) => 0 === t ? e : t), 0) - 1]
             }
 
-            function Ii(t, e) {
-                return e.reduce(((e, n) => (e[n] = Bi(t, n), e)), {})
+            function ji(t, e) {
+                return e.reduce(((e, n) => (e[n] = Ii(t, n), e)), {})
             }
 
             function Ui(t) {
                 const e = function(e, n) {
                     const i = {
                         delimiter: t
                     };
                     return qi(e, n ? (0, m.l7)(n, i) : i)
                 };
                 return e.responseType = "text", e
             }
 
             function qi(t, e) {
-                return e.header && (t = e.header.map(m.m8).join(e.delimiter) + "\n" + t), D(e.delimiter).parse(t + "")
+                return e.header && (t = e.header.map(m.m8).join(e.delimiter) + "\n" + t), A(e.delimiter).parse(t + "")
             }
 
             function Wi(t, e) {
                 const n = e && e.property ? (0, m.EP)(e.property) : m.yR;
                 return !(0, m.Kn)(t) || (i = t, "function" === typeof Buffer && (0, m.mf)(Buffer.isBuffer) && Buffer.isBuffer(i)) ? n(JSON.parse(t)) : function(t, e) {
                     !(0, m.kJ)(t) && (0, m.TW)(t) && (t = [...t]);
                     return e && e.copy ? JSON.parse(JSON.stringify(t)) : t
@@ -21761,39 +21873,39 @@
             };
 
             function Xi(t, e) {
                 let n, i, r, o;
                 return t = Wi(t, e), e && e.feature ? (n = S, r = e.feature) : e && e.mesh ? (n = O, r = e.mesh, o = Hi[e.filter]) : (0, m.vU)("Missing TopoJSON feature or mesh parameter."), i = (i = t.objects[r]) ? n(t, i, o) : (0, m.vU)("Invalid TopoJSON object: " + r), i && i.features || [i]
             }
             Xi.responseType = "json";
-            const Ji = {
+            const Gi = {
                 dsv: qi,
                 csv: Ui(","),
                 tsv: Ui("\t"),
                 json: Wi,
                 topojson: Xi
             };
 
-            function Gi(t, e) {
-                return arguments.length > 1 ? (Ji[t] = e, this) : (0, m.nr)(Ji, t) ? Ji[t] : null
+            function Ji(t, e) {
+                return arguments.length > 1 ? (Gi[t] = e, this) : (0, m.nr)(Gi, t) ? Gi[t] : null
             }
 
-            function $i(t) {
-                const e = Gi(t);
+            function Zi(t) {
+                const e = Ji(t);
                 return e && e.responseType || "text"
             }
 
-            function Zi(t, e, n, i) {
-                const r = Gi((e = e || {}).type || "json");
+            function $i(t, e, n, i) {
+                const r = Ji((e = e || {}).type || "json");
                 return r || (0, m.vU)("Unknown data format type: " + e.type), t = r(t, e), e.parse && function(t, e, n, i) {
                     if (!t.length) return;
                     const r = bi();
                     n = n || r.timeParse, i = i || r.utcParse;
                     let o, a, s, c, l, u, f = t.columns || Object.keys(t[0]);
-                    "auto" === e && (e = Ii(t, f));
+                    "auto" === e && (e = ji(t, f));
                     f = Object.keys(e);
                     const d = f.map((t => {
                         const r = e[t];
                         let o, a;
                         if (r && (r.startsWith("date:") || r.startsWith("utc:"))) {
                             o = r.split(/:(.+)?/, 2), a = o[1], ("'" === a[0] && "'" === a[a.length - 1] || '"' === a[0] && '"' === a[a.length - 1]) && (a = a.slice(1, -1));
                             return ("utc" === o[0] ? i : n)(a)
@@ -21804,18 +21916,18 @@
                     for (s = 0, l = t.length, u = f.length; s < l; ++s)
                         for (o = t[s], c = 0; c < u; ++c) a = f[c], o[a] = d[c](o[a])
                 }(t, e.parse, n, i), (0, m.nr)(t, "columns") && delete t.columns, t
             }
             const Yi = function(t, e) {
                 return n => ({
                     options: n || {},
-                    sanitize: Fi,
+                    sanitize: Mi,
                     load: Ci,
                     fileAccess: !!e,
-                    file: Mi(e),
+                    file: Fi(e),
                     http: Ti(t)
                 })
             }("undefined" !== typeof fetch && fetch, null);
 
             function Vi(t) {
                 const e = t || m.yR,
                     n = [],
@@ -22160,20 +22272,20 @@
             }
             const kr = {};
 
             function Er(t, e, n) {
                 this.dataflow = t, this.stamp = null == e ? -1 : e, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null
             }
 
-            function Dr(t, e) {
+            function Ar(t, e) {
                 const n = [];
                 return (0, m.FP)(t, e, (t => n.push(t))), n
             }
 
-            function Ar(t, e) {
+            function Dr(t, e) {
                 const n = {};
                 return t.visit(e, (t => {
                     n[nr(t)] = 1
                 })), t => n[nr(t)] ? null : t
             }
 
             function Sr(t, e) {
@@ -22190,15 +22302,15 @@
                             const t = r.fields || (r.fields = {});
                             for (const e in a.fields) t[e] = 1
                         }
                         a.changed(r.ADD) && (o |= r.ADD), a.changed(r.REM) && (o |= r.REM), a.changed(r.MOD) && (o |= r.MOD)
                     } this.changes = o
             }
 
-            function Fr(t) {
+            function Mr(t) {
                 return t.error("Dataflow already running. Use runAsync() to chain invocations."), t
             }
             Er.prototype = {
                 StopPropagation: kr,
                 ADD: 1,
                 REM: 2,
                 MOD: 4,
@@ -22231,15 +22343,15 @@
                     const e = t || 7;
                     return 1 & e && this.add.length || 2 & e && this.rem.length || 4 & e && this.mod.length
                 },
                 reflow(t) {
                     if (t) return this.fork(7).reflow();
                     const e = this.add.length,
                         n = this.source && this.source.length;
-                    return n && n !== e && (this.mod = this.source, e && this.filter(4, Ar(this, 1))), this
+                    return n && n !== e && (this.mod = this.source, e && this.filter(4, Dr(this, 1))), this
                 },
                 clean(t) {
                     return arguments.length ? (this.cleans = !!t, this) : this.cleans
                 },
                 modifies(t) {
                     const e = this.fields || (this.fields = {});
                     return (0, m.kJ)(t) ? t.forEach((t => e[t] = !0)) : e[t] = !0, this
@@ -22250,25 +22362,25 @@
                 },
                 filter(t, e) {
                     const n = this;
                     return 1 & t && (n.addF = Sr(n.addF, e)), 2 & t && (n.remF = Sr(n.remF, e)), 4 & t && (n.modF = Sr(n.modF, e)), 16 & t && (n.srcF = Sr(n.srcF, e)), n
                 },
                 materialize(t) {
                     const e = this;
-                    return 1 & (t = t || 7) && e.addF && (e.add = Dr(e.add, e.addF), e.addF = null), 2 & t && e.remF && (e.rem = Dr(e.rem, e.remF), e.remF = null), 4 & t && e.modF && (e.mod = Dr(e.mod, e.modF), e.modF = null), 16 & t && e.srcF && (e.source = e.source.filter(e.srcF), e.srcF = null), e
+                    return 1 & (t = t || 7) && e.addF && (e.add = Ar(e.add, e.addF), e.addF = null), 2 & t && e.remF && (e.rem = Ar(e.rem, e.remF), e.remF = null), 4 & t && e.modF && (e.mod = Ar(e.mod, e.modF), e.modF = null), 16 & t && e.srcF && (e.source = e.source.filter(e.srcF), e.srcF = null), e
                 },
                 visit(t, e) {
                     const n = this,
                         i = e;
                     if (16 & t) return (0, m.FP)(n.source, n.srcF, i), n;
                     1 & t && (0, m.FP)(n.add, n.addF, i), 2 & t && (0, m.FP)(n.rem, n.remF, i), 4 & t && (0, m.FP)(n.mod, n.modF, i);
                     const r = n.source;
                     if (8 & t && r) {
                         const t = n.add.length + n.mod.length;
-                        t === r.length || (t ? (0, m.FP)(r, Ar(n, 5), i) : (0, m.FP)(r, n.srcF, i))
+                        t === r.length || (t ? (0, m.FP)(r, Dr(n, 5), i) : (0, m.FP)(r, n.srcF, i))
                     }
                     return n
                 }
             }, (0, m.XW)(Cr, Er, {
                 fork(t) {
                     const e = new Er(this.dataflow).init(this, t & this.NO_FIELDS);
                     return void 0 !== t && (t & e.ADD && this.visit(e.ADD, (t => e.add.push(t))), t & e.REM && this.visit(e.REM, (t => e.rem.push(t))), t & e.MOD && this.visit(e.MOD, (t => e.mod.push(t)))), e
@@ -22295,15 +22407,15 @@
                     if (t & n.SOURCE)
                         for (; o < r; ++o) i[o].visit(t, e);
                     else
                         for (; o < r; ++o) i[o].stamp === n.stamp && i[o].visit(t, e);
                     return n
                 }
             });
-            const Mr = {
+            const Fr = {
                 skip: !1,
                 force: !1
             };
 
             function Or(t) {
                 let e = [];
                 return {
@@ -22337,21 +22449,21 @@
                 this.logger((0, m.kg)()), this.logLevel(m.jj), this._clock = 0, this._rank = 0, this._locale = wi();
                 try {
                     this._loader = Yi()
                 } catch (t) {}
                 this._touched = Vi(m.id), this._input = {}, this._pulse = null, this._heap = Or(((t, e) => t.qrank - e.qrank)), this._postrun = []
             }
 
-            function zr(t) {
+            function Rr(t) {
                 return function() {
                     return this._log[t].apply(this, arguments)
                 }
             }
 
-            function Rr(t, e) {
+            function zr(t, e) {
                 mr.call(this, t, null, e)
             }
             Nr.prototype = {
                 stamp() {
                     return this._clock
                 },
                 loader(t) {
@@ -22359,19 +22471,19 @@
                 },
                 locale(t) {
                     return arguments.length ? (this._locale = t, this) : this._locale
                 },
                 logger(t) {
                     return arguments.length ? (this._log = t, this) : this._log
                 },
-                error: zr("error"),
-                warn: zr("warn"),
-                info: zr("info"),
-                debug: zr("debug"),
-                logLevel: zr("level"),
+                error: Rr("error"),
+                warn: Rr("warn"),
+                info: Rr("info"),
+                debug: Rr("debug"),
+                logLevel: Rr("level"),
                 cleanThreshold: 1e4,
                 add: function(t, e, n, i) {
                     let r, o = 1;
                     return t instanceof mr ? r = t : t && t.prototype instanceof mr ? r = new t : (0, m.mf)(t) ? r = new mr(null, t) : (o = 0, r = new mr(t, e)), this.rank(r), o && (i = n, n = e), n && this.connect(r, r.parameters(n, i)), this.touch(r), r
                 },
                 connect: function(t, e) {
                     const n = t.rank,
@@ -22386,34 +22498,34 @@
                     const e = [t];
                     let n, i, r;
                     for (; e.length;)
                         if (this.rank(n = e.pop()), i = n._targets)
                             for (r = i.length; --r >= 0;) e.push(n = i[r]), n === t && (0, m.vU)("Cycle detected in dataflow graph.")
                 },
                 pulse: function(t, e, n) {
-                    this.touch(t, n || Mr);
+                    this.touch(t, n || Fr);
                     const i = new Er(this, this._clock + (this._pulse ? 0 : 1)),
                         r = t.pulse && t.pulse.source || [];
                     return i.target = t, this._input[t.id] = e.pulse(i, r), this
                 },
                 touch: function(t, e) {
-                    const n = e || Mr;
+                    const n = e || Fr;
                     return this._pulse ? this._enqueue(t) : this._touched.add(t), n.skip && t.skip(!0), this
                 },
                 update: function(t, e, n) {
-                    const i = n || Mr;
+                    const i = n || Fr;
                     return (t.set(e) || i.force) && this.touch(t, i), this
                 },
                 changeset: ur,
                 ingest: function(t, e, n) {
                     return e = this.parse(e, n), this.pulse(t, this.changeset().insert(e))
                 },
                 parse: function(t, e) {
                     const n = this.locale();
-                    return Zi(t, e, n.timeParse, n.utcParse)
+                    return $i(t, e, n.timeParse, n.utcParse)
                 },
                 preload: async function(t, e, n) {
                     const i = this,
                         r = i._pending || function(t) {
                             let e;
                             const n = new Promise((t => e = t));
                             return n.requests = 0, n.done = () => {
@@ -22426,15 +22538,15 @@
                 },
                 request: async function(t, e) {
                     const n = this;
                     let i, r = 0;
                     try {
                         i = await n.loader().load(t, {
                             context: "dataflow",
-                            response: $i(e && e.type)
+                            response: Zi(e && e.type)
                         });
                         try {
                             i = n.parse(i, e)
                         } catch (o) {
                             r = -2, n.warn("Data ingestion failed", t, o)
                         }
                     } catch (o) {
@@ -22466,15 +22578,15 @@
                 },
                 on: function(t, e, n, i, r) {
                     return (t instanceof mr ? wr : _r)(this, t, e, n, i, r), this
                 },
                 evaluate: async function(t, e, n) {
                     const i = this,
                         r = [];
-                    if (i._pulse) return Fr(i);
+                    if (i._pulse) return Mr(i);
                     if (i._pending && await i._pending, e && await Ki(i, e), !i._touched.length) return i.debug("Dataflow invoked, but nothing to do."), i;
                     const o = ++i._clock;
                     i._pulse = new Er(i, o, t), i._touched.forEach((t => i._enqueue(t, !0))), i._touched = Vi(m.id);
                     let a, s, c, l = 0;
                     try {
                         for (; i._heap.size() > 0;) a = i._heap.pop(), a.rank === a.qrank ? (s = a.run(i._getPulse(a, t)), s.then ? s = await s : s.async && (r.push(s.async), s = kr), s !== kr && a._targets && a._targets.forEach((t => i._enqueue(t))), ++l) : i._enqueue(a, !0)
                     } catch (u) {
@@ -22492,15 +22604,15 @@
                             } catch (u) {
                                 i.error(u)
                             }
                         }))
                     })))), i
                 },
                 run: function(t, e, n) {
-                    return this._pulse ? Fr(this) : (this.evaluate(t, e, n), this)
+                    return this._pulse ? Mr(this) : (this.evaluate(t, e, n), this)
                 },
                 runAsync: async function(t, e, n) {
                     for (; this._running;) await this._running;
                     const i = () => this._running = null;
                     return (this._running = this.evaluate(t, e, n)).then(i, i), this._running
                 },
                 runAfter: function(t, e, n) {
@@ -22523,15 +22635,15 @@
                         i = this._clock;
                     return n && (0, m.kJ)(n) ? new Cr(this, i, n.map((t => t.pulse)), e) : this._input[t.id] || function(t, e) {
                         if (e && e.stamp === t.stamp) return e;
                         t = t.fork(), e && e !== kr && (t.source = e.source);
                         return t
                     }(this._pulse, n && n.pulse)
                 }
-            }, (0, m.XW)(Rr, mr, {
+            }, (0, m.XW)(zr, mr, {
                 run(t) {
                     if (t.stamp < this.stamp) return t.StopPropagation;
                     let e;
                     return this.skip() ? this.skip(!1) : e = this.evaluate(t), e = e || t, e.then ? e = e.then((t => this.pulse = t)) : e !== t.StopPropagation && (this.pulse = e), e
                 },
                 evaluate(t) {
                     const e = this.marshall(t.stamp),
@@ -22539,53 +22651,53 @@
                     return e.clear(), n
                 },
                 transform() {}
             });
             const Pr = {};
 
             function Lr(t) {
-                const e = jr(t);
+                const e = Br(t);
                 return e && e.Definition || null
             }
 
-            function jr(t) {
+            function Br(t) {
                 return t = t && t.toLowerCase(), (0, m.nr)(Pr, t) ? Pr[t] : null
             }
-            var Br = n(94319),
-                Ir = n(88643),
+            var Ir = n(94319),
+                jr = n(88643),
                 Ur = n(26379),
                 qr = n(88048);
 
             function* Wr(t, e) {
                 if (null == e)
                     for (let n of t) null != n && "" !== n && (n = +n) >= n && (yield n);
                 else {
                     let n = -1;
                     for (let i of t) i = e(i, ++n, t), null != i && "" !== i && (i = +i) >= i && (yield i)
                 }
             }
 
             function Hr(t, e, n) {
                 const i = Float64Array.from(Wr(t, n));
-                return i.sort(Br.Z), e.map((t => (0, Ir.s7)(i, t)))
+                return i.sort(Ir.Z), e.map((t => (0, jr.s7)(i, t)))
             }
 
             function Xr(t, e) {
                 return Hr(t, [.25, .5, .75], e)
             }
 
-            function Jr(t, e) {
+            function Gr(t, e) {
                 const n = t.length,
                     i = (0, Ur.Z)(t, e),
                     r = Xr(t, e),
                     o = (r[2] - r[0]) / 1.34;
                 return 1.06 * (Math.min(i, o) || i || Math.abs(r[0]) || 1) * Math.pow(n, -.2)
             }
 
-            function Gr(t) {
+            function Jr(t) {
                 const e = t.maxbins || 20,
                     n = t.base || 10,
                     i = Math.log(n),
                     r = t.divide || [5, 2];
                 let o, a, s, c, l, u, f = t.extent[0],
                     d = t.extent[1];
                 const h = t.span || d - f || Math.abs(f) || 1;
@@ -22602,31 +22714,31 @@
                     m = Math.pow(n, -p - 1);
                 return (t.nice || void 0 === t.nice) && (c = Math.floor(f / o + m) * o, f = f < c ? c - o : c, d = Math.ceil(d / o) * o), {
                     start: f,
                     stop: d === f ? f + o : d,
                     step: o
                 }
             }
-            var $r = Math.random;
+            var Zr = Math.random;
 
-            function Zr(t) {
-                $r = t
+            function $r(t) {
+                Zr = t
             }
 
             function Yr(t, e, n, i) {
                 if (!t.length) return [void 0, void 0];
                 const r = Float64Array.from(Wr(t, i)),
                     o = r.length,
                     a = e;
                 let s, c, l, u;
                 for (l = 0, u = Array(a); l < a; ++l) {
-                    for (s = 0, c = 0; c < o; ++c) s += r[~~($r() * o)];
+                    for (s = 0, c = 0; c < o; ++c) s += r[~~(Zr() * o)];
                     u[l] = s / o
                 }
-                return u.sort(Br.Z), [(0, Ir.ZP)(u, n / 2), (0, Ir.ZP)(u, 1 - n / 2)]
+                return u.sort(Ir.Z), [(0, jr.ZP)(u, n / 2), (0, jr.ZP)(u, 1 - n / 2)]
             }
 
             function Vr(t, e, n, i) {
                 i = i || (t => t);
                 const r = t.length,
                     o = new Float64Array(r);
                 let a, s = 0,
@@ -22671,15 +22783,15 @@
                 const o = {
                     min(t) {
                         return arguments.length ? (n = t || 0, r = i - n, o) : n
                     },
                     max(t) {
                         return arguments.length ? (i = t || 0, r = i - n, o) : i
                     },
-                    sample: () => n + Math.floor(r * $r()),
+                    sample: () => n + Math.floor(r * Zr()),
                     pdf: t => t === Math.floor(t) && t >= n && t < i ? 1 / r : 0,
                     cdf(t) {
                         const e = Math.floor(t);
                         return e < n ? 0 : e >= i ? 1 : (e - n + 1) / r
                     },
                     icdf: t => t >= 0 && t <= 1 ? n - 1 + Math.floor(t * r) : NaN
                 };
@@ -22692,15 +22804,15 @@
             function io(t, e) {
                 t = t || 0, e = null == e ? 1 : e;
                 let n, i, r = 0,
                     o = 0;
                 if (no === no) r = no, no = NaN;
                 else {
                     do {
-                        r = 2 * $r() - 1, o = 2 * $r() - 1, n = r * r + o * o
+                        r = 2 * Zr() - 1, o = 2 * Zr() - 1, n = r * r + o * o
                     } while (0 === n || n > 1);
                     i = Math.sqrt(-2 * Math.log(n) / n), r *= i, no = o * i
                 }
                 return t + r * e
             }
 
             function ro(t, e, n) {
@@ -22750,17 +22862,17 @@
                 const n = so();
                 let i = 0;
                 const r = {
                     data(n) {
                         return arguments.length ? (t = n, i = n ? n.length : 0, r.bandwidth(e)) : t
                     },
                     bandwidth(n) {
-                        return arguments.length ? (!(e = n) && t && (e = Jr(t)), r) : e
+                        return arguments.length ? (!(e = n) && t && (e = Gr(t)), r) : e
                     },
-                    sample: () => t[~~($r() * i)] + e * n.sample(),
+                    sample: () => t[~~(Zr() * i)] + e * n.sample(),
                     pdf(r) {
                         let o = 0,
                             a = 0;
                         for (; a < i; ++a) o += n.pdf((r - t[a]) / e);
                         return o / e / i
                     },
                     cdf(r) {
@@ -22824,15 +22936,15 @@
                             return e
                         }(e = t || []), r) : e
                     },
                     distributions(n) {
                         return arguments.length ? (n ? (i = n.length, t = n) : (i = 0, t = []), r.weights(e)) : t
                     },
                     sample() {
-                        const e = $r();
+                        const e = Zr();
                         let r = t[i - 1],
                             o = n[0],
                             a = 0;
                         for (; a < i - 1; o += n[++a])
                             if (e < o) {
                                 r = t[a];
                                 break
@@ -22854,15 +22966,15 @@
                         throw Error("Mixture icdf not supported.")
                     }
                 };
                 return r.distributions(t).weights(e)
             }
 
             function go(t, e) {
-                return null == e && (e = null == t ? 1 : t, t = 0), t + (e - t) * $r()
+                return null == e && (e = null == t ? 1 : t, t = 0), t + (e - t) * Zr()
             }
 
             function vo(t, e, n) {
                 return null == n && (n = null == e ? 1 : e, e = 0), t >= e && t <= n ? 1 / (n - e) : 0
             }
 
             function yo(t, e, n) {
@@ -22928,39 +23040,39 @@
             }
 
             function Eo(t, e, n, i) {
                 let r, o, a = -1;
                 for (const s of t) r = e(s), o = n(s), null != r && (r = +r) >= r && null != o && (o = +o) >= o && i(r, o, ++a)
             }
 
-            function Do(t, e, n, i, r) {
+            function Ao(t, e, n, i, r) {
                 let o = 0,
                     a = 0;
                 return Eo(t, e, n, ((t, e) => {
                     const n = e - r(t),
                         s = e - i;
                     o += n * n, a += s * s
                 })), 1 - o / a
             }
 
-            function Ao(t, e, n) {
+            function Do(t, e, n) {
                 let i = 0,
                     r = 0,
                     o = 0,
                     a = 0,
                     s = 0;
                 Eo(t, e, n, ((t, e) => {
                     ++s, i += (t - i) / s, r += (e - r) / s, o += (t * e - o) / s, a += (t * t - a) / s
                 }));
                 const c = wo(i, r, o, a),
                     l = t => c[0] + c[1] * t;
                 return {
                     coef: c,
                     predict: l,
-                    rSquared: Do(t, e, n, r, l)
+                    rSquared: Ao(t, e, n, r, l)
                 }
             }
 
             function So(t, e, n) {
                 let i = 0,
                     r = 0,
                     o = 0,
@@ -22970,15 +23082,15 @@
                     ++s, t = Math.log(t), i += (t - i) / s, r += (e - r) / s, o += (t * e - o) / s, a += (t * t - a) / s
                 }));
                 const c = wo(i, r, o, a),
                     l = t => c[0] + c[1] * Math.log(t);
                 return {
                     coef: c,
                     predict: l,
-                    rSquared: Do(t, e, n, r, l)
+                    rSquared: Ao(t, e, n, r, l)
                 }
             }
 
             function Co(t, e, n) {
                 const [i, r, o, a] = ko(t, e, n);
                 let s, c, l, u = 0,
                     f = 0,
@@ -22988,19 +23100,19 @@
                 Eo(t, e, n, ((t, e) => {
                     s = i[p++], c = Math.log(e), l = s * e, u += (e * c - u) / p, f += (l - f) / p, d += (l * c - d) / p, h += (s * l - h) / p
                 }));
                 const [m, g] = wo(f / a, u / a, d / a, h / a), v = t => Math.exp(m + g * (t - o));
                 return {
                     coef: [Math.exp(m - g * o), g],
                     predict: v,
-                    rSquared: Do(t, e, n, a, v)
+                    rSquared: Ao(t, e, n, a, v)
                 }
             }
 
-            function Fo(t, e, n) {
+            function Mo(t, e, n) {
                 let i = 0,
                     r = 0,
                     o = 0,
                     a = 0,
                     s = 0,
                     c = 0;
                 Eo(t, e, n, ((t, e) => {
@@ -23009,19 +23121,19 @@
                     ++c, i += (n - i) / c, r += (l - r) / c, o += (n * l - o) / c, a += (n * n - a) / c, s += (e - s) / c
                 }));
                 const l = wo(i, r, o, a),
                     u = t => l[0] * Math.pow(t, l[1]);
                 return l[0] = Math.exp(l[0]), {
                     coef: l,
                     predict: u,
-                    rSquared: Do(t, e, n, s, u)
+                    rSquared: Ao(t, e, n, s, u)
                 }
             }
 
-            function Mo(t, e, n) {
+            function Fo(t, e, n) {
                 const [i, r, o, a] = ko(t, e, n), s = i.length;
                 let c, l, u, f, d = 0,
                     h = 0,
                     p = 0,
                     m = 0,
                     g = 0;
                 for (c = 0; c < s;) l = i[c], u = r[c++], f = l * l, d += (f - d) / c, h += (f * l - h) / c, p += (f * f - p) / c, m += (l * u - m) / c, g += (f * u - g) / c;
@@ -23030,22 +23142,22 @@
                     b = (g * d - m * h) / y,
                     x = (m * v - g * h) / y,
                     _ = -b * d,
                     w = t => b * (t -= o) * t + x * t + _ + a;
                 return {
                     coef: [_ - x * o + b * o * o + a, x - 2 * b * o, b],
                     predict: w,
-                    rSquared: Do(t, e, n, a, w)
+                    rSquared: Ao(t, e, n, a, w)
                 }
             }
 
             function Oo(t, e, n, i) {
                 if (0 === i) return _o(t, e, n);
-                if (1 === i) return Ao(t, e, n);
-                if (2 === i) return Mo(t, e, n);
+                if (1 === i) return Do(t, e, n);
+                if (2 === i) return Fo(t, e, n);
                 const [r, o, a, s] = ko(t, e, n), c = r.length, l = [], u = [], f = i + 1;
                 let d, h, p, m, g;
                 for (d = 0; d < f; ++d) {
                     for (p = 0, m = 0; p < c; ++p) m += Math.pow(r[p], d) * o[p];
                     for (l.push(m), g = new Float64Array(f), h = 0; h < f; ++h) {
                         for (p = 0, m = 0; p < c; ++p) m += Math.pow(r[p], d + h);
                         g[h] = m
@@ -23074,30 +23186,30 @@
                         let e = s + v[0] + v[1] * t + v[2] * t * t;
                         for (d = 3; d < f; ++d) e += v[d] * Math.pow(t, d);
                         return e
                     };
                 return {
                     coef: To(f, v, -a, s),
                     predict: y,
-                    rSquared: Do(t, e, n, s, y)
+                    rSquared: Ao(t, e, n, s, y)
                 }
             }
 
             function To(t, e, n, i) {
                 const r = Array(t);
                 let o, a, s, c;
                 for (o = 0; o < t; ++o) r[o] = 0;
                 for (o = t - 1; o >= 0; --o)
                     for (s = e[o], c = 1, r[o] += s, a = 1; a <= o; ++a) c *= (o + 1 - a) / a, r[o - a] += s * Math.pow(n, a) * c;
                 return r[0] += i, r
             }
             const No = 2,
-                zo = 1e-12;
+                Ro = 1e-12;
 
-            function Ro(t, e, n, i) {
+            function zo(t, e, n, i) {
                 const [r, o, a, s] = ko(t, e, n, !0), c = r.length, l = Math.max(2, ~~(i * c)), u = new Float64Array(c), f = new Float64Array(c), d = new Float64Array(c).fill(1);
                 for (let h = -1; ++h <= No;) {
                     const t = [0, l - 1];
                     for (let n = 0; n < c; ++n) {
                         const e = r[n],
                             i = t[0],
                             a = t[1],
@@ -23116,16 +23228,16 @@
                             c += a, l += s, h += i * a, p += i * s, m += n * s
                         }
                         const [v, y] = wo(l / c, h / c, p / c, m / c);
                         u[n] = v + y * e, f[n] = Math.abs(o[n] - u[n]), Lo(r, n + 1, t)
                     }
                     if (h === No) break;
                     const e = (0, qr.Z)(f);
-                    if (Math.abs(e) < zo) break;
-                    for (let n, i, r = 0; r < c; ++r) n = f[r] / (6 * e), d[r] = n >= 1 ? zo : (i = 1 - n * n) * i
+                    if (Math.abs(e) < Ro) break;
+                    for (let n, i, r = 0; r < c; ++r) n = f[r] / (6 * e), d[r] = n >= 1 ? Ro : (i = 1 - n * n) * i
                 }
                 return function(t, e, n, i) {
                     const r = t.length,
                         o = [];
                     let a, s = 0,
                         c = 0,
                         l = [];
@@ -23141,17 +23253,17 @@
             function Lo(t, e, n) {
                 const i = t[e];
                 let r = n[0],
                     o = n[1] + 1;
                 if (!(o >= t.length))
                     for (; e > r && t[o] - i <= i - t[r];) n[0] = ++r, n[1] = o, ++o
             }
-            const jo = .5 * Math.PI / 180;
+            const Bo = .5 * Math.PI / 180;
 
-            function Bo(t, e, n, i) {
+            function Io(t, e, n, i) {
                 n = n || 25, i = Math.max(n, i || 200);
                 const r = e => [e, t(e)],
                     o = e[0],
                     a = e[1],
                     s = a - o,
                     c = s / i,
                     l = [r(o)],
@@ -23173,20 +23285,20 @@
                             const t = e[o][1];
                             t < n && (n = t), t > i && (i = t)
                         }
                         return 1 / (i - n)
                     }(f[1], u);
                 for (; d;) {
                     const t = r((f[0] + d[0]) / 2);
-                    t[0] - f[0] >= c && Io(f, t, d, h, p) > jo ? u.push(t) : (f = d, l.push(d), u.pop()), d = u[u.length - 1]
+                    t[0] - f[0] >= c && jo(f, t, d, h, p) > Bo ? u.push(t) : (f = d, l.push(d), u.pop()), d = u[u.length - 1]
                 }
                 return l
             }
 
-            function Io(t, e, n, i, r) {
+            function jo(t, e, n, i, r) {
                 const o = Math.atan2(r * (n[1] - t[1]), i * (n[0] - t[0])),
                     a = Math.atan2(r * (e[1] - t[1]), i * (e[0] - t[0]));
                 return Math.abs(o - a)
             }
             var Uo = n(36397),
                 qo = n(84128),
                 Wo = n(82601);
@@ -23203,22 +23315,22 @@
                 };
                 var e
             }
 
             function Xo(t, e, n) {
                 return n || t + (e ? "_" + e : "")
             }
-            const Jo = () => {},
-                Go = {
-                    init: Jo,
-                    add: Jo,
-                    rem: Jo,
+            const Go = () => {},
+                Jo = {
+                    init: Go,
+                    add: Go,
+                    rem: Go,
                     idx: 0
                 },
-                $o = {
+                Zo = {
                     values: {
                         init: t => t.cell.store = !0,
                         value: t => t.cell.data.values(),
                         idx: -1
                     },
                     count: {
                         value: t => t.cell.num
@@ -23230,15 +23342,15 @@
                         value: t => t.missing
                     },
                     valid: {
                         value: t => t.valid
                     },
                     sum: {
                         init: t => t.sum = 0,
-                        value: t => t.sum,
+                        value: t => t.valid ? t.sum : void 0,
                         add: (t, e) => t.sum += +e,
                         rem: (t, e) => t.sum -= e
                     },
                     product: {
                         init: t => t.product = 1,
                         value: t => t.valid ? t.product : void 0,
                         add: (t, e) => t.product *= e,
@@ -23356,28 +23468,41 @@
                             e > t.max && (t.argmax = n)
                         },
                         rem: (t, e) => {
                             e >= t.max && (t.argmax = void 0)
                         },
                         req: ["max", "values"],
                         idx: 3
+                    },
+                    exponential: {
+                        init: (t, e) => {
+                            t.exp = 0, t.exp_r = e
+                        },
+                        value: t => t.valid ? t.exp * (1 - t.exp_r) / (1 - t.exp_r ** t.valid) : void 0,
+                        add: (t, e) => t.exp = t.exp_r * t.exp + e,
+                        rem: (t, e) => t.exp = (t.exp - e / t.exp_r ** (t.valid - 1)) / t.exp_r
+                    },
+                    exponentialb: {
+                        value: t => t.valid ? t.exp * (1 - t.exp_r) : void 0,
+                        req: ["exponential"],
+                        idx: 1
                     }
                 },
-                Zo = Object.keys($o).filter((t => "__count__" !== t));
+                $o = Object.keys(Zo).filter((t => "__count__" !== t));
 
-            function Yo(t, e) {
-                return $o[t](e)
+            function Yo(t, e, n) {
+                return Zo[t](n, e)
             }
 
             function Vo(t, e) {
                 return t.idx - e.idx
             }
 
             function Ko() {
-                this.valid = 0, this.missing = 0, this._ops.forEach((t => t.init(this)))
+                this.valid = 0, this.missing = 0, this._ops.forEach((t => null == t.aggregate_param ? t.init(this) : t.init(this, t.aggregate_param)))
             }
 
             function Qo(t, e) {
                 null != t && "" !== t ? t === t && (++this.valid, this._ops.forEach((n => n.add(this, t, e)))) : ++this.missing
             }
 
             function ta(t, e) {
@@ -23391,41 +23516,42 @@
             function na(t, e) {
                 const n = e || m.yR,
                     i = function(t) {
                         const e = {};
                         t.forEach((t => e[t.name] = t));
                         const n = t => {
                             t.req && t.req.forEach((t => {
-                                e[t] || n(e[t] = $o[t]())
+                                e[t] || n(e[t] = Zo[t]())
                             }))
                         };
                         return t.forEach(n), Object.values(e).sort(Vo)
                     }(t),
                     r = t.slice().sort(Vo);
 
                 function o(t) {
                     this._ops = i, this._out = r, this.cell = t, this.init()
                 }
                 return o.prototype.init = Ko, o.prototype.add = Qo, o.prototype.rem = ta, o.prototype.set = ea, o.prototype.get = n, o.fields = t.map((t => t.out)), o
             }
 
             function ia(t) {
                 this._key = t ? (0, m.EP)(t) : nr, this.reset()
-            } [...Zo, "__count__"].forEach((t => {
-                $o[t] = function(t, e) {
-                    return n => (0, m.l7)({
+            } [...$o, "__count__"].forEach((t => {
+                Zo[t] = function(t, e) {
+                    return (n, i) => (0, m.l7)({
                         name: t,
+                        aggregate_param: i,
                         out: n || t
-                    }, Go, e)
-                }(t, $o[t])
+                    }, Jo, e)
+                }(t, Zo[t])
             }));
             const ra = ia.prototype;
 
             function oa(t) {
-                Rr.call(this, null, t), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null
+                zr.call(this, null, t), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null
             }
             ra.reset = function() {
                 this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null
             }, ra.add = function(t) {
                 this._add.push(t)
             }, ra.rem = function(t) {
                 this._rem.push(t)
@@ -23490,15 +23616,20 @@
                     name: "groupby",
                     type: "field",
                     array: !0
                 }, {
                     name: "ops",
                     type: "enum",
                     array: !0,
-                    values: Zo
+                    values: $o
+                }, {
+                    name: "aggregate_params",
+                    type: "number",
+                    null: !0,
+                    array: !0
                 }, {
                     name: "fields",
                     type: "field",
                     null: !0,
                     array: !0
                 }, {
                     name: "as",
@@ -23513,15 +23644,15 @@
                     name: "cross",
                     type: "boolean",
                     default: !1
                 }, {
                     name: "key",
                     type: "field"
                 }]
-            }, (0, m.XW)(oa, Rr, {
+            }, (0, m.XW)(oa, zr, {
                 transform(t, e) {
                     const n = this,
                         i = e.fork(e.NO_SOURCE | e.NO_FIELDS),
                         r = t.modified();
                     return n.stamp = i.stamp, n.value && (r || e.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(t) : Object.create(null), e.visit(e.SOURCE, (t => n.add(t)))) : (n.value = n.value || n.init(t), e.visit(e.REM, (t => n.rem(t))), e.visit(e.ADD, (t => n.add(t)))), i.modifies(n._outputs), n._drop = !1 !== t.drop, t.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), e.clean() && n._drop && i.clean(!0).runAfter((() => this.clean())), n.changes(i)
                 },
                 cross() {
@@ -23559,19 +23690,20 @@
                     }
                     this._dims = (0, m.IX)(t.groupby), this._dnames = this._dims.map((t => {
                         const e = (0, m.el)(t);
                         return r(t), n.push(e), e
                     })), this.cellkey = t.key ? t.key : Ho(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
                     const o = t.fields || [null],
                         a = t.ops || ["count"],
-                        s = t.as || [],
-                        c = o.length,
-                        l = {};
-                    let u, f, d, h, p, g;
-                    for (c !== a.length && (0, m.vU)("Unmatched number of fields and aggregate ops."), g = 0; g < c; ++g) u = o[g], f = a[g], null == u && "count" !== f && (0, m.vU)("Null aggregate field specified."), h = (0, m.el)(u), p = Xo(f, h, s[g]), n.push(p), "count" !== f ? (d = l[h], d || (r(u), d = l[h] = [], d.field = u, this._measures.push(d)), "count" !== f && (this._countOnly = !1), d.push(Yo(f, p))) : this._counts.push(p);
+                        s = t.aggregate_params || [null],
+                        c = t.as || [],
+                        l = o.length,
+                        u = {};
+                    let f, d, h, p, g, v, y;
+                    for (l !== a.length && (0, m.vU)("Unmatched number of fields and aggregate ops."), y = 0; y < l; ++y) f = o[y], d = a[y], h = s[y] || null, null == f && "count" !== d && (0, m.vU)("Null aggregate field specified."), g = (0, m.el)(f), v = Xo(d, g, c[y]), n.push(v), "count" !== d ? (p = u[g], p || (r(f), p = u[g] = [], p.field = f, this._measures.push(p)), "count" !== d && (this._countOnly = !1), p.push(Yo(d, h, v))) : this._counts.push(v);
                     return this._measures = this._measures.map((t => na(t, t.field))), Object.create(null)
                 },
                 cellkey: Ho(),
                 cell(t, e) {
                     let n = this.value[t];
                     return n ? 0 === n.num && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[t] = this.newcell(t, e), this._adds[this._alen++] = n), n
                 },
@@ -23645,15 +23777,15 @@
                     for (u = 0, f = this._alen; u < f; ++u) o.push(this.celltuple(e[u])), e[u] = null;
                     for (u = 0, f = this._mlen; u < f; ++u) c = n[u], (0 === c.num && r ? a : s).push(this.celltuple(c)), n[u] = null;
                     return this._alen = this._mlen = 0, this._prev = null, t
                 }
             });
 
             function aa(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function sa(t, e, n) {
                 const i = t;
                 let r = e || [],
                     o = n || [],
                     a = {},
@@ -23663,31 +23795,31 @@
                     remove: t => a[i(t)] = ++s,
                     size: () => r.length,
                     data: (t, e) => (s && (r = r.filter((t => !a[i(t)])), a = {}, s = 0), e && t && r.sort(t), o.length && (r = t ? (0, m.TS)(t, r, o.sort(t)) : r.concat(o), o = []), r)
                 }
             }
 
             function ca(t) {
-                Rr.call(this, [], t)
+                zr.call(this, [], t)
             }
 
             function la(t) {
                 mr.call(this, null, ua, t)
             }
 
             function ua(t) {
                 return this.value && !t.modified() ? this.value : (0, m.qu)(t.fields, t.orders)
             }
 
             function fa(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function da(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
             aa.Definition = {
                 type: "Bin",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
@@ -23744,15 +23876,15 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: ["bin0", "bin1"]
                 }]
-            }, (0, m.XW)(aa, Rr, {
+            }, (0, m.XW)(aa, zr, {
                 transform(t, e) {
                     const n = !1 !== t.interval,
                         i = this._bins(t),
                         r = i.start,
                         o = i.step,
                         a = t.as || ["bin0", "bin1"],
                         s = a[0],
@@ -23762,15 +23894,15 @@
                         const e = i(t);
                         t[s] = e, t[c] = null == e ? null : r + o * (1 + (e - r) / o)
                     } : t => t[s] = i(t)), e.modifies(n ? a : s)
                 },
                 _bins(t) {
                     if (this.value && !t.modified()) return this.value;
                     const e = t.field,
-                        n = Gr(t),
+                        n = Jr(t),
                         i = n.step;
                     let r, o, a = n.start,
                         s = a + Math.ceil((n.stop - a) / i) * i;
                     null != (r = t.anchor) && (o = r - (a + i * Math.floor((r - a) / i)), a += o, s += o);
                     const c = function(t) {
                         let n = (0, m.He)(e(t));
                         return null == n ? null : n < a ? -1 / 0 : n > s ? 1 / 0 : (n = Math.max(a, Math.min(n, s - i)), a + i * Math.floor(1e-14 + (n - a) / i))
@@ -23782,15 +23914,15 @@
                 metadata: {
                     source: !0
                 },
                 params: [{
                     name: "sort",
                     type: "compare"
                 }]
-            }, (0, m.XW)(ca, Rr, {
+            }, (0, m.XW)(ca, zr, {
                 transform(t, e) {
                     const n = e.fork(e.ALL),
                         i = sa(nr, this.value, n.materialize(n.ADD).add),
                         r = t.sort,
                         o = e.changed() || r && (t.modified("sort") || e.modified(r.fields));
                     return n.visit(n.REM, i.remove), this.modified(o), this.value = n.source = i.data(cr(r), o), e.source && e.source.root && (this.value.root = e.source.root), n
                 }
@@ -23820,15 +23952,15 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: ["text", "count"]
                 }]
-            }, (0, m.XW)(fa, Rr, {
+            }, (0, m.XW)(fa, zr, {
                 transform(t, e) {
                     const n = e => n => {
                             for (var i, r = function(t, e, n) {
                                     switch (e) {
                                         case "upper":
                                             t = t.toUpperCase();
                                             break;
@@ -23873,15 +24005,15 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: ["a", "b"]
                 }]
-            }, (0, m.XW)(da, Rr, {
+            }, (0, m.XW)(da, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE),
                         i = t.as || ["a", "b"],
                         r = i[0],
                         o = i[1],
                         a = !this.value || e.changed(e.ADD_REM) || t.modified("as") || t.modified("filter");
                     let s = this.value;
@@ -23906,15 +24038,15 @@
                 (0, m.nr)(ha, n) || (0, m.vU)("Unknown distribution function: " + n);
                 const i = ha[n]();
                 for (const r in t) "field" === r ? i.data((t.from || e()).map(t[r])) : "distributions" === r ? i[r](t[r].map((t => ma(t, e)))) : typeof i[r] === pa && i[r](t[r]);
                 return i
             }
 
             function ga(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
             const va = [{
                     key: {
                         function: "normal"
                     },
                     params: [{
                         name: "mean",
@@ -24029,38 +24161,38 @@
                     params: va.concat(ya)
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     default: ["value", "density"]
                 }]
-            }, (0, m.XW)(ga, Rr, {
+            }, (0, m.XW)(ga, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE | e.NO_FIELDS);
                     if (!this.value || e.changed() || t.modified()) {
                         const i = ma(t.distribution, function(t) {
                                 return () => t.materialize(t.SOURCE).source
                             }(e)),
                             r = t.steps || t.minsteps || 25,
                             o = t.steps || t.maxsteps || 200;
                         let a = t.method || "pdf";
                         "pdf" !== a && "cdf" !== a && (0, m.vU)("Invalid density method: " + a), t.extent || i.data || (0, m.vU)("Missing density extent parameter."), a = i[a];
                         const s = t.as || ["value", "density"],
-                            c = Bo(a, t.extent || (0, m.We)(i.data()), r, o).map((t => {
+                            c = Io(a, t.extent || (0, m.We)(i.data()), r, o).map((t => {
                                 const e = {};
                                 return e[s[0]] = t[0], e[s[1]] = t[1], rr(e)
                             }));
                         this.value && (n.rem = this.value), this.value = n.add = n.source = c
                     }
                     return n
                 }
             });
 
             function _a(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
             _a.Definition = {
                 type: "DotBin",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
@@ -24091,56 +24223,56 @@
 
             function ka(t) {
                 const e = t.expr;
                 return this.value && !t.modified("expr") ? this.value : (0, m.ZE)((n => e(n, t)), (0, m.Oj)(e), (0, m.el)(e))
             }
 
             function Ea(t) {
-                Rr.call(this, [void 0, void 0], t)
+                zr.call(this, [void 0, void 0], t)
             }
 
-            function Da(t, e) {
+            function Aa(t, e) {
                 mr.call(this, t), this.parent = e, this.count = 0
             }
 
-            function Aa(t) {
-                Rr.call(this, {}, t), this._keys = (0, m.Xr)();
+            function Da(t) {
+                zr.call(this, {}, t), this._keys = (0, m.Xr)();
                 const e = this._targets = [];
                 e.active = 0, e.forEach = t => {
                     for (let n = 0, i = e.active; n < i; ++n) t(e[n], n, e)
                 }
             }
 
             function Sa(t) {
                 mr.call(this, null, Ca, t)
             }
 
             function Ca(t) {
                 return this.value && !t.modified() ? this.value : (0, m.kJ)(t.name) ? (0, m.IX)(t.name).map((t => (0, m.EP)(t))) : (0, m.EP)(t.name, t.as)
             }
 
-            function Fa(t) {
-                Rr.call(this, (0, m.Xr)(), t)
+            function Ma(t) {
+                zr.call(this, (0, m.Xr)(), t)
             }
 
-            function Ma(t) {
-                Rr.call(this, [], t)
+            function Fa(t) {
+                zr.call(this, [], t)
             }
 
             function Oa(t) {
-                Rr.call(this, [], t)
+                zr.call(this, [], t)
             }
 
             function Ta(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function Na(t) {
-                Rr.call(this, [], t)
-            }(0, m.XW)(_a, Rr, {
+                zr.call(this, [], t)
+            }(0, m.XW)(_a, zr, {
                 transform(t, e) {
                     if (this.value && !t.modified() && !e.changed()) return e;
                     const n = e.materialize(e.SOURCE).source,
                         i = xa(e.source, t.groupby, m.yR),
                         r = t.smooth || !1,
                         o = t.field,
                         a = t.step || ((t, e) => (0, m.yP)((0, m.We)(t, e)) / 30)(n, o),
@@ -24165,15 +24297,15 @@
                 type: "Extent",
                 metadata: {},
                 params: [{
                     name: "field",
                     type: "field",
                     required: !0
                 }]
-            }, (0, m.XW)(Ea, Rr, {
+            }, (0, m.XW)(Ea, zr, {
                 transform(t, e) {
                     const n = this.value,
                         i = t.field,
                         r = e.changed() || e.modified(i.fields) || t.modified("field");
                     let o = n[0],
                         a = n[1];
                     if ((r || null == o) && (o = 1 / 0, a = -1 / 0), e.visit(r ? e.SOURCE : e.ADD, (t => {
@@ -24181,15 +24313,15 @@
                             null != e && (e < o && (o = e), e > a && (a = e))
                         })), !Number.isFinite(o) || !Number.isFinite(a)) {
                         let t = (0, m.el)(i);
                         t && (t = ' for field "'.concat(t, '"')), e.dataflow.warn("Infinite extent".concat(t, ": [").concat(o, ", ").concat(a, "]")), o = a = void 0
                     }
                     this.value = [o, a]
                 }
-            }), (0, m.XW)(Da, mr, {
+            }), (0, m.XW)(Aa, mr, {
                 connect(t) {
                     return this.detachSubflow = t.detachSubflow, this.targets().add(t), t.source = this
                 },
                 add(t) {
                     this.count += 1, this.value.add.push(t)
                 },
                 rem(t) {
@@ -24200,22 +24332,22 @@
                 },
                 init(t) {
                     this.value.init(t, t.NO_SOURCE)
                 },
                 evaluate() {
                     return this.value
                 }
-            }), (0, m.XW)(Aa, Rr, {
+            }), (0, m.XW)(Da, zr, {
                 activate(t) {
                     this._targets[this._targets.active++] = t
                 },
                 subflow(t, e, n, i) {
                     const r = this.value;
                     let o, a, s = (0, m.nr)(r, t) && r[t];
-                    return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (a = i || (a = this._group[t]) && a.tuple, o = n.dataflow, s = new Da(n.fork(n.NO_SOURCE), this), o.add(s).connect(e(o, t, a)), r[t] = s, this.activate(s)), s
+                    return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (a = i || (a = this._group[t]) && a.tuple, o = n.dataflow, s = new Aa(n.fork(n.NO_SOURCE), this), o.add(s).connect(e(o, t, a)), r[t] = s, this.activate(s)), s
                 },
                 clean() {
                     const t = this.value;
                     let e = 0;
                     for (const n in t)
                         if (0 === t[n].count) {
                             const i = t[n].detachSubflow;
@@ -24260,25 +24392,25 @@
                             n = o.get(e),
                             r = i(t);
                         n !== r && (o.set(e, r), s(n).rem(t), s(r).add(t))
                     })), e.clean() ? n.runAfter((() => {
                         this.clean(), o.clean()
                     })) : o.empty > n.cleanThreshold && n.runAfter(o.clean), e
                 }
-            }), (0, m.XW)(Sa, mr), Fa.Definition = {
+            }), (0, m.XW)(Sa, mr), Ma.Definition = {
                 type: "Filter",
                 metadata: {
                     changes: !0
                 },
                 params: [{
                     name: "expr",
                     type: "expr",
                     required: !0
                 }]
-            }, (0, m.XW)(Fa, Rr, {
+            }, (0, m.XW)(Ma, zr, {
                 transform(t, e) {
                     const n = e.dataflow,
                         i = this.value,
                         r = e.fork(),
                         o = r.add,
                         a = r.rem,
                         s = r.mod,
@@ -24294,15 +24426,15 @@
                     return e.visit(e.REM, (t => {
                         const e = nr(t);
                         i.has(e) ? i.delete(e) : a.push(t)
                     })), e.visit(e.ADD, (e => {
                         c(e, t) ? o.push(e) : i.set(nr(e), 1)
                     })), e.visit(e.MOD, u), t.modified() && (l = !1, e.visit(e.REFLOW, u)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r
                 }
-            }), Ma.Definition = {
+            }), Fa.Definition = {
                 type: "Flatten",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "fields",
                     type: "field",
@@ -24312,15 +24444,15 @@
                     name: "index",
                     type: "string"
                 }, {
                     name: "as",
                     type: "string",
                     array: !0
                 }]
-            }, (0, m.XW)(Ma, Rr, {
+            }, (0, m.XW)(Fa, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE),
                         i = t.fields,
                         r = ba(i, t.as || []),
                         o = t.index || null,
                         a = r.length;
                     return n.rem = this.value, e.visit(e.SOURCE, (t => {
@@ -24346,15 +24478,15 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: ["key", "value"]
                 }]
-            }, (0, m.XW)(Oa, Rr, {
+            }, (0, m.XW)(Oa, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE),
                         i = t.fields,
                         r = i.map(m.el),
                         o = t.as || ["key", "value"],
                         a = o[0],
                         s = o[1],
@@ -24376,36 +24508,36 @@
                     name: "as",
                     type: "string",
                     required: !0
                 }, {
                     name: "initonly",
                     type: "boolean"
                 }]
-            }, (0, m.XW)(Ta, Rr, {
+            }, (0, m.XW)(Ta, zr, {
                 transform(t, e) {
                     const n = t.expr,
                         i = t.as,
                         r = t.modified(),
                         o = t.initonly ? e.ADD : r ? e.SOURCE : e.modified(n.fields) || e.modified(i) ? e.ADD_MOD : e.ADD;
                     return r && (e = e.materialize().reflow(!0)), t.initonly || e.modifies(i), e.visit(o, (e => e[i] = n(e, t)))
                 }
-            }), (0, m.XW)(Na, Rr, {
+            }), (0, m.XW)(Na, zr, {
                 transform(t, e) {
                     const n = e.fork(e.ALL),
                         i = t.generator;
                     let r, o, a, s = this.value,
                         c = t.size - s.length;
                     if (c > 0) {
                         for (r = []; --c >= 0;) r.push(a = rr(i(t))), s.push(a);
                         n.add = n.add.length ? n.materialize(n.ADD).add.concat(r) : r
                     } else o = s.slice(0, -c), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(o) : o, s = s.slice(-c);
                     return n.source = this.value = s, n
                 }
             });
-            const za = {
+            const Ra = {
                     value: "value",
                     median: qr.Z,
                     mean: function(t, e) {
                         let n = 0,
                             i = 0;
                         if (void 0 === e)
                             for (let r of t) null != r && (r = +r) >= r && (++n, i += r);
@@ -24414,48 +24546,48 @@
                             for (let o of t) null != (o = e(o, ++r, t)) && (o = +o) >= o && (++n, i += o)
                         }
                         if (n) return i / n
                     },
                     min: Uo.Z,
                     max: qo.Z
                 },
-                Ra = [];
+                za = [];
 
             function Pa(t) {
-                Rr.call(this, [], t)
+                zr.call(this, [], t)
             }
 
             function La(t) {
                 oa.call(this, t)
             }
 
-            function ja(t) {
-                Rr.call(this, null, t)
-            }
-
             function Ba(t) {
-                mr.call(this, null, Ia, t)
+                zr.call(this, null, t)
             }
 
             function Ia(t) {
+                mr.call(this, null, ja, t)
+            }
+
+            function ja(t) {
                 return this.value && !t.modified() ? this.value : (0, m.Jy)(t.fields, t.flat)
             }
 
             function Ua(t) {
-                Rr.call(this, [], t), this._pending = null
+                zr.call(this, [], t), this._pending = null
             }
 
             function qa(t, e, n) {
                 n.forEach(rr);
                 const i = e.fork(e.NO_FIELDS & e.NO_SOURCE);
                 return i.rem = t.value, t.value = i.source = i.add = n, t._pending = null, i.rem.length && i.clean(!0), i
             }
 
             function Wa(t) {
-                Rr.call(this, {}, t)
+                zr.call(this, {}, t)
             }
 
             function Ha(t) {
                 mr.call(this, null, Xa, t)
             }
 
             function Xa(t) {
@@ -24464,44 +24596,44 @@
                     n = e.length;
                 let i, r, o = 1 / 0,
                     a = -1 / 0;
                 for (i = 0; i < n; ++i) r = e[i], r[0] < o && (o = r[0]), r[1] > a && (a = r[1]);
                 return [o, a]
             }
 
-            function Ja(t) {
-                mr.call(this, null, Ga, t)
+            function Ga(t) {
+                mr.call(this, null, Ja, t)
             }
 
-            function Ga(t) {
+            function Ja(t) {
                 return this.value && !t.modified() ? this.value : t.values.reduce(((t, e) => t.concat(e)), [])
             }
 
-            function $a(t) {
-                Rr.call(this, null, t)
+            function Za(t) {
+                zr.call(this, null, t)
             }
 
-            function Za(t) {
+            function $a(t) {
                 oa.call(this, t)
             }
 
             function Ya(t) {
-                Aa.call(this, t)
+                Da.call(this, t)
             }
 
             function Va(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function Ka(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function Qa(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
             Pa.Definition = {
                 type: "Impute",
                 metadata: {
                     changes: !0
                 },
                 params: [{
@@ -24524,20 +24656,20 @@
                     type: "enum",
                     default: "value",
                     values: ["value", "mean", "median", "max", "min"]
                 }, {
                     name: "value",
                     default: 0
                 }]
-            }, (0, m.XW)(Pa, Rr, {
+            }, (0, m.XW)(Pa, zr, {
                 transform(t, e) {
                     var n, i, r, o, a, s, c, l, u, f, d = e.fork(e.ALL),
                         h = function(t) {
-                            var e, n = t.method || za.value;
-                            if (null != za[n]) return n === za.value ? (e = void 0 !== t.value ? t.value : 0, () => e) : za[n];
+                            var e, n = t.method || Ra.value;
+                            if (null != Ra[n]) return n === Ra.value ? (e = void 0 !== t.value ? t.value : 0, () => e) : Ra[n];
                             (0, m.vU)("Unrecognized imputation method: " + n)
                         }(t),
                         p = function(t) {
                             const e = t.field;
                             return t => t ? e(t) : NaN
                         }(t),
                         g = (0, m.el)(t.field),
@@ -24545,15 +24677,15 @@
                         y = (t.groupby || []).map(m.el),
                         b = function(t, e, n, i) {
                             var r, o, a, s, c, l, u, f, d = t => t(f),
                                 h = [],
                                 p = i ? i.slice() : [],
                                 m = {},
                                 g = {};
-                            for (p.forEach(((t, e) => m[t] = e + 1)), s = 0, u = t.length; s < u; ++s) l = n(f = t[s]), c = m[l] || (m[l] = p.push(l)), (a = g[o = (r = e ? e.map(d) : Ra) + ""]) || (a = g[o] = [], h.push(a), a.values = r), a[c - 1] = f;
+                            for (p.forEach(((t, e) => m[t] = e + 1)), s = 0, u = t.length; s < u; ++s) l = n(f = t[s]), c = m[l] || (m[l] = p.push(l)), (a = g[o = (r = e ? e.map(d) : za) + ""]) || (a = g[o] = [], h.push(a), a.values = r), a[c - 1] = f;
                             return h.domain = p, h
                         }(e.source, t.groupby, t.key, t.keyvals),
                         x = [],
                         _ = this.value,
                         w = b.domain.length;
                     for (a = 0, l = b.length; a < l; ++a)
                         for (r = (n = b[a]).values, i = NaN, c = 0; c < w; ++c)
@@ -24578,15 +24710,15 @@
                     type: "field",
                     null: !0,
                     array: !0
                 }, {
                     name: "ops",
                     type: "enum",
                     array: !0,
-                    values: Zo
+                    values: $o
                 }, {
                     name: "as",
                     type: "string",
                     null: !0,
                     array: !0
                 }, {
                     name: "key",
@@ -24605,15 +24737,15 @@
                     const t = this._adds,
                         e = this._mods;
                     let n, i;
                     for (n = 0, i = this._alen; n < i; ++n) this.celltuple(t[n]), t[n] = null;
                     for (n = 0, i = this._mlen; n < i; ++n) this.celltuple(e[n]), e[n] = null;
                     this._alen = this._mlen = 0
                 }
-            }), ja.Definition = {
+            }), Ba.Definition = {
                 type: "KDE",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "groupby",
                     type: "field",
@@ -24657,15 +24789,15 @@
                     default: 200
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     default: ["value", "density"]
                 }]
-            }, (0, m.XW)(ja, Rr, {
+            }, (0, m.XW)(Ba, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE | e.NO_FIELDS);
                     if (!this.value || e.changed() || t.modified()) {
                         const i = e.materialize(e.SOURCE).source,
                             r = xa(i, t.groupby, t.field),
                             o = (t.groupby || []).map(m.el),
                             a = t.bandwidth,
@@ -24674,24 +24806,24 @@
                             l = [];
                         let u = t.extent,
                             f = t.steps || t.minsteps || 25,
                             d = t.steps || t.maxsteps || 200;
                         "pdf" !== s && "cdf" !== s && (0, m.vU)("Invalid density method: " + s), "shared" === t.resolve && (u || (u = (0, m.We)(i, t.field)), f = d = t.steps || d), r.forEach((e => {
                             const n = co(e, a)[s],
                                 i = t.counts ? e.length : 1;
-                            Bo(n, u || (0, m.We)(e), f, d).forEach((t => {
+                            Io(n, u || (0, m.We)(e), f, d).forEach((t => {
                                 const n = {};
                                 for (let i = 0; i < o.length; ++i) n[o[i]] = e.dims[i];
                                 n[c[0]] = t[0], n[c[1]] = t[1] * i, l.push(rr(n))
                             }))
                         })), this.value && (n.rem = this.value), this.value = n.add = n.source = l
                     }
                     return n
                 }
-            }), (0, m.XW)(Ba, mr), (0, m.XW)(Ua, Rr, {
+            }), (0, m.XW)(Ia, mr), (0, m.XW)(Ua, zr, {
                 transform(t, e) {
                     const n = e.dataflow;
                     if (this._pending) return qa(this, e, this._pending);
                     if (function(t) {
                             return t.modified("async") && !(t.modified("values") || t.modified("url") || t.modified("format"))
                         }(t)) return e.StopPropagation;
                     if (t.values) return qa(this, e, n.parse(t.values, t.format));
@@ -24733,15 +24865,15 @@
                     name: "as",
                     type: "string",
                     array: !0
                 }, {
                     name: "default",
                     default: null
                 }]
-            }, (0, m.XW)(Wa, Rr, {
+            }, (0, m.XW)(Wa, zr, {
                 transform(t, e) {
                     const n = t.fields,
                         i = t.index,
                         r = t.values,
                         o = null == t.default ? null : t.default,
                         a = t.modified(),
                         s = n.length;
@@ -24754,19 +24886,19 @@
                                 for (e = 0; e < l; ++e, ++u) t[h[u]] = o;
                             else
                                 for (e = 0; e < l; ++e, ++u) t[h[u]] = r[e](a)
                     }) : (h || (0, m.vU)("Missing output field names."), c = function(t) {
                         for (var e, r = 0; r < s; ++r) e = i.get(n[r](t)), t[h[r]] = null == e ? o : e
                     }), a ? d = e.reflow(!0) : (u = n.some((t => e.modified(t.fields))), f |= u ? e.MOD : 0), e.visit(f, c), d.modifies(h)
                 }
-            }), (0, m.XW)(Ha, mr), (0, m.XW)(Ja, mr), (0, m.XW)($a, Rr, {
+            }), (0, m.XW)(Ha, mr), (0, m.XW)(Ga, mr), (0, m.XW)(Za, zr, {
                 transform(t, e) {
                     return this.modified(t.modified()), this.value = t, e.fork(e.NO_SOURCE | e.NO_FIELDS)
                 }
-            }), Za.Definition = {
+            }), $a.Definition = {
                 type: "Pivot",
                 metadata: {
                     generates: !0,
                     changes: !0
                 },
                 params: [{
                     name: "groupby",
@@ -24779,25 +24911,25 @@
                 }, {
                     name: "value",
                     type: "field",
                     required: !0
                 }, {
                     name: "op",
                     type: "enum",
-                    values: Zo,
+                    values: $o,
                     default: "sum"
                 }, {
                     name: "limit",
                     type: "number",
                     default: 0
                 }, {
                     name: "key",
                     type: "field"
                 }]
-            }, (0, m.XW)(Za, oa, {
+            }, (0, m.XW)($a, oa, {
                 _transform: oa.prototype.transform,
                 transform(t, e) {
                     return this._transform(function(t, e) {
                         const n = t.field,
                             i = t.value,
                             r = ("count" === t.op ? "__count__" : t.op) || "sum",
                             o = (0, m.Oj)(n).concat((0, m.Oj)(i)),
@@ -24818,15 +24950,15 @@
                                 return (0, m.ZE)((i => e(i) === t ? n(i) : NaN), i, t + "")
                             }(t, n, i, o))),
                             as: a.map((t => t + "")),
                             modified: t.modified.bind(t)
                         }
                     }(t, e), e)
                 }
-            }), (0, m.XW)(Ya, Aa, {
+            }), (0, m.XW)(Ya, Da, {
                 transform(t, e) {
                     const n = t.subflow,
                         i = t.field,
                         r = t => this.subflow(nr(t), n, e, t);
                     return (t.modified("field") || i && e.modified((0, m.Oj)(i))) && (0, m.vU)("PreFacet does not support field modification."), this.initTargets(), i ? (e.visit(e.MOD, (t => {
                         const e = r(t);
                         i(t).forEach((t => e.mod(t)))
@@ -24850,15 +24982,15 @@
                     array: !0
                 }, {
                     name: "as",
                     type: "string",
                     null: !0,
                     array: !0
                 }]
-            }, (0, m.XW)(Va, Rr, {
+            }, (0, m.XW)(Va, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE),
                         i = t.fields,
                         r = ba(t.fields, t.as || []),
                         o = i ? (t, e) => function(t, e, n, i) {
                             for (let r = 0, o = n.length; r < o; ++r) e[i[r]] = n[r](t);
                             return e
@@ -24870,15 +25002,15 @@
                     })), e.visit(e.ADD, (t => {
                         const e = o(t, rr({}));
                         a[nr(t)] = e, n.add.push(e)
                     })), e.visit(e.MOD, (t => {
                         n.mod.push(o(t, a[nr(t)]))
                     })), n
                 }
-            }), (0, m.XW)(Ka, Rr, {
+            }), (0, m.XW)(Ka, zr, {
                 transform(t, e) {
                     return this.value = t.value, t.modified("value") ? e.fork(e.NO_SOURCE | e.NO_FIELDS) : e.StopPropagation
                 }
             }), Qa.Definition = {
                 type: "Quantile",
                 metadata: {
                     generates: !0,
@@ -24905,32 +25037,32 @@
                     type: "string",
                     array: !0,
                     default: ["prob", "value"]
                 }]
             };
 
             function ts(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function es(t) {
-                Rr.call(this, [], t), this.count = 0
+                zr.call(this, [], t), this.count = 0
             }
 
             function ns(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
 
             function is(t) {
-                Rr.call(this, null, t), this.modified(!0)
+                zr.call(this, null, t), this.modified(!0)
             }
 
             function rs(t) {
-                Rr.call(this, null, t)
-            }(0, m.XW)(Qa, Rr, {
+                zr.call(this, null, t)
+            }(0, m.XW)(Qa, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE | e.NO_FIELDS),
                         i = t.as || ["prob", "value"];
                     if (this.value && !t.modified() && !e.changed()) return n.source = this.value, n;
                     const r = xa(e.materialize(e.SOURCE).source, t.groupby, t.field),
                         o = (t.groupby || []).map(m.el),
                         a = [],
@@ -24942,15 +25074,15 @@
                         for (let n = 0; n < l; ++n) {
                             const r = {};
                             for (let e = 0; e < o.length; ++e) r[o[e]] = t.dims[e];
                             r[i[0]] = c[n], r[i[1]] = e[n], a.push(rr(r))
                         }
                     })), this.value && (n.rem = this.value), this.value = n.add = n.source = a, n
                 }
-            }), (0, m.XW)(ts, Rr, {
+            }), (0, m.XW)(ts, zr, {
                 transform(t, e) {
                     let n, i;
                     return this.value ? i = this.value : (n = e = e.addAll(), i = this.value = {}), t.derive && (n = e.fork(e.NO_SOURCE), e.visit(e.REM, (t => {
                         const e = nr(t);
                         n.rem.push(i[e]), i[e] = null
                     })), e.visit(e.ADD, (t => {
                         const e = or(t);
@@ -24965,27 +25097,27 @@
                 type: "Sample",
                 metadata: {},
                 params: [{
                     name: "size",
                     type: "number",
                     default: 1e3
                 }]
-            }, (0, m.XW)(es, Rr, {
+            }, (0, m.XW)(es, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE),
                         i = t.modified("size"),
                         r = t.size,
                         o = this.value.reduce(((t, e) => (t[nr(e)] = 1, t)), {});
                     let a = this.value,
                         s = this.count,
                         c = 0;
 
                     function l(t) {
                         let e, i;
-                        a.length < r ? a.push(t) : (i = ~~((s + 1) * $r()), i < a.length && i >= c && (e = a[i], o[nr(e)] && n.rem.push(e), a[i] = t)), ++s
+                        a.length < r ? a.push(t) : (i = ~~((s + 1) * Zr()), i < a.length && i >= c && (e = a[i], o[nr(e)] && n.rem.push(e), a[i] = t)), ++s
                     }
                     if (e.rem.length && (e.visit(e.REM, (t => {
                             const e = nr(t);
                             o[e] && (o[e] = -1, n.rem.push(t)), --s
                         })), a = a.filter((t => -1 !== o[nr(t)]))), (e.rem.length || i) && a.length < r && e.source && (c = s = a.length, e.visit(e.SOURCE, (t => {
                             o[nr(t)] || l(t)
                         })), c = -1), i && a.length > r) {
@@ -25016,37 +25148,37 @@
                     type: "number",
                     default: 1
                 }, {
                     name: "as",
                     type: "string",
                     default: "data"
                 }]
-            }, (0, m.XW)(ns, Rr, {
+            }, (0, m.XW)(ns, zr, {
                 transform(t, e) {
                     if (this.value && !t.modified()) return;
                     const n = e.materialize().fork(e.MOD),
                         i = t.as || "data";
                     return n.rem = this.value ? e.rem.concat(this.value) : e.rem, this.value = (0, Wo.Z)(t.start, t.stop, t.step || 1).map((t => {
                         const e = {};
                         return e[i] = t, rr(e)
                     })), n.add = e.add.concat(this.value), n
                 }
-            }), (0, m.XW)(is, Rr, {
+            }), (0, m.XW)(is, zr, {
                 transform(t, e) {
                     return this.value = e.source, e.changed() ? e.fork(e.NO_SOURCE | e.NO_FIELDS) : e.StopPropagation
                 }
             });
             const os = ["unit0", "unit1"];
 
             function as(t) {
-                Rr.call(this, (0, m.Xr)(), t)
+                zr.call(this, (0, m.Xr)(), t)
             }
 
             function ss(t) {
-                Rr.call(this, null, t)
+                zr.call(this, null, t)
             }
             rs.Definition = {
                 type: "TimeUnit",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
@@ -25082,15 +25214,15 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: os
                 }]
-            }, (0, m.XW)(rs, Rr, {
+            }, (0, m.XW)(rs, zr, {
                 transform(t, e) {
                     const n = t.field,
                         i = !1 !== t.interval,
                         r = "utc" === t.timezone,
                         o = this._floor(t, e),
                         a = (r ? he : de)(o.unit).offset,
                         s = t.as || os,
@@ -25110,33 +25242,33 @@
                     const n = "utc" === t.timezone,
                         {
                             units: i,
                             step: r
                         } = t.units ? {
                             units: t.units,
                             step: t.step || 1
-                        } : ze({
+                        } : Re({
                             extent: t.extent || (0, m.We)(e.materialize(e.SOURCE).source, t.field),
                             maxbins: t.maxbins
                         }),
-                        o = Bt(i),
+                        o = It(i),
                         a = this.value || {},
                         s = (n ? le : ae)(o, r);
                     return s.unit = (0, m.fj)(o), s.units = o, s.step = r, s.start = a.start, s.stop = a.stop, this.value = s
                 }
-            }), (0, m.XW)(as, Rr, {
+            }), (0, m.XW)(as, zr, {
                 transform(t, e) {
                     const n = e.dataflow,
                         i = t.field,
                         r = this.value,
                         o = t => r.set(i(t), t);
                     let a = !0;
                     return t.modified("field") || e.modified(i.fields) ? (r.clear(), e.visit(e.SOURCE, o)) : e.changed() ? (e.visit(e.REM, (t => r.delete(i(t)))), e.visit(e.ADD, o)) : a = !1, this.modified(a), r.empty > n.cleanThreshold && n.runAfter(r.clean), e.fork()
                 }
-            }), (0, m.XW)(ss, Rr, {
+            }), (0, m.XW)(ss, zr, {
                 transform(t, e) {
                     (!this.value || t.modified("field") || t.modified("sort") || e.changed() || t.sort && e.modified(t.sort.fields)) && (this.value = (t.sort ? e.source.slice().sort(cr(t.sort)) : e.source).map(t.field))
                 }
             });
             const cs = {
                 row_number: function() {
                     return {
@@ -25261,46 +25393,49 @@
             };
             const ls = Object.keys(cs);
 
             function us(t) {
                 const e = (0, m.IX)(t.ops),
                     n = (0, m.IX)(t.fields),
                     i = (0, m.IX)(t.params),
-                    r = (0, m.IX)(t.as),
-                    o = this.outputs = [],
-                    a = this.windows = [],
-                    s = {},
+                    r = (0, m.IX)(t.aggregate_params),
+                    o = (0, m.IX)(t.as),
+                    a = this.outputs = [],
+                    s = this.windows = [],
                     c = {},
-                    l = [],
-                    u = [];
-                let f = !0;
+                    l = {},
+                    u = [],
+                    f = [];
+                let d = !0;
 
-                function d(t) {
-                    (0, m.IX)((0, m.Oj)(t)).forEach((t => s[t] = 1))
+                function h(t) {
+                    (0, m.IX)((0, m.Oj)(t)).forEach((t => c[t] = 1))
                 }
-                d(t.sort), e.forEach(((t, e) => {
-                    const s = n[e],
-                        h = (0, m.el)(s),
-                        p = Xo(t, h, r[e]);
-                    if (d(s), o.push(p), (0, m.nr)(cs, t)) a.push(function(t, e, n, i) {
+                h(t.sort), e.forEach(((t, e) => {
+                    const c = n[e],
+                        p = i[e],
+                        g = r[e] || null,
+                        v = (0, m.el)(c),
+                        y = Xo(t, v, o[e]);
+                    if (h(c), a.push(y), (0, m.nr)(cs, t)) s.push(function(t, e, n, i) {
                         const r = cs[t](e, n);
                         return {
                             init: r.init || m.bM,
                             update: function(t, e) {
                                 e[i] = r.next(t)
                             }
                         }
-                    }(t, n[e], i[e], p));
+                    }(t, c, p, y));
                     else {
-                        if (null == s && "count" !== t && (0, m.vU)("Null aggregate field specified."), "count" === t) return void l.push(p);
-                        f = !1;
-                        let e = c[h];
-                        e || (e = c[h] = [], e.field = s, u.push(e)), e.push(Yo(t, p))
+                        if (null == c && "count" !== t && (0, m.vU)("Null aggregate field specified."), "count" === t) return void u.push(y);
+                        d = !1;
+                        let e = l[v];
+                        e || (e = l[v] = [], e.field = c, f.push(e)), e.push(Yo(t, g, y))
                     }
-                })), (l.length || u.length) && (this.cell = function(t, e, n) {
+                })), (u.length || f.length) && (this.cell = function(t, e, n) {
                     t = t.map((t => na(t, t.field)));
                     const i = {
                         num: 0,
                         agg: null,
                         store: !1,
                         count: e
                     };
@@ -25322,29 +25457,29 @@
                         for (s && s.values(), r = 0, a = e.length; r < a; ++r) t[e[r]] = i.num;
                         if (!n)
                             for (r = 0, a = o.length; r < a; ++r) o[r].set(t)
                     }, i.init = function() {
                         i.num = 0, s && s.reset();
                         for (let t = 0; t < r; ++t) o[t].init()
                     }, i
-                }(u, l, f)), this.inputs = Object.keys(s)
+                }(f, u, d)), this.inputs = Object.keys(c)
             }
             const fs = us.prototype;
 
             function ds(t) {
-                Rr.call(this, {}, t), this._mlen = 0, this._mods = []
+                zr.call(this, {}, t), this._mlen = 0, this._mods = []
             }
 
             function hs(t, e, n, i) {
                 const r = i.sort,
                     o = r && !i.ignorePeers,
                     a = i.frame || [null, 0],
                     s = t.data(n),
                     c = s.length,
-                    l = o ? (0, Dt.Z)(r) : null,
+                    l = o ? (0, At.Z)(r) : null,
                     u = {
                         i0: 0,
                         i1: 0,
                         p0: 0,
                         p1: 0,
                         index: 0,
                         data: s,
@@ -25371,25 +25506,37 @@
                 t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + e) / 6, (t._y0 + 4 * t._y1 + n) / 6)
             }
 
             function vs(t) {
                 this._context = t
             }
 
-            function ys() {}
+            function ys(t) {
+                return new vs(t)
+            }
 
-            function bs(t) {
+            function bs() {}
+
+            function xs(t) {
                 this._context = t
             }
 
-            function xs(t) {
+            function _s(t) {
+                return new xs(t)
+            }
+
+            function ws(t) {
                 this._context = t
             }
 
-            function _s(t, e) {
+            function ks(t) {
+                return new ws(t)
+            }
+
+            function Es(t, e) {
                 this._basis = new vs(t), this._beta = e
             }
             fs.init = function() {
                 this.windows.forEach((t => t.init())), this.cell && this.cell.init()
             }, fs.update = function(t, e) {
                 const n = this.cell,
                     i = this.windows,
@@ -25414,21 +25561,26 @@
                     name: "groupby",
                     type: "field",
                     array: !0
                 }, {
                     name: "ops",
                     type: "enum",
                     array: !0,
-                    values: ls.concat(Zo)
+                    values: ls.concat($o)
                 }, {
                     name: "params",
                     type: "number",
                     null: !0,
                     array: !0
                 }, {
+                    name: "aggregate_params",
+                    type: "number",
+                    null: !0,
+                    array: !0
+                }, {
                     name: "fields",
                     type: "field",
                     null: !0,
                     array: !0
                 }, {
                     name: "as",
                     type: "string",
@@ -25442,15 +25594,15 @@
                     length: 2,
                     default: [null, 0]
                 }, {
                     name: "ignorePeers",
                     type: "boolean",
                     default: !1
                 }]
-            }, (0, m.XW)(ds, Rr, {
+            }, (0, m.XW)(ds, zr, {
                 transform(t, e) {
                     this.stamp = e.stamp;
                     const n = t.modified(),
                         i = cr(t.sort),
                         r = Ho(t.groupby),
                         o = t => this.group(r(t));
                     let a = this.state;
@@ -25491,17 +25643,17 @@
                         case 2:
                             this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
                         default:
                             gs(this, t, e)
                     }
                     this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e
                 }
-            }, bs.prototype = {
-                areaStart: ys,
-                areaEnd: ys,
+            }, xs.prototype = {
+                areaStart: bs,
+                areaEnd: bs,
                 lineStart: function() {
                     this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0
                 },
                 lineEnd: function() {
                     switch (this._point) {
                         case 1:
                             this._context.moveTo(this._x2, this._y2), this._context.closePath();
@@ -25525,15 +25677,15 @@
                             this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
                             break;
                         default:
                             gs(this, t, e)
                     }
                     this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e
                 }
-            }, xs.prototype = {
+            }, ws.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -25559,15 +25711,15 @@
                         case 3:
                             this._point = 4;
                         default:
                             gs(this, t, e)
                     }
                     this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e
                 }
-            }, _s.prototype = {
+            }, Es.prototype = {
                 lineStart: function() {
                     this._x = [], this._y = [], this._basis.lineStart()
                 },
                 lineEnd: function() {
                     var t = this._x,
                         e = this._y,
                         n = t.length - 1;
@@ -25575,31 +25727,31 @@
                         for (var i, r = t[0], o = e[0], a = t[n] - r, s = e[n] - o, c = -1; ++c <= n;) i = c / n, this._basis.point(this._beta * t[c] + (1 - this._beta) * (r + i * a), this._beta * e[c] + (1 - this._beta) * (o + i * s));
                     this._x = this._y = null, this._basis.lineEnd()
                 },
                 point: function(t, e) {
                     this._x.push(+t), this._y.push(+e)
                 }
             };
-            const ws = function t(e) {
+            const As = function t(e) {
                 function n(t) {
-                    return 1 === e ? new vs(t) : new _s(t, e)
+                    return 1 === e ? new vs(t) : new Es(t, e)
                 }
                 return n.beta = function(e) {
                     return t(+e)
                 }, n
             }(.85);
 
-            function ks(t, e, n) {
+            function Ds(t, e, n) {
                 t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - e), t._y2 + t._k * (t._y1 - n), t._x2, t._y2)
             }
 
-            function Es(t, e) {
+            function Ss(t, e) {
                 this._context = t, this._k = (1 - e) / 6
             }
-            Es.prototype = {
+            Ss.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -25607,46 +25759,46 @@
                 },
                 lineEnd: function() {
                     switch (this._point) {
                         case 2:
                             this._context.lineTo(this._x2, this._y2);
                             break;
                         case 3:
-                            ks(this, this._x1, this._y1)
+                            Ds(this, this._x1, this._y1)
                     }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line
                 },
                 point: function(t, e) {
                     switch (t = +t, e = +e, this._point) {
                         case 0:
                             this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
                             break;
                         case 1:
                             this._point = 2, this._x1 = t, this._y1 = e;
                             break;
                         case 2:
                             this._point = 3;
                         default:
-                            ks(this, t, e)
+                            Ds(this, t, e)
                     }
                     this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e
                 }
             };
-            const Ds = function t(e) {
+            const Cs = function t(e) {
                 function n(t) {
-                    return new Es(t, e)
+                    return new Ss(t, e)
                 }
                 return n.tension = function(e) {
                     return t(+e)
                 }, n
             }(0);
 
-            function As(t, e) {
+            function Ms(t, e) {
                 this._context = t, this._k = (1 - e) / 6
             }
-            As.prototype = {
+            Ms.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -25665,34 +25817,34 @@
                             break;
                         case 2:
                             this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                             break;
                         case 3:
                             this._point = 4;
                         default:
-                            ks(this, t, e)
+                            Ds(this, t, e)
                     }
                     this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e
                 }
             };
-            const Ss = function t(e) {
+            const Fs = function t(e) {
                 function n(t) {
-                    return new As(t, e)
+                    return new Ms(t, e)
                 }
                 return n.tension = function(e) {
                     return t(+e)
                 }, n
             }(0);
 
-            function Cs(t, e) {
+            function Os(t, e) {
                 this._context = t, this._k = (1 - e) / 6
             }
-            Cs.prototype = {
-                areaStart: ys,
-                areaEnd: ys,
+            Os.prototype = {
+                areaStart: bs,
+                areaEnd: bs,
                 lineStart: function() {
                     this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0
                 },
                 lineEnd: function() {
                     switch (this._point) {
                         case 1:
                             this._context.moveTo(this._x3, this._y3), this._context.closePath();
@@ -25712,65 +25864,65 @@
                         case 1:
                             this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
                             break;
                         case 2:
                             this._point = 3, this._x5 = t, this._y5 = e;
                             break;
                         default:
-                            ks(this, t, e)
+                            Ds(this, t, e)
                     }
                     this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e
                 }
             };
-            const Fs = function t(e) {
+            const Ts = function t(e) {
                     function n(t) {
-                        return new Cs(t, e)
+                        return new Os(t, e)
                     }
                     return n.tension = function(e) {
                         return t(+e)
                     }, n
                 }(0),
-                Ms = Math.abs,
-                Os = Math.atan2,
-                Ts = Math.cos,
-                Ns = Math.max,
-                zs = Math.min,
-                Rs = Math.sin,
-                Ps = Math.sqrt,
-                Ls = 1e-12,
-                js = Math.PI,
-                Bs = js / 2,
-                Is = 2 * js;
+                Ns = Math.abs,
+                Rs = Math.atan2,
+                zs = Math.cos,
+                Ps = Math.max,
+                Ls = Math.min,
+                Bs = Math.sin,
+                Is = Math.sqrt,
+                js = 1e-12,
+                Us = Math.PI,
+                qs = Us / 2,
+                Ws = 2 * Us;
 
-            function Us(t) {
-                return t >= 1 ? Bs : t <= -1 ? -Bs : Math.asin(t)
+            function Hs(t) {
+                return t >= 1 ? qs : t <= -1 ? -qs : Math.asin(t)
             }
 
-            function qs(t, e, n) {
+            function Xs(t, e, n) {
                 var i = t._x1,
                     r = t._y1,
                     o = t._x2,
                     a = t._y2;
-                if (t._l01_a > Ls) {
+                if (t._l01_a > js) {
                     var s = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,
                         c = 3 * t._l01_a * (t._l01_a + t._l12_a);
                     i = (i * s - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c, r = (r * s - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c
                 }
-                if (t._l23_a > Ls) {
+                if (t._l23_a > js) {
                     var l = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,
                         u = 3 * t._l23_a * (t._l23_a + t._l12_a);
                     o = (o * l + t._x1 * t._l23_2a - e * t._l12_2a) / u, a = (a * l + t._y1 * t._l23_2a - n * t._l12_2a) / u
                 }
                 t._context.bezierCurveTo(i, r, o, a, t._x2, t._y2)
             }
 
-            function Ws(t, e) {
+            function Gs(t, e) {
                 this._context = t, this._alpha = e
             }
-            Ws.prototype = {
+            Gs.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -25797,34 +25949,34 @@
                             break;
                         case 1:
                             this._point = 2;
                             break;
                         case 2:
                             this._point = 3;
                         default:
-                            qs(this, t, e)
+                            Xs(this, t, e)
                     }
                     this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e
                 }
             };
-            const Hs = function t(e) {
+            const Js = function t(e) {
                 function n(t) {
-                    return e ? new Ws(t, e) : new Es(t, 0)
+                    return e ? new Gs(t, e) : new Ss(t, 0)
                 }
                 return n.alpha = function(e) {
                     return t(+e)
                 }, n
             }(.5);
 
-            function Xs(t, e) {
+            function Zs(t, e) {
                 this._context = t, this._alpha = e
             }
-            Xs.prototype = {
-                areaStart: ys,
-                areaEnd: ys,
+            Zs.prototype = {
+                areaStart: bs,
+                areaEnd: bs,
                 lineStart: function() {
                     this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
                 },
                 lineEnd: function() {
                     switch (this._point) {
                         case 1:
                             this._context.moveTo(this._x3, this._y3), this._context.closePath();
@@ -25849,32 +26001,32 @@
                         case 1:
                             this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
                             break;
                         case 2:
                             this._point = 3, this._x5 = t, this._y5 = e;
                             break;
                         default:
-                            qs(this, t, e)
+                            Xs(this, t, e)
                     }
                     this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e
                 }
             };
-            const Js = function t(e) {
+            const $s = function t(e) {
                 function n(t) {
-                    return e ? new Xs(t, e) : new Cs(t, 0)
+                    return e ? new Zs(t, e) : new Os(t, 0)
                 }
                 return n.alpha = function(e) {
                     return t(+e)
                 }, n
             }(.5);
 
-            function Gs(t, e) {
+            function Ys(t, e) {
                 this._context = t, this._alpha = e
             }
-            Gs.prototype = {
+            Ys.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -25898,105 +26050,133 @@
                             break;
                         case 2:
                             this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                             break;
                         case 3:
                             this._point = 4;
                         default:
-                            qs(this, t, e)
+                            Xs(this, t, e)
                     }
                     this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e
                 }
             };
-            const $s = function t(e) {
+            const Vs = function t(e) {
                 function n(t) {
-                    return e ? new Gs(t, e) : new As(t, 0)
+                    return e ? new Ys(t, e) : new Ms(t, 0)
                 }
                 return n.alpha = function(e) {
                     return t(+e)
                 }, n
             }(.5);
 
-            function Zs(t) {
+            function Ks(t) {
                 this._context = t
             }
 
-            function Ys(t) {
-                return new Zs(t)
+            function Qs(t) {
+                return new Ks(t)
             }
 
-            function Vs(t) {
+            function tc(t) {
                 this._context = t
             }
 
-            function Ks(t) {
+            function ec(t) {
+                return new tc(t)
+            }
+
+            function nc(t) {
                 return t < 0 ? -1 : 1
             }
 
-            function Qs(t, e, n) {
+            function ic(t, e, n) {
                 var i = t._x1 - t._x0,
                     r = e - t._x1,
                     o = (t._y1 - t._y0) / (i || r < 0 && -0),
                     a = (n - t._y1) / (r || i < 0 && -0),
                     s = (o * r + a * i) / (i + r);
-                return (Ks(o) + Ks(a)) * Math.min(Math.abs(o), Math.abs(a), .5 * Math.abs(s)) || 0
+                return (nc(o) + nc(a)) * Math.min(Math.abs(o), Math.abs(a), .5 * Math.abs(s)) || 0
             }
 
-            function tc(t, e) {
+            function rc(t, e) {
                 var n = t._x1 - t._x0;
                 return n ? (3 * (t._y1 - t._y0) / n - e) / 2 : e
             }
 
-            function ec(t, e, n) {
+            function oc(t, e, n) {
                 var i = t._x0,
                     r = t._y0,
                     o = t._x1,
                     a = t._y1,
                     s = (o - i) / 3;
                 t._context.bezierCurveTo(i + s, r + s * e, o - s, a - s * n, o, a)
             }
 
-            function nc(t) {
+            function ac(t) {
                 this._context = t
             }
 
-            function ic(t) {
-                this._context = new rc(t)
+            function sc(t) {
+                this._context = new cc(t)
             }
 
-            function rc(t) {
+            function cc(t) {
                 this._context = t
             }
 
-            function oc(t) {
+            function lc(t) {
+                return new ac(t)
+            }
+
+            function uc(t) {
+                return new sc(t)
+            }
+
+            function fc(t) {
                 this._context = t
             }
 
-            function ac(t) {
+            function dc(t) {
                 var e, n, i = t.length - 1,
                     r = new Array(i),
                     o = new Array(i),
                     a = new Array(i);
                 for (r[0] = 0, o[0] = 2, a[0] = t[0] + 2 * t[1], e = 1; e < i - 1; ++e) r[e] = 1, o[e] = 4, a[e] = 4 * t[e] + 2 * t[e + 1];
                 for (r[i - 1] = 2, o[i - 1] = 7, a[i - 1] = 8 * t[i - 1] + t[i], e = 1; e < i; ++e) n = r[e] / o[e - 1], o[e] -= n, a[e] -= n * a[e - 1];
                 for (r[i - 1] = a[i - 1] / o[i - 1], e = i - 2; e >= 0; --e) r[e] = (a[e] - r[e + 1]) / o[e];
                 for (o[i - 1] = (t[i] + r[i - 1]) / 2, e = 0; e < i - 1; ++e) o[e] = 2 * t[e + 1] - r[e + 1];
                 return [r, o]
             }
 
-            function sc(t, e) {
+            function hc(t) {
+                return new fc(t)
+            }
+
+            function pc(t, e) {
                 this._context = t, this._t = e
             }
 
-            function cc(t) {
+            function mc(t) {
+                return new pc(t, .5)
+            }
+
+            function gc(t) {
+                return new pc(t, 0)
+            }
+
+            function vc(t) {
+                return new pc(t, 1)
+            }
+
+            function yc(t) {
                 return function() {
                     return t
                 }
             }
-            Zs.prototype = {
+            Ks.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -26012,27 +26192,27 @@
                             break;
                         case 1:
                             this._point = 2;
                         default:
                             this._context.lineTo(t, e)
                     }
                 }
-            }, Vs.prototype = {
-                areaStart: ys,
-                areaEnd: ys,
+            }, tc.prototype = {
+                areaStart: bs,
+                areaEnd: bs,
                 lineStart: function() {
                     this._point = 0
                 },
                 lineEnd: function() {
                     this._point && this._context.closePath()
                 },
                 point: function(t, e) {
                     t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e))
                 }
-            }, nc.prototype = {
+            }, ac.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -26040,52 +26220,52 @@
                 },
                 lineEnd: function() {
                     switch (this._point) {
                         case 2:
                             this._context.lineTo(this._x1, this._y1);
                             break;
                         case 3:
-                            ec(this, this._t0, tc(this, this._t0))
+                            oc(this, this._t0, rc(this, this._t0))
                     }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line
                 },
                 point: function(t, e) {
                     var n = NaN;
                     if (e = +e, (t = +t) !== this._x1 || e !== this._y1) {
                         switch (this._point) {
                             case 0:
                                 this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
                                 break;
                             case 1:
                                 this._point = 2;
                                 break;
                             case 2:
-                                this._point = 3, ec(this, tc(this, n = Qs(this, t, e)), n);
+                                this._point = 3, oc(this, rc(this, n = ic(this, t, e)), n);
                                 break;
                             default:
-                                ec(this, this._t0, n = Qs(this, t, e))
+                                oc(this, this._t0, n = ic(this, t, e))
                         }
                         this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = n
                     }
                 }
-            }, (ic.prototype = Object.create(nc.prototype)).point = function(t, e) {
-                nc.prototype.point.call(this, e, t)
-            }, rc.prototype = {
+            }, (sc.prototype = Object.create(ac.prototype)).point = function(t, e) {
+                ac.prototype.point.call(this, e, t)
+            }, cc.prototype = {
                 moveTo: function(t, e) {
                     this._context.moveTo(e, t)
                 },
                 closePath: function() {
                     this._context.closePath()
                 },
                 lineTo: function(t, e) {
                     this._context.lineTo(e, t)
                 },
                 bezierCurveTo: function(t, e, n, i, r, o) {
                     this._context.bezierCurveTo(e, t, i, n, o, r)
                 }
-            }, oc.prototype = {
+            }, fc.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -26094,21 +26274,21 @@
                 lineEnd: function() {
                     var t = this._x,
                         e = this._y,
                         n = t.length;
                     if (n)
                         if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), 2 === n) this._context.lineTo(t[1], e[1]);
                         else
-                            for (var i = ac(t), r = ac(e), o = 0, a = 1; a < n; ++o, ++a) this._context.bezierCurveTo(i[0][o], r[0][o], i[1][o], r[1][o], t[a], e[a]);
+                            for (var i = dc(t), r = dc(e), o = 0, a = 1; a < n; ++o, ++a) this._context.bezierCurveTo(i[0][o], r[0][o], i[1][o], r[1][o], t[a], e[a]);
                     (this._line || 0 !== this._line && 1 === n) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null
                 },
                 point: function(t, e) {
                     this._x.push(+t), this._y.push(+e)
                 }
-            }, sc.prototype = {
+            }, pc.prototype = {
                 areaStart: function() {
                     this._line = 0
                 },
                 areaEnd: function() {
                     this._line = NaN
                 },
                 lineStart: function() {
@@ -26130,219 +26310,313 @@
                                 var n = this._x * (1 - this._t) + t * this._t;
                                 this._context.lineTo(n, this._y), this._context.lineTo(n, e)
                             }
                     }
                     this._x = t, this._y = e
                 }
             };
-            var lc, uc, fc, dc, hc, pc, mc, gc, vc, yc, bc, xc, _c, wc, kc = n(50669);
-            const Ec = Math.PI,
-                Dc = 2 * Ec,
-                Ac = 1e-6,
-                Sc = Dc - Ac;
+            var bc, xc, _c, wc, kc, Ec, Ac, Dc, Sc, Cc, Mc, Fc, Oc, Tc, Nc = n(50669);
+            const Rc = Math.PI,
+                zc = 2 * Rc,
+                Pc = 1e-6,
+                Lc = zc - Pc;
 
-            function Cc(t) {
+            function Bc(t) {
                 this._ += t[0];
                 for (let e = 1, n = t.length; e < n; ++e) this._ += arguments[e] + t[e]
             }
-            class Fc {
+            class Ic {
                 constructor(t) {
-                    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = null == t ? Cc : function(t) {
+                    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = null == t ? Bc : function(t) {
                         let e = Math.floor(t);
                         if (!(e >= 0)) throw new Error("invalid digits: ".concat(t));
-                        if (e > 15) return Cc;
+                        if (e > 15) return Bc;
                         const n = 10 ** e;
                         return function(t) {
                             this._ += t[0];
                             for (let e = 1, i = t.length; e < i; ++e) this._ += Math.round(arguments[e] * n) / n + t[e]
                         }
                     }(t)
                 }
                 moveTo(t, e) {
-                    this._append(lc || (lc = (0, kc.Z)(["M", ",", ""])), this._x0 = this._x1 = +t, this._y0 = this._y1 = +e)
+                    this._append(bc || (bc = (0, Nc.Z)(["M", ",", ""])), this._x0 = this._x1 = +t, this._y0 = this._y1 = +e)
                 }
                 closePath() {
-                    null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._append(uc || (uc = (0, kc.Z)(["Z"]))))
+                    null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._append(xc || (xc = (0, Nc.Z)(["Z"]))))
                 }
                 lineTo(t, e) {
-                    this._append(fc || (fc = (0, kc.Z)(["L", ",", ""])), this._x1 = +t, this._y1 = +e)
+                    this._append(_c || (_c = (0, Nc.Z)(["L", ",", ""])), this._x1 = +t, this._y1 = +e)
                 }
                 quadraticCurveTo(t, e, n, i) {
-                    this._append(dc || (dc = (0, kc.Z)(["Q", ",", ",", ",", ""])), +t, +e, this._x1 = +n, this._y1 = +i)
+                    this._append(wc || (wc = (0, Nc.Z)(["Q", ",", ",", ",", ""])), +t, +e, this._x1 = +n, this._y1 = +i)
                 }
                 bezierCurveTo(t, e, n, i, r, o) {
-                    this._append(hc || (hc = (0, kc.Z)(["C", ",", ",", ",", ",", ",", ""])), +t, +e, +n, +i, this._x1 = +r, this._y1 = +o)
+                    this._append(kc || (kc = (0, Nc.Z)(["C", ",", ",", ",", ",", ",", ""])), +t, +e, +n, +i, this._x1 = +r, this._y1 = +o)
                 }
                 arcTo(t, e, n, i, r) {
                     if (t = +t, e = +e, n = +n, i = +i, (r = +r) < 0) throw new Error("negative radius: ".concat(r));
                     let o = this._x1,
                         a = this._y1,
                         s = n - t,
                         c = i - e,
                         l = o - t,
                         u = a - e,
                         f = l * l + u * u;
-                    if (null === this._x1) this._append(pc || (pc = (0, kc.Z)(["M", ",", ""])), this._x1 = t, this._y1 = e);
-                    else if (f > Ac)
-                        if (Math.abs(u * s - c * l) > Ac && r) {
+                    if (null === this._x1) this._append(Ec || (Ec = (0, Nc.Z)(["M", ",", ""])), this._x1 = t, this._y1 = e);
+                    else if (f > Pc)
+                        if (Math.abs(u * s - c * l) > Pc && r) {
                             let d = n - o,
                                 h = i - a,
                                 p = s * s + c * c,
                                 m = d * d + h * h,
                                 g = Math.sqrt(p),
                                 v = Math.sqrt(f),
-                                y = r * Math.tan((Ec - Math.acos((p + f - m) / (2 * g * v))) / 2),
+                                y = r * Math.tan((Rc - Math.acos((p + f - m) / (2 * g * v))) / 2),
                                 b = y / v,
                                 x = y / g;
-                            Math.abs(b - 1) > Ac && this._append(gc || (gc = (0, kc.Z)(["L", ",", ""])), t + b * l, e + b * u), this._append(vc || (vc = (0, kc.Z)(["A", ",", ",0,0,", ",", ",", ""])), r, r, +(u * d > l * h), this._x1 = t + x * s, this._y1 = e + x * c)
-                        } else this._append(mc || (mc = (0, kc.Z)(["L", ",", ""])), this._x1 = t, this._y1 = e);
+                            Math.abs(b - 1) > Pc && this._append(Dc || (Dc = (0, Nc.Z)(["L", ",", ""])), t + b * l, e + b * u), this._append(Sc || (Sc = (0, Nc.Z)(["A", ",", ",0,0,", ",", ",", ""])), r, r, +(u * d > l * h), this._x1 = t + x * s, this._y1 = e + x * c)
+                        } else this._append(Ac || (Ac = (0, Nc.Z)(["L", ",", ""])), this._x1 = t, this._y1 = e);
                     else;
                 }
                 arc(t, e, n, i, r, o) {
                     if (t = +t, e = +e, o = !!o, (n = +n) < 0) throw new Error("negative radius: ".concat(n));
                     let a = n * Math.cos(i),
                         s = n * Math.sin(i),
                         c = t + a,
                         l = e + s,
                         u = 1 ^ o,
                         f = o ? i - r : r - i;
-                    null === this._x1 ? this._append(yc || (yc = (0, kc.Z)(["M", ",", ""])), c, l) : (Math.abs(this._x1 - c) > Ac || Math.abs(this._y1 - l) > Ac) && this._append(bc || (bc = (0, kc.Z)(["L", ",", ""])), c, l), n && (f < 0 && (f = f % Dc + Dc), f > Sc ? this._append(xc || (xc = (0, kc.Z)(["A", ",", ",0,1,", ",", ",", "A", ",", ",0,1,", ",", ",", ""])), n, n, u, t - a, e - s, n, n, u, this._x1 = c, this._y1 = l) : f > Ac && this._append(_c || (_c = (0, kc.Z)(["A", ",", ",0,", ",", ",", ",", ""])), n, n, +(f >= Ec), u, this._x1 = t + n * Math.cos(r), this._y1 = e + n * Math.sin(r)))
+                    null === this._x1 ? this._append(Cc || (Cc = (0, Nc.Z)(["M", ",", ""])), c, l) : (Math.abs(this._x1 - c) > Pc || Math.abs(this._y1 - l) > Pc) && this._append(Mc || (Mc = (0, Nc.Z)(["L", ",", ""])), c, l), n && (f < 0 && (f = f % zc + zc), f > Lc ? this._append(Fc || (Fc = (0, Nc.Z)(["A", ",", ",0,1,", ",", ",", "A", ",", ",0,1,", ",", ",", ""])), n, n, u, t - a, e - s, n, n, u, this._x1 = c, this._y1 = l) : f > Pc && this._append(Oc || (Oc = (0, Nc.Z)(["A", ",", ",0,", ",", ",", ",", ""])), n, n, +(f >= Rc), u, this._x1 = t + n * Math.cos(r), this._y1 = e + n * Math.sin(r)))
                 }
                 rect(t, e, n, i) {
-                    this._append(wc || (wc = (0, kc.Z)(["M", ",", "h", "v", "h", "Z"])), this._x0 = this._x1 = +t, this._y0 = this._y1 = +e, n = +n, +i, -n)
+                    this._append(Tc || (Tc = (0, Nc.Z)(["M", ",", "h", "v", "h", "Z"])), this._x0 = this._x1 = +t, this._y0 = this._y1 = +e, n = +n, +i, -n)
                 }
                 toString() {
                     return this._
                 }
             }
 
-            function Mc() {
-                return new Fc
+            function jc() {
+                return new Ic
             }
 
-            function Oc(t) {
+            function Uc(t) {
                 let e = 3;
                 return t.digits = function(n) {
                     if (!arguments.length) return e;
                     if (null == n) e = null;
                     else {
                         const t = Math.floor(n);
                         if (!(t >= 0)) throw new RangeError("invalid digits: ".concat(n));
                         e = t
                     }
                     return t
-                }, () => new Fc(e)
+                }, () => new Ic(e)
             }
 
-            function Tc(t) {
+            function qc(t) {
                 return t.innerRadius
             }
 
-            function Nc(t) {
+            function Wc(t) {
                 return t.outerRadius
             }
 
-            function zc(t) {
+            function Hc(t) {
                 return t.startAngle
             }
 
-            function Rc(t) {
+            function Xc(t) {
                 return t.endAngle
             }
 
-            function Pc(t) {
+            function Gc(t) {
                 return t && t.padAngle
             }
 
-            function Lc(t, e, n, i, r, o, a) {
+            function Jc(t, e, n, i, r, o, a) {
                 var s = t - n,
                     c = e - i,
-                    l = (a ? o : -o) / Ps(s * s + c * c),
+                    l = (a ? o : -o) / Is(s * s + c * c),
                     u = l * c,
                     f = -l * s,
                     d = t + u,
                     h = e + f,
                     p = n + u,
                     m = i + f,
                     g = (d + p) / 2,
                     v = (h + m) / 2,
                     y = p - d,
                     b = m - h,
                     x = y * y + b * b,
                     _ = r - o,
                     w = d * m - p * h,
-                    k = (b < 0 ? -1 : 1) * Ps(Ns(0, _ * _ * x - w * w)),
+                    k = (b < 0 ? -1 : 1) * Is(Ps(0, _ * _ * x - w * w)),
                     E = (w * b - y * k) / x,
-                    D = (-w * y - b * k) / x,
-                    A = (w * b + y * k) / x,
+                    A = (-w * y - b * k) / x,
+                    D = (w * b + y * k) / x,
                     S = (-w * y + b * k) / x,
                     C = E - g,
-                    F = D - v,
-                    M = A - g,
+                    M = A - v,
+                    F = D - g,
                     O = S - v;
-                return C * C + F * F > M * M + O * O && (E = A, D = S), {
+                return C * C + M * M > F * F + O * O && (E = D, A = S), {
                     cx: E,
-                    cy: D,
+                    cy: A,
                     x01: -u,
                     y01: -f,
                     x11: E * (r / _ - 1),
-                    y11: D * (r / _ - 1)
+                    y11: A * (r / _ - 1)
                 }
             }
-            Mc.prototype = Fc.prototype;
+
+            function Zc() {
+                var t = qc,
+                    e = Wc,
+                    n = yc(0),
+                    i = null,
+                    r = Hc,
+                    o = Xc,
+                    a = Gc,
+                    s = null,
+                    c = Uc(l);
+
+                function l() {
+                    var l, u, f = +t.apply(this, arguments),
+                        d = +e.apply(this, arguments),
+                        h = r.apply(this, arguments) - qs,
+                        p = o.apply(this, arguments) - qs,
+                        m = Ns(p - h),
+                        g = p > h;
+                    if (s || (s = l = c()), d < f && (u = d, d = f, f = u), d > js)
+                        if (m > Ws - js) s.moveTo(d * zs(h), d * Bs(h)), s.arc(0, 0, d, h, p, !g), f > js && (s.moveTo(f * zs(p), f * Bs(p)), s.arc(0, 0, f, p, h, g));
+                        else {
+                            var v, y, b = h,
+                                x = p,
+                                _ = h,
+                                w = p,
+                                k = m,
+                                E = m,
+                                A = a.apply(this, arguments) / 2,
+                                D = A > js && (i ? +i.apply(this, arguments) : Is(f * f + d * d)),
+                                S = Ls(Ns(d - f) / 2, +n.apply(this, arguments)),
+                                C = S,
+                                M = S;
+                            if (D > js) {
+                                var F = Hs(D / f * Bs(A)),
+                                    O = Hs(D / d * Bs(A));
+                                (k -= 2 * F) > js ? (_ += F *= g ? 1 : -1, w -= F) : (k = 0, _ = w = (h + p) / 2), (E -= 2 * O) > js ? (b += O *= g ? 1 : -1, x -= O) : (E = 0, b = x = (h + p) / 2)
+                            }
+                            var T = d * zs(b),
+                                N = d * Bs(b),
+                                R = f * zs(w),
+                                z = f * Bs(w);
+                            if (S > js) {
+                                var P, L = d * zs(x),
+                                    B = d * Bs(x),
+                                    I = f * zs(_),
+                                    j = f * Bs(_);
+                                if (m < Us)
+                                    if (P = function(t, e, n, i, r, o, a, s) {
+                                            var c = n - t,
+                                                l = i - e,
+                                                u = a - r,
+                                                f = s - o,
+                                                d = f * c - u * l;
+                                            if (!(d * d < js)) return [t + (d = (u * (e - o) - f * (t - r)) / d) * c, e + d * l]
+                                        }(T, N, I, j, L, B, R, z)) {
+                                        var U = T - P[0],
+                                            q = N - P[1],
+                                            W = L - P[0],
+                                            H = B - P[1],
+                                            X = 1 / Bs(function(t) {
+                                                return t > 1 ? 0 : t < -1 ? Us : Math.acos(t)
+                                            }((U * W + q * H) / (Is(U * U + q * q) * Is(W * W + H * H))) / 2),
+                                            G = Is(P[0] * P[0] + P[1] * P[1]);
+                                        C = Ls(S, (f - G) / (X - 1)), M = Ls(S, (d - G) / (X + 1))
+                                    } else C = M = 0
+                            }
+                            E > js ? M > js ? (v = Jc(I, j, T, N, d, M, g), y = Jc(L, B, R, z, d, M, g), s.moveTo(v.cx + v.x01, v.cy + v.y01), M < S ? s.arc(v.cx, v.cy, M, Rs(v.y01, v.x01), Rs(y.y01, y.x01), !g) : (s.arc(v.cx, v.cy, M, Rs(v.y01, v.x01), Rs(v.y11, v.x11), !g), s.arc(0, 0, d, Rs(v.cy + v.y11, v.cx + v.x11), Rs(y.cy + y.y11, y.cx + y.x11), !g), s.arc(y.cx, y.cy, M, Rs(y.y11, y.x11), Rs(y.y01, y.x01), !g))) : (s.moveTo(T, N), s.arc(0, 0, d, b, x, !g)) : s.moveTo(T, N), f > js && k > js ? C > js ? (v = Jc(R, z, L, B, f, -C, g), y = Jc(T, N, I, j, f, -C, g), s.lineTo(v.cx + v.x01, v.cy + v.y01), C < S ? s.arc(v.cx, v.cy, C, Rs(v.y01, v.x01), Rs(y.y01, y.x01), !g) : (s.arc(v.cx, v.cy, C, Rs(v.y01, v.x01), Rs(v.y11, v.x11), !g), s.arc(0, 0, f, Rs(v.cy + v.y11, v.cx + v.x11), Rs(y.cy + y.y11, y.cx + y.x11), g), s.arc(y.cx, y.cy, C, Rs(y.y11, y.x11), Rs(y.y01, y.x01), !g))) : s.arc(0, 0, f, w, _, g) : s.lineTo(R, z)
+                        }
+                    else s.moveTo(0, 0);
+                    if (s.closePath(), l) return s = null, l + "" || null
+                }
+                return l.centroid = function() {
+                    var n = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2,
+                        i = (+r.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Us / 2;
+                    return [zs(i) * n, Bs(i) * n]
+                }, l.innerRadius = function(e) {
+                    return arguments.length ? (t = "function" === typeof e ? e : yc(+e), l) : t
+                }, l.outerRadius = function(t) {
+                    return arguments.length ? (e = "function" === typeof t ? t : yc(+t), l) : e
+                }, l.cornerRadius = function(t) {
+                    return arguments.length ? (n = "function" === typeof t ? t : yc(+t), l) : n
+                }, l.padRadius = function(t) {
+                    return arguments.length ? (i = null == t ? null : "function" === typeof t ? t : yc(+t), l) : i
+                }, l.startAngle = function(t) {
+                    return arguments.length ? (r = "function" === typeof t ? t : yc(+t), l) : r
+                }, l.endAngle = function(t) {
+                    return arguments.length ? (o = "function" === typeof t ? t : yc(+t), l) : o
+                }, l.padAngle = function(t) {
+                    return arguments.length ? (a = "function" === typeof t ? t : yc(+t), l) : a
+                }, l.context = function(t) {
+                    return arguments.length ? (s = null == t ? null : t, l) : s
+                }, l
+            }
+            jc.prototype = Ic.prototype;
             Array.prototype.slice;
 
-            function jc(t) {
+            function $c(t) {
                 return "object" === typeof t && "length" in t ? t : Array.from(t)
             }
 
-            function Bc(t) {
+            function Yc(t) {
                 return t[0]
             }
 
-            function Ic(t) {
+            function Vc(t) {
                 return t[1]
             }
 
-            function Uc(t, e) {
-                var n = cc(!0),
+            function Kc(t, e) {
+                var n = yc(!0),
                     i = null,
-                    r = Ys,
+                    r = Qs,
                     o = null,
-                    a = Oc(s);
+                    a = Uc(s);
 
                 function s(s) {
-                    var c, l, u, f = (s = jc(s)).length,
+                    var c, l, u, f = (s = $c(s)).length,
                         d = !1;
                     for (null == i && (o = r(u = a())), c = 0; c <= f; ++c) !(c < f && n(l = s[c], c, s)) === d && ((d = !d) ? o.lineStart() : o.lineEnd()), d && o.point(+t(l, c, s), +e(l, c, s));
                     if (u) return o = null, u + "" || null
                 }
-                return t = "function" === typeof t ? t : void 0 === t ? Bc : cc(t), e = "function" === typeof e ? e : void 0 === e ? Ic : cc(e), s.x = function(e) {
-                    return arguments.length ? (t = "function" === typeof e ? e : cc(+e), s) : t
+                return t = "function" === typeof t ? t : void 0 === t ? Yc : yc(t), e = "function" === typeof e ? e : void 0 === e ? Vc : yc(e), s.x = function(e) {
+                    return arguments.length ? (t = "function" === typeof e ? e : yc(+e), s) : t
                 }, s.y = function(t) {
-                    return arguments.length ? (e = "function" === typeof t ? t : cc(+t), s) : e
+                    return arguments.length ? (e = "function" === typeof t ? t : yc(+t), s) : e
                 }, s.defined = function(t) {
-                    return arguments.length ? (n = "function" === typeof t ? t : cc(!!t), s) : n
+                    return arguments.length ? (n = "function" === typeof t ? t : yc(!!t), s) : n
                 }, s.curve = function(t) {
                     return arguments.length ? (r = t, null != i && (o = r(i)), s) : r
                 }, s.context = function(t) {
                     return arguments.length ? (null == t ? i = o = null : o = r(i = t), s) : i
                 }, s
             }
 
-            function qc(t, e, n) {
+            function Qc(t, e, n) {
                 var i = null,
-                    r = cc(!0),
+                    r = yc(!0),
                     o = null,
-                    a = Ys,
+                    a = Qs,
                     s = null,
-                    c = Oc(l);
+                    c = Uc(l);
 
                 function l(l) {
-                    var u, f, d, h, p, m = (l = jc(l)).length,
+                    var u, f, d, h, p, m = (l = $c(l)).length,
                         g = !1,
                         v = new Array(m),
                         y = new Array(m);
                     for (null == o && (s = a(p = c())), u = 0; u <= m; ++u) {
                         if (!(u < m && r(h = l[u], u, l)) === g)
                             if (g = !g) f = u, s.areaStart(), s.lineStart();
                             else {
@@ -26350,142 +26624,181 @@
                                 s.lineEnd(), s.areaEnd()
                             } g && (v[u] = +t(h, u, l), y[u] = +e(h, u, l), s.point(i ? +i(h, u, l) : v[u], n ? +n(h, u, l) : y[u]))
                     }
                     if (p) return s = null, p + "" || null
                 }
 
                 function u() {
-                    return Uc().defined(r).curve(a).context(o)
+                    return Kc().defined(r).curve(a).context(o)
                 }
-                return t = "function" === typeof t ? t : void 0 === t ? Bc : cc(+t), e = "function" === typeof e ? e : cc(void 0 === e ? 0 : +e), n = "function" === typeof n ? n : void 0 === n ? Ic : cc(+n), l.x = function(e) {
-                    return arguments.length ? (t = "function" === typeof e ? e : cc(+e), i = null, l) : t
+                return t = "function" === typeof t ? t : void 0 === t ? Yc : yc(+t), e = "function" === typeof e ? e : yc(void 0 === e ? 0 : +e), n = "function" === typeof n ? n : void 0 === n ? Vc : yc(+n), l.x = function(e) {
+                    return arguments.length ? (t = "function" === typeof e ? e : yc(+e), i = null, l) : t
                 }, l.x0 = function(e) {
-                    return arguments.length ? (t = "function" === typeof e ? e : cc(+e), l) : t
+                    return arguments.length ? (t = "function" === typeof e ? e : yc(+e), l) : t
                 }, l.x1 = function(t) {
-                    return arguments.length ? (i = null == t ? null : "function" === typeof t ? t : cc(+t), l) : i
+                    return arguments.length ? (i = null == t ? null : "function" === typeof t ? t : yc(+t), l) : i
                 }, l.y = function(t) {
-                    return arguments.length ? (e = "function" === typeof t ? t : cc(+t), n = null, l) : e
+                    return arguments.length ? (e = "function" === typeof t ? t : yc(+t), n = null, l) : e
                 }, l.y0 = function(t) {
-                    return arguments.length ? (e = "function" === typeof t ? t : cc(+t), l) : e
+                    return arguments.length ? (e = "function" === typeof t ? t : yc(+t), l) : e
                 }, l.y1 = function(t) {
-                    return arguments.length ? (n = null == t ? null : "function" === typeof t ? t : cc(+t), l) : n
+                    return arguments.length ? (n = null == t ? null : "function" === typeof t ? t : yc(+t), l) : n
                 }, l.lineX0 = l.lineY0 = function() {
                     return u().x(t).y(e)
                 }, l.lineY1 = function() {
                     return u().x(t).y(n)
                 }, l.lineX1 = function() {
                     return u().x(i).y(e)
                 }, l.defined = function(t) {
-                    return arguments.length ? (r = "function" === typeof t ? t : cc(!!t), l) : r
+                    return arguments.length ? (r = "function" === typeof t ? t : yc(!!t), l) : r
                 }, l.curve = function(t) {
                     return arguments.length ? (a = t, null != o && (s = a(o)), l) : a
                 }, l.context = function(t) {
                     return arguments.length ? (null == t ? o = s = null : s = a(o = t), l) : o
                 }, l
             }
-            Ps(3);
-            const Wc = {
+            Is(3);
+            const tl = {
                     draw(t, e) {
-                        const n = Ps(e / js);
-                        t.moveTo(n, 0), t.arc(0, 0, n, 0, Is)
+                        const n = Is(e / Us);
+                        t.moveTo(n, 0), t.arc(0, 0, n, 0, Ws)
                     }
                 },
-                Hc = (Ps(1 / 3), Rs(js / 10) / Rs(7 * js / 10));
-            Rs(Is / 10), Ts(Is / 10), Ps(3), Ps(3), Ps(3), Ps(12);
+                el = (Is(1 / 3), Bs(Us / 10) / Bs(7 * Us / 10));
+            Bs(Ws / 10), zs(Ws / 10), Is(3), Is(3), Is(3), Is(12);
 
-            function Xc(t, e) {
+            function nl(t, e) {
+                let n = null,
+                    i = Uc(r);
+
+                function r() {
+                    let r;
+                    if (n || (n = r = i()), t.apply(this, arguments).draw(n, +e.apply(this, arguments)), r) return n = null, r + "" || null
+                }
+                return t = "function" === typeof t ? t : yc(t || tl), e = "function" === typeof e ? e : yc(void 0 === e ? 64 : +e), r.type = function(e) {
+                    return arguments.length ? (t = "function" === typeof e ? e : yc(e), r) : t
+                }, r.size = function(t) {
+                    return arguments.length ? (e = "function" === typeof t ? t : yc(+t), r) : e
+                }, r.context = function(t) {
+                    return arguments.length ? (n = null == t ? null : t, r) : n
+                }, r
+            }
+
+            function il(t, e) {
                 if ("undefined" !== typeof document && document.createElement) {
                     const n = document.createElement("canvas");
                     if (n && n.getContext) return n.width = t, n.height = e, n
                 }
                 return null
             }
-            const Jc = () => "undefined" !== typeof Image ? Image : null;
-            var Gc = n(94712),
-                $c = n(13629),
-                Zc = n(94923);
-            var Yc = n(95658),
-                Vc = n(66042),
-                Kc = n(1885),
-                Qc = n(8896);
+            const rl = () => "undefined" !== typeof Image ? Image : null;
+            var ol = n(94712),
+                al = n(13629),
+                sl = n(94923);
 
-            function tl(t) {
+            function cl(t) {
+                var e;
+
+                function n(t) {
+                    return null == t || isNaN(t = +t) ? e : t
+                }
+                return n.invert = n, n.domain = n.range = function(e) {
+                    return arguments.length ? (t = Array.from(e, sl.Z), n) : t.slice()
+                }, n.unknown = function(t) {
+                    return arguments.length ? (e = t, n) : e
+                }, n.copy = function() {
+                    return cl(t).unknown(e)
+                }, t = arguments.length ? Array.from(t, sl.Z) : [0, 1], (0, al.Q)(n)
+            }
+            var ll = n(95658),
+                ul = n(66042),
+                fl = n(1885),
+                dl = n(8896);
+
+            function hl(t) {
                 return function(e) {
                     return Math.sign(e) * Math.log1p(Math.abs(e / t))
                 }
             }
 
-            function el(t) {
+            function pl(t) {
                 return function(e) {
                     return Math.sign(e) * Math.expm1(Math.abs(e)) * t
                 }
             }
 
-            function nl(t) {
+            function ml(t) {
                 var e = 1,
-                    n = t(tl(e), el(e));
+                    n = t(hl(e), pl(e));
                 return n.constant = function(n) {
-                    return arguments.length ? t(tl(e = +n), el(e)) : e
-                }, (0, $c.Q)(n)
+                    return arguments.length ? t(hl(e = +n), pl(e)) : e
+                }, (0, al.Q)(n)
             }
 
-            function il(t, e, n, i, r, o) {
+            function gl() {
+                var t = ml((0, fl.l4)());
+                return t.copy = function() {
+                    return (0, fl.JG)(t, gl()).constant(t.constant())
+                }, dl.o.apply(t, arguments)
+            }
+
+            function vl(t, e, n, i, r, o) {
                 const a = [
                     [kt, 1, W],
                     [kt, 5, 5e3],
                     [kt, 15, 15e3],
                     [kt, 30, 3e4],
                     [o, 1, H],
                     [o, 5, 3e5],
                     [o, 15, 9e5],
                     [o, 30, 18e5],
                     [r, 1, X],
                     [r, 3, 108e5],
                     [r, 6, 216e5],
                     [r, 12, 432e5],
-                    [i, 1, J],
+                    [i, 1, G],
                     [i, 2, 1728e5],
-                    [n, 1, G],
-                    [e, 1, $],
+                    [n, 1, J],
+                    [e, 1, Z],
                     [e, 3, 7776e6],
-                    [t, 1, Z]
+                    [t, 1, $]
                 ];
 
                 function s(e, n, i) {
                     const r = Math.abs(n - e) / i,
-                        o = (0, Dt.Z)((t => {
+                        o = (0, At.Z)((t => {
                             let [, , e] = t;
                             return e
                         })).right(a, r);
-                    if (o === a.length) return t.every((0, N.ly)(e / Z, n / Z, i));
+                    if (o === a.length) return t.every((0, N.ly)(e / $, n / $, i));
                     if (0 === o) return Et.every(Math.max((0, N.ly)(e, n, i), 1));
                     const [s, c] = a[r / a[o - 1][2] < a[o][2] / r ? o - 1 : o];
                     return s.every(c)
                 }
                 return [function(t, e, n) {
                     const i = e < t;
                     i && ([t, e] = [e, t]);
                     const r = n && "function" === typeof n.range ? n : s(t, e, n),
                         o = r ? r.range(t, +e + 1) : [];
                     return i ? o.reverse() : o
                 }, s]
             }
-            const [rl, ol] = il(gt, yt, ct, K, xt, wt), [al, sl] = il(mt, vt, tt, Y, bt, _t);
-            var cl = n(48033);
+            const [yl, bl] = vl(gt, yt, ct, K, xt, wt), [xl, _l] = vl(mt, vt, tt, Y, bt, _t);
+            var wl = n(48033);
 
-            function ll(t) {
+            function kl(t) {
                 return new Date(t)
             }
 
-            function ul(t) {
+            function El(t) {
                 return t instanceof Date ? +t : +new Date(+t)
             }
 
-            function fl(t, e, n, i, r, o, a, s, c, l) {
-                var u = (0, Kc.ZP)(),
+            function Al(t, e, n, i, r, o, a, s, c, l) {
+                var u = (0, fl.ZP)(),
                     f = u.invert,
                     d = u.domain,
                     h = l(".%L"),
                     p = l(":%S"),
                     m = l("%I:%M"),
                     g = l("%I %p"),
                     v = l("%a %d"),
@@ -26495,34 +26808,42 @@
 
                 function _(t) {
                     return (c(t) < t ? h : s(t) < t ? p : a(t) < t ? m : o(t) < t ? g : i(t) < t ? r(t) < t ? v : y : n(t) < t ? b : x)(t)
                 }
                 return u.invert = function(t) {
                     return new Date(f(t))
                 }, u.domain = function(t) {
-                    return arguments.length ? d(Array.from(t, ul)) : d().map(ll)
+                    return arguments.length ? d(Array.from(t, El)) : d().map(kl)
                 }, u.ticks = function(e) {
                     var n = d();
                     return t(n[0], n[n.length - 1], null == e ? 10 : e)
                 }, u.tickFormat = function(t, e) {
                     return null == e ? _ : l(e)
                 }, u.nice = function(t) {
                     var n = d();
-                    return t && "function" === typeof t.range || (t = e(n[0], n[n.length - 1], null == t ? 10 : t)), t ? d((0, cl.Z)(n, t)) : u
+                    return t && "function" === typeof t.range || (t = e(n[0], n[n.length - 1], null == t ? 10 : t)), t ? d((0, wl.Z)(n, t)) : u
                 }, u.copy = function() {
-                    return (0, Kc.JG)(u, fl(t, e, n, i, r, o, a, s, c, l))
+                    return (0, fl.JG)(u, Al(t, e, n, i, r, o, a, s, c, l))
                 }, u
             }
-            var dl = n(34588),
-                hl = n(40602);
 
-            function pl() {
+            function Dl() {
+                return dl.o.apply(Al(xl, _l, mt, vt, tt, Y, bt, _t, kt, je).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
+            }
+
+            function Sl() {
+                return dl.o.apply(Al(yl, bl, gt, yt, ct, V, xt, wt, kt, qe).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
+            }
+            var Cl = n(34588),
+                Ml = n(40602);
+
+            function Fl() {
                 var t, e, n, i, r, o = 0,
                     a = 1,
-                    s = Kc.yR,
+                    s = fl.yR,
                     c = !1;
 
                 function l(e) {
                     return null == e || isNaN(e = +e) ? r : s(0 === n ? .5 : (e = (i(e) - t) * n, c ? Math.max(0, Math.min(1, e)) : e))
                 }
 
                 function u(t) {
@@ -26533,122 +26854,165 @@
                 }
                 return l.domain = function(r) {
                         return arguments.length ? ([o, a] = r, t = i(o = +o), e = i(a = +a), n = t === e ? 0 : 1 / (e - t), l) : [o, a]
                     }, l.clamp = function(t) {
                         return arguments.length ? (c = !!t, l) : c
                     }, l.interpolator = function(t) {
                         return arguments.length ? (s = t, l) : s
-                    }, l.range = u(dl.Z), l.rangeRound = u(hl.Z), l.unknown = function(t) {
+                    }, l.range = u(Cl.Z), l.rangeRound = u(Ml.Z), l.unknown = function(t) {
                         return arguments.length ? (r = t, l) : r
                     },
                     function(r) {
                         return i = r, t = r(o), e = r(a), n = t === e ? 0 : 1 / (e - t), l
                     }
             }
 
-            function ml(t, e) {
+            function Ol(t, e) {
                 return e.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown())
             }
 
-            function gl() {
-                var t = (0, $c.Q)(pl()(Kc.yR));
+            function Tl() {
+                var t = (0, al.Q)(Fl()(fl.yR));
+                return t.copy = function() {
+                    return Ol(t, Tl())
+                }, dl.O.apply(t, arguments)
+            }
+
+            function Nl() {
+                var t = (0, ll.Q)(Fl()).domain([1, 10]);
+                return t.copy = function() {
+                    return Ol(t, Nl()).base(t.base())
+                }, dl.O.apply(t, arguments)
+            }
+
+            function Rl() {
+                var t = ml(Fl());
                 return t.copy = function() {
-                    return ml(t, gl())
-                }, Qc.O.apply(t, arguments)
+                    return Ol(t, Rl()).constant(t.constant())
+                }, dl.O.apply(t, arguments)
             }
 
-            function vl() {
-                var t = (0, Vc.Hh)(pl());
+            function zl() {
+                var t = (0, ul.Hh)(Fl());
                 return t.copy = function() {
-                    return ml(t, vl()).exponent(t.exponent())
-                }, Qc.O.apply(t, arguments)
+                    return Ol(t, zl()).exponent(t.exponent())
+                }, dl.O.apply(t, arguments)
+            }
+
+            function Pl() {
+                return zl.apply(null, arguments).exponent(.5)
             }
 
-            function yl(t, e) {
-                void 0 === e && (e = t, t = dl.Z);
+            function Ll(t, e) {
+                void 0 === e && (e = t, t = Cl.Z);
                 for (var n = 0, i = e.length - 1, r = e[0], o = new Array(i < 0 ? 0 : i); n < i;) o[n] = t(r, r = e[++n]);
                 return function(t) {
                     var e = Math.max(0, Math.min(i - 1, Math.floor(t *= i)));
                     return o[e](t - e)
                 }
             }
 
-            function bl() {
+            function Bl() {
                 var t, e, n, i, r, o, a, s = 0,
                     c = .5,
                     l = 1,
                     u = 1,
-                    f = Kc.yR,
+                    f = fl.yR,
                     d = !1;
 
                 function h(t) {
                     return isNaN(t = +t) ? a : (t = .5 + ((t = +o(t)) - e) * (u * t < u * e ? i : r), f(d ? Math.max(0, Math.min(1, t)) : t))
                 }
 
                 function p(t) {
                     return function(e) {
                         var n, i, r;
-                        return arguments.length ? ([n, i, r] = e, f = yl(t, [n, i, r]), h) : [f(0), f(.5), f(1)]
+                        return arguments.length ? ([n, i, r] = e, f = Ll(t, [n, i, r]), h) : [f(0), f(.5), f(1)]
                     }
                 }
                 return h.domain = function(a) {
                         return arguments.length ? ([s, c, l] = a, t = o(s = +s), e = o(c = +c), n = o(l = +l), i = t === e ? 0 : .5 / (e - t), r = e === n ? 0 : .5 / (n - e), u = e < t ? -1 : 1, h) : [s, c, l]
                     }, h.clamp = function(t) {
                         return arguments.length ? (d = !!t, h) : d
                     }, h.interpolator = function(t) {
                         return arguments.length ? (f = t, h) : f
-                    }, h.range = p(dl.Z), h.rangeRound = p(hl.Z), h.unknown = function(t) {
+                    }, h.range = p(Cl.Z), h.rangeRound = p(Ml.Z), h.unknown = function(t) {
                         return arguments.length ? (a = t, h) : a
                     },
                     function(a) {
                         return o = a, t = a(s), e = a(c), n = a(l), i = t === e ? 0 : .5 / (e - t), r = e === n ? 0 : .5 / (n - e), u = e < t ? -1 : 1, h
                     }
             }
 
-            function xl() {
-                var t = (0, Vc.Hh)(bl());
+            function Il() {
+                var t = (0, al.Q)(Bl()(fl.yR));
                 return t.copy = function() {
-                    return ml(t, xl()).exponent(t.exponent())
-                }, Qc.O.apply(t, arguments)
+                    return Ol(t, Il())
+                }, dl.O.apply(t, arguments)
             }
-            var _l = n(79978),
-                wl = n(90983),
-                kl = n(87758),
-                El = n(58458),
-                Dl = n(73113),
-                Al = n(15507),
-                Sl = n(5535),
-                Cl = n(20943),
-                Fl = n(30155);
 
-            function Ml(t) {
+            function jl() {
+                var t = (0, ll.Q)(Bl()).domain([.1, 1, 10]);
+                return t.copy = function() {
+                    return Ol(t, jl()).base(t.base())
+                }, dl.O.apply(t, arguments)
+            }
+
+            function Ul() {
+                var t = ml(Bl());
+                return t.copy = function() {
+                    return Ol(t, Ul()).constant(t.constant())
+                }, dl.O.apply(t, arguments)
+            }
+
+            function ql() {
+                var t = (0, ul.Hh)(Bl());
+                return t.copy = function() {
+                    return Ol(t, ql()).exponent(t.exponent())
+                }, dl.O.apply(t, arguments)
+            }
+
+            function Wl() {
+                return ql.apply(null, arguments).exponent(.5)
+            }
+            var Hl = n(79978),
+                Xl = n(90983),
+                Gl = n(87758),
+                Jl = n(58458),
+                Zl = n(73113),
+                $l = n(15507),
+                Yl = n(5535),
+                Vl = n(20943),
+                Kl = n(30155);
+
+            function Ql(t) {
                 var e = t.length;
                 return function(n) {
                     return t[Math.max(0, Math.min(e - 1, Math.floor(n * e)))]
                 }
             }
-            var Ol = n(97017);
+            var tu = n(97017);
 
-            function Tl(t, e) {
-                var n = (0, Ol.wx)(+t, +e);
+            function eu(t, e) {
+                var n = (0, tu.wx)(+t, +e);
                 return function(t) {
                     var e = n(t);
                     return e - 360 * Math.floor(e / 360)
                 }
             }
-            var Nl = n(74552),
-                zl = n(29232),
-                Rl = n(88246),
-                Pl = n(71413),
-                Ll = n(18959);
+            var nu = n(74552),
+                iu = n(29232),
+                ru = n(88246),
+                ou = n(71413),
+                au = n(18959);
 
-            function jl(t) {
+            function su(t) {
                 return ((t = Math.exp(t)) + 1 / t) / 2
             }
-            const Bl = function t(e, n, i) {
+            const cu = function t(e, n, i) {
                 function r(t, r) {
                     var o, a, s = t[0],
                         c = t[1],
                         l = t[2],
                         u = r[0],
                         f = r[1],
                         d = r[2],
@@ -26662,267 +27026,267 @@
                         var g = Math.sqrt(m),
                             v = (d * d - l * l + i * m) / (2 * l * n * g),
                             y = (d * d - l * l - i * m) / (2 * d * n * g),
                             b = Math.log(Math.sqrt(v * v + 1) - v),
                             x = Math.log(Math.sqrt(y * y + 1) - y);
                         a = (x - b) / e, o = function(t) {
                             var i = t * a,
-                                r = jl(b),
+                                r = su(b),
                                 o = l / (n * g) * (r * function(t) {
                                     return ((t = Math.exp(2 * t)) - 1) / (t + 1)
                                 }(e * i + b) - function(t) {
                                     return ((t = Math.exp(t)) - 1 / t) / 2
                                 }(b));
-                            return [s + o * h, c + o * p, l * r / jl(e * i + b)]
+                            return [s + o * h, c + o * p, l * r / su(e * i + b)]
                         }
                     }
                     return o.duration = 1e3 * a * e / Math.SQRT2, o
                 }
                 return r.rho = function(e) {
                     var n = Math.max(.001, +e),
                         i = n * n;
                     return t(n, i, i * i)
                 }, r
             }(Math.SQRT2, 2, 4);
-            var Il = n(30975),
-                Ul = n(52017);
+            var lu = n(30975),
+                uu = n(52017);
 
-            function ql(t) {
+            function fu(t) {
                 return function(e, n) {
-                    var i = t((e = (0, Ul.Ym)(e)).h, (n = (0, Ul.Ym)(n)).h),
-                        r = (0, Ol.ZP)(e.s, n.s),
-                        o = (0, Ol.ZP)(e.l, n.l),
-                        a = (0, Ol.ZP)(e.opacity, n.opacity);
+                    var i = t((e = (0, uu.Ym)(e)).h, (n = (0, uu.Ym)(n)).h),
+                        r = (0, tu.ZP)(e.s, n.s),
+                        o = (0, tu.ZP)(e.l, n.l),
+                        a = (0, tu.ZP)(e.opacity, n.opacity);
                     return function(t) {
                         return e.h = i(t), e.s = r(t), e.l = o(t), e.opacity = a(t), e + ""
                     }
                 }
             }
-            const Wl = ql(Ol.wx);
-            var Hl = ql(Ol.ZP),
-                Xl = n(20322);
-            const Jl = Math.PI / 180,
-                Gl = 180 / Math.PI,
-                $l = .96422,
-                Zl = 1,
-                Yl = .82521,
-                Vl = 4 / 29,
-                Kl = 6 / 29,
-                Ql = 3 * Kl * Kl,
-                tu = .008856451679035631;
-
-            function eu(t) {
-                if (t instanceof iu) return new iu(t.l, t.a, t.b, t.opacity);
-                if (t instanceof uu) return fu(t);
-                t instanceof Ul.Ss || (t = (0, Ul.SU)(t));
-                var e, n, i = su(t.r),
-                    r = su(t.g),
-                    o = su(t.b),
-                    a = ru((.2225045 * i + .7168786 * r + .0606169 * o) / Zl);
-                return i === r && r === o ? e = n = a : (e = ru((.4360747 * i + .3850649 * r + .1430804 * o) / $l), n = ru((.0139322 * i + .0971045 * r + .7141733 * o) / Yl)), new iu(116 * a - 16, 500 * (e - a), 200 * (a - n), t.opacity)
+            const du = fu(tu.wx);
+            var hu = fu(tu.ZP),
+                pu = n(20322);
+            const mu = Math.PI / 180,
+                gu = 180 / Math.PI,
+                vu = .96422,
+                yu = 1,
+                bu = .82521,
+                xu = 4 / 29,
+                _u = 6 / 29,
+                wu = 3 * _u * _u,
+                ku = .008856451679035631;
+
+            function Eu(t) {
+                if (t instanceof Du) return new Du(t.l, t.a, t.b, t.opacity);
+                if (t instanceof Nu) return Ru(t);
+                t instanceof uu.Ss || (t = (0, uu.SU)(t));
+                var e, n, i = Fu(t.r),
+                    r = Fu(t.g),
+                    o = Fu(t.b),
+                    a = Su((.2225045 * i + .7168786 * r + .0606169 * o) / yu);
+                return i === r && r === o ? e = n = a : (e = Su((.4360747 * i + .3850649 * r + .1430804 * o) / vu), n = Su((.0139322 * i + .0971045 * r + .7141733 * o) / bu)), new Du(116 * a - 16, 500 * (e - a), 200 * (a - n), t.opacity)
             }
 
-            function nu(t, e, n, i) {
-                return 1 === arguments.length ? eu(t) : new iu(t, e, n, null == i ? 1 : i)
+            function Au(t, e, n, i) {
+                return 1 === arguments.length ? Eu(t) : new Du(t, e, n, null == i ? 1 : i)
             }
 
-            function iu(t, e, n, i) {
+            function Du(t, e, n, i) {
                 this.l = +t, this.a = +e, this.b = +n, this.opacity = +i
             }
 
-            function ru(t) {
-                return t > tu ? Math.pow(t, 1 / 3) : t / Ql + Vl
+            function Su(t) {
+                return t > ku ? Math.pow(t, 1 / 3) : t / wu + xu
             }
 
-            function ou(t) {
-                return t > Kl ? t * t * t : Ql * (t - Vl)
+            function Cu(t) {
+                return t > _u ? t * t * t : wu * (t - xu)
             }
 
-            function au(t) {
+            function Mu(t) {
                 return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055)
             }
 
-            function su(t) {
+            function Fu(t) {
                 return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
             }
 
-            function cu(t) {
-                if (t instanceof uu) return new uu(t.h, t.c, t.l, t.opacity);
-                if (t instanceof iu || (t = eu(t)), 0 === t.a && 0 === t.b) return new uu(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
-                var e = Math.atan2(t.b, t.a) * Gl;
-                return new uu(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity)
+            function Ou(t) {
+                if (t instanceof Nu) return new Nu(t.h, t.c, t.l, t.opacity);
+                if (t instanceof Du || (t = Eu(t)), 0 === t.a && 0 === t.b) return new Nu(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
+                var e = Math.atan2(t.b, t.a) * gu;
+                return new Nu(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity)
             }
 
-            function lu(t, e, n, i) {
-                return 1 === arguments.length ? cu(t) : new uu(t, e, n, null == i ? 1 : i)
+            function Tu(t, e, n, i) {
+                return 1 === arguments.length ? Ou(t) : new Nu(t, e, n, null == i ? 1 : i)
             }
 
-            function uu(t, e, n, i) {
+            function Nu(t, e, n, i) {
                 this.h = +t, this.c = +e, this.l = +n, this.opacity = +i
             }
 
-            function fu(t) {
-                if (isNaN(t.h)) return new iu(t.l, 0, 0, t.opacity);
-                var e = t.h * Jl;
-                return new iu(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity)
+            function Ru(t) {
+                if (isNaN(t.h)) return new Du(t.l, 0, 0, t.opacity);
+                var e = t.h * mu;
+                return new Du(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity)
             }
 
-            function du(t, e) {
-                var n = (0, Ol.ZP)((t = nu(t)).l, (e = nu(e)).l),
-                    i = (0, Ol.ZP)(t.a, e.a),
-                    r = (0, Ol.ZP)(t.b, e.b),
-                    o = (0, Ol.ZP)(t.opacity, e.opacity);
+            function zu(t, e) {
+                var n = (0, tu.ZP)((t = Au(t)).l, (e = Au(e)).l),
+                    i = (0, tu.ZP)(t.a, e.a),
+                    r = (0, tu.ZP)(t.b, e.b),
+                    o = (0, tu.ZP)(t.opacity, e.opacity);
                 return function(e) {
                     return t.l = n(e), t.a = i(e), t.b = r(e), t.opacity = o(e), t + ""
                 }
             }
 
-            function hu(t) {
+            function Pu(t) {
                 return function(e, n) {
-                    var i = t((e = lu(e)).h, (n = lu(n)).h),
-                        r = (0, Ol.ZP)(e.c, n.c),
-                        o = (0, Ol.ZP)(e.l, n.l),
-                        a = (0, Ol.ZP)(e.opacity, n.opacity);
+                    var i = t((e = Tu(e)).h, (n = Tu(n)).h),
+                        r = (0, tu.ZP)(e.c, n.c),
+                        o = (0, tu.ZP)(e.l, n.l),
+                        a = (0, tu.ZP)(e.opacity, n.opacity);
                     return function(t) {
                         return e.h = i(t), e.c = r(t), e.l = o(t), e.opacity = a(t), e + ""
                     }
                 }
-            }(0, Xl.Z)(iu, nu, (0, Xl.l)(Ul.Il, {
+            }(0, pu.Z)(Du, Au, (0, pu.l)(uu.Il, {
                 brighter(t) {
-                    return new iu(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)
+                    return new Du(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)
                 },
                 darker(t) {
-                    return new iu(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)
+                    return new Du(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)
                 },
                 rgb() {
                     var t = (this.l + 16) / 116,
                         e = isNaN(this.a) ? t : t + this.a / 500,
                         n = isNaN(this.b) ? t : t - this.b / 200;
-                    return e = $l * ou(e), t = Zl * ou(t), n = Yl * ou(n), new Ul.Ss(au(3.1338561 * e - 1.6168667 * t - .4906146 * n), au(-.9787684 * e + 1.9161415 * t + .033454 * n), au(.0719453 * e - .2289914 * t + 1.4052427 * n), this.opacity)
+                    return e = vu * Cu(e), t = yu * Cu(t), n = bu * Cu(n), new uu.Ss(Mu(3.1338561 * e - 1.6168667 * t - .4906146 * n), Mu(-.9787684 * e + 1.9161415 * t + .033454 * n), Mu(.0719453 * e - .2289914 * t + 1.4052427 * n), this.opacity)
                 }
-            })), (0, Xl.Z)(uu, lu, (0, Xl.l)(Ul.Il, {
+            })), (0, pu.Z)(Nu, Tu, (0, pu.l)(uu.Il, {
                 brighter(t) {
-                    return new uu(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity)
+                    return new Nu(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity)
                 },
                 darker(t) {
-                    return new uu(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity)
+                    return new Nu(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity)
                 },
                 rgb() {
-                    return fu(this).rgb()
+                    return Ru(this).rgb()
                 }
             }));
-            const pu = hu(Ol.wx);
-            var mu = hu(Ol.ZP),
-                gu = -.14861,
-                vu = 1.78277,
-                yu = -.29227,
-                bu = -.90649,
-                xu = 1.97294,
-                _u = xu * bu,
-                wu = xu * vu,
-                ku = vu * yu - bu * gu;
+            const Lu = Pu(tu.wx);
+            var Bu = Pu(tu.ZP),
+                Iu = -.14861,
+                ju = 1.78277,
+                Uu = -.29227,
+                qu = -.90649,
+                Wu = 1.97294,
+                Hu = Wu * qu,
+                Xu = Wu * ju,
+                Gu = ju * Uu - qu * Iu;
 
-            function Eu(t, e, n, i) {
+            function Ju(t, e, n, i) {
                 return 1 === arguments.length ? function(t) {
-                    if (t instanceof Du) return new Du(t.h, t.s, t.l, t.opacity);
-                    t instanceof Ul.Ss || (t = (0, Ul.SU)(t));
+                    if (t instanceof Zu) return new Zu(t.h, t.s, t.l, t.opacity);
+                    t instanceof uu.Ss || (t = (0, uu.SU)(t));
                     var e = t.r / 255,
                         n = t.g / 255,
                         i = t.b / 255,
-                        r = (ku * i + _u * e - wu * n) / (ku + _u - wu),
+                        r = (Gu * i + Hu * e - Xu * n) / (Gu + Hu - Xu),
                         o = i - r,
-                        a = (xu * (n - r) - yu * o) / bu,
-                        s = Math.sqrt(a * a + o * o) / (xu * r * (1 - r)),
-                        c = s ? Math.atan2(a, o) * Gl - 120 : NaN;
-                    return new Du(c < 0 ? c + 360 : c, s, r, t.opacity)
-                }(t) : new Du(t, e, n, null == i ? 1 : i)
+                        a = (Wu * (n - r) - Uu * o) / qu,
+                        s = Math.sqrt(a * a + o * o) / (Wu * r * (1 - r)),
+                        c = s ? Math.atan2(a, o) * gu - 120 : NaN;
+                    return new Zu(c < 0 ? c + 360 : c, s, r, t.opacity)
+                }(t) : new Zu(t, e, n, null == i ? 1 : i)
             }
 
-            function Du(t, e, n, i) {
+            function Zu(t, e, n, i) {
                 this.h = +t, this.s = +e, this.l = +n, this.opacity = +i
             }
 
-            function Au(t) {
+            function $u(t) {
                 return function e(n) {
                     function i(e, i) {
-                        var r = t((e = Eu(e)).h, (i = Eu(i)).h),
-                            o = (0, Ol.ZP)(e.s, i.s),
-                            a = (0, Ol.ZP)(e.l, i.l),
-                            s = (0, Ol.ZP)(e.opacity, i.opacity);
+                        var r = t((e = Ju(e)).h, (i = Ju(i)).h),
+                            o = (0, tu.ZP)(e.s, i.s),
+                            a = (0, tu.ZP)(e.l, i.l),
+                            s = (0, tu.ZP)(e.opacity, i.opacity);
                         return function(t) {
                             return e.h = r(t), e.s = o(t), e.l = a(Math.pow(t, n)), e.opacity = s(t), e + ""
                         }
                     }
                     return n = +n, i.gamma = e, i
                 }(1)
-            }(0, Xl.Z)(Du, Eu, (0, Xl.l)(Ul.Il, {
+            }(0, pu.Z)(Zu, Ju, (0, pu.l)(uu.Il, {
                 brighter(t) {
-                    return t = null == t ? Ul.J5 : Math.pow(Ul.J5, t), new Du(this.h, this.s, this.l * t, this.opacity)
+                    return t = null == t ? uu.J5 : Math.pow(uu.J5, t), new Zu(this.h, this.s, this.l * t, this.opacity)
                 },
                 darker(t) {
-                    return t = null == t ? Ul.xV : Math.pow(Ul.xV, t), new Du(this.h, this.s, this.l * t, this.opacity)
+                    return t = null == t ? uu.xV : Math.pow(uu.xV, t), new Zu(this.h, this.s, this.l * t, this.opacity)
                 },
                 rgb() {
-                    var t = isNaN(this.h) ? 0 : (this.h + 120) * Jl,
+                    var t = isNaN(this.h) ? 0 : (this.h + 120) * mu,
                         e = +this.l,
                         n = isNaN(this.s) ? 0 : this.s * e * (1 - e),
                         i = Math.cos(t),
                         r = Math.sin(t);
-                    return new Ul.Ss(255 * (e + n * (gu * i + vu * r)), 255 * (e + n * (yu * i + bu * r)), 255 * (e + n * (xu * i)), this.opacity)
+                    return new uu.Ss(255 * (e + n * (Iu * i + ju * r)), 255 * (e + n * (Uu * i + qu * r)), 255 * (e + n * (Wu * i)), this.opacity)
                 }
             }));
-            const Su = Au(Ol.wx);
-            var Cu = Au(Ol.ZP);
+            const Yu = $u(tu.wx);
+            var Vu = $u(tu.ZP);
 
-            function Fu(t, e) {
+            function Ku(t, e) {
                 for (var n = new Array(e), i = 0; i < e; ++i) n[i] = t(i / (e - 1));
                 return n
             }
 
-            function Mu(t, e, n) {
+            function Qu(t, e, n) {
                 const i = t - e + 2 * n;
                 return t ? i > 0 ? i : 1 : 0
             }
-            const Ou = "linear",
-                Tu = "log",
-                Nu = "pow",
-                zu = "sqrt",
-                Ru = "symlog",
-                Pu = "time",
-                Lu = "utc",
-                ju = "sequential",
-                Bu = "diverging",
-                Iu = "quantile",
-                Uu = "quantize",
-                qu = "threshold",
-                Wu = "ordinal",
-                Hu = "point",
-                Xu = "band",
-                Ju = "bin-ordinal",
-                Gu = "continuous",
-                $u = "discrete",
-                Zu = "discretizing",
-                Yu = "interpolating",
-                Vu = "temporal";
+            const tf = "linear",
+                ef = "log",
+                nf = "pow",
+                rf = "sqrt",
+                of = "symlog",
+                af = "time",
+                sf = "utc",
+                cf = "sequential",
+                lf = "diverging",
+                uf = "quantile",
+                ff = "quantize",
+                df = "threshold",
+                hf = "ordinal",
+                pf = "point",
+                mf = "band",
+                gf = "bin-ordinal",
+                vf = "continuous",
+                yf = "discrete",
+                bf = "discretizing",
+                xf = "interpolating",
+                _f = "temporal";
 
-            function Ku() {
-                const t = (0, El.Z)().unknown(void 0),
+            function wf() {
+                const t = (0, Jl.Z)().unknown(void 0),
                     e = t.domain,
                     n = t.range;
                 let i, r, o = [0, 1],
                     a = !1,
                     s = 0,
                     c = 0,
                     l = .5;
 
                 function u() {
                     const t = e().length,
                         u = o[1] < o[0],
                         f = o[1 - u],
-                        d = Mu(t, s, c);
+                        d = Qu(t, s, c);
                     let h = o[u - 0];
                     i = (f - h) / (d || 1), a && (i = Math.floor(i)), h += (f - h - i * (t - s)) * l, r = i * (1 - s), a && (h = Math.round(h), r = Math.round(r));
                     const p = (0, Wo.Z)(t).map((t => h + i * t));
                     return n(u ? p.reverse() : p)
                 }
                 return delete t.unknown, t.domain = function(t) {
                     return arguments.length ? (e(t), u()) : e()
@@ -26947,40 +27311,44 @@
                 }, t.invertRange = function(t) {
                     if (null == t[0] || null == t[1]) return;
                     const i = o[1] < o[0],
                         a = i ? n().reverse() : n(),
                         s = a.length - 1;
                     let c, l, u, f = +t[0],
                         d = +t[1];
-                    return f !== f || d !== d || (d < f && (u = f, f = d, d = u), d < a[0] || f > o[1 - i]) ? void 0 : (c = Math.max(0, (0, Gc.ml)(a, f) - 1), l = f === d ? c : (0, Gc.ml)(a, d) - 1, f - a[c] > r + 1e-10 && ++c, i && (u = c, c = s - l, l = s - u), c > l ? void 0 : e().slice(c, l + 1))
+                    return f !== f || d !== d || (d < f && (u = f, f = d, d = u), d < a[0] || f > o[1 - i]) ? void 0 : (c = Math.max(0, (0, ol.ml)(a, f) - 1), l = f === d ? c : (0, ol.ml)(a, d) - 1, f - a[c] > r + 1e-10 && ++c, i && (u = c, c = s - l, l = s - u), c > l ? void 0 : e().slice(c, l + 1))
                 }, t.invert = function(e) {
                     const n = t.invertRange([e, e]);
                     return n ? n[0] : n
                 }, t.copy = function() {
-                    return Ku().domain(e()).range(o).round(a).paddingInner(s).paddingOuter(c).align(l)
+                    return wf().domain(e()).range(o).round(a).paddingInner(s).paddingOuter(c).align(l)
                 }, u()
             }
 
-            function Qu(t) {
+            function kf(t) {
                 const e = t.copy;
                 return t.padding = t.paddingOuter, delete t.paddingInner, t.copy = function() {
-                    return Qu(e())
+                    return kf(e())
                 }, t
             }
-            var tf = Array.prototype.map;
-            const ef = Array.prototype.slice;
-            const nf = new Map,
-                rf = Symbol("vega_scale");
+            var Ef = Array.prototype.map;
+            const Af = Array.prototype.slice;
+            const Df = new Map,
+                Sf = Symbol("vega_scale");
 
-            function of(t) {
-                return t[rf] = !0, t
+            function Cf(t) {
+                return t[Sf] = !0, t
+            }
+
+            function Mf(t) {
+                return t && !0 === t[Sf]
             }
 
-            function af(t, e, n) {
-                return arguments.length > 1 ? (nf.set(t, function(t, e, n) {
+            function Ff(t, e, n) {
+                return arguments.length > 1 ? (Df.set(t, function(t, e, n) {
                     const i = function() {
                         const n = e();
                         return n.invertRange || (n.invertRange = n.invert ? function(t) {
                             return function(e) {
                                 let n, i = e[0],
                                     r = e[1];
                                 return r < i && (n = i, i = r, r = n), [t.invert(i), t.invert(r)]
@@ -26990,189 +27358,113 @@
                                 const n = t.range();
                                 let i, r, o, a, s = e[0],
                                     c = e[1],
                                     l = -1;
                                 for (c < s && (r = s, s = c, c = r), o = 0, a = n.length; o < a; ++o) n[o] >= s && n[o] <= c && (l < 0 && (l = o), i = o);
                                 if (!(l < 0)) return s = t.invertExtent(n[l]), c = t.invertExtent(n[i]), [void 0 === s[0] ? s[1] : s[0], void 0 === c[1] ? c[0] : c[1]]
                             }
-                        }(n) : void 0), n.type = t, of(n)
+                        }(n) : void 0), n.type = t, Cf(n)
                     };
                     return i.metadata = (0, m.Rg)((0, m.IX)(n)), i
-                }(t, e, n)), this) : sf(t) ? nf.get(t) : void 0
-            }
-
-            function sf(t) {
-                return nf.has(t)
+                }(t, e, n)), this) : function(t) {
+                    return Df.has(t)
+                }(t) ? Df.get(t) : void 0
             }
 
-            function cf(t, e) {
-                const n = nf.get(t);
+            function Of(t, e) {
+                const n = Df.get(t);
                 return n && n.metadata[e]
             }
 
-            function lf(t) {
-                return cf(t, Gu)
-            }
-
-            function uf(t) {
-                return cf(t, $u)
-            }
-
-            function ff(t) {
-                return cf(t, Zu)
+            function Tf(t) {
+                return Of(t, vf)
             }
 
-            function df(t) {
-                return cf(t, Tu)
+            function Nf(t) {
+                return Of(t, yf)
             }
 
-            function hf(t) {
-                return cf(t, Yu)
+            function Rf(t) {
+                return Of(t, ef)
             }
 
-            function pf(t) {
-                return cf(t, Iu)
+            function zf(t) {
+                return Of(t, xf)
             }
-            af("identity", (function t(e) {
-                var n;
-
-                function i(t) {
-                    return null == t || isNaN(t = +t) ? n : t
-                }
-                return i.invert = i, i.domain = i.range = function(t) {
-                    return arguments.length ? (e = Array.from(t, Zc.Z), i) : e.slice()
-                }, i.unknown = function(t) {
-                    return arguments.length ? (n = t, i) : n
-                }, i.copy = function() {
-                    return t(e).unknown(n)
-                }, e = arguments.length ? Array.from(e, Zc.Z) : [0, 1], (0, $c.Q)(i)
-            })), af(Ou, $c.Z, Gu), af(Tu, Yc.Z, [Gu, Tu]), af(Nu, Vc.ZP, Gu), af(zu, Vc._b, Gu), af(Ru, (function t() {
-                var e = nl((0, Kc.l4)());
-                return e.copy = function() {
-                    return (0, Kc.JG)(e, t()).constant(e.constant())
-                }, Qc.o.apply(e, arguments)
-            }), Gu), af(Pu, (function() {
-                return Qc.o.apply(fl(al, sl, mt, vt, tt, Y, bt, _t, kt, Ie).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
-            }), [Gu, Vu]), af(Lu, (function() {
-                return Qc.o.apply(fl(rl, ol, gt, yt, ct, V, xt, wt, kt, qe).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
-            }), [Gu, Vu]), af(ju, gl, [Gu, Yu]), af("".concat(ju, "-").concat(Ou), gl, [Gu, Yu]), af("".concat(ju, "-").concat(Tu), (function t() {
-                var e = (0, Yc.Q)(pl()).domain([1, 10]);
-                return e.copy = function() {
-                    return ml(e, t()).base(e.base())
-                }, Qc.O.apply(e, arguments)
-            }), [Gu, Yu, Tu]), af("".concat(ju, "-").concat(Nu), vl, [Gu, Yu]), af("".concat(ju, "-").concat(zu), (function() {
-                return vl.apply(null, arguments).exponent(.5)
-            }), [Gu, Yu]), af("".concat(ju, "-").concat(Ru), (function t() {
-                var e = nl(pl());
-                return e.copy = function() {
-                    return ml(e, t()).constant(e.constant())
-                }, Qc.O.apply(e, arguments)
-            }), [Gu, Yu]), af("".concat(Bu, "-").concat(Ou), (function t() {
-                var e = (0, $c.Q)(bl()(Kc.yR));
-                return e.copy = function() {
-                    return ml(e, t())
-                }, Qc.O.apply(e, arguments)
-            }), [Gu, Yu]), af("".concat(Bu, "-").concat(Tu), (function t() {
-                var e = (0, Yc.Q)(bl()).domain([.1, 1, 10]);
-                return e.copy = function() {
-                    return ml(e, t()).base(e.base())
-                }, Qc.O.apply(e, arguments)
-            }), [Gu, Yu, Tu]), af("".concat(Bu, "-").concat(Nu), xl, [Gu, Yu]), af("".concat(Bu, "-").concat(zu), (function() {
-                return xl.apply(null, arguments).exponent(.5)
-            }), [Gu, Yu]), af("".concat(Bu, "-").concat(Ru), (function t() {
-                var e = nl(bl());
-                return e.copy = function() {
-                    return ml(e, t()).constant(e.constant())
-                }, Qc.O.apply(e, arguments)
-            }), [Gu, Yu]), af(Iu, _l.Z, [Zu, Iu]), af(Uu, wl.Z, Zu), af(qu, kl.Z, Zu), af(Ju, (function t() {
+            Ff("identity", cl), Ff(tf, al.Z, vf), Ff(ef, ll.Z, [vf, ef]), Ff(nf, ul.ZP, vf), Ff(rf, ul._b, vf), Ff(of, gl, vf), Ff(af, Dl, [vf, _f]), Ff(sf, Sl, [vf, _f]), Ff(cf, Tl, [vf, xf]), Ff("".concat(cf, "-").concat(tf), Tl, [vf, xf]), Ff("".concat(cf, "-").concat(ef), Nl, [vf, xf, ef]), Ff("".concat(cf, "-").concat(nf), zl, [vf, xf]), Ff("".concat(cf, "-").concat(rf), Pl, [vf, xf]), Ff("".concat(cf, "-").concat(of), Rl, [vf, xf]), Ff("".concat(lf, "-").concat(tf), Il, [vf, xf]), Ff("".concat(lf, "-").concat(ef), jl, [vf, xf, ef]), Ff("".concat(lf, "-").concat(nf), ql, [vf, xf]), Ff("".concat(lf, "-").concat(rf), Wl, [vf, xf]), Ff("".concat(lf, "-").concat(of), Ul, [vf, xf]), Ff(uf, Hl.Z, [bf, uf]), Ff(ff, Xl.Z, bf), Ff(df, Gl.Z, bf), Ff(gf, (function t() {
                 let e = [],
                     n = [];
 
                 function i(t) {
-                    return null == t || t !== t ? void 0 : n[((0, Gc.ZP)(e, t) - 1) % n.length]
+                    return null == t || t !== t ? void 0 : n[((0, ol.ZP)(e, t) - 1) % n.length]
                 }
                 return i.domain = function(t) {
                     return arguments.length ? (e = function(t) {
-                        return tf.call(t, m.He)
+                        return Ef.call(t, m.He)
                     }(t), i) : e.slice()
                 }, i.range = function(t) {
-                    return arguments.length ? (n = ef.call(t), i) : n.slice()
+                    return arguments.length ? (n = Af.call(t), i) : n.slice()
                 }, i.tickFormat = function(t, n) {
-                    return (0, Dl.Z)(e[0], (0, m.fj)(e), null == t ? 10 : t, n)
+                    return (0, Zl.Z)(e[0], (0, m.fj)(e), null == t ? 10 : t, n)
                 }, i.copy = function() {
                     return t().domain(i.domain()).range(i.range())
                 }, i
-            }), [$u, Zu]), af(Wu, El.Z, $u), af(Xu, Ku, $u), af(Hu, (function() {
-                return Qu(Ku().paddingInner(1))
-            }), $u);
-            const mf = ["clamp", "base", "constant", "exponent"];
-
-            function gf(t, e) {
-                const n = e[0],
-                    i = (0, m.fj)(e) - n;
-                return function(e) {
-                    return t(n + e * i)
-                }
-            }
+            }), [yf, bf]), Ff(hf, Jl.Z, yf), Ff(mf, wf, yf), Ff(pf, (function() {
+                return kf(wf().paddingInner(1))
+            }), yf);
+            const Pf = ["clamp", "base", "constant", "exponent"];
 
-            function vf(t, e, n) {
-                return yl(xf(e || "rgb", n), t)
+            function Lf(t, e, n) {
+                return Ll(If(e || "rgb", n), t)
             }
 
-            function yf(t, e) {
-                const n = new Array(e),
-                    i = e + 1;
-                for (let r = 0; r < e;) n[r] = t(++r / i);
-                return n
-            }
-
-            function bf(t, e, n) {
+            function Bf(t, e, n) {
                 const i = n - e;
                 let r, o, a;
-                return i && Number.isFinite(i) ? (r = (o = t.type).indexOf("-"), o = r < 0 ? o : o.slice(r + 1), a = af(o)().domain([e, n]).range([0, 1]), mf.forEach((e => t[e] ? a[e](t[e]()) : 0)), a) : (0, m.a9)(.5)
+                return i && Number.isFinite(i) ? (r = (o = t.type).indexOf("-"), o = r < 0 ? o : o.slice(r + 1), a = Ff(o)().domain([e, n]).range([0, 1]), Pf.forEach((e => t[e] ? a[e](t[e]()) : 0)), a) : (0, m.a9)(.5)
             }
 
-            function xf(t, e) {
+            function If(t, e) {
                 const n = r[function(t) {
                     return "interpolate" + t.toLowerCase().split("-").map((t => t[0].toUpperCase() + t.slice(1))).join("")
                 }(t)];
                 return null != e && n && n.gamma ? n.gamma(e) : n
             }
 
-            function _f(t) {
+            function jf(t) {
                 const e = t.length / 6 | 0,
                     n = new Array(e);
                 for (let i = 0; i < e;) n[i] = "#" + t.slice(6 * i, 6 * ++i);
                 return n
             }
 
-            function wf(t, e) {
-                for (const n in t) Ef(n, e(t[n]))
+            function Uf(t, e) {
+                for (const n in t) Wf(n, e(t[n]))
             }
-            const kf = {};
+            const qf = {};
 
-            function Ef(t, e) {
-                return t = t && t.toLowerCase(), arguments.length > 1 ? (kf[t] = e, this) : kf[t]
+            function Wf(t, e) {
+                return t = t && t.toLowerCase(), arguments.length > 1 ? (qf[t] = e, this) : qf[t]
             }
-            wf({
+            Uf({
                 category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
                 category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
                 category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
                 category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
                 tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
                 tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
                 accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
                 dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
                 paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
                 pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
                 pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
                 set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
                 set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
                 set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
-            }, _f), wf({
+            }, jf), Uf({
                 blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
                 greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
                 greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
                 oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
                 purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
                 reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
                 blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
@@ -27218,158 +27510,158 @@
                 lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
                 lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
                 darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
                 darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
                 darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
                 darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
                 darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
-            }, (t => vf(_f(t))));
-            const Df = "symbol",
-                Af = "discrete",
-                Sf = t => (0, m.kJ)(t) ? t.map((t => String(t))) : String(t),
-                Cf = (t, e) => t[1] - e[1],
-                Ff = (t, e) => e[1] - t[1];
+            }, (t => Lf(jf(t))));
+            const Hf = "symbol",
+                Xf = "discrete",
+                Gf = t => (0, m.kJ)(t) ? t.map((t => String(t))) : String(t),
+                Jf = (t, e) => t[1] - e[1],
+                Zf = (t, e) => e[1] - t[1];
 
-            function Mf(t, e, n) {
+            function $f(t, e, n) {
                 let i;
-                return (0, m.hj)(e) && (t.bins && (e = Math.max(e, t.bins.length)), null != n && (e = Math.min(e, Math.floor((0, m.yP)(t.domain()) / n || 1)))), (0, m.Kn)(e) && (i = e.step, e = e.interval), (0, m.HD)(e) && (e = t.type === Pu ? de(e) : t.type == Lu ? he(e) : (0, m.vU)("Only time and utc scales accept interval strings."), i && (e = e.every(i))), e
+                return (0, m.hj)(e) && (t.bins && (e = Math.max(e, t.bins.length)), null != n && (e = Math.min(e, Math.floor((0, m.yP)(t.domain()) / n || 1)))), (0, m.Kn)(e) && (i = e.step, e = e.interval), (0, m.HD)(e) && (e = t.type === af ? de(e) : t.type == sf ? he(e) : (0, m.vU)("Only time and utc scales accept interval strings."), i && (e = e.every(i))), e
             }
 
-            function Of(t, e, n) {
+            function Yf(t, e, n) {
                 let i = t.range(),
                     r = i[0],
                     o = (0, m.fj)(i),
-                    a = Cf;
-                if (r > o && (i = o, o = r, r = i, a = Ff), r = Math.floor(r), o = Math.ceil(o), e = e.map((e => [e, t(e)])).filter((t => r <= t[1] && t[1] <= o)).sort(a).map((t => t[0])), n > 0 && e.length > 1) {
+                    a = Jf;
+                if (r > o && (i = o, o = r, r = i, a = Zf), r = Math.floor(r), o = Math.ceil(o), e = e.map((e => [e, t(e)])).filter((t => r <= t[1] && t[1] <= o)).sort(a).map((t => t[0])), n > 0 && e.length > 1) {
                     const t = [e[0], (0, m.fj)(e)];
                     for (; e.length > n && e.length >= 3;) e = e.filter(((t, e) => !(e % 2)));
                     e.length < 3 && (e = t)
                 }
                 return e
             }
 
-            function Tf(t, e) {
-                return t.bins ? Of(t, t.bins) : t.ticks ? t.ticks(e) : t.domain()
+            function Vf(t, e) {
+                return t.bins ? Yf(t, t.bins) : t.ticks ? t.ticks(e) : t.domain()
             }
 
-            function Nf(t, e, n, i, r, o) {
+            function Kf(t, e, n, i, r, o) {
                 const a = e.type;
-                let s = Sf;
-                if (a === Pu || r === Pu) s = t.timeFormat(i);
-                else if (a === Lu || r === Lu) s = t.utcFormat(i);
-                else if (df(a)) {
+                let s = Gf;
+                if (a === af || r === af) s = t.timeFormat(i);
+                else if (a === sf || r === sf) s = t.utcFormat(i);
+                else if (Rf(a)) {
                     const r = t.formatFloat(i);
                     if (o || e.bins) s = r;
                     else {
-                        const t = zf(e, n, !1);
+                        const t = Qf(e, n, !1);
                         s = e => t(e) ? r(e) : ""
                     }
                 } else if (e.tickFormat) {
                     const r = e.domain();
                     s = t.formatSpan(r[0], r[r.length - 1], n, i)
                 } else i && (s = t.format(i));
                 return s
             }
 
-            function zf(t, e, n) {
-                const i = Tf(t, e),
+            function Qf(t, e, n) {
+                const i = Vf(t, e),
                     r = t.base(),
                     o = Math.log(r),
                     a = Math.max(1, r * e / i.length),
                     s = t => {
                         let e = t / Math.pow(r, Math.round(Math.log(t) / o));
                         return e * r < r - .5 && (e *= r), e <= a
                     };
                 return n ? i.filter(s) : s
             }
-            const Rf = {
-                    [Iu]: "quantiles",
-                    [Uu]: "thresholds",
-                    [qu]: "domain"
-                },
-                Pf = {
-                    [Iu]: "quantiles",
-                    [Uu]: "domain"
+            const td = {
+                    [uf]: "quantiles",
+                    [ff]: "thresholds",
+                    [df]: "domain"
+                },
+                ed = {
+                    [uf]: "quantiles",
+                    [ff]: "domain"
                 };
 
-            function Lf(t, e) {
+            function nd(t, e) {
                 return t.bins ? function(t) {
                     const e = t.slice(0, -1);
                     return e.max = (0, m.fj)(t), e
-                }(t.bins) : t.type === Tu ? zf(t, e, !0) : Rf[t.type] ? function(t) {
+                }(t.bins) : t.type === ef ? Qf(t, e, !0) : td[t.type] ? function(t) {
                     const e = [-1 / 0].concat(t);
                     return e.max = 1 / 0, e
-                }(t[Rf[t.type]]()) : Tf(t, e)
+                }(t[td[t.type]]()) : Vf(t, e)
             }
-            const jf = t => Rf[t.type] || t.bins;
+            const id = t => td[t.type] || t.bins;
 
-            function Bf(t, e, n, i, r, o, a) {
-                const s = Pf[e.type] && o !== Pu && o !== Lu ? function(t, e, n) {
-                    const i = e[Pf[e.type]](),
+            function rd(t, e, n, i, r, o, a) {
+                const s = ed[e.type] && o !== af && o !== sf ? function(t, e, n) {
+                    const i = e[ed[e.type]](),
                         r = i.length;
                     let o, a = r > 1 ? i[1] - i[0] : i[0];
                     for (o = 1; o < r; ++o) a = Math.min(a, i[o] - i[o - 1]);
                     return t.formatSpan(0, a, 30, n)
-                }(t, e, r) : Nf(t, e, n, r, o, a);
-                return i === Df && jf(e) ? If(s) : i === Af ? qf(s) : Wf(s)
+                }(t, e, r) : Kf(t, e, n, r, o, a);
+                return i === Hf && id(e) ? od(s) : i === Xf ? sd(s) : cd(s)
             }
-            const If = t => (e, n, i) => {
-                    const r = Uf(i[n + 1], Uf(i.max, 1 / 0)),
-                        o = Hf(e, t),
-                        a = Hf(r, t);
+            const od = t => (e, n, i) => {
+                    const r = ad(i[n + 1], ad(i.max, 1 / 0)),
+                        o = ld(e, t),
+                        a = ld(r, t);
                     return o && a ? o + " \u2013 " + a : a ? "< " + a : "\u2265 " + o
                 },
-                Uf = (t, e) => null != t ? t : e,
-                qf = t => (e, n) => n ? t(e) : null,
-                Wf = t => e => t(e),
-                Hf = (t, e) => Number.isFinite(t) ? e(t) : null;
+                ad = (t, e) => null != t ? t : e,
+                sd = t => (e, n) => n ? t(e) : null,
+                cd = t => e => t(e),
+                ld = (t, e) => Number.isFinite(t) ? e(t) : null;
 
-            function Xf(t, e, n, i) {
+            function ud(t, e, n, i) {
                 const r = i || e.type;
-                return (0, m.HD)(n) && cf(r, Vu) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), n || r !== Pu ? n || r !== Lu ? Bf(t, e, 5, null, n, i, !0) : t.utcFormat("%A, %d %B %Y, %X UTC") : t.timeFormat("%A, %d %B %Y, %X")
+                return (0, m.HD)(n) && Of(r, _f) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), n || r !== af ? n || r !== sf ? rd(t, e, 5, null, n, i, !0) : t.utcFormat("%A, %d %B %Y, %X UTC") : t.timeFormat("%A, %d %B %Y, %X")
             }
 
-            function Jf(t, e, n) {
+            function fd(t, e, n) {
                 n = n || {};
                 const i = Math.max(3, n.maxlen || 7),
-                    r = Xf(t, e, n.format, n.formatType);
-                if (ff(e.type)) {
-                    const t = Lf(e).slice(1).map(r),
+                    r = ud(t, e, n.format, n.formatType);
+                if (Of(e.type, bf)) {
+                    const t = nd(e).slice(1).map(r),
                         n = t.length;
                     return "".concat(n, " boundar").concat(1 === n ? "y" : "ies", ": ").concat(t.join(", "))
                 }
-                if (uf(e.type)) {
+                if (Nf(e.type)) {
                     const t = e.domain(),
                         n = t.length,
                         o = n > i ? t.slice(0, i - 2).map(r).join(", ") + ", ending with " + t.slice(-1).map(r) : t.map(r).join(", ");
                     return "".concat(n, " value").concat(1 === n ? "" : "s", ": ").concat(o)
                 } {
                     const t = e.domain();
                     return "values from ".concat(r(t[0]), " to ").concat(r((0, m.fj)(t)))
                 }
             }
-            let Gf = 0;
-            const $f = "p_";
+            let dd = 0;
+            const hd = "p_";
 
-            function Zf(t) {
+            function pd(t) {
                 return t && t.gradient
             }
 
-            function Yf(t, e, n) {
+            function md(t, e, n) {
                 const i = t.gradient;
                 let r = t.id,
-                    o = "radial" === i ? $f : "";
-                return r || (r = t.id = "gradient_" + Gf++, "radial" === i ? (t.x1 = Vf(t.x1, .5), t.y1 = Vf(t.y1, .5), t.r1 = Vf(t.r1, 0), t.x2 = Vf(t.x2, .5), t.y2 = Vf(t.y2, .5), t.r2 = Vf(t.r2, .5), o = $f) : (t.x1 = Vf(t.x1, 0), t.y1 = Vf(t.y1, 0), t.x2 = Vf(t.x2, 1), t.y2 = Vf(t.y2, 0))), e[r] = t, "url(" + (n || "") + "#" + o + r + ")"
+                    o = "radial" === i ? hd : "";
+                return r || (r = t.id = "gradient_" + dd++, "radial" === i ? (t.x1 = gd(t.x1, .5), t.y1 = gd(t.y1, .5), t.r1 = gd(t.r1, 0), t.x2 = gd(t.x2, .5), t.y2 = gd(t.y2, .5), t.r2 = gd(t.r2, .5), o = hd) : (t.x1 = gd(t.x1, 0), t.y1 = gd(t.y1, 0), t.x2 = gd(t.x2, 1), t.y2 = gd(t.y2, 0))), e[r] = t, "url(" + (n || "") + "#" + o + r + ")"
             }
 
-            function Vf(t, e) {
+            function gd(t, e) {
                 return null != t ? t : e
             }
 
-            function Kf(t, e) {
+            function vd(t, e) {
                 var n, i = [];
                 return n = {
                     gradient: "linear",
                     x1: t ? t[0] : 0,
                     y1: t ? t[1] : 0,
                     x2: e ? e[0] : 1,
                     y2: e ? e[1] : 0,
@@ -27378,163 +27670,143 @@
                         return i.push({
                             offset: t,
                             color: e
                         }), n
                     }
                 }
             }
-            const Qf = {
+            const yd = {
                 basis: {
-                    curve: function(t) {
-                        return new vs(t)
-                    }
+                    curve: ys
                 },
                 "basis-closed": {
-                    curve: function(t) {
-                        return new bs(t)
-                    }
+                    curve: _s
                 },
                 "basis-open": {
-                    curve: function(t) {
-                        return new xs(t)
-                    }
+                    curve: ks
                 },
                 bundle: {
-                    curve: ws,
+                    curve: As,
                     tension: "beta",
                     value: .85
                 },
                 cardinal: {
-                    curve: Ds,
+                    curve: Cs,
                     tension: "tension",
                     value: 0
                 },
                 "cardinal-open": {
-                    curve: Ss,
+                    curve: Fs,
                     tension: "tension",
                     value: 0
                 },
                 "cardinal-closed": {
-                    curve: Fs,
+                    curve: Ts,
                     tension: "tension",
                     value: 0
                 },
                 "catmull-rom": {
-                    curve: Hs,
+                    curve: Js,
                     tension: "alpha",
                     value: .5
                 },
                 "catmull-rom-closed": {
-                    curve: Js,
+                    curve: $s,
                     tension: "alpha",
                     value: .5
                 },
                 "catmull-rom-open": {
-                    curve: $s,
+                    curve: Vs,
                     tension: "alpha",
                     value: .5
                 },
                 linear: {
-                    curve: Ys
+                    curve: Qs
                 },
                 "linear-closed": {
-                    curve: function(t) {
-                        return new Vs(t)
-                    }
+                    curve: ec
                 },
                 monotone: {
-                    horizontal: function(t) {
-                        return new ic(t)
-                    },
-                    vertical: function(t) {
-                        return new nc(t)
-                    }
+                    horizontal: uc,
+                    vertical: lc
                 },
                 natural: {
-                    curve: function(t) {
-                        return new oc(t)
-                    }
+                    curve: hc
                 },
                 step: {
-                    curve: function(t) {
-                        return new sc(t, .5)
-                    }
+                    curve: mc
                 },
                 "step-after": {
-                    curve: function(t) {
-                        return new sc(t, 1)
-                    }
+                    curve: vc
                 },
                 "step-before": {
-                    curve: function(t) {
-                        return new sc(t, 0)
-                    }
+                    curve: gc
                 }
             };
 
-            function td(t, e, n) {
-                var i = (0, m.nr)(Qf, t) && Qf[t],
+            function bd(t, e, n) {
+                var i = (0, m.nr)(yd, t) && yd[t],
                     r = null;
                 return i && (r = i.curve || i[e || "vertical"], i.tension && null != n && (r = r[i.tension](n))), r
             }
-            const ed = {
+            const xd = {
                     m: 2,
                     l: 2,
                     h: 1,
                     v: 1,
                     z: 0,
                     c: 6,
                     s: 4,
                     q: 4,
                     t: 2,
                     a: 7
                 },
-                nd = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
-                id = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
-                rd = /^((\s+,?\s*)|(,\s*))/,
-                od = /^[01]/;
+                _d = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
+                wd = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
+                kd = /^((\s+,?\s*)|(,\s*))/,
+                Ed = /^[01]/;
 
-            function ad(t) {
+            function Ad(t) {
                 const e = [];
-                return (t.match(nd) || []).forEach((t => {
+                return (t.match(_d) || []).forEach((t => {
                     let n = t[0];
                     const i = n.toLowerCase(),
-                        r = ed[i],
+                        r = xd[i],
                         o = function(t, e, n) {
                             const i = [];
                             for (let r = 0; e && r < n.length;)
                                 for (let o = 0; o < e; ++o) {
-                                    const e = "a" !== t || 3 !== o && 4 !== o ? id : od,
+                                    const e = "a" !== t || 3 !== o && 4 !== o ? wd : Ed,
                                         a = n.slice(r).match(e);
                                     if (null === a) throw Error("Invalid SVG path, incorrect parameter type");
                                     r += a[0].length, i.push(+a[0]);
-                                    const s = n.slice(r).match(rd);
+                                    const s = n.slice(r).match(kd);
                                     null !== s && (r += s[0].length)
                                 }
                             return i
                         }(i, r, t.slice(1).trim()),
                         a = o.length;
                     if (a < r || a && a % r !== 0) throw Error("Invalid SVG path, incorrect parameter count");
                     if (e.push([n, ...o.slice(0, r)]), a !== r) {
                         "m" === i && (n = "M" === n ? "L" : "l");
                         for (let t = r; t < a; t += r) e.push([n, ...o.slice(t, t + r)])
                     }
                 })), e
             }
-            const sd = Math.PI / 180,
-                cd = Math.PI / 2,
-                ld = 2 * Math.PI,
-                ud = Math.sqrt(3) / 2;
-            var fd = {},
-                dd = {},
-                hd = [].join;
-
-            function pd(t) {
-                const e = hd.call(t);
-                if (dd[e]) return dd[e];
+            const Dd = Math.PI / 180,
+                Sd = Math.PI / 2,
+                Cd = 2 * Math.PI,
+                Md = Math.sqrt(3) / 2;
+            var Fd = {},
+                Od = {},
+                Td = [].join;
+
+            function Nd(t) {
+                const e = Td.call(t);
+                if (Od[e]) return Od[e];
                 var n = t[0],
                     i = t[1],
                     r = t[2],
                     o = t[3],
                     a = t[4],
                     s = t[5],
                     c = t[6],
@@ -27550,41 +27822,41 @@
                     y = .5 * (o - r),
                     b = Math.sin(.5 * y),
                     x = 8 / 3 * b * b / Math.sin(y),
                     _ = n + p - x * m,
                     w = i + m + x * p,
                     k = n + g,
                     E = i + v,
-                    D = k + x * v,
-                    A = E - x * g;
-                return dd[e] = [u * _ + f * w, d * _ + h * w, u * D + f * A, d * D + h * A, u * k + f * E, d * k + h * E]
-            }
-            const md = ["l", 0, 0, 0, 0, 0, 0, 0];
-
-            function gd(t, e, n) {
-                const i = md[0] = t[0];
-                if ("a" === i || "A" === i) md[1] = e * t[1], md[2] = n * t[2], md[3] = t[3], md[4] = t[4], md[5] = t[5], md[6] = e * t[6], md[7] = n * t[7];
-                else if ("h" === i || "H" === i) md[1] = e * t[1];
-                else if ("v" === i || "V" === i) md[1] = n * t[1];
+                    A = k + x * v,
+                    D = E - x * g;
+                return Od[e] = [u * _ + f * w, d * _ + h * w, u * A + f * D, d * A + h * D, u * k + f * E, d * k + h * E]
+            }
+            const Rd = ["l", 0, 0, 0, 0, 0, 0, 0];
+
+            function zd(t, e, n) {
+                const i = Rd[0] = t[0];
+                if ("a" === i || "A" === i) Rd[1] = e * t[1], Rd[2] = n * t[2], Rd[3] = t[3], Rd[4] = t[4], Rd[5] = t[5], Rd[6] = e * t[6], Rd[7] = n * t[7];
+                else if ("h" === i || "H" === i) Rd[1] = e * t[1];
+                else if ("v" === i || "V" === i) Rd[1] = n * t[1];
                 else
-                    for (var r = 1, o = t.length; r < o; ++r) md[r] = (r % 2 == 1 ? e : n) * t[r];
-                return md
+                    for (var r = 1, o = t.length; r < o; ++r) Rd[r] = (r % 2 == 1 ? e : n) * t[r];
+                return Rd
             }
 
-            function vd(t, e, n, i, r, o) {
+            function Pd(t, e, n, i, r, o) {
                 var a, s, c, l, u, f = null,
                     d = 0,
                     h = 0,
                     p = 0,
                     m = 0,
                     g = 0,
                     v = 0;
                 null == n && (n = 0), null == i && (i = 0), null == r && (r = 1), null == o && (o = r), t.beginPath && t.beginPath();
                 for (var y = 0, b = e.length; y < b; ++y) {
-                    switch (a = e[y], 1 === r && 1 === o || (a = gd(a, r, o)), a[0]) {
+                    switch (a = e[y], 1 === r && 1 === o || (a = zd(a, r, o)), a[0]) {
                         case "l":
                             d += a[1], h += a[2], t.lineTo(d + n, h + i);
                             break;
                         case "L":
                             d = a[1], h = a[2], t.lineTo(d + n, h + i);
                             break;
                         case "h":
@@ -27626,32 +27898,32 @@
                         case "t":
                             s = d + a[1], c = h + a[2], null === f[0].match(/[QqTt]/) ? (p = d, m = h) : "t" === f[0] ? (p = 2 * d - l, m = 2 * h - u) : "q" === f[0] && (p = 2 * d - p, m = 2 * h - m), l = p, u = m, t.quadraticCurveTo(p + n, m + i, s + n, c + i), h = c, p = (d = s) + a[1], m = h + a[2];
                             break;
                         case "T":
                             s = a[1], c = a[2], p = 2 * d - p, m = 2 * h - m, t.quadraticCurveTo(p + n, m + i, s + n, c + i), d = s, h = c;
                             break;
                         case "a":
-                            yd(t, d + n, h + i, [a[1], a[2], a[3], a[4], a[5], a[6] + d + n, a[7] + h + i]), d += a[6], h += a[7];
+                            Ld(t, d + n, h + i, [a[1], a[2], a[3], a[4], a[5], a[6] + d + n, a[7] + h + i]), d += a[6], h += a[7];
                             break;
                         case "A":
-                            yd(t, d + n, h + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), d = a[6], h = a[7];
+                            Ld(t, d + n, h + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), d = a[6], h = a[7];
                             break;
                         case "z":
                         case "Z":
                             d = g, h = v, t.closePath()
                     }
                     f = a
                 }
             }
 
-            function yd(t, e, n, i) {
+            function Ld(t, e, n, i) {
                 const r = function(t, e, n, i, r, o, a, s, c) {
-                    const l = hd.call(arguments);
-                    if (fd[l]) return fd[l];
-                    const u = a * sd,
+                    const l = Td.call(arguments);
+                    if (Fd[l]) return Fd[l];
+                    const u = a * Dd,
                         f = Math.sin(u),
                         d = Math.cos(u),
                         h = d * (s - t) * .5 + f * (c - e) * .5,
                         p = d * (c - e) * .5 - f * (s - t) * .5;
                     let m = h * h / ((n = Math.abs(n)) * n) + p * p / ((i = Math.abs(i)) * i);
                     m > 1 && (m = Math.sqrt(m), n *= m, i *= m);
                     const g = d / n,
@@ -27660,41 +27932,41 @@
                         b = d / i,
                         x = g * s + v * c,
                         _ = y * s + b * c,
                         w = g * t + v * e,
                         k = y * t + b * e;
                     let E = 1 / ((w - x) * (w - x) + (k - _) * (k - _)) - .25;
                     E < 0 && (E = 0);
-                    let D = Math.sqrt(E);
-                    o == r && (D = -D);
-                    const A = .5 * (x + w) - D * (k - _),
-                        S = .5 * (_ + k) + D * (w - x),
-                        C = Math.atan2(_ - S, x - A);
-                    let F = Math.atan2(k - S, w - A) - C;
-                    F < 0 && 1 === o ? F += ld : F > 0 && 0 === o && (F -= ld);
-                    const M = Math.ceil(Math.abs(F / (cd + .001))),
+                    let A = Math.sqrt(E);
+                    o == r && (A = -A);
+                    const D = .5 * (x + w) - A * (k - _),
+                        S = .5 * (_ + k) + A * (w - x),
+                        C = Math.atan2(_ - S, x - D);
+                    let M = Math.atan2(k - S, w - D) - C;
+                    M < 0 && 1 === o ? M += Cd : M > 0 && 0 === o && (M -= Cd);
+                    const F = Math.ceil(Math.abs(M / (Sd + .001))),
                         O = [];
-                    for (let T = 0; T < M; ++T) {
-                        const t = C + T * F / M,
-                            e = C + (T + 1) * F / M;
-                        O[T] = [A, S, t, e, n, i, f, d]
+                    for (let T = 0; T < F; ++T) {
+                        const t = C + T * M / F,
+                            e = C + (T + 1) * M / F;
+                        O[T] = [D, S, t, e, n, i, f, d]
                     }
-                    return fd[l] = O
+                    return Fd[l] = O
                 }(i[5], i[6], i[0], i[1], i[3], i[4], i[2], e, n);
                 for (let o = 0; o < r.length; ++o) {
-                    const e = pd(r[o]);
+                    const e = Nd(r[o]);
                     t.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5])
                 }
             }
-            const bd = .5773502691896257,
-                xd = {
+            const Bd = .5773502691896257,
+                Id = {
                     circle: {
                         draw: function(t, e) {
                             const n = Math.sqrt(e) / 2;
-                            t.moveTo(n, 0), t.arc(0, 0, n, 0, ld)
+                            t.moveTo(n, 0), t.arc(0, 0, n, 0, Cd)
                         }
                     },
                     cross: {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
                                 i = n / 2.5;
                             t.moveTo(-n, -i), t.lineTo(-n, i), t.lineTo(-i, i), t.lineTo(-i, n), t.lineTo(i, n), t.lineTo(i, i), t.lineTo(n, i), t.lineTo(n, -i), t.lineTo(i, -i), t.lineTo(i, -n), t.lineTo(-i, -n), t.lineTo(-i, -i), t.closePath()
@@ -27721,367 +27993,252 @@
                                 o = n / 8;
                             t.moveTo(-i, n), t.lineTo(i, n), t.lineTo(i, -o), t.lineTo(r, -o), t.lineTo(0, -n), t.lineTo(-r, -o), t.lineTo(-i, -o), t.closePath()
                         }
                     },
                     wedge: {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
-                                i = ud * n,
-                                r = i - n * bd,
+                                i = Md * n,
+                                r = i - n * Bd,
                                 o = n / 4;
                             t.moveTo(0, -i - r), t.lineTo(-o, i - r), t.lineTo(o, i - r), t.closePath()
                         }
                     },
                     triangle: {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
-                                i = ud * n,
-                                r = i - n * bd;
+                                i = Md * n,
+                                r = i - n * Bd;
                             t.moveTo(0, -i - r), t.lineTo(-n, i - r), t.lineTo(n, i - r), t.closePath()
                         }
                     },
                     "triangle-up": {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
-                                i = ud * n;
+                                i = Md * n;
                             t.moveTo(0, -i), t.lineTo(-n, i), t.lineTo(n, i), t.closePath()
                         }
                     },
                     "triangle-down": {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
-                                i = ud * n;
+                                i = Md * n;
                             t.moveTo(0, i), t.lineTo(-n, -i), t.lineTo(n, -i), t.closePath()
                         }
                     },
                     "triangle-right": {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
-                                i = ud * n;
+                                i = Md * n;
                             t.moveTo(i, 0), t.lineTo(-i, -n), t.lineTo(-i, n), t.closePath()
                         }
                     },
                     "triangle-left": {
                         draw: function(t, e) {
                             var n = Math.sqrt(e) / 2,
-                                i = ud * n;
+                                i = Md * n;
                             t.moveTo(-i, 0), t.lineTo(i, -n), t.lineTo(i, n), t.closePath()
                         }
                     },
                     stroke: {
                         draw: function(t, e) {
                             const n = Math.sqrt(e) / 2;
                             t.moveTo(-n, 0), t.lineTo(n, 0)
                         }
                     }
                 };
 
-            function _d(t) {
-                return (0, m.nr)(xd, t) ? xd[t] : function(t) {
-                    if (!(0, m.nr)(wd, t)) {
-                        const e = ad(t);
-                        wd[t] = {
+            function jd(t) {
+                return (0, m.nr)(Id, t) ? Id[t] : function(t) {
+                    if (!(0, m.nr)(Ud, t)) {
+                        const e = Ad(t);
+                        Ud[t] = {
                             draw: function(t, n) {
-                                vd(t, e, 0, 0, Math.sqrt(n) / 2)
+                                Pd(t, e, 0, 0, Math.sqrt(n) / 2)
                             }
                         }
                     }
-                    return wd[t]
+                    return Ud[t]
                 }(t)
             }
-            var wd = {};
-            const kd = .448084975506;
+            var Ud = {};
+            const qd = .448084975506;
 
-            function Ed(t) {
+            function Wd(t) {
                 return t.x
             }
 
-            function Dd(t) {
+            function Hd(t) {
                 return t.y
             }
 
-            function Ad(t) {
+            function Xd(t) {
                 return t.width
             }
 
-            function Sd(t) {
+            function Gd(t) {
                 return t.height
             }
 
-            function Cd(t) {
+            function Jd(t) {
                 return "function" === typeof t ? t : () => +t
             }
 
-            function Fd(t, e, n) {
+            function Zd(t, e, n) {
                 return Math.max(e, Math.min(t, n))
             }
 
-            function Md() {
-                var t = Ed,
-                    e = Dd,
-                    n = Ad,
-                    i = Sd,
-                    r = Cd(0),
-                    o = r,
-                    a = r,
-                    s = r,
-                    c = null;
-
-                function l(l, u, f) {
-                    var d, h = null != u ? u : +t.call(this, l),
-                        p = null != f ? f : +e.call(this, l),
-                        m = +n.call(this, l),
-                        g = +i.call(this, l),
-                        v = Math.min(m, g) / 2,
-                        y = Fd(+r.call(this, l), 0, v),
-                        b = Fd(+o.call(this, l), 0, v),
-                        x = Fd(+a.call(this, l), 0, v),
-                        _ = Fd(+s.call(this, l), 0, v);
-                    if (c || (c = d = Mc()), y <= 0 && b <= 0 && x <= 0 && _ <= 0) c.rect(h, p, m, g);
-                    else {
-                        var w = h + m,
-                            k = p + g;
-                        c.moveTo(h + y, p), c.lineTo(w - b, p), c.bezierCurveTo(w - kd * b, p, w, p + kd * b, w, p + b), c.lineTo(w, k - _), c.bezierCurveTo(w, k - kd * _, w - kd * _, k, w - _, k), c.lineTo(h + x, k), c.bezierCurveTo(h + kd * x, k, h, k - kd * x, h, k - x), c.lineTo(h, p + y), c.bezierCurveTo(h, p + kd * y, h + kd * y, p, h + y, p), c.closePath()
-                    }
-                    if (d) return c = null, d + "" || null
-                }
-                return l.x = function(e) {
-                    return arguments.length ? (t = Cd(e), l) : t
-                }, l.y = function(t) {
-                    return arguments.length ? (e = Cd(t), l) : e
-                }, l.width = function(t) {
-                    return arguments.length ? (n = Cd(t), l) : n
-                }, l.height = function(t) {
-                    return arguments.length ? (i = Cd(t), l) : i
-                }, l.cornerRadius = function(t, e, n, i) {
-                    return arguments.length ? (r = Cd(t), o = null != e ? Cd(e) : r, s = null != n ? Cd(n) : r, a = null != i ? Cd(i) : o, l) : r
-                }, l.context = function(t) {
-                    return arguments.length ? (c = null == t ? null : t, l) : c
-                }, l
-            }
-
-            function Od() {
-                var t, e, n, i, r, o, a, s, c = null;
-
-                function l(t, e, n) {
-                    const i = n / 2;
-                    if (r) {
-                        var l = a - e,
-                            u = t - o;
-                        if (l || u) {
-                            var f = Math.sqrt(l * l + u * u),
-                                d = (l /= f) * s,
-                                h = (u /= f) * s,
-                                p = Math.atan2(u, l);
-                            c.moveTo(o - d, a - h), c.lineTo(t - l * i, e - u * i), c.arc(t, e, i, p - Math.PI, p), c.lineTo(o + d, a + h), c.arc(o, a, s, p, p + Math.PI)
-                        } else c.arc(t, e, i, 0, ld);
-                        c.closePath()
-                    } else r = 1;
-                    o = t, a = e, s = i
-                }
-
-                function u(o) {
-                    var a, s, u, f = o.length,
-                        d = !1;
-                    for (null == c && (c = u = Mc()), a = 0; a <= f; ++a) !(a < f && i(s = o[a], a, o)) === d && (d = !d) && (r = 0), d && l(+t(s, a, o), +e(s, a, o), +n(s, a, o));
-                    if (u) return c = null, u + "" || null
-                }
-                return u.x = function(e) {
-                    return arguments.length ? (t = e, u) : t
-                }, u.y = function(t) {
-                    return arguments.length ? (e = t, u) : e
-                }, u.size = function(t) {
-                    return arguments.length ? (n = t, u) : n
-                }, u.defined = function(t) {
-                    return arguments.length ? (i = t, u) : i
-                }, u.context = function(t) {
-                    return arguments.length ? (c = null == t ? null : t, u) : c
-                }, u
-            }
-
-            function Td(t, e) {
+            function $d(t, e) {
                 return null != t ? t : e
             }
-            const Nd = t => t.x || 0,
-                zd = t => t.y || 0,
-                Rd = t => !(!1 === t.defined),
-                Pd = function() {
-                    var t = Tc,
-                        e = Nc,
-                        n = cc(0),
-                        i = null,
-                        r = zc,
-                        o = Rc,
-                        a = Pc,
-                        s = null,
-                        c = Oc(l);
-
-                    function l() {
-                        var l, u, f = +t.apply(this, arguments),
-                            d = +e.apply(this, arguments),
-                            h = r.apply(this, arguments) - Bs,
-                            p = o.apply(this, arguments) - Bs,
-                            m = Ms(p - h),
-                            g = p > h;
-                        if (s || (s = l = c()), d < f && (u = d, d = f, f = u), d > Ls)
-                            if (m > Is - Ls) s.moveTo(d * Ts(h), d * Rs(h)), s.arc(0, 0, d, h, p, !g), f > Ls && (s.moveTo(f * Ts(p), f * Rs(p)), s.arc(0, 0, f, p, h, g));
-                            else {
-                                var v, y, b = h,
-                                    x = p,
-                                    _ = h,
-                                    w = p,
-                                    k = m,
-                                    E = m,
-                                    D = a.apply(this, arguments) / 2,
-                                    A = D > Ls && (i ? +i.apply(this, arguments) : Ps(f * f + d * d)),
-                                    S = zs(Ms(d - f) / 2, +n.apply(this, arguments)),
-                                    C = S,
-                                    F = S;
-                                if (A > Ls) {
-                                    var M = Us(A / f * Rs(D)),
-                                        O = Us(A / d * Rs(D));
-                                    (k -= 2 * M) > Ls ? (_ += M *= g ? 1 : -1, w -= M) : (k = 0, _ = w = (h + p) / 2), (E -= 2 * O) > Ls ? (b += O *= g ? 1 : -1, x -= O) : (E = 0, b = x = (h + p) / 2)
-                                }
-                                var T = d * Ts(b),
-                                    N = d * Rs(b),
-                                    z = f * Ts(w),
-                                    R = f * Rs(w);
-                                if (S > Ls) {
-                                    var P, L = d * Ts(x),
-                                        j = d * Rs(x),
-                                        B = f * Ts(_),
-                                        I = f * Rs(_);
-                                    if (m < js)
-                                        if (P = function(t, e, n, i, r, o, a, s) {
-                                                var c = n - t,
-                                                    l = i - e,
-                                                    u = a - r,
-                                                    f = s - o,
-                                                    d = f * c - u * l;
-                                                if (!(d * d < Ls)) return [t + (d = (u * (e - o) - f * (t - r)) / d) * c, e + d * l]
-                                            }(T, N, B, I, L, j, z, R)) {
-                                            var U = T - P[0],
-                                                q = N - P[1],
-                                                W = L - P[0],
-                                                H = j - P[1],
-                                                X = 1 / Rs(function(t) {
-                                                    return t > 1 ? 0 : t < -1 ? js : Math.acos(t)
-                                                }((U * W + q * H) / (Ps(U * U + q * q) * Ps(W * W + H * H))) / 2),
-                                                J = Ps(P[0] * P[0] + P[1] * P[1]);
-                                            C = zs(S, (f - J) / (X - 1)), F = zs(S, (d - J) / (X + 1))
-                                        } else C = F = 0
-                                }
-                                E > Ls ? F > Ls ? (v = Lc(B, I, T, N, d, F, g), y = Lc(L, j, z, R, d, F, g), s.moveTo(v.cx + v.x01, v.cy + v.y01), F < S ? s.arc(v.cx, v.cy, F, Os(v.y01, v.x01), Os(y.y01, y.x01), !g) : (s.arc(v.cx, v.cy, F, Os(v.y01, v.x01), Os(v.y11, v.x11), !g), s.arc(0, 0, d, Os(v.cy + v.y11, v.cx + v.x11), Os(y.cy + y.y11, y.cx + y.x11), !g), s.arc(y.cx, y.cy, F, Os(y.y11, y.x11), Os(y.y01, y.x01), !g))) : (s.moveTo(T, N), s.arc(0, 0, d, b, x, !g)) : s.moveTo(T, N), f > Ls && k > Ls ? C > Ls ? (v = Lc(z, R, L, j, f, -C, g), y = Lc(T, N, B, I, f, -C, g), s.lineTo(v.cx + v.x01, v.cy + v.y01), C < S ? s.arc(v.cx, v.cy, C, Os(v.y01, v.x01), Os(y.y01, y.x01), !g) : (s.arc(v.cx, v.cy, C, Os(v.y01, v.x01), Os(v.y11, v.x11), !g), s.arc(0, 0, f, Os(v.cy + v.y11, v.cx + v.x11), Os(y.cy + y.y11, y.cx + y.x11), g), s.arc(y.cx, y.cy, C, Os(y.y11, y.x11), Os(y.y01, y.x01), !g))) : s.arc(0, 0, f, w, _, g) : s.lineTo(z, R)
-                            }
-                        else s.moveTo(0, 0);
-                        if (s.closePath(), l) return s = null, l + "" || null
-                    }
-                    return l.centroid = function() {
-                        var n = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2,
-                            i = (+r.apply(this, arguments) + +o.apply(this, arguments)) / 2 - js / 2;
-                        return [Ts(i) * n, Rs(i) * n]
-                    }, l.innerRadius = function(e) {
-                        return arguments.length ? (t = "function" === typeof e ? e : cc(+e), l) : t
-                    }, l.outerRadius = function(t) {
-                        return arguments.length ? (e = "function" === typeof t ? t : cc(+t), l) : e
-                    }, l.cornerRadius = function(t) {
-                        return arguments.length ? (n = "function" === typeof t ? t : cc(+t), l) : n
-                    }, l.padRadius = function(t) {
-                        return arguments.length ? (i = null == t ? null : "function" === typeof t ? t : cc(+t), l) : i
-                    }, l.startAngle = function(t) {
-                        return arguments.length ? (r = "function" === typeof t ? t : cc(+t), l) : r
-                    }, l.endAngle = function(t) {
-                        return arguments.length ? (o = "function" === typeof t ? t : cc(+t), l) : o
-                    }, l.padAngle = function(t) {
-                        return arguments.length ? (a = "function" === typeof t ? t : cc(+t), l) : a
+            const Yd = t => t.x || 0,
+                Vd = t => t.y || 0,
+                Kd = t => !(!1 === t.defined),
+                Qd = Zc().startAngle((t => t.startAngle || 0)).endAngle((t => t.endAngle || 0)).padAngle((t => t.padAngle || 0)).innerRadius((t => t.innerRadius || 0)).outerRadius((t => t.outerRadius || 0)).cornerRadius((t => t.cornerRadius || 0)),
+                th = Qc().x(Yd).y1(Vd).y0((t => (t.y || 0) + (t.height || 0))).defined(Kd),
+                eh = Qc().y(Vd).x1(Yd).x0((t => (t.x || 0) + (t.width || 0))).defined(Kd),
+                nh = Kc().x(Yd).y(Vd).defined(Kd),
+                ih = function() {
+                    var t = Wd,
+                        e = Hd,
+                        n = Xd,
+                        i = Gd,
+                        r = Jd(0),
+                        o = r,
+                        a = r,
+                        s = r,
+                        c = null;
+
+                    function l(l, u, f) {
+                        var d, h = null != u ? u : +t.call(this, l),
+                            p = null != f ? f : +e.call(this, l),
+                            m = +n.call(this, l),
+                            g = +i.call(this, l),
+                            v = Math.min(m, g) / 2,
+                            y = Zd(+r.call(this, l), 0, v),
+                            b = Zd(+o.call(this, l), 0, v),
+                            x = Zd(+a.call(this, l), 0, v),
+                            _ = Zd(+s.call(this, l), 0, v);
+                        if (c || (c = d = jc()), y <= 0 && b <= 0 && x <= 0 && _ <= 0) c.rect(h, p, m, g);
+                        else {
+                            var w = h + m,
+                                k = p + g;
+                            c.moveTo(h + y, p), c.lineTo(w - b, p), c.bezierCurveTo(w - qd * b, p, w, p + qd * b, w, p + b), c.lineTo(w, k - _), c.bezierCurveTo(w, k - qd * _, w - qd * _, k, w - _, k), c.lineTo(h + x, k), c.bezierCurveTo(h + qd * x, k, h, k - qd * x, h, k - x), c.lineTo(h, p + y), c.bezierCurveTo(h, p + qd * y, h + qd * y, p, h + y, p), c.closePath()
+                        }
+                        if (d) return c = null, d + "" || null
+                    }
+                    return l.x = function(e) {
+                        return arguments.length ? (t = Jd(e), l) : t
+                    }, l.y = function(t) {
+                        return arguments.length ? (e = Jd(t), l) : e
+                    }, l.width = function(t) {
+                        return arguments.length ? (n = Jd(t), l) : n
+                    }, l.height = function(t) {
+                        return arguments.length ? (i = Jd(t), l) : i
+                    }, l.cornerRadius = function(t, e, n, i) {
+                        return arguments.length ? (r = Jd(t), o = null != e ? Jd(e) : r, s = null != n ? Jd(n) : r, a = null != i ? Jd(i) : o, l) : r
                     }, l.context = function(t) {
-                        return arguments.length ? (s = null == t ? null : t, l) : s
+                        return arguments.length ? (c = null == t ? null : t, l) : c
                     }, l
-                }().startAngle((t => t.startAngle || 0)).endAngle((t => t.endAngle || 0)).padAngle((t => t.padAngle || 0)).innerRadius((t => t.innerRadius || 0)).outerRadius((t => t.outerRadius || 0)).cornerRadius((t => t.cornerRadius || 0)),
-                Ld = qc().x(Nd).y1(zd).y0((t => (t.y || 0) + (t.height || 0))).defined(Rd),
-                jd = qc().y(zd).x1(Nd).x0((t => (t.x || 0) + (t.width || 0))).defined(Rd),
-                Bd = Uc().x(Nd).y(zd).defined(Rd),
-                Id = Md().x(Nd).y(zd).width((t => t.width || 0)).height((t => t.height || 0)).cornerRadius((t => Td(t.cornerRadiusTopLeft, t.cornerRadius) || 0), (t => Td(t.cornerRadiusTopRight, t.cornerRadius) || 0), (t => Td(t.cornerRadiusBottomRight, t.cornerRadius) || 0), (t => Td(t.cornerRadiusBottomLeft, t.cornerRadius) || 0)),
-                Ud = function(t, e) {
-                    let n = null,
-                        i = Oc(r);
+                }().x(Yd).y(Vd).width((t => t.width || 0)).height((t => t.height || 0)).cornerRadius((t => $d(t.cornerRadiusTopLeft, t.cornerRadius) || 0), (t => $d(t.cornerRadiusTopRight, t.cornerRadius) || 0), (t => $d(t.cornerRadiusBottomRight, t.cornerRadius) || 0), (t => $d(t.cornerRadiusBottomLeft, t.cornerRadius) || 0)),
+                rh = nl().type((t => jd(t.shape || "circle"))).size((t => $d(t.size, 64))),
+                oh = function() {
+                    var t, e, n, i, r, o, a, s, c = null;
+
+                    function l(t, e, n) {
+                        const i = n / 2;
+                        if (r) {
+                            var l = a - e,
+                                u = t - o;
+                            if (l || u) {
+                                var f = Math.sqrt(l * l + u * u),
+                                    d = (l /= f) * s,
+                                    h = (u /= f) * s,
+                                    p = Math.atan2(u, l);
+                                c.moveTo(o - d, a - h), c.lineTo(t - l * i, e - u * i), c.arc(t, e, i, p - Math.PI, p), c.lineTo(o + d, a + h), c.arc(o, a, s, p, p + Math.PI)
+                            } else c.arc(t, e, i, 0, Cd);
+                            c.closePath()
+                        } else r = 1;
+                        o = t, a = e, s = i
+                    }
+
+                    function u(o) {
+                        var a, s, u, f = o.length,
+                            d = !1;
+                        for (null == c && (c = u = jc()), a = 0; a <= f; ++a) !(a < f && i(s = o[a], a, o)) === d && (d = !d) && (r = 0), d && l(+t(s, a, o), +e(s, a, o), +n(s, a, o));
+                        if (u) return c = null, u + "" || null
+                    }
+                    return u.x = function(e) {
+                        return arguments.length ? (t = e, u) : t
+                    }, u.y = function(t) {
+                        return arguments.length ? (e = t, u) : e
+                    }, u.size = function(t) {
+                        return arguments.length ? (n = t, u) : n
+                    }, u.defined = function(t) {
+                        return arguments.length ? (i = t, u) : i
+                    }, u.context = function(t) {
+                        return arguments.length ? (c = null == t ? null : t, u) : c
+                    }, u
+                }().x(Yd).y(Vd).defined(Kd).size((t => t.size || 1));
 
-                    function r() {
-                        let r;
-                        if (n || (n = r = i()), t.apply(this, arguments).draw(n, +e.apply(this, arguments)), r) return n = null, r + "" || null
-                    }
-                    return t = "function" === typeof t ? t : cc(t || Wc), e = "function" === typeof e ? e : cc(void 0 === e ? 64 : +e), r.type = function(e) {
-                        return arguments.length ? (t = "function" === typeof e ? e : cc(e), r) : t
-                    }, r.size = function(t) {
-                        return arguments.length ? (e = "function" === typeof t ? t : cc(+t), r) : e
-                    }, r.context = function(t) {
-                        return arguments.length ? (n = null == t ? null : t, r) : n
-                    }, r
-                }().type((t => _d(t.shape || "circle"))).size((t => Td(t.size, 64))),
-                qd = Od().x(Nd).y(zd).defined(Rd).size((t => t.size || 1));
-
-            function Wd(t) {
+            function ah(t) {
                 return t.cornerRadius || t.cornerRadiusTopLeft || t.cornerRadiusTopRight || t.cornerRadiusBottomRight || t.cornerRadiusBottomLeft
             }
 
-            function Hd(t, e, n, i) {
-                return Id.context(t)(e, n, i)
+            function sh(t, e, n, i) {
+                return ih.context(t)(e, n, i)
             }
-            var Xd = 1;
+            var ch = 1;
 
-            function Jd() {
-                Xd = 1
-            }
-
-            function Gd(t, e, n) {
+            function lh(t, e, n) {
                 var i = e.clip,
                     r = t._defs,
-                    o = e.clip_id || (e.clip_id = "clip" + Xd++),
+                    o = e.clip_id || (e.clip_id = "clip" + ch++),
                     a = r.clipping[o] || (r.clipping[o] = {
                         id: o
                     });
-                return (0, m.mf)(i) ? a.path = i(null) : Wd(n) ? a.path = Hd(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + o + ")"
+                return (0, m.mf)(i) ? a.path = i(null) : ah(n) ? a.path = sh(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + o + ")"
             }
 
-            function $d(t) {
+            function uh(t) {
                 this.clear(), t && this.union(t)
             }
 
-            function Zd(t) {
-                this.mark = t, this.bounds = this.bounds || new $d
+            function fh(t) {
+                this.mark = t, this.bounds = this.bounds || new uh
             }
 
-            function Yd(t) {
-                Zd.call(this, t), this.items = this.items || []
+            function dh(t) {
+                fh.call(this, t), this.items = this.items || []
             }
 
-            function Vd(t) {
+            function hh(t) {
                 this._pending = 0, this._loader = t || Yi()
             }
 
-            function Kd(t) {
+            function ph(t) {
                 t._pending += 1
             }
 
-            function Qd(t) {
+            function mh(t) {
                 t._pending -= 1
             }
 
-            function th(t, e, n) {
+            function gh(t, e, n) {
                 if (e.stroke && 0 !== e.opacity && 0 !== e.strokeOpacity) {
                     const i = null != e.strokeWidth ? +e.strokeWidth : 1;
                     t.expand(i + (n ? function(t, e) {
                         return t.strokeJoin && "miter" !== t.strokeJoin ? 0 : e
                     }(e, i) : 0))
                 }
                 return t
             }
-            $d.prototype = {
+            uh.prototype = {
                 clone() {
-                    return new $d(this)
+                    return new uh(this)
                 },
                 clear() {
                     return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this
                 },
                 empty() {
                     return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE
                 },
@@ -28139,38 +28296,38 @@
                 },
                 width() {
                     return this.x2 - this.x1
                 },
                 height() {
                     return this.y2 - this.y1
                 }
-            }, (0, m.XW)(Yd, Zd), Vd.prototype = {
+            }, (0, m.XW)(dh, fh), hh.prototype = {
                 pending() {
                     return this._pending
                 },
                 sanitizeURL(t) {
                     const e = this;
-                    return Kd(e), e._loader.sanitize(t, {
+                    return ph(e), e._loader.sanitize(t, {
                         context: "href"
-                    }).then((t => (Qd(e), t))).catch((() => (Qd(e), null)))
+                    }).then((t => (mh(e), t))).catch((() => (mh(e), null)))
                 },
                 loadImage(t) {
                     const e = this,
-                        n = Jc();
-                    return Kd(e), e._loader.sanitize(t, {
+                        n = rl();
+                    return ph(e), e._loader.sanitize(t, {
                         context: "image"
                     }).then((t => {
                         const i = t.href;
                         if (!i || !n) throw {
                             url: i
                         };
                         const r = new n,
                             o = (0, m.nr)(t, "crossOrigin") ? t.crossOrigin : "anonymous";
-                        return null != o && (r.crossOrigin = o), r.onload = () => Qd(e), r.onerror = () => Qd(e), r.src = i, r
-                    })).catch((t => (Qd(e), {
+                        return null != o && (r.crossOrigin = o), r.onload = () => mh(e), r.onerror = () => mh(e), r.src = i, r
+                    })).catch((t => (mh(e), {
                         complete: !1,
                         width: 0,
                         height: 0,
                         src: t && t.url || ""
                     })))
                 },
                 ready() {
@@ -28180,125 +28337,119 @@
                             t.pending() ? setTimeout((() => {
                                 n(!0)
                             }), 10) : e(i)
                         }(!1)
                     }))
                 }
             };
-            const eh = ld - 1e-8;
-            let nh, ih, rh, oh, ah, sh, ch, lh;
-            const uh = (t, e) => nh.add(t, e),
-                fh = (t, e) => uh(ih = t, rh = e),
-                dh = t => uh(t, nh.y1),
-                hh = t => uh(nh.x1, t),
-                ph = (t, e) => ah * t + ch * e,
-                mh = (t, e) => sh * t + lh * e,
-                gh = (t, e) => uh(ph(t, e), mh(t, e)),
-                vh = (t, e) => fh(ph(t, e), mh(t, e));
+            const vh = Cd - 1e-8;
+            let yh, bh, xh, _h, wh, kh, Eh, Ah;
+            const Dh = (t, e) => yh.add(t, e),
+                Sh = (t, e) => Dh(bh = t, xh = e),
+                Ch = t => Dh(t, yh.y1),
+                Mh = t => Dh(yh.x1, t),
+                Fh = (t, e) => wh * t + Eh * e,
+                Oh = (t, e) => kh * t + Ah * e,
+                Th = (t, e) => Dh(Fh(t, e), Oh(t, e)),
+                Nh = (t, e) => Sh(Fh(t, e), Oh(t, e));
 
-            function yh(t, e) {
-                return nh = t, e ? (oh = e * sd, ah = lh = Math.cos(oh), sh = Math.sin(oh), ch = -sh) : (ah = lh = 1, oh = sh = ch = 0), bh
+            function Rh(t, e) {
+                return yh = t, e ? (_h = e * Dd, wh = Ah = Math.cos(_h), kh = Math.sin(_h), Eh = -kh) : (wh = Ah = 1, _h = kh = Eh = 0), zh
             }
-            const bh = {
+            const zh = {
                 beginPath() {},
                 closePath() {},
-                moveTo: vh,
-                lineTo: vh,
+                moveTo: Nh,
+                lineTo: Nh,
                 rect(t, e, n, i) {
-                    oh ? (gh(t + n, e), gh(t + n, e + i), gh(t, e + i), vh(t, e)) : (uh(t + n, e + i), fh(t, e))
+                    _h ? (Th(t + n, e), Th(t + n, e + i), Th(t, e + i), Nh(t, e)) : (Dh(t + n, e + i), Sh(t, e))
                 },
                 quadraticCurveTo(t, e, n, i) {
-                    const r = ph(t, e),
-                        o = mh(t, e),
-                        a = ph(n, i),
-                        s = mh(n, i);
-                    xh(ih, r, a, dh), xh(rh, o, s, hh), fh(a, s)
+                    const r = Fh(t, e),
+                        o = Oh(t, e),
+                        a = Fh(n, i),
+                        s = Oh(n, i);
+                    Ph(bh, r, a, Ch), Ph(xh, o, s, Mh), Sh(a, s)
                 },
                 bezierCurveTo(t, e, n, i, r, o) {
-                    const a = ph(t, e),
-                        s = mh(t, e),
-                        c = ph(n, i),
-                        l = mh(n, i),
-                        u = ph(r, o),
-                        f = mh(r, o);
-                    _h(ih, a, c, u, dh), _h(rh, s, l, f, hh), fh(u, f)
+                    const a = Fh(t, e),
+                        s = Oh(t, e),
+                        c = Fh(n, i),
+                        l = Oh(n, i),
+                        u = Fh(r, o),
+                        f = Oh(r, o);
+                    Lh(bh, a, c, u, Ch), Lh(xh, s, l, f, Mh), Sh(u, f)
                 },
                 arc(t, e, n, i, r, o) {
-                    if (i += oh, r += oh, ih = n * Math.cos(r) + t, rh = n * Math.sin(r) + e, Math.abs(r - i) > eh) uh(t - n, e - n), uh(t + n, e + n);
+                    if (i += _h, r += _h, bh = n * Math.cos(r) + t, xh = n * Math.sin(r) + e, Math.abs(r - i) > vh) Dh(t - n, e - n), Dh(t + n, e + n);
                     else {
-                        const a = i => uh(n * Math.cos(i) + t, n * Math.sin(i) + e);
+                        const a = i => Dh(n * Math.cos(i) + t, n * Math.sin(i) + e);
                         let s, c;
                         if (a(i), a(r), r !== i)
-                            if ((i %= ld) < 0 && (i += ld), (r %= ld) < 0 && (r += ld), r < i && (o = !o, s = i, i = r, r = s), o)
-                                for (r -= ld, s = i - i % cd, c = 0; c < 4 && s > r; ++c, s -= cd) a(s);
+                            if ((i %= Cd) < 0 && (i += Cd), (r %= Cd) < 0 && (r += Cd), r < i && (o = !o, s = i, i = r, r = s), o)
+                                for (r -= Cd, s = i - i % Sd, c = 0; c < 4 && s > r; ++c, s -= Sd) a(s);
                             else
-                                for (s = i - i % cd + cd, c = 0; c < 4 && s < r; ++c, s += cd) a(s)
+                                for (s = i - i % Sd + Sd, c = 0; c < 4 && s < r; ++c, s += Sd) a(s)
                     }
                 }
             };
 
-            function xh(t, e, n, i) {
+            function Ph(t, e, n, i) {
                 const r = (t - e) / (t + n - 2 * e);
                 0 < r && r < 1 && i(t + (e - t) * r)
             }
 
-            function _h(t, e, n, i, r) {
+            function Lh(t, e, n, i, r) {
                 const o = i - t + 3 * e - 3 * n,
                     a = t + n - 2 * e,
                     s = t - e;
                 let c, l = 0,
                     u = 0;
-                Math.abs(o) > 1e-14 ? (c = a * a + s * o, c >= 0 && (c = Math.sqrt(c), l = (-a + c) / o, u = (-a - c) / o)) : l = .5 * s / a, 0 < l && l < 1 && r(wh(l, t, e, n, i)), 0 < u && u < 1 && r(wh(u, t, e, n, i))
+                Math.abs(o) > 1e-14 ? (c = a * a + s * o, c >= 0 && (c = Math.sqrt(c), l = (-a + c) / o, u = (-a - c) / o)) : l = .5 * s / a, 0 < l && l < 1 && r(Bh(l, t, e, n, i)), 0 < u && u < 1 && r(Bh(u, t, e, n, i))
             }
 
-            function wh(t, e, n, i, r) {
+            function Bh(t, e, n, i, r) {
                 const o = 1 - t,
                     a = o * o,
                     s = t * t;
                 return a * o * e + 3 * a * t * n + 3 * o * s * i + s * t * r
             }
-            var kh = (kh = Xc(1, 1)) ? kh.getContext("2d") : null;
-            const Eh = new $d;
+            var Ih = (Ih = il(1, 1)) ? Ih.getContext("2d") : null;
+            const jh = new uh;
 
-            function Dh(t) {
+            function Uh(t) {
                 return function(e, n) {
-                    if (!kh) return !0;
-                    t(kh, e), Eh.clear().union(e.bounds).intersect(n).round();
+                    if (!Ih) return !0;
+                    t(Ih, e), jh.clear().union(e.bounds).intersect(n).round();
                     const {
                         x1: i,
                         y1: r,
                         x2: o,
                         y2: a
-                    } = Eh;
+                    } = jh;
                     for (let t = r; t <= a; ++t)
                         for (let e = i; e <= o; ++e)
-                            if (kh.isPointInPath(e, t)) return !0;
+                            if (Ih.isPointInPath(e, t)) return !0;
                     return !1
                 }
             }
 
-            function Ah(t, e) {
+            function qh(t, e) {
                 return e.contains(t.x || 0, t.y || 0)
             }
 
-            function Sh(t, e) {
+            function Wh(t, e) {
                 const n = t.x || 0,
                     i = t.y || 0,
                     r = t.width || 0,
                     o = t.height || 0;
-                return e.intersects(Eh.set(n, i, n + r, i + o))
-            }
-
-            function Ch(t, e) {
-                const n = t.x || 0,
-                    i = t.y || 0;
-                return Fh(e, n, i, null != t.x2 ? t.x2 : n, null != t.y2 ? t.y2 : i)
+                return e.intersects(jh.set(n, i, n + r, i + o))
             }
 
-            function Fh(t, e, n, i, r) {
+            function Hh(t, e, n, i, r) {
                 const {
                     x1: o,
                     y1: a,
                     x2: s,
                     y2: c
                 } = t, l = i - e, u = r - n;
                 let f, d, h, p, m = 0,
@@ -28312,517 +28463,521 @@
                         if (h < m) return !1;
                         h < g && (g = h)
                     }
                 }
                 return !0
             }
 
-            function Mh(t, e) {
+            function Xh(t, e) {
                 t.globalCompositeOperation = e.blend || "source-over"
             }
 
-            function Oh(t, e) {
+            function Gh(t, e) {
                 return null == t ? e : t
             }
 
-            function Th(t, e) {
+            function Jh(t, e) {
                 const n = e.length;
                 for (let i = 0; i < n; ++i) t.addColorStop(e[i].offset, e[i].color);
                 return t
             }
 
-            function Nh(t, e, n) {
-                return Zf(n) ? function(t, e, n) {
+            function Zh(t, e, n) {
+                return pd(n) ? function(t, e, n) {
                     const i = n.width(),
                         r = n.height();
                     let o;
-                    if ("radial" === e.gradient) o = t.createRadialGradient(n.x1 + Oh(e.x1, .5) * i, n.y1 + Oh(e.y1, .5) * r, Math.max(i, r) * Oh(e.r1, 0), n.x1 + Oh(e.x2, .5) * i, n.y1 + Oh(e.y2, .5) * r, Math.max(i, r) * Oh(e.r2, .5));
+                    if ("radial" === e.gradient) o = t.createRadialGradient(n.x1 + Gh(e.x1, .5) * i, n.y1 + Gh(e.y1, .5) * r, Math.max(i, r) * Gh(e.r1, 0), n.x1 + Gh(e.x2, .5) * i, n.y1 + Gh(e.y2, .5) * r, Math.max(i, r) * Gh(e.r2, .5));
                     else {
-                        const a = Oh(e.x1, 0),
-                            s = Oh(e.y1, 0),
-                            c = Oh(e.x2, 1),
-                            l = Oh(e.y2, 0);
+                        const a = Gh(e.x1, 0),
+                            s = Gh(e.y1, 0),
+                            c = Gh(e.x2, 1),
+                            l = Gh(e.y2, 0);
                         if (a !== c && s !== l && i !== r) {
-                            const n = Xc(Math.ceil(i), Math.ceil(r)),
+                            const n = il(Math.ceil(i), Math.ceil(r)),
                                 o = n.getContext("2d");
-                            return o.scale(i, r), o.fillStyle = Th(o.createLinearGradient(a, s, c, l), e.stops), o.fillRect(0, 0, i, r), t.createPattern(n, "no-repeat")
+                            return o.scale(i, r), o.fillStyle = Jh(o.createLinearGradient(a, s, c, l), e.stops), o.fillRect(0, 0, i, r), t.createPattern(n, "no-repeat")
                         }
                         o = t.createLinearGradient(n.x1 + a * i, n.y1 + s * r, n.x1 + c * i, n.y1 + l * r)
                     }
-                    return Th(o, e.stops)
+                    return Jh(o, e.stops)
                 }(t, n, e.bounds) : n
             }
 
-            function zh(t, e, n) {
-                return (n *= null == e.fillOpacity ? 1 : e.fillOpacity) > 0 && (t.globalAlpha = n, t.fillStyle = Nh(t, e, e.fill), !0)
+            function $h(t, e, n) {
+                return (n *= null == e.fillOpacity ? 1 : e.fillOpacity) > 0 && (t.globalAlpha = n, t.fillStyle = Zh(t, e, e.fill), !0)
             }
-            var Rh = [];
+            var Yh = [];
 
-            function Ph(t, e, n) {
+            function Vh(t, e, n) {
                 var i = null != (i = e.strokeWidth) ? i : 1;
-                return !(i <= 0) && ((n *= null == e.strokeOpacity ? 1 : e.strokeOpacity) > 0 && (t.globalAlpha = n, t.strokeStyle = Nh(t, e, e.stroke), t.lineWidth = i, t.lineCap = e.strokeCap || "butt", t.lineJoin = e.strokeJoin || "miter", t.miterLimit = e.strokeMiterLimit || 10, t.setLineDash && (t.setLineDash(e.strokeDash || Rh), t.lineDashOffset = e.strokeDashOffset || 0), !0))
+                return !(i <= 0) && ((n *= null == e.strokeOpacity ? 1 : e.strokeOpacity) > 0 && (t.globalAlpha = n, t.strokeStyle = Zh(t, e, e.stroke), t.lineWidth = i, t.lineCap = e.strokeCap || "butt", t.lineJoin = e.strokeJoin || "miter", t.miterLimit = e.strokeMiterLimit || 10, t.setLineDash && (t.setLineDash(e.strokeDash || Yh), t.lineDashOffset = e.strokeDashOffset || 0), !0))
             }
 
-            function Lh(t, e) {
+            function Kh(t, e) {
                 return t.zindex - e.zindex || t.index - e.index
             }
 
-            function jh(t) {
+            function Qh(t) {
                 if (!t.zdirty) return t.zitems;
                 var e, n, i, r = t.items,
                     o = [];
                 for (n = 0, i = r.length; n < i; ++n)(e = r[n]).index = n, e.zindex && o.push(e);
-                return t.zdirty = !1, t.zitems = o.sort(Lh)
+                return t.zdirty = !1, t.zitems = o.sort(Kh)
             }
 
-            function Bh(t, e) {
+            function tp(t, e) {
                 var n, i, r = t.items;
                 if (!r || !r.length) return;
-                const o = jh(t);
+                const o = Qh(t);
                 if (o && o.length) {
                     for (n = 0, i = r.length; n < i; ++n) r[n].zindex || e(r[n]);
                     r = o
                 }
                 for (n = 0, i = r.length; n < i; ++n) e(r[n])
             }
 
-            function Ih(t, e) {
+            function ep(t, e) {
                 var n, i, r = t.items;
                 if (!r || !r.length) return null;
-                const o = jh(t);
+                const o = Qh(t);
                 for (o && o.length && (r = o), i = r.length; --i >= 0;)
                     if (n = e(r[i])) return n;
                 if (r === o)
                     for (i = (r = t.items).length; --i >= 0;)
                         if (!r[i].zindex && (n = e(r[i]))) return n;
                 return null
             }
 
-            function Uh(t) {
+            function np(t) {
                 return function(e, n, i) {
-                    Bh(n, (n => {
-                        i && !i.intersects(n.bounds) || Wh(t, e, n, n)
+                    tp(n, (n => {
+                        i && !i.intersects(n.bounds) || rp(t, e, n, n)
                     }))
                 }
             }
 
-            function qh(t) {
+            function ip(t) {
                 return function(e, n, i) {
-                    !n.items.length || i && !i.intersects(n.bounds) || Wh(t, e, n.items[0], n.items)
+                    !n.items.length || i && !i.intersects(n.bounds) || rp(t, e, n.items[0], n.items)
                 }
             }
 
-            function Wh(t, e, n, i) {
+            function rp(t, e, n, i) {
                 var r = null == n.opacity ? 1 : n.opacity;
-                0 !== r && (t(e, i) || (Mh(e, n), n.fill && zh(e, n, r) && e.fill(), n.stroke && Ph(e, n, r) && e.stroke()))
+                0 !== r && (t(e, i) || (Xh(e, n), n.fill && $h(e, n, r) && e.fill(), n.stroke && Vh(e, n, r) && e.stroke()))
             }
 
-            function Hh(t) {
+            function op(t) {
                 return t = t || m.yb,
                     function(e, n, i, r, o, a) {
-                        return i *= e.pixelRatio, r *= e.pixelRatio, Ih(n, (n => {
+                        return i *= e.pixelRatio, r *= e.pixelRatio, ep(n, (n => {
                             const s = n.bounds;
                             if ((!s || s.contains(o, a)) && s) return t(e, n, i, r, o, a) ? n : void 0
                         }))
                     }
             }
 
-            function Xh(t, e) {
+            function ap(t, e) {
                 return function(n, i, r, o) {
                     var a, s, c = Array.isArray(i) ? i[0] : i,
                         l = null == e ? c.fill : e,
                         u = c.stroke && n.isPointInStroke;
                     return u && (a = c.strokeWidth, s = c.strokeCap, n.lineWidth = null != a ? a : 1, n.lineCap = null != s ? s : "butt"), !t(n, i) && (l && n.isPointInPath(r, o) || u && n.isPointInStroke(r, o))
                 }
             }
 
-            function Jh(t) {
-                return Hh(Xh(t))
+            function sp(t) {
+                return op(ap(t))
             }
 
-            function Gh(t, e) {
+            function cp(t, e) {
                 return "translate(" + t + "," + e + ")"
             }
 
-            function $h(t) {
+            function lp(t) {
                 return "rotate(" + t + ")"
             }
 
-            function Zh(t) {
-                return Gh(t.x || 0, t.y || 0)
+            function up(t) {
+                return cp(t.x || 0, t.y || 0)
             }
 
-            function Yh(t, e, n) {
+            function fp(t, e, n) {
                 function i(t, n) {
                     var i = n.x || 0,
                         r = n.y || 0,
                         o = n.angle || 0;
-                    t.translate(i, r), o && t.rotate(o *= sd), t.beginPath(), e(t, n), o && t.rotate(-o), t.translate(-i, -r)
+                    t.translate(i, r), o && t.rotate(o *= Dd), t.beginPath(), e(t, n), o && t.rotate(-o), t.translate(-i, -r)
                 }
                 return {
                     type: t,
                     tag: "path",
                     nested: !1,
                     attr: function(t, n) {
                         t("transform", function(t) {
-                            return Gh(t.x || 0, t.y || 0) + (t.angle ? " " + $h(t.angle) : "")
+                            return cp(t.x || 0, t.y || 0) + (t.angle ? " " + lp(t.angle) : "")
                         }(n)), t("d", e(null, n))
                     },
                     bound: function(t, n) {
-                        return e(yh(t, n.angle), n), th(t, n).translate(n.x || 0, n.y || 0)
+                        return e(Rh(t, n.angle), n), gh(t, n).translate(n.x || 0, n.y || 0)
                     },
-                    draw: Uh(i),
-                    pick: Jh(i),
-                    isect: n || Dh(i)
+                    draw: np(i),
+                    pick: sp(i),
+                    isect: n || Uh(i)
                 }
             }
-            var Vh = Yh("arc", (function(t, e) {
-                return Pd.context(t)(e)
+            var dp = fp("arc", (function(t, e) {
+                return Qd.context(t)(e)
             }));
 
-            function Kh(t, e, n) {
+            function hp(t, e, n) {
                 function i(t, n) {
                     t.beginPath(), e(t, n)
                 }
-                const r = Xh(i);
+                const r = ap(i);
                 return {
                     type: t,
                     tag: "path",
                     nested: !0,
                     attr: function(t, n) {
                         var i = n.mark.items;
                         i.length && t("d", e(null, i))
                     },
                     bound: function(t, n) {
                         var i = n.items;
-                        return 0 === i.length ? t : (e(yh(t), i), th(t, i[0]))
+                        return 0 === i.length ? t : (e(Rh(t), i), gh(t, i[0]))
                     },
-                    draw: qh(i),
+                    draw: ip(i),
                     pick: function(t, e, n, i, o, a) {
                         var s = e.items,
                             c = e.bounds;
                         return !s || !s.length || c && !c.contains(o, a) ? null : (n *= t.pixelRatio, i *= t.pixelRatio, r(t, s, n, i) ? s[0] : null)
                     },
-                    isect: Ah,
+                    isect: qh,
                     tip: n
                 }
             }
-            var Qh = Kh("area", (function(t, e) {
+            var pp = hp("area", (function(t, e) {
                 const n = e[0],
                     i = n.interpolate || "linear";
-                return ("horizontal" === n.orient ? jd : Ld).curve(td(i, n.orient, n.tension)).context(t)(e)
+                return ("horizontal" === n.orient ? eh : th).curve(bd(i, n.orient, n.tension)).context(t)(e)
             }), (function(t, e) {
                 for (var n, i, r = "horizontal" === t[0].orient ? e[1] : e[0], o = "horizontal" === t[0].orient ? "y" : "x", a = t.length, s = 1 / 0; --a >= 0;) !1 !== t[a].defined && (i = Math.abs(t[a][o] - r)) < s && (s = i, n = t[a]);
                 return n
             }));
 
-            function tp(t, e) {
-                t.beginPath(), Wd(e) ? Hd(t, e, 0, 0) : t.rect(0, 0, e.width || 0, e.height || 0), t.clip()
+            function mp(t, e) {
+                t.beginPath(), ah(e) ? sh(t, e, 0, 0) : t.rect(0, 0, e.width || 0, e.height || 0), t.clip()
             }
 
-            function ep(t) {
-                const e = Oh(t.strokeWidth, 1);
+            function gp(t) {
+                const e = Gh(t.strokeWidth, 1);
                 return null != t.strokeOffset ? t.strokeOffset : t.stroke && e > .5 && e < 1.5 ? .5 - Math.abs(e - 1) : 0
             }
 
-            function np(t, e) {
-                const n = ep(e);
-                t("d", Hd(null, e, n, n))
+            function vp(t, e) {
+                const n = gp(e);
+                t("d", sh(null, e, n, n))
             }
 
-            function ip(t, e, n, i) {
-                const r = ep(e);
-                t.beginPath(), Hd(t, e, (n || 0) + r, (i || 0) + r)
-            }
-            const rp = Xh(ip),
-                op = Xh(ip, !1),
-                ap = Xh(ip, !0);
-            var sp = {
+            function yp(t, e, n, i) {
+                const r = gp(e);
+                t.beginPath(), sh(t, e, (n || 0) + r, (i || 0) + r)
+            }
+            const bp = ap(yp),
+                xp = ap(yp, !1),
+                _p = ap(yp, !0);
+            var wp = {
                     type: "group",
                     tag: "g",
                     nested: !1,
                     attr: function(t, e) {
-                        t("transform", Zh(e))
+                        t("transform", up(e))
                     },
                     bound: function(t, e) {
                         if (!e.clip && e.items) {
                             const n = e.items,
                                 i = n.length;
                             for (let e = 0; e < i; ++e) t.union(n[e].bounds)
                         }
-                        return (e.clip || e.width || e.height) && !e.noBound && t.add(0, 0).add(e.width || 0, e.height || 0), th(t, e), t.translate(e.x || 0, e.y || 0)
+                        return (e.clip || e.width || e.height) && !e.noBound && t.add(0, 0).add(e.width || 0, e.height || 0), gh(t, e), t.translate(e.x || 0, e.y || 0)
                     },
                     draw: function(t, e, n) {
-                        Bh(e, (e => {
+                        tp(e, (e => {
                             const i = e.x || 0,
                                 r = e.y || 0,
                                 o = e.strokeForeground,
                                 a = null == e.opacity ? 1 : e.opacity;
-                            (e.stroke || e.fill) && a && (ip(t, e, i, r), Mh(t, e), e.fill && zh(t, e, a) && t.fill(), e.stroke && !o && Ph(t, e, a) && t.stroke()), t.save(), t.translate(i, r), e.clip && tp(t, e), n && n.translate(-i, -r), Bh(e, (e => {
+                            (e.stroke || e.fill) && a && (yp(t, e, i, r), Xh(t, e), e.fill && $h(t, e, a) && t.fill(), e.stroke && !o && Vh(t, e, a) && t.stroke()), t.save(), t.translate(i, r), e.clip && mp(t, e), n && n.translate(-i, -r), tp(e, (e => {
                                 this.draw(t, e, n)
-                            })), n && n.translate(i, r), t.restore(), o && e.stroke && a && (ip(t, e, i, r), Mh(t, e), Ph(t, e, a) && t.stroke())
+                            })), n && n.translate(i, r), t.restore(), o && e.stroke && a && (yp(t, e, i, r), Xh(t, e), Vh(t, e, a) && t.stroke())
                         }))
                     },
                     pick: function(t, e, n, i, r, o) {
                         if (e.bounds && !e.bounds.contains(r, o) || !e.items) return null;
                         const a = n * t.pixelRatio,
                             s = i * t.pixelRatio;
-                        return Ih(e, (c => {
+                        return ep(e, (c => {
                             let l, u, f;
                             const d = c.bounds;
                             if (d && !d.contains(r, o)) return;
                             u = c.x || 0, f = c.y || 0;
                             const h = u + (c.width || 0),
                                 p = f + (c.height || 0),
                                 m = c.clip;
                             if (m && (r < u || r > h || o < f || o > p)) return;
-                            if (t.save(), t.translate(u, f), u = r - u, f = o - f, m && Wd(c) && !ap(t, c, a, s)) return t.restore(), null;
+                            if (t.save(), t.translate(u, f), u = r - u, f = o - f, m && ah(c) && !_p(t, c, a, s)) return t.restore(), null;
                             const g = c.strokeForeground,
                                 v = !1 !== e.interactive;
-                            return v && g && c.stroke && op(t, c, a, s) ? (t.restore(), c) : (l = Ih(c, (t => function(t, e, n) {
+                            return v && g && c.stroke && xp(t, c, a, s) ? (t.restore(), c) : (l = ep(c, (t => function(t, e, n) {
                                 return (!1 !== t.interactive || "group" === t.marktype) && t.bounds && t.bounds.contains(e, n)
-                            }(t, u, f) ? this.pick(t, n, i, u, f) : null)), !l && v && (c.fill || !g && c.stroke) && rp(t, c, a, s) && (l = c), t.restore(), l || null)
+                            }(t, u, f) ? this.pick(t, n, i, u, f) : null)), !l && v && (c.fill || !g && c.stroke) && bp(t, c, a, s) && (l = c), t.restore(), l || null)
                         }))
                     },
-                    isect: Sh,
+                    isect: Wh,
                     content: function(t, e, n) {
-                        t("clip-path", e.clip ? Gd(n, e, e) : null)
+                        t("clip-path", e.clip ? lh(n, e, e) : null)
                     },
                     background: function(t, e) {
-                        t("class", "background"), t("aria-hidden", !0), np(t, e)
+                        t("class", "background"), t("aria-hidden", !0), vp(t, e)
                     },
                     foreground: function(t, e) {
-                        t("class", "foreground"), t("aria-hidden", !0), e.strokeForeground ? np(t, e) : t("d", "")
+                        t("class", "foreground"), t("aria-hidden", !0), e.strokeForeground ? vp(t, e) : t("d", "")
                     }
                 },
-                cp = {
+                kp = {
                     xmlns: "http://www.w3.org/2000/svg",
                     "xmlns:xlink": "http://www.w3.org/1999/xlink",
                     version: "1.1"
                 };
 
-            function lp(t, e) {
+            function Ep(t, e) {
                 var n = t.image;
                 return (!n || t.url && t.url !== n.url) && (n = {
                     complete: !1,
                     width: 0,
                     height: 0
                 }, e.loadImage(t.url).then((e => {
                     t.image = e, t.image.url = t.url
                 }))), n
             }
 
-            function up(t, e) {
+            function Ap(t, e) {
                 return null != t.width ? t.width : e && e.width ? !1 !== t.aspect && t.height ? t.height * e.width / e.height : e.width : 0
             }
 
-            function fp(t, e) {
+            function Dp(t, e) {
                 return null != t.height ? t.height : e && e.height ? !1 !== t.aspect && t.width ? t.width * e.height / e.width : e.height : 0
             }
 
-            function dp(t, e) {
+            function Sp(t, e) {
                 return "center" === t ? e / 2 : "right" === t ? e : 0
             }
 
-            function hp(t, e) {
+            function Cp(t, e) {
                 return "middle" === t ? e / 2 : "bottom" === t ? e : 0
             }
-            var pp = {
+            var Mp = {
                     type: "image",
                     tag: "image",
                     nested: !1,
                     attr: function(t, e, n) {
-                        const i = lp(e, n),
-                            r = up(e, i),
-                            o = fp(e, i),
-                            a = (e.x || 0) - dp(e.align, r),
-                            s = (e.y || 0) - hp(e.baseline, o);
-                        t("href", !i.src && i.toDataURL ? i.toDataURL() : i.src || "", cp["xmlns:xlink"], "xlink:href"), t("transform", Gh(a, s)), t("width", r), t("height", o), t("preserveAspectRatio", !1 === e.aspect ? "none" : "xMidYMid")
+                        const i = Ep(e, n),
+                            r = Ap(e, i),
+                            o = Dp(e, i),
+                            a = (e.x || 0) - Sp(e.align, r),
+                            s = (e.y || 0) - Cp(e.baseline, o);
+                        t("href", !i.src && i.toDataURL ? i.toDataURL() : i.src || "", kp["xmlns:xlink"], "xlink:href"), t("transform", cp(a, s)), t("width", r), t("height", o), t("preserveAspectRatio", !1 === e.aspect ? "none" : "xMidYMid")
                     },
                     bound: function(t, e) {
                         const n = e.image,
-                            i = up(e, n),
-                            r = fp(e, n),
-                            o = (e.x || 0) - dp(e.align, i),
-                            a = (e.y || 0) - hp(e.baseline, r);
+                            i = Ap(e, n),
+                            r = Dp(e, n),
+                            o = (e.x || 0) - Sp(e.align, i),
+                            a = (e.y || 0) - Cp(e.baseline, r);
                         return t.set(o, a, o + i, a + r)
                     },
                     draw: function(t, e, n) {
-                        Bh(e, (e => {
+                        tp(e, (e => {
                             if (n && !n.intersects(e.bounds)) return;
-                            const i = lp(e, this);
-                            let r = up(e, i),
-                                o = fp(e, i);
+                            const i = Ep(e, this);
+                            let r = Ap(e, i),
+                                o = Dp(e, i);
                             if (0 === r || 0 === o) return;
-                            let a, s, c, l, u = (e.x || 0) - dp(e.align, r),
-                                f = (e.y || 0) - hp(e.baseline, o);
-                            !1 !== e.aspect && (s = i.width / i.height, c = e.width / e.height, s === s && c === c && s !== c && (c < s ? (l = r / s, f += (o - l) / 2, o = l) : (l = o * s, u += (r - l) / 2, r = l))), (i.complete || i.toDataURL) && (Mh(t, e), t.globalAlpha = null != (a = e.opacity) ? a : 1, t.imageSmoothingEnabled = !1 !== e.smooth, t.drawImage(i, u, f, r, o))
+                            let a, s, c, l, u = (e.x || 0) - Sp(e.align, r),
+                                f = (e.y || 0) - Cp(e.baseline, o);
+                            !1 !== e.aspect && (s = i.width / i.height, c = e.width / e.height, s === s && c === c && s !== c && (c < s ? (l = r / s, f += (o - l) / 2, o = l) : (l = o * s, u += (r - l) / 2, r = l))), (i.complete || i.toDataURL) && (Xh(t, e), t.globalAlpha = null != (a = e.opacity) ? a : 1, t.imageSmoothingEnabled = !1 !== e.smooth, t.drawImage(i, u, f, r, o))
                         }))
                     },
-                    pick: Hh(),
+                    pick: op(),
                     isect: m.yb,
-                    get: lp,
-                    xOffset: dp,
-                    yOffset: hp
+                    get: Ep,
+                    xOffset: Sp,
+                    yOffset: Cp
                 },
-                mp = Kh("line", (function(t, e) {
+                Fp = hp("line", (function(t, e) {
                     const n = e[0],
                         i = n.interpolate || "linear";
-                    return Bd.curve(td(i, n.orient, n.tension)).context(t)(e)
+                    return nh.curve(bd(i, n.orient, n.tension)).context(t)(e)
                 }), (function(t, e) {
                     for (var n, i, r = Math.pow(t[0].strokeWidth || 1, 2), o = t.length; --o >= 0;)
                         if (!1 !== t[o].defined && (n = t[o].x - e[0]) * n + (i = t[o].y - e[1]) * i < r) return t[o];
                     return null
                 }));
 
-            function gp(t, e) {
+            function Op(t, e) {
                 var n = e.path;
                 if (null == n) return !0;
                 var i = e.x || 0,
                     r = e.y || 0,
                     o = e.scaleX || 1,
                     a = e.scaleY || 1,
-                    s = (e.angle || 0) * sd,
+                    s = (e.angle || 0) * Dd,
                     c = e.pathCache;
-                c && c.path === n || ((e.pathCache = c = ad(n)).path = n), s && t.rotate && t.translate ? (t.translate(i, r), t.rotate(s), vd(t, c, 0, 0, o, a), t.rotate(-s), t.translate(-i, -r)) : vd(t, c, i, r, o, a)
+                c && c.path === n || ((e.pathCache = c = Ad(n)).path = n), s && t.rotate && t.translate ? (t.translate(i, r), t.rotate(s), Pd(t, c, 0, 0, o, a), t.rotate(-s), t.translate(-i, -r)) : Pd(t, c, i, r, o, a)
             }
-            var vp = {
+            var Tp = {
                 type: "path",
                 tag: "path",
                 nested: !1,
                 attr: function(t, e) {
                     var n = e.scaleX || 1,
                         i = e.scaleY || 1;
                     1 === n && 1 === i || t("vector-effect", "non-scaling-stroke"), t("transform", function(t) {
-                        return Gh(t.x || 0, t.y || 0) + (t.angle ? " " + $h(t.angle) : "") + (t.scaleX || t.scaleY ? " " + function(t, e) {
+                        return cp(t.x || 0, t.y || 0) + (t.angle ? " " + lp(t.angle) : "") + (t.scaleX || t.scaleY ? " " + function(t, e) {
                             return "scale(" + t + "," + e + ")"
                         }(t.scaleX || 1, t.scaleY || 1) : "")
                     }(e)), t("d", e.path)
                 },
                 bound: function(t, e) {
-                    return gp(yh(t, e.angle), e) ? t.set(0, 0, 0, 0) : th(t, e, !0)
+                    return Op(Rh(t, e.angle), e) ? t.set(0, 0, 0, 0) : gh(t, e, !0)
                 },
-                draw: Uh(gp),
-                pick: Jh(gp),
-                isect: Dh(gp)
+                draw: np(Op),
+                pick: sp(Op),
+                isect: Uh(Op)
             };
 
-            function yp(t, e) {
-                t.beginPath(), Hd(t, e)
+            function Np(t, e) {
+                t.beginPath(), sh(t, e)
             }
-            var bp = {
+            var Rp = {
                 type: "rect",
                 tag: "path",
                 nested: !1,
                 attr: function(t, e) {
-                    t("d", Hd(null, e))
+                    t("d", sh(null, e))
                 },
                 bound: function(t, e) {
                     var n, i;
-                    return th(t.set(n = e.x || 0, i = e.y || 0, n + e.width || 0, i + e.height || 0), e)
+                    return gh(t.set(n = e.x || 0, i = e.y || 0, n + e.width || 0, i + e.height || 0), e)
                 },
-                draw: Uh(yp),
-                pick: Jh(yp),
-                isect: Sh
+                draw: np(Np),
+                pick: sp(Np),
+                isect: Wh
             };
 
-            function xp(t, e, n) {
+            function zp(t, e, n) {
                 var i, r, o, a;
-                return !(!e.stroke || !Ph(t, e, n)) && (i = e.x || 0, r = e.y || 0, o = null != e.x2 ? e.x2 : i, a = null != e.y2 ? e.y2 : r, t.beginPath(), t.moveTo(i, r), t.lineTo(o, a), !0)
+                return !(!e.stroke || !Vh(t, e, n)) && (i = e.x || 0, r = e.y || 0, o = null != e.x2 ? e.x2 : i, a = null != e.y2 ? e.y2 : r, t.beginPath(), t.moveTo(i, r), t.lineTo(o, a), !0)
             }
-            var _p = {
+            var Pp = {
                     type: "rule",
                     tag: "line",
                     nested: !1,
                     attr: function(t, e) {
-                        t("transform", Zh(e)), t("x2", null != e.x2 ? e.x2 - (e.x || 0) : 0), t("y2", null != e.y2 ? e.y2 - (e.y || 0) : 0)
+                        t("transform", up(e)), t("x2", null != e.x2 ? e.x2 - (e.x || 0) : 0), t("y2", null != e.y2 ? e.y2 - (e.y || 0) : 0)
                     },
                     bound: function(t, e) {
                         var n, i;
-                        return th(t.set(n = e.x || 0, i = e.y || 0, null != e.x2 ? e.x2 : n, null != e.y2 ? e.y2 : i), e)
+                        return gh(t.set(n = e.x || 0, i = e.y || 0, null != e.x2 ? e.x2 : n, null != e.y2 ? e.y2 : i), e)
                     },
                     draw: function(t, e, n) {
-                        Bh(e, (e => {
+                        tp(e, (e => {
                             if (!n || n.intersects(e.bounds)) {
                                 var i = null == e.opacity ? 1 : e.opacity;
-                                i && xp(t, e, i) && (Mh(t, e), t.stroke())
+                                i && zp(t, e, i) && (Xh(t, e), t.stroke())
                             }
                         }))
                     },
-                    pick: Hh((function(t, e, n, i) {
-                        return !!t.isPointInStroke && (xp(t, e, 1) && t.isPointInStroke(n, i))
+                    pick: op((function(t, e, n, i) {
+                        return !!t.isPointInStroke && (zp(t, e, 1) && t.isPointInStroke(n, i))
                     })),
-                    isect: Ch
+                    isect: function(t, e) {
+                        const n = t.x || 0,
+                            i = t.y || 0;
+                        return Hh(e, n, i, null != t.x2 ? t.x2 : n, null != t.y2 ? t.y2 : i)
+                    }
                 },
-                wp = Yh("shape", (function(t, e) {
+                Lp = fp("shape", (function(t, e) {
                     return (e.mark.shape || e.shape).context(t)(e)
                 })),
-                kp = Yh("symbol", (function(t, e) {
-                    return Ud.context(t)(e)
-                }), Ah);
-            const Ep = (0, m.$m)();
-            var Dp = {
-                height: Op,
-                measureWidth: Fp,
-                estimateWidth: Sp,
-                width: Sp,
-                canvas: Ap
+                Bp = fp("symbol", (function(t, e) {
+                    return rh.context(t)(e)
+                }), qh);
+            const Ip = (0, m.$m)();
+            var jp = {
+                height: Gp,
+                measureWidth: Hp,
+                estimateWidth: qp,
+                width: qp,
+                canvas: Up
             };
 
-            function Ap(t) {
-                Dp.width = t && kh ? Fp : Sp
+            function Up(t) {
+                jp.width = t && Ih ? Hp : qp
             }
 
-            function Sp(t, e) {
-                return Cp(Rp(t, e), Op(t))
+            function qp(t, e) {
+                return Wp(Yp(t, e), Gp(t))
             }
 
-            function Cp(t, e) {
+            function Wp(t, e) {
                 return ~~(.8 * t.length * e)
             }
 
-            function Fp(t, e) {
-                return Op(t) <= 0 || !(e = Rp(t, e)) ? 0 : Mp(e, Lp(t))
+            function Hp(t, e) {
+                return Gp(t) <= 0 || !(e = Yp(t, e)) ? 0 : Xp(e, Kp(t))
             }
 
-            function Mp(t, e) {
+            function Xp(t, e) {
                 const n = "(".concat(e, ") ").concat(t);
-                let i = Ep.get(n);
-                return void 0 === i && (kh.font = e, i = kh.measureText(t).width, Ep.set(n, i)), i
+                let i = Ip.get(n);
+                return void 0 === i && (Ih.font = e, i = Ih.measureText(t).width, Ip.set(n, i)), i
             }
 
-            function Op(t) {
+            function Gp(t) {
                 return null != t.fontSize ? +t.fontSize || 0 : 11
             }
 
-            function Tp(t) {
-                return null != t.lineHeight ? t.lineHeight : Op(t) + 2
+            function Jp(t) {
+                return null != t.lineHeight ? t.lineHeight : Gp(t) + 2
             }
 
-            function Np(t) {
+            function Zp(t) {
                 return e = t.lineBreak && t.text && !(0, m.kJ)(t.text) ? t.text.split(t.lineBreak) : t.text, (0, m.kJ)(e) ? e.length > 1 ? e : e[0] : e;
                 var e
             }
 
-            function zp(t) {
-                const e = Np(t);
-                return ((0, m.kJ)(e) ? e.length - 1 : 0) * Tp(t)
+            function $p(t) {
+                const e = Zp(t);
+                return ((0, m.kJ)(e) ? e.length - 1 : 0) * Jp(t)
             }
 
-            function Rp(t, e) {
+            function Yp(t, e) {
                 const n = null == e ? "" : (e + "").trim();
                 return t.limit > 0 && n.length ? function(t, e) {
                     var n = +t.limit,
                         i = function(t) {
-                            if (Dp.width === Fp) {
-                                const e = Lp(t);
-                                return t => Mp(t, e)
+                            if (jp.width === Hp) {
+                                const e = Kp(t);
+                                return t => Xp(t, e)
                             } {
-                                const e = Op(t);
-                                return t => Cp(t, e)
+                                const e = Gp(t);
+                                return t => Wp(t, e)
                             }
                         }(t);
                     if (i(e) < n) return e;
                     var r, o = t.ellipsis || "\u2026",
                         a = "rtl" === t.dir,
                         s = 0,
                         c = e.length;
@@ -28831,231 +28986,227 @@
                         return o + e.slice(s)
                     }
                     for (; s < c;) r = 1 + (s + c >>> 1), i(e.slice(0, r)) < n ? s = r : c = r - 1;
                     return e.slice(0, s) + o
                 }(t, n) : n
             }
 
-            function Pp(t, e) {
+            function Vp(t, e) {
                 var n = t.font;
                 return (e && n ? String(n).replace(/"/g, "'") : n) || "sans-serif"
             }
 
-            function Lp(t, e) {
-                return (t.fontStyle ? t.fontStyle + " " : "") + (t.fontVariant ? t.fontVariant + " " : "") + (t.fontWeight ? t.fontWeight + " " : "") + Op(t) + "px " + Pp(t, e)
+            function Kp(t, e) {
+                return (t.fontStyle ? t.fontStyle + " " : "") + (t.fontVariant ? t.fontVariant + " " : "") + (t.fontWeight ? t.fontWeight + " " : "") + Gp(t) + "px " + Vp(t, e)
             }
 
-            function jp(t) {
+            function Qp(t) {
                 var e = t.baseline,
-                    n = Op(t);
-                return Math.round("top" === e ? .79 * n : "middle" === e ? .3 * n : "bottom" === e ? -.21 * n : "line-top" === e ? .29 * n + .5 * Tp(t) : "line-bottom" === e ? .29 * n - .5 * Tp(t) : 0)
+                    n = Gp(t);
+                return Math.round("top" === e ? .79 * n : "middle" === e ? .3 * n : "bottom" === e ? -.21 * n : "line-top" === e ? .29 * n + .5 * Jp(t) : "line-bottom" === e ? .29 * n - .5 * Jp(t) : 0)
             }
-            Ap(!0);
-            const Bp = {
+            Up(!0);
+            const tm = {
                     left: "start",
                     center: "middle",
                     right: "end"
                 },
-                Ip = new $d;
+                em = new uh;
 
-            function Up(t) {
+            function nm(t) {
                 var e, n = t.x || 0,
                     i = t.y || 0,
                     r = t.radius || 0;
-                return r && (e = (t.theta || 0) - cd, n += r * Math.cos(e), i += r * Math.sin(e)), Ip.x1 = n, Ip.y1 = i, Ip
+                return r && (e = (t.theta || 0) - Sd, n += r * Math.cos(e), i += r * Math.sin(e)), em.x1 = n, em.y1 = i, em
             }
 
-            function qp(t, e, n) {
-                var i, r = Dp.height(e),
+            function im(t, e, n) {
+                var i, r = jp.height(e),
                     o = e.align,
-                    a = Up(e),
+                    a = nm(e),
                     s = a.x1,
                     c = a.y1,
                     l = e.dx || 0,
-                    u = (e.dy || 0) + jp(e) - Math.round(.8 * r),
-                    f = Np(e);
-                if ((0, m.kJ)(f) ? (r += Tp(e) * (f.length - 1), i = f.reduce(((t, n) => Math.max(t, Dp.width(e, n))), 0)) : i = Dp.width(e, f), "center" === o ? l -= i / 2 : "right" === o && (l -= i), t.set(l += s, u += c, l + i, u + r), e.angle && !n) t.rotate(e.angle * sd, s, c);
-                else if (2 === n) return t.rotatedPoints(e.angle * sd, s, c);
+                    u = (e.dy || 0) + Qp(e) - Math.round(.8 * r),
+                    f = Zp(e);
+                if ((0, m.kJ)(f) ? (r += Jp(e) * (f.length - 1), i = f.reduce(((t, n) => Math.max(t, jp.width(e, n))), 0)) : i = jp.width(e, f), "center" === o ? l -= i / 2 : "right" === o && (l -= i), t.set(l += s, u += c, l + i, u + r), e.angle && !n) t.rotate(e.angle * Dd, s, c);
+                else if (2 === n) return t.rotatedPoints(e.angle * Dd, s, c);
                 return t
             }
-            var Wp = {
+            var rm = {
                     type: "text",
                     tag: "text",
                     nested: !1,
                     attr: function(t, e) {
                         var n, i = e.dx || 0,
-                            r = (e.dy || 0) + jp(e),
-                            o = Up(e),
+                            r = (e.dy || 0) + Qp(e),
+                            o = nm(e),
                             a = o.x1,
                             s = o.y1,
                             c = e.angle || 0;
-                        t("text-anchor", Bp[e.align] || "start"), c ? (n = Gh(a, s) + " " + $h(c), (i || r) && (n += " " + Gh(i, r))) : n = Gh(a + i, s + r), t("transform", n)
+                        t("text-anchor", tm[e.align] || "start"), c ? (n = cp(a, s) + " " + lp(c), (i || r) && (n += " " + cp(i, r))) : n = cp(a + i, s + r), t("transform", n)
                     },
-                    bound: qp,
+                    bound: im,
                     draw: function(t, e, n) {
-                        Bh(e, (e => {
+                        tp(e, (e => {
                             var i, r, o, a, s, c, l, u = null == e.opacity ? 1 : e.opacity;
                             if (!(n && !n.intersects(e.bounds) || 0 === u || e.fontSize <= 0 || null == e.text || 0 === e.text.length)) {
-                                if (t.font = Lp(e), t.textAlign = e.align || "left", r = (i = Up(e)).x1, o = i.y1, e.angle && (t.save(), t.translate(r, o), t.rotate(e.angle * sd), r = o = 0), r += e.dx || 0, o += (e.dy || 0) + jp(e), c = Np(e), Mh(t, e), (0, m.kJ)(c))
-                                    for (s = Tp(e), a = 0; a < c.length; ++a) l = Rp(e, c[a]), e.fill && zh(t, e, u) && t.fillText(l, r, o), e.stroke && Ph(t, e, u) && t.strokeText(l, r, o), o += s;
-                                else l = Rp(e, c), e.fill && zh(t, e, u) && t.fillText(l, r, o), e.stroke && Ph(t, e, u) && t.strokeText(l, r, o);
+                                if (t.font = Kp(e), t.textAlign = e.align || "left", r = (i = nm(e)).x1, o = i.y1, e.angle && (t.save(), t.translate(r, o), t.rotate(e.angle * Dd), r = o = 0), r += e.dx || 0, o += (e.dy || 0) + Qp(e), c = Zp(e), Xh(t, e), (0, m.kJ)(c))
+                                    for (s = Jp(e), a = 0; a < c.length; ++a) l = Yp(e, c[a]), e.fill && $h(t, e, u) && t.fillText(l, r, o), e.stroke && Vh(t, e, u) && t.strokeText(l, r, o), o += s;
+                                else l = Yp(e, c), e.fill && $h(t, e, u) && t.fillText(l, r, o), e.stroke && Vh(t, e, u) && t.strokeText(l, r, o);
                                 e.angle && t.restore()
                             }
                         }))
                     },
-                    pick: Hh((function(t, e, n, i, r, o) {
+                    pick: op((function(t, e, n, i, r, o) {
                         if (e.fontSize <= 0) return !1;
                         if (!e.angle) return !0;
-                        var a = Up(e),
+                        var a = nm(e),
                             s = a.x1,
                             c = a.y1,
-                            l = qp(Ip, e, 1),
-                            u = -e.angle * sd,
+                            l = im(em, e, 1),
+                            u = -e.angle * Dd,
                             f = Math.cos(u),
                             d = Math.sin(u),
                             h = f * r - d * o + (s - f * s + d * c),
                             p = d * r + f * o + (c - d * s - f * c);
                         return l.contains(h, p)
                     })),
                     isect: function(t, e) {
-                        const n = qp(Ip, t, 2);
-                        return Fh(e, n[0], n[1], n[2], n[3]) || Fh(e, n[0], n[1], n[4], n[5]) || Fh(e, n[4], n[5], n[6], n[7]) || Fh(e, n[2], n[3], n[6], n[7])
+                        const n = im(em, t, 2);
+                        return Hh(e, n[0], n[1], n[2], n[3]) || Hh(e, n[0], n[1], n[4], n[5]) || Hh(e, n[4], n[5], n[6], n[7]) || Hh(e, n[2], n[3], n[6], n[7])
                     }
                 },
-                Hp = Kh("trail", (function(t, e) {
-                    return qd.context(t)(e)
+                om = hp("trail", (function(t, e) {
+                    return oh.context(t)(e)
                 }), (function(t, e) {
                     for (var n, i, r = t.length; --r >= 0;)
                         if (!1 !== t[r].defined && (n = t[r].x - e[0]) * n + (i = t[r].y - e[1]) * i < (n = t[r].size || 1) * n) return t[r];
                     return null
                 })),
-                Xp = {
-                    arc: Vh,
-                    area: Qh,
-                    group: sp,
-                    image: pp,
-                    line: mp,
-                    path: vp,
-                    rect: bp,
-                    rule: _p,
-                    shape: wp,
-                    symbol: kp,
-                    text: Wp,
-                    trail: Hp
+                am = {
+                    arc: dp,
+                    area: pp,
+                    group: wp,
+                    image: Mp,
+                    line: Fp,
+                    path: Tp,
+                    rect: Rp,
+                    rule: Pp,
+                    shape: Lp,
+                    symbol: Bp,
+                    text: rm,
+                    trail: om
                 };
 
-            function Jp(t, e, n) {
-                var i = Xp[t.mark.marktype],
+            function sm(t, e, n) {
+                var i = am[t.mark.marktype],
                     r = e || i.bound;
-                return i.nested && (t = t.mark), r(t.bounds || (t.bounds = new $d), t, n)
+                return i.nested && (t = t.mark), r(t.bounds || (t.bounds = new uh), t, n)
             }
-            var Gp = {
+            var cm = {
                 mark: null
             };
+            const lm = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
 
-            function $p(t, e, n) {
-                var i, r, o, a, s = Xp[t.marktype],
-                    c = s.bound,
-                    l = t.items,
-                    u = l && l.length;
-                if (s.nested) return u ? o = l[0] : (Gp.mark = t, o = Gp), a = Jp(o, c, n), e = e && e.union(a) || a;
-                if (e = e || t.bounds && t.bounds.clear() || new $d, u)
-                    for (i = 0, r = l.length; i < r; ++i) e.union(Jp(l[i], c, n));
-                return t.bounds = e
-            }
-            const Zp = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
-
-            function Yp(t, e) {
-                return JSON.stringify(t, Zp, e)
-            }
-
-            function Vp(t) {
-                return Kp("string" === typeof t ? JSON.parse(t) : t)
+            function um(t) {
+                return fm("string" === typeof t ? JSON.parse(t) : t)
             }
 
-            function Kp(t) {
+            function fm(t) {
                 var e, n, i, r = t.marktype,
                     o = t.items;
                 if (o)
-                    for (n = 0, i = o.length; n < i; ++n) e = r ? "mark" : "group", o[n][e] = t, o[n].zindex && (o[n][e].zdirty = !0), "group" === (r || e) && Kp(o[n]);
-                return r && $p(t), t
+                    for (n = 0, i = o.length; n < i; ++n) e = r ? "mark" : "group", o[n][e] = t, o[n].zindex && (o[n][e].zdirty = !0), "group" === (r || e) && fm(o[n]);
+                return r && function(t, e, n) {
+                    var i, r, o, a, s = am[t.marktype],
+                        c = s.bound,
+                        l = t.items,
+                        u = l && l.length;
+                    if (s.nested) return u ? o = l[0] : (cm.mark = t, o = cm), a = sm(o, c, n), e && e.union(a) || a;
+                    if (e = e || t.bounds && t.bounds.clear() || new uh, u)
+                        for (i = 0, r = l.length; i < r; ++i) e.union(sm(l[i], c, n));
+                    t.bounds = e
+                }(t), t
             }
 
-            function Qp(t) {
-                arguments.length ? this.root = Vp(t) : (this.root = tm({
+            function dm(t) {
+                arguments.length ? this.root = um(t) : (this.root = hm({
                     marktype: "group",
                     name: "root",
                     role: "frame"
-                }), this.root.items = [new Yd(this.root)])
+                }), this.root.items = [new dh(this.root)])
             }
 
-            function tm(t, e) {
+            function hm(t, e) {
                 const n = {
-                    bounds: new $d,
+                    bounds: new uh,
                     clip: !!t.clip,
                     group: e,
                     interactive: !1 !== t.interactive,
                     items: [],
                     marktype: t.marktype,
                     name: t.name || void 0,
                     role: t.role || void 0,
                     zindex: t.zindex || 0
                 };
                 return null != t.aria && (n.aria = t.aria), t.description && (n.description = t.description), n
             }
 
-            function em(t, e, n) {
+            function pm(t, e, n) {
                 return !t && "undefined" !== typeof document && document.createElement && (t = document), t ? n ? t.createElementNS(n, e) : t.createElement(e) : null
             }
 
-            function nm(t, e) {
+            function mm(t, e) {
                 e = e.toLowerCase();
                 for (var n = t.childNodes, i = 0, r = n.length; i < r; ++i)
                     if (n[i].tagName.toLowerCase() === e) return n[i]
             }
 
-            function im(t, e, n, i) {
+            function gm(t, e, n, i) {
                 var r, o = t.childNodes[e];
-                return o && o.tagName.toLowerCase() === n.toLowerCase() || (r = o || null, o = em(t.ownerDocument, n, i), t.insertBefore(o, r)), o
+                return o && o.tagName.toLowerCase() === n.toLowerCase() || (r = o || null, o = pm(t.ownerDocument, n, i), t.insertBefore(o, r)), o
             }
 
-            function rm(t, e) {
+            function vm(t, e) {
                 for (var n = t.childNodes, i = n.length; i > e;) t.removeChild(n[--i]);
                 return t
             }
 
-            function om(t) {
+            function ym(t) {
                 return "mark-" + t.marktype + (t.role ? " role-" + t.role : "") + (t.name ? " " + t.name : "")
             }
 
-            function am(t, e) {
+            function bm(t, e) {
                 const n = e.getBoundingClientRect();
                 return [t.clientX - n.left - (e.clientLeft || 0), t.clientY - n.top - (e.clientTop || 0)]
             }
 
-            function sm(t, e) {
-                this._active = null, this._handlers = {}, this._loader = t || Yi(), this._tooltip = e || cm
+            function xm(t, e) {
+                this._active = null, this._handlers = {}, this._loader = t || Yi(), this._tooltip = e || _m
             }
 
-            function cm(t, e, n, i) {
+            function _m(t, e, n, i) {
                 t.element().setAttribute("title", i || "")
             }
 
-            function lm(t) {
-                this._el = null, this._bgcolor = null, this._loader = new Vd(t)
+            function wm(t) {
+                this._el = null, this._bgcolor = null, this._loader = new hh(t)
             }
-            Qp.prototype = {
+            dm.prototype = {
                 toJSON(t) {
-                    return Yp(this.root, t || 0)
+                    return function(t, e) {
+                        return JSON.stringify(t, lm, e)
+                    }(this.root, t || 0)
                 },
                 mark(t, e, n) {
-                    const i = tm(t, e = e || this.root.items[0]);
+                    const i = hm(t, e = e || this.root.items[0]);
                     return e.items[n] = i, i.zindex && (i.group.zdirty = !0), i
                 }
-            }, sm.prototype = {
+            }, xm.prototype = {
                 initialize(t, e, n) {
                     return this._el = t, this._obj = n || null, this.origin(e)
                 },
                 element() {
                     return this._el
                 },
                 canvas() {
@@ -29087,25 +29238,25 @@
                     return e < 0 ? t : t.slice(0, e)
                 },
                 handleHref(t, e, n) {
                     this._loader.sanitize(n, {
                         context: "href"
                     }).then((e => {
                         const n = new MouseEvent(t.type, t),
-                            i = em(null, "a");
+                            i = pm(null, "a");
                         for (const t in e) i.setAttribute(t, e[t]);
                         i.dispatchEvent(n)
                     })).catch((() => {}))
                 },
                 handleTooltip(t, e, n) {
                     if (e && null != e.tooltip) {
                         e = function(t, e, n, i) {
                             var r, o, a = t && t.mark;
-                            if (a && (r = Xp[a.marktype]).tip) {
-                                for ((o = am(e, n))[0] -= i[0], o[1] -= i[1]; t = t.mark.group;) o[0] -= t.x || 0, o[1] -= t.y || 0;
+                            if (a && (r = am[a.marktype]).tip) {
+                                for ((o = bm(e, n))[0] -= i[0], o[1] -= i[1]; t = t.mark.group;) o[0] -= t.x || 0, o[1] -= t.y || 0;
                                 t = r.tip(a.items, o)
                             }
                             return t
                         }(e, t, this.canvas(), this._origin);
                         const i = n && e && e.tooltip || null;
                         this._tooltip.call(this._obj, this, t, e, i)
                     }
@@ -29128,15 +29279,15 @@
                         height: a,
                         left: s,
                         top: c,
                         right: s + o,
                         bottom: c + a
                     }
                 }
-            }, lm.prototype = {
+            }, wm.prototype = {
                 initialize(t, e, n, i, r) {
                     return this._el = t, this.resize(e, n, i, r)
                 },
                 element() {
                     return this._el
                 },
                 canvas() {
@@ -29174,141 +29325,141 @@
                 sanitizeURL(t) {
                     return this._load("sanitizeURL", t)
                 },
                 loadImage(t) {
                     return this._load("loadImage", t)
                 }
             };
-            const um = "dragenter",
-                fm = "dragleave",
-                dm = "dragover",
-                hm = "mousedown",
-                pm = "mousemove",
-                mm = "mouseout",
-                gm = "mouseover",
-                vm = "click",
-                ym = "mousewheel",
-                bm = "touchstart",
-                xm = "touchmove",
-                _m = "touchend",
-                wm = ["keydown", "keypress", "keyup", um, fm, dm, hm, "mouseup", pm, mm, gm, vm, "dblclick", "wheel", ym, bm, xm, _m],
-                km = pm,
-                Em = mm,
-                Dm = vm;
+            const km = "dragenter",
+                Em = "dragleave",
+                Am = "dragover",
+                Dm = "mousedown",
+                Sm = "mousemove",
+                Cm = "mouseout",
+                Mm = "mouseover",
+                Fm = "click",
+                Om = "mousewheel",
+                Tm = "touchstart",
+                Nm = "touchmove",
+                Rm = "touchend",
+                zm = ["keydown", "keypress", "keyup", km, Em, Am, Dm, "mouseup", Sm, Cm, Mm, Fm, "dblclick", "wheel", Om, Tm, Nm, Rm],
+                Pm = Sm,
+                Lm = Cm,
+                Bm = Fm;
 
-            function Am(t, e) {
-                sm.call(this, t, e), this._down = null, this._touch = null, this._first = !0, this._events = {}
+            function Im(t, e) {
+                xm.call(this, t, e), this._down = null, this._touch = null, this._first = !0, this._events = {}
             }
 
-            function Sm(t, e) {
-                (t => t === bm || t === xm || t === _m ? [bm, xm, _m] : [t])(e).forEach((e => function(t, e) {
+            function jm(t, e) {
+                (t => t === Tm || t === Nm || t === Rm ? [Tm, Nm, Rm] : [t])(e).forEach((e => function(t, e) {
                     const n = t.canvas();
                     n && !t._events[e] && (t._events[e] = 1, n.addEventListener(e, t[e] ? n => t[e](n) : n => t.fire(e, n)))
                 }(t, e)))
             }
 
-            function Cm(t, e, n) {
+            function Um(t, e, n) {
                 return function(i) {
                     const r = this._active,
                         o = this.pickEvent(i);
                     o === r || (r && r.exit || this.fire(n, i), this._active = o, this.fire(e, i)), this.fire(t, i)
                 }
             }
 
-            function Fm(t) {
+            function qm(t) {
                 return function(e) {
                     this.fire(t, e), this._active = null
                 }
-            }(0, m.XW)(Am, sm, {
+            }(0, m.XW)(Im, xm, {
                 initialize(t, e, n) {
-                    return this._canvas = t && nm(t, "canvas"), [vm, hm, pm, mm, fm].forEach((t => Sm(this, t))), sm.prototype.initialize.call(this, t, e, n)
+                    return this._canvas = t && mm(t, "canvas"), [Fm, Dm, Sm, Cm, Em].forEach((t => jm(this, t))), xm.prototype.initialize.call(this, t, e, n)
                 },
                 canvas() {
                     return this._canvas
                 },
                 context() {
                     return this._canvas.getContext("2d")
                 },
-                events: wm,
+                events: zm,
                 DOMMouseScroll(t) {
-                    this.fire(ym, t)
+                    this.fire(Om, t)
                 },
-                mousemove: Cm(pm, gm, mm),
-                dragover: Cm(dm, um, fm),
-                mouseout: Fm(mm),
-                dragleave: Fm(fm),
+                mousemove: Um(Sm, Mm, Cm),
+                dragover: Um(Am, km, Em),
+                mouseout: qm(Cm),
+                dragleave: qm(Em),
                 mousedown(t) {
-                    this._down = this._active, this.fire(hm, t)
+                    this._down = this._active, this.fire(Dm, t)
                 },
                 click(t) {
-                    this._down === this._active && (this.fire(vm, t), this._down = null)
+                    this._down === this._active && (this.fire(Fm, t), this._down = null)
                 },
                 touchstart(t) {
-                    this._touch = this.pickEvent(t.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(bm, t, !0)
+                    this._touch = this.pickEvent(t.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(Tm, t, !0)
                 },
                 touchmove(t) {
-                    this.fire(xm, t, !0)
+                    this.fire(Nm, t, !0)
                 },
                 touchend(t) {
-                    this.fire(_m, t, !0), this._touch = null
+                    this.fire(Rm, t, !0), this._touch = null
                 },
                 fire(t, e, n) {
                     const i = n ? this._touch : this._active,
                         r = this._handlers[t];
-                    if (e.vegaType = t, t === Dm && i && i.href ? this.handleHref(e, i, i.href) : t !== km && t !== Em || this.handleTooltip(e, i, t !== Em), r)
+                    if (e.vegaType = t, t === Bm && i && i.href ? this.handleHref(e, i, i.href) : t !== Pm && t !== Lm || this.handleTooltip(e, i, t !== Lm), r)
                         for (let o = 0, a = r.length; o < a; ++o) r[o].handler.call(this._obj, e, i)
                 },
                 on(t, e) {
                     const n = this.eventName(t),
                         i = this._handlers;
-                    return this._handlerIndex(i[n], t, e) < 0 && (Sm(this, t), (i[n] || (i[n] = [])).push({
+                    return this._handlerIndex(i[n], t, e) < 0 && (jm(this, t), (i[n] || (i[n] = [])).push({
                         type: t,
                         handler: e
                     })), this
                 },
                 off(t, e) {
                     const n = this.eventName(t),
                         i = this._handlers[n],
                         r = this._handlerIndex(i, t, e);
                     return r >= 0 && i.splice(r, 1), this
                 },
                 pickEvent(t) {
-                    const e = am(t, this._canvas),
+                    const e = bm(t, this._canvas),
                         n = this._origin;
                     return this.pick(this._scene, e[0], e[1], e[0] - n[0], e[1] - n[1])
                 },
                 pick(t, e, n, i, r) {
                     const o = this.context();
-                    return Xp[t.marktype].pick.call(this, o, t, e, n, i, r)
+                    return am[t.marktype].pick.call(this, o, t, e, n, i, r)
                 }
             });
-            var Mm = "undefined" !== typeof window && window.devicePixelRatio || 1;
+            var Wm = "undefined" !== typeof window && window.devicePixelRatio || 1;
 
-            function Om(t) {
-                lm.call(this, t), this._options = {}, this._redraw = !1, this._dirty = new $d, this._tempb = new $d
+            function Hm(t) {
+                wm.call(this, t), this._options = {}, this._redraw = !1, this._dirty = new uh, this._tempb = new uh
             }
-            const Tm = lm.prototype;
+            const Xm = wm.prototype;
 
-            function Nm(t, e) {
-                sm.call(this, t, e);
+            function Gm(t, e) {
+                xm.call(this, t, e);
                 const n = this;
-                n._hrefHandler = zm(n, ((t, e) => {
+                n._hrefHandler = Jm(n, ((t, e) => {
                     e && e.href && n.handleHref(t, e, e.href)
-                })), n._tooltipHandler = zm(n, ((t, e) => {
-                    n.handleTooltip(t, e, t.type !== Em)
+                })), n._tooltipHandler = Jm(n, ((t, e) => {
+                    n.handleTooltip(t, e, t.type !== Lm)
                 }))
-            }(0, m.XW)(Om, lm, {
+            }(0, m.XW)(Hm, wm, {
                 initialize(t, e, n, i, r, o) {
-                    return this._options = o || {}, this._canvas = this._options.externalContext ? null : Xc(1, 1, this._options.type), t && this._canvas && (rm(t, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), Tm.initialize.call(this, t, e, n, i, r)
+                    return this._options = o || {}, this._canvas = this._options.externalContext ? null : il(1, 1, this._options.type), t && this._canvas && (vm(t, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), Xm.initialize.call(this, t, e, n, i, r)
                 },
                 resize(t, e, n, i) {
-                    if (Tm.resize.call(this, t, e, n, i), this._canvas) ! function(t, e, n, i, r, o) {
+                    if (Xm.resize.call(this, t, e, n, i), this._canvas) ! function(t, e, n, i, r, o) {
                         const a = "undefined" !== typeof HTMLElement && t instanceof HTMLElement && null != t.parentNode,
                             s = t.getContext("2d"),
-                            c = a ? Mm : r;
+                            c = a ? Wm : r;
                         t.width = e * c, t.height = n * c;
                         for (const l in o) s[l] = o[l];
                         a && 1 !== c && (t.style.width = e + "px", t.style.height = n + "px"), s.pixelRatio = c, s.setTransform(c, 0, 0, c, c * i[0], c * i[1])
                     }(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
                     else {
                         const t = this._options.externalContext;
                         t || (0, m.vU)("CanvasRenderer is missing a valid canvas or context"), t.scale(this._scale, this._scale), t.translate(this._origin[0], this._origin[1])
@@ -29329,174 +29480,173 @@
                 },
                 _render(t) {
                     const e = this.context(),
                         n = this._origin,
                         i = this._width,
                         r = this._height,
                         o = this._dirty,
-                        a = ((t, e, n) => (new $d).set(0, 0, e, n).translate(-t[0], -t[1]))(n, i, r);
+                        a = ((t, e, n) => (new uh).set(0, 0, e, n).translate(-t[0], -t[1]))(n, i, r);
                     e.save();
                     const s = this._redraw || o.empty() ? (this._redraw = !1, a.expand(1)) : function(t, e, n) {
                         return e.expand(1).round(), t.pixelRatio % 1 && e.scale(t.pixelRatio).round().scale(1 / t.pixelRatio), e.translate(-n[0] % 1, -n[1] % 1), t.beginPath(), t.rect(e.x1, e.y1, e.width(), e.height()), t.clip(), e
                     }(e, a.intersect(o), n);
                     return this.clear(-n[0], -n[1], i, r), this.draw(e, t, s), e.restore(), o.clear(), this
                 },
                 draw(t, e, n) {
-                    const i = Xp[e.marktype];
+                    const i = am[e.marktype];
                     e.clip && function(t, e) {
                         var n = e.clip;
-                        t.save(), (0, m.mf)(n) ? (t.beginPath(), n(t), t.clip()) : tp(t, e.group)
+                        t.save(), (0, m.mf)(n) ? (t.beginPath(), n(t), t.clip()) : mp(t, e.group)
                     }(t, e), i.draw.call(this, t, e, n), e.clip && t.restore()
                 },
                 clear(t, e, n, i) {
                     const r = this._options,
                         o = this.context();
                     "pdf" === r.type || r.externalContext || o.clearRect(t, e, n, i), null != this._bgcolor && (o.fillStyle = this._bgcolor, o.fillRect(t, e, n, i))
                 }
             });
-            const zm = (t, e) => n => {
+            const Jm = (t, e) => n => {
                 let i = n.target.__data__;
                 i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, e.call(t._obj, n, i)
             };
-            (0, m.XW)(Nm, sm, {
+            (0, m.XW)(Gm, xm, {
                 initialize(t, e, n) {
                     let i = this._svg;
-                    return i && (i.removeEventListener(Dm, this._hrefHandler), i.removeEventListener(km, this._tooltipHandler), i.removeEventListener(Em, this._tooltipHandler)), this._svg = i = t && nm(t, "svg"), i && (i.addEventListener(Dm, this._hrefHandler), i.addEventListener(km, this._tooltipHandler), i.addEventListener(Em, this._tooltipHandler)), sm.prototype.initialize.call(this, t, e, n)
+                    return i && (i.removeEventListener(Bm, this._hrefHandler), i.removeEventListener(Pm, this._tooltipHandler), i.removeEventListener(Lm, this._tooltipHandler)), this._svg = i = t && mm(t, "svg"), i && (i.addEventListener(Bm, this._hrefHandler), i.addEventListener(Pm, this._tooltipHandler), i.addEventListener(Lm, this._tooltipHandler)), xm.prototype.initialize.call(this, t, e, n)
                 },
                 canvas() {
                     return this._svg
                 },
                 on(t, e) {
                     const n = this.eventName(t),
                         i = this._handlers;
                     if (this._handlerIndex(i[n], t, e) < 0) {
                         const r = {
                             type: t,
                             handler: e,
-                            listener: zm(this, e)
+                            listener: Jm(this, e)
                         };
                         (i[n] || (i[n] = [])).push(r), this._svg && this._svg.addEventListener(n, r.listener)
                     }
                     return this
                 },
                 off(t, e) {
                     const n = this.eventName(t),
                         i = this._handlers[n],
                         r = this._handlerIndex(i, t, e);
                     return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this
                 }
             });
-            const Rm = "aria-hidden",
-                Pm = "aria-label",
-                Lm = "role",
-                jm = "aria-roledescription",
-                Bm = "graphics-object",
-                Im = "graphics-symbol",
-                Um = (t, e, n) => ({
-                    [Lm]: t,
-                    [jm]: e,
-                    [Pm]: n || void 0
+            const Zm = "aria-hidden",
+                $m = "aria-label",
+                Ym = "role",
+                Vm = "aria-roledescription",
+                Km = "graphics-object",
+                Qm = "graphics-symbol",
+                tg = (t, e, n) => ({
+                    [Ym]: t,
+                    [Vm]: e,
+                    [$m]: n || void 0
                 }),
-                qm = (0, m.Rg)(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
-                Wm = {
+                eg = (0, m.Rg)(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
+                ng = {
                     axis: {
                         desc: "axis",
                         caption: function(t) {
                             const e = t.datum,
                                 n = t.orient,
-                                i = e.title ? $m(t) : null,
+                                i = e.title ? sg(t) : null,
                                 r = t.context,
                                 o = r.scales[e.scale].value,
                                 a = r.dataflow.locale(),
                                 s = o.type;
-                            return "".concat("left" === n || "right" === n ? "Y" : "X", "-axis") + (i ? " titled '".concat(i, "'") : "") + " for a ".concat(uf(s) ? "discrete" : s, " scale") + " with ".concat(Jf(a, o, t))
+                            return "".concat("left" === n || "right" === n ? "Y" : "X", "-axis") + (i ? " titled '".concat(i, "'") : "") + " for a ".concat(Nf(s) ? "discrete" : s, " scale") + " with ".concat(fd(a, o, t))
                         }
                     },
                     legend: {
                         desc: "legend",
                         caption: function(t) {
                             const e = t.datum,
-                                n = e.title ? $m(t) : null,
+                                n = e.title ? sg(t) : null,
                                 i = "".concat(e.type || "", " legend").trim(),
                                 r = e.scales,
                                 o = Object.keys(r),
                                 a = t.context,
                                 s = a.scales[r[o[0]]].value,
                                 c = a.dataflow.locale();
                             return function(t) {
                                 return t.length ? t[0].toUpperCase() + t.slice(1) : t
                             }(i) + (n ? " titled '".concat(n, "'") : "") + " for ".concat(function(t) {
                                 return t = t.map((t => t + ("fill" === t || "stroke" === t ? " color" : ""))), t.length < 2 ? t[0] : t.slice(0, -1).join(", ") + " and " + (0, m.fj)(t)
-                            }(o)) + " with ".concat(Jf(c, s, t))
+                            }(o)) + " with ".concat(fd(c, s, t))
                         }
                     },
                     "title-text": {
                         desc: "title",
-                        caption: t => "Title text '".concat(Gm(t), "'")
+                        caption: t => "Title text '".concat(ag(t), "'")
                     },
                     "title-subtitle": {
                         desc: "subtitle",
-                        caption: t => "Subtitle text '".concat(Gm(t), "'")
+                        caption: t => "Subtitle text '".concat(ag(t), "'")
                     }
                 },
-                Hm = {
-                    ariaRole: Lm,
-                    ariaRoleDescription: jm,
-                    description: Pm
+                ig = {
+                    ariaRole: Ym,
+                    ariaRoleDescription: Vm,
+                    description: $m
                 };
 
-            function Xm(t, e) {
+            function rg(t, e) {
                 const n = !1 === e.aria;
-                if (t(Rm, n || void 0), n || null == e.description)
-                    for (const i in Hm) t(Hm[i], void 0);
+                if (t(Zm, n || void 0), n || null == e.description)
+                    for (const i in ig) t(ig[i], void 0);
                 else {
                     const n = e.mark.marktype;
-                    t(Pm, e.description), t(Lm, e.ariaRole || ("group" === n ? Bm : Im)), t(jm, e.ariaRoleDescription || "".concat(n, " mark"))
+                    t($m, e.description), t(Ym, e.ariaRole || ("group" === n ? Km : Qm)), t(Vm, e.ariaRoleDescription || "".concat(n, " mark"))
                 }
             }
 
-            function Jm(t) {
+            function og(t) {
                 return !1 === t.aria ? {
-                    [Rm]: !0
-                } : qm[t.role] ? null : Wm[t.role] ? function(t, e) {
+                    [Zm]: !0
+                } : eg[t.role] ? null : ng[t.role] ? function(t, e) {
                     try {
                         const n = t.items[0],
                             i = e.caption || (() => "");
-                        return Um(e.role || Im, e.desc, n.description || i(n))
+                        return tg(e.role || Qm, e.desc, n.description || i(n))
                     } catch (n) {
                         return null
                     }
-                }(t, Wm[t.role]) : function(t) {
+                }(t, ng[t.role]) : function(t) {
                     const e = t.marktype,
                         n = "group" === e || "text" === e || t.items.some((t => null != t.description && !1 !== t.aria));
-                    return Um(n ? Bm : Im, "".concat(e, " mark container"), t.description)
+                    return tg(n ? Km : Qm, "".concat(e, " mark container"), t.description)
                 }(t)
             }
 
-            function Gm(t) {
+            function ag(t) {
                 return (0, m.IX)(t.text).join(" ")
             }
 
-            function $m(t) {
+            function sg(t) {
                 try {
                     return (0, m.IX)((0, m.fj)(t.items).items[0].text).join(" ")
                 } catch (e) {
                     return null
                 }
             }
-            const Zm = t => (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
-                Ym = t => Zm(t).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
+            const cg = t => (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
 
-            function Vm() {
+            function lg() {
                 let t = "",
                     e = "",
                     n = "";
                 const i = [],
                     r = () => e = n = "",
-                    o = (t, n) => (null != n && (e += " ".concat(t, '="').concat(Ym(n), '"')), a),
+                    o = (t, n) => (null != n && (e += " ".concat(t, '="').concat(cg(n).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"), '"')), a),
                     a = {
                         open(s) {
                             (o => {
                                 e && (t += "".concat(e, ">").concat(n), r()), i.push(o)
                             })(s), e = "<" + s;
                             for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), u = 1; u < c; u++) l[u - 1] = arguments[u];
                             for (const t of l)
@@ -29504,341 +29654,341 @@
                             return a
                         },
                         close() {
                             const o = i.pop();
                             return t += e ? e + (n ? ">".concat(n, "</").concat(o, ">") : "/>") : "</".concat(o, ">"), r(), a
                         },
                         attr: o,
-                        text: t => (n += Zm(t), a),
+                        text: t => (n += cg(t), a),
                         toString: () => t
                     };
                 return a
             }
-            const Km = t => Qm(Vm(), t) + "";
+            const ug = t => fg(lg(), t) + "";
 
-            function Qm(t, e) {
+            function fg(t, e) {
                 if (t.open(e.tagName), e.hasAttributes()) {
                     const n = e.attributes,
                         i = n.length;
                     for (let e = 0; e < i; ++e) t.attr(n[e].name, n[e].value)
                 }
                 if (e.hasChildNodes()) {
                     const n = e.childNodes;
-                    for (const e of n) 3 === e.nodeType ? t.text(e.nodeValue) : Qm(t, e)
+                    for (const e of n) 3 === e.nodeType ? t.text(e.nodeValue) : fg(t, e)
                 }
                 return t.close()
             }
-            const tg = {
+            const dg = {
                     fill: "fill",
                     fillOpacity: "fill-opacity",
                     stroke: "stroke",
                     strokeOpacity: "stroke-opacity",
                     strokeWidth: "stroke-width",
                     strokeCap: "stroke-linecap",
                     strokeJoin: "stroke-linejoin",
                     strokeDash: "stroke-dasharray",
                     strokeDashOffset: "stroke-dashoffset",
                     strokeMiterLimit: "stroke-miterlimit",
                     opacity: "opacity"
                 },
-                eg = {
+                hg = {
                     blend: "mix-blend-mode"
                 },
-                ng = {
+                pg = {
                     fill: "none",
                     "stroke-miterlimit": 10
                 },
-                ig = "http://www.w3.org/2000/xmlns/",
-                rg = cp.xmlns;
+                mg = "http://www.w3.org/2000/xmlns/",
+                gg = kp.xmlns;
 
-            function og(t) {
-                lm.call(this, t), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
+            function vg(t) {
+                wm.call(this, t), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
             }
-            const ag = lm.prototype;
+            const yg = wm.prototype;
 
-            function sg(t, e) {
+            function bg(t, e) {
                 for (; t && t.dirty !== e; t = t.mark.group) {
                     if (t.dirty = e, !t.mark || t.mark.dirty === e) return;
                     t.mark.dirty = e
                 }
             }
 
-            function cg(t, e, n) {
+            function xg(t, e, n) {
                 let i, r, o;
                 if ("radial" === e.gradient) {
-                    let i = im(t, n++, "pattern", rg);
-                    gg(i, {
-                        id: $f + e.id,
+                    let i = gm(t, n++, "pattern", gg);
+                    Cg(i, {
+                        id: hd + e.id,
                         viewBox: "0,0,1,1",
                         width: "100%",
                         height: "100%",
                         preserveAspectRatio: "xMidYMid slice"
-                    }), i = im(i, 0, "rect", rg), gg(i, {
+                    }), i = gm(i, 0, "rect", gg), Cg(i, {
                         width: 1,
                         height: 1,
-                        fill: "url(".concat(yg(), "#").concat(e.id, ")")
-                    }), gg(t = im(t, n++, "radialGradient", rg), {
+                        fill: "url(".concat(Fg(), "#").concat(e.id, ")")
+                    }), Cg(t = gm(t, n++, "radialGradient", gg), {
                         id: e.id,
                         fx: e.x1,
                         fy: e.y1,
                         fr: e.r1,
                         cx: e.x2,
                         cy: e.y2,
                         r: e.r2
                     })
-                } else gg(t = im(t, n++, "linearGradient", rg), {
+                } else Cg(t = gm(t, n++, "linearGradient", gg), {
                     id: e.id,
                     x1: e.x1,
                     x2: e.x2,
                     y1: e.y1,
                     y2: e.y2
                 });
-                for (i = 0, r = e.stops.length; i < r; ++i) o = im(t, i, "stop", rg), o.setAttribute("offset", e.stops[i].offset), o.setAttribute("stop-color", e.stops[i].color);
-                return rm(t, i), n
+                for (i = 0, r = e.stops.length; i < r; ++i) o = gm(t, i, "stop", gg), o.setAttribute("offset", e.stops[i].offset), o.setAttribute("stop-color", e.stops[i].color);
+                return vm(t, i), n
             }
 
-            function lg(t, e, n) {
+            function _g(t, e, n) {
                 let i;
-                return (t = im(t, n, "clipPath", rg)).setAttribute("id", e.id), e.path ? (i = im(t, 0, "path", rg), i.setAttribute("d", e.path)) : (i = im(t, 0, "rect", rg), gg(i, {
+                return (t = gm(t, n, "clipPath", gg)).setAttribute("id", e.id), e.path ? (i = gm(t, 0, "path", gg), i.setAttribute("d", e.path)) : (i = gm(t, 0, "rect", gg), Cg(i, {
                     x: 0,
                     y: 0,
                     width: e.width,
                     height: e.height
-                })), rm(t, 1), n + 1
+                })), vm(t, 1), n + 1
             }
 
-            function ug(t, e, n, i, r) {
+            function wg(t, e, n, i, r) {
                 let o, a = t._svg;
-                if (!a && (o = e.ownerDocument, a = em(o, i, rg), t._svg = a, t.mark && (a.__data__ = t, a.__values__ = {
+                if (!a && (o = e.ownerDocument, a = pm(o, i, gg), t._svg = a, t.mark && (a.__data__ = t, a.__values__ = {
                         fill: "default"
                     }, "g" === i))) {
-                    const e = em(o, "path", rg);
+                    const e = pm(o, "path", gg);
                     a.appendChild(e), e.__data__ = t;
-                    const n = em(o, "g", rg);
+                    const n = pm(o, "g", gg);
                     a.appendChild(n), n.__data__ = t;
-                    const i = em(o, "path", rg);
+                    const i = pm(o, "path", gg);
                     a.appendChild(i), i.__data__ = t, i.__values__ = {
                         fill: "default"
                     }
                 }
                 return (a.ownerSVGElement !== r || function(t, e) {
                     return t.parentNode && t.parentNode.childNodes.length > 1 && t.previousSibling != e
                 }(a, n)) && e.insertBefore(a, n ? n.nextSibling : e.firstChild), a
-            }(0, m.XW)(og, lm, {
+            }(0, m.XW)(vg, wm, {
                 initialize(t, e, n, i, r) {
-                    return this._defs = {}, this._clearDefs(), t && (this._svg = im(t, 0, "svg", rg), this._svg.setAttributeNS(ig, "xmlns", rg), this._svg.setAttributeNS(ig, "xmlns:xlink", cp["xmlns:xlink"]), this._svg.setAttribute("version", cp.version), this._svg.setAttribute("class", "marks"), rm(t, 1), this._root = im(this._svg, 0, "g", rg), gg(this._root, ng), rm(this._svg, 1)), this.background(this._bgcolor), ag.initialize.call(this, t, e, n, i, r)
+                    return this._defs = {}, this._clearDefs(), t && (this._svg = gm(t, 0, "svg", gg), this._svg.setAttributeNS(mg, "xmlns", gg), this._svg.setAttributeNS(mg, "xmlns:xlink", kp["xmlns:xlink"]), this._svg.setAttribute("version", kp.version), this._svg.setAttribute("class", "marks"), vm(t, 1), this._root = gm(this._svg, 0, "g", gg), Cg(this._root, pg), vm(this._svg, 1)), this.background(this._bgcolor), yg.initialize.call(this, t, e, n, i, r)
                 },
                 background(t) {
-                    return arguments.length && this._svg && this._svg.style.setProperty("background-color", t), ag.background.apply(this, arguments)
+                    return arguments.length && this._svg && this._svg.style.setProperty("background-color", t), yg.background.apply(this, arguments)
                 },
                 resize(t, e, n, i) {
-                    return ag.resize.call(this, t, e, n, i), this._svg && (gg(this._svg, {
+                    return yg.resize.call(this, t, e, n, i), this._svg && (Cg(this._svg, {
                         width: this._width * this._scale,
                         height: this._height * this._scale,
                         viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
                     }), this._root.setAttribute("transform", "translate(".concat(this._origin, ")"))), this._dirty = [], this
                 },
                 canvas() {
                     return this._svg
                 },
                 svg() {
                     const t = this._svg,
                         e = this._bgcolor;
                     if (!t) return null;
                     let n;
-                    e && (t.removeAttribute("style"), n = im(t, 0, "rect", rg), gg(n, {
+                    e && (t.removeAttribute("style"), n = gm(t, 0, "rect", gg), Cg(n, {
                         width: this._width,
                         height: this._height,
                         fill: e
                     }));
-                    const i = Km(t);
+                    const i = ug(t);
                     return e && (t.removeChild(n), this._svg.style.setProperty("background-color", e)), i
                 },
                 _render(t) {
-                    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t), rm(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
+                    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t), vm(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
                 },
                 dirty(t) {
                     t.dirty !== this._dirtyID && (t.dirty = this._dirtyID, this._dirty.push(t))
                 },
                 isDirty(t) {
                     return this._dirtyAll || !t._svg || !t._svg.ownerSVGElement || t.dirty === this._dirtyID
                 },
                 _dirtyCheck() {
                     this._dirtyAll = !0;
                     const t = this._dirty;
                     if (!t.length || !this._dirtyID) return !0;
                     const e = ++this._dirtyID;
                     let n, i, r, o, a, s, c;
-                    for (a = 0, s = t.length; a < s; ++a) n = t[a], i = n.mark, i.marktype !== r && (r = i.marktype, o = Xp[r]), i.zdirty && i.dirty !== e && (this._dirtyAll = !1, sg(n, e), i.items.forEach((t => {
+                    for (a = 0, s = t.length; a < s; ++a) n = t[a], i = n.mark, i.marktype !== r && (r = i.marktype, o = am[r]), i.zdirty && i.dirty !== e && (this._dirtyAll = !1, bg(n, e), i.items.forEach((t => {
                         t.dirty = e
-                    }))), i.zdirty || (n.exit ? (o.nested && i.items.length ? (c = i.items[0], c._svg && this._update(o, c._svg, c)) : n._svg && (c = n._svg.parentNode, c && c.removeChild(n._svg)), n._svg = null) : (n = o.nested ? i.items[0] : n, n._update !== e && (n._svg && n._svg.ownerSVGElement ? this._update(o, n._svg, n) : (this._dirtyAll = !1, sg(n, e)), n._update = e)));
+                    }))), i.zdirty || (n.exit ? (o.nested && i.items.length ? (c = i.items[0], c._svg && this._update(o, c._svg, c)) : n._svg && (c = n._svg.parentNode, c && c.removeChild(n._svg)), n._svg = null) : (n = o.nested ? i.items[0] : n, n._update !== e && (n._svg && n._svg.ownerSVGElement ? this._update(o, n._svg, n) : (this._dirtyAll = !1, bg(n, e)), n._update = e)));
                     return !this._dirtyAll
                 },
                 mark(t, e, n) {
                     if (!this.isDirty(e)) return e._svg;
                     const i = this._svg,
-                        r = Xp[e.marktype],
+                        r = am[e.marktype],
                         o = !1 === e.interactive ? "none" : null,
                         a = "g" === r.tag,
-                        s = ug(e, t, n, "g", i);
-                    s.setAttribute("class", om(e));
-                    const c = Jm(e);
-                    for (const d in c) vg(s, d, c[d]);
-                    a || vg(s, "pointer-events", o), vg(s, "clip-path", e.clip ? Gd(this, e, e.group) : null);
+                        s = wg(e, t, n, "g", i);
+                    s.setAttribute("class", ym(e));
+                    const c = og(e);
+                    for (const d in c) Mg(s, d, c[d]);
+                    a || Mg(s, "pointer-events", o), Mg(s, "clip-path", e.clip ? lh(this, e, e.group) : null);
                     let l = null,
                         u = 0;
                     const f = t => {
                         const e = this.isDirty(t),
-                            n = ug(t, s, l, r.tag, i);
+                            n = wg(t, s, l, r.tag, i);
                         e && (this._update(r, n, t), a && function(t, e, n) {
                             e = e.lastChild.previousSibling;
                             let i, r = 0;
-                            Bh(n, (n => {
+                            tp(n, (n => {
                                 i = t.mark(e, n, i), ++r
-                            })), rm(e, 1 + r)
+                            })), vm(e, 1 + r)
                         }(this, n, t)), l = n, ++u
                     };
-                    return r.nested ? e.items.length && f(e.items[0]) : Bh(e, f), rm(s, u), s
+                    return r.nested ? e.items.length && f(e.items[0]) : tp(e, f), vm(s, u), s
                 },
                 _update(t, e, n) {
-                    fg = e, dg = e.__values__, Xm(pg, n), t.attr(pg, n, this);
-                    const i = hg[t.type];
-                    i && i.call(this, t, e, n), fg && this.style(fg, n)
+                    kg = e, Eg = e.__values__, rg(Dg, n), t.attr(Dg, n, this);
+                    const i = Ag[t.type];
+                    i && i.call(this, t, e, n), kg && this.style(kg, n)
                 },
                 style(t, e) {
                     if (null != e) {
-                        for (const n in tg) {
-                            let i = "font" === n ? Pp(e) : e[n];
-                            if (i === dg[n]) continue;
-                            const r = tg[n];
-                            null == i ? t.removeAttribute(r) : (Zf(i) && (i = Yf(i, this._defs.gradient, yg())), t.setAttribute(r, i + "")), dg[n] = i
+                        for (const n in dg) {
+                            let i = "font" === n ? Vp(e) : e[n];
+                            if (i === Eg[n]) continue;
+                            const r = dg[n];
+                            null == i ? t.removeAttribute(r) : (pd(i) && (i = md(i, this._defs.gradient, Fg())), t.setAttribute(r, i + "")), Eg[n] = i
                         }
-                        for (const n in eg) mg(t, eg[n], e[n])
+                        for (const n in hg) Sg(t, hg[n], e[n])
                     }
                 },
                 defs() {
                     const t = this._svg,
                         e = this._defs;
                     let n = e.el,
                         i = 0;
-                    for (const r in e.gradient) n || (e.el = n = im(t, 1, "defs", rg)), i = cg(n, e.gradient[r], i);
-                    for (const r in e.clipping) n || (e.el = n = im(t, 1, "defs", rg)), i = lg(n, e.clipping[r], i);
-                    n && (0 === i ? (t.removeChild(n), e.el = null) : rm(n, i))
+                    for (const r in e.gradient) n || (e.el = n = gm(t, 1, "defs", gg)), i = xg(n, e.gradient[r], i);
+                    for (const r in e.clipping) n || (e.el = n = gm(t, 1, "defs", gg)), i = _g(n, e.clipping[r], i);
+                    n && (0 === i ? (t.removeChild(n), e.el = null) : vm(n, i))
                 },
                 _clearDefs() {
                     const t = this._defs;
                     t.gradient = {}, t.clipping = {}
                 }
             });
-            let fg = null,
-                dg = null;
-            const hg = {
+            let kg = null,
+                Eg = null;
+            const Ag = {
                 group(t, e, n) {
-                    const i = fg = e.childNodes[2];
-                    dg = i.__values__, t.foreground(pg, n, this), dg = e.__values__, fg = e.childNodes[1], t.content(pg, n, this);
-                    const r = fg = e.childNodes[0];
-                    t.background(pg, n, this);
+                    const i = kg = e.childNodes[2];
+                    Eg = i.__values__, t.foreground(Dg, n, this), Eg = e.__values__, kg = e.childNodes[1], t.content(Dg, n, this);
+                    const r = kg = e.childNodes[0];
+                    t.background(Dg, n, this);
                     const o = !1 === n.mark.interactive ? "none" : null;
-                    if (o !== dg.events && (vg(i, "pointer-events", o), vg(r, "pointer-events", o), dg.events = o), n.strokeForeground && n.stroke) {
+                    if (o !== Eg.events && (Mg(i, "pointer-events", o), Mg(r, "pointer-events", o), Eg.events = o), n.strokeForeground && n.stroke) {
                         const t = n.fill;
-                        vg(i, "display", null), this.style(r, n), vg(r, "stroke", null), t && (n.fill = null), dg = i.__values__, this.style(i, n), t && (n.fill = t), fg = null
-                    } else vg(i, "display", "none")
+                        Mg(i, "display", null), this.style(r, n), Mg(r, "stroke", null), t && (n.fill = null), Eg = i.__values__, this.style(i, n), t && (n.fill = t), kg = null
+                    } else Mg(i, "display", "none")
                 },
                 image(t, e, n) {
-                    !1 === n.smooth ? (mg(e, "image-rendering", "optimizeSpeed"), mg(e, "image-rendering", "pixelated")) : mg(e, "image-rendering", null)
+                    !1 === n.smooth ? (Sg(e, "image-rendering", "optimizeSpeed"), Sg(e, "image-rendering", "pixelated")) : Sg(e, "image-rendering", null)
                 },
                 text(t, e, n) {
-                    const i = Np(n);
+                    const i = Zp(n);
                     let r, o, a, s;
-                    (0, m.kJ)(i) ? (o = i.map((t => Rp(n, t))), r = o.join("\n"), r !== dg.text && (rm(e, 0), a = e.ownerDocument, s = Tp(n), o.forEach(((t, i) => {
-                        const r = em(a, "tspan", rg);
+                    (0, m.kJ)(i) ? (o = i.map((t => Yp(n, t))), r = o.join("\n"), r !== Eg.text && (vm(e, 0), a = e.ownerDocument, s = Jp(n), o.forEach(((t, i) => {
+                        const r = pm(a, "tspan", gg);
                         r.__data__ = n, r.textContent = t, i && (r.setAttribute("x", 0), r.setAttribute("dy", s)), e.appendChild(r)
-                    })), dg.text = r)) : (o = Rp(n, i), o !== dg.text && (e.textContent = o, dg.text = o)), vg(e, "font-family", Pp(n)), vg(e, "font-size", Op(n) + "px"), vg(e, "font-style", n.fontStyle), vg(e, "font-variant", n.fontVariant), vg(e, "font-weight", n.fontWeight)
+                    })), Eg.text = r)) : (o = Yp(n, i), o !== Eg.text && (e.textContent = o, Eg.text = o)), Mg(e, "font-family", Vp(n)), Mg(e, "font-size", Gp(n) + "px"), Mg(e, "font-style", n.fontStyle), Mg(e, "font-variant", n.fontVariant), Mg(e, "font-weight", n.fontWeight)
                 }
             };
 
-            function pg(t, e, n) {
-                e !== dg[t] && (n ? function(t, e, n, i) {
+            function Dg(t, e, n) {
+                e !== Eg[t] && (n ? function(t, e, n, i) {
                     null != n ? t.setAttributeNS(i, e, n) : t.removeAttributeNS(i, e)
-                }(fg, t, e, n) : vg(fg, t, e), dg[t] = e)
+                }(kg, t, e, n) : Mg(kg, t, e), Eg[t] = e)
             }
 
-            function mg(t, e, n) {
-                n !== dg[e] && (null == n ? t.style.removeProperty(e) : t.style.setProperty(e, n + ""), dg[e] = n)
+            function Sg(t, e, n) {
+                n !== Eg[e] && (null == n ? t.style.removeProperty(e) : t.style.setProperty(e, n + ""), Eg[e] = n)
             }
 
-            function gg(t, e) {
-                for (const n in e) vg(t, n, e[n])
+            function Cg(t, e) {
+                for (const n in e) Mg(t, n, e[n])
             }
 
-            function vg(t, e, n) {
+            function Mg(t, e, n) {
                 null != n ? t.setAttribute(e, n) : t.removeAttribute(e)
             }
 
-            function yg() {
+            function Fg() {
                 let t;
                 return "undefined" === typeof window ? "" : (t = window.location).hash ? t.href.slice(0, -t.hash.length) : t.href
             }
 
-            function bg(t) {
-                lm.call(this, t), this._text = null, this._defs = {
+            function Og(t) {
+                wm.call(this, t), this._text = null, this._defs = {
                     gradient: {},
                     clipping: {}
                 }
-            }(0, m.XW)(bg, lm, {
+            }(0, m.XW)(Og, wm, {
                 svg() {
                     return this._text
                 },
                 _render(t) {
-                    const e = Vm();
-                    e.open("svg", (0, m.l7)({}, cp, {
+                    const e = lg();
+                    e.open("svg", (0, m.l7)({}, kp, {
                         class: "marks",
                         width: this._width * this._scale,
                         height: this._height * this._scale,
                         viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
                     }));
                     const n = this._bgcolor;
                     return n && "transparent" !== n && "none" !== n && e.open("rect", {
                         width: this._width,
                         height: this._height,
                         fill: n
-                    }).close(), e.open("g", ng, {
+                    }).close(), e.open("g", pg, {
                         transform: "translate(" + this._origin + ")"
                     }), this.mark(e, t), e.close(), this.defs(e), this._text = e.close() + "", this
                 },
                 mark(t, e) {
-                    const n = Xp[e.marktype],
+                    const n = am[e.marktype],
                         i = n.tag,
-                        r = [Xm, n.attr];
+                        r = [rg, n.attr];
                     t.open("g", {
-                        class: om(e),
-                        "clip-path": e.clip ? Gd(this, e, e.group) : null
-                    }, Jm(e), {
+                        class: ym(e),
+                        "clip-path": e.clip ? lh(this, e, e.group) : null
+                    }, og(e), {
                         "pointer-events": "g" !== i && !1 === e.interactive ? "none" : null
                     });
                     const o = o => {
                         const a = this.href(o);
                         if (a && t.open("a", a), t.open(i, this.attr(e, o, r, "g" !== i ? i : null)), "text" === i) {
-                            const e = Np(o);
+                            const e = Zp(o);
                             if ((0, m.kJ)(e)) {
                                 const n = {
                                     x: 0,
-                                    dy: Tp(o)
+                                    dy: Jp(o)
                                 };
-                                for (let i = 0; i < e.length; ++i) t.open("tspan", i ? n : null).text(Rp(o, e[i])).close()
-                            } else t.text(Rp(o, e))
+                                for (let i = 0; i < e.length; ++i) t.open("tspan", i ? n : null).text(Yp(o, e[i])).close()
+                            } else t.text(Yp(o, e))
                         } else if ("g" === i) {
                             const i = o.strokeForeground,
                                 r = o.fill,
                                 a = o.stroke;
-                            i && a && (o.stroke = null), t.open("path", this.attr(e, o, n.background, "bgrect")).close(), t.open("g", this.attr(e, o, n.content)), Bh(o, (e => this.mark(t, e))), t.close(), i && a ? (r && (o.fill = null), o.stroke = a, t.open("path", this.attr(e, o, n.foreground, "bgrect")).close(), r && (o.fill = r)) : t.open("path", this.attr(e, o, n.foreground, "bgfore")).close()
+                            i && a && (o.stroke = null), t.open("path", this.attr(e, o, n.background, "bgrect")).close(), t.open("g", this.attr(e, o, n.content)), tp(o, (e => this.mark(t, e))), t.close(), i && a ? (r && (o.fill = null), o.stroke = a, t.open("path", this.attr(e, o, n.foreground, "bgrect")).close(), r && (o.fill = r)) : t.open("path", this.attr(e, o, n.foreground, "bgfore")).close()
                         }
                         t.close(), a && t.close()
                     };
-                    return n.nested ? e.items && e.items.length && o(e.items[0]) : Bh(e, o), t.close()
+                    return n.nested ? e.items && e.items.length && o(e.items[0]) : tp(e, o), t.close()
                 },
                 href(t) {
                     const e = t.href;
                     let n;
                     if (e) {
                         if (n = this._hrefs && this._hrefs[e]) return n;
                         this.sanitizeURL(e).then((t => {
@@ -29854,37 +30004,37 @@
                         };
                     return Array.isArray(n) ? n.forEach((t => t(o, e, this))) : n(o, e, this), i && function(t, e, n, i, r) {
                         let o;
                         if (null == e) return t;
                         "bgrect" === i && !1 === n.interactive && (t["pointer-events"] = "none");
                         if ("bgfore" === i && (!1 === n.interactive && (t["pointer-events"] = "none"), t.display = "none", null !== e.fill)) return t;
                         "image" === i && !1 === e.smooth && (o = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]);
-                        "text" === i && (t["font-family"] = Pp(e), t["font-size"] = Op(e) + "px", t["font-style"] = e.fontStyle, t["font-variant"] = e.fontVariant, t["font-weight"] = e.fontWeight);
-                        for (const a in tg) {
+                        "text" === i && (t["font-family"] = Vp(e), t["font-size"] = Gp(e) + "px", t["font-style"] = e.fontStyle, t["font-variant"] = e.fontVariant, t["font-weight"] = e.fontWeight);
+                        for (const a in dg) {
                             let n = e[a];
-                            const i = tg[a];
-                            ("transparent" !== n || "fill" !== i && "stroke" !== i) && null != n && (Zf(n) && (n = Yf(n, r.gradient, "")), t[i] = n)
+                            const i = dg[a];
+                            ("transparent" !== n || "fill" !== i && "stroke" !== i) && null != n && (pd(n) && (n = md(n, r.gradient, "")), t[i] = n)
                         }
-                        for (const a in eg) {
+                        for (const a in hg) {
                             const t = e[a];
-                            null != t && (o = o || [], o.push("".concat(eg[a], ": ").concat(t, ";")))
+                            null != t && (o = o || [], o.push("".concat(hg[a], ": ").concat(t, ";")))
                         }
                         o && (t.style = o.join(" "))
                     }(r, e, t, i, this._defs), r
                 },
                 defs(t) {
                     const e = this._defs.gradient,
                         n = this._defs.clipping;
                     if (0 !== Object.keys(e).length + Object.keys(n).length) {
                         t.open("defs");
                         for (const n in e) {
                             const i = e[n],
                                 r = i.stops;
                             "radial" === i.gradient ? (t.open("pattern", {
-                                id: $f + n,
+                                id: hd + n,
                                 viewBox: "0,0,1,1",
                                 width: "100%",
                                 height: "100%",
                                 preserveAspectRatio: "xMidYMid slice"
                             }), t.open("rect", {
                                 width: "1",
                                 height: "1",
@@ -29923,293 +30073,269 @@
                                 height: i.height
                             }).close(), t.close()
                         }
                         t.close()
                     }
                 }
             });
-            const xg = "canvas",
-                _g = "none",
-                wg = {
-                    Canvas: xg,
+            const Tg = "canvas",
+                Ng = "none",
+                Rg = {
+                    Canvas: Tg,
                     PNG: "png",
                     SVG: "svg",
-                    None: _g
+                    None: Ng
                 },
-                kg = {};
+                zg = {};
 
-            function Eg(t, e) {
-                return t = String(t || "").toLowerCase(), arguments.length > 1 ? (kg[t] = e, this) : kg[t]
+            function Pg(t, e) {
+                return t = String(t || "").toLowerCase(), arguments.length > 1 ? (zg[t] = e, this) : zg[t]
             }
 
-            function Dg(t, e, n) {
+            function Lg(t, e, n) {
                 const i = [],
-                    r = (new $d).union(e),
+                    r = (new uh).union(e),
                     o = t.marktype;
-                return o ? Ag(t, r, n, i) : "group" === o ? Sg(t, r, n, i) : (0, m.vU)("Intersect scene must be mark node or group item.")
+                return o ? Bg(t, r, n, i) : "group" === o ? Ig(t, r, n, i) : (0, m.vU)("Intersect scene must be mark node or group item.")
             }
 
-            function Ag(t, e, n, i) {
+            function Bg(t, e, n, i) {
                 if (function(t, e, n) {
                         return t.bounds && e.intersects(t.bounds) && ("group" === t.marktype || !1 !== t.interactive && (!n || n(t)))
                     }(t, e, n)) {
                     const r = t.items,
                         o = t.marktype,
                         a = r.length;
                     let s = 0;
                     if ("group" === o)
-                        for (; s < a; ++s) Sg(r[s], e, n, i);
+                        for (; s < a; ++s) Ig(r[s], e, n, i);
                     else
-                        for (const t = Xp[o].isect; s < a; ++s) {
+                        for (const t = am[o].isect; s < a; ++s) {
                             const n = r[s];
-                            Cg(n, e, t) && i.push(n)
+                            jg(n, e, t) && i.push(n)
                         }
                 }
                 return i
             }
 
-            function Sg(t, e, n, i) {
-                n && n(t.mark) && Cg(t, e, Xp.group.isect) && i.push(t);
+            function Ig(t, e, n, i) {
+                n && n(t.mark) && jg(t, e, am.group.isect) && i.push(t);
                 const r = t.items,
                     o = r && r.length;
                 if (o) {
                     const a = t.x || 0,
                         s = t.y || 0;
                     e.translate(-a, -s);
-                    for (let t = 0; t < o; ++t) Ag(r[t], e, n, i);
+                    for (let t = 0; t < o; ++t) Bg(r[t], e, n, i);
                     e.translate(a, s)
                 }
                 return i
             }
 
-            function Cg(t, e, n) {
+            function jg(t, e, n) {
                 const i = t.bounds;
                 return e.encloses(i) || e.intersects(i) && n(t, e)
             }
-            kg[xg] = kg.png = {
-                renderer: Om,
-                headless: Om,
-                handler: Am
-            }, kg.svg = {
-                renderer: og,
-                headless: bg,
-                handler: Nm
-            }, kg[_g] = {};
-            const Fg = new $d;
-
-            function Mg(t) {
-                const e = t.clip;
-                if ((0, m.mf)(e)) e(yh(Fg.clear()));
-                else {
-                    if (!e) return;
-                    Fg.set(0, 0, t.group.width, t.group.height)
-                }
-                t.bounds.intersect(Fg)
-            }
-            const Og = 1e-9;
-
-            function Tg(t, e, n) {
-                return t === e || ("path" === n ? Ng(t, e) : t instanceof Date && e instanceof Date ? +t === +e : (0, m.hj)(t) && (0, m.hj)(e) ? Math.abs(t - e) <= Og : t && e && ((0, m.Kn)(t) || (0, m.Kn)(e)) ? function(t, e) {
-                    var n, i, r = Object.keys(t),
-                        o = Object.keys(e);
-                    if (r.length !== o.length) return !1;
-                    for (r.sort(), o.sort(), i = r.length - 1; i >= 0; i--)
-                        if (r[i] != o[i]) return !1;
-                    for (i = r.length - 1; i >= 0; i--)
-                        if (!Tg(t[n = r[i]], e[n], n)) return !1;
-                    return typeof t === typeof e
-                }(t, e) : t == e)
-            }
-
-            function Ng(t, e) {
-                return Tg(ad(t), ad(e))
-            }
+            zg[Tg] = zg.png = {
+                renderer: Hm,
+                headless: Hm,
+                handler: Im
+            }, zg.svg = {
+                renderer: vg,
+                headless: Og,
+                handler: Gm
+            }, zg[Ng] = {};
+            const Ug = new uh;
+            const qg = "top",
+                Wg = "left",
+                Hg = "right",
+                Xg = "bottom",
+                Gg = "top-left",
+                Jg = "top-right",
+                Zg = "bottom-left",
+                $g = "bottom-right",
+                Yg = "start",
+                Vg = "middle",
+                Kg = "end",
+                Qg = "x",
+                tv = "y",
+                ev = "group",
+                nv = "axis",
+                iv = "title",
+                rv = "frame",
+                ov = "scope",
+                av = "legend",
+                sv = "row-header",
+                cv = "row-footer",
+                lv = "row-title",
+                uv = "column-header",
+                fv = "column-footer",
+                dv = "column-title",
+                hv = "padding",
+                pv = "symbol",
+                mv = "fit",
+                gv = "fit-x",
+                vv = "fit-y",
+                yv = "pad",
+                bv = "none",
+                xv = "all",
+                _v = "each",
+                wv = "flush",
+                kv = "column",
+                Ev = "row";
 
-            function zg() {
-                Jd(), Gf = 0
+            function Av(t) {
+                zr.call(this, null, t)
             }
-            const Rg = "top",
-                Pg = "left",
-                Lg = "right",
-                jg = "bottom",
-                Bg = "top-left",
-                Ig = "top-right",
-                Ug = "bottom-left",
-                qg = "bottom-right",
-                Wg = "start",
-                Hg = "middle",
-                Xg = "end",
-                Jg = "x",
-                Gg = "y",
-                $g = "group",
-                Zg = "axis",
-                Yg = "title",
-                Vg = "frame",
-                Kg = "scope",
-                Qg = "legend",
-                tv = "row-header",
-                ev = "row-footer",
-                nv = "row-title",
-                iv = "column-header",
-                rv = "column-footer",
-                ov = "column-title",
-                av = "padding",
-                sv = "symbol",
-                cv = "fit",
-                lv = "fit-x",
-                uv = "fit-y",
-                fv = "pad",
-                dv = "none",
-                hv = "all",
-                pv = "each",
-                mv = "flush",
-                gv = "column",
-                vv = "row";
 
-            function yv(t) {
-                Rr.call(this, null, t)
-            }
-
-            function bv(t, e, n) {
+            function Dv(t, e, n) {
                 return e(t.bounds.clear(), t, n)
-            }(0, m.XW)(yv, Rr, {
+            }(0, m.XW)(Av, zr, {
                 transform(t, e) {
                     const n = e.dataflow,
                         i = t.mark,
                         r = i.marktype,
-                        o = Xp[r],
+                        o = am[r],
                         a = o.bound;
                     let s, c = i.bounds;
-                    if (o.nested) i.items.length && n.dirty(i.items[0]), c = bv(i, a), i.items.forEach((t => {
+                    if (o.nested) i.items.length && n.dirty(i.items[0]), c = Dv(i, a), i.items.forEach((t => {
                         t.bounds.clear().union(c)
                     }));
-                    else if (r === $g || t.modified()) switch (e.visit(e.MOD, (t => n.dirty(t))), c.clear(), i.items.forEach((t => c.union(bv(t, a)))), i.role) {
-                        case Zg:
-                        case Qg:
-                        case Yg:
+                    else if (r === ev || t.modified()) switch (e.visit(e.MOD, (t => n.dirty(t))), c.clear(), i.items.forEach((t => c.union(Dv(t, a)))), i.role) {
+                        case nv:
+                        case av:
+                        case iv:
                             e.reflow()
                     } else s = e.changed(e.REM), e.visit(e.ADD, (t => {
-                        c.union(bv(t, a))
+                        c.union(Dv(t, a))
                     })), e.visit(e.MOD, (t => {
-                        s = s || c.alignsWith(t.bounds), n.dirty(t), c.union(bv(t, a))
+                        s = s || c.alignsWith(t.bounds), n.dirty(t), c.union(Dv(t, a))
                     })), s && (c.clear(), i.items.forEach((t => c.union(t.bounds))));
-                    return Mg(i), e.modifies("bounds")
+                    return function(t) {
+                        const e = t.clip;
+                        if ((0, m.mf)(e)) e(Rh(Ug.clear()));
+                        else {
+                            if (!e) return;
+                            Ug.set(0, 0, t.group.width, t.group.height)
+                        }
+                        t.bounds.intersect(Ug)
+                    }(i), e.modifies("bounds")
                 }
             });
-            const xv = ":vega_identifier:";
+            const Sv = ":vega_identifier:";
 
-            function _v(t) {
-                Rr.call(this, 0, t)
+            function Cv(t) {
+                zr.call(this, 0, t)
             }
 
-            function wv(t) {
-                Rr.call(this, null, t)
+            function Mv(t) {
+                zr.call(this, null, t)
             }
 
-            function kv(t) {
-                Rr.call(this, null, t)
+            function Fv(t) {
+                zr.call(this, null, t)
             }
-            _v.Definition = {
+            Cv.Definition = {
                 type: "Identifier",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "as",
                     type: "string",
                     required: !0
                 }]
-            }, (0, m.XW)(_v, Rr, {
+            }, (0, m.XW)(Cv, zr, {
                 transform(t, e) {
-                    const n = (r = e.dataflow)._signals[xv] || (r._signals[xv] = r.add(0)),
+                    const n = (r = e.dataflow)._signals[Sv] || (r._signals[Sv] = r.add(0)),
                         i = t.as;
                     var r;
                     let o = n.value;
                     return e.visit(e.ADD, (t => t[i] = t[i] || ++o)), n.set(this.value = o), e
                 }
-            }), (0, m.XW)(wv, Rr, {
+            }), (0, m.XW)(Mv, zr, {
                 transform(t, e) {
                     let n = this.value;
                     n || (n = e.dataflow.scenegraph().mark(t.markdef, function(t) {
                         const e = t.groups,
                             n = t.parent;
                         return e && 1 === e.size ? e.get(Object.keys(e.object)[0]) : e && n ? e.lookup(n) : null
                     }(t), t.index), n.group.context = t.context, t.context.group || (t.context.group = n.group), n.source = this.source, n.clip = t.clip, n.interactive = t.interactive, this.value = n);
-                    const i = n.marktype === $g ? Yd : Zd;
+                    const i = n.marktype === ev ? dh : fh;
                     return e.visit(e.ADD, (t => i.call(t, n))), (t.modified("clip") || t.modified("interactive")) && (n.clip = t.clip, n.interactive = !!t.interactive, n.zdirty = !0, e.reflow()), n.items = e.source, e
                 }
             });
-            const Ev = {
+            const Ov = {
                     parity: t => t.filter(((t, e) => e % 2 ? t.opacity = 0 : 1)),
                     greedy: (t, e) => {
                         let n;
-                        return t.filter(((t, i) => i && Dv(n.bounds, t.bounds, e) ? t.opacity = 0 : (n = t, 1)))
+                        return t.filter(((t, i) => i && Tv(n.bounds, t.bounds, e) ? t.opacity = 0 : (n = t, 1)))
                     }
                 },
-                Dv = (t, e, n) => n > Math.max(e.x1 - t.x2, t.x1 - e.x2, e.y1 - t.y2, t.y1 - e.y2),
-                Av = (t, e) => {
+                Tv = (t, e, n) => n > Math.max(e.x1 - t.x2, t.x1 - e.x2, e.y1 - t.y2, t.y1 - e.y2),
+                Nv = (t, e) => {
                     for (var n, i = 1, r = t.length, o = t[0].bounds; i < r; o = n, ++i)
-                        if (Dv(o, n = t[i].bounds, e)) return !0
+                        if (Tv(o, n = t[i].bounds, e)) return !0
                 },
-                Sv = t => {
+                Rv = t => {
                     const e = t.bounds;
                     return e.width() > 1 && e.height() > 1
                 },
-                Cv = t => (t.forEach((t => t.opacity = 1)), t),
-                Fv = (t, e) => t.reflow(e.modified()).modifies("opacity");
+                zv = t => (t.forEach((t => t.opacity = 1)), t),
+                Pv = (t, e) => t.reflow(e.modified()).modifies("opacity");
 
-            function Mv(t) {
-                Rr.call(this, null, t)
-            }(0, m.XW)(kv, Rr, {
+            function Lv(t) {
+                zr.call(this, null, t)
+            }(0, m.XW)(Fv, zr, {
                 transform(t, e) {
-                    const n = Ev[t.method] || Ev.parity,
+                    const n = Ov[t.method] || Ov.parity,
                         i = t.separation || 0;
                     let r, o, a = e.materialize(e.SOURCE).source;
                     if (!a || !a.length) return;
-                    if (!t.method) return t.modified("method") && (Cv(a), e = Fv(e, t)), e;
-                    if (a = a.filter(Sv), !a.length) return;
-                    if (t.sort && (a = a.slice().sort(t.sort)), r = Cv(a), e = Fv(e, t), r.length >= 3 && Av(r, i)) {
+                    if (!t.method) return t.modified("method") && (zv(a), e = Pv(e, t)), e;
+                    if (a = a.filter(Rv), !a.length) return;
+                    if (t.sort && (a = a.slice().sort(t.sort)), r = zv(a), e = Pv(e, t), r.length >= 3 && Nv(r, i)) {
                         do {
                             r = n(r, i)
-                        } while (r.length >= 3 && Av(r, i));
+                        } while (r.length >= 3 && Nv(r, i));
                         r.length < 3 && !(0, m.fj)(a).opacity && (r.length > 1 && ((0, m.fj)(r).opacity = 0), (0, m.fj)(a).opacity = 1)
                     }
                     t.boundScale && t.boundTolerance >= 0 && (o = ((t, e, n) => {
                         var i = t.range(),
-                            r = new $d;
-                        return e === Rg || e === jg ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), t => r.encloses(t.bounds)
+                            r = new uh;
+                        return e === qg || e === Xg ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), t => r.encloses(t.bounds)
                     })(t.boundScale, t.boundOrient, +t.boundTolerance), a.forEach((t => {
                         o(t) || (t.opacity = 0)
                     })));
                     const s = r[0].mark.bounds.clear();
                     return a.forEach((t => {
                         t.opacity && s.union(t.bounds)
                     })), e
                 }
-            }), (0, m.XW)(Mv, Rr, {
+            }), (0, m.XW)(Lv, zr, {
                 transform(t, e) {
                     const n = e.dataflow;
                     if (e.visit(e.ALL, (t => n.dirty(t))), e.fields && e.fields.zindex) {
                         const t = e.source && e.source[0];
                         t && (t.mark.zdirty = !0)
                     }
                 }
             });
-            const Ov = new $d;
+            const Bv = new uh;
 
-            function Tv(t, e, n) {
+            function Iv(t, e, n) {
                 return t[e] === n ? 0 : (t[e] = n, 1)
             }
 
-            function Nv(t) {
+            function jv(t) {
                 var e = t.items[0].orient;
-                return e === Pg || e === Lg
+                return e === Wg || e === Hg
             }
 
-            function zv(t, e, n, i) {
+            function Uv(t, e, n, i) {
                 var r, o, a = e.items[0],
                     s = a.datum,
                     c = null != a.translate ? a.translate : .5,
                     l = a.orient,
                     u = function(t) {
                         let e = +t.grid;
                         return [t.ticks ? e++ : -1, t.labels ? e++ : -1, e + +t.domain]
@@ -30218,307 +30344,307 @@
                     d = a.offset,
                     h = a.position,
                     p = a.minExtent,
                     m = a.maxExtent,
                     g = s.title && a.items[u[2]].items[0],
                     v = a.titlePadding,
                     y = a.bounds,
-                    b = g && zp(g),
+                    b = g && $p(g),
                     x = 0,
                     _ = 0;
-                switch (Ov.clear().union(y), y.clear(), (r = u[0]) > -1 && y.union(a.items[r].bounds), (r = u[1]) > -1 && y.union(a.items[r].bounds), l) {
-                    case Rg:
-                        x = h || 0, _ = -d, o = Math.max(p, Math.min(m, -y.y1)), y.add(0, -o).add(f, 0), g && Rv(t, g, o, v, b, 0, -1, y);
+                switch (Bv.clear().union(y), y.clear(), (r = u[0]) > -1 && y.union(a.items[r].bounds), (r = u[1]) > -1 && y.union(a.items[r].bounds), l) {
+                    case qg:
+                        x = h || 0, _ = -d, o = Math.max(p, Math.min(m, -y.y1)), y.add(0, -o).add(f, 0), g && qv(t, g, o, v, b, 0, -1, y);
                         break;
-                    case Pg:
-                        x = -d, _ = h || 0, o = Math.max(p, Math.min(m, -y.x1)), y.add(-o, 0).add(0, f), g && Rv(t, g, o, v, b, 1, -1, y);
+                    case Wg:
+                        x = -d, _ = h || 0, o = Math.max(p, Math.min(m, -y.x1)), y.add(-o, 0).add(0, f), g && qv(t, g, o, v, b, 1, -1, y);
                         break;
-                    case Lg:
-                        x = n + d, _ = h || 0, o = Math.max(p, Math.min(m, y.x2)), y.add(0, 0).add(o, f), g && Rv(t, g, o, v, b, 1, 1, y);
+                    case Hg:
+                        x = n + d, _ = h || 0, o = Math.max(p, Math.min(m, y.x2)), y.add(0, 0).add(o, f), g && qv(t, g, o, v, b, 1, 1, y);
                         break;
-                    case jg:
-                        x = h || 0, _ = i + d, o = Math.max(p, Math.min(m, y.y2)), y.add(0, 0).add(f, o), g && Rv(t, g, o, v, 0, 0, 1, y);
+                    case Xg:
+                        x = h || 0, _ = i + d, o = Math.max(p, Math.min(m, y.y2)), y.add(0, 0).add(f, o), g && qv(t, g, o, v, 0, 0, 1, y);
                         break;
                     default:
                         x = a.x, _ = a.y
                 }
-                return th(y.translate(x, _), a), Tv(a, "x", x + c) | Tv(a, "y", _ + c) && (a.bounds = Ov, t.dirty(a), a.bounds = y, t.dirty(a)), a.mark.bounds.clear().union(y)
+                return gh(y.translate(x, _), a), Iv(a, "x", x + c) | Iv(a, "y", _ + c) && (a.bounds = Bv, t.dirty(a), a.bounds = y, t.dirty(a)), a.mark.bounds.clear().union(y)
             }
 
-            function Rv(t, e, n, i, r, o, a, s) {
+            function qv(t, e, n, i, r, o, a, s) {
                 const c = e.bounds;
                 if (e.auto) {
                     const s = a * (n + r + i);
                     let l = 0,
                         u = 0;
                     t.dirty(e), o ? l = (e.x || 0) - (e.x = s) : u = (e.y || 0) - (e.y = s), e.mark.bounds.clear().union(c.translate(-l, -u)), t.dirty(e)
                 }
                 s.union(c)
             }
-            const Pv = (t, e) => Math.floor(Math.min(t, e)),
-                Lv = (t, e) => Math.ceil(Math.max(t, e));
+            const Wv = (t, e) => Math.floor(Math.min(t, e)),
+                Hv = (t, e) => Math.ceil(Math.max(t, e));
 
-            function jv(t) {
-                return (new $d).set(0, 0, t.width || 0, t.height || 0)
+            function Xv(t) {
+                return (new uh).set(0, 0, t.width || 0, t.height || 0)
             }
 
-            function Bv(t) {
+            function Gv(t) {
                 const e = t.bounds.clone();
                 return e.empty() ? e.set(0, 0, 0, 0) : e.translate(-(t.x || 0), -(t.y || 0))
             }
 
-            function Iv(t, e, n) {
+            function Jv(t, e, n) {
                 const i = (0, m.Kn)(t) ? t[e] : t;
                 return null != i ? i : void 0 !== n ? n : 0
             }
 
-            function Uv(t) {
+            function Zv(t) {
                 return t < 0 ? Math.ceil(-t) : 0
             }
 
-            function qv(t, e, n) {
+            function $v(t, e, n) {
                 var i, r, o, a, s, c, l, u, f, d, h, p = !n.nodirty,
-                    m = n.bounds === mv ? jv : Bv,
-                    g = Ov.set(0, 0, 0, 0),
-                    v = Iv(n.align, gv),
-                    y = Iv(n.align, vv),
-                    b = Iv(n.padding, gv),
-                    x = Iv(n.padding, vv),
+                    m = n.bounds === wv ? Xv : Gv,
+                    g = Bv.set(0, 0, 0, 0),
+                    v = Jv(n.align, kv),
+                    y = Jv(n.align, Ev),
+                    b = Jv(n.padding, kv),
+                    x = Jv(n.padding, Ev),
                     _ = n.columns || e.length,
                     w = _ <= 0 ? 1 : Math.ceil(e.length / _),
                     k = e.length,
                     E = Array(k),
-                    D = Array(_),
-                    A = 0,
+                    A = Array(_),
+                    D = 0,
                     S = Array(k),
                     C = Array(w),
-                    F = 0,
-                    M = Array(k),
+                    M = 0,
+                    F = Array(k),
                     O = Array(k),
                     T = Array(k);
-                for (r = 0; r < _; ++r) D[r] = 0;
+                for (r = 0; r < _; ++r) A[r] = 0;
                 for (r = 0; r < w; ++r) C[r] = 0;
-                for (r = 0; r < k; ++r) c = e[r], s = T[r] = m(c), c.x = c.x || 0, M[r] = 0, c.y = c.y || 0, O[r] = 0, o = r % _, a = ~~(r / _), A = Math.max(A, l = Math.ceil(s.x2)), F = Math.max(F, u = Math.ceil(s.y2)), D[o] = Math.max(D[o], l), C[a] = Math.max(C[a], u), E[r] = b + Uv(s.x1), S[r] = x + Uv(s.y1), p && t.dirty(e[r]);
+                for (r = 0; r < k; ++r) c = e[r], s = T[r] = m(c), c.x = c.x || 0, F[r] = 0, c.y = c.y || 0, O[r] = 0, o = r % _, a = ~~(r / _), D = Math.max(D, l = Math.ceil(s.x2)), M = Math.max(M, u = Math.ceil(s.y2)), A[o] = Math.max(A[o], l), C[a] = Math.max(C[a], u), E[r] = b + Zv(s.x1), S[r] = x + Zv(s.y1), p && t.dirty(e[r]);
                 for (r = 0; r < k; ++r) r % _ === 0 && (E[r] = 0), r < _ && (S[r] = 0);
-                if (v === pv)
+                if (v === _v)
                     for (o = 1; o < _; ++o) {
                         for (h = 0, r = o; r < k; r += _) h < E[r] && (h = E[r]);
-                        for (r = o; r < k; r += _) E[r] = h + D[o - 1]
-                    } else if (v === hv) {
+                        for (r = o; r < k; r += _) E[r] = h + A[o - 1]
+                    } else if (v === xv) {
                         for (h = 0, r = 0; r < k; ++r) r % _ && h < E[r] && (h = E[r]);
-                        for (r = 0; r < k; ++r) r % _ && (E[r] = h + A)
+                        for (r = 0; r < k; ++r) r % _ && (E[r] = h + D)
                     } else
                         for (v = !1, o = 1; o < _; ++o)
-                            for (r = o; r < k; r += _) E[r] += D[o - 1];
-                if (y === pv)
+                            for (r = o; r < k; r += _) E[r] += A[o - 1];
+                if (y === _v)
                     for (a = 1; a < w; ++a) {
                         for (h = 0, i = (r = a * _) + _; r < i; ++r) h < S[r] && (h = S[r]);
                         for (r = a * _; r < i; ++r) S[r] = h + C[a - 1]
-                    } else if (y === hv) {
+                    } else if (y === xv) {
                         for (h = 0, r = _; r < k; ++r) h < S[r] && (h = S[r]);
-                        for (r = _; r < k; ++r) S[r] = h + F
+                        for (r = _; r < k; ++r) S[r] = h + M
                     } else
                         for (y = !1, a = 1; a < w; ++a)
                             for (i = (r = a * _) + _; r < i; ++r) S[r] += C[a - 1];
-                for (f = 0, r = 0; r < k; ++r) f = E[r] + (r % _ ? f : 0), M[r] += f - e[r].x;
+                for (f = 0, r = 0; r < k; ++r) f = E[r] + (r % _ ? f : 0), F[r] += f - e[r].x;
                 for (o = 0; o < _; ++o)
                     for (d = 0, r = o; r < k; r += _) d += S[r], O[r] += d - e[r].y;
-                if (v && Iv(n.center, gv) && w > 1)
-                    for (r = 0; r < k; ++r)(f = (s = v === hv ? A : D[r % _]) - T[r].x2 - e[r].x - M[r]) > 0 && (M[r] += f / 2);
-                if (y && Iv(n.center, vv) && 1 !== _)
-                    for (r = 0; r < k; ++r)(d = (s = y === hv ? F : C[~~(r / _)]) - T[r].y2 - e[r].y - O[r]) > 0 && (O[r] += d / 2);
-                for (r = 0; r < k; ++r) g.union(T[r].translate(M[r], O[r]));
-                switch (f = Iv(n.anchor, Jg), d = Iv(n.anchor, Gg), Iv(n.anchor, gv)) {
-                    case Xg:
+                if (v && Jv(n.center, kv) && w > 1)
+                    for (r = 0; r < k; ++r)(f = (s = v === xv ? D : A[r % _]) - T[r].x2 - e[r].x - F[r]) > 0 && (F[r] += f / 2);
+                if (y && Jv(n.center, Ev) && 1 !== _)
+                    for (r = 0; r < k; ++r)(d = (s = y === xv ? M : C[~~(r / _)]) - T[r].y2 - e[r].y - O[r]) > 0 && (O[r] += d / 2);
+                for (r = 0; r < k; ++r) g.union(T[r].translate(F[r], O[r]));
+                switch (f = Jv(n.anchor, Qg), d = Jv(n.anchor, tv), Jv(n.anchor, kv)) {
+                    case Kg:
                         f -= g.width();
                         break;
-                    case Hg:
+                    case Vg:
                         f -= g.width() / 2
                 }
-                switch (Iv(n.anchor, vv)) {
-                    case Xg:
+                switch (Jv(n.anchor, Ev)) {
+                    case Kg:
                         d -= g.height();
                         break;
-                    case Hg:
+                    case Vg:
                         d -= g.height() / 2
                 }
                 for (f = Math.round(f), d = Math.round(d), g.clear(), r = 0; r < k; ++r) e[r].mark.bounds.clear();
-                for (r = 0; r < k; ++r)(c = e[r]).x += M[r] += f, c.y += O[r] += d, g.union(c.mark.bounds.union(c.bounds.translate(M[r], O[r]))), p && t.dirty(c);
+                for (r = 0; r < k; ++r)(c = e[r]).x += F[r] += f, c.y += O[r] += d, g.union(c.mark.bounds.union(c.bounds.translate(F[r], O[r]))), p && t.dirty(c);
                 return g
             }
 
-            function Wv(t, e, n) {
+            function Yv(t, e, n) {
                 var i, r, o, a, s, c, l, u = function(t) {
                         var e, n, i = t.items,
                             r = i.length,
                             o = 0;
                         const a = {
                             marks: [],
                             rowheaders: [],
                             rowfooters: [],
                             colheaders: [],
                             colfooters: [],
                             rowtitle: null,
                             coltitle: null
                         };
                         for (; o < r; ++o)
-                            if (n = (e = i[o]).items, e.marktype === $g) switch (e.role) {
-                                case Zg:
-                                case Qg:
-                                case Yg:
+                            if (n = (e = i[o]).items, e.marktype === ev) switch (e.role) {
+                                case nv:
+                                case av:
+                                case iv:
                                     break;
-                                case tv:
+                                case sv:
                                     a.rowheaders.push(...n);
                                     break;
-                                case ev:
+                                case cv:
                                     a.rowfooters.push(...n);
                                     break;
-                                case iv:
+                                case uv:
                                     a.colheaders.push(...n);
                                     break;
-                                case rv:
+                                case fv:
                                     a.colfooters.push(...n);
                                     break;
-                                case nv:
+                                case lv:
                                     a.rowtitle = n[0];
                                     break;
-                                case ov:
+                                case dv:
                                     a.coltitle = n[0];
                                     break;
                                 default:
                                     a.marks.push(...n)
                             }
                         return a
                     }(e),
                     f = u.marks,
-                    d = n.bounds === mv ? Hv : Xv,
+                    d = n.bounds === wv ? Vv : Kv,
                     h = n.offset,
                     p = n.columns || f.length,
                     m = p <= 0 ? 1 : Math.ceil(f.length / p),
                     g = m * p;
-                const v = qv(t, f, n);
-                v.empty() && v.set(0, 0, 0, 0), u.rowheaders && (c = Iv(n.headerBand, vv, null), i = Jv(t, u.rowheaders, f, p, m, -Iv(h, "rowHeader"), Pv, 0, d, "x1", 0, p, 1, c)), u.colheaders && (c = Iv(n.headerBand, gv, null), r = Jv(t, u.colheaders, f, p, p, -Iv(h, "columnHeader"), Pv, 1, d, "y1", 0, 1, p, c)), u.rowfooters && (c = Iv(n.footerBand, vv, null), o = Jv(t, u.rowfooters, f, p, m, Iv(h, "rowFooter"), Lv, 0, d, "x2", p - 1, p, 1, c)), u.colfooters && (c = Iv(n.footerBand, gv, null), a = Jv(t, u.colfooters, f, p, p, Iv(h, "columnFooter"), Lv, 1, d, "y2", g - p, 1, p, c)), u.rowtitle && (s = Iv(n.titleAnchor, vv), l = Iv(h, "rowTitle"), l = s === Xg ? o + l : i - l, c = Iv(n.titleBand, vv, .5), Gv(t, u.rowtitle, l, 0, v, c)), u.coltitle && (s = Iv(n.titleAnchor, gv), l = Iv(h, "columnTitle"), l = s === Xg ? a + l : r - l, c = Iv(n.titleBand, gv, .5), Gv(t, u.coltitle, l, 1, v, c))
+                const v = $v(t, f, n);
+                v.empty() && v.set(0, 0, 0, 0), u.rowheaders && (c = Jv(n.headerBand, Ev, null), i = Qv(t, u.rowheaders, f, p, m, -Jv(h, "rowHeader"), Wv, 0, d, "x1", 0, p, 1, c)), u.colheaders && (c = Jv(n.headerBand, kv, null), r = Qv(t, u.colheaders, f, p, p, -Jv(h, "columnHeader"), Wv, 1, d, "y1", 0, 1, p, c)), u.rowfooters && (c = Jv(n.footerBand, Ev, null), o = Qv(t, u.rowfooters, f, p, m, Jv(h, "rowFooter"), Hv, 0, d, "x2", p - 1, p, 1, c)), u.colfooters && (c = Jv(n.footerBand, kv, null), a = Qv(t, u.colfooters, f, p, p, Jv(h, "columnFooter"), Hv, 1, d, "y2", g - p, 1, p, c)), u.rowtitle && (s = Jv(n.titleAnchor, Ev), l = Jv(h, "rowTitle"), l = s === Kg ? o + l : i - l, c = Jv(n.titleBand, Ev, .5), ty(t, u.rowtitle, l, 0, v, c)), u.coltitle && (s = Jv(n.titleAnchor, kv), l = Jv(h, "columnTitle"), l = s === Kg ? a + l : r - l, c = Jv(n.titleBand, kv, .5), ty(t, u.coltitle, l, 1, v, c))
             }
 
-            function Hv(t, e) {
+            function Vv(t, e) {
                 return "x1" === e ? t.x || 0 : "y1" === e ? t.y || 0 : "x2" === e ? (t.x || 0) + (t.width || 0) : "y2" === e ? (t.y || 0) + (t.height || 0) : void 0
             }
 
-            function Xv(t, e) {
+            function Kv(t, e) {
                 return t.bounds[e]
             }
 
-            function Jv(t, e, n, i, r, o, a, s, c, l, u, f, d, h) {
+            function Qv(t, e, n, i, r, o, a, s, c, l, u, f, d, h) {
                 var p, m, g, v, y, b, x, _, w, k = n.length,
                     E = 0,
-                    D = 0;
+                    A = 0;
                 if (!k) return E;
                 for (p = u; p < k; p += f) n[p] && (E = a(E, c(n[p], l)));
                 if (!e.length) return E;
                 for (e.length > r && (t.warn("Grid headers exceed limit: " + r), e = e.slice(0, r)), E += o, m = 0, v = e.length; m < v; ++m) t.dirty(e[m]), e[m].mark.bounds.clear();
                 for (p = u, m = 0, v = e.length; m < v; ++m, p += f) {
                     for (y = (b = e[m]).mark.bounds, g = p; g >= 0 && null == (x = n[g]); g -= d);
-                    s ? (_ = null == h ? x.x : Math.round(x.bounds.x1 + h * x.bounds.width()), w = E) : (_ = E, w = null == h ? x.y : Math.round(x.bounds.y1 + h * x.bounds.height())), y.union(b.bounds.translate(_ - (b.x || 0), w - (b.y || 0))), b.x = _, b.y = w, t.dirty(b), D = a(D, y[l])
+                    s ? (_ = null == h ? x.x : Math.round(x.bounds.x1 + h * x.bounds.width()), w = E) : (_ = E, w = null == h ? x.y : Math.round(x.bounds.y1 + h * x.bounds.height())), y.union(b.bounds.translate(_ - (b.x || 0), w - (b.y || 0))), b.x = _, b.y = w, t.dirty(b), A = a(A, y[l])
                 }
-                return D
+                return A
             }
 
-            function Gv(t, e, n, i, r, o) {
+            function ty(t, e, n, i, r, o) {
                 if (e) {
                     t.dirty(e);
                     var a = n,
                         s = n;
                     i ? a = Math.round(r.x1 + o * r.width()) : s = Math.round(r.y1 + o * r.height()), e.bounds.translate(a - (e.x || 0), s - (e.y || 0)), e.mark.bounds.clear().union(e.bounds), e.x = a, e.y = s, t.dirty(e)
                 }
             }
 
-            function $v(t, e, n, i, r, o, a) {
+            function ey(t, e, n, i, r, o, a) {
                 const s = function(t, e) {
                         const n = t[e] || {};
                         return (e, i) => null != n[e] ? n[e] : null != t[e] ? t[e] : i
                     }(n, e),
                     c = function(t, e) {
                         let n = -1 / 0;
                         return t.forEach((t => {
                             null != t.offset && (n = Math.max(n, t.offset))
                         })), n > -1 / 0 ? n : e
                     }(t, s("offset", 0)),
-                    l = s("anchor", Wg),
-                    u = l === Xg ? 1 : l === Hg ? .5 : 0,
+                    l = s("anchor", Yg),
+                    u = l === Kg ? 1 : l === Vg ? .5 : 0,
                     f = {
-                        align: pv,
-                        bounds: s("bounds", mv),
+                        align: _v,
+                        bounds: s("bounds", wv),
                         columns: "vertical" === s("direction") ? 1 : t.length,
                         padding: s("margin", 8),
                         center: s("center"),
                         nodirty: !0
                     };
                 switch (e) {
-                    case Pg:
+                    case Wg:
                         f.anchor = {
                             x: Math.floor(i.x1) - c,
-                            column: Xg,
+                            column: Kg,
                             y: u * (a || i.height() + 2 * i.y1),
                             row: l
                         };
                         break;
-                    case Lg:
+                    case Hg:
                         f.anchor = {
                             x: Math.ceil(i.x2) + c,
                             y: u * (a || i.height() + 2 * i.y1),
                             row: l
                         };
                         break;
-                    case Rg:
+                    case qg:
                         f.anchor = {
                             y: Math.floor(r.y1) - c,
-                            row: Xg,
+                            row: Kg,
                             x: u * (o || r.width() + 2 * r.x1),
                             column: l
                         };
                         break;
-                    case jg:
+                    case Xg:
                         f.anchor = {
                             y: Math.ceil(r.y2) + c,
                             x: u * (o || r.width() + 2 * r.x1),
                             column: l
                         };
                         break;
-                    case Bg:
+                    case Gg:
                         f.anchor = {
                             x: c,
                             y: c
                         };
                         break;
-                    case Ig:
+                    case Jg:
                         f.anchor = {
                             x: o - c,
                             y: c,
-                            column: Xg
+                            column: Kg
                         };
                         break;
-                    case Ug:
+                    case Zg:
                         f.anchor = {
                             x: c,
                             y: a - c,
-                            row: Xg
+                            row: Kg
                         };
                         break;
-                    case qg:
+                    case $g:
                         f.anchor = {
                             x: o - c,
                             y: a - c,
-                            column: Xg,
-                            row: Xg
+                            column: Kg,
+                            row: Kg
                         }
                 }
                 return f
             }
 
-            function Zv(t, e) {
+            function ny(t, e) {
                 var n, i, r = e.items[0],
                     o = r.datum,
                     a = r.orient,
                     s = r.bounds,
                     c = r.x,
                     l = r.y;
                 return r._bounds ? r._bounds.clear().union(s) : r._bounds = s.clone(), s.clear(),
@@ -30529,253 +30655,253 @@
                         if (e.datum.title) {
                             var a = e.items[1].items[0],
                                 s = a.anchor,
                                 c = e.titlePadding || 0,
                                 l = i - a.x,
                                 u = i - a.y;
                             switch (a.orient) {
-                                case Pg:
+                                case Wg:
                                     r += Math.ceil(a.bounds.width()) + c;
                                     break;
-                                case Lg:
-                                case jg:
+                                case Hg:
+                                case Xg:
                                     break;
                                 default:
                                     o += a.bounds.height() + c
                             }
-                            switch ((r || o) && Vv(t, n, r, o), a.orient) {
-                                case Pg:
-                                    u += Yv(e, n, a, s, 1, 1);
+                            switch ((r || o) && ry(t, n, r, o), a.orient) {
+                                case Wg:
+                                    u += iy(e, n, a, s, 1, 1);
                                     break;
-                                case Lg:
-                                    l += Yv(e, n, a, Xg, 0, 0) + c, u += Yv(e, n, a, s, 1, 1);
+                                case Hg:
+                                    l += iy(e, n, a, Kg, 0, 0) + c, u += iy(e, n, a, s, 1, 1);
                                     break;
-                                case jg:
-                                    l += Yv(e, n, a, s, 0, 0), u += Yv(e, n, a, Xg, -1, 0, 1) + c;
+                                case Xg:
+                                    l += iy(e, n, a, s, 0, 0), u += iy(e, n, a, Kg, -1, 0, 1) + c;
                                     break;
                                 default:
-                                    l += Yv(e, n, a, s, 0, 0)
-                            }(l || u) && Vv(t, a, l, u), (l = Math.round(a.bounds.x1 - i)) < 0 && (Vv(t, n, -l, 0), Vv(t, a, -l, 0))
-                        } else(r || o) && Vv(t, n, r, o)
+                                    l += iy(e, n, a, s, 0, 0)
+                            }(l || u) && ry(t, a, l, u), (l = Math.round(a.bounds.x1 - i)) < 0 && (ry(t, n, -l, 0), ry(t, a, -l, 0))
+                        } else(r || o) && ry(t, n, r, o)
                     }(t, r, r.items[0].items[0]), s = function(t, e) {
                         return t.items.forEach((t => e.union(t.bounds))), e.x1 = t.padding, e.y1 = t.padding, e
-                    }(r, s), n = 2 * r.padding, i = 2 * r.padding, s.empty() || (n = Math.ceil(s.width() + n), i = Math.ceil(s.height() + i)), o.type === sv && function(t) {
+                    }(r, s), n = 2 * r.padding, i = 2 * r.padding, s.empty() || (n = Math.ceil(s.width() + n), i = Math.ceil(s.height() + i)), o.type === pv && function(t) {
                         const e = t.reduce(((t, e) => (t[e.column] = Math.max(e.bounds.x2 - e.x, t[e.column] || 0), t)), {});
                         t.forEach((t => {
                             t.width = e[t.column], t.height = t.bounds.y2 - t.y
                         }))
-                    }(r.items[0].items[0].items[0].items), a !== dv && (r.x = c = 0, r.y = l = 0), r.width = n, r.height = i, th(s.set(c, l, c + n, l + i), r), r.mark.bounds.clear().union(s), r
+                    }(r.items[0].items[0].items[0].items), a !== bv && (r.x = c = 0, r.y = l = 0), r.width = n, r.height = i, gh(s.set(c, l, c + n, l + i), r), r.mark.bounds.clear().union(s), r
             }
 
-            function Yv(t, e, n, i, r, o, a) {
+            function iy(t, e, n, i, r, o, a) {
                 const s = "symbol" !== t.datum.type,
                     c = n.datum.vgrad,
                     l = (!s || !o && c || a ? e : e.items[0]).bounds[r ? "y2" : "x2"] - t.padding,
                     u = c && o ? l : 0,
                     f = c && o ? 0 : l,
-                    d = r <= 0 ? 0 : zp(n);
-                return Math.round(i === Wg ? u : i === Xg ? f - d : .5 * (l - d))
+                    d = r <= 0 ? 0 : $p(n);
+                return Math.round(i === Yg ? u : i === Kg ? f - d : .5 * (l - d))
             }
 
-            function Vv(t, e, n, i) {
+            function ry(t, e, n, i) {
                 e.x += n, e.y += i, e.bounds.translate(n, i), e.mark.bounds.translate(n, i), t.dirty(e)
             }
 
-            function Kv(t) {
-                Rr.call(this, null, t)
+            function oy(t) {
+                zr.call(this, null, t)
             }
 
-            function Qv(t, e) {
+            function ay(t, e) {
                 let n = 0;
                 if (void 0 === e)
                     for (let i of t)(i = +i) && (n += i);
                 else {
                     let i = -1;
                     for (let r of t)(r = +e(r, ++i, t)) && (n += r)
                 }
                 return n
             }
 
-            function ty(t) {
-                Rr.call(this, null, t)
+            function sy(t) {
+                zr.call(this, null, t)
             }
 
-            function ey(t) {
-                Rr.call(this, null, t)
+            function cy(t) {
+                zr.call(this, null, t)
             }
 
-            function ny() {
+            function ly() {
                 return rr({})
             }
 
-            function iy(t) {
-                Rr.call(this, null, t)
+            function uy(t) {
+                zr.call(this, null, t)
             }
 
-            function ry(t) {
-                Rr.call(this, [], t)
-            }(0, m.XW)(Kv, Rr, {
+            function fy(t) {
+                zr.call(this, [], t)
+            }(0, m.XW)(oy, zr, {
                 transform(t, e) {
                     const n = e.dataflow;
                     return t.mark.items.forEach((e => {
-                            t.layout && Wv(n, e, t.layout),
+                            t.layout && Yv(n, e, t.layout),
                                 function(t, e, n) {
                                     var i, r, o, a, s, c = e.items,
                                         l = Math.max(0, e.width || 0),
                                         u = Math.max(0, e.height || 0),
-                                        f = (new $d).set(0, 0, l, u),
+                                        f = (new uh).set(0, 0, l, u),
                                         d = f.clone(),
                                         h = f.clone(),
                                         p = [];
                                     for (a = 0, s = c.length; a < s; ++a) switch ((r = c[a]).role) {
-                                        case Zg:
-                                            (Nv(r) ? d : h).union(zv(t, r, l, u));
+                                        case nv:
+                                            (jv(r) ? d : h).union(Uv(t, r, l, u));
                                             break;
-                                        case Yg:
+                                        case iv:
                                             i = r;
                                             break;
-                                        case Qg:
-                                            p.push(Zv(t, r));
+                                        case av:
+                                            p.push(ny(t, r));
                                             break;
-                                        case Vg:
-                                        case Kg:
-                                        case tv:
-                                        case ev:
-                                        case nv:
-                                        case iv:
                                         case rv:
                                         case ov:
+                                        case sv:
+                                        case cv:
+                                        case lv:
+                                        case uv:
+                                        case fv:
+                                        case dv:
                                             d.union(r.bounds), h.union(r.bounds);
                                             break;
                                         default:
                                             f.union(r.bounds)
                                     }
                                     if (p.length) {
                                         const e = {};
                                         p.forEach((t => {
-                                            (o = t.orient || Lg) !== dv && (e[o] || (e[o] = [])).push(t)
+                                            (o = t.orient || Hg) !== bv && (e[o] || (e[o] = [])).push(t)
                                         }));
                                         for (const i in e) {
                                             const r = e[i];
-                                            qv(t, r, $v(r, i, n.legends, d, h, l, u))
+                                            $v(t, r, ey(r, i, n.legends, d, h, l, u))
                                         }
                                         p.forEach((e => {
                                             const i = e.bounds;
-                                            if (i.equals(e._bounds) || (e.bounds = e._bounds, t.dirty(e), e.bounds = i, t.dirty(e)), !n.autosize || n.autosize.type !== cv && n.autosize.type !== lv && n.autosize.type !== uv) f.union(i);
+                                            if (i.equals(e._bounds) || (e.bounds = e._bounds, t.dirty(e), e.bounds = i, t.dirty(e)), !n.autosize || n.autosize.type !== mv && n.autosize.type !== gv && n.autosize.type !== vv) f.union(i);
                                             else switch (e.orient) {
-                                                case Pg:
-                                                case Lg:
+                                                case Wg:
+                                                case Hg:
                                                     f.add(i.x1, 0).add(i.x2, 0);
                                                     break;
-                                                case Rg:
-                                                case jg:
+                                                case qg:
+                                                case Xg:
                                                     f.add(0, i.y1).add(0, i.y2)
                                             }
                                         }))
                                     }
                                     f.union(d).union(h), i && f.union(function(t, e, n, i, r) {
                                         var o, a = e.items[0],
                                             s = a.frame,
                                             c = a.orient,
                                             l = a.anchor,
                                             u = a.offset,
                                             f = a.padding,
                                             d = a.items[0].items[0],
                                             h = a.items[1] && a.items[1].items[0],
-                                            p = c === Pg || c === Lg ? i : n,
+                                            p = c === Wg || c === Hg ? i : n,
                                             m = 0,
                                             g = 0,
                                             v = 0,
                                             y = 0,
                                             b = 0;
-                                        if (s !== $g ? c === Pg ? (m = r.y2, p = r.y1) : c === Lg ? (m = r.y1, p = r.y2) : (m = r.x1, p = r.x2) : c === Pg && (m = i, p = 0), o = l === Wg ? m : l === Xg ? p : (m + p) / 2, h && h.text) {
+                                        if (s !== ev ? c === Wg ? (m = r.y2, p = r.y1) : c === Hg ? (m = r.y1, p = r.y2) : (m = r.x1, p = r.x2) : c === Wg && (m = i, p = 0), o = l === Yg ? m : l === Kg ? p : (m + p) / 2, h && h.text) {
                                             switch (c) {
-                                                case Rg:
-                                                case jg:
+                                                case qg:
+                                                case Xg:
                                                     b = d.bounds.height() + f;
                                                     break;
-                                                case Pg:
+                                                case Wg:
                                                     y = d.bounds.width() + f;
                                                     break;
-                                                case Lg:
+                                                case Hg:
                                                     y = -d.bounds.width() - f
                                             }
-                                            Ov.clear().union(h.bounds), Ov.translate(y - (h.x || 0), b - (h.y || 0)), Tv(h, "x", y) | Tv(h, "y", b) && (t.dirty(h), h.bounds.clear().union(Ov), h.mark.bounds.clear().union(Ov), t.dirty(h)), Ov.clear().union(h.bounds)
-                                        } else Ov.clear();
-                                        switch (Ov.union(d.bounds), c) {
-                                            case Rg:
-                                                g = o, v = r.y1 - Ov.height() - u;
+                                            Bv.clear().union(h.bounds), Bv.translate(y - (h.x || 0), b - (h.y || 0)), Iv(h, "x", y) | Iv(h, "y", b) && (t.dirty(h), h.bounds.clear().union(Bv), h.mark.bounds.clear().union(Bv), t.dirty(h)), Bv.clear().union(h.bounds)
+                                        } else Bv.clear();
+                                        switch (Bv.union(d.bounds), c) {
+                                            case qg:
+                                                g = o, v = r.y1 - Bv.height() - u;
                                                 break;
-                                            case Pg:
-                                                g = r.x1 - Ov.width() - u, v = o;
+                                            case Wg:
+                                                g = r.x1 - Bv.width() - u, v = o;
                                                 break;
-                                            case Lg:
-                                                g = r.x2 + Ov.width() + u, v = o;
+                                            case Hg:
+                                                g = r.x2 + Bv.width() + u, v = o;
                                                 break;
-                                            case jg:
+                                            case Xg:
                                                 g = o, v = r.y2 + u;
                                                 break;
                                             default:
                                                 g = a.x, v = a.y
                                         }
-                                        return Tv(a, "x", g) | Tv(a, "y", v) && (Ov.translate(g, v), t.dirty(a), a.bounds.clear().union(Ov), e.bounds.clear().union(Ov), t.dirty(a)), a.bounds
+                                        return Iv(a, "x", g) | Iv(a, "y", v) && (Bv.translate(g, v), t.dirty(a), a.bounds.clear().union(Bv), e.bounds.clear().union(Bv), t.dirty(a)), a.bounds
                                     }(t, i, l, u, f));
                                     e.clip && f.set(0, 0, e.width || 0, e.height || 0);
                                     ! function(t, e, n, i) {
                                         const r = i.autosize || {},
                                             o = r.type;
                                         if (t._autosize < 1 || !o) return;
                                         let a = t._width,
                                             s = t._height,
                                             c = Math.max(0, e.width || 0),
                                             l = Math.max(0, Math.ceil(-n.x1)),
                                             u = Math.max(0, e.height || 0),
                                             f = Math.max(0, Math.ceil(-n.y1));
                                         const d = Math.max(0, Math.ceil(n.x2 - c)),
                                             h = Math.max(0, Math.ceil(n.y2 - u));
-                                        if (r.contains === av) {
+                                        if (r.contains === hv) {
                                             const e = t.padding();
                                             a -= e.left + e.right, s -= e.top + e.bottom
                                         }
-                                        o === dv ? (l = 0, f = 0, c = a, u = s) : o === cv ? (c = Math.max(0, a - l - d), u = Math.max(0, s - f - h)) : o === lv ? (c = Math.max(0, a - l - d), s = u + f + h) : o === uv ? (a = c + l + d, u = Math.max(0, s - f - h)) : o === fv && (a = c + l + d, s = u + f + h);
+                                        o === bv ? (l = 0, f = 0, c = a, u = s) : o === mv ? (c = Math.max(0, a - l - d), u = Math.max(0, s - f - h)) : o === gv ? (c = Math.max(0, a - l - d), s = u + f + h) : o === vv ? (a = c + l + d, u = Math.max(0, s - f - h)) : o === yv && (a = c + l + d, s = u + f + h);
                                         t._resizeView(a, s, c, u, [l, f], r.resize)
                                     }(t, e, f, n)
                                 }(n, e, t)
                         })),
                         function(t) {
                             return t && "legend-entry" !== t.mark.role
                         }(t.mark.group) ? e.reflow() : e
                 }
-            }), (0, m.XW)(ty, Rr, {
+            }), (0, m.XW)(sy, zr, {
                 transform(t, e) {
                     if (this.value && !t.modified()) return e.StopPropagation;
                     var n = e.dataflow.locale(),
                         i = e.fork(e.NO_SOURCE | e.NO_FIELDS),
                         r = this.value,
                         o = t.scale,
-                        a = Mf(o, null == t.count ? t.values ? t.values.length : 10 : t.count, t.minstep),
-                        s = t.format || Nf(n, o, a, t.formatSpecifier, t.formatType, !!t.values),
-                        c = t.values ? Of(o, t.values, a) : Tf(o, a);
+                        a = $f(o, null == t.count ? t.values ? t.values.length : 10 : t.count, t.minstep),
+                        s = t.format || Kf(n, o, a, t.formatSpecifier, t.formatType, !!t.values),
+                        c = t.values ? Yf(o, t.values, a) : Vf(o, a);
                     return r && (i.rem = r), r = c.map(((t, e) => rr({
                         index: e / (c.length - 1 || 1),
                         value: t,
                         label: s(t)
                     }))), t.extra && r.length && r.push(rr({
                         index: -1,
                         extra: {
                             value: r[0].value
                         },
                         label: ""
                     })), i.source = r, i.add = r, this.value = r, i
                 }
-            }), (0, m.XW)(ey, Rr, {
+            }), (0, m.XW)(cy, zr, {
                 transform(t, e) {
                     var n = e.dataflow,
                         i = e.fork(e.NO_SOURCE | e.NO_FIELDS),
-                        r = t.item || ny,
+                        r = t.item || ly,
                         o = t.key || nr,
                         a = this.value;
                     return (0, m.kJ)(i.encode) && (i.encode = null), a && (t.modified("key") || e.modified(o)) && (0, m.vU)("DataJoin does not support modified key function or fields."), a || (e = e.addAll(), this.value = a = function(t) {
                         const e = (0, m.Xr)().test((t => t.exit));
                         return e.lookup = n => e.get(t(n)), e
                     }(o)), e.visit(e.ADD, (t => {
                         const e = o(t);
@@ -30787,15 +30913,15 @@
                         n && (n.datum = t, i.mod.push(n))
                     })), e.visit(e.REM, (t => {
                         const e = o(t),
                             n = a.get(e);
                         t !== n.datum || n.exit || (i.rem.push(n), n.exit = !0, ++a.empty)
                     })), e.changed(e.ADD_MOD) && i.modifies("datum"), (e.clean() || t.clean && a.empty > n.cleanThreshold) && n.runAfter(a.clean), i
                 }
-            }), (0, m.XW)(iy, Rr, {
+            }), (0, m.XW)(uy, zr, {
                 transform(t, e) {
                     var n = e.fork(e.ADD_REM),
                         i = t.mod || !1,
                         r = t.encoders,
                         o = e.encode;
                     if ((0, m.kJ)(o)) {
                         if (!n.changed() && !o.every((t => r[t]))) return e.StopPropagation;
@@ -30819,73 +30945,73 @@
                             (u(e, t) || r) && n.mod.push(e)
                         })), n.mod.length && n.modifies(c.output)) : e.visit(r, (e => {
                             (u(e, t) || i) && n.mod.push(e)
                         })), n.mod.length && n.modifies(u.output)
                     }
                     return n.changed() ? n : e.StopPropagation
                 }
-            }), (0, m.XW)(ry, Rr, {
+            }), (0, m.XW)(fy, zr, {
                 transform(t, e) {
                     if (null != this.value && !t.modified()) return e.StopPropagation;
                     var n, i, r, o, a, s = e.dataflow.locale(),
                         c = e.fork(e.NO_SOURCE | e.NO_FIELDS),
                         l = this.value,
-                        u = t.type || Df,
+                        u = t.type || Hf,
                         f = t.scale,
                         d = +t.limit,
-                        h = Mf(f, null == t.count ? 5 : t.count, t.minstep),
-                        p = !!t.values || u === Df,
-                        g = t.format || Bf(s, f, h, u, t.formatSpecifier, t.formatType, p),
-                        v = t.values || Lf(f, h);
-                    return l && (c.rem = l), u === Df ? (d && v.length > d ? (e.dataflow.warn("Symbol legend count exceeds limit, filtering items."), l = v.slice(0, d - 1), a = !0) : l = v, (0, m.mf)(r = t.size) ? (t.values || 0 !== f(l[0]) || (l = l.slice(1)), o = l.reduce(((e, n) => Math.max(e, r(n, t))), 0)) : r = (0, m.a9)(o = r || 8), l = l.map(((e, n) => rr({
+                        h = $f(f, null == t.count ? 5 : t.count, t.minstep),
+                        p = !!t.values || u === Hf,
+                        g = t.format || rd(s, f, h, u, t.formatSpecifier, t.formatType, p),
+                        v = t.values || nd(f, h);
+                    return l && (c.rem = l), u === Hf ? (d && v.length > d ? (e.dataflow.warn("Symbol legend count exceeds limit, filtering items."), l = v.slice(0, d - 1), a = !0) : l = v, (0, m.mf)(r = t.size) ? (t.values || 0 !== f(l[0]) || (l = l.slice(1)), o = l.reduce(((e, n) => Math.max(e, r(n, t))), 0)) : r = (0, m.a9)(o = r || 8), l = l.map(((e, n) => rr({
                         index: n,
                         label: g(e, n, l),
                         value: e,
                         offset: o,
                         size: r(e, t)
                     }))), a && (a = v[l.length], l.push(rr({
                         index: l.length,
                         label: "\u2026".concat(v.length - l.length, " entries"),
                         value: a,
                         offset: o,
                         size: r(a, t)
-                    })))) : "gradient" === u ? (n = f.domain(), i = bf(f, n[0], (0, m.fj)(n)), v.length < 3 && !t.values && n[0] !== (0, m.fj)(n) && (v = [n[0], (0, m.fj)(n)]), l = v.map(((t, e) => rr({
+                    })))) : "gradient" === u ? (n = f.domain(), i = Bf(f, n[0], (0, m.fj)(n)), v.length < 3 && !t.values && n[0] !== (0, m.fj)(n) && (v = [n[0], (0, m.fj)(n)]), l = v.map(((t, e) => rr({
                         index: e,
                         label: g(t, e, v),
                         value: t,
                         perc: i(t)
                     })))) : (r = v.length - 1, i = function(t) {
                         const e = t.domain(),
                             n = e.length - 1;
                         let i = +e[0],
                             r = +(0, m.fj)(e),
                             o = r - i;
-                        if (t.type === qu) {
+                        if (t.type === df) {
                             const t = n ? o / n : .1;
                             i -= t, r += t, o = r - i
                         }
                         return t => (t - i) / o
                     }(f), l = v.map(((t, e) => rr({
                         index: e,
                         label: g(t, e, v),
                         value: t,
                         perc: e ? i(t) : 0,
                         perc2: e === r ? 1 : i(v[e + 1])
                     })))), c.source = l, c.add = l, this.value = l, c
                 }
             });
-            const oy = t => t.source.x,
-                ay = t => t.source.y,
-                sy = t => t.target.x,
-                cy = t => t.target.y;
+            const dy = t => t.source.x,
+                hy = t => t.source.y,
+                py = t => t.target.x,
+                my = t => t.target.y;
 
-            function ly(t) {
-                Rr.call(this, {}, t)
+            function gy(t) {
+                zr.call(this, {}, t)
             }
-            ly.Definition = {
+            gy.Definition = {
                 type: "LinkPath",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "sourceX",
                     type: "field",
@@ -30916,50 +31042,50 @@
                     name: "require",
                     type: "signal"
                 }, {
                     name: "as",
                     type: "string",
                     default: "path"
                 }]
-            }, (0, m.XW)(ly, Rr, {
+            }, (0, m.XW)(gy, zr, {
                 transform(t, e) {
-                    var n = t.sourceX || oy,
-                        i = t.sourceY || ay,
-                        r = t.targetX || sy,
-                        o = t.targetY || cy,
+                    var n = t.sourceX || dy,
+                        i = t.sourceY || hy,
+                        r = t.targetX || py,
+                        o = t.targetY || my,
                         a = t.as || "path",
                         s = t.orient || "vertical",
                         c = t.shape || "line",
-                        l = hy.get(c + "-" + s) || hy.get(c);
+                        l = xy.get(c + "-" + s) || xy.get(c);
                     return l || (0, m.vU)("LinkPath unsupported type: " + t.shape + (t.orient ? "-" + t.orient : "")), e.visit(e.SOURCE, (t => {
                         t[a] = l(n(t), i(t), r(t), o(t))
                     })), e.reflow(t.modified()).modifies(a)
                 }
             });
-            const uy = (t, e, n, i) => "M" + t + "," + e + "L" + n + "," + i,
-                fy = (t, e, n, i) => {
+            const vy = (t, e, n, i) => "M" + t + "," + e + "L" + n + "," + i,
+                yy = (t, e, n, i) => {
                     var r = n - t,
                         o = i - e,
                         a = Math.hypot(r, o) / 2;
                     return "M" + t + "," + e + "A" + a + "," + a + " " + 180 * Math.atan2(o, r) / Math.PI + " 0 1 " + n + "," + i
                 },
-                dy = (t, e, n, i) => {
+                by = (t, e, n, i) => {
                     const r = n - t,
                         o = i - e,
                         a = .2 * (r + o),
                         s = .2 * (o - r);
                     return "M" + t + "," + e + "C" + (t + a) + "," + (e + s) + " " + (n + s) + "," + (i - a) + " " + n + "," + i
                 },
-                hy = (0, m.Xr)({
-                    line: uy,
-                    "line-radial": (t, e, n, i) => uy(e * Math.cos(t), e * Math.sin(t), i * Math.cos(n), i * Math.sin(n)),
-                    arc: fy,
-                    "arc-radial": (t, e, n, i) => fy(e * Math.cos(t), e * Math.sin(t), i * Math.cos(n), i * Math.sin(n)),
-                    curve: dy,
-                    "curve-radial": (t, e, n, i) => dy(e * Math.cos(t), e * Math.sin(t), i * Math.cos(n), i * Math.sin(n)),
+                xy = (0, m.Xr)({
+                    line: vy,
+                    "line-radial": (t, e, n, i) => vy(e * Math.cos(t), e * Math.sin(t), i * Math.cos(n), i * Math.sin(n)),
+                    arc: yy,
+                    "arc-radial": (t, e, n, i) => yy(e * Math.cos(t), e * Math.sin(t), i * Math.cos(n), i * Math.sin(n)),
+                    curve: by,
+                    "curve-radial": (t, e, n, i) => by(e * Math.cos(t), e * Math.sin(t), i * Math.cos(n), i * Math.sin(n)),
                     "orthogonal-horizontal": (t, e, n, i) => "M" + t + "," + e + "V" + i + "H" + n,
                     "orthogonal-vertical": (t, e, n, i) => "M" + t + "," + e + "H" + n + "V" + i,
                     "orthogonal-radial": (t, e, n, i) => {
                         const r = Math.cos(t),
                             o = Math.sin(t),
                             a = Math.cos(n),
                             s = Math.sin(n);
@@ -30979,18 +31105,18 @@
                             a = Math.cos(n),
                             s = Math.sin(n),
                             c = (e + i) / 2;
                         return "M" + e * r + "," + e * o + "C" + c * r + "," + c * o + " " + c * a + "," + c * s + " " + i * a + "," + i * s
                     }
                 });
 
-            function py(t) {
-                Rr.call(this, null, t)
+            function _y(t) {
+                zr.call(this, null, t)
             }
-            py.Definition = {
+            _y.Definition = {
                 type: "Pie",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "field",
                     type: "field"
@@ -31009,168 +31135,179 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: ["startAngle", "endAngle"]
                 }]
-            }, (0, m.XW)(py, Rr, {
+            }, (0, m.XW)(_y, zr, {
                 transform(t, e) {
                     var n, i, r, o = t.as || ["startAngle", "endAngle"],
                         a = o[0],
                         s = o[1],
                         c = t.field || m.kX,
                         l = t.startAngle || 0,
                         u = null != t.endAngle ? t.endAngle : 2 * Math.PI,
                         f = e.source,
                         d = f.map(c),
                         h = d.length,
                         p = l,
-                        g = (u - l) / Qv(d),
+                        g = (u - l) / ay(d),
                         v = (0, Wo.Z)(h);
                     for (t.sort && v.sort(((t, e) => d[t] - d[e])), n = 0; n < h; ++n) r = d[v[n]], (i = f[v[n]])[a] = p, i[s] = p += r * g;
                     return this.value = d, e.reflow(t.modified()).modifies(o)
                 }
             });
-            const my = 5;
+            const wy = 5;
 
-            function gy(t) {
-                return lf(t) && t !== ju
+            function ky(t) {
+                return Tf(t) && t !== cf
             }
-            const vy = (0, m.Rg)(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
+            const Ey = (0, m.Rg)(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
 
-            function yy(t) {
-                Rr.call(this, null, t), this.modified(!0)
+            function Ay(t) {
+                zr.call(this, null, t), this.modified(!0)
             }
 
-            function by(t, e, n) {
-                if (df(t)) {
+            function Dy(t, e, n) {
+                if (Rf(t)) {
                     var i = Math.abs(e.reduce(((t, e) => t + (e < 0 ? -1 : e > 0 ? 1 : 0)), 0));
                     i !== e.length && n.warn("Log scale domain includes zero: " + (0, m.m8)(e))
                 }
                 return e
             }
 
-            function xy(t, e, n) {
-                return (0, m.mf)(t) && (e || n) ? gf(t, _y(e || [0, 1], n)) : t
+            function Sy(t, e, n) {
+                return (0, m.mf)(t) && (e || n) ? function(t, e) {
+                    const n = e[0],
+                        i = (0, m.fj)(e) - n;
+                    return function(e) {
+                        return t(n + e * i)
+                    }
+                }(t, Cy(e || [0, 1], n)) : t
             }
 
-            function _y(t, e) {
+            function Cy(t, e) {
                 return e ? t.slice().reverse() : t
             }
 
-            function wy(t) {
-                Rr.call(this, null, t)
-            }(0, m.XW)(yy, Rr, {
+            function My(t) {
+                zr.call(this, null, t)
+            }(0, m.XW)(Ay, zr, {
                 transform(t, e) {
                     var n = e.dataflow,
                         i = this.value,
                         r = function(t) {
                             var e, n = t.type,
                                 i = "";
-                            if (n === ju) return ju + "-" + Ou;
+                            if (n === cf) return cf + "-" + tf;
                             (function(t) {
                                 const e = t.type;
-                                return lf(e) && e !== Pu && e !== Lu && (t.scheme || t.range && t.range.length && t.range.every(m.HD))
-                            })(t) && (i = 2 === (e = t.rawDomain ? t.rawDomain.length : t.domain ? t.domain.length + +(null != t.domainMid) : 0) ? ju + "-" : 3 === e ? Bu + "-" : "");
-                            return (i + n || Ou).toLowerCase()
+                                return Tf(e) && e !== af && e !== sf && (t.scheme || t.range && t.range.length && t.range.every(m.HD))
+                            })(t) && (i = 2 === (e = t.rawDomain ? t.rawDomain.length : t.domain ? t.domain.length + +(null != t.domainMid) : 0) ? cf + "-" : 3 === e ? lf + "-" : "");
+                            return (i + n || tf).toLowerCase()
                         }(t);
-                    for (r in i && r === i.type || (this.value = i = af(r)()), t)
-                        if (!vy[r]) {
-                            if ("padding" === r && gy(i.type)) continue;
+                    for (r in i && r === i.type || (this.value = i = Ff(r)()), t)
+                        if (!Ey[r]) {
+                            if ("padding" === r && ky(i.type)) continue;
                             (0, m.mf)(i[r]) ? i[r](t[r]): n.warn("Unsupported scale property: " + r)
                         } return function(t, e, n) {
                         var i = t.type,
                             r = e.round || !1,
                             o = e.range;
                         if (null != e.rangeStep) o = function(t, e, n) {
-                            t !== Xu && t !== Hu && (0, m.vU)("Only band and point scales support rangeStep.");
+                            t !== mf && t !== pf && (0, m.vU)("Only band and point scales support rangeStep.");
                             var i = (null != e.paddingOuter ? e.paddingOuter : e.padding) || 0,
-                                r = t === Hu ? 1 : (null != e.paddingInner ? e.paddingInner : e.padding) || 0;
-                            return [0, e.rangeStep * Mu(n, r, i)]
+                                r = t === pf ? 1 : (null != e.paddingInner ? e.paddingInner : e.padding) || 0;
+                            return [0, e.rangeStep * Qu(n, r, i)]
                         }(i, e, n);
                         else if (e.scheme && (o = function(t, e, n) {
                                 var i, r = e.schemeExtent;
-                                (0, m.kJ)(e.scheme) ? i = vf(e.scheme, e.interpolate, e.interpolateGamma): (i = Ef(e.scheme.toLowerCase())) || (0, m.vU)("Unrecognized scheme name: ".concat(e.scheme));
-                                return n = t === qu ? n + 1 : t === Ju ? n - 1 : t === Iu || t === Uu ? +e.schemeCount || my : n, hf(t) ? xy(i, r, e.reverse) : (0, m.mf)(i) ? yf(xy(i, r), n) : t === Wu ? i : i.slice(0, n)
+                                (0, m.kJ)(e.scheme) ? i = Lf(e.scheme, e.interpolate, e.interpolateGamma): (i = Wf(e.scheme.toLowerCase())) || (0, m.vU)("Unrecognized scheme name: ".concat(e.scheme));
+                                return n = t === df ? n + 1 : t === gf ? n - 1 : t === uf || t === ff ? +e.schemeCount || wy : n, zf(t) ? Sy(i, r, e.reverse) : (0, m.mf)(i) ? function(t, e) {
+                                    const n = new Array(e),
+                                        i = e + 1;
+                                    for (let r = 0; r < e;) n[r] = t(++r / i);
+                                    return n
+                                }(Sy(i, r), n) : t === hf ? i : i.slice(0, n)
                             }(i, e, n), (0, m.mf)(o))) {
                             if (t.interpolator) return t.interpolator(o);
                             (0, m.vU)("Scale type ".concat(i, " does not support interpolating color schemes."))
                         }
-                        if (o && hf(i)) return t.interpolator(vf(_y(o, e.reverse), e.interpolate, e.interpolateGamma));
-                        o && e.interpolate && t.interpolate ? t.interpolate(xf(e.interpolate, e.interpolateGamma)) : (0, m.mf)(t.round) ? t.round(r) : (0, m.mf)(t.rangeRound) && t.interpolate(r ? hl.Z : dl.Z);
-                        o && t.range(_y(o, e.reverse))
+                        if (o && zf(i)) return t.interpolator(Lf(Cy(o, e.reverse), e.interpolate, e.interpolateGamma));
+                        o && e.interpolate && t.interpolate ? t.interpolate(If(e.interpolate, e.interpolateGamma)) : (0, m.mf)(t.round) ? t.round(r) : (0, m.mf)(t.rangeRound) && t.interpolate(r ? Ml.Z : Cl.Z);
+                        o && t.range(Cy(o, e.reverse))
                     }(i, t, function(t, e, n) {
                         let i = e.bins;
                         if (i && !(0, m.kJ)(i)) {
                             const e = t.domain(),
                                 n = e[0],
                                 r = (0, m.fj)(e),
                                 o = i.step;
                             let a = null == i.start ? n : i.start,
                                 s = null == i.stop ? r : i.stop;
                             o || (0, m.vU)("Scale bins parameter missing step property."), a < n && (a = o * Math.ceil(n / o)), s > r && (s = o * Math.floor(r / o)), i = (0, Wo.Z)(a, s + o / 2, o)
                         }
                         i ? t.bins = i : t.bins && delete t.bins;
-                        t.type === Ju && (i ? e.domain || e.domainRaw || (t.domain(i), n = i.length) : t.bins = t.domain());
+                        t.type === gf && (i ? e.domain || e.domainRaw || (t.domain(i), n = i.length) : t.bins = t.domain());
                         return n
                     }(i, t, function(t, e, n) {
                         const i = function(t, e, n) {
-                            return e ? (t.domain(by(t.type, e, n)), e.length) : -1
+                            return e ? (t.domain(Dy(t.type, e, n)), e.length) : -1
                         }(t, e.domainRaw, n);
                         if (i > -1) return i;
                         var r, o, a = e.domain,
                             s = t.type,
                             c = e.zero || void 0 === e.zero && function(t) {
                                 const e = t.type;
-                                return !t.bins && (e === Ou || e === Nu || e === zu)
+                                return !t.bins && (e === tf || e === nf || e === rf)
                             }(t);
                         if (!a) return 0;
-                        gy(s) && e.padding && a[0] !== (0, m.fj)(a) && (a = function(t, e, n, i, r, o) {
+                        ky(s) && e.padding && a[0] !== (0, m.fj)(a) && (a = function(t, e, n, i, r, o) {
                             var a = Math.abs((0, m.fj)(n) - n[0]),
                                 s = a / (a - 2 * i),
-                                c = t === Tu ? (0, m.dH)(e, null, s) : t === zu ? (0, m.mK)(e, null, s, .5) : t === Nu ? (0, m.mK)(e, null, s, r || 1) : t === Ru ? (0, m.bV)(e, null, s, o || 1) : (0, m.ay)(e, null, s);
+                                c = t === ef ? (0, m.dH)(e, null, s) : t === rf ? (0, m.mK)(e, null, s, .5) : t === nf ? (0, m.mK)(e, null, s, r || 1) : t === of ? (0, m.bV)(e, null, s, o || 1) : (0, m.ay)(e, null, s);
                             return e = e.slice(), e[0] = c[0], e[e.length - 1] = c[1], e
                         }(s, a, e.range, e.padding, e.exponent, e.constant));
                         if ((c || null != e.domainMin || null != e.domainMax || null != e.domainMid) && (r = (a = a.slice()).length - 1 || 1, c && (a[0] > 0 && (a[0] = 0), a[r] < 0 && (a[r] = 0)), null != e.domainMin && (a[0] = e.domainMin), null != e.domainMax && (a[r] = e.domainMax), null != e.domainMid)) {
                             const t = (o = e.domainMid) > a[r] ? r + 1 : o < a[0] ? 0 : r;
                             t !== r && n.warn("Scale domainMid exceeds domain min or max.", o), a.splice(t, 0, o)
                         }
-                        t.domain(by(s, a, n)), s === Wu && t.unknown(e.domainImplicit ? El.O : void 0);
-                        e.nice && t.nice && t.nice(!0 !== e.nice && Mf(t, e.nice) || null);
+                        t.domain(Dy(s, a, n)), s === hf && t.unknown(e.domainImplicit ? Jl.O : void 0);
+                        e.nice && t.nice && t.nice(!0 !== e.nice && $f(t, e.nice) || null);
                         return a.length
                     }(i, t, n))), e.fork(e.NO_SOURCE | e.NO_FIELDS)
                 }
-            }), (0, m.XW)(wy, Rr, {
+            }), (0, m.XW)(My, zr, {
                 transform(t, e) {
                     const n = t.modified("sort") || e.changed(e.ADD) || e.modified(t.sort.fields) || e.modified("datum");
                     return n && e.source.sort(cr(t.sort)), this.modified(n), e
                 }
             });
-            const ky = "zero",
-                Ey = "center",
-                Dy = "normalize",
-                Ay = ["y0", "y1"];
+            const Fy = "zero",
+                Oy = "center",
+                Ty = "normalize",
+                Ny = ["y0", "y1"];
 
-            function Sy(t) {
-                Rr.call(this, null, t)
+            function Ry(t) {
+                zr.call(this, null, t)
             }
 
-            function Cy(t, e, n, i, r) {
+            function zy(t, e, n, i, r) {
                 for (var o, a = (e - t.sum) / 2, s = t.length, c = 0; c < s; ++c)(o = t[c])[i] = a, o[r] = a += Math.abs(n(o))
             }
 
-            function Fy(t, e, n, i, r) {
+            function Py(t, e, n, i, r) {
                 for (var o, a = 1 / t.sum, s = 0, c = t.length, l = 0, u = 0; l < c; ++l)(o = t[l])[i] = s, o[r] = s = a * (u += Math.abs(n(o)))
             }
 
-            function My(t, e, n, i, r) {
+            function Ly(t, e, n, i, r) {
                 for (var o, a, s = 0, c = 0, l = t.length, u = 0; u < l; ++u)(o = +n(a = t[u])) < 0 ? (a[i] = c, a[r] = c += o) : (a[i] = s, a[r] = s += o)
             }
-            Sy.Definition = {
+            Ry.Definition = {
                 type: "Stack",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "field",
                     type: "field"
@@ -31180,31 +31317,31 @@
                     array: !0
                 }, {
                     name: "sort",
                     type: "compare"
                 }, {
                     name: "offset",
                     type: "enum",
-                    default: ky,
-                    values: [ky, Ey, Dy]
+                    default: Fy,
+                    values: [Fy, Oy, Ty]
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
-                    default: Ay
+                    default: Ny
                 }]
-            }, (0, m.XW)(Sy, Rr, {
+            }, (0, m.XW)(Ry, zr, {
                 transform(t, e) {
-                    var n, i, r, o, a = t.as || Ay,
+                    var n, i, r, o, a = t.as || Ny,
                         s = a[0],
                         c = a[1],
                         l = cr(t.sort),
                         u = t.field || m.kX,
-                        f = t.offset === Ey ? Cy : t.offset === Dy ? Fy : My;
+                        f = t.offset === Oy ? zy : t.offset === Ty ? Py : Ly;
                     for (n = function(t, e, n, i) {
                             var r, o, a, s, c, l, u, f, d, h = [],
                                 p = t => t(c);
                             if (null == e) h.push(t.slice());
                             else
                                 for (r = {}, o = 0, a = t.length; o < a; ++o) c = t[o], (u = r[l = e.map(p)]) || (r[l] = u = [], h.push(u)), u.push(c);
                             for (l = 0, d = 0, s = h.length; l < s; ++l) {
@@ -31212,72 +31349,72 @@
                                 u.sum = f, f > d && (d = f), n && u.sort(n)
                             }
                             return h.max = d, h
                         }(e.source, t.groupby, l, u), i = 0, r = n.length, o = n.max; i < r; ++i) f(n[i], o, u, s, c);
                     return e.reflow(t.modified()).modifies(a)
                 }
             });
-            const Oy = t => t;
+            const By = t => t;
 
-            function Ty(t, e) {
-                t && zy.hasOwnProperty(t.type) && zy[t.type](t, e)
+            function Iy(t, e) {
+                t && Uy.hasOwnProperty(t.type) && Uy[t.type](t, e)
             }
-            var Ny = {
+            var jy = {
                     Feature: function(t, e) {
-                        Ty(t.geometry, e)
+                        Iy(t.geometry, e)
                     },
                     FeatureCollection: function(t, e) {
-                        for (var n = t.features, i = -1, r = n.length; ++i < r;) Ty(n[i].geometry, e)
+                        for (var n = t.features, i = -1, r = n.length; ++i < r;) Iy(n[i].geometry, e)
                     }
                 },
-                zy = {
+                Uy = {
                     Sphere: function(t, e) {
                         e.sphere()
                     },
                     Point: function(t, e) {
                         t = t.coordinates, e.point(t[0], t[1], t[2])
                     },
                     MultiPoint: function(t, e) {
                         for (var n = t.coordinates, i = -1, r = n.length; ++i < r;) t = n[i], e.point(t[0], t[1], t[2])
                     },
                     LineString: function(t, e) {
-                        Ry(t.coordinates, e, 0)
+                        qy(t.coordinates, e, 0)
                     },
                     MultiLineString: function(t, e) {
-                        for (var n = t.coordinates, i = -1, r = n.length; ++i < r;) Ry(n[i], e, 0)
+                        for (var n = t.coordinates, i = -1, r = n.length; ++i < r;) qy(n[i], e, 0)
                     },
                     Polygon: function(t, e) {
-                        Py(t.coordinates, e)
+                        Wy(t.coordinates, e)
                     },
                     MultiPolygon: function(t, e) {
-                        for (var n = t.coordinates, i = -1, r = n.length; ++i < r;) Py(n[i], e)
+                        for (var n = t.coordinates, i = -1, r = n.length; ++i < r;) Wy(n[i], e)
                     },
                     GeometryCollection: function(t, e) {
-                        for (var n = t.geometries, i = -1, r = n.length; ++i < r;) Ty(n[i], e)
+                        for (var n = t.geometries, i = -1, r = n.length; ++i < r;) Iy(n[i], e)
                     }
                 };
 
-            function Ry(t, e, n) {
+            function qy(t, e, n) {
                 var i, r = -1,
                     o = t.length - n;
                 for (e.lineStart(); ++r < o;) i = t[r], e.point(i[0], i[1], i[2]);
                 e.lineEnd()
             }
 
-            function Py(t, e) {
+            function Wy(t, e) {
                 var n = -1,
                     i = t.length;
-                for (e.polygonStart(); ++n < i;) Ry(t[n], e, 1);
+                for (e.polygonStart(); ++n < i;) qy(t[n], e, 1);
                 e.polygonEnd()
             }
 
-            function Ly(t, e) {
-                t && Ny.hasOwnProperty(t.type) ? Ny[t.type](t, e) : Ty(t, e)
+            function Hy(t, e) {
+                t && jy.hasOwnProperty(t.type) ? jy[t.type](t, e) : Iy(t, e)
             }
-            class jy {
+            class Xy {
                 constructor() {
                     this._partials = new Float64Array(32), this._n = 0
                 }
                 add(t) {
                     const e = this._partials;
                     let n = 0;
                     for (let i = 0; i < this._n && i < 32; i++) {
@@ -31295,177 +31432,177 @@
                     if (r > 0) {
                         for (o = t[--r]; r > 0 && (e = o, n = t[--r], o = e + n, i = n - (o - e), !i););
                         r > 0 && (i < 0 && t[r - 1] < 0 || i > 0 && t[r - 1] > 0) && (n = 2 * i, e = o + n, n == e - o && (o = e))
                     }
                     return o
                 }
             }
-            var By = 1e-6,
-                Iy = 1e-12,
-                Uy = Math.PI,
-                qy = Uy / 2,
-                Wy = Uy / 4,
-                Hy = 2 * Uy,
-                Xy = 180 / Uy,
-                Jy = Uy / 180,
-                Gy = Math.abs,
-                $y = Math.atan,
-                Zy = Math.atan2,
-                Yy = Math.cos,
-                Vy = Math.ceil,
-                Ky = Math.exp,
-                Qy = (Math.floor, Math.hypot),
-                tb = Math.log,
-                eb = Math.pow,
-                nb = Math.sin,
-                ib = Math.sign || function(t) {
+            var Gy = 1e-6,
+                Jy = 1e-12,
+                Zy = Math.PI,
+                $y = Zy / 2,
+                Yy = Zy / 4,
+                Vy = 2 * Zy,
+                Ky = 180 / Zy,
+                Qy = Zy / 180,
+                tb = Math.abs,
+                eb = Math.atan,
+                nb = Math.atan2,
+                ib = Math.cos,
+                rb = Math.ceil,
+                ob = Math.exp,
+                ab = (Math.floor, Math.hypot),
+                sb = Math.log,
+                cb = Math.pow,
+                lb = Math.sin,
+                ub = Math.sign || function(t) {
                     return t > 0 ? 1 : t < 0 ? -1 : 0
                 },
-                rb = Math.sqrt,
-                ob = Math.tan;
+                fb = Math.sqrt,
+                db = Math.tan;
 
-            function ab(t) {
-                return t > 1 ? 0 : t < -1 ? Uy : Math.acos(t)
+            function hb(t) {
+                return t > 1 ? 0 : t < -1 ? Zy : Math.acos(t)
             }
 
-            function sb(t) {
-                return t > 1 ? qy : t < -1 ? -qy : Math.asin(t)
+            function pb(t) {
+                return t > 1 ? $y : t < -1 ? -$y : Math.asin(t)
             }
 
-            function cb() {}
-            var lb, ub, fb, db, hb = new jy,
-                pb = new jy,
-                mb = {
-                    point: cb,
-                    lineStart: cb,
-                    lineEnd: cb,
+            function mb() {}
+            var gb, vb, yb, bb, xb = new Xy,
+                _b = new Xy,
+                wb = {
+                    point: mb,
+                    lineStart: mb,
+                    lineEnd: mb,
                     polygonStart: function() {
-                        mb.lineStart = gb, mb.lineEnd = bb
+                        wb.lineStart = kb, wb.lineEnd = Db
                     },
                     polygonEnd: function() {
-                        mb.lineStart = mb.lineEnd = mb.point = cb, hb.add(Gy(pb)), pb = new jy
+                        wb.lineStart = wb.lineEnd = wb.point = mb, xb.add(tb(_b)), _b = new Xy
                     },
                     result: function() {
-                        var t = hb / 2;
-                        return hb = new jy, t
+                        var t = xb / 2;
+                        return xb = new Xy, t
                     }
                 };
 
-            function gb() {
-                mb.point = vb
+            function kb() {
+                wb.point = Eb
             }
 
-            function vb(t, e) {
-                mb.point = yb, lb = fb = t, ub = db = e
+            function Eb(t, e) {
+                wb.point = Ab, gb = yb = t, vb = bb = e
             }
 
-            function yb(t, e) {
-                pb.add(db * t - fb * e), fb = t, db = e
+            function Ab(t, e) {
+                _b.add(bb * t - yb * e), yb = t, bb = e
             }
 
-            function bb() {
-                yb(lb, ub)
+            function Db() {
+                Ab(gb, vb)
             }
-            const xb = mb;
-            var _b = 1 / 0,
-                wb = _b,
-                kb = -_b,
-                Eb = kb,
-                Db = {
+            const Sb = wb;
+            var Cb = 1 / 0,
+                Mb = Cb,
+                Fb = -Cb,
+                Ob = Fb,
+                Tb = {
                     point: function(t, e) {
-                        t < _b && (_b = t);
-                        t > kb && (kb = t);
-                        e < wb && (wb = e);
-                        e > Eb && (Eb = e)
-                    },
-                    lineStart: cb,
-                    lineEnd: cb,
-                    polygonStart: cb,
-                    polygonEnd: cb,
+                        t < Cb && (Cb = t);
+                        t > Fb && (Fb = t);
+                        e < Mb && (Mb = e);
+                        e > Ob && (Ob = e)
+                    },
+                    lineStart: mb,
+                    lineEnd: mb,
+                    polygonStart: mb,
+                    polygonEnd: mb,
                     result: function() {
                         var t = [
-                            [_b, wb],
-                            [kb, Eb]
+                            [Cb, Mb],
+                            [Fb, Ob]
                         ];
-                        return kb = Eb = -(wb = _b = 1 / 0), t
+                        return Fb = Ob = -(Mb = Cb = 1 / 0), t
                     }
                 };
-            const Ab = Db;
-            var Sb, Cb, Fb, Mb, Ob = 0,
-                Tb = 0,
-                Nb = 0,
-                zb = 0,
-                Rb = 0,
-                Pb = 0,
-                Lb = 0,
+            const Nb = Tb;
+            var Rb, zb, Pb, Lb, Bb = 0,
+                Ib = 0,
                 jb = 0,
-                Bb = 0,
-                Ib = {
-                    point: Ub,
-                    lineStart: qb,
-                    lineEnd: Xb,
+                Ub = 0,
+                qb = 0,
+                Wb = 0,
+                Hb = 0,
+                Xb = 0,
+                Gb = 0,
+                Jb = {
+                    point: Zb,
+                    lineStart: $b,
+                    lineEnd: Kb,
                     polygonStart: function() {
-                        Ib.lineStart = Jb, Ib.lineEnd = Gb
+                        Jb.lineStart = Qb, Jb.lineEnd = tx
                     },
                     polygonEnd: function() {
-                        Ib.point = Ub, Ib.lineStart = qb, Ib.lineEnd = Xb
+                        Jb.point = Zb, Jb.lineStart = $b, Jb.lineEnd = Kb
                     },
                     result: function() {
-                        var t = Bb ? [Lb / Bb, jb / Bb] : Pb ? [zb / Pb, Rb / Pb] : Nb ? [Ob / Nb, Tb / Nb] : [NaN, NaN];
-                        return Ob = Tb = Nb = zb = Rb = Pb = Lb = jb = Bb = 0, t
+                        var t = Gb ? [Hb / Gb, Xb / Gb] : Wb ? [Ub / Wb, qb / Wb] : jb ? [Bb / jb, Ib / jb] : [NaN, NaN];
+                        return Bb = Ib = jb = Ub = qb = Wb = Hb = Xb = Gb = 0, t
                     }
                 };
 
-            function Ub(t, e) {
-                Ob += t, Tb += e, ++Nb
+            function Zb(t, e) {
+                Bb += t, Ib += e, ++jb
             }
 
-            function qb() {
-                Ib.point = Wb
+            function $b() {
+                Jb.point = Yb
             }
 
-            function Wb(t, e) {
-                Ib.point = Hb, Ub(Fb = t, Mb = e)
+            function Yb(t, e) {
+                Jb.point = Vb, Zb(Pb = t, Lb = e)
             }
 
-            function Hb(t, e) {
-                var n = t - Fb,
-                    i = e - Mb,
-                    r = rb(n * n + i * i);
-                zb += r * (Fb + t) / 2, Rb += r * (Mb + e) / 2, Pb += r, Ub(Fb = t, Mb = e)
+            function Vb(t, e) {
+                var n = t - Pb,
+                    i = e - Lb,
+                    r = fb(n * n + i * i);
+                Ub += r * (Pb + t) / 2, qb += r * (Lb + e) / 2, Wb += r, Zb(Pb = t, Lb = e)
             }
 
-            function Xb() {
-                Ib.point = Ub
+            function Kb() {
+                Jb.point = Zb
             }
 
-            function Jb() {
-                Ib.point = $b
+            function Qb() {
+                Jb.point = ex
             }
 
-            function Gb() {
-                Zb(Sb, Cb)
+            function tx() {
+                nx(Rb, zb)
             }
 
-            function $b(t, e) {
-                Ib.point = Zb, Ub(Sb = Fb = t, Cb = Mb = e)
+            function ex(t, e) {
+                Jb.point = nx, Zb(Rb = Pb = t, zb = Lb = e)
             }
 
-            function Zb(t, e) {
-                var n = t - Fb,
-                    i = e - Mb,
-                    r = rb(n * n + i * i);
-                zb += r * (Fb + t) / 2, Rb += r * (Mb + e) / 2, Pb += r, Lb += (r = Mb * t - Fb * e) * (Fb + t), jb += r * (Mb + e), Bb += 3 * r, Ub(Fb = t, Mb = e)
+            function nx(t, e) {
+                var n = t - Pb,
+                    i = e - Lb,
+                    r = fb(n * n + i * i);
+                Ub += r * (Pb + t) / 2, qb += r * (Lb + e) / 2, Wb += r, Hb += (r = Lb * t - Pb * e) * (Pb + t), Xb += r * (Lb + e), Gb += 3 * r, Zb(Pb = t, Lb = e)
             }
-            const Yb = Ib;
+            const ix = Jb;
 
-            function Vb(t) {
+            function rx(t) {
                 this._context = t
             }
-            Vb.prototype = {
+            rx.prototype = {
                 _radius: 4.5,
                 pointRadius: function(t) {
                     return this._radius = t, this
                 },
                 polygonStart: function() {
                     this._line = 0
                 },
@@ -31483,65 +31620,65 @@
                         case 0:
                             this._context.moveTo(t, e), this._point = 1;
                             break;
                         case 1:
                             this._context.lineTo(t, e);
                             break;
                         default:
-                            this._context.moveTo(t + this._radius, e), this._context.arc(t, e, this._radius, 0, Hy)
+                            this._context.moveTo(t + this._radius, e), this._context.arc(t, e, this._radius, 0, Vy)
                     }
                 },
-                result: cb
+                result: mb
             };
-            var Kb, Qb, tx, ex, nx, ix = new jy,
-                rx = {
-                    point: cb,
+            var ox, ax, sx, cx, lx, ux = new Xy,
+                fx = {
+                    point: mb,
                     lineStart: function() {
-                        rx.point = ox
+                        fx.point = dx
                     },
                     lineEnd: function() {
-                        Kb && ax(Qb, tx), rx.point = cb
+                        ox && hx(ax, sx), fx.point = mb
                     },
                     polygonStart: function() {
-                        Kb = !0
+                        ox = !0
                     },
                     polygonEnd: function() {
-                        Kb = null
+                        ox = null
                     },
                     result: function() {
-                        var t = +ix;
-                        return ix = new jy, t
+                        var t = +ux;
+                        return ux = new Xy, t
                     }
                 };
 
-            function ox(t, e) {
-                rx.point = ax, Qb = ex = t, tx = nx = e
+            function dx(t, e) {
+                fx.point = hx, ax = cx = t, sx = lx = e
             }
 
-            function ax(t, e) {
-                ex -= t, nx -= e, ix.add(rb(ex * ex + nx * nx)), ex = t, nx = e
+            function hx(t, e) {
+                cx -= t, lx -= e, ux.add(fb(cx * cx + lx * lx)), cx = t, lx = e
             }
-            const sx = rx;
-            var cx, lx, ux, fx;
-            let dx, hx, px, mx;
-            class gx {
+            const px = fx;
+            var mx, gx, vx, yx;
+            let bx, xx, _x, wx;
+            class kx {
                 constructor(t) {
-                    this._append = null == t ? vx : function(t) {
+                    this._append = null == t ? Ex : function(t) {
                         const e = Math.floor(t);
                         if (!(e >= 0)) throw new RangeError("invalid digits: ".concat(t));
-                        if (e > 15) return vx;
-                        if (e !== dx) {
+                        if (e > 15) return Ex;
+                        if (e !== bx) {
                             const t = 10 ** e;
-                            dx = e, hx = function(e) {
+                            bx = e, xx = function(e) {
                                 let n = 1;
                                 this._ += e[0];
                                 for (const i = e.length; n < i; ++n) this._ += Math.round(arguments[n] * t) / t + e[n]
                             }
                         }
-                        return hx
+                        return xx
                     }(t), this._radius = 4.5, this._ = ""
                 }
                 pointRadius(t) {
                     return this._radius = +t, this
                 }
                 polygonStart() {
                     this._line = 0
@@ -31554,119 +31691,119 @@
                 }
                 lineEnd() {
                     0 === this._line && (this._ += "Z"), this._point = NaN
                 }
                 point(t, e) {
                     switch (this._point) {
                         case 0:
-                            this._append(cx || (cx = (0, kc.Z)(["M", ",", ""])), t, e), this._point = 1;
+                            this._append(mx || (mx = (0, Nc.Z)(["M", ",", ""])), t, e), this._point = 1;
                             break;
                         case 1:
-                            this._append(lx || (lx = (0, kc.Z)(["L", ",", ""])), t, e);
+                            this._append(gx || (gx = (0, Nc.Z)(["L", ",", ""])), t, e);
                             break;
                         default:
-                            if (this._append(ux || (ux = (0, kc.Z)(["M", ",", ""])), t, e), this._radius !== px || this._append !== hx) {
+                            if (this._append(vx || (vx = (0, Nc.Z)(["M", ",", ""])), t, e), this._radius !== _x || this._append !== xx) {
                                 const t = this._radius,
                                     e = this._;
-                                this._ = "", this._append(fx || (fx = (0, kc.Z)(["m0,", "a", ",", " 0 1,1 0,", "a", ",", " 0 1,1 0,", "z"])), t, t, t, -2 * t, t, t, 2 * t), px = t, hx = this._append, mx = this._, this._ = e
+                                this._ = "", this._append(yx || (yx = (0, Nc.Z)(["m0,", "a", ",", " 0 1,1 0,", "a", ",", " 0 1,1 0,", "z"])), t, t, t, -2 * t, t, t, 2 * t), _x = t, xx = this._append, wx = this._, this._ = e
                             }
-                            this._ += mx
+                            this._ += wx
                     }
                 }
                 result() {
                     const t = this._;
                     return this._ = "", t.length ? t : null
                 }
             }
 
-            function vx(t) {
+            function Ex(t) {
                 let e = 1;
                 this._ += t[0];
                 for (const n = t.length; e < n; ++e) this._ += arguments[e] + t[e]
             }
 
-            function yx(t, e) {
+            function Ax(t, e) {
                 let n, i, r = 3,
                     o = 4.5;
 
                 function a(t) {
-                    return t && ("function" === typeof o && i.pointRadius(+o.apply(this, arguments)), Ly(t, n(i))), i.result()
+                    return t && ("function" === typeof o && i.pointRadius(+o.apply(this, arguments)), Hy(t, n(i))), i.result()
                 }
                 return a.area = function(t) {
-                    return Ly(t, n(xb)), xb.result()
+                    return Hy(t, n(Sb)), Sb.result()
                 }, a.measure = function(t) {
-                    return Ly(t, n(sx)), sx.result()
+                    return Hy(t, n(px)), px.result()
                 }, a.bounds = function(t) {
-                    return Ly(t, n(Ab)), Ab.result()
+                    return Hy(t, n(Nb)), Nb.result()
                 }, a.centroid = function(t) {
-                    return Ly(t, n(Yb)), Yb.result()
+                    return Hy(t, n(ix)), ix.result()
                 }, a.projection = function(e) {
-                    return arguments.length ? (n = null == e ? (t = null, Oy) : (t = e).stream, a) : t
+                    return arguments.length ? (n = null == e ? (t = null, By) : (t = e).stream, a) : t
                 }, a.context = function(t) {
-                    return arguments.length ? (i = null == t ? (e = null, new gx(r)) : new Vb(e = t), "function" !== typeof o && i.pointRadius(o), a) : e
+                    return arguments.length ? (i = null == t ? (e = null, new kx(r)) : new rx(e = t), "function" !== typeof o && i.pointRadius(o), a) : e
                 }, a.pointRadius = function(t) {
                     return arguments.length ? (o = "function" === typeof t ? t : (i.pointRadius(+t), +t), a) : o
                 }, a.digits = function(t) {
                     if (!arguments.length) return r;
                     if (null == t) r = null;
                     else {
                         const e = Math.floor(t);
                         if (!(e >= 0)) throw new RangeError("invalid digits: ".concat(t));
                         r = e
                     }
-                    return null === e && (i = new gx(r)), a
+                    return null === e && (i = new kx(r)), a
                 }, a.projection(t).digits(r).context(e)
             }
 
-            function bx() {
+            function Dx() {
                 var t, e = [];
                 return {
                     point: function(e, n, i) {
                         t.push([e, n, i])
                     },
                     lineStart: function() {
                         e.push(t = [])
                     },
-                    lineEnd: cb,
+                    lineEnd: mb,
                     rejoin: function() {
                         e.length > 1 && e.push(e.pop().concat(e.shift()))
                     },
                     result: function() {
                         var n = e;
                         return e = [], t = null, n
                     }
                 }
             }
 
-            function xx(t, e) {
-                return Gy(t[0] - e[0]) < By && Gy(t[1] - e[1]) < By
+            function Sx(t, e) {
+                return tb(t[0] - e[0]) < Gy && tb(t[1] - e[1]) < Gy
             }
 
-            function _x(t, e, n, i) {
+            function Cx(t, e, n, i) {
                 this.x = t, this.z = e, this.o = n, this.e = i, this.v = !1, this.n = this.p = null
             }
 
-            function wx(t, e, n, i, r) {
+            function Mx(t, e, n, i, r) {
                 var o, a, s = [],
                     c = [];
                 if (t.forEach((function(t) {
                         if (!((e = t.length - 1) <= 0)) {
                             var e, n, i = t[0],
                                 a = t[e];
-                            if (xx(i, a)) {
+                            if (Sx(i, a)) {
                                 if (!i[2] && !a[2]) {
                                     for (r.lineStart(), o = 0; o < e; ++o) r.point((i = t[o])[0], i[1]);
                                     return void r.lineEnd()
                                 }
-                                a[0] += 2 * By
+                                a[0] += 2 * Gy
                             }
-                            s.push(n = new _x(i, t, null, !0)), c.push(n.o = new _x(i, null, n, !1)), s.push(n = new _x(a, t, null, !1)), c.push(n.o = new _x(a, null, n, !0))
+                            s.push(n = new Cx(i, t, null, !0)), c.push(n.o = new Cx(i, null, n, !1)), s.push(n = new Cx(a, t, null, !1)), c.push(n.o = new Cx(a, null, n, !0))
                         }
                     })), s.length) {
-                    for (c.sort(e), kx(s), kx(c), o = 0, a = c.length; o < a; ++o) c[o].e = n = !n;
+                    for (c.sort(e), Fx(s), Fx(c), o = 0, a = c.length; o < a; ++o) c[o].e = n = !n;
                     for (var l, u, f = s[0];;) {
                         for (var d = f, h = !0; d.v;)
                             if ((d = d.n) === f) return;
                         l = d.z, r.lineStart();
                         do {
                             if (d.v = d.o.v = !0, d.e) {
                                 if (h)
@@ -31682,112 +31819,112 @@
                             l = (d = d.o).z, h = !h
                         } while (!d.v);
                         r.lineEnd()
                     }
                 }
             }
 
-            function kx(t) {
+            function Fx(t) {
                 if (e = t.length) {
                     for (var e, n, i = 0, r = t[0]; ++i < e;) r.n = n = t[i], n.p = r, r = n;
                     r.n = n = t[0], n.p = r
                 }
             }
 
-            function Ex(t) {
-                return [Zy(t[1], t[0]), sb(t[2])]
+            function Ox(t) {
+                return [nb(t[1], t[0]), pb(t[2])]
             }
 
-            function Dx(t) {
+            function Tx(t) {
                 var e = t[0],
                     n = t[1],
-                    i = Yy(n);
-                return [i * Yy(e), i * nb(e), nb(n)]
+                    i = ib(n);
+                return [i * ib(e), i * lb(e), lb(n)]
             }
 
-            function Ax(t, e) {
+            function Nx(t, e) {
                 return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
             }
 
-            function Sx(t, e) {
+            function Rx(t, e) {
                 return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
             }
 
-            function Cx(t, e) {
+            function zx(t, e) {
                 t[0] += e[0], t[1] += e[1], t[2] += e[2]
             }
 
-            function Fx(t, e) {
+            function Px(t, e) {
                 return [t[0] * e, t[1] * e, t[2] * e]
             }
 
-            function Mx(t) {
-                var e = rb(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
+            function Lx(t) {
+                var e = fb(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
                 t[0] /= e, t[1] /= e, t[2] /= e
             }
 
-            function Ox(t) {
-                return Gy(t[0]) <= Uy ? t[0] : ib(t[0]) * ((Gy(t[0]) + Uy) % Hy - Uy)
+            function Bx(t) {
+                return tb(t[0]) <= Zy ? t[0] : ub(t[0]) * ((tb(t[0]) + Zy) % Vy - Zy)
             }
 
-            function Tx(t) {
+            function Ix(t) {
                 return Array.from(function*(t) {
                     for (const e of t) yield* e
                 }(t))
             }
 
-            function Nx(t, e, n, i) {
+            function jx(t, e, n, i) {
                 return function(r) {
                     var o, a, s, c = e(r),
-                        l = bx(),
+                        l = Dx(),
                         u = e(l),
                         f = !1,
                         d = {
                             point: h,
                             lineStart: m,
                             lineEnd: g,
                             polygonStart: function() {
                                 d.point = v, d.lineStart = y, d.lineEnd = b, a = [], o = []
                             },
                             polygonEnd: function() {
-                                d.point = h, d.lineStart = m, d.lineEnd = g, a = Tx(a);
+                                d.point = h, d.lineStart = m, d.lineEnd = g, a = Ix(a);
                                 var t = function(t, e) {
-                                    var n = Ox(e),
+                                    var n = Bx(e),
                                         i = e[1],
-                                        r = nb(i),
-                                        o = [nb(n), -Yy(n), 0],
+                                        r = lb(i),
+                                        o = [lb(n), -ib(n), 0],
                                         a = 0,
                                         s = 0,
-                                        c = new jy;
-                                    1 === r ? i = qy + By : -1 === r && (i = -qy - By);
+                                        c = new Xy;
+                                    1 === r ? i = $y + Gy : -1 === r && (i = -$y - Gy);
                                     for (var l = 0, u = t.length; l < u; ++l)
                                         if (d = (f = t[l]).length)
-                                            for (var f, d, h = f[d - 1], p = Ox(h), m = h[1] / 2 + Wy, g = nb(m), v = Yy(m), y = 0; y < d; ++y, p = x, g = w, v = k, h = b) {
+                                            for (var f, d, h = f[d - 1], p = Bx(h), m = h[1] / 2 + Yy, g = lb(m), v = ib(m), y = 0; y < d; ++y, p = x, g = w, v = k, h = b) {
                                                 var b = f[y],
-                                                    x = Ox(b),
-                                                    _ = b[1] / 2 + Wy,
-                                                    w = nb(_),
-                                                    k = Yy(_),
+                                                    x = Bx(b),
+                                                    _ = b[1] / 2 + Yy,
+                                                    w = lb(_),
+                                                    k = ib(_),
                                                     E = x - p,
-                                                    D = E >= 0 ? 1 : -1,
-                                                    A = D * E,
-                                                    S = A > Uy,
+                                                    A = E >= 0 ? 1 : -1,
+                                                    D = A * E,
+                                                    S = D > Zy,
                                                     C = g * w;
-                                                if (c.add(Zy(C * D * nb(A), v * k + C * Yy(A))), a += S ? E + D * Hy : E, S ^ p >= n ^ x >= n) {
-                                                    var F = Sx(Dx(h), Dx(b));
-                                                    Mx(F);
-                                                    var M = Sx(o, F);
-                                                    Mx(M);
-                                                    var O = (S ^ E >= 0 ? -1 : 1) * sb(M[2]);
-                                                    (i > O || i === O && (F[0] || F[1])) && (s += S ^ E >= 0 ? 1 : -1)
+                                                if (c.add(nb(C * A * lb(D), v * k + C * ib(D))), a += S ? E + A * Vy : E, S ^ p >= n ^ x >= n) {
+                                                    var M = Rx(Tx(h), Tx(b));
+                                                    Lx(M);
+                                                    var F = Rx(o, M);
+                                                    Lx(F);
+                                                    var O = (S ^ E >= 0 ? -1 : 1) * pb(F[2]);
+                                                    (i > O || i === O && (M[0] || M[1])) && (s += S ^ E >= 0 ? 1 : -1)
                                                 }
                                             }
-                                    return (a < -By || a < By && c < -Iy) ^ 1 & s
+                                    return (a < -Gy || a < Gy && c < -Jy) ^ 1 & s
                                 }(o, i);
-                                a.length ? (f || (r.polygonStart(), f = !0), wx(a, Rx, t, n, r)) : t && (f || (r.polygonStart(), f = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), f && (r.polygonEnd(), f = !1), a = o = null
+                                a.length ? (f || (r.polygonStart(), f = !0), Mx(a, qx, t, n, r)) : t && (f || (r.polygonStart(), f = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), f && (r.polygonEnd(), f = !1), a = o = null
                             },
                             sphere: function() {
                                 r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd()
                             }
                         };
 
                     function h(e, n) {
@@ -31821,80 +31958,80 @@
                             h = d.length;
                         if (s.pop(), o.push(s), s = null, h)
                             if (1 & c) {
                                 if ((e = (n = d[0]).length - 1) > 0) {
                                     for (f || (r.polygonStart(), f = !0), r.lineStart(), t = 0; t < e; ++t) r.point((i = n[t])[0], i[1]);
                                     r.lineEnd()
                                 }
-                            } else h > 1 && 2 & c && d.push(d.pop().concat(d.shift())), a.push(d.filter(zx))
+                            } else h > 1 && 2 & c && d.push(d.pop().concat(d.shift())), a.push(d.filter(Ux))
                     }
                     return d
                 }
             }
 
-            function zx(t) {
+            function Ux(t) {
                 return t.length > 1
             }
 
-            function Rx(t, e) {
-                return ((t = t.x)[0] < 0 ? t[1] - qy - By : qy - t[1]) - ((e = e.x)[0] < 0 ? e[1] - qy - By : qy - e[1])
+            function qx(t, e) {
+                return ((t = t.x)[0] < 0 ? t[1] - $y - Gy : $y - t[1]) - ((e = e.x)[0] < 0 ? e[1] - $y - Gy : $y - e[1])
             }
-            const Px = Nx((function() {
+            const Wx = jx((function() {
                 return !0
             }), (function(t) {
                 var e, n = NaN,
                     i = NaN,
                     r = NaN;
                 return {
                     lineStart: function() {
                         t.lineStart(), e = 1
                     },
                     point: function(o, a) {
-                        var s = o > 0 ? Uy : -Uy,
-                            c = Gy(o - n);
-                        Gy(c - Uy) < By ? (t.point(n, i = (i + a) / 2 > 0 ? qy : -qy), t.point(r, i), t.lineEnd(), t.lineStart(), t.point(s, i), t.point(o, i), e = 0) : r !== s && c >= Uy && (Gy(n - r) < By && (n -= r * By), Gy(o - s) < By && (o -= s * By), i = function(t, e, n, i) {
-                            var r, o, a = nb(t - n);
-                            return Gy(a) > By ? $y((nb(e) * (o = Yy(i)) * nb(n) - nb(i) * (r = Yy(e)) * nb(t)) / (r * o * a)) : (e + i) / 2
+                        var s = o > 0 ? Zy : -Zy,
+                            c = tb(o - n);
+                        tb(c - Zy) < Gy ? (t.point(n, i = (i + a) / 2 > 0 ? $y : -$y), t.point(r, i), t.lineEnd(), t.lineStart(), t.point(s, i), t.point(o, i), e = 0) : r !== s && c >= Zy && (tb(n - r) < Gy && (n -= r * Gy), tb(o - s) < Gy && (o -= s * Gy), i = function(t, e, n, i) {
+                            var r, o, a = lb(t - n);
+                            return tb(a) > Gy ? eb((lb(e) * (o = ib(i)) * lb(n) - lb(i) * (r = ib(e)) * lb(t)) / (r * o * a)) : (e + i) / 2
                         }(n, i, o, a), t.point(r, i), t.lineEnd(), t.lineStart(), t.point(s, i), e = 0), t.point(n = o, i = a), r = s
                     },
                     lineEnd: function() {
                         t.lineEnd(), n = i = NaN
                     },
                     clean: function() {
                         return 2 - e
                     }
                 }
             }), (function(t, e, n, i) {
                 var r;
-                if (null == t) r = n * qy, i.point(-Uy, r), i.point(0, r), i.point(Uy, r), i.point(Uy, 0), i.point(Uy, -r), i.point(0, -r), i.point(-Uy, -r), i.point(-Uy, 0), i.point(-Uy, r);
-                else if (Gy(t[0] - e[0]) > By) {
-                    var o = t[0] < e[0] ? Uy : -Uy;
+                if (null == t) r = n * $y, i.point(-Zy, r), i.point(0, r), i.point(Zy, r), i.point(Zy, 0), i.point(Zy, -r), i.point(0, -r), i.point(-Zy, -r), i.point(-Zy, 0), i.point(-Zy, r);
+                else if (tb(t[0] - e[0]) > Gy) {
+                    var o = t[0] < e[0] ? Zy : -Zy;
                     r = n * o / 2, i.point(-o, r), i.point(0, r), i.point(o, r)
                 } else i.point(e[0], e[1])
-            }), [-Uy, -qy]);
+            }), [-Zy, -$y]);
 
-            function Lx(t, e, n, i, r, o) {
+            function Hx(t, e, n, i, r, o) {
                 if (n) {
-                    var a = Yy(e),
-                        s = nb(e),
+                    var a = ib(e),
+                        s = lb(e),
                         c = i * n;
-                    null == r ? (r = e + i * Hy, o = e - c / 2) : (r = jx(a, r), o = jx(a, o), (i > 0 ? r < o : r > o) && (r += i * Hy));
-                    for (var l, u = r; i > 0 ? u > o : u < o; u -= c) l = Ex([a, -s * Yy(u), -s * nb(u)]), t.point(l[0], l[1])
+                    null == r ? (r = e + i * Vy, o = e - c / 2) : (r = Xx(a, r), o = Xx(a, o), (i > 0 ? r < o : r > o) && (r += i * Vy));
+                    for (var l, u = r; i > 0 ? u > o : u < o; u -= c) l = Ox([a, -s * ib(u), -s * lb(u)]), t.point(l[0], l[1])
                 }
             }
 
-            function jx(t, e) {
-                (e = Dx(e))[0] -= t, Mx(e);
-                var n = ab(-e[1]);
-                return ((-e[2] < 0 ? -n : n) + Hy - By) % Hy
+            function Xx(t, e) {
+                (e = Tx(e))[0] -= t, Lx(e);
+                var n = hb(-e[1]);
+                return ((-e[2] < 0 ? -n : n) + Vy - Gy) % Vy
             }
-            var Bx = 1e9,
-                Ix = -Bx;
+            var Gx = 1e9,
+                Jx = -Gx;
 
-            function Ux(t, e, n, i) {
+            function Zx(t, e, n, i) {
                 function r(r, o) {
                     return t <= r && r <= n && e <= o && o <= i
                 }
 
                 function o(r, o, s, l) {
                     var u = 0,
                         f = 0;
@@ -31902,29 +32039,29 @@
                         do {
                             l.point(0 === u || 3 === u ? t : n, u > 1 ? i : e)
                         } while ((u = (u + s + 4) % 4) !== f);
                     else l.point(o[0], o[1])
                 }
 
                 function a(i, r) {
-                    return Gy(i[0] - t) < By ? r > 0 ? 0 : 3 : Gy(i[0] - n) < By ? r > 0 ? 2 : 1 : Gy(i[1] - e) < By ? r > 0 ? 1 : 0 : r > 0 ? 3 : 2
+                    return tb(i[0] - t) < Gy ? r > 0 ? 0 : 3 : tb(i[0] - n) < Gy ? r > 0 ? 2 : 1 : tb(i[1] - e) < Gy ? r > 0 ? 1 : 0 : r > 0 ? 3 : 2
                 }
 
                 function s(t, e) {
                     return c(t.x, e.x)
                 }
 
                 function c(t, e) {
                     var n = a(t, 1),
                         i = a(e, 1);
                     return n !== i ? n - i : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0]
                 }
                 return function(a) {
                     var c, l, u, f, d, h, p, m, g, v, y, b = a,
-                        x = bx(),
+                        x = Dx(),
                         _ = {
                             point: w,
                             lineStart: function() {
                                 _.point = k, l && l.push(u = []);
                                 v = !0, g = !1, p = m = NaN
                             },
                             lineEnd: function() {
@@ -31937,31 +32074,31 @@
                             polygonEnd: function() {
                                 var e = function() {
                                         for (var e = 0, n = 0, r = l.length; n < r; ++n)
                                             for (var o, a, s = l[n], c = 1, u = s.length, f = s[0], d = f[0], h = f[1]; c < u; ++c) o = d, a = h, d = (f = s[c])[0], h = f[1], a <= i ? h > i && (d - o) * (i - a) > (h - a) * (t - o) && ++e : h <= i && (d - o) * (i - a) < (h - a) * (t - o) && --e;
                                         return e
                                     }(),
                                     n = y && e,
-                                    r = (c = Tx(c)).length;
-                                (n || r) && (a.polygonStart(), n && (a.lineStart(), o(null, null, 1, a), a.lineEnd()), r && wx(c, s, e, o, a), a.polygonEnd());
+                                    r = (c = Ix(c)).length;
+                                (n || r) && (a.polygonStart(), n && (a.lineStart(), o(null, null, 1, a), a.lineEnd()), r && Mx(c, s, e, o, a), a.polygonEnd());
                                 b = a, c = l = u = null
                             }
                         };
 
                     function w(t, e) {
                         r(t, e) && b.point(t, e)
                     }
 
                     function k(o, a) {
                         var s = r(o, a);
                         if (l && u.push([o, a]), v) f = o, d = a, h = s, v = !1, s && (b.lineStart(), b.point(o, a));
                         else if (s && g) b.point(o, a);
                         else {
-                            var c = [p = Math.max(Ix, Math.min(Bx, p)), m = Math.max(Ix, Math.min(Bx, m))],
-                                x = [o = Math.max(Ix, Math.min(Bx, o)), a = Math.max(Ix, Math.min(Bx, a))];
+                            var c = [p = Math.max(Jx, Math.min(Gx, p)), m = Math.max(Jx, Math.min(Gx, m))],
+                                x = [o = Math.max(Jx, Math.min(Gx, o)), a = Math.max(Jx, Math.min(Gx, a))];
                             ! function(t, e, n, i, r, o) {
                                 var a, s = t[0],
                                     c = t[1],
                                     l = 0,
                                     u = 1,
                                     f = e[0] - s,
                                     d = e[1] - c;
@@ -32006,119 +32143,119 @@
                         }
                         p = o, m = a, g = s
                     }
                     return _
                 }
             }
 
-            function qx(t, e) {
+            function $x(t, e) {
                 function n(n, i) {
                     return n = t(n, i), e(n[0], n[1])
                 }
                 return t.invert && e.invert && (n.invert = function(n, i) {
                     return (n = e.invert(n, i)) && t.invert(n[0], n[1])
                 }), n
             }
 
-            function Wx(t, e) {
-                return Gy(t) > Uy && (t -= Math.round(t / Hy) * Hy), [t, e]
+            function Yx(t, e) {
+                return tb(t) > Zy && (t -= Math.round(t / Vy) * Vy), [t, e]
             }
 
-            function Hx(t, e, n) {
-                return (t %= Hy) ? e || n ? qx(Jx(t), Gx(e, n)) : Jx(t) : e || n ? Gx(e, n) : Wx
+            function Vx(t, e, n) {
+                return (t %= Vy) ? e || n ? $x(Qx(t), t_(e, n)) : Qx(t) : e || n ? t_(e, n) : Yx
             }
 
-            function Xx(t) {
+            function Kx(t) {
                 return function(e, n) {
-                    return Gy(e += t) > Uy && (e -= Math.round(e / Hy) * Hy), [e, n]
+                    return tb(e += t) > Zy && (e -= Math.round(e / Vy) * Vy), [e, n]
                 }
             }
 
-            function Jx(t) {
-                var e = Xx(t);
-                return e.invert = Xx(-t), e
+            function Qx(t) {
+                var e = Kx(t);
+                return e.invert = Kx(-t), e
             }
 
-            function Gx(t, e) {
-                var n = Yy(t),
-                    i = nb(t),
-                    r = Yy(e),
-                    o = nb(e);
+            function t_(t, e) {
+                var n = ib(t),
+                    i = lb(t),
+                    r = ib(e),
+                    o = lb(e);
 
                 function a(t, e) {
-                    var a = Yy(e),
-                        s = Yy(t) * a,
-                        c = nb(t) * a,
-                        l = nb(e),
+                    var a = ib(e),
+                        s = ib(t) * a,
+                        c = lb(t) * a,
+                        l = lb(e),
                         u = l * n + s * i;
-                    return [Zy(c * r - u * o, s * n - l * i), sb(u * r + c * o)]
+                    return [nb(c * r - u * o, s * n - l * i), pb(u * r + c * o)]
                 }
                 return a.invert = function(t, e) {
-                    var a = Yy(e),
-                        s = Yy(t) * a,
-                        c = nb(t) * a,
-                        l = nb(e),
+                    var a = ib(e),
+                        s = ib(t) * a,
+                        c = lb(t) * a,
+                        l = lb(e),
                         u = l * r - c * o;
-                    return [Zy(c * r + l * o, s * n + u * i), sb(u * n - s * i)]
+                    return [nb(c * r + l * o, s * n + u * i), pb(u * n - s * i)]
                 }, a
             }
 
-            function $x(t) {
+            function e_(t) {
                 return function(e) {
-                    var n = new Zx;
+                    var n = new n_;
                     for (var i in t) n[i] = t[i];
                     return n.stream = e, n
                 }
             }
 
-            function Zx() {}
+            function n_() {}
 
-            function Yx(t, e, n) {
+            function i_(t, e, n) {
                 var i = t.clipExtent && t.clipExtent();
-                return t.scale(150).translate([0, 0]), null != i && t.clipExtent(null), Ly(n, t.stream(Ab)), e(Ab.result()), null != i && t.clipExtent(i), t
+                return t.scale(150).translate([0, 0]), null != i && t.clipExtent(null), Hy(n, t.stream(Nb)), e(Nb.result()), null != i && t.clipExtent(i), t
             }
 
-            function Vx(t, e, n) {
-                return Yx(t, (function(n) {
+            function r_(t, e, n) {
+                return i_(t, (function(n) {
                     var i = e[1][0] - e[0][0],
                         r = e[1][1] - e[0][1],
                         o = Math.min(i / (n[1][0] - n[0][0]), r / (n[1][1] - n[0][1])),
                         a = +e[0][0] + (i - o * (n[1][0] + n[0][0])) / 2,
                         s = +e[0][1] + (r - o * (n[1][1] + n[0][1])) / 2;
                     t.scale(150 * o).translate([a, s])
                 }), n)
             }
 
-            function Kx(t, e, n) {
-                return Vx(t, [
+            function o_(t, e, n) {
+                return r_(t, [
                     [0, 0], e
                 ], n)
             }
 
-            function Qx(t, e, n) {
-                return Yx(t, (function(n) {
+            function a_(t, e, n) {
+                return i_(t, (function(n) {
                     var i = +e,
                         r = i / (n[1][0] - n[0][0]),
                         o = (i - r * (n[1][0] + n[0][0])) / 2,
                         a = -r * n[0][1];
                     t.scale(150 * r).translate([o, a])
                 }), n)
             }
 
-            function t_(t, e, n) {
-                return Yx(t, (function(n) {
+            function s_(t, e, n) {
+                return i_(t, (function(n) {
                     var i = +e,
                         r = i / (n[1][1] - n[0][1]),
                         o = -r * n[0][0],
                         a = (i - r * (n[1][1] + n[0][1])) / 2;
                     t.scale(150 * r).translate([o, a])
                 }), n)
             }
-            Wx.invert = Wx, Zx.prototype = {
-                constructor: Zx,
+            Yx.invert = Yx, n_.prototype = {
+                constructor: n_,
                 point: function(t, e) {
                     this.stream.point(t, e)
                 },
                 sphere: function() {
                     this.stream.sphere()
                 },
                 lineStart: function() {
@@ -32130,37 +32267,37 @@
                 polygonStart: function() {
                     this.stream.polygonStart()
                 },
                 polygonEnd: function() {
                     this.stream.polygonEnd()
                 }
             };
-            var e_ = 16,
-                n_ = Yy(30 * Jy);
+            var c_ = 16,
+                l_ = ib(30 * Qy);
 
-            function i_(t, e) {
+            function u_(t, e) {
                 return +e ? function(t, e) {
                     function n(i, r, o, a, s, c, l, u, f, d, h, p, m, g) {
                         var v = l - i,
                             y = u - r,
                             b = v * v + y * y;
                         if (b > 4 * e && m--) {
                             var x = a + d,
                                 _ = s + h,
                                 w = c + p,
-                                k = rb(x * x + _ * _ + w * w),
-                                E = sb(w /= k),
-                                D = Gy(Gy(w) - 1) < By || Gy(o - f) < By ? (o + f) / 2 : Zy(_, x),
-                                A = t(D, E),
-                                S = A[0],
-                                C = A[1],
-                                F = S - i,
-                                M = C - r,
-                                O = y * F - v * M;
-                            (O * O / b > e || Gy((v * F + y * M) / b - .5) > .3 || a * d + s * h + c * p < n_) && (n(i, r, o, a, s, c, S, C, D, x /= k, _ /= k, w, m, g), g.point(S, C), n(S, C, D, x, _, w, l, u, f, d, h, p, m, g))
+                                k = fb(x * x + _ * _ + w * w),
+                                E = pb(w /= k),
+                                A = tb(tb(w) - 1) < Gy || tb(o - f) < Gy ? (o + f) / 2 : nb(_, x),
+                                D = t(A, E),
+                                S = D[0],
+                                C = D[1],
+                                M = S - i,
+                                F = C - r,
+                                O = y * M - v * F;
+                            (O * O / b > e || tb((v * M + y * F) / b - .5) > .3 || a * d + s * h + c * p < l_) && (n(i, r, o, a, s, c, S, C, A, x /= k, _ /= k, w, m, g), g.point(S, C), n(S, C, A, x, _, w, l, u, f, d, h, p, m, g))
                         }
                     }
                     return function(e) {
                         var i, r, o, a, s, c, l, u, f, d, h, p, m = {
                             point: g,
                             lineStart: v,
                             lineEnd: b,
@@ -32177,17 +32314,17 @@
                         }
 
                         function v() {
                             u = NaN, m.point = y, e.lineStart()
                         }
 
                         function y(i, r) {
-                            var o = Dx([i, r]),
+                            var o = Tx([i, r]),
                                 a = t(i, r);
-                            n(u, f, l, d, h, p, u = a[0], f = a[1], l = i, d = o[0], h = o[1], p = o[2], e_, e), e.point(u, f)
+                            n(u, f, l, d, h, p, u = a[0], f = a[1], l = i, d = o[0], h = o[1], p = o[2], c_, e), e.point(u, f)
                         }
 
                         function b() {
                             m.point = g, e.lineEnd()
                         }
 
                         function x() {
@@ -32195,43 +32332,43 @@
                         }
 
                         function _(t, e) {
                             y(i = t, e), r = u, o = f, a = d, s = h, c = p, m.point = y
                         }
 
                         function w() {
-                            n(u, f, l, d, h, p, r, o, i, a, s, c, e_, e), m.lineEnd = b, b()
+                            n(u, f, l, d, h, p, r, o, i, a, s, c, c_, e), m.lineEnd = b, b()
                         }
                         return m
                     }
                 }(t, e) : function(t) {
-                    return $x({
+                    return e_({
                         point: function(e, n) {
                             e = t(e, n), this.stream.point(e[0], e[1])
                         }
                     })
                 }(t)
             }
-            var r_ = $x({
+            var f_ = e_({
                 point: function(t, e) {
-                    this.stream.point(t * Jy, e * Jy)
+                    this.stream.point(t * Qy, e * Qy)
                 }
             });
 
-            function o_(t, e, n, i, r, o) {
+            function d_(t, e, n, i, r, o) {
                 if (!o) return function(t, e, n, i, r) {
                     function o(o, a) {
                         return [e + t * (o *= i), n - t * (a *= r)]
                     }
                     return o.invert = function(o, a) {
                         return [(o - e) / t * i, (n - a) / t * r]
                     }, o
                 }(t, e, n, i, r);
-                var a = Yy(o),
-                    s = nb(o),
+                var a = ib(o),
+                    s = lb(o),
                     c = a * t,
                     l = s * t,
                     u = a / t,
                     f = s / t,
                     d = (s * n - a * e) / t,
                     h = (s * e + a * n) / t;
 
@@ -32239,279 +32376,279 @@
                     return [c * (t *= i) - l * (o *= r) + e, n - l * t - c * o]
                 }
                 return p.invert = function(t, e) {
                     return [i * (u * t - f * e + d), r * (h - f * t - u * e)]
                 }, p
             }
 
-            function a_(t) {
-                return s_((function() {
+            function h_(t) {
+                return p_((function() {
                     return t
                 }))()
             }
 
-            function s_(t) {
+            function p_(t) {
                 var e, n, i, r, o, a, s, c, l, u, f = 150,
                     d = 480,
                     h = 250,
                     p = 0,
                     m = 0,
                     g = 0,
                     v = 0,
                     y = 0,
                     b = 0,
                     x = 1,
                     _ = 1,
                     w = null,
-                    k = Px,
+                    k = Wx,
                     E = null,
-                    D = Oy,
-                    A = .5;
+                    A = By,
+                    D = .5;
 
                 function S(t) {
-                    return c(t[0] * Jy, t[1] * Jy)
+                    return c(t[0] * Qy, t[1] * Qy)
                 }
 
                 function C(t) {
-                    return (t = c.invert(t[0], t[1])) && [t[0] * Xy, t[1] * Xy]
+                    return (t = c.invert(t[0], t[1])) && [t[0] * Ky, t[1] * Ky]
                 }
 
-                function F() {
-                    var t = o_(f, 0, 0, x, _, b).apply(null, e(p, m)),
-                        i = o_(f, d - t[0], h - t[1], x, _, b);
-                    return n = Hx(g, v, y), s = qx(e, i), c = qx(n, s), a = i_(s, A), M()
+                function M() {
+                    var t = d_(f, 0, 0, x, _, b).apply(null, e(p, m)),
+                        i = d_(f, d - t[0], h - t[1], x, _, b);
+                    return n = Vx(g, v, y), s = $x(e, i), c = $x(n, s), a = u_(s, D), F()
                 }
 
-                function M() {
+                function F() {
                     return l = u = null, S
                 }
                 return S.stream = function(t) {
-                        return l && u === t ? l : l = r_(function(t) {
-                            return $x({
+                        return l && u === t ? l : l = f_(function(t) {
+                            return e_({
                                 point: function(e, n) {
                                     var i = t(e, n);
                                     return this.stream.point(i[0], i[1])
                                 }
                             })
-                        }(n)(k(a(D(u = t)))))
+                        }(n)(k(a(A(u = t)))))
                     }, S.preclip = function(t) {
-                        return arguments.length ? (k = t, w = void 0, M()) : k
+                        return arguments.length ? (k = t, w = void 0, F()) : k
                     }, S.postclip = function(t) {
-                        return arguments.length ? (D = t, E = i = r = o = null, M()) : D
+                        return arguments.length ? (A = t, E = i = r = o = null, F()) : A
                     }, S.clipAngle = function(t) {
                         return arguments.length ? (k = +t ? function(t) {
-                            var e = Yy(t),
-                                n = 6 * Jy,
+                            var e = ib(t),
+                                n = 6 * Qy,
                                 i = e > 0,
-                                r = Gy(e) > By;
+                                r = tb(e) > Gy;
 
                             function o(t, n) {
-                                return Yy(t) * Yy(n) > e
+                                return ib(t) * ib(n) > e
                             }
 
                             function a(t, n, i) {
                                 var r = [1, 0, 0],
-                                    o = Sx(Dx(t), Dx(n)),
-                                    a = Ax(o, o),
+                                    o = Rx(Tx(t), Tx(n)),
+                                    a = Nx(o, o),
                                     s = o[0],
                                     c = a - s * s;
                                 if (!c) return !i && t;
                                 var l = e * a / c,
                                     u = -e * s / c,
-                                    f = Sx(r, o),
-                                    d = Fx(r, l);
-                                Cx(d, Fx(o, u));
+                                    f = Rx(r, o),
+                                    d = Px(r, l);
+                                zx(d, Px(o, u));
                                 var h = f,
-                                    p = Ax(d, h),
-                                    m = Ax(h, h),
-                                    g = p * p - m * (Ax(d, d) - 1);
+                                    p = Nx(d, h),
+                                    m = Nx(h, h),
+                                    g = p * p - m * (Nx(d, d) - 1);
                                 if (!(g < 0)) {
-                                    var v = rb(g),
-                                        y = Fx(h, (-p - v) / m);
-                                    if (Cx(y, d), y = Ex(y), !i) return y;
+                                    var v = fb(g),
+                                        y = Px(h, (-p - v) / m);
+                                    if (zx(y, d), y = Ox(y), !i) return y;
                                     var b, x = t[0],
                                         _ = n[0],
                                         w = t[1],
                                         k = n[1];
                                     _ < x && (b = x, x = _, _ = b);
                                     var E = _ - x,
-                                        D = Gy(E - Uy) < By;
-                                    if (!D && k < w && (b = w, w = k, k = b), D || E < By ? D ? w + k > 0 ^ y[1] < (Gy(y[0] - x) < By ? w : k) : w <= y[1] && y[1] <= k : E > Uy ^ (x <= y[0] && y[0] <= _)) {
-                                        var A = Fx(h, (-p + v) / m);
-                                        return Cx(A, d), [y, Ex(A)]
+                                        A = tb(E - Zy) < Gy;
+                                    if (!A && k < w && (b = w, w = k, k = b), A || E < Gy ? A ? w + k > 0 ^ y[1] < (tb(y[0] - x) < Gy ? w : k) : w <= y[1] && y[1] <= k : E > Zy ^ (x <= y[0] && y[0] <= _)) {
+                                        var D = Px(h, (-p + v) / m);
+                                        return zx(D, d), [y, Ox(D)]
                                     }
                                 }
                             }
 
                             function s(e, n) {
-                                var r = i ? t : Uy - t,
+                                var r = i ? t : Zy - t,
                                     o = 0;
                                 return e < -r ? o |= 1 : e > r && (o |= 2), n < -r ? o |= 4 : n > r && (o |= 8), o
                             }
-                            return Nx(o, (function(t) {
+                            return jx(o, (function(t) {
                                 var e, n, c, l, u;
                                 return {
                                     lineStart: function() {
                                         l = c = !1, u = 1
                                     },
                                     point: function(f, d) {
                                         var h, p = [f, d],
                                             m = o(f, d),
-                                            g = i ? m ? 0 : s(f, d) : m ? s(f + (f < 0 ? Uy : -Uy), d) : 0;
-                                        if (!e && (l = c = m) && t.lineStart(), m !== c && (!(h = a(e, p)) || xx(e, h) || xx(p, h)) && (p[2] = 1), m !== c) u = 0, m ? (t.lineStart(), h = a(p, e), t.point(h[0], h[1])) : (h = a(e, p), t.point(h[0], h[1], 2), t.lineEnd()), e = h;
+                                            g = i ? m ? 0 : s(f, d) : m ? s(f + (f < 0 ? Zy : -Zy), d) : 0;
+                                        if (!e && (l = c = m) && t.lineStart(), m !== c && (!(h = a(e, p)) || Sx(e, h) || Sx(p, h)) && (p[2] = 1), m !== c) u = 0, m ? (t.lineStart(), h = a(p, e), t.point(h[0], h[1])) : (h = a(e, p), t.point(h[0], h[1], 2), t.lineEnd()), e = h;
                                         else if (r && e && i ^ m) {
                                             var v;
                                             g & n || !(v = a(p, e, !0)) || (u = 0, i ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1], 3)))
-                                        }!m || e && xx(e, p) || t.point(p[0], p[1]), e = p, c = m, n = g
+                                        }!m || e && Sx(e, p) || t.point(p[0], p[1]), e = p, c = m, n = g
                                     },
                                     lineEnd: function() {
                                         c && t.lineEnd(), e = null
                                     },
                                     clean: function() {
                                         return u | (l && c) << 1
                                     }
                                 }
                             }), (function(e, i, r, o) {
-                                Lx(o, t, n, r, e, i)
-                            }), i ? [0, -t] : [-Uy, t - Uy])
-                        }(w = t * Jy) : (w = null, Px), M()) : w * Xy
+                                Hx(o, t, n, r, e, i)
+                            }), i ? [0, -t] : [-Zy, t - Zy])
+                        }(w = t * Qy) : (w = null, Wx), F()) : w * Ky
                     }, S.clipExtent = function(t) {
-                        return arguments.length ? (D = null == t ? (E = i = r = o = null, Oy) : Ux(E = +t[0][0], i = +t[0][1], r = +t[1][0], o = +t[1][1]), M()) : null == E ? null : [
+                        return arguments.length ? (A = null == t ? (E = i = r = o = null, By) : Zx(E = +t[0][0], i = +t[0][1], r = +t[1][0], o = +t[1][1]), F()) : null == E ? null : [
                             [E, i],
                             [r, o]
                         ]
                     }, S.scale = function(t) {
-                        return arguments.length ? (f = +t, F()) : f
+                        return arguments.length ? (f = +t, M()) : f
                     }, S.translate = function(t) {
-                        return arguments.length ? (d = +t[0], h = +t[1], F()) : [d, h]
+                        return arguments.length ? (d = +t[0], h = +t[1], M()) : [d, h]
                     }, S.center = function(t) {
-                        return arguments.length ? (p = t[0] % 360 * Jy, m = t[1] % 360 * Jy, F()) : [p * Xy, m * Xy]
+                        return arguments.length ? (p = t[0] % 360 * Qy, m = t[1] % 360 * Qy, M()) : [p * Ky, m * Ky]
                     }, S.rotate = function(t) {
-                        return arguments.length ? (g = t[0] % 360 * Jy, v = t[1] % 360 * Jy, y = t.length > 2 ? t[2] % 360 * Jy : 0, F()) : [g * Xy, v * Xy, y * Xy]
+                        return arguments.length ? (g = t[0] % 360 * Qy, v = t[1] % 360 * Qy, y = t.length > 2 ? t[2] % 360 * Qy : 0, M()) : [g * Ky, v * Ky, y * Ky]
                     }, S.angle = function(t) {
-                        return arguments.length ? (b = t % 360 * Jy, F()) : b * Xy
+                        return arguments.length ? (b = t % 360 * Qy, M()) : b * Ky
                     }, S.reflectX = function(t) {
-                        return arguments.length ? (x = t ? -1 : 1, F()) : x < 0
+                        return arguments.length ? (x = t ? -1 : 1, M()) : x < 0
                     }, S.reflectY = function(t) {
-                        return arguments.length ? (_ = t ? -1 : 1, F()) : _ < 0
+                        return arguments.length ? (_ = t ? -1 : 1, M()) : _ < 0
                     }, S.precision = function(t) {
-                        return arguments.length ? (a = i_(s, A = t * t), M()) : rb(A)
+                        return arguments.length ? (a = u_(s, D = t * t), F()) : fb(D)
                     }, S.fitExtent = function(t, e) {
-                        return Vx(S, t, e)
+                        return r_(S, t, e)
                     }, S.fitSize = function(t, e) {
-                        return Kx(S, t, e)
+                        return o_(S, t, e)
                     }, S.fitWidth = function(t, e) {
-                        return Qx(S, t, e)
+                        return a_(S, t, e)
                     }, S.fitHeight = function(t, e) {
-                        return t_(S, t, e)
+                        return s_(S, t, e)
                     },
                     function() {
-                        return e = t.apply(this, arguments), S.invert = e.invert && C, F()
+                        return e = t.apply(this, arguments), S.invert = e.invert && C, M()
                     }
             }
 
-            function c_(t) {
+            function m_(t) {
                 var e = 0,
-                    n = Uy / 3,
-                    i = s_(t),
+                    n = Zy / 3,
+                    i = p_(t),
                     r = i(e, n);
                 return r.parallels = function(t) {
-                    return arguments.length ? i(e = t[0] * Jy, n = t[1] * Jy) : [e * Xy, n * Xy]
+                    return arguments.length ? i(e = t[0] * Qy, n = t[1] * Qy) : [e * Ky, n * Ky]
                 }, r
             }
 
-            function l_(t, e) {
-                var n = nb(t),
-                    i = (n + nb(e)) / 2;
-                if (Gy(i) < By) return function(t) {
-                    var e = Yy(t);
+            function g_(t, e) {
+                var n = lb(t),
+                    i = (n + lb(e)) / 2;
+                if (tb(i) < Gy) return function(t) {
+                    var e = ib(t);
 
                     function n(t, n) {
-                        return [t * e, nb(n) / e]
+                        return [t * e, lb(n) / e]
                     }
                     return n.invert = function(t, n) {
-                        return [t / e, sb(n * e)]
+                        return [t / e, pb(n * e)]
                     }, n
                 }(t);
                 var r = 1 + n * (2 * i - n),
-                    o = rb(r) / i;
+                    o = fb(r) / i;
 
                 function a(t, e) {
-                    var n = rb(r - 2 * i * nb(e)) / i;
-                    return [n * nb(t *= i), o - n * Yy(t)]
+                    var n = fb(r - 2 * i * lb(e)) / i;
+                    return [n * lb(t *= i), o - n * ib(t)]
                 }
                 return a.invert = function(t, e) {
                     var n = o - e,
-                        a = Zy(t, Gy(n)) * ib(n);
-                    return n * i < 0 && (a -= Uy * ib(t) * ib(n)), [a / i, sb((r - (t * t + n * n) * i * i) / (2 * i))]
+                        a = nb(t, tb(n)) * ub(n);
+                    return n * i < 0 && (a -= Zy * ub(t) * ub(n)), [a / i, pb((r - (t * t + n * n) * i * i) / (2 * i))]
                 }, a
             }
 
-            function u_() {
-                return c_(l_).scale(155.424).center([0, 33.6442])
+            function v_() {
+                return m_(g_).scale(155.424).center([0, 33.6442])
             }
 
-            function f_() {
-                return u_().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7])
+            function y_() {
+                return v_().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7])
             }
 
-            function d_(t) {
+            function b_(t) {
                 return function(e, n) {
-                    var i = Yy(e),
-                        r = Yy(n),
+                    var i = ib(e),
+                        r = ib(n),
                         o = t(i * r);
-                    return o === 1 / 0 ? [2, 0] : [o * r * nb(e), o * nb(n)]
+                    return o === 1 / 0 ? [2, 0] : [o * r * lb(e), o * lb(n)]
                 }
             }
 
-            function h_(t) {
+            function x_(t) {
                 return function(e, n) {
-                    var i = rb(e * e + n * n),
+                    var i = fb(e * e + n * n),
                         r = t(i),
-                        o = nb(r),
-                        a = Yy(r);
-                    return [Zy(e * o, i * a), sb(i && n * o / i)]
+                        o = lb(r),
+                        a = ib(r);
+                    return [nb(e * o, i * a), pb(i && n * o / i)]
                 }
             }
-            var p_ = d_((function(t) {
-                return rb(2 / (1 + t))
+            var __ = b_((function(t) {
+                return fb(2 / (1 + t))
             }));
-            p_.invert = h_((function(t) {
-                return 2 * sb(t / 2)
+            __.invert = x_((function(t) {
+                return 2 * pb(t / 2)
             }));
-            var m_ = d_((function(t) {
-                return (t = ab(t)) && t / nb(t)
+            var w_ = b_((function(t) {
+                return (t = hb(t)) && t / lb(t)
             }));
 
-            function g_(t, e) {
-                return [t, tb(ob((qy + e) / 2))]
+            function k_(t, e) {
+                return [t, sb(db(($y + e) / 2))]
             }
 
-            function v_(t) {
-                var e, n, i, r = a_(t),
+            function E_(t) {
+                var e, n, i, r = h_(t),
                     o = r.center,
                     a = r.scale,
                     s = r.translate,
                     c = r.clipExtent,
                     l = null;
 
                 function u() {
-                    var o = Uy * a(),
+                    var o = Zy * a(),
                         s = r(function(t) {
                             function e(e) {
-                                return (e = t(e[0] * Jy, e[1] * Jy))[0] *= Xy, e[1] *= Xy, e
+                                return (e = t(e[0] * Qy, e[1] * Qy))[0] *= Ky, e[1] *= Ky, e
                             }
-                            return t = Hx(t[0] * Jy, t[1] * Jy, t.length > 2 ? t[2] * Jy : 0), e.invert = function(e) {
-                                return (e = t.invert(e[0] * Jy, e[1] * Jy))[0] *= Xy, e[1] *= Xy, e
+                            return t = Vx(t[0] * Qy, t[1] * Qy, t.length > 2 ? t[2] * Qy : 0), e.invert = function(e) {
+                                return (e = t.invert(e[0] * Qy, e[1] * Qy))[0] *= Ky, e[1] *= Ky, e
                             }, e
                         }(r.rotate()).invert([0, 0]));
                     return c(null == l ? [
                         [s[0] - o, s[1] - o],
                         [s[0] + o, s[1] + o]
-                    ] : t === g_ ? [
+                    ] : t === k_ ? [
                         [Math.max(s[0] - o, l), e],
                         [Math.min(s[0] + o, n), i]
                     ] : [
                         [l, Math.max(s[1] - o, e)],
                         [n, Math.min(s[1] + o, i)]
                     ])
                 }
@@ -32525,178 +32662,178 @@
                     return arguments.length ? (null == t ? l = e = n = i = null : (l = +t[0][0], e = +t[0][1], n = +t[1][0], i = +t[1][1]), u()) : null == l ? null : [
                         [l, e],
                         [n, i]
                     ]
                 }, u()
             }
 
-            function y_(t) {
-                return ob((qy + t) / 2)
+            function A_(t) {
+                return db(($y + t) / 2)
             }
 
-            function b_(t, e) {
-                var n = Yy(t),
-                    i = t === e ? nb(t) : tb(n / Yy(e)) / tb(y_(e) / y_(t)),
-                    r = n * eb(y_(t), i) / i;
-                if (!i) return g_;
+            function D_(t, e) {
+                var n = ib(t),
+                    i = t === e ? lb(t) : sb(n / ib(e)) / sb(A_(e) / A_(t)),
+                    r = n * cb(A_(t), i) / i;
+                if (!i) return k_;
 
                 function o(t, e) {
-                    r > 0 ? e < -qy + By && (e = -qy + By) : e > qy - By && (e = qy - By);
-                    var n = r / eb(y_(e), i);
-                    return [n * nb(i * t), r - n * Yy(i * t)]
+                    r > 0 ? e < -$y + Gy && (e = -$y + Gy) : e > $y - Gy && (e = $y - Gy);
+                    var n = r / cb(A_(e), i);
+                    return [n * lb(i * t), r - n * ib(i * t)]
                 }
                 return o.invert = function(t, e) {
                     var n = r - e,
-                        o = ib(i) * rb(t * t + n * n),
-                        a = Zy(t, Gy(n)) * ib(n);
-                    return n * i < 0 && (a -= Uy * ib(t) * ib(n)), [a / i, 2 * $y(eb(r / o, 1 / i)) - qy]
+                        o = ub(i) * fb(t * t + n * n),
+                        a = nb(t, tb(n)) * ub(n);
+                    return n * i < 0 && (a -= Zy * ub(t) * ub(n)), [a / i, 2 * eb(cb(r / o, 1 / i)) - $y]
                 }, o
             }
 
-            function x_(t, e) {
+            function S_(t, e) {
                 return [t, e]
             }
 
-            function __(t, e) {
-                var n = Yy(t),
-                    i = t === e ? nb(t) : (n - Yy(e)) / (e - t),
+            function C_(t, e) {
+                var n = ib(t),
+                    i = t === e ? lb(t) : (n - ib(e)) / (e - t),
                     r = n / i + t;
-                if (Gy(i) < By) return x_;
+                if (tb(i) < Gy) return S_;
 
                 function o(t, e) {
                     var n = r - e,
                         o = i * t;
-                    return [n * nb(o), r - n * Yy(o)]
+                    return [n * lb(o), r - n * ib(o)]
                 }
                 return o.invert = function(t, e) {
                     var n = r - e,
-                        o = Zy(t, Gy(n)) * ib(n);
-                    return n * i < 0 && (o -= Uy * ib(t) * ib(n)), [o / i, r - ib(i) * rb(t * t + n * n)]
+                        o = nb(t, tb(n)) * ub(n);
+                    return n * i < 0 && (o -= Zy * ub(t) * ub(n)), [o / i, r - ub(i) * fb(t * t + n * n)]
                 }, o
             }
-            m_.invert = h_((function(t) {
+            w_.invert = x_((function(t) {
                 return t
-            })), g_.invert = function(t, e) {
-                return [t, 2 * $y(Ky(e)) - qy]
-            }, x_.invert = x_;
-            var w_ = 1.340264,
-                k_ = -.081106,
-                E_ = 893e-6,
-                D_ = .003796,
-                A_ = rb(3) / 2;
+            })), k_.invert = function(t, e) {
+                return [t, 2 * eb(ob(e)) - $y]
+            }, S_.invert = S_;
+            var M_ = 1.340264,
+                F_ = -.081106,
+                O_ = 893e-6,
+                T_ = .003796,
+                N_ = fb(3) / 2;
 
-            function S_(t, e) {
-                var n = sb(A_ * nb(e)),
+            function R_(t, e) {
+                var n = pb(N_ * lb(e)),
                     i = n * n,
                     r = i * i * i;
-                return [t * Yy(n) / (A_ * (w_ + 3 * k_ * i + r * (7 * E_ + 9 * D_ * i))), n * (w_ + k_ * i + r * (E_ + D_ * i))]
+                return [t * ib(n) / (N_ * (M_ + 3 * F_ * i + r * (7 * O_ + 9 * T_ * i))), n * (M_ + F_ * i + r * (O_ + T_ * i))]
             }
 
-            function C_(t, e) {
-                var n = Yy(e),
-                    i = Yy(t) * n;
-                return [n * nb(t) / i, nb(e) / i]
+            function z_(t, e) {
+                var n = ib(e),
+                    i = ib(t) * n;
+                return [n * lb(t) / i, lb(e) / i]
             }
 
-            function F_(t, e) {
+            function P_(t, e) {
                 var n = e * e,
                     i = n * n;
                 return [t * (.8707 - .131979 * n + i * (i * (.003971 * n - .001529 * i) - .013791)), e * (1.007226 + n * (.015085 + i * (.028874 * n - .044475 - .005916 * i)))]
             }
 
-            function M_(t, e) {
-                return [Yy(e) * nb(t), nb(e)]
+            function L_(t, e) {
+                return [ib(e) * lb(t), lb(e)]
             }
 
-            function O_(t, e) {
-                var n = Yy(e),
-                    i = 1 + Yy(t) * n;
-                return [n * nb(t) / i, nb(e) / i]
+            function B_(t, e) {
+                var n = ib(e),
+                    i = 1 + ib(t) * n;
+                return [n * lb(t) / i, lb(e) / i]
             }
 
-            function T_(t, e) {
-                return [tb(ob((qy + e) / 2)), -t]
+            function I_(t, e) {
+                return [sb(db(($y + e) / 2)), -t]
             }
-            S_.invert = function(t, e) {
-                for (var n, i = e, r = i * i, o = r * r * r, a = 0; a < 12 && (o = (r = (i -= n = (i * (w_ + k_ * r + o * (E_ + D_ * r)) - e) / (w_ + 3 * k_ * r + o * (7 * E_ + 9 * D_ * r))) * i) * r * r, !(Gy(n) < Iy)); ++a);
-                return [A_ * t * (w_ + 3 * k_ * r + o * (7 * E_ + 9 * D_ * r)) / Yy(i), sb(nb(i) / A_)]
-            }, C_.invert = h_($y), F_.invert = function(t, e) {
+            R_.invert = function(t, e) {
+                for (var n, i = e, r = i * i, o = r * r * r, a = 0; a < 12 && (o = (r = (i -= n = (i * (M_ + F_ * r + o * (O_ + T_ * r)) - e) / (M_ + 3 * F_ * r + o * (7 * O_ + 9 * T_ * r))) * i) * r * r, !(tb(n) < Jy)); ++a);
+                return [N_ * t * (M_ + 3 * F_ * r + o * (7 * O_ + 9 * T_ * r)) / ib(i), pb(lb(i) / N_)]
+            }, z_.invert = x_(eb), P_.invert = function(t, e) {
                 var n, i = e,
                     r = 25;
                 do {
                     var o = i * i,
                         a = o * o;
                     i -= n = (i * (1.007226 + o * (.015085 + a * (.028874 * o - .044475 - .005916 * a))) - e) / (1.007226 + o * (.045255 + a * (.259866 * o - .311325 - .005916 * 11 * a)))
-                } while (Gy(n) > By && --r > 0);
+                } while (tb(n) > Gy && --r > 0);
                 return [t / (.8707 + (o = i * i) * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979)), i]
-            }, M_.invert = h_(sb), O_.invert = h_((function(t) {
-                return 2 * $y(t)
-            })), T_.invert = function(t, e) {
-                return [-e, 2 * $y(Ky(t)) - qy]
-            };
-            var N_ = Math.abs,
-                z_ = (Math.atan, Math.atan2, Math.ceil, Math.cos),
-                R_ = (Math.exp, Math.floor, Math.log, Math.max, Math.min, Math.pow, Math.round, Math.sign, Math.sin),
-                P_ = (Math.tan, 1e-6),
-                L_ = Math.PI,
-                j_ = L_ / 2,
-                B_ = (Math.SQRT1_2, U_(2));
-            U_(L_);
+            }, L_.invert = x_(pb), B_.invert = x_((function(t) {
+                return 2 * eb(t)
+            })), I_.invert = function(t, e) {
+                return [-e, 2 * eb(ob(t)) - $y]
+            };
+            var j_ = Math.abs,
+                U_ = (Math.atan, Math.atan2, Math.ceil, Math.cos),
+                q_ = (Math.exp, Math.floor, Math.log, Math.max, Math.min, Math.pow, Math.round, Math.sign, Math.sin),
+                W_ = (Math.tan, 1e-6),
+                H_ = Math.PI,
+                X_ = H_ / 2,
+                G_ = (Math.SQRT1_2, Z_(2));
+            Z_(H_);
 
-            function I_(t) {
-                return t > 1 ? j_ : t < -1 ? -j_ : Math.asin(t)
+            function J_(t) {
+                return t > 1 ? X_ : t < -1 ? -X_ : Math.asin(t)
             }
 
-            function U_(t) {
+            function Z_(t) {
                 return t > 0 ? Math.sqrt(t) : 0
             }
 
-            function q_(t, e) {
-                var n, i = t * R_(e),
+            function $_(t, e) {
+                var n, i = t * q_(e),
                     r = 30;
                 do {
-                    e -= n = (e + R_(e) - i) / (1 + z_(e))
-                } while (N_(n) > P_ && --r > 0);
+                    e -= n = (e + q_(e) - i) / (1 + U_(e))
+                } while (j_(n) > W_ && --r > 0);
                 return e / 2
             }
-            var W_ = function(t, e, n) {
+            var Y_ = function(t, e, n) {
                 function i(i, r) {
-                    return [t * i * z_(r = q_(n, r)), e * R_(r)]
+                    return [t * i * U_(r = $_(n, r)), e * q_(r)]
                 }
                 return i.invert = function(i, r) {
-                    return r = I_(r / e), [i / (t * z_(r)), I_((2 * r + R_(2 * r)) / n)]
+                    return r = J_(r / e), [i / (t * U_(r)), J_((2 * r + q_(2 * r)) / n)]
                 }, i
-            }(B_ / j_, B_, L_);
-            const H_ = yx(),
-                X_ = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "parallels", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
+            }(G_ / X_, G_, H_);
+            const V_ = Ax(),
+                K_ = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "parallels", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
 
-            function J_(t, e) {
+            function Q_(t, e) {
                 if (!t || "string" !== typeof t) throw new Error("Projection type must be a name string.");
-                return t = t.toLowerCase(), arguments.length > 1 ? ($_[t] = function(t, e) {
+                return t = t.toLowerCase(), arguments.length > 1 ? (ew[t] = function(t, e) {
                     return function n() {
                         const i = e();
-                        return i.type = t, i.path = yx().projection(i), i.copy = i.copy || function() {
+                        return i.type = t, i.path = Ax().projection(i), i.copy = i.copy || function() {
                             const t = n();
-                            return X_.forEach((e => {
+                            return K_.forEach((e => {
                                 i[e] && t[e](i[e]())
                             })), t.path.pointRadius(i.path.pointRadius()), t
-                        }, of(i)
+                        }, Cf(i)
                     }
-                }(t, e), this) : $_[t] || null
+                }(t, e), this) : ew[t] || null
             }
 
-            function G_(t) {
-                return t && t.path || H_
+            function tw(t) {
+                return t && t.path || V_
             }
-            const $_ = {
-                albers: f_,
+            const ew = {
+                albers: y_,
                 albersusa: function() {
-                    var t, e, n, i, r, o, a = f_(),
-                        s = u_().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
-                        c = u_().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
+                    var t, e, n, i, r, o, a = y_(),
+                        s = v_().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
+                        c = v_().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
                         l = {
                             point: function(t, e) {
                                 o = [t, e]
                             }
                         };
 
                     function u(t) {
@@ -32747,69 +32884,69 @@
                         var e = a.scale(),
                             o = +t[0],
                             u = +t[1];
                         return n = a.translate(t).clipExtent([
                             [o - .455 * e, u - .238 * e],
                             [o + .455 * e, u + .238 * e]
                         ]).stream(l), i = s.translate([o - .307 * e, u + .201 * e]).clipExtent([
-                            [o - .425 * e + By, u + .12 * e + By],
-                            [o - .214 * e - By, u + .234 * e - By]
+                            [o - .425 * e + Gy, u + .12 * e + Gy],
+                            [o - .214 * e - Gy, u + .234 * e - Gy]
                         ]).stream(l), r = c.translate([o - .205 * e, u + .212 * e]).clipExtent([
-                            [o - .214 * e + By, u + .166 * e + By],
-                            [o - .115 * e - By, u + .234 * e - By]
+                            [o - .214 * e + Gy, u + .166 * e + Gy],
+                            [o - .115 * e - Gy, u + .234 * e - Gy]
                         ]).stream(l), f()
                     }, u.fitExtent = function(t, e) {
-                        return Vx(u, t, e)
+                        return r_(u, t, e)
                     }, u.fitSize = function(t, e) {
-                        return Kx(u, t, e)
+                        return o_(u, t, e)
                     }, u.fitWidth = function(t, e) {
-                        return Qx(u, t, e)
+                        return a_(u, t, e)
                     }, u.fitHeight = function(t, e) {
-                        return t_(u, t, e)
+                        return s_(u, t, e)
                     }, u.scale(1070)
                 },
                 azimuthalequalarea: function() {
-                    return a_(p_).scale(124.75).clipAngle(179.999)
+                    return h_(__).scale(124.75).clipAngle(179.999)
                 },
                 azimuthalequidistant: function() {
-                    return a_(m_).scale(79.4188).clipAngle(179.999)
+                    return h_(w_).scale(79.4188).clipAngle(179.999)
                 },
                 conicconformal: function() {
-                    return c_(b_).scale(109.5).parallels([30, 30])
+                    return m_(D_).scale(109.5).parallels([30, 30])
                 },
-                conicequalarea: u_,
+                conicequalarea: v_,
                 conicequidistant: function() {
-                    return c_(__).scale(131.154).center([0, 13.9389])
+                    return m_(C_).scale(131.154).center([0, 13.9389])
                 },
                 equalEarth: function() {
-                    return a_(S_).scale(177.158)
+                    return h_(R_).scale(177.158)
                 },
                 equirectangular: function() {
-                    return a_(x_).scale(152.63)
+                    return h_(S_).scale(152.63)
                 },
                 gnomonic: function() {
-                    return a_(C_).scale(144.049).clipAngle(60)
+                    return h_(z_).scale(144.049).clipAngle(60)
                 },
                 identity: function() {
                     var t, e, n, i, r, o, a, s = 1,
                         c = 0,
                         l = 0,
                         u = 1,
                         f = 1,
                         d = 0,
                         h = null,
                         p = 1,
                         m = 1,
-                        g = $x({
+                        g = e_({
                             point: function(t, e) {
                                 var n = b([t, e]);
                                 this.stream.point(n[0], n[1])
                             }
                         }),
-                        v = Oy;
+                        v = By;
 
                     function y() {
                         return p = s * u, m = s * f, o = a = null, b
                     }
 
                     function b(n) {
                         var i = n[0] * p,
@@ -32829,103 +32966,103 @@
                         }
                         return [i / p, r / m]
                     }, b.stream = function(t) {
                         return o && a === t ? o : o = g(v(a = t))
                     }, b.postclip = function(t) {
                         return arguments.length ? (v = t, h = n = i = r = null, y()) : v
                     }, b.clipExtent = function(t) {
-                        return arguments.length ? (v = null == t ? (h = n = i = r = null, Oy) : Ux(h = +t[0][0], n = +t[0][1], i = +t[1][0], r = +t[1][1]), y()) : null == h ? null : [
+                        return arguments.length ? (v = null == t ? (h = n = i = r = null, By) : Zx(h = +t[0][0], n = +t[0][1], i = +t[1][0], r = +t[1][1]), y()) : null == h ? null : [
                             [h, n],
                             [i, r]
                         ]
                     }, b.scale = function(t) {
                         return arguments.length ? (s = +t, y()) : s
                     }, b.translate = function(t) {
                         return arguments.length ? (c = +t[0], l = +t[1], y()) : [c, l]
                     }, b.angle = function(n) {
-                        return arguments.length ? (e = nb(d = n % 360 * Jy), t = Yy(d), y()) : d * Xy
+                        return arguments.length ? (e = lb(d = n % 360 * Qy), t = ib(d), y()) : d * Ky
                     }, b.reflectX = function(t) {
                         return arguments.length ? (u = t ? -1 : 1, y()) : u < 0
                     }, b.reflectY = function(t) {
                         return arguments.length ? (f = t ? -1 : 1, y()) : f < 0
                     }, b.fitExtent = function(t, e) {
-                        return Vx(b, t, e)
+                        return r_(b, t, e)
                     }, b.fitSize = function(t, e) {
-                        return Kx(b, t, e)
+                        return o_(b, t, e)
                     }, b.fitWidth = function(t, e) {
-                        return Qx(b, t, e)
+                        return a_(b, t, e)
                     }, b.fitHeight = function(t, e) {
-                        return t_(b, t, e)
+                        return s_(b, t, e)
                     }, b
                 },
                 mercator: function() {
-                    return v_(g_).scale(961 / Hy)
+                    return E_(k_).scale(961 / Vy)
                 },
                 mollweide: function() {
-                    return a_(W_).scale(169.529)
+                    return h_(Y_).scale(169.529)
                 },
                 naturalEarth1: function() {
-                    return a_(F_).scale(175.295)
+                    return h_(P_).scale(175.295)
                 },
                 orthographic: function() {
-                    return a_(M_).scale(249.5).clipAngle(90 + By)
+                    return h_(L_).scale(249.5).clipAngle(90 + Gy)
                 },
                 stereographic: function() {
-                    return a_(O_).scale(250).clipAngle(142)
+                    return h_(B_).scale(250).clipAngle(142)
                 },
                 transversemercator: function() {
-                    var t = v_(T_),
+                    var t = E_(I_),
                         e = t.center,
                         n = t.rotate;
                     return t.center = function(t) {
                         return arguments.length ? e([-t[1], t[0]]) : [(t = e())[1], -t[0]]
                     }, t.rotate = function(t) {
                         return arguments.length ? n([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = n())[0], t[1], t[2] - 90]
                     }, n([0, 0, 90]).scale(159.155)
                 }
             };
-            for (const GN in $_) J_(GN, $_[GN]);
+            for (const _q in ew) Q_(_q, ew[_q]);
 
-            function Z_(t, e, n) {
-                var i = (0, Wo.Z)(t, e - By, n).concat(e);
+            function nw(t, e, n) {
+                var i = (0, Wo.Z)(t, e - Gy, n).concat(e);
                 return function(t) {
                     return i.map((function(e) {
                         return [t, e]
                     }))
                 }
             }
 
-            function Y_(t, e, n) {
-                var i = (0, Wo.Z)(t, e - By, n).concat(e);
+            function iw(t, e, n) {
+                var i = (0, Wo.Z)(t, e - Gy, n).concat(e);
                 return function(t) {
                     return i.map((function(e) {
                         return [e, t]
                     }))
                 }
             }
 
-            function V_() {
+            function rw() {
                 var t, e, n, i, r, o, a, s, c, l, u, f, d = 10,
                     h = d,
                     p = 90,
                     m = 360,
                     g = 2.5;
 
                 function v() {
                     return {
                         type: "MultiLineString",
                         coordinates: y()
                     }
                 }
 
                 function y() {
-                    return (0, Wo.Z)(Vy(i / p) * p, n, p).map(u).concat((0, Wo.Z)(Vy(s / m) * m, a, m).map(f)).concat((0, Wo.Z)(Vy(e / d) * d, t, d).filter((function(t) {
-                        return Gy(t % p) > By
-                    })).map(c)).concat((0, Wo.Z)(Vy(o / h) * h, r, h).filter((function(t) {
-                        return Gy(t % m) > By
+                    return (0, Wo.Z)(rb(i / p) * p, n, p).map(u).concat((0, Wo.Z)(rb(s / m) * m, a, m).map(f)).concat((0, Wo.Z)(rb(e / d) * d, t, d).filter((function(t) {
+                        return tb(t % p) > Gy
+                    })).map(c)).concat((0, Wo.Z)(rb(o / h) * h, r, h).filter((function(t) {
+                        return tb(t % m) > Gy
                     })).map(l))
                 }
                 return v.lines = function() {
                     return y().map((function(t) {
                         return {
                             type: "LineString",
                             coordinates: t
@@ -32951,26 +33088,26 @@
                 }, v.step = function(t) {
                     return arguments.length ? v.stepMajor(t).stepMinor(t) : v.stepMinor()
                 }, v.stepMajor = function(t) {
                     return arguments.length ? (p = +t[0], m = +t[1], v) : [p, m]
                 }, v.stepMinor = function(t) {
                     return arguments.length ? (d = +t[0], h = +t[1], v) : [d, h]
                 }, v.precision = function(d) {
-                    return arguments.length ? (g = +d, c = Z_(o, r, 90), l = Y_(e, t, g), u = Z_(s, a, 90), f = Y_(i, n, g), v) : g
+                    return arguments.length ? (g = +d, c = nw(o, r, 90), l = iw(e, t, g), u = nw(s, a, 90), f = iw(i, n, g), v) : g
                 }, v.extentMajor([
-                    [-180, -90 + By],
-                    [180, 90 - By]
+                    [-180, -90 + Gy],
+                    [180, 90 - Gy]
                 ]).extentMinor([
-                    [-180, -80 - By],
-                    [180, 80 + By]
+                    [-180, -80 - Gy],
+                    [180, 80 + Gy]
                 ])
             }
 
-            function K_() {}
-            const Q_ = [
+            function ow() {}
+            const aw = [
                 [],
                 [
                     [
                         [1, 1.5],
                         [.5, 1]
                     ]
                 ],
@@ -33059,38 +33196,38 @@
                         [.5, 1],
                         [1, 1.5]
                     ]
                 ],
                 []
             ];
 
-            function tw() {
+            function sw() {
                 var t = 1,
                     e = 1,
                     n = a;
 
                 function i(t, e) {
                     return e.map((e => r(t, e)))
                 }
 
                 function r(i, r) {
                     var a = [],
                         s = [];
                     return function(n, i, r) {
                         var a, s, c, l, u, f, d = new Array,
                             h = new Array;
-                        a = s = -1, l = n[0] >= i, Q_[l << 1].forEach(p);
-                        for (; ++a < t - 1;) c = l, l = n[a + 1] >= i, Q_[c | l << 1].forEach(p);
-                        Q_[l | 0].forEach(p);
+                        a = s = -1, l = n[0] >= i, aw[l << 1].forEach(p);
+                        for (; ++a < t - 1;) c = l, l = n[a + 1] >= i, aw[c | l << 1].forEach(p);
+                        aw[l | 0].forEach(p);
                         for (; ++s < e - 1;) {
-                            for (a = -1, l = n[s * t + t] >= i, u = n[s * t] >= i, Q_[l << 1 | u << 2].forEach(p); ++a < t - 1;) c = l, l = n[s * t + t + a + 1] >= i, f = u, u = n[s * t + a + 1] >= i, Q_[c | l << 1 | u << 2 | f << 3].forEach(p);
-                            Q_[l | u << 3].forEach(p)
+                            for (a = -1, l = n[s * t + t] >= i, u = n[s * t] >= i, aw[l << 1 | u << 2].forEach(p); ++a < t - 1;) c = l, l = n[s * t + t + a + 1] >= i, f = u, u = n[s * t + a + 1] >= i, aw[c | l << 1 | u << 2 | f << 3].forEach(p);
+                            aw[l | u << 3].forEach(p)
                         }
-                        a = -1, u = n[s * t] >= i, Q_[u << 2].forEach(p);
-                        for (; ++a < t - 1;) f = u, u = n[s * t + a + 1] >= i, Q_[u << 2 | f << 3].forEach(p);
+                        a = -1, u = n[s * t] >= i, aw[u << 2].forEach(p);
+                        for (; ++a < t - 1;) f = u, u = n[s * t + a + 1] >= i, aw[u << 2 | f << 3].forEach(p);
 
                         function p(t) {
                             var e, n, i = [t[0][0] + a, t[0][1] + s],
                                 c = [t[1][0] + a, t[1][1] + s],
                                 l = o(i),
                                 u = o(c);
                             (e = h[l]) ? (n = d[u]) ? (delete h[e.end], delete d[n.start], e === n ? (e.ring.push(c), r(e.ring)) : d[e.start] = h[n.end] = {
@@ -33103,27 +33240,27 @@
                                 ring: n.ring.concat(e.ring)
                             }) : (delete d[e.start], e.ring.unshift(i), d[e.start = l] = e) : d[l] = h[u] = {
                                 start: l,
                                 end: u,
                                 ring: [i, c]
                             }
                         }
-                        Q_[u << 3].forEach(p)
+                        aw[u << 3].forEach(p)
                     }(i, r, (t => {
                         n(t, i, r),
                             function(t) {
                                 var e = 0,
                                     n = t.length,
                                     i = t[n - 1][1] * t[0][0] - t[n - 1][0] * t[0][1];
                                 for (; ++e < n;) i += t[e - 1][1] * t[e][0] - t[e - 1][0] * t[e][1];
                                 return i
                             }(t) > 0 ? a.push([t]) : s.push(t)
                     })), s.forEach((t => {
                         for (var e, n = 0, i = a.length; n < i; ++n)
-                            if (-1 !== ew((e = a[n])[0], t)) return void e.push(t)
+                            if (-1 !== cw((e = a[n])[0], t)) return void e.push(t)
                     })), {
                         type: "MultiPolygon",
                         value: r,
                         coordinates: a
                     }
                 }
 
@@ -33143,61 +33280,61 @@
                 }
                 return i.contour = r, i.size = function(n) {
                     if (!arguments.length) return [t, e];
                     var r = Math.floor(n[0]),
                         o = Math.floor(n[1]);
                     return r >= 0 && o >= 0 || (0, m.vU)("invalid size"), t = r, e = o, i
                 }, i.smooth = function(t) {
-                    return arguments.length ? (n = t ? a : K_, i) : n === a
+                    return arguments.length ? (n = t ? a : ow, i) : n === a
                 }, i
             }
 
-            function ew(t, e) {
+            function cw(t, e) {
                 for (var n, i = -1, r = e.length; ++i < r;)
-                    if (n = nw(t, e[i])) return n;
+                    if (n = lw(t, e[i])) return n;
                 return 0
             }
 
-            function nw(t, e) {
+            function lw(t, e) {
                 for (var n = e[0], i = e[1], r = -1, o = 0, a = t.length, s = a - 1; o < a; s = o++) {
                     var c = t[o],
                         l = c[0],
                         u = c[1],
                         f = t[s],
                         d = f[0],
                         h = f[1];
-                    if (iw(c, f, e)) return 0;
+                    if (uw(c, f, e)) return 0;
                     u > i !== h > i && n < (d - l) * (i - u) / (h - u) + l && (r = -r)
                 }
                 return r
             }
 
-            function iw(t, e, n) {
+            function uw(t, e, n) {
                 var i, r, o, a;
                 return function(t, e, n) {
                     return (e[0] - t[0]) * (n[1] - t[1]) === (n[0] - t[0]) * (e[1] - t[1])
                 }(t, e, n) && (r = t[i = +(t[0] === e[0])], o = n[i], a = e[i], r <= o && o <= a || a <= o && o <= r)
             }
 
-            function rw(t, e, n) {
+            function fw(t, e, n) {
                 return function(i) {
                     var r = (0, m.We)(i),
                         o = n ? Math.min(r[0], 0) : r[0],
                         a = r[1],
                         s = a - o,
                         c = e ? (0, N.ly)(o, a, t) : s / (t + 1);
                     return (0, Wo.Z)(o + c, a, c)
                 }
             }
 
-            function ow(t) {
-                Rr.call(this, null, t)
+            function dw(t) {
+                zr.call(this, null, t)
             }
 
-            function aw(t, e, n, i, r) {
+            function hw(t, e, n, i, r) {
                 const o = t.x1 || 0,
                     a = t.y1 || 0,
                     s = e * n < 0;
 
                 function c(t) {
                     t.forEach(l)
                 }
@@ -33210,94 +33347,94 @@
                     t[0] = (t[0] - o) * e + i, t[1] = (t[1] - a) * n + r
                 }
                 return function(t) {
                     return t.coordinates.forEach(c), t
                 }
             }
 
-            function sw(t, e, n) {
-                const i = t >= 0 ? t : Jr(e, n);
+            function pw(t, e, n) {
+                const i = t >= 0 ? t : Gr(e, n);
                 return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2)
             }
 
-            function cw(t) {
+            function mw(t) {
                 return (0, m.mf)(t) ? t : (0, m.a9)(+t)
             }
 
-            function lw() {
+            function gw() {
                 var t = t => t[0],
                     e = t => t[1],
                     n = m.kX,
                     i = [-1, -1],
                     r = 960,
                     o = 500,
                     a = 2;
 
                 function s(s, c) {
-                    const l = sw(i[0], s, t) >> a,
-                        u = sw(i[1], s, e) >> a,
+                    const l = pw(i[0], s, t) >> a,
+                        u = pw(i[1], s, e) >> a,
                         f = l ? l + 2 : 0,
                         d = u ? u + 2 : 0,
                         h = 2 * f + (r >> a),
                         p = 2 * d + (o >> a),
                         m = new Float32Array(h * p),
                         g = new Float32Array(h * p);
                     let v = m;
                     s.forEach((i => {
                         const r = f + (+t(i) >> a),
                             o = d + (+e(i) >> a);
                         r >= 0 && r < h && o >= 0 && o < p && (m[r + o * h] += +n(i))
-                    })), l > 0 && u > 0 ? (uw(h, p, m, g, l), fw(h, p, g, m, u), uw(h, p, m, g, l), fw(h, p, g, m, u), uw(h, p, m, g, l), fw(h, p, g, m, u)) : l > 0 ? (uw(h, p, m, g, l), uw(h, p, g, m, l), uw(h, p, m, g, l), v = g) : u > 0 && (fw(h, p, m, g, u), fw(h, p, g, m, u), fw(h, p, m, g, u), v = g);
-                    const y = c ? Math.pow(2, -2 * a) : 1 / Qv(v);
+                    })), l > 0 && u > 0 ? (vw(h, p, m, g, l), yw(h, p, g, m, u), vw(h, p, m, g, l), yw(h, p, g, m, u), vw(h, p, m, g, l), yw(h, p, g, m, u)) : l > 0 ? (vw(h, p, m, g, l), vw(h, p, g, m, l), vw(h, p, m, g, l), v = g) : u > 0 && (yw(h, p, m, g, u), yw(h, p, g, m, u), yw(h, p, m, g, u), v = g);
+                    const y = c ? Math.pow(2, -2 * a) : 1 / ay(v);
                     for (let t = 0, e = h * p; t < e; ++t) v[t] *= y;
                     return {
                         values: v,
                         scale: 1 << a,
                         width: h,
                         height: p,
                         x1: f,
                         y1: d,
                         x2: f + (r >> a),
                         y2: d + (o >> a)
                     }
                 }
                 return s.x = function(e) {
-                    return arguments.length ? (t = cw(e), s) : t
+                    return arguments.length ? (t = mw(e), s) : t
                 }, s.y = function(t) {
-                    return arguments.length ? (e = cw(t), s) : e
+                    return arguments.length ? (e = mw(t), s) : e
                 }, s.weight = function(t) {
-                    return arguments.length ? (n = cw(t), s) : n
+                    return arguments.length ? (n = mw(t), s) : n
                 }, s.size = function(t) {
                     if (!arguments.length) return [r, o];
                     var e = +t[0],
                         n = +t[1];
                     return e >= 0 && n >= 0 || (0, m.vU)("invalid size"), r = e, o = n, s
                 }, s.cellSize = function(t) {
                     return arguments.length ? ((t = +t) >= 1 || (0, m.vU)("invalid cell size"), a = Math.floor(Math.log(t) / Math.LN2), s) : 1 << a
                 }, s.bandwidth = function(t) {
                     return arguments.length ? (1 === (t = (0, m.IX)(t)).length && (t = [+t[0], +t[0]]), 2 !== t.length && (0, m.vU)("invalid bandwidth"), i = t, s) : i
                 }, s
             }
 
-            function uw(t, e, n, i, r) {
+            function vw(t, e, n, i, r) {
                 const o = 1 + (r << 1);
                 for (let a = 0; a < e; ++a)
                     for (let e = 0, s = 0; e < t + r; ++e) e < t && (s += n[e + a * t]), e >= r && (e >= o && (s -= n[e - o + a * t]), i[e - r + a * t] = s / Math.min(e + 1, t - 1 + o - e, o))
             }
 
-            function fw(t, e, n, i, r) {
+            function yw(t, e, n, i, r) {
                 const o = 1 + (r << 1);
                 for (let a = 0; a < t; ++a)
                     for (let s = 0, c = 0; s < e + r; ++s) s < e && (c += n[a + s * t]), s >= r && (s >= o && (c -= n[a + (s - o) * t]), i[a + (s - r) * t] = c / Math.min(s + 1, e - 1 + o - s, o))
             }
 
-            function dw(t) {
-                Rr.call(this, null, t)
+            function bw(t) {
+                zr.call(this, null, t)
             }
-            ow.Definition = {
+            dw.Definition = {
                 type: "Isocontour",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "field",
                     type: "field"
@@ -33336,23 +33473,23 @@
                     expr: !0
                 }, {
                     name: "as",
                     type: "string",
                     null: !0,
                     default: "contour"
                 }]
-            }, (0, m.XW)(ow, Rr, {
+            }, (0, m.XW)(dw, zr, {
                 transform(t, e) {
                     if (this.value && !e.changed() && !t.modified()) return e.StopPropagation;
                     var n = e.fork(e.NO_SOURCE | e.NO_FIELDS),
                         i = e.materialize(e.SOURCE).source,
                         r = t.field || m.yR,
-                        o = tw().smooth(!1 !== t.smooth),
+                        o = sw().smooth(!1 !== t.smooth),
                         a = t.thresholds || function(t, e, n) {
-                            const i = rw(n.levels || 10, n.nice, !1 !== n.zero);
+                            const i = fw(n.levels || 10, n.nice, !1 !== n.zero);
                             return "shared" !== n.resolve ? i : i(t.map((t => (0, qo.Z)(e(t).values))))
                         }(i, r, t),
                         s = null === t.as ? null : t.as || "contour",
                         c = [];
                     return i.forEach((e => {
                         const n = r(e),
                             i = o.size([n.width, n.height])(n.values, (0, m.kJ)(a) ? a : a(n.values));
@@ -33362,23 +33499,23 @@
                             (0, m.mf)(r) && (r = r(n, i));
                             (0, m.mf)(o) && (o = o(n, i));
                             if ((1 === r || null == r) && !o) return;
                             const a = ((0, m.hj)(r) ? r : r[0]) || 1,
                                 s = ((0, m.hj)(r) ? r : r[1]) || 1,
                                 c = o && o[0] || 0,
                                 l = o && o[1] || 0;
-                            t.forEach(aw(e, a, s, c, l))
+                            t.forEach(hw(e, a, s, c, l))
                         }(i, n, e, t), i.forEach((t => {
                             c.push(ar(e, rr(null != s ? {
                                 [s]: t
                             } : t)))
                         }))
                     })), this.value && (n.rem = this.value), this.value = n.source = n.add = c, n
                 }
-            }), dw.Definition = {
+            }), bw.Definition = {
                 type: "KDE2D",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "size",
                     type: "number",
@@ -33414,45 +33551,45 @@
                     default: !1
                 }, {
                     name: "as",
                     type: "string",
                     default: "grid"
                 }]
             };
-            const hw = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
+            const xw = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
 
-            function pw(t, e) {
-                return hw.forEach((n => null != e[n] ? t[n](e[n]) : 0)), t
+            function _w(t, e) {
+                return xw.forEach((n => null != e[n] ? t[n](e[n]) : 0)), t
             }
 
-            function mw(t) {
-                Rr.call(this, null, t)
-            }(0, m.XW)(dw, Rr, {
+            function ww(t) {
+                zr.call(this, null, t)
+            }(0, m.XW)(bw, zr, {
                 transform(t, e) {
                     if (this.value && !e.changed() && !t.modified()) return e.StopPropagation;
                     var n, i = e.fork(e.NO_SOURCE | e.NO_FIELDS),
                         r = function(t, e) {
                             var n, i, r, o, a, s, c = [],
                                 l = t => t(o);
                             if (null == e) c.push(t);
                             else
                                 for (n = {}, i = 0, r = t.length; i < r; ++i) o = t[i], (s = n[a = e.map(l)]) || (n[a] = s = [], s.dims = a, c.push(s)), s.push(o);
                             return c
                         }(e.materialize(e.SOURCE).source, t.groupby),
                         o = (t.groupby || []).map(m.el),
-                        a = pw(lw(), t),
+                        a = _w(gw(), t),
                         s = t.as || "grid";
                     return n = r.map((e => rr(function(t, e) {
                         for (let n = 0; n < o.length; ++n) t[o[n]] = e[n];
                         return t
                     }({
                         [s]: a(e, t.counts)
                     }, e.dims)))), this.value && (i.rem = this.value), this.value = i.source = i.add = n, i
                 }
-            }), mw.Definition = {
+            }), ww.Definition = {
                 type: "Contour",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "size",
                     type: "number",
@@ -33490,67 +33627,67 @@
                     type: "number",
                     array: !0
                 }, {
                     name: "smooth",
                     type: "boolean",
                     default: !0
                 }]
-            }, (0, m.XW)(mw, Rr, {
+            }, (0, m.XW)(ww, zr, {
                 transform(t, e) {
                     if (this.value && !e.changed() && !t.modified()) return e.StopPropagation;
                     var n, i, r = e.fork(e.NO_SOURCE | e.NO_FIELDS),
-                        o = tw().smooth(!1 !== t.smooth),
+                        o = sw().smooth(!1 !== t.smooth),
                         a = t.values,
-                        s = t.thresholds || rw(t.count || 10, t.nice, !!a),
+                        s = t.thresholds || fw(t.count || 10, t.nice, !!a),
                         c = t.size;
-                    return a || (a = e.materialize(e.SOURCE).source, i = aw(n = pw(lw(), t)(a, !0), n.scale || 1, n.scale || 1, 0, 0), c = [n.width, n.height], a = n.values), s = (0, m.kJ)(s) ? s : s(a), a = o.size(c)(a, s), i && a.forEach(i), this.value && (r.rem = this.value), this.value = r.source = r.add = (a || []).map(rr), r
+                    return a || (a = e.materialize(e.SOURCE).source, i = hw(n = _w(gw(), t)(a, !0), n.scale || 1, n.scale || 1, 0, 0), c = [n.width, n.height], a = n.values), s = (0, m.kJ)(s) ? s : s(a), a = o.size(c)(a, s), i && a.forEach(i), this.value && (r.rem = this.value), this.value = r.source = r.add = (a || []).map(rr), r
                 }
             });
-            const gw = "Feature",
-                vw = "FeatureCollection";
+            const kw = "Feature",
+                Ew = "FeatureCollection";
 
-            function yw(t) {
-                Rr.call(this, null, t)
+            function Aw(t) {
+                zr.call(this, null, t)
             }
 
-            function bw(t) {
-                Rr.call(this, null, t)
+            function Dw(t) {
+                zr.call(this, null, t)
             }
 
-            function xw(t) {
-                Rr.call(this, null, t)
+            function Sw(t) {
+                zr.call(this, null, t)
             }
 
-            function _w(t) {
-                Rr.call(this, null, t)
+            function Cw(t) {
+                zr.call(this, null, t)
             }
 
-            function ww(t) {
-                Rr.call(this, [], t), this.generator = V_()
+            function Mw(t) {
+                zr.call(this, [], t), this.generator = rw()
             }
 
-            function kw(t) {
-                Rr.call(this, null, t)
+            function Fw(t) {
+                zr.call(this, null, t)
             }
 
-            function Ew(t) {
+            function Ow(t) {
                 if (!(0, m.mf)(t)) return !1;
                 const e = (0, m.Rg)((0, m.Oj)(t));
                 return e.$x || e.$y || e.$value || e.$max
             }
 
-            function Dw(t) {
-                Rr.call(this, null, t), this.modified(!0)
+            function Tw(t) {
+                zr.call(this, null, t), this.modified(!0)
             }
 
-            function Aw(t, e, n) {
+            function Nw(t, e, n) {
                 (0, m.mf)(t[e]) && t[e](n)
             }
 
-            function Sw(t, e, n, i) {
+            function Rw(t, e, n, i) {
                 if (isNaN(e) || isNaN(n)) return t;
                 var r, o, a, s, c, l, u, f, d, h = t._root,
                     p = {
                         data: i
                     },
                     m = t._x0,
                     g = t._y0,
@@ -33562,80 +33699,80 @@
                 if (s = +t._x.call(null, h.data), c = +t._y.call(null, h.data), e === s && n === c) return p.next = h, r ? r[f] = p : t._root = p, t;
                 do {
                     r = r ? r[f] = new Array(4) : t._root = new Array(4), (l = e >= (o = (m + v) / 2)) ? m = o : v = o, (u = n >= (a = (g + y) / 2)) ? g = a : y = a
                 } while ((f = u << 1 | l) === (d = (c >= a) << 1 | s >= o));
                 return r[d] = h, r[f] = p, t
             }
 
-            function Cw(t, e, n, i, r) {
+            function zw(t, e, n, i, r) {
                 this.node = t, this.x0 = e, this.y0 = n, this.x1 = i, this.y1 = r
             }
 
-            function Fw(t) {
+            function Pw(t) {
                 return t[0]
             }
 
-            function Mw(t) {
+            function Lw(t) {
                 return t[1]
             }
 
-            function Ow(t, e, n) {
-                var i = new Tw(null == e ? Fw : e, null == n ? Mw : n, NaN, NaN, NaN, NaN);
+            function Bw(t, e, n) {
+                var i = new Iw(null == e ? Pw : e, null == n ? Lw : n, NaN, NaN, NaN, NaN);
                 return null == t ? i : i.addAll(t)
             }
 
-            function Tw(t, e, n, i, r, o) {
+            function Iw(t, e, n, i, r, o) {
                 this._x = t, this._y = e, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = o, this._root = void 0
             }
 
-            function Nw(t) {
+            function jw(t) {
                 for (var e = {
                         data: t.data
                     }, n = e; t = t.next;) n = n.next = {
                     data: t.data
                 };
                 return e
             }
-            yw.Definition = {
+            Aw.Definition = {
                 type: "GeoJSON",
                 metadata: {},
                 params: [{
                     name: "fields",
                     type: "field",
                     array: !0,
                     length: 2
                 }, {
                     name: "geojson",
                     type: "field"
                 }]
-            }, (0, m.XW)(yw, Rr, {
+            }, (0, m.XW)(Aw, zr, {
                 transform(t, e) {
                     var n, i = this._features,
                         r = this._points,
                         o = t.fields,
                         a = o && o[0],
                         s = o && o[1],
                         c = t.geojson || !o && m.yR,
                         l = e.ADD;
                     n = t.modified() || e.changed(e.REM) || e.modified((0, m.Oj)(c)) || a && e.modified((0, m.Oj)(a)) || s && e.modified((0, m.Oj)(s)), this.value && !n || (l = e.SOURCE, this._features = i = [], this._points = r = []), c && e.visit(l, (t => i.push(c(t)))), a && s && (e.visit(l, (t => {
                         var e = a(t),
                             n = s(t);
                         null != e && null != n && (e = +e) === e && (n = +n) === n && r.push([e, n])
                     })), i = i.concat({
-                        type: gw,
+                        type: kw,
                         geometry: {
                             type: "MultiPoint",
                             coordinates: r
                         }
                     })), this.value = {
-                        type: vw,
+                        type: Ew,
                         features: i
                     }
                 }
-            }), bw.Definition = {
+            }), Dw.Definition = {
                 type: "GeoPath",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "projection",
                     type: "projection"
@@ -33647,30 +33784,30 @@
                     type: "number",
                     expr: !0
                 }, {
                     name: "as",
                     type: "string",
                     default: "path"
                 }]
-            }, (0, m.XW)(bw, Rr, {
+            }, (0, m.XW)(Dw, zr, {
                 transform(t, e) {
                     var n = e.fork(e.ALL),
                         i = this.value,
                         r = t.field || m.yR,
                         o = t.as || "path",
                         a = n.SOURCE;
-                    !i || t.modified() ? (this.value = i = G_(t.projection), n.materialize().reflow()) : a = r === m.yR || e.modified(r.fields) ? n.ADD_MOD : n.ADD;
+                    !i || t.modified() ? (this.value = i = tw(t.projection), n.materialize().reflow()) : a = r === m.yR || e.modified(r.fields) ? n.ADD_MOD : n.ADD;
                     const s = function(t, e) {
                         const n = t.pointRadius();
                         t.context(null), null != e && t.pointRadius(e);
                         return n
                     }(i, t.pointRadius);
                     return n.visit(a, (t => t[o] = i(r(t)))), i.pointRadius(s), n.modifies(o)
                 }
-            }), xw.Definition = {
+            }), Sw.Definition = {
                 type: "GeoPoint",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "projection",
                     type: "projection",
@@ -33684,30 +33821,30 @@
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 2,
                     default: ["x", "y"]
                 }]
-            }, (0, m.XW)(xw, Rr, {
+            }, (0, m.XW)(Sw, zr, {
                 transform(t, e) {
                     var n, i = t.projection,
                         r = t.fields[0],
                         o = t.fields[1],
                         a = t.as || ["x", "y"],
                         s = a[0],
                         c = a[1];
 
                     function l(t) {
                         const e = i([r(t), o(t)]);
                         e ? (t[s] = e[0], t[c] = e[1]) : (t[s] = void 0, t[c] = void 0)
                     }
                     return t.modified() ? e = e.materialize().reflow(!0).visit(e.SOURCE, l) : (n = e.modified(r.fields) || e.modified(o.fields), e.visit(n ? e.ADD_MOD : e.ADD, l)), e.modifies(a)
                 }
-            }), _w.Definition = {
+            }), Cw.Definition = {
                 type: "GeoShape",
                 metadata: {
                     modifies: !0,
                     nomod: !0
                 },
                 params: [{
                     name: "projection",
@@ -33721,30 +33858,30 @@
                     type: "number",
                     expr: !0
                 }, {
                     name: "as",
                     type: "string",
                     default: "shape"
                 }]
-            }, (0, m.XW)(_w, Rr, {
+            }, (0, m.XW)(Cw, zr, {
                 transform(t, e) {
                     var n = e.fork(e.ALL),
                         i = this.value,
                         r = t.as || "shape",
                         o = n.ADD;
                     return i && !t.modified() || (this.value = i = function(t, e, n) {
                         const i = null == n ? n => t(e(n)) : i => {
                             var r = t.pointRadius(),
                                 o = t.pointRadius(n)(e(i));
                             return t.pointRadius(r), o
                         };
                         return i.context = e => (t.context(e), i), i
-                    }(G_(t.projection), t.field || (0, m.EP)("datum"), t.pointRadius), n.materialize().reflow(), o = n.SOURCE), n.visit(o, (t => t[r] = i)), n.modifies(r)
+                    }(tw(t.projection), t.field || (0, m.EP)("datum"), t.pointRadius), n.materialize().reflow(), o = n.SOURCE), n.visit(o, (t => t[r] = i)), n.modifies(r)
                 }
-            }), ww.Definition = {
+            }), Mw.Definition = {
                 type: "Graticule",
                 metadata: {
                     changes: !0,
                     generates: !0
                 },
                 params: [{
                     name: "extent",
@@ -33794,23 +33931,23 @@
                     length: 2,
                     default: [10, 10]
                 }, {
                     name: "precision",
                     type: "number",
                     default: 2.5
                 }]
-            }, (0, m.XW)(ww, Rr, {
+            }, (0, m.XW)(Mw, zr, {
                 transform(t, e) {
                     var n, i = this.value,
                         r = this.generator;
                     if (!i.length || t.modified())
                         for (const o in t)(0, m.mf)(r[o]) && r[o](t[o]);
                     return n = r(), i.length ? e.mod.push(sr(i[0], n)) : e.add.push(rr(n)), i[0] = n, e
                 }
-            }), kw.Definition = {
+            }), Fw.Definition = {
                 type: "heatmap",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "field",
                     type: "field"
@@ -33828,28 +33965,28 @@
                     values: ["shared", "independent"],
                     default: "independent"
                 }, {
                     name: "as",
                     type: "string",
                     default: "image"
                 }]
-            }, (0, m.XW)(kw, Rr, {
+            }, (0, m.XW)(Fw, zr, {
                 transform(t, e) {
                     if (!e.changed() && !t.modified()) return e.StopPropagation;
                     var n = e.materialize(e.SOURCE).source,
                         i = "shared" === t.resolve,
                         r = t.field || m.yR,
                         o = function(t, e) {
                             let n;
-                            (0, m.mf)(t) ? (n = n => t(n, e), n.dep = Ew(t)) : t ? n = (0, m.a9)(t) : (n = t => t.$value / t.$max || 0, n.dep = !0);
+                            (0, m.mf)(t) ? (n = n => t(n, e), n.dep = Ow(t)) : t ? n = (0, m.a9)(t) : (n = t => t.$value / t.$max || 0, n.dep = !0);
                             return n
                         }(t.opacity, t),
                         a = function(t, e) {
                             let n;
-                            (0, m.mf)(t) ? (n = n => (0, Ul.B8)(t(n, e)), n.dep = Ew(t)) : n = (0, m.a9)((0, Ul.B8)(t || "#888"));
+                            (0, m.mf)(t) ? (n = n => (0, uu.B8)(t(n, e)), n.dep = Ow(t)) : n = (0, m.a9)((0, uu.B8)(t || "#888"));
                             return n
                         }(t.color, t),
                         s = t.as || "image",
                         c = {
                             $x: 0,
                             $y: 0,
                             $value: 0,
@@ -33863,15 +34000,15 @@
                                 o = t.height,
                                 a = t.x1 || 0,
                                 s = t.y1 || 0,
                                 c = t.x2 || r,
                                 l = t.y2 || o,
                                 u = t.values,
                                 f = u ? t => u[t] : m.bM,
-                                d = Xc(c - a, l - s),
+                                d = il(c - a, l - s),
                                 h = d.getContext("2d"),
                                 p = h.getImageData(0, 0, c - a, l - s),
                                 g = p.data;
                             for (let m = s, v = 0; m < l; ++m) {
                                 e.$y = m - s;
                                 for (let t = a, o = m * r; t < c; ++t, v += 4) {
                                     e.$x = t - a, e.$value = f(t + o);
@@ -33879,91 +34016,91 @@
                                     g[v + 0] = r.r, g[v + 1] = r.g, g[v + 2] = r.b, g[v + 3] = ~~(255 * i(e))
                                 }
                             }
                             return h.putImageData(p, 0, 0), d
                         }(e, n, a.dep ? a : (0, m.a9)(a(n)), o.dep ? o : (0, m.a9)(o(n)))
                     })), e.reflow(!0).modifies(s)
                 }
-            }), (0, m.XW)(Dw, Rr, {
+            }), (0, m.XW)(Tw, zr, {
                 transform(t, e) {
                     let n = this.value;
                     return !n || t.modified("type") ? (this.value = n = function(t) {
-                        const e = J_((t || "mercator").toLowerCase());
+                        const e = Q_((t || "mercator").toLowerCase());
                         e || (0, m.vU)("Unrecognized projection type: " + t);
                         return e()
-                    }(t.type), X_.forEach((e => {
-                        null != t[e] && Aw(n, e, t[e])
-                    }))) : X_.forEach((e => {
-                        t.modified(e) && Aw(n, e, t[e])
+                    }(t.type), K_.forEach((e => {
+                        null != t[e] && Nw(n, e, t[e])
+                    }))) : K_.forEach((e => {
+                        t.modified(e) && Nw(n, e, t[e])
                     })), null != t.pointRadius && n.path.pointRadius(t.pointRadius), t.fit && function(t, e) {
                         const n = function(t) {
                             return t = (0, m.IX)(t), 1 === t.length ? t[0] : {
-                                type: vw,
+                                type: Ew,
                                 features: t.reduce(((t, e) => t.concat(function(t) {
-                                    return t.type === vw ? t.features : (0, m.IX)(t).filter((t => null != t)).map((t => t.type === gw ? t : {
-                                        type: gw,
+                                    return t.type === Ew ? t.features : (0, m.IX)(t).filter((t => null != t)).map((t => t.type === kw ? t : {
+                                        type: kw,
                                         geometry: t
                                     }))
                                 }(e))), [])
                             }
                         }(e.fit);
                         e.extent ? t.fitExtent(e.extent, n) : e.size && t.fitSize(e.size, n)
                     }(n, t), e.fork(e.NO_SOURCE | e.NO_FIELDS)
                 }
             });
-            var zw = Ow.prototype = Tw.prototype;
+            var Uw = Bw.prototype = Iw.prototype;
 
-            function Rw(t) {
+            function qw(t) {
                 return function() {
                     return t
                 }
             }
 
-            function Pw(t) {
+            function Ww(t) {
                 return 1e-6 * (t() - .5)
             }
 
-            function Lw(t) {
+            function Hw(t) {
                 return t.x + t.vx
             }
 
-            function jw(t) {
+            function Xw(t) {
                 return t.y + t.vy
             }
-            zw.copy = function() {
-                var t, e, n = new Tw(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
+            Uw.copy = function() {
+                var t, e, n = new Iw(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
                     i = this._root;
                 if (!i) return n;
-                if (!i.length) return n._root = Nw(i), n;
+                if (!i.length) return n._root = jw(i), n;
                 for (t = [{
                         source: i,
                         target: n._root = new Array(4)
                     }]; i = t.pop();)
                     for (var r = 0; r < 4; ++r)(e = i.source[r]) && (e.length ? t.push({
                         source: e,
                         target: i.target[r] = new Array(4)
-                    }) : i.target[r] = Nw(e));
+                    }) : i.target[r] = jw(e));
                 return n
-            }, zw.add = function(t) {
+            }, Uw.add = function(t) {
                 const e = +this._x.call(null, t),
                     n = +this._y.call(null, t);
-                return Sw(this.cover(e, n), e, n, t)
-            }, zw.addAll = function(t) {
+                return Rw(this.cover(e, n), e, n, t)
+            }, Uw.addAll = function(t) {
                 var e, n, i, r, o = t.length,
                     a = new Array(o),
                     s = new Array(o),
                     c = 1 / 0,
                     l = 1 / 0,
                     u = -1 / 0,
                     f = -1 / 0;
                 for (n = 0; n < o; ++n) isNaN(i = +this._x.call(null, e = t[n])) || isNaN(r = +this._y.call(null, e)) || (a[n] = i, s[n] = r, i < c && (c = i), i > u && (u = i), r < l && (l = r), r > f && (f = r));
                 if (c > u || l > f) return this;
-                for (this.cover(c, l).cover(u, f), n = 0; n < o; ++n) Sw(this, a[n], s[n], t[n]);
+                for (this.cover(c, l).cover(u, f), n = 0; n < o; ++n) Rw(this, a[n], s[n], t[n]);
                 return this
-            }, zw.cover = function(t, e) {
+            }, Uw.cover = function(t, e) {
                 if (isNaN(t = +t) || isNaN(e = +e)) return this;
                 var n = this._x0,
                     i = this._y0,
                     r = this._x1,
                     o = this._y1;
                 if (isNaN(n)) r = (n = Math.floor(t)) + 1, o = (i = Math.floor(e)) + 1;
                 else {
@@ -33979,50 +34116,50 @@
                             break;
                         case 3:
                             n = r - c, i = o - c
                     }
                     this._root && this._root.length && (this._root = l)
                 }
                 return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = o, this
-            }, zw.data = function() {
+            }, Uw.data = function() {
                 var t = [];
                 return this.visit((function(e) {
                     if (!e.length)
                         do {
                             t.push(e.data)
                         } while (e = e.next)
                 })), t
-            }, zw.extent = function(t) {
+            }, Uw.extent = function(t) {
                 return arguments.length ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1]) : isNaN(this._x0) ? void 0 : [
                     [this._x0, this._y0],
                     [this._x1, this._y1]
                 ]
-            }, zw.find = function(t, e, n) {
+            }, Uw.find = function(t, e, n) {
                 var i, r, o, a, s, c, l, u = this._x0,
                     f = this._y0,
                     d = this._x1,
                     h = this._y1,
                     p = [],
                     m = this._root;
-                for (m && p.push(new Cw(m, u, f, d, h)), null == n ? n = 1 / 0 : (u = t - n, f = e - n, d = t + n, h = e + n, n *= n); c = p.pop();)
+                for (m && p.push(new zw(m, u, f, d, h)), null == n ? n = 1 / 0 : (u = t - n, f = e - n, d = t + n, h = e + n, n *= n); c = p.pop();)
                     if (!(!(m = c.node) || (r = c.x0) > d || (o = c.y0) > h || (a = c.x1) < u || (s = c.y1) < f))
                         if (m.length) {
                             var g = (r + a) / 2,
                                 v = (o + s) / 2;
-                            p.push(new Cw(m[3], g, v, a, s), new Cw(m[2], r, v, g, s), new Cw(m[1], g, o, a, v), new Cw(m[0], r, o, g, v)), (l = (e >= v) << 1 | t >= g) && (c = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - l], p[p.length - 1 - l] = c)
+                            p.push(new zw(m[3], g, v, a, s), new zw(m[2], r, v, g, s), new zw(m[1], g, o, a, v), new zw(m[0], r, o, g, v)), (l = (e >= v) << 1 | t >= g) && (c = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - l], p[p.length - 1 - l] = c)
                         } else {
                             var y = t - +this._x.call(null, m.data),
                                 b = e - +this._y.call(null, m.data),
                                 x = y * y + b * b;
                             if (x < n) {
                                 var _ = Math.sqrt(n = x);
                                 u = t - _, f = e - _, d = t + _, h = e + _, i = m.data
                             }
                         } return i
-            }, zw.remove = function(t) {
+            }, Uw.remove = function(t) {
                 if (isNaN(o = +this._x.call(null, t)) || isNaN(a = +this._y.call(null, t))) return this;
                 var e, n, i, r, o, a, s, c, l, u, f, d, h = this._root,
                     p = this._x0,
                     m = this._y0,
                     g = this._x1,
                     v = this._y1;
                 if (!h) return this;
@@ -34031,92 +34168,92 @@
                         if ((l = o >= (s = (p + g) / 2)) ? p = s : g = s, (u = a >= (c = (m + v) / 2)) ? m = c : v = c, e = h, !(h = h[f = u << 1 | l])) return this;
                         if (!h.length) break;
                         (e[f + 1 & 3] || e[f + 2 & 3] || e[f + 3 & 3]) && (n = e, d = f)
                     }
                 for (; h.data !== t;)
                     if (i = h, !(h = h.next)) return this;
                 return (r = h.next) && delete h.next, i ? (r ? i.next = r : delete i.next, this) : e ? (r ? e[f] = r : delete e[f], (h = e[0] || e[1] || e[2] || e[3]) && h === (e[3] || e[2] || e[1] || e[0]) && !h.length && (n ? n[d] = h : this._root = h), this) : (this._root = r, this)
-            }, zw.removeAll = function(t) {
+            }, Uw.removeAll = function(t) {
                 for (var e = 0, n = t.length; e < n; ++e) this.remove(t[e]);
                 return this
-            }, zw.root = function() {
+            }, Uw.root = function() {
                 return this._root
-            }, zw.size = function() {
+            }, Uw.size = function() {
                 var t = 0;
                 return this.visit((function(e) {
                     if (!e.length)
                         do {
                             ++t
                         } while (e = e.next)
                 })), t
-            }, zw.visit = function(t) {
+            }, Uw.visit = function(t) {
                 var e, n, i, r, o, a, s = [],
                     c = this._root;
-                for (c && s.push(new Cw(c, this._x0, this._y0, this._x1, this._y1)); e = s.pop();)
+                for (c && s.push(new zw(c, this._x0, this._y0, this._x1, this._y1)); e = s.pop();)
                     if (!t(c = e.node, i = e.x0, r = e.y0, o = e.x1, a = e.y1) && c.length) {
                         var l = (i + o) / 2,
                             u = (r + a) / 2;
-                        (n = c[3]) && s.push(new Cw(n, l, u, o, a)), (n = c[2]) && s.push(new Cw(n, i, u, l, a)), (n = c[1]) && s.push(new Cw(n, l, r, o, u)), (n = c[0]) && s.push(new Cw(n, i, r, l, u))
+                        (n = c[3]) && s.push(new zw(n, l, u, o, a)), (n = c[2]) && s.push(new zw(n, i, u, l, a)), (n = c[1]) && s.push(new zw(n, l, r, o, u)), (n = c[0]) && s.push(new zw(n, i, r, l, u))
                     } return this
-            }, zw.visitAfter = function(t) {
+            }, Uw.visitAfter = function(t) {
                 var e, n = [],
                     i = [];
-                for (this._root && n.push(new Cw(this._root, this._x0, this._y0, this._x1, this._y1)); e = n.pop();) {
+                for (this._root && n.push(new zw(this._root, this._x0, this._y0, this._x1, this._y1)); e = n.pop();) {
                     var r = e.node;
                     if (r.length) {
                         var o, a = e.x0,
                             s = e.y0,
                             c = e.x1,
                             l = e.y1,
                             u = (a + c) / 2,
                             f = (s + l) / 2;
-                        (o = r[0]) && n.push(new Cw(o, a, s, u, f)), (o = r[1]) && n.push(new Cw(o, u, s, c, f)), (o = r[2]) && n.push(new Cw(o, a, f, u, l)), (o = r[3]) && n.push(new Cw(o, u, f, c, l))
+                        (o = r[0]) && n.push(new zw(o, a, s, u, f)), (o = r[1]) && n.push(new zw(o, u, s, c, f)), (o = r[2]) && n.push(new zw(o, a, f, u, l)), (o = r[3]) && n.push(new zw(o, u, f, c, l))
                     }
                     i.push(e)
                 }
                 for (; e = i.pop();) t(e.node, e.x0, e.y0, e.x1, e.y1);
                 return this
-            }, zw.x = function(t) {
+            }, Uw.x = function(t) {
                 return arguments.length ? (this._x = t, this) : this._x
-            }, zw.y = function(t) {
+            }, Uw.y = function(t) {
                 return arguments.length ? (this._y = t, this) : this._y
             };
-            var Bw = {
+            var Gw = {
                 value: () => {}
             };
 
-            function Iw() {
+            function Jw() {
                 for (var t, e = 0, n = arguments.length, i = {}; e < n; ++e) {
                     if (!(t = arguments[e] + "") || t in i || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
                     i[t] = []
                 }
-                return new Uw(i)
+                return new Zw(i)
             }
 
-            function Uw(t) {
+            function Zw(t) {
                 this._ = t
             }
 
-            function qw(t, e) {
+            function $w(t, e) {
                 for (var n, i = 0, r = t.length; i < r; ++i)
                     if ((n = t[i]).name === e) return n.value
             }
 
-            function Ww(t, e, n) {
+            function Yw(t, e, n) {
                 for (var i = 0, r = t.length; i < r; ++i)
                     if (t[i].name === e) {
-                        t[i] = Bw, t = t.slice(0, i).concat(t.slice(i + 1));
+                        t[i] = Gw, t = t.slice(0, i).concat(t.slice(i + 1));
                         break
                     } return null != n && t.push({
                     name: e,
                     value: n
                 }), t
             }
-            Uw.prototype = Iw.prototype = {
-                constructor: Uw,
+            Zw.prototype = Jw.prototype = {
+                constructor: Zw,
                 on: function(t, e) {
                     var n, i, r = this._,
                         o = (i = r, (t + "").trim().split(/^|\s+/).map((function(t) {
                             var e = "",
                                 n = t.indexOf(".");
                             if (n >= 0 && (e = t.slice(n + 1), t = t.slice(0, n)), t && !i.hasOwnProperty(t)) throw new Error("unknown type: " + t);
                             return {
@@ -34125,67 +34262,67 @@
                             }
                         }))),
                         a = -1,
                         s = o.length;
                     if (!(arguments.length < 2)) {
                         if (null != e && "function" !== typeof e) throw new Error("invalid callback: " + e);
                         for (; ++a < s;)
-                            if (n = (t = o[a]).type) r[n] = Ww(r[n], t.name, e);
+                            if (n = (t = o[a]).type) r[n] = Yw(r[n], t.name, e);
                             else if (null == e)
-                            for (n in r) r[n] = Ww(r[n], t.name, null);
+                            for (n in r) r[n] = Yw(r[n], t.name, null);
                         return this
                     }
                     for (; ++a < s;)
-                        if ((n = (t = o[a]).type) && (n = qw(r[n], t.name))) return n
+                        if ((n = (t = o[a]).type) && (n = $w(r[n], t.name))) return n
                 },
                 copy: function() {
                     var t = {},
                         e = this._;
                     for (var n in e) t[n] = e[n].slice();
-                    return new Uw(t)
+                    return new Zw(t)
                 },
                 call: function(t, e) {
                     if ((n = arguments.length - 2) > 0)
                         for (var n, i, r = new Array(n), o = 0; o < n; ++o) r[o] = arguments[o + 2];
                     if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
                     for (o = 0, n = (i = this._[t]).length; o < n; ++o) i[o].value.apply(e, r)
                 },
                 apply: function(t, e, n) {
                     if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
                     for (var i = this._[t], r = 0, o = i.length; r < o; ++r) i[r].value.apply(e, n)
                 }
             };
-            const Hw = Iw;
-            var Xw = n(89121);
-            const Jw = 1664525,
-                Gw = 1013904223,
-                $w = 4294967296;
+            const Vw = Jw;
+            var Kw = n(89121);
+            const Qw = 1664525,
+                tk = 1013904223,
+                ek = 4294967296;
 
-            function Zw(t) {
+            function nk(t) {
                 return t.x
             }
 
-            function Yw(t) {
+            function ik(t) {
                 return t.y
             }
-            var Vw = 10,
-                Kw = Math.PI * (3 - Math.sqrt(5));
+            var rk = 10,
+                ok = Math.PI * (3 - Math.sqrt(5));
 
-            function Qw(t) {
+            function ak(t) {
                 var e, n = 1,
                     i = .001,
                     r = 1 - Math.pow(i, 1 / 300),
                     o = 0,
                     a = .6,
                     s = new Map,
-                    c = (0, Xw.HT)(f),
-                    l = Hw("tick", "end"),
+                    c = (0, Kw.HT)(f),
+                    l = Vw("tick", "end"),
                     u = function() {
                         let t = 1;
-                        return () => (t = (Jw * t + Gw) % $w) / $w
+                        return () => (t = (Qw * t + tk) % ek) / ek
                     }();
 
                 function f() {
                     d(), l.call("tick", e), n < i && (c.stop(), l.call("end", e))
                 }
 
                 function d(i) {
@@ -34197,16 +34334,16 @@
                             })), c = 0; c < u; ++c) null == (l = t[c]).fx ? l.x += l.vx *= a : (l.x = l.fx, l.vx = 0), null == l.fy ? l.y += l.vy *= a : (l.y = l.fy, l.vy = 0);
                     return e
                 }
 
                 function h() {
                     for (var e, n = 0, i = t.length; n < i; ++n) {
                         if ((e = t[n]).index = n, null != e.fx && (e.x = e.fx), null != e.fy && (e.y = e.fy), isNaN(e.x) || isNaN(e.y)) {
-                            var r = Vw * Math.sqrt(.5 + n),
-                                o = n * Kw;
+                            var r = rk * Math.sqrt(.5 + n),
+                                o = n * ok;
                             e.x = r * Math.cos(o), e.y = r * Math.sin(o)
                         }(isNaN(e.vx) || isNaN(e.vy)) && (e.vx = e.vy = 0)
                     }
                 }
 
                 function p(e) {
                     return e.initialize && e.initialize(t, u), e
@@ -34251,24 +34388,24 @@
                     },
                     on: function(t, n) {
                         return arguments.length > 1 ? (l.on(t, n), e) : l.on(t)
                     }
                 }
             }
 
-            function tk(t) {
+            function sk(t) {
                 return t.index
             }
 
-            function ek(t, e) {
+            function ck(t, e) {
                 var n = t.get(e);
                 if (!n) throw new Error("node not found: " + e);
                 return n
             }
-            const nk = {
+            const lk = {
                     center: function(t, e) {
                         var n, i = 1;
 
                         function r() {
                             var r, o, a = n.length,
                                 s = 0,
                                 c = 0;
@@ -34287,26 +34424,26 @@
                     },
                     collide: function(t) {
                         var e, n, i, r = 1,
                             o = 1;
 
                         function a() {
                             for (var t, a, c, l, u, f, d, h = e.length, p = 0; p < o; ++p)
-                                for (a = Ow(e, Lw, jw).visitAfter(s), t = 0; t < h; ++t) c = e[t], f = n[c.index], d = f * f, l = c.x + c.vx, u = c.y + c.vy, a.visit(m);
+                                for (a = Bw(e, Hw, Xw).visitAfter(s), t = 0; t < h; ++t) c = e[t], f = n[c.index], d = f * f, l = c.x + c.vx, u = c.y + c.vy, a.visit(m);
 
                             function m(t, e, n, o, a) {
                                 var s = t.data,
                                     h = t.r,
                                     p = f + h;
                                 if (!s) return e > l + p || o < l - p || n > u + p || a < u - p;
                                 if (s.index > c.index) {
                                     var m = l - s.x - s.vx,
                                         g = u - s.y - s.vy,
                                         v = m * m + g * g;
-                                    v < p * p && (0 === m && (v += (m = Pw(i)) * m), 0 === g && (v += (g = Pw(i)) * g), v = (p - (v = Math.sqrt(v))) / v * r, c.vx += (m *= v) * (p = (h *= h) / (d + h)), c.vy += (g *= v) * p, s.vx -= m * (p = 1 - p), s.vy -= g * p)
+                                    v < p * p && (0 === m && (v += (m = Ww(i)) * m), 0 === g && (v += (g = Ww(i)) * g), v = (p - (v = Math.sqrt(v))) / v * r, c.vx += (m *= v) * (p = (h *= h) / (d + h)), c.vy += (g *= v) * p, s.vx -= m * (p = 1 - p), s.vy -= g * p)
                                 }
                             }
                         }
 
                         function s(t) {
                             if (t.data) return t.r = n[t.data.index];
                             for (var e = t.r = 0; e < 4; ++e) t[e] && t[e].r > t.r && (t.r = t[e].r)
@@ -34314,33 +34451,33 @@
 
                         function c() {
                             if (e) {
                                 var i, r, o = e.length;
                                 for (n = new Array(o), i = 0; i < o; ++i) r = e[i], n[r.index] = +t(r, i, e)
                             }
                         }
-                        return "function" !== typeof t && (t = Rw(null == t ? 1 : +t)), a.initialize = function(t, n) {
+                        return "function" !== typeof t && (t = qw(null == t ? 1 : +t)), a.initialize = function(t, n) {
                             e = t, i = n, c()
                         }, a.iterations = function(t) {
                             return arguments.length ? (o = +t, a) : o
                         }, a.strength = function(t) {
                             return arguments.length ? (r = +t, a) : r
                         }, a.radius = function(e) {
-                            return arguments.length ? (t = "function" === typeof e ? e : Rw(+e), c(), a) : t
+                            return arguments.length ? (t = "function" === typeof e ? e : qw(+e), c(), a) : t
                         }, a
                     },
                     nbody: function() {
-                        var t, e, n, i, r, o = Rw(-30),
+                        var t, e, n, i, r, o = qw(-30),
                             a = 1,
                             s = 1 / 0,
                             c = .81;
 
                         function l(n) {
                             var r, o = t.length,
-                                a = Ow(t, Zw, Yw).visitAfter(f);
+                                a = Bw(t, nk, ik).visitAfter(f);
                             for (i = n, r = 0; r < o; ++r) e = t[r], a.visit(d)
                         }
 
                         function u() {
                             if (t) {
                                 var e, n, i = t.length;
                                 for (r = new Array(i), e = 0; e < i; ++e) n = t[e], r[n.index] = +o(n, e, t)
@@ -34364,53 +34501,53 @@
 
                         function d(t, o, l, u) {
                             if (!t.value) return !0;
                             var f = t.x - e.x,
                                 d = t.y - e.y,
                                 h = u - o,
                                 p = f * f + d * d;
-                            if (h * h / c < p) return p < s && (0 === f && (p += (f = Pw(n)) * f), 0 === d && (p += (d = Pw(n)) * d), p < a && (p = Math.sqrt(a * p)), e.vx += f * t.value * i / p, e.vy += d * t.value * i / p), !0;
+                            if (h * h / c < p) return p < s && (0 === f && (p += (f = Ww(n)) * f), 0 === d && (p += (d = Ww(n)) * d), p < a && (p = Math.sqrt(a * p)), e.vx += f * t.value * i / p, e.vy += d * t.value * i / p), !0;
                             if (!(t.length || p >= s)) {
-                                (t.data !== e || t.next) && (0 === f && (p += (f = Pw(n)) * f), 0 === d && (p += (d = Pw(n)) * d), p < a && (p = Math.sqrt(a * p)));
+                                (t.data !== e || t.next) && (0 === f && (p += (f = Ww(n)) * f), 0 === d && (p += (d = Ww(n)) * d), p < a && (p = Math.sqrt(a * p)));
                                 do {
                                     t.data !== e && (h = r[t.data.index] * i / p, e.vx += f * h, e.vy += d * h)
                                 } while (t = t.next)
                             }
                         }
                         return l.initialize = function(e, i) {
                             t = e, n = i, u()
                         }, l.strength = function(t) {
-                            return arguments.length ? (o = "function" === typeof t ? t : Rw(+t), u(), l) : o
+                            return arguments.length ? (o = "function" === typeof t ? t : qw(+t), u(), l) : o
                         }, l.distanceMin = function(t) {
                             return arguments.length ? (a = t * t, l) : Math.sqrt(a)
                         }, l.distanceMax = function(t) {
                             return arguments.length ? (s = t * t, l) : Math.sqrt(s)
                         }, l.theta = function(t) {
                             return arguments.length ? (c = t * t, l) : Math.sqrt(c)
                         }, l
                     },
                     link: function(t) {
-                        var e, n, i, r, o, a, s = tk,
+                        var e, n, i, r, o, a, s = sk,
                             c = function(t) {
                                 return 1 / Math.min(r[t.source.index], r[t.target.index])
                             },
-                            l = Rw(30),
+                            l = qw(30),
                             u = 1;
 
                         function f(i) {
                             for (var r = 0, s = t.length; r < u; ++r)
-                                for (var c, l, f, d, h, p, m, g = 0; g < s; ++g) l = (c = t[g]).source, d = (f = c.target).x + f.vx - l.x - l.vx || Pw(a), h = f.y + f.vy - l.y - l.vy || Pw(a), d *= p = ((p = Math.sqrt(d * d + h * h)) - n[g]) / p * i * e[g], h *= p, f.vx -= d * (m = o[g]), f.vy -= h * m, l.vx += d * (m = 1 - m), l.vy += h * m
+                                for (var c, l, f, d, h, p, m, g = 0; g < s; ++g) l = (c = t[g]).source, d = (f = c.target).x + f.vx - l.x - l.vx || Ww(a), h = f.y + f.vy - l.y - l.vy || Ww(a), d *= p = ((p = Math.sqrt(d * d + h * h)) - n[g]) / p * i * e[g], h *= p, f.vx -= d * (m = o[g]), f.vy -= h * m, l.vx += d * (m = 1 - m), l.vy += h * m
                         }
 
                         function d() {
                             if (i) {
                                 var a, c, l = i.length,
                                     u = t.length,
                                     f = new Map(i.map(((t, e) => [s(t, e, i), t])));
-                                for (a = 0, r = new Array(l); a < u; ++a)(c = t[a]).index = a, "object" !== typeof c.source && (c.source = ek(f, c.source)), "object" !== typeof c.target && (c.target = ek(f, c.target)), r[c.source.index] = (r[c.source.index] || 0) + 1, r[c.target.index] = (r[c.target.index] || 0) + 1;
+                                for (a = 0, r = new Array(l); a < u; ++a)(c = t[a]).index = a, "object" !== typeof c.source && (c.source = ck(f, c.source)), "object" !== typeof c.target && (c.target = ck(f, c.target)), r[c.source.index] = (r[c.source.index] || 0) + 1, r[c.target.index] = (r[c.target.index] || 0) + 1;
                                 for (a = 0, o = new Array(u); a < u; ++a) c = t[a], o[a] = r[c.source.index] / (r[c.source.index] + r[c.target.index]);
                                 e = new Array(u), h(), n = new Array(u), p()
                             }
                         }
 
                         function h() {
                             if (i)
@@ -34426,156 +34563,156 @@
                         }, f.links = function(e) {
                             return arguments.length ? (t = e, d(), f) : t
                         }, f.id = function(t) {
                             return arguments.length ? (s = t, f) : s
                         }, f.iterations = function(t) {
                             return arguments.length ? (u = +t, f) : u
                         }, f.strength = function(t) {
-                            return arguments.length ? (c = "function" === typeof t ? t : Rw(+t), h(), f) : c
+                            return arguments.length ? (c = "function" === typeof t ? t : qw(+t), h(), f) : c
                         }, f.distance = function(t) {
-                            return arguments.length ? (l = "function" === typeof t ? t : Rw(+t), p(), f) : l
+                            return arguments.length ? (l = "function" === typeof t ? t : qw(+t), p(), f) : l
                         }, f
                     },
                     x: function(t) {
-                        var e, n, i, r = Rw(.1);
+                        var e, n, i, r = qw(.1);
 
                         function o(t) {
                             for (var r, o = 0, a = e.length; o < a; ++o)(r = e[o]).vx += (i[o] - r.x) * n[o] * t
                         }
 
                         function a() {
                             if (e) {
                                 var o, a = e.length;
                                 for (n = new Array(a), i = new Array(a), o = 0; o < a; ++o) n[o] = isNaN(i[o] = +t(e[o], o, e)) ? 0 : +r(e[o], o, e)
                             }
                         }
-                        return "function" !== typeof t && (t = Rw(null == t ? 0 : +t)), o.initialize = function(t) {
+                        return "function" !== typeof t && (t = qw(null == t ? 0 : +t)), o.initialize = function(t) {
                             e = t, a()
                         }, o.strength = function(t) {
-                            return arguments.length ? (r = "function" === typeof t ? t : Rw(+t), a(), o) : r
+                            return arguments.length ? (r = "function" === typeof t ? t : qw(+t), a(), o) : r
                         }, o.x = function(e) {
-                            return arguments.length ? (t = "function" === typeof e ? e : Rw(+e), a(), o) : t
+                            return arguments.length ? (t = "function" === typeof e ? e : qw(+e), a(), o) : t
                         }, o
                     },
                     y: function(t) {
-                        var e, n, i, r = Rw(.1);
+                        var e, n, i, r = qw(.1);
 
                         function o(t) {
                             for (var r, o = 0, a = e.length; o < a; ++o)(r = e[o]).vy += (i[o] - r.y) * n[o] * t
                         }
 
                         function a() {
                             if (e) {
                                 var o, a = e.length;
                                 for (n = new Array(a), i = new Array(a), o = 0; o < a; ++o) n[o] = isNaN(i[o] = +t(e[o], o, e)) ? 0 : +r(e[o], o, e)
                             }
                         }
-                        return "function" !== typeof t && (t = Rw(null == t ? 0 : +t)), o.initialize = function(t) {
+                        return "function" !== typeof t && (t = qw(null == t ? 0 : +t)), o.initialize = function(t) {
                             e = t, a()
                         }, o.strength = function(t) {
-                            return arguments.length ? (r = "function" === typeof t ? t : Rw(+t), a(), o) : r
+                            return arguments.length ? (r = "function" === typeof t ? t : qw(+t), a(), o) : r
                         }, o.y = function(e) {
-                            return arguments.length ? (t = "function" === typeof e ? e : Rw(+e), a(), o) : t
+                            return arguments.length ? (t = "function" === typeof e ? e : qw(+e), a(), o) : t
                         }, o
                     }
                 },
-                ik = "forces",
-                rk = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"],
-                ok = ["static", "iterations"],
-                ak = ["x", "y", "vx", "vy"];
+                uk = "forces",
+                fk = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"],
+                dk = ["static", "iterations"],
+                hk = ["x", "y", "vx", "vy"];
 
-            function sk(t) {
-                Rr.call(this, null, t)
+            function pk(t) {
+                zr.call(this, null, t)
             }
 
-            function ck(t, e, n, i) {
+            function mk(t, e, n, i) {
                 var r, o, a, s, c = (0, m.IX)(e.forces);
-                for (r = 0, o = rk.length; r < o; ++r)(a = rk[r]) !== ik && e.modified(a) && t[a](e[a]);
-                for (r = 0, o = c.length; r < o; ++r) s = ik + r, (a = n || e.modified(ik, r) ? uk(c[r]) : i && lk(c[r], i) ? t.force(s) : null) && t.force(s, a);
-                for (o = t.numForces || 0; r < o; ++r) t.force(ik + r, null);
+                for (r = 0, o = fk.length; r < o; ++r)(a = fk[r]) !== uk && e.modified(a) && t[a](e[a]);
+                for (r = 0, o = c.length; r < o; ++r) s = uk + r, (a = n || e.modified(uk, r) ? vk(c[r]) : i && gk(c[r], i) ? t.force(s) : null) && t.force(s, a);
+                for (o = t.numForces || 0; r < o; ++r) t.force(uk + r, null);
                 return t.numForces = c.length, t
             }
 
-            function lk(t, e) {
+            function gk(t, e) {
                 var n, i;
                 for (n in t)
                     if ((0, m.mf)(i = t[n]) && e.modified((0, m.Oj)(i))) return 1;
                 return 0
             }
 
-            function uk(t) {
+            function vk(t) {
                 var e, n;
-                for (n in (0, m.nr)(nk, t.force) || (0, m.vU)("Unrecognized force: " + t.force), e = nk[t.force](), t)(0, m.mf)(e[n]) && fk(e[n], t[n], t);
+                for (n in (0, m.nr)(lk, t.force) || (0, m.vU)("Unrecognized force: " + t.force), e = lk[t.force](), t)(0, m.mf)(e[n]) && yk(e[n], t[n], t);
                 return e
             }
 
-            function fk(t, e, n) {
+            function yk(t, e, n) {
                 t((0, m.mf)(e) ? t => e(t, n) : e)
             }
 
-            function dk(t) {
+            function bk(t) {
                 var e = 0,
                     n = t.children,
                     i = n && n.length;
                 if (i)
                     for (; --i >= 0;) e += n[i].value;
                 else e = 1;
                 t.value = e
             }
 
-            function hk(t, e) {
-                t instanceof Map ? (t = [void 0, t], void 0 === e && (e = mk)) : void 0 === e && (e = pk);
-                for (var n, i, r, o, a, s = new yk(t), c = [s]; n = c.pop();)
+            function xk(t, e) {
+                t instanceof Map ? (t = [void 0, t], void 0 === e && (e = wk)) : void 0 === e && (e = _k);
+                for (var n, i, r, o, a, s = new Ak(t), c = [s]; n = c.pop();)
                     if ((r = e(n.data)) && (a = (r = Array.from(r)).length))
-                        for (n.children = r, o = a - 1; o >= 0; --o) c.push(i = r[o] = new yk(r[o])), i.parent = n, i.depth = n.depth + 1;
-                return s.eachBefore(vk)
+                        for (n.children = r, o = a - 1; o >= 0; --o) c.push(i = r[o] = new Ak(r[o])), i.parent = n, i.depth = n.depth + 1;
+                return s.eachBefore(Ek)
             }
 
-            function pk(t) {
+            function _k(t) {
                 return t.children
             }
 
-            function mk(t) {
+            function wk(t) {
                 return Array.isArray(t) ? t[1] : null
             }
 
-            function gk(t) {
+            function kk(t) {
                 void 0 !== t.data.value && (t.value = t.data.value), t.data = t.data.data
             }
 
-            function vk(t) {
+            function Ek(t) {
                 var e = 0;
                 do {
                     t.height = e
                 } while ((t = t.parent) && t.height < ++e)
             }
 
-            function yk(t) {
+            function Ak(t) {
                 this.data = t, this.depth = this.height = 0, this.parent = null
             }
 
-            function bk(t) {
-                return null == t ? null : xk(t)
+            function Dk(t) {
+                return null == t ? null : Sk(t)
             }
 
-            function xk(t) {
+            function Sk(t) {
                 if ("function" !== typeof t) throw new Error;
                 return t
             }
 
-            function _k() {
+            function Ck() {
                 return 0
             }
 
-            function wk(t) {
+            function Mk(t) {
                 return function() {
                     return t
                 }
             }
-            sk.Definition = {
+            pk.Definition = {
                 type: "Force",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "static",
                     type: "boolean",
@@ -34709,48 +34846,48 @@
                         }]
                     }]
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     modify: !1,
-                    default: ak
+                    default: hk
                 }]
-            }, (0, m.XW)(sk, Rr, {
+            }, (0, m.XW)(pk, zr, {
                 transform(t, e) {
                     var n, i, r = this.value,
                         o = e.changed(e.ADD_REM),
-                        a = t.modified(rk),
+                        a = t.modified(fk),
                         s = t.iterations || 300;
-                    if (r ? (o && (e.modifies("index"), r.nodes(e.source)), (a || e.changed(e.MOD)) && ck(r, t, 0, e)) : (this.value = r = function(t, e) {
-                            const n = Qw(t),
+                    if (r ? (o && (e.modifies("index"), r.nodes(e.source)), (a || e.changed(e.MOD)) && mk(r, t, 0, e)) : (this.value = r = function(t, e) {
+                            const n = ak(t),
                                 i = n.stop,
                                 r = n.restart;
                             let o = !1;
-                            return n.stopped = () => o, n.restart = () => (o = !1, r()), n.stop = () => (o = !0, i()), ck(n, e, !0).on("end", (() => o = !0))
-                        }(e.source, t), r.on("tick", (n = e.dataflow, i = this, () => n.touch(i).run())), t.static || (o = !0, r.tick()), e.modifies("index")), a || o || t.modified(ok) || e.changed() && t.restart)
+                            return n.stopped = () => o, n.restart = () => (o = !1, r()), n.stop = () => (o = !0, i()), mk(n, e, !0).on("end", (() => o = !0))
+                        }(e.source, t), r.on("tick", (n = e.dataflow, i = this, () => n.touch(i).run())), t.static || (o = !0, r.tick()), e.modifies("index")), a || o || t.modified(dk) || e.changed() && t.restart)
                         if (r.alpha(Math.max(r.alpha(), t.alpha || 1)).alphaDecay(1 - Math.pow(r.alphaMin(), 1 / s)), t.static)
                             for (r.stop(); --s >= 0;) r.tick();
                         else if (r.stopped() && r.restart(), !o) return e.StopPropagation;
                     return this.finish(t, e)
                 },
                 finish(t, e) {
                     const n = e.dataflow;
                     for (let s, c = this._argops, l = 0, u = c.length; l < u; ++l)
-                        if (s = c[l], s.name === ik && "link" === s.op._argval.force)
+                        if (s = c[l], s.name === uk && "link" === s.op._argval.force)
                             for (var i, r = s.op._argops, o = 0, a = r.length; o < a; ++o)
                                 if ("links" === r[o].name && (i = r[o].op.source)) {
                                     n.pulse(i, n.changeset().reflow());
                                     break
-                                } return e.reflow(t.modified()).modifies(ak)
+                                } return e.reflow(t.modified()).modifies(hk)
                 }
-            }), yk.prototype = hk.prototype = {
-                constructor: yk,
+            }), Ak.prototype = xk.prototype = {
+                constructor: Ak,
                 count: function() {
-                    return this.eachAfter(dk)
+                    return this.eachAfter(bk)
                 },
                 each: function(t, e) {
                     let n = -1;
                     for (const i of this) t.call(e, i, ++n, this);
                     return this
                 },
                 eachAfter: function(t, e) {
@@ -34815,88 +34952,88 @@
                         n !== t && e.push({
                             source: n.parent,
                             target: n
                         })
                     })), e
                 },
                 copy: function() {
-                    return hk(this).eachBefore(gk)
+                    return xk(this).eachBefore(kk)
                 },
                 [Symbol.iterator]: function*() {
                     var t, e, n, i, r = this,
                         o = [r];
                     do {
                         for (t = o.reverse(), o = []; r = t.pop();)
                             if (yield r, e = r.children)
                                 for (n = 0, i = e.length; n < i; ++n) o.push(e[n])
                     } while (o.length)
                 }
             };
-            const kk = 1664525,
-                Ek = 1013904223,
-                Dk = 4294967296;
+            const Fk = 1664525,
+                Ok = 1013904223,
+                Tk = 4294967296;
 
-            function Ak(t, e) {
+            function Nk(t, e) {
                 for (var n, i, r = 0, o = (t = function(t, e) {
                         let n, i, r = t.length;
                         for (; r;) i = e() * r-- | 0, n = t[r], t[r] = t[i], t[i] = n;
                         return t
-                    }(Array.from(t), e)).length, a = []; r < o;) n = t[r], i && Fk(i, n) ? ++r : (i = Ok(a = Sk(a, n)), r = 0);
+                    }(Array.from(t), e)).length, a = []; r < o;) n = t[r], i && Pk(i, n) ? ++r : (i = Bk(a = Rk(a, n)), r = 0);
                 return i
             }
 
-            function Sk(t, e) {
+            function Rk(t, e) {
                 var n, i;
-                if (Mk(e, t)) return [e];
+                if (Lk(e, t)) return [e];
                 for (n = 0; n < t.length; ++n)
-                    if (Ck(e, t[n]) && Mk(Tk(t[n], e), t)) return [t[n], e];
+                    if (zk(e, t[n]) && Lk(Ik(t[n], e), t)) return [t[n], e];
                 for (n = 0; n < t.length - 1; ++n)
                     for (i = n + 1; i < t.length; ++i)
-                        if (Ck(Tk(t[n], t[i]), e) && Ck(Tk(t[n], e), t[i]) && Ck(Tk(t[i], e), t[n]) && Mk(Nk(t[n], t[i], e), t)) return [t[n], t[i], e];
+                        if (zk(Ik(t[n], t[i]), e) && zk(Ik(t[n], e), t[i]) && zk(Ik(t[i], e), t[n]) && Lk(jk(t[n], t[i], e), t)) return [t[n], t[i], e];
                 throw new Error
             }
 
-            function Ck(t, e) {
+            function zk(t, e) {
                 var n = t.r - e.r,
                     i = e.x - t.x,
                     r = e.y - t.y;
                 return n < 0 || n * n < i * i + r * r
             }
 
-            function Fk(t, e) {
+            function Pk(t, e) {
                 var n = t.r - e.r + 1e-9 * Math.max(t.r, e.r, 1),
                     i = e.x - t.x,
                     r = e.y - t.y;
                 return n > 0 && n * n > i * i + r * r
             }
 
-            function Mk(t, e) {
+            function Lk(t, e) {
                 for (var n = 0; n < e.length; ++n)
-                    if (!Fk(t, e[n])) return !1;
+                    if (!Pk(t, e[n])) return !1;
                 return !0
             }
 
-            function Ok(t) {
+            function Bk(t) {
                 switch (t.length) {
                     case 1:
                         return function(t) {
                             return {
                                 x: t.x,
                                 y: t.y,
                                 r: t.r
                             }
                         }(t[0]);
                     case 2:
-                        return Tk(t[0], t[1]);
+                        return Ik(t[0], t[1]);
                     case 3:
-                        return Nk(t[0], t[1], t[2])
+                        return jk(t[0], t[1], t[2])
                 }
             }
 
-            function Tk(t, e) {
+            function Ik(t, e) {
                 var n = t.x,
                     i = t.y,
                     r = t.r,
                     o = e.x,
                     a = e.y,
                     s = e.r,
                     c = o - n,
@@ -34906,15 +35043,15 @@
                 return {
                     x: (n + o + c / f * u) / 2,
                     y: (i + a + l / f * u) / 2,
                     r: (f + r + s) / 2
                 }
             }
 
-            function Nk(t, e, n) {
+            function jk(t, e, n) {
                 var i = t.x,
                     r = t.y,
                     o = t.r,
                     a = e.x,
                     s = e.y,
                     c = e.r,
                     l = n.x,
@@ -34929,251 +35066,251 @@
                     y = i * i + r * r - o * o,
                     b = y - a * a - s * s + c * c,
                     x = y - l * l - u * u + f * f,
                     _ = h * p - d * m,
                     w = (p * x - m * b) / (2 * _) - i,
                     k = (m * g - p * v) / _,
                     E = (h * b - d * x) / (2 * _) - r,
-                    D = (d * v - h * g) / _,
-                    A = k * k + D * D - 1,
-                    S = 2 * (o + w * k + E * D),
+                    A = (d * v - h * g) / _,
+                    D = k * k + A * A - 1,
+                    S = 2 * (o + w * k + E * A),
                     C = w * w + E * E - o * o,
-                    F = -(Math.abs(A) > 1e-6 ? (S + Math.sqrt(S * S - 4 * A * C)) / (2 * A) : C / S);
+                    M = -(Math.abs(D) > 1e-6 ? (S + Math.sqrt(S * S - 4 * D * C)) / (2 * D) : C / S);
                 return {
-                    x: i + w + k * F,
-                    y: r + E + D * F,
-                    r: F
+                    x: i + w + k * M,
+                    y: r + E + A * M,
+                    r: M
                 }
             }
 
-            function zk(t, e, n) {
+            function Uk(t, e, n) {
                 var i, r, o, a, s = t.x - e.x,
                     c = t.y - e.y,
                     l = s * s + c * c;
                 l ? (r = e.r + n.r, r *= r, a = t.r + n.r, r > (a *= a) ? (i = (l + a - r) / (2 * l), o = Math.sqrt(Math.max(0, a / l - i * i)), n.x = t.x - i * s - o * c, n.y = t.y - i * c + o * s) : (i = (l + r - a) / (2 * l), o = Math.sqrt(Math.max(0, r / l - i * i)), n.x = e.x + i * s - o * c, n.y = e.y + i * c + o * s)) : (n.x = e.x + n.r, n.y = e.y)
             }
 
-            function Rk(t, e) {
+            function qk(t, e) {
                 var n = t.r + e.r - 1e-6,
                     i = e.x - t.x,
                     r = e.y - t.y;
                 return n > 0 && n * n > i * i + r * r
             }
 
-            function Pk(t) {
+            function Wk(t) {
                 var e = t._,
                     n = t.next._,
                     i = e.r + n.r,
                     r = (e.x * n.r + n.x * e.r) / i,
                     o = (e.y * n.r + n.y * e.r) / i;
                 return r * r + o * o
             }
 
-            function Lk(t) {
+            function Hk(t) {
                 this._ = t, this.next = null, this.previous = null
             }
 
-            function jk(t, e) {
+            function Xk(t, e) {
                 if (!(o = (t = function(t) {
                         return "object" === typeof t && "length" in t ? t : Array.from(t)
                     }(t)).length)) return 0;
                 var n, i, r, o, a, s, c, l, u, f, d;
                 if ((n = t[0]).x = 0, n.y = 0, !(o > 1)) return n.r;
                 if (i = t[1], n.x = -i.r, i.x = n.r, i.y = 0, !(o > 2)) return n.r + i.r;
-                zk(i, n, r = t[2]), n = new Lk(n), i = new Lk(i), r = new Lk(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
+                Uk(i, n, r = t[2]), n = new Hk(n), i = new Hk(i), r = new Hk(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
                 t: for (c = 3; c < o; ++c) {
-                    zk(n._, i._, r = t[c]), r = new Lk(r), l = i.next, u = n.previous, f = i._.r, d = n._.r;
+                    Uk(n._, i._, r = t[c]), r = new Hk(r), l = i.next, u = n.previous, f = i._.r, d = n._.r;
                     do {
                         if (f <= d) {
-                            if (Rk(l._, r._)) {
+                            if (qk(l._, r._)) {
                                 i = l, n.next = i, i.previous = n, --c;
                                 continue t
                             }
                             f += l._.r, l = l.next
                         } else {
-                            if (Rk(u._, r._)) {
+                            if (qk(u._, r._)) {
                                 (n = u).next = i, i.previous = n, --c;
                                 continue t
                             }
                             d += u._.r, u = u.previous
                         }
                     } while (l !== u.next);
-                    for (r.previous = n, r.next = i, n.next = i.previous = i = r, a = Pk(n);
-                        (r = r.next) !== i;)(s = Pk(r)) < a && (n = r, a = s);
+                    for (r.previous = n, r.next = i, n.next = i.previous = i = r, a = Wk(n);
+                        (r = r.next) !== i;)(s = Wk(r)) < a && (n = r, a = s);
                     i = n.next
                 }
                 for (n = [i._], r = i;
                     (r = r.next) !== i;) n.push(r._);
-                for (r = Ak(n, e), c = 0; c < o; ++c)(n = t[c]).x -= r.x, n.y -= r.y;
+                for (r = Nk(n, e), c = 0; c < o; ++c)(n = t[c]).x -= r.x, n.y -= r.y;
                 return r.r
             }
 
-            function Bk(t) {
+            function Gk(t) {
                 return Math.sqrt(t.value)
             }
 
-            function Ik(t) {
+            function Jk(t) {
                 return function(e) {
                     e.children || (e.r = Math.max(0, +t(e) || 0))
                 }
             }
 
-            function Uk(t, e, n) {
+            function Zk(t, e, n) {
                 return function(i) {
                     if (r = i.children) {
                         var r, o, a, s = r.length,
                             c = t(i) * e || 0;
                         if (c)
                             for (o = 0; o < s; ++o) r[o].r += c;
-                        if (a = jk(r, n), c)
+                        if (a = Xk(r, n), c)
                             for (o = 0; o < s; ++o) r[o].r -= c;
                         i.r = a + c
                     }
                 }
             }
 
-            function qk(t) {
+            function $k(t) {
                 return function(e) {
                     var n = e.parent;
                     e.r *= t, n && (e.x = n.x + t * e.x, e.y = n.y + t * e.y)
                 }
             }
 
-            function Wk(t) {
+            function Yk(t) {
                 t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1)
             }
 
-            function Hk(t, e, n, i, r) {
+            function Vk(t, e, n, i, r) {
                 for (var o, a = t.children, s = -1, c = a.length, l = t.value && (i - e) / t.value; ++s < c;)(o = a[s]).y0 = n, o.y1 = r, o.x0 = e, o.x1 = e += o.value * l
             }
-            var Xk = {
+            var Kk = {
                     depth: -1
                 },
-                Jk = {},
-                Gk = {};
+                Qk = {},
+                tE = {};
 
-            function $k(t) {
+            function eE(t) {
                 return t.id
             }
 
-            function Zk(t) {
+            function nE(t) {
                 return t.parentId
             }
 
-            function Yk() {
-                var t, e = $k,
-                    n = Zk;
+            function iE() {
+                var t, e = eE,
+                    n = nE;
 
                 function i(i) {
                     var r, o, a, s, c, l, u, f, d = Array.from(i),
                         h = e,
                         p = n,
                         m = new Map;
                     if (null != t) {
                         const e = d.map(((e, n) => function(t) {
                                 t = "".concat(t);
                                 let e = t.length;
-                                Kk(t, e - 1) && !Kk(t, e - 2) && (t = t.slice(0, -1));
+                                oE(t, e - 1) && !oE(t, e - 2) && (t = t.slice(0, -1));
                                 return "/" === t[0] ? t : "/".concat(t)
                             }(t(e, n, i)))),
-                            n = e.map(Vk),
+                            n = e.map(rE),
                             r = new Set(e).add("");
-                        for (const t of n) r.has(t) || (r.add(t), e.push(t), n.push(Vk(t)), d.push(Gk));
+                        for (const t of n) r.has(t) || (r.add(t), e.push(t), n.push(rE(t)), d.push(tE));
                         h = (t, n) => e[n], p = (t, e) => n[e]
                     }
-                    for (a = 0, r = d.length; a < r; ++a) o = d[a], l = d[a] = new yk(o), null != (u = h(o, a, i)) && (u += "") && (f = l.id = u, m.set(f, m.has(f) ? Jk : l)), null != (u = p(o, a, i)) && (u += "") && (l.parent = u);
+                    for (a = 0, r = d.length; a < r; ++a) o = d[a], l = d[a] = new Ak(o), null != (u = h(o, a, i)) && (u += "") && (f = l.id = u, m.set(f, m.has(f) ? Qk : l)), null != (u = p(o, a, i)) && (u += "") && (l.parent = u);
                     for (a = 0; a < r; ++a)
                         if (u = (l = d[a]).parent) {
                             if (!(c = m.get(u))) throw new Error("missing: " + u);
-                            if (c === Jk) throw new Error("ambiguous: " + u);
+                            if (c === Qk) throw new Error("ambiguous: " + u);
                             c.children ? c.children.push(l) : c.children = [l], l.parent = c
                         } else {
                             if (s) throw new Error("multiple roots");
                             s = l
                         } if (!s) throw new Error("no root");
                     if (null != t) {
-                        for (; s.data === Gk && 1 === s.children.length;) s = s.children[0], --r;
-                        for (let t = d.length - 1; t >= 0 && (l = d[t]).data === Gk; --t) l.data = null
+                        for (; s.data === tE && 1 === s.children.length;) s = s.children[0], --r;
+                        for (let t = d.length - 1; t >= 0 && (l = d[t]).data === tE; --t) l.data = null
                     }
-                    if (s.parent = Xk, s.eachBefore((function(t) {
+                    if (s.parent = Kk, s.eachBefore((function(t) {
                             t.depth = t.parent.depth + 1, --r
-                        })).eachBefore(vk), s.parent = null, r > 0) throw new Error("cycle");
+                        })).eachBefore(Ek), s.parent = null, r > 0) throw new Error("cycle");
                     return s
                 }
                 return i.id = function(t) {
-                    return arguments.length ? (e = bk(t), i) : e
+                    return arguments.length ? (e = Dk(t), i) : e
                 }, i.parentId = function(t) {
-                    return arguments.length ? (n = bk(t), i) : n
+                    return arguments.length ? (n = Dk(t), i) : n
                 }, i.path = function(e) {
-                    return arguments.length ? (t = bk(e), i) : t
+                    return arguments.length ? (t = Dk(e), i) : t
                 }, i
             }
 
-            function Vk(t) {
+            function rE(t) {
                 let e = t.length;
                 if (e < 2) return "";
-                for (; --e > 1 && !Kk(t, e););
+                for (; --e > 1 && !oE(t, e););
                 return t.slice(0, e)
             }
 
-            function Kk(t, e) {
+            function oE(t, e) {
                 if ("/" === t[e]) {
                     let n = 0;
                     for (; e > 0 && "\\" === t[--e];) ++n;
                     if (0 === (1 & n)) return !0
                 }
                 return !1
             }
 
-            function Qk(t, e) {
+            function aE(t, e) {
                 return t.parent === e.parent ? 1 : 2
             }
 
-            function tE(t) {
+            function sE(t) {
                 var e = t.children;
                 return e ? e[0] : t.t
             }
 
-            function eE(t) {
+            function cE(t) {
                 var e = t.children;
                 return e ? e[e.length - 1] : t.t
             }
 
-            function nE(t, e, n) {
+            function lE(t, e, n) {
                 var i = n / (e.i - t.i);
                 e.c -= i, e.s += n, t.c += i, e.z += n, e.m += n
             }
 
-            function iE(t, e, n) {
+            function uE(t, e, n) {
                 return t.a.parent === e.parent ? t.a : n
             }
 
-            function rE(t, e) {
+            function fE(t, e) {
                 this._ = t, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = e
             }
 
-            function oE(t, e) {
+            function dE(t, e) {
                 return t.parent === e.parent ? 1 : 2
             }
 
-            function aE(t, e) {
+            function hE(t, e) {
                 return t + e.x
             }
 
-            function sE(t, e) {
+            function pE(t, e) {
                 return Math.max(t, e.y)
             }
 
-            function cE(t, e, n, i, r) {
+            function mE(t, e, n, i, r) {
                 for (var o, a = t.children, s = -1, c = a.length, l = t.value && (r - n) / t.value; ++s < c;)(o = a[s]).x0 = e, o.x1 = i, o.y0 = n, o.y1 = n += o.value * l
             }
-            rE.prototype = Object.create(yk.prototype);
-            var lE = (1 + Math.sqrt(5)) / 2;
+            fE.prototype = Object.create(Ak.prototype);
+            var gE = (1 + Math.sqrt(5)) / 2;
 
-            function uE(t, e, n, i, r, o) {
+            function vE(t, e, n, i, r, o) {
                 for (var a, s, c, l, u, f, d, h, p, m, g, v = [], y = e.children, b = 0, x = 0, _ = y.length, w = e.value; b < _;) {
                     c = r - n, l = o - i;
                     do {
                         u = y[x++].value
                     } while (!u && x < _);
                     for (f = d = u, g = u * u * (m = Math.max(l / c, c / l) / (w * t)), p = Math.max(d / g, g / f); x < _; ++x) {
                         if (u += s = y[x].value, s < f && (f = s), s > d && (d = s), g = u * u * m, (h = Math.max(d / g, g / f)) > p) {
@@ -35182,68 +35319,68 @@
                         }
                         p = h
                     }
                     v.push(a = {
                         value: u,
                         dice: c < l,
                         children: y.slice(b, x)
-                    }), a.dice ? Hk(a, n, i, r, w ? i += l * u / w : o) : cE(a, n, i, w ? n += c * u / w : r, o), w -= u, b = x
+                    }), a.dice ? Vk(a, n, i, r, w ? i += l * u / w : o) : mE(a, n, i, w ? n += c * u / w : r, o), w -= u, b = x
                 }
                 return v
             }
-            const fE = function t(e) {
+            const yE = function t(e) {
                     function n(t, n, i, r, o) {
-                        uE(e, t, n, i, r, o)
+                        vE(e, t, n, i, r, o)
                     }
                     return n.ratio = function(e) {
                         return t((e = +e) > 1 ? e : 1)
                     }, n
-                }(lE),
-                dE = function t(e) {
+                }(gE),
+                bE = function t(e) {
                     function n(t, n, i, r, o) {
                         if ((a = t._squarify) && a.ratio === e)
                             for (var a, s, c, l, u, f = -1, d = a.length, h = t.value; ++f < d;) {
                                 for (c = (s = a[f]).children, l = s.value = 0, u = c.length; l < u; ++l) s.value += c[l].value;
-                                s.dice ? Hk(s, n, i, r, h ? i += (o - i) * s.value / h : o) : cE(s, n, i, h ? n += (r - n) * s.value / h : r, o), h -= s.value
-                            } else t._squarify = a = uE(e, t, n, i, r, o), a.ratio = e
+                                s.dice ? Vk(s, n, i, r, h ? i += (o - i) * s.value / h : o) : mE(s, n, i, h ? n += (r - n) * s.value / h : r, o), h -= s.value
+                            } else t._squarify = a = vE(e, t, n, i, r, o), a.ratio = e
                     }
                     return n.ratio = function(e) {
                         return t((e = +e) > 1 ? e : 1)
                     }, n
-                }(lE);
+                }(gE);
 
-            function hE(t, e, n) {
+            function xE(t, e, n) {
                 const i = {};
                 return t.each((t => {
                     const r = t.data;
                     n(r) && (i[e(r)] = t)
                 })), t.lookup = i, t
             }
 
-            function pE(t) {
-                Rr.call(this, null, t)
+            function _E(t) {
+                zr.call(this, null, t)
             }
-            pE.Definition = {
+            _E.Definition = {
                 type: "Nest",
                 metadata: {
                     treesource: !0,
                     changes: !0
                 },
                 params: [{
                     name: "keys",
                     type: "field",
                     array: !0
                 }, {
                     name: "generate",
                     type: "boolean"
                 }]
             };
-            const mE = t => t.values;
+            const wE = t => t.values;
 
-            function gE() {
+            function kE() {
                 const t = [],
                     e = {
                         entries: t => i(n(t, 0), 0),
                         key: n => (t.push(n), e)
                     };
 
                 function n(e, i) {
@@ -35266,63 +35403,63 @@
                         values: i(e[t], n)
                     });
                     return r
                 }
                 return e
             }
 
-            function vE(t) {
-                Rr.call(this, null, t)
-            }(0, m.XW)(pE, Rr, {
+            function EE(t) {
+                zr.call(this, null, t)
+            }(0, m.XW)(_E, zr, {
                 transform(t, e) {
                     e.source || (0, m.vU)("Nest transform requires an upstream data source.");
                     var n = t.generate,
                         i = t.modified(),
                         r = e.clone(),
                         o = this.value;
                     return (!o || i || e.changed()) && (o && o.each((t => {
                         t.children && er(t.data) && r.rem.push(t.data)
-                    })), this.value = o = hk({
-                        values: (0, m.IX)(t.keys).reduce(((t, e) => (t.key(e), t)), gE()).entries(r.source)
-                    }, mE), n && o.each((t => {
+                    })), this.value = o = xk({
+                        values: (0, m.IX)(t.keys).reduce(((t, e) => (t.key(e), t)), kE()).entries(r.source)
+                    }, wE), n && o.each((t => {
                         t.children && (t = rr(t.data), r.add.push(t), r.source.push(t))
-                    })), hE(o, nr, nr)), r.source.root = o, r
+                    })), xE(o, nr, nr)), r.source.root = o, r
                 }
             });
-            const yE = (t, e) => t.parent === e.parent ? 1 : 2;
-            (0, m.XW)(vE, Rr, {
+            const AE = (t, e) => t.parent === e.parent ? 1 : 2;
+            (0, m.XW)(EE, zr, {
                 transform(t, e) {
                     e.source && e.source.root || (0, m.vU)(this.constructor.name + " transform requires a backing tree data source.");
                     const n = this.layout(t.method),
                         i = this.fields,
                         r = e.source.root,
                         o = t.as || i;
                     t.field ? r.sum(t.field) : r.count(), t.sort && r.sort(cr(t.sort, (t => t.data))),
                         function(t, e, n) {
                             for (let i, r = 0, o = e.length; r < o; ++r) i = e[r], i in n && t[i](n[i])
-                        }(n, this.params, t), n.separation && n.separation(!1 !== t.separation ? yE : m.kX);
+                        }(n, this.params, t), n.separation && n.separation(!1 !== t.separation ? AE : m.kX);
                     try {
                         this.value = n(r)
                     } catch (a) {
                         (0, m.vU)(a)
                     }
                     return r.each((t => function(t, e, n) {
                         const i = t.data,
                             r = e.length - 1;
                         for (let o = 0; o < r; ++o) i[n[o]] = t[e[o]];
                         i[n[r]] = t.children ? t.children.length : 0
                     }(t, i, o))), e.reflow(t.modified()).modifies(o).modifies("leaf")
                 }
             });
-            const bE = ["x", "y", "r", "depth", "children"];
+            const DE = ["x", "y", "r", "depth", "children"];
 
-            function xE(t) {
-                vE.call(this, t)
+            function SE(t) {
+                EE.call(this, t)
             }
-            xE.Definition = {
+            SE.Definition = {
                 type: "Pack",
                 metadata: {
                     tree: !0,
                     modifies: !0
                 },
                 params: [{
                     name: "field",
@@ -35343,52 +35480,52 @@
                     type: "number",
                     array: !0,
                     length: 2
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
-                    length: bE.length,
-                    default: bE
+                    length: DE.length,
+                    default: DE
                 }]
-            }, (0, m.XW)(xE, vE, {
+            }, (0, m.XW)(SE, EE, {
                 layout: function() {
                     var t = null,
                         e = 1,
                         n = 1,
-                        i = _k;
+                        i = Ck;
 
                     function r(r) {
                         const o = function() {
                             let t = 1;
-                            return () => (t = (kk * t + Ek) % Dk) / Dk
+                            return () => (t = (Fk * t + Ok) % Tk) / Tk
                         }();
-                        return r.x = e / 2, r.y = n / 2, t ? r.eachBefore(Ik(t)).eachAfter(Uk(i, .5, o)).eachBefore(qk(1)) : r.eachBefore(Ik(Bk)).eachAfter(Uk(_k, 1, o)).eachAfter(Uk(i, r.r / Math.min(e, n), o)).eachBefore(qk(Math.min(e, n) / (2 * r.r))), r
+                        return r.x = e / 2, r.y = n / 2, t ? r.eachBefore(Jk(t)).eachAfter(Zk(i, .5, o)).eachBefore($k(1)) : r.eachBefore(Jk(Gk)).eachAfter(Zk(Ck, 1, o)).eachAfter(Zk(i, r.r / Math.min(e, n), o)).eachBefore($k(Math.min(e, n) / (2 * r.r))), r
                     }
                     return r.radius = function(e) {
-                        return arguments.length ? (t = bk(e), r) : t
+                        return arguments.length ? (t = Dk(e), r) : t
                     }, r.size = function(t) {
                         return arguments.length ? (e = +t[0], n = +t[1], r) : [e, n]
                     }, r.padding = function(t) {
-                        return arguments.length ? (i = "function" === typeof t ? t : wk(+t), r) : i
+                        return arguments.length ? (i = "function" === typeof t ? t : Mk(+t), r) : i
                     }, r
                 },
                 params: ["radius", "size", "padding"],
-                fields: bE
+                fields: DE
             });
-            const _E = ["x0", "y0", "x1", "y1", "depth", "children"];
+            const CE = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-            function wE(t) {
-                vE.call(this, t)
+            function ME(t) {
+                EE.call(this, t)
             }
 
-            function kE(t) {
-                Rr.call(this, null, t)
+            function FE(t) {
+                zr.call(this, null, t)
             }
-            wE.Definition = {
+            ME.Definition = {
                 type: "Partition",
                 metadata: {
                     tree: !0,
                     modifies: !0
                 },
                 params: [{
                     name: "field",
@@ -35409,84 +35546,84 @@
                     type: "number",
                     array: !0,
                     length: 2
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
-                    length: _E.length,
-                    default: _E
+                    length: CE.length,
+                    default: CE
                 }]
-            }, (0, m.XW)(wE, vE, {
+            }, (0, m.XW)(ME, EE, {
                 layout: function() {
                     var t = 1,
                         e = 1,
                         n = 0,
                         i = !1;
 
                     function r(r) {
                         var o = r.height + 1;
                         return r.x0 = r.y0 = n, r.x1 = t, r.y1 = e / o, r.eachBefore(function(t, e) {
                             return function(i) {
-                                i.children && Hk(i, i.x0, t * (i.depth + 1) / e, i.x1, t * (i.depth + 2) / e);
+                                i.children && Vk(i, i.x0, t * (i.depth + 1) / e, i.x1, t * (i.depth + 2) / e);
                                 var r = i.x0,
                                     o = i.y0,
                                     a = i.x1 - n,
                                     s = i.y1 - n;
                                 a < r && (r = a = (r + a) / 2), s < o && (o = s = (o + s) / 2), i.x0 = r, i.y0 = o, i.x1 = a, i.y1 = s
                             }
-                        }(e, o)), i && r.eachBefore(Wk), r
+                        }(e, o)), i && r.eachBefore(Yk), r
                     }
                     return r.round = function(t) {
                         return arguments.length ? (i = !!t, r) : i
                     }, r.size = function(n) {
                         return arguments.length ? (t = +n[0], e = +n[1], r) : [t, e]
                     }, r.padding = function(t) {
                         return arguments.length ? (n = +t, r) : n
                     }, r
                 },
                 params: ["size", "round", "padding"],
-                fields: _E
-            }), kE.Definition = {
+                fields: CE
+            }), FE.Definition = {
                 type: "Stratify",
                 metadata: {
                     treesource: !0
                 },
                 params: [{
                     name: "key",
                     type: "field",
                     required: !0
                 }, {
                     name: "parentKey",
                     type: "field",
                     required: !0
                 }]
-            }, (0, m.XW)(kE, Rr, {
+            }, (0, m.XW)(FE, zr, {
                 transform(t, e) {
                     e.source || (0, m.vU)("Stratify transform requires an upstream data source.");
                     let n = this.value;
                     const i = t.modified(),
                         r = e.fork(e.ALL).materialize(e.SOURCE),
                         o = !n || i || e.changed(e.ADD_REM) || e.modified(t.key.fields) || e.modified(t.parentKey.fields);
-                    return r.source = r.source.slice(), o && (n = r.source.length ? hE(Yk().id(t.key).parentId(t.parentKey)(r.source), t.key, m.yb) : hE(Yk()([{}]), t.key, t.key)), r.source.root = this.value = n, r
+                    return r.source = r.source.slice(), o && (n = r.source.length ? xE(iE().id(t.key).parentId(t.parentKey)(r.source), t.key, m.yb) : xE(iE()([{}]), t.key, t.key)), r.source.root = this.value = n, r
                 }
             });
-            const EE = {
+            const OE = {
                     tidy: function() {
-                        var t = Qk,
+                        var t = aE,
                             e = 1,
                             n = 1,
                             i = null;
 
                         function r(r) {
                             var c = function(t) {
-                                for (var e, n, i, r, o, a = new rE(t, 0), s = [a]; e = s.pop();)
+                                for (var e, n, i, r, o, a = new fE(t, 0), s = [a]; e = s.pop();)
                                     if (i = e._.children)
-                                        for (e.children = new Array(o = i.length), r = o - 1; r >= 0; --r) s.push(n = e.children[r] = new rE(i[r], r)), n.parent = e;
-                                return (a.parent = new rE(null, 0)).children = [a], a
+                                        for (e.children = new Array(o = i.length), r = o - 1; r >= 0; --r) s.push(n = e.children[r] = new fE(i[r], r)), n.parent = e;
+                                return (a.parent = new fE(null, 0)).children = [a], a
                             }(r);
                             if (c.eachAfter(o), c.parent.m = -c.z, c.eachBefore(a), i) r.eachBefore(s);
                             else {
                                 var l = r,
                                     u = r,
                                     f = r;
                                 r.eachBefore((function(t) {
@@ -35512,16 +35649,16 @@
                                     for (var e, n = 0, i = 0, r = t.children, o = r.length; --o >= 0;)(e = r[o]).z += n, e.m += n, n += e.s + (i += e.c)
                                 }(e);
                                 var o = (n[0].z + n[n.length - 1].z) / 2;
                                 r ? (e.z = r.z + t(e._, r._), e.m = e.z - o) : e.z = o
                             } else r && (e.z = r.z + t(e._, r._));
                             e.parent.A = function(e, n, i) {
                                 if (n) {
-                                    for (var r, o = e, a = e, s = n, c = o.parent.children[0], l = o.m, u = a.m, f = s.m, d = c.m; s = eE(s), o = tE(o), s && o;) c = tE(c), (a = eE(a)).a = e, (r = s.z + f - o.z - l + t(s._, o._)) > 0 && (nE(iE(s, e, i), e, r), l += r, u += r), f += s.m, l += o.m, d += c.m, u += a.m;
-                                    s && !eE(a) && (a.t = s, a.m += f - u), o && !tE(c) && (c.t = o, c.m += l - d, i = e)
+                                    for (var r, o = e, a = e, s = n, c = o.parent.children[0], l = o.m, u = a.m, f = s.m, d = c.m; s = cE(s), o = sE(o), s && o;) c = sE(c), (a = cE(a)).a = e, (r = s.z + f - o.z - l + t(s._, o._)) > 0 && (lE(uE(s, e, i), e, r), l += r, u += r), f += s.m, l += o.m, d += c.m, u += a.m;
+                                    s && !cE(a) && (a.t = s, a.m += f - u), o && !sE(c) && (c.t = o, c.m += l - d, i = e)
                                 }
                                 return i
                             }(e, r, e.parent.A || i[0])
                         }
 
                         function a(t) {
                             t._.x = t.z + t.parent.m, t.m += t.parent.m
@@ -35535,27 +35672,27 @@
                         }, r.size = function(t) {
                             return arguments.length ? (i = !1, e = +t[0], n = +t[1], r) : i ? null : [e, n]
                         }, r.nodeSize = function(t) {
                             return arguments.length ? (i = !0, e = +t[0], n = +t[1], r) : i ? [e, n] : null
                         }, r
                     },
                     cluster: function() {
-                        var t = oE,
+                        var t = dE,
                             e = 1,
                             n = 1,
                             i = !1;
 
                         function r(r) {
                             var o, a = 0;
                             r.eachAfter((function(e) {
                                 var n = e.children;
                                 n ? (e.x = function(t) {
-                                    return t.reduce(aE, 0) / t.length
+                                    return t.reduce(hE, 0) / t.length
                                 }(n), e.y = function(t) {
-                                    return 1 + t.reduce(sE, 0)
+                                    return 1 + t.reduce(pE, 0)
                                 }(n)) : (e.x = o ? a += t(e, o) : 0, e.y = 0, o = e)
                             }));
                             var s = function(t) {
                                     for (var e; e = t.children;) t = e[0];
                                     return t
                                 }(r),
                                 c = function(t) {
@@ -35575,24 +35712,24 @@
                         }, r.size = function(t) {
                             return arguments.length ? (i = !1, e = +t[0], n = +t[1], r) : i ? null : [e, n]
                         }, r.nodeSize = function(t) {
                             return arguments.length ? (i = !0, e = +t[0], n = +t[1], r) : i ? [e, n] : null
                         }, r
                     }
                 },
-                DE = ["x", "y", "depth", "children"];
+                TE = ["x", "y", "depth", "children"];
 
-            function AE(t) {
-                vE.call(this, t)
+            function NE(t) {
+                EE.call(this, t)
             }
 
-            function SE(t) {
-                Rr.call(this, [], t)
+            function RE(t) {
+                zr.call(this, [], t)
             }
-            AE.Definition = {
+            NE.Definition = {
                 type: "Tree",
                 metadata: {
                     tree: !0,
                     modifies: !0
                 },
                 params: [{
                     name: "field",
@@ -35619,34 +35756,34 @@
                     name: "separation",
                     type: "boolean",
                     default: !0
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
-                    length: DE.length,
-                    default: DE
+                    length: TE.length,
+                    default: TE
                 }]
-            }, (0, m.XW)(AE, vE, {
+            }, (0, m.XW)(NE, EE, {
                 layout(t) {
                     const e = t || "tidy";
-                    if ((0, m.nr)(EE, e)) return EE[e]();
+                    if ((0, m.nr)(OE, e)) return OE[e]();
                     (0, m.vU)("Unrecognized Tree layout method: " + e)
                 },
                 params: ["size", "nodeSize"],
-                fields: DE
-            }), SE.Definition = {
+                fields: TE
+            }), RE.Definition = {
                 type: "TreeLinks",
                 metadata: {
                     tree: !0,
                     generates: !0,
                     changes: !0
                 },
                 params: []
-            }, (0, m.XW)(SE, Rr, {
+            }, (0, m.XW)(RE, zr, {
                 transform(t, e) {
                     const n = this.value,
                         i = e.source && e.source.root,
                         r = e.fork(e.NO_SOURCE),
                         o = {};
                     return i || (0, m.vU)("TreeLinks transform requires a tree data source."), e.changed(e.ADD_REM) ? (r.rem = n, e.visit(e.SOURCE, (t => o[nr(t)] = 1)), i.each((t => {
                         const e = t.data,
@@ -35656,15 +35793,15 @@
                             target: e
                         }))
                     })), this.value = r.add) : e.changed(e.MOD) && (e.visit(e.MOD, (t => o[nr(t)] = 1)), n.forEach((t => {
                         (o[nr(t.source)] || o[nr(t.target)]) && r.mod.push(t)
                     }))), r
                 }
             });
-            const CE = {
+            const zE = {
                     binary: function(t, e, n, i, r) {
                         var o, a, s = t.children,
                             c = s.length,
                             l = new Array(c + 1);
                         for (l[0] = a = o = 0; o < c; ++o) l[o + 1] = a += s[o].value;
                         ! function t(e, n, i, r, o, a, c) {
                             if (e >= n - 1) {
@@ -35687,28 +35824,28 @@
                                 t(e, h, g, r, o, y, c), t(h, n, v, y, o, a, c)
                             } else {
                                 var b = i ? (o * v + c * g) / i : c;
                                 t(e, h, g, r, o, a, b), t(h, n, v, r, b, a, c)
                             }
                         }(0, c, t.value, e, n, i, r)
                     },
-                    dice: Hk,
-                    slice: cE,
+                    dice: Vk,
+                    slice: mE,
                     slicedice: function(t, e, n, i, r) {
-                        (1 & t.depth ? cE : Hk)(t, e, n, i, r)
+                        (1 & t.depth ? mE : Vk)(t, e, n, i, r)
                     },
-                    squarify: fE,
-                    resquarify: dE
+                    squarify: yE,
+                    resquarify: bE
                 },
-                FE = ["x0", "y0", "x1", "y1", "depth", "children"];
+                PE = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-            function ME(t) {
-                vE.call(this, t)
+            function LE(t) {
+                EE.call(this, t)
             }
-            ME.Definition = {
+            LE.Definition = {
                 type: "Treemap",
                 metadata: {
                     tree: !0,
                     modifies: !0
                 },
                 params: [{
                     name: "field",
@@ -35762,33 +35899,33 @@
                     type: "number",
                     array: !0,
                     length: 2
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
-                    length: FE.length,
-                    default: FE
+                    length: PE.length,
+                    default: PE
                 }]
-            }, (0, m.XW)(ME, vE, {
+            }, (0, m.XW)(LE, EE, {
                 layout() {
                     const t = function() {
-                        var t = fE,
+                        var t = yE,
                             e = !1,
                             n = 1,
                             i = 1,
                             r = [0],
-                            o = _k,
-                            a = _k,
-                            s = _k,
-                            c = _k,
-                            l = _k;
+                            o = Ck,
+                            a = Ck,
+                            s = Ck,
+                            c = Ck,
+                            l = Ck;
 
                         function u(t) {
-                            return t.x0 = t.y0 = 0, t.x1 = n, t.y1 = i, t.eachBefore(f), r = [0], e && t.eachBefore(Wk), t
+                            return t.x0 = t.y0 = 0, t.x1 = n, t.y1 = i, t.eachBefore(f), r = [0], e && t.eachBefore(Yk), t
                         }
 
                         function f(e) {
                             var n = r[e.depth],
                                 i = e.x0 + n,
                                 u = e.y0 + n,
                                 f = e.x1 - n,
@@ -35796,175 +35933,175 @@
                             f < i && (i = f = (i + f) / 2), d < u && (u = d = (u + d) / 2), e.x0 = i, e.y0 = u, e.x1 = f, e.y1 = d, e.children && (n = r[e.depth + 1] = o(e) / 2, i += l(e) - n, u += a(e) - n, (f -= s(e) - n) < i && (i = f = (i + f) / 2), (d -= c(e) - n) < u && (u = d = (u + d) / 2), t(e, i, u, f, d))
                         }
                         return u.round = function(t) {
                             return arguments.length ? (e = !!t, u) : e
                         }, u.size = function(t) {
                             return arguments.length ? (n = +t[0], i = +t[1], u) : [n, i]
                         }, u.tile = function(e) {
-                            return arguments.length ? (t = xk(e), u) : t
+                            return arguments.length ? (t = Sk(e), u) : t
                         }, u.padding = function(t) {
                             return arguments.length ? u.paddingInner(t).paddingOuter(t) : u.paddingInner()
                         }, u.paddingInner = function(t) {
-                            return arguments.length ? (o = "function" === typeof t ? t : wk(+t), u) : o
+                            return arguments.length ? (o = "function" === typeof t ? t : Mk(+t), u) : o
                         }, u.paddingOuter = function(t) {
                             return arguments.length ? u.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t) : u.paddingTop()
                         }, u.paddingTop = function(t) {
-                            return arguments.length ? (a = "function" === typeof t ? t : wk(+t), u) : a
+                            return arguments.length ? (a = "function" === typeof t ? t : Mk(+t), u) : a
                         }, u.paddingRight = function(t) {
-                            return arguments.length ? (s = "function" === typeof t ? t : wk(+t), u) : s
+                            return arguments.length ? (s = "function" === typeof t ? t : Mk(+t), u) : s
                         }, u.paddingBottom = function(t) {
-                            return arguments.length ? (c = "function" === typeof t ? t : wk(+t), u) : c
+                            return arguments.length ? (c = "function" === typeof t ? t : Mk(+t), u) : c
                         }, u.paddingLeft = function(t) {
-                            return arguments.length ? (l = "function" === typeof t ? t : wk(+t), u) : l
+                            return arguments.length ? (l = "function" === typeof t ? t : Mk(+t), u) : l
                         }, u
                     }();
                     return t.ratio = e => {
                         const n = t.tile();
                         n.ratio && t.tile(n.ratio(e))
                     }, t.method = e => {
-                        (0, m.nr)(CE, e) ? t.tile(CE[e]): (0, m.vU)("Unrecognized Treemap layout method: " + e)
+                        (0, m.nr)(zE, e) ? t.tile(zE[e]): (0, m.vU)("Unrecognized Treemap layout method: " + e)
                     }, t
                 },
                 params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
-                fields: FE
+                fields: PE
             });
-            const OE = 4278190080;
+            const BE = 4278190080;
 
-            function TE(t, e, n) {
+            function IE(t, e, n) {
                 return new Uint32Array(t.getImageData(0, 0, e, n).data.buffer)
             }
 
-            function NE(t, e, n) {
+            function jE(t, e, n) {
                 if (!e.length) return;
                 const i = e[0].mark.marktype;
                 "group" === i ? e.forEach((e => {
-                    e.items.forEach((e => NE(t, e.items, n)))
-                })) : Xp[i].draw(t, {
-                    items: n ? e.map(zE) : e
+                    e.items.forEach((e => jE(t, e.items, n)))
+                })) : am[i].draw(t, {
+                    items: n ? e.map(UE) : e
                 })
             }
 
-            function zE(t) {
+            function UE(t) {
                 const e = ar(t, {});
                 return e.stroke && 0 !== e.strokeOpacity || e.fill && 0 !== e.fillOpacity ? {
                     ...e,
                     strokeOpacity: 1,
                     stroke: "#000",
                     fillOpacity: 0
                 } : e
             }
-            const RE = 5,
-                PE = 31,
-                LE = 32,
-                jE = new Uint32Array(LE + 1),
-                BE = new Uint32Array(LE + 1);
-            BE[0] = 0, jE[0] = ~BE[0];
-            for (let GN = 1; GN <= LE; ++GN) BE[GN] = BE[GN - 1] << 1 | 1, jE[GN] = ~BE[GN];
+            const qE = 5,
+                WE = 31,
+                HE = 32,
+                XE = new Uint32Array(HE + 1),
+                GE = new Uint32Array(HE + 1);
+            GE[0] = 0, XE[0] = ~GE[0];
+            for (let _q = 1; _q <= HE; ++_q) GE[_q] = GE[_q - 1] << 1 | 1, XE[_q] = ~GE[_q];
 
-            function IE(t, e, n) {
+            function JE(t, e, n) {
                 const i = Math.max(1, Math.sqrt(t * e / 1e6)),
                     r = ~~((t + 2 * n + i) / i),
                     o = ~~((e + 2 * n + i) / i),
                     a = t => ~~((t + n) / i);
                 return a.invert = t => t * i - n, a.bitmap = () => function(t, e) {
-                    const n = new Uint32Array(~~((t * e + LE) / LE));
+                    const n = new Uint32Array(~~((t * e + HE) / HE));
 
                     function i(t, e) {
                         n[t] |= e
                     }
 
                     function r(t, e) {
                         n[t] &= e
                     }
                     return {
                         array: n,
                         get: (e, i) => {
                             const r = i * t + e;
-                            return n[r >>> RE] & 1 << (r & PE)
+                            return n[r >>> qE] & 1 << (r & WE)
                         },
                         set: (e, n) => {
                             const r = n * t + e;
-                            i(r >>> RE, 1 << (r & PE))
+                            i(r >>> qE, 1 << (r & WE))
                         },
                         clear: (e, n) => {
                             const i = n * t + e;
-                            r(i >>> RE, ~(1 << (i & PE)))
+                            r(i >>> qE, ~(1 << (i & WE)))
                         },
                         getRange: (e, i, r, o) => {
                             let a, s, c, l, u = o;
                             for (; u >= i; --u)
-                                if (a = u * t + e, s = u * t + r, c = a >>> RE, l = s >>> RE, c === l) {
-                                    if (n[c] & jE[a & PE] & BE[1 + (s & PE)]) return !0
+                                if (a = u * t + e, s = u * t + r, c = a >>> qE, l = s >>> qE, c === l) {
+                                    if (n[c] & XE[a & WE] & GE[1 + (s & WE)]) return !0
                                 } else {
-                                    if (n[c] & jE[a & PE]) return !0;
-                                    if (n[l] & BE[1 + (s & PE)]) return !0;
+                                    if (n[c] & XE[a & WE]) return !0;
+                                    if (n[l] & GE[1 + (s & WE)]) return !0;
                                     for (let t = c + 1; t < l; ++t)
                                         if (n[t]) return !0
                                 } return !1
                         },
                         setRange: (e, n, r, o) => {
                             let a, s, c, l, u;
                             for (; n <= o; ++n)
-                                if (a = n * t + e, s = n * t + r, c = a >>> RE, l = s >>> RE, c === l) i(c, jE[a & PE] & BE[1 + (s & PE)]);
+                                if (a = n * t + e, s = n * t + r, c = a >>> qE, l = s >>> qE, c === l) i(c, XE[a & WE] & GE[1 + (s & WE)]);
                                 else
-                                    for (i(c, jE[a & PE]), i(l, BE[1 + (s & PE)]), u = c + 1; u < l; ++u) i(u, 4294967295)
+                                    for (i(c, XE[a & WE]), i(l, GE[1 + (s & WE)]), u = c + 1; u < l; ++u) i(u, 4294967295)
                         },
                         clearRange: (e, n, i, o) => {
                             let a, s, c, l, u;
                             for (; n <= o; ++n)
-                                if (a = n * t + e, s = n * t + i, c = a >>> RE, l = s >>> RE, c === l) r(c, BE[a & PE] | jE[1 + (s & PE)]);
+                                if (a = n * t + e, s = n * t + i, c = a >>> qE, l = s >>> qE, c === l) r(c, GE[a & WE] | XE[1 + (s & WE)]);
                                 else
-                                    for (r(c, BE[a & PE]), r(l, jE[1 + (s & PE)]), u = c + 1; u < l; ++u) r(u, 0)
+                                    for (r(c, GE[a & WE]), r(l, XE[1 + (s & WE)]), u = c + 1; u < l; ++u) r(u, 0)
                         },
                         outOfBounds: (n, i, r, o) => n < 0 || i < 0 || o >= e || r >= t
                     }
                 }(r, o), a.ratio = i, a.padding = n, a.width = t, a.height = e, a
             }
 
-            function UE(t, e, n, i, r, o) {
+            function ZE(t, e, n, i, r, o) {
                 let a = n / 2;
                 return t - a < 0 || t + a > r || e - (a = i / 2) < 0 || e + a > o
             }
 
-            function qE(t, e, n, i, r, o, a, s) {
+            function $E(t, e, n, i, r, o, a, s) {
                 const c = r * o / (2 * i),
                     l = t(e - c),
                     u = t(e + c),
                     f = t(n - (o /= 2)),
                     d = t(n + o);
                 return a.outOfBounds(l, f, u, d) || a.getRange(l, f, u, d) || s && s.getRange(l, f, u, d)
             }
-            const WE = [-1, -1, 1, 1],
-                HE = [-1, 1, -1, 1];
-            const XE = ["right", "center", "left"],
-                JE = ["bottom", "middle", "top"];
+            const YE = [-1, -1, 1, 1],
+                VE = [-1, 1, -1, 1];
+            const KE = ["right", "center", "left"],
+                QE = ["bottom", "middle", "top"];
 
-            function GE(t, e, n, i, r, o, a, s, c, l, u, f) {
+            function tA(t, e, n, i, r, o, a, s, c, l, u, f) {
                 return !(r.outOfBounds(t, n, e, i) || (f && o || r).getRange(t, n, e, i))
             }
-            const $E = {
+            const eA = {
                     "top-left": 0,
                     top: 1,
                     "top-right": 2,
                     left: 4,
                     middle: 5,
                     right: 6,
                     "bottom-left": 8,
                     bottom: 9,
                     "bottom-right": 10
                 },
-                ZE = {
+                nA = {
                     naive: function(t, e, n, i) {
                         const r = t.width,
                             o = t.height;
                         return function(t) {
                             const e = t.datum.datum.items[i].items,
                                 n = e.length,
                                 a = t.datum.fontSize,
-                                s = Dp.width(t.datum, t.datum.text);
+                                s = jp.width(t.datum, t.datum.text);
                             let c, l, u, f, d, h, p, m = 0;
                             for (let i = 0; i < n; ++i) c = e[i].x, u = e[i].y, l = void 0 === e[i].x2 ? c : e[i].x2, f = void 0 === e[i].y2 ? u : e[i].y2, d = (c + l) / 2, h = (u + f) / 2, p = Math.abs(l - c + f - u), p >= m && (m = p, t.x = d, t.y = h);
                             return d = s / 2, h = a / 2, c = t.x - d, l = t.x + d, u = t.y - h, f = t.y + h, t.align = "center", c < 0 && l <= r ? t.align = "left" : 0 <= c && r < l && (t.align = "right"), t.baseline = "middle", u < 0 && f <= o ? t.baseline = "top" : 0 <= u && o < f && (t.baseline = "bottom"), !0
                         }
                     },
                     "reduced-search": function(t, e, n, i) {
                         const r = t.width,
@@ -35973,84 +36110,84 @@
                             s = e[1];
 
                         function c(e, n, i, c, l) {
                             const u = t.invert(e),
                                 f = t.invert(n);
                             let d, h = i,
                                 p = o;
-                            if (!UE(u, f, c, l, r, o) && !qE(t, u, f, l, c, h, a, s) && !qE(t, u, f, l, c, l, a, null)) {
-                                for (; p - h >= 1;) d = (h + p) / 2, qE(t, u, f, l, c, d, a, s) ? p = d : h = d;
+                            if (!ZE(u, f, c, l, r, o) && !$E(t, u, f, l, c, h, a, s) && !$E(t, u, f, l, c, l, a, null)) {
+                                for (; p - h >= 1;) d = (h + p) / 2, $E(t, u, f, l, c, d, a, s) ? p = d : h = d;
                                 if (h > i) return [u, f, h, !0]
                             }
                         }
                         return function(e) {
                             const s = e.datum.datum.items[i].items,
                                 l = s.length,
                                 u = e.datum.fontSize,
-                                f = Dp.width(e.datum, e.datum.text);
-                            let d, h, p, m, g, v, y, b, x, _, w, k, E, D, A, S, C, F = n ? u : 0,
-                                M = !1,
+                                f = jp.width(e.datum, e.datum.text);
+                            let d, h, p, m, g, v, y, b, x, _, w, k, E, A, D, S, C, M = n ? u : 0,
+                                F = !1,
                                 O = !1,
                                 T = 0;
                             for (let i = 0; i < l; ++i) {
-                                for (d = s[i].x, p = s[i].y, h = void 0 === s[i].x2 ? d : s[i].x2, m = void 0 === s[i].y2 ? p : s[i].y2, d > h && (C = d, d = h, h = C), p > m && (C = p, p = m, m = C), x = t(d), w = t(h), _ = ~~((x + w) / 2), k = t(p), D = t(m), E = ~~((k + D) / 2), y = _; y >= x; --y)
-                                    for (b = E; b >= k; --b) S = c(y, b, F, f, u), S && ([e.x, e.y, F, M] = S);
+                                for (d = s[i].x, p = s[i].y, h = void 0 === s[i].x2 ? d : s[i].x2, m = void 0 === s[i].y2 ? p : s[i].y2, d > h && (C = d, d = h, h = C), p > m && (C = p, p = m, m = C), x = t(d), w = t(h), _ = ~~((x + w) / 2), k = t(p), A = t(m), E = ~~((k + A) / 2), y = _; y >= x; --y)
+                                    for (b = E; b >= k; --b) S = c(y, b, M, f, u), S && ([e.x, e.y, M, F] = S);
                                 for (y = _; y <= w; ++y)
-                                    for (b = E; b <= D; ++b) S = c(y, b, F, f, u), S && ([e.x, e.y, F, M] = S);
-                                M || n || (A = Math.abs(h - d + m - p), g = (d + h) / 2, v = (p + m) / 2, A >= T && !UE(g, v, f, u, r, o) && !qE(t, g, v, u, f, u, a, null) && (T = A, e.x = g, e.y = v, O = !0))
+                                    for (b = E; b <= A; ++b) S = c(y, b, M, f, u), S && ([e.x, e.y, M, F] = S);
+                                F || n || (D = Math.abs(h - d + m - p), g = (d + h) / 2, v = (p + m) / 2, D >= T && !ZE(g, v, f, u, r, o) && !$E(t, g, v, u, f, u, a, null) && (T = D, e.x = g, e.y = v, O = !0))
                             }
-                            return !(!M && !O) && (g = f / 2, v = u / 2, a.setRange(t(e.x - g), t(e.y - v), t(e.x + g), t(e.y + v)), e.align = "center", e.baseline = "middle", !0)
+                            return !(!F && !O) && (g = f / 2, v = u / 2, a.setRange(t(e.x - g), t(e.y - v), t(e.x + g), t(e.y + v)), e.align = "center", e.baseline = "middle", !0)
                         }
                     },
                     floodfill: function(t, e, n, i) {
                         const r = t.width,
                             o = t.height,
                             a = e[0],
                             s = e[1],
                             c = t.bitmap();
                         return function(e) {
                             const l = e.datum.datum.items[i].items,
                                 u = l.length,
                                 f = e.datum.fontSize,
-                                d = Dp.width(e.datum, e.datum.text),
+                                d = jp.width(e.datum, e.datum.text),
                                 h = [];
-                            let p, m, g, v, y, b, x, _, w, k, E, D, A = n ? f : 0,
+                            let p, m, g, v, y, b, x, _, w, k, E, A, D = n ? f : 0,
                                 S = !1,
                                 C = !1,
-                                F = 0;
+                                M = 0;
                             for (let i = 0; i < u; ++i) {
                                 for (p = l[i].x, g = l[i].y, m = void 0 === l[i].x2 ? p : l[i].x2, v = void 0 === l[i].y2 ? g : l[i].y2, h.push([t((p + m) / 2), t((g + v) / 2)]); h.length;)
                                     if ([x, _] = h.pop(), !(a.get(x, _) || s.get(x, _) || c.get(x, _))) {
                                         c.set(x, _);
-                                        for (let t = 0; t < 4; ++t) y = x + WE[t], b = _ + HE[t], c.outOfBounds(y, b, y, b) || h.push([y, b]);
-                                        if (y = t.invert(x), b = t.invert(_), w = A, k = o, !UE(y, b, d, f, r, o) && !qE(t, y, b, f, d, w, a, s) && !qE(t, y, b, f, d, f, a, null)) {
-                                            for (; k - w >= 1;) E = (w + k) / 2, qE(t, y, b, f, d, E, a, s) ? k = E : w = E;
-                                            w > A && (e.x = y, e.y = b, A = w, S = !0)
+                                        for (let t = 0; t < 4; ++t) y = x + YE[t], b = _ + VE[t], c.outOfBounds(y, b, y, b) || h.push([y, b]);
+                                        if (y = t.invert(x), b = t.invert(_), w = D, k = o, !ZE(y, b, d, f, r, o) && !$E(t, y, b, f, d, w, a, s) && !$E(t, y, b, f, d, f, a, null)) {
+                                            for (; k - w >= 1;) E = (w + k) / 2, $E(t, y, b, f, d, E, a, s) ? k = E : w = E;
+                                            w > D && (e.x = y, e.y = b, D = w, S = !0)
                                         }
-                                    } S || n || (D = Math.abs(m - p + v - g), y = (p + m) / 2, b = (g + v) / 2, D >= F && !UE(y, b, d, f, r, o) && !qE(t, y, b, f, d, f, a, null) && (F = D, e.x = y, e.y = b, C = !0))
+                                    } S || n || (A = Math.abs(m - p + v - g), y = (p + m) / 2, b = (g + v) / 2, A >= M && !ZE(y, b, d, f, r, o) && !$E(t, y, b, f, d, f, a, null) && (M = A, e.x = y, e.y = b, C = !0))
                             }
                             return !(!S && !C) && (y = d / 2, b = f / 2, a.setRange(t(e.x - y), t(e.y - b), t(e.x + y), t(e.y + b)), e.align = "center", e.baseline = "middle", !0)
                         }
                     }
                 };
 
-            function YE(t, e, n, i, r, o, a, s, c, l, u) {
+            function iA(t, e, n, i, r, o, a, s, c, l, u) {
                 if (!t.length) return t;
                 const f = Math.max(i.length, r.length),
                     d = function(t, e) {
                         const n = new Float64Array(e),
                             i = t.length;
                         for (let r = 0; r < i; ++r) n[r] = t[r] || 0;
                         for (let r = i; r < e; ++r) n[r] = n[i - 1];
                         return n
                     }(i, f),
                     h = function(t, e) {
                         const n = new Int8Array(e),
                             i = t.length;
-                        for (let r = 0; r < i; ++r) n[r] |= $E[t[r]];
+                        for (let r = 0; r < i; ++r) n[r] |= eA[t[r]];
                         for (let r = i; r < e; ++r) n[r] = n[i - 1];
                         return n
                     }(r, f),
                     p = (x = t[0].datum) && x.mark && x.mark.marktype,
                     m = "group" === p && t[0].datum.items[c].marktype,
                     g = "area" === m,
                     v = function(t, e, n, i) {
@@ -36068,102 +36205,102 @@
                     }(p, m, s, c),
                     y = null === l || l === 1 / 0,
                     b = g && "naive" === u;
                 var x;
                 let _ = -1,
                     w = -1;
                 const k = t.map((t => {
-                    const e = y ? Dp.width(t, t.text) : void 0;
+                    const e = y ? jp.width(t, t.text) : void 0;
                     return _ = Math.max(_, e), w = Math.max(w, t.fontSize), {
                         datum: t,
                         opacity: 0,
                         x: void 0,
                         y: void 0,
                         align: void 0,
                         baseline: void 0,
                         boundary: v(t),
                         textWidth: e
                     }
                 }));
                 l = null === l || l === 1 / 0 ? Math.max(_, w) + Math.max(...i) : l;
-                const E = IE(e[0], e[1], l);
-                let D;
+                const E = JE(e[0], e[1], l);
+                let A;
                 if (!b) {
                     n && k.sort(((t, e) => n(t.datum, e.datum)));
                     let e = !1;
                     for (let t = 0; t < h.length && !e; ++t) e = 5 === h[t] || d[t] < 0;
                     const i = (p && a || g) && t.map((t => t.datum));
-                    D = o.length || i ? function(t, e, n, i, r) {
+                    A = o.length || i ? function(t, e, n, i, r) {
                         const o = t.width,
                             a = t.height,
                             s = i || r,
-                            c = Xc(o, a).getContext("2d"),
-                            l = Xc(o, a).getContext("2d"),
-                            u = s && Xc(o, a).getContext("2d");
-                        n.forEach((t => NE(c, t, !1))), NE(l, e, !1), s && NE(u, e, !0);
-                        const f = TE(c, o, a),
-                            d = TE(l, o, a),
-                            h = s && TE(u, o, a),
+                            c = il(o, a).getContext("2d"),
+                            l = il(o, a).getContext("2d"),
+                            u = s && il(o, a).getContext("2d");
+                        n.forEach((t => jE(c, t, !1))), jE(l, e, !1), s && jE(u, e, !0);
+                        const f = IE(c, o, a),
+                            d = IE(l, o, a),
+                            h = s && IE(u, o, a),
                             p = t.bitmap(),
                             m = s && t.bitmap();
                         let g, v, y, b, x, _, w, k;
                         for (v = 0; v < a; ++v)
-                            for (g = 0; g < o; ++g) x = v * o + g, _ = f[x] & OE, k = d[x] & OE, w = s && h[x] & OE, (_ || w || k) && (y = t(g), b = t(v), r || !_ && !k || p.set(y, b), s && (_ || w) && m.set(y, b));
+                            for (g = 0; g < o; ++g) x = v * o + g, _ = f[x] & BE, k = d[x] & BE, w = s && h[x] & BE, (_ || w || k) && (y = t(g), b = t(v), r || !_ && !k || p.set(y, b), s && (_ || w) && m.set(y, b));
                         return [p, m]
                     }(E, i || [], o, e, g) : function(t, e) {
                         const n = t.bitmap();
                         return (e || []).forEach((e => n.set(t(e.boundary[0]), t(e.boundary[3])))), [n, void 0]
                     }(E, a && k)
                 }
-                const A = g ? ZE[u](E, D, a, c) : function(t, e, n, i) {
+                const D = g ? nA[u](E, A, a, c) : function(t, e, n, i) {
                     const r = t.width,
                         o = t.height,
                         a = e[0],
                         s = e[1],
                         c = i.length;
                     return function(e) {
                         var l;
                         const u = e.boundary,
                             f = e.datum.fontSize;
                         if (u[2] < 0 || u[5] < 0 || u[0] > r || u[3] > o) return !1;
-                        let d, h, p, m, g, v, y, b, x, _, w, k, E, D, A, S = null !== (l = e.textWidth) && void 0 !== l ? l : 0;
+                        let d, h, p, m, g, v, y, b, x, _, w, k, E, A, D, S = null !== (l = e.textWidth) && void 0 !== l ? l : 0;
                         for (let r = 0; r < c; ++r) {
-                            if (d = (3 & n[r]) - 1, h = (n[r] >>> 2 & 3) - 1, p = 0 === d && 0 === h || i[r] < 0, m = d && h ? Math.SQRT1_2 : 1, g = i[r] < 0 ? -1 : 1, v = u[1 + d] + i[r] * d * m, w = u[4 + h] + g * f * h / 2 + i[r] * h * m, b = w - f / 2, x = w + f / 2, k = t(v), D = t(b), A = t(x), !S) {
-                                if (!GE(k, k, D, A, a, s, 0, 0, 0, 0, 0, p)) continue;
-                                S = Dp.width(e.datum, e.datum.text)
+                            if (d = (3 & n[r]) - 1, h = (n[r] >>> 2 & 3) - 1, p = 0 === d && 0 === h || i[r] < 0, m = d && h ? Math.SQRT1_2 : 1, g = i[r] < 0 ? -1 : 1, v = u[1 + d] + i[r] * d * m, w = u[4 + h] + g * f * h / 2 + i[r] * h * m, b = w - f / 2, x = w + f / 2, k = t(v), A = t(b), D = t(x), !S) {
+                                if (!tA(k, k, A, D, a, s, 0, 0, 0, 0, 0, p)) continue;
+                                S = jp.width(e.datum, e.datum.text)
                             }
-                            if (_ = v + g * S * d / 2, v = _ - S / 2, y = _ + S / 2, k = t(v), E = t(y), GE(k, E, D, A, a, s, 0, 0, 0, 0, 0, p)) return e.x = d ? d * g < 0 ? y : v : _, e.y = h ? h * g < 0 ? x : b : w, e.align = XE[d * g + 1], e.baseline = JE[h * g + 1], a.setRange(k, D, E, A), !0
+                            if (_ = v + g * S * d / 2, v = _ - S / 2, y = _ + S / 2, k = t(v), E = t(y), tA(k, E, A, D, a, s, 0, 0, 0, 0, 0, p)) return e.x = d ? d * g < 0 ? y : v : _, e.y = h ? h * g < 0 ? x : b : w, e.align = KE[d * g + 1], e.baseline = QE[h * g + 1], a.setRange(k, A, E, D), !0
                         }
                         return !1
                     }
-                }(E, D, h, d);
-                return k.forEach((t => t.opacity = +A(t))), k
+                }(E, A, h, d);
+                return k.forEach((t => t.opacity = +D(t))), k
             }
-            const VE = ["x", "y", "opacity", "align", "baseline"],
-                KE = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
+            const rA = ["x", "y", "opacity", "align", "baseline"],
+                oA = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
 
-            function QE(t) {
-                Rr.call(this, null, t)
+            function aA(t) {
+                zr.call(this, null, t)
             }
 
-            function tD(t, e) {
+            function sA(t, e) {
                 var n, i, r, o, a, s, c = [],
                     l = function(t) {
                         return t(o)
                     };
                 if (null == e) c.push(t);
                 else
                     for (n = {}, i = 0, r = t.length; i < r; ++i) o = t[i], (s = n[a = e.map(l)]) || (n[a] = s = [], s.dims = a, c.push(s)), s.push(o);
                 return c
             }
 
-            function eD(t) {
-                Rr.call(this, null, t)
+            function cA(t) {
+                zr.call(this, null, t)
             }
-            QE.Definition = {
+            aA.Definition = {
                 type: "Label",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "size",
                     type: "number",
@@ -36173,15 +36310,15 @@
                 }, {
                     name: "sort",
                     type: "compare"
                 }, {
                     name: "anchor",
                     type: "string",
                     array: !0,
-                    default: KE
+                    default: oA
                 }, {
                     name: "offset",
                     type: "number",
                     array: !0,
                     default: [1]
                 }, {
                     name: "padding",
@@ -36209,32 +36346,32 @@
                     name: "method",
                     type: "string",
                     default: "naive"
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
-                    length: VE.length,
-                    default: VE
+                    length: rA.length,
+                    default: rA
                 }]
-            }, (0, m.XW)(QE, Rr, {
+            }, (0, m.XW)(aA, zr, {
                 transform(t, e) {
                     const n = t.modified();
                     if (!(n || e.changed(e.ADD_REM) || function(n) {
                             const i = t[n];
                             return (0, m.mf)(i) && e.modified(i.fields)
                         }("sort"))) return;
                     t.size && 2 === t.size.length || (0, m.vU)("Size parameter should be specified as a [width, height] array.");
-                    const i = t.as || VE;
-                    return YE(e.materialize(e.SOURCE).source || [], t.size, t.sort, (0, m.IX)(null == t.offset ? 1 : t.offset), (0, m.IX)(t.anchor || KE), t.avoidMarks || [], !1 !== t.avoidBaseMark, t.lineAnchor || "end", t.markIndex || 0, void 0 === t.padding ? 0 : t.padding, t.method || "naive").forEach((t => {
+                    const i = t.as || rA;
+                    return iA(e.materialize(e.SOURCE).source || [], t.size, t.sort, (0, m.IX)(null == t.offset ? 1 : t.offset), (0, m.IX)(t.anchor || oA), t.avoidMarks || [], !1 !== t.avoidBaseMark, t.lineAnchor || "end", t.markIndex || 0, void 0 === t.padding ? 0 : t.padding, t.method || "naive").forEach((t => {
                         const e = t.datum;
                         e[i[0]] = t.x, e[i[1]] = t.y, e[i[2]] = t.opacity, e[i[3]] = t.align, e[i[4]] = t.baseline
                     })), e.reflow(n).modifies(i)
                 }
-            }), eD.Definition = {
+            }), cA.Definition = {
                 type: "Loess",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "x",
                     type: "field",
@@ -36252,48 +36389,48 @@
                     type: "number",
                     default: .3
                 }, {
                     name: "as",
                     type: "string",
                     array: !0
                 }]
-            }, (0, m.XW)(eD, Rr, {
+            }, (0, m.XW)(cA, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE | e.NO_FIELDS);
                     if (!this.value || e.changed() || t.modified()) {
-                        const i = tD(e.materialize(e.SOURCE).source, t.groupby),
+                        const i = sA(e.materialize(e.SOURCE).source, t.groupby),
                             r = (t.groupby || []).map(m.el),
                             o = r.length,
                             a = t.as || [(0, m.el)(t.x), (0, m.el)(t.y)],
                             s = [];
                         i.forEach((e => {
-                            Ro(e, t.x, t.y, t.bandwidth || .3).forEach((t => {
+                            zo(e, t.x, t.y, t.bandwidth || .3).forEach((t => {
                                 const n = {};
                                 for (let i = 0; i < o; ++i) n[r[i]] = e.dims[i];
                                 n[a[0]] = t[0], n[a[1]] = t[1], s.push(rr(n))
                             }))
                         })), this.value && (n.rem = this.value), this.value = n.add = n.source = s
                     }
                     return n
                 }
             });
-            const nD = {
+            const lA = {
                 constant: _o,
-                linear: Ao,
+                linear: Do,
                 log: So,
                 exp: Co,
-                pow: Fo,
-                quad: Mo,
+                pow: Mo,
+                quad: Fo,
                 poly: Oo
             };
 
-            function iD(t) {
-                Rr.call(this, null, t)
+            function uA(t) {
+                zr.call(this, null, t)
             }
-            iD.Definition = {
+            uA.Definition = {
                 type: "Regression",
                 metadata: {
                     generates: !0
                 },
                 params: [{
                     name: "x",
                     type: "field",
@@ -36306,15 +36443,15 @@
                     name: "groupby",
                     type: "field",
                     array: !0
                 }, {
                     name: "method",
                     type: "string",
                     default: "linear",
-                    values: Object.keys(nD)
+                    values: Object.keys(lA)
                 }, {
                     name: "order",
                     type: "number",
                     default: 3
                 }, {
                     name: "extent",
                     type: "number",
@@ -36325,125 +36462,125 @@
                     type: "boolean",
                     default: !1
                 }, {
                     name: "as",
                     type: "string",
                     array: !0
                 }]
-            }, (0, m.XW)(iD, Rr, {
+            }, (0, m.XW)(uA, zr, {
                 transform(t, e) {
                     const n = e.fork(e.NO_SOURCE | e.NO_FIELDS);
                     if (!this.value || e.changed() || t.modified()) {
-                        const i = tD(e.materialize(e.SOURCE).source, t.groupby),
+                        const i = sA(e.materialize(e.SOURCE).source, t.groupby),
                             r = (t.groupby || []).map(m.el),
                             o = t.method || "linear",
                             a = null == t.order ? 3 : t.order,
                             s = ((t, e) => "poly" === t ? e : "quad" === t ? 2 : 1)(o, a),
                             c = t.as || [(0, m.el)(t.x), (0, m.el)(t.y)],
-                            l = nD[o],
+                            l = lA[o],
                             u = [];
                         let f = t.extent;
-                        (0, m.nr)(nD, o) || (0, m.vU)("Invalid regression method: " + o), null != f && "log" === o && f[0] <= 0 && (e.dataflow.warn("Ignoring extent with values <= 0 for log regression."), f = null), i.forEach((n => {
+                        (0, m.nr)(lA, o) || (0, m.vU)("Invalid regression method: " + o), null != f && "log" === o && f[0] <= 0 && (e.dataflow.warn("Ignoring extent with values <= 0 for log regression."), f = null), i.forEach((n => {
                             if (n.length <= s) return void e.dataflow.warn("Skipping regression with more parameters than data points.");
                             const i = l(n, t.x, t.y, a);
                             if (t.params) return void u.push(rr({
                                 keys: n.dims,
                                 coef: i.coef,
                                 rSquared: i.rSquared
                             }));
                             const d = f || (0, m.We)(n, t.x),
                                 h = t => {
                                     const e = {};
                                     for (let i = 0; i < r.length; ++i) e[r[i]] = n.dims[i];
                                     e[c[0]] = t[0], e[c[1]] = t[1], u.push(rr(e))
                                 };
-                            "linear" === o || "constant" === o ? d.forEach((t => h([t, i.predict(t)]))) : Bo(i.predict, d, 25, 200).forEach(h)
+                            "linear" === o || "constant" === o ? d.forEach((t => h([t, i.predict(t)]))) : Io(i.predict, d, 25, 200).forEach(h)
                         })), this.value && (n.rem = this.value), this.value = n.add = n.source = u
                     }
                     return n
                 }
             });
-            const rD = 134217729,
-                oD = 33306690738754706e-32;
+            const fA = 134217729,
+                dA = 33306690738754706e-32;
 
-            function aD(t, e, n, i, r) {
+            function hA(t, e, n, i, r) {
                 let o, a, s, c, l = e[0],
                     u = i[0],
                     f = 0,
                     d = 0;
                 u > l === u > -l ? (o = l, l = e[++f]) : (o = u, u = i[++d]);
                 let h = 0;
                 if (f < t && d < n)
                     for (u > l === u > -l ? (a = l + o, s = o - (a - l), l = e[++f]) : (a = u + o, s = o - (a - u), u = i[++d]), o = a, 0 !== s && (r[h++] = s); f < t && d < n;) u > l === u > -l ? (a = o + l, c = a - o, s = o - (a - c) + (l - c), l = e[++f]) : (a = o + u, c = a - o, s = o - (a - c) + (u - c), u = i[++d]), o = a, 0 !== s && (r[h++] = s);
                 for (; f < t;) a = o + l, c = a - o, s = o - (a - c) + (l - c), l = e[++f], o = a, 0 !== s && (r[h++] = s);
                 for (; d < n;) a = o + u, c = a - o, s = o - (a - c) + (u - c), u = i[++d], o = a, 0 !== s && (r[h++] = s);
                 return 0 === o && 0 !== h || (r[h++] = o), h
             }
 
-            function sD(t) {
+            function pA(t) {
                 return new Float64Array(t)
             }
-            const cD = 22204460492503146e-32,
-                lD = 11093356479670487e-47,
-                uD = sD(4),
-                fD = sD(8),
-                dD = sD(12),
-                hD = sD(16),
-                pD = sD(4);
+            const mA = 22204460492503146e-32,
+                gA = 11093356479670487e-47,
+                vA = pA(4),
+                yA = pA(8),
+                bA = pA(12),
+                xA = pA(16),
+                _A = pA(4);
 
-            function mD(t, e, n, i, r, o) {
+            function wA(t, e, n, i, r, o) {
                 const a = (e - o) * (n - r),
                     s = (t - r) * (i - o),
                     c = a - s;
                 if (0 === a || 0 === s || a > 0 !== s > 0) return c;
                 const l = Math.abs(a + s);
                 return Math.abs(c) >= 33306690738754716e-32 * l ? c : - function(t, e, n, i, r, o, a) {
                     let s, c, l, u, f, d, h, p, m, g, v, y, b, x, _, w, k, E;
-                    const D = t - r,
-                        A = n - r,
+                    const A = t - r,
+                        D = n - r,
                         S = e - o,
                         C = i - o;
-                    x = D * C, d = rD * D, h = d - (d - D), p = D - h, d = rD * C, m = d - (d - C), g = C - m, _ = p * g - (x - h * m - p * m - h * g), w = S * A, d = rD * S, h = d - (d - S), p = S - h, d = rD * A, m = d - (d - A), g = A - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, uD[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, uD[1] = b - (v + f) + (f - w), E = y + v, f = E - y, uD[2] = y - (E - f) + (v - f), uD[3] = E;
-                    let F = function(t, e) {
+                    x = A * C, d = fA * A, h = d - (d - A), p = A - h, d = fA * C, m = d - (d - C), g = C - m, _ = p * g - (x - h * m - p * m - h * g), w = S * D, d = fA * S, h = d - (d - S), p = S - h, d = fA * D, m = d - (d - D), g = D - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, vA[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, vA[1] = b - (v + f) + (f - w), E = y + v, f = E - y, vA[2] = y - (E - f) + (v - f), vA[3] = E;
+                    let M = function(t, e) {
                             let n = e[0];
                             for (let i = 1; i < t; i++) n += e[i];
                             return n
-                        }(4, uD),
-                        M = cD * a;
-                    if (F >= M || -F >= M) return F;
-                    if (f = t - D, s = t - (D + f) + (f - r), f = n - A, l = n - (A + f) + (f - r), f = e - S, c = e - (S + f) + (f - o), f = i - C, u = i - (C + f) + (f - o), 0 === s && 0 === c && 0 === l && 0 === u) return F;
-                    if (M = lD * a + oD * Math.abs(F), F += D * u + C * s - (S * l + A * c), F >= M || -F >= M) return F;
-                    x = s * C, d = rD * s, h = d - (d - s), p = s - h, d = rD * C, m = d - (d - C), g = C - m, _ = p * g - (x - h * m - p * m - h * g), w = c * A, d = rD * c, h = d - (d - c), p = c - h, d = rD * A, m = d - (d - A), g = A - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, pD[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, pD[1] = b - (v + f) + (f - w), E = y + v, f = E - y, pD[2] = y - (E - f) + (v - f), pD[3] = E;
-                    const O = aD(4, uD, 4, pD, fD);
-                    x = D * u, d = rD * D, h = d - (d - D), p = D - h, d = rD * u, m = d - (d - u), g = u - m, _ = p * g - (x - h * m - p * m - h * g), w = S * l, d = rD * S, h = d - (d - S), p = S - h, d = rD * l, m = d - (d - l), g = l - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, pD[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, pD[1] = b - (v + f) + (f - w), E = y + v, f = E - y, pD[2] = y - (E - f) + (v - f), pD[3] = E;
-                    const T = aD(O, fD, 4, pD, dD);
-                    x = s * u, d = rD * s, h = d - (d - s), p = s - h, d = rD * u, m = d - (d - u), g = u - m, _ = p * g - (x - h * m - p * m - h * g), w = c * l, d = rD * c, h = d - (d - c), p = c - h, d = rD * l, m = d - (d - l), g = l - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, pD[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, pD[1] = b - (v + f) + (f - w), E = y + v, f = E - y, pD[2] = y - (E - f) + (v - f), pD[3] = E;
-                    const N = aD(T, dD, 4, pD, hD);
-                    return hD[N - 1]
+                        }(4, vA),
+                        F = mA * a;
+                    if (M >= F || -M >= F) return M;
+                    if (f = t - A, s = t - (A + f) + (f - r), f = n - D, l = n - (D + f) + (f - r), f = e - S, c = e - (S + f) + (f - o), f = i - C, u = i - (C + f) + (f - o), 0 === s && 0 === c && 0 === l && 0 === u) return M;
+                    if (F = gA * a + dA * Math.abs(M), M += A * u + C * s - (S * l + D * c), M >= F || -M >= F) return M;
+                    x = s * C, d = fA * s, h = d - (d - s), p = s - h, d = fA * C, m = d - (d - C), g = C - m, _ = p * g - (x - h * m - p * m - h * g), w = c * D, d = fA * c, h = d - (d - c), p = c - h, d = fA * D, m = d - (d - D), g = D - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, _A[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, _A[1] = b - (v + f) + (f - w), E = y + v, f = E - y, _A[2] = y - (E - f) + (v - f), _A[3] = E;
+                    const O = hA(4, vA, 4, _A, yA);
+                    x = A * u, d = fA * A, h = d - (d - A), p = A - h, d = fA * u, m = d - (d - u), g = u - m, _ = p * g - (x - h * m - p * m - h * g), w = S * l, d = fA * S, h = d - (d - S), p = S - h, d = fA * l, m = d - (d - l), g = l - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, _A[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, _A[1] = b - (v + f) + (f - w), E = y + v, f = E - y, _A[2] = y - (E - f) + (v - f), _A[3] = E;
+                    const T = hA(O, yA, 4, _A, bA);
+                    x = s * u, d = fA * s, h = d - (d - s), p = s - h, d = fA * u, m = d - (d - u), g = u - m, _ = p * g - (x - h * m - p * m - h * g), w = c * l, d = fA * c, h = d - (d - c), p = c - h, d = fA * l, m = d - (d - l), g = l - m, k = p * g - (w - h * m - p * m - h * g), v = _ - k, f = _ - v, _A[0] = _ - (v + f) + (f - k), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - w, f = b - v, _A[1] = b - (v + f) + (f - w), E = y + v, f = E - y, _A[2] = y - (E - f) + (v - f), _A[3] = E;
+                    const N = hA(T, bA, 4, _A, xA);
+                    return xA[N - 1]
                 }(t, e, n, i, r, o, l)
             }
-            sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(8), sD(8), sD(8), sD(4), sD(8), sD(8), sD(8), sD(12);
-            sD(192), sD(192);
-            sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(8), sD(8), sD(8), sD(8), sD(8), sD(8), sD(8), sD(8), sD(8), sD(4), sD(4), sD(4), sD(8), sD(16), sD(16), sD(16), sD(32), sD(32), sD(48), sD(64);
-            sD(1152), sD(1152);
-            sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(4), sD(24), sD(24), sD(24), sD(24), sD(24), sD(24), sD(24), sD(24), sD(24), sD(24), sD(1152), sD(1152), sD(1152), sD(1152), sD(1152), sD(2304), sD(2304), sD(3456), sD(5760), sD(8), sD(8), sD(8), sD(16), sD(24), sD(48), sD(48), sD(96), sD(192), sD(384), sD(384), sD(384), sD(768);
-            sD(96), sD(96), sD(96), sD(1152);
-            const gD = Math.pow(2, -52),
-                vD = new Uint32Array(512);
-            class yD {
+            pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(8), pA(8), pA(8), pA(4), pA(8), pA(8), pA(8), pA(12);
+            pA(192), pA(192);
+            pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(8), pA(8), pA(8), pA(8), pA(8), pA(8), pA(8), pA(8), pA(8), pA(4), pA(4), pA(4), pA(8), pA(16), pA(16), pA(16), pA(32), pA(32), pA(48), pA(64);
+            pA(1152), pA(1152);
+            pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(4), pA(24), pA(24), pA(24), pA(24), pA(24), pA(24), pA(24), pA(24), pA(24), pA(24), pA(1152), pA(1152), pA(1152), pA(1152), pA(1152), pA(2304), pA(2304), pA(3456), pA(5760), pA(8), pA(8), pA(8), pA(16), pA(24), pA(48), pA(48), pA(96), pA(192), pA(384), pA(384), pA(384), pA(768);
+            pA(96), pA(96), pA(96), pA(1152);
+            const kA = Math.pow(2, -52),
+                EA = new Uint32Array(512);
+            class AA {
                 static from(t) {
-                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ED,
-                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DD;
+                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : OA,
+                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : TA;
                     const i = t.length,
                         r = new Float64Array(2 * i);
                     for (let o = 0; o < i; o++) {
                         const i = t[o];
                         r[2 * o] = e(i), r[2 * o + 1] = n(i)
                     }
-                    return new yD(r)
+                    return new AA(r)
                 }
                 constructor(t) {
                     const e = t.length >> 1;
                     if (e > 0 && "number" !== typeof t[0]) throw new Error("Expected coords to contain numbers.");
                     this.coords = t;
                     const n = Math.max(2 * e - 5, 0);
                     this._triangles = new Uint32Array(3 * n), this._halfedges = new Int32Array(3 * n), this._hashSize = Math.ceil(Math.sqrt(e)), this._hullPrev = new Uint32Array(e), this._hullNext = new Uint32Array(e), this._hullTri = new Uint32Array(e), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(e), this._dists = new Float64Array(e), this.update()
@@ -36456,56 +36593,56 @@
                         _hullTri: i,
                         _hullHash: r
                     } = this, o = t.length >> 1;
                     let a = 1 / 0,
                         s = 1 / 0,
                         c = -1 / 0,
                         l = -1 / 0;
-                    for (let D = 0; D < o; D++) {
-                        const e = t[2 * D],
-                            n = t[2 * D + 1];
-                        e < a && (a = e), n < s && (s = n), e > c && (c = e), n > l && (l = n), this._ids[D] = D
+                    for (let A = 0; A < o; A++) {
+                        const e = t[2 * A],
+                            n = t[2 * A + 1];
+                        e < a && (a = e), n < s && (s = n), e > c && (c = e), n > l && (l = n), this._ids[A] = A
                     }
                     const u = (a + c) / 2,
                         f = (s + l) / 2;
                     let d, h, p, m = 1 / 0;
-                    for (let D = 0; D < o; D++) {
-                        const e = bD(u, f, t[2 * D], t[2 * D + 1]);
-                        e < m && (d = D, m = e)
+                    for (let A = 0; A < o; A++) {
+                        const e = DA(u, f, t[2 * A], t[2 * A + 1]);
+                        e < m && (d = A, m = e)
                     }
                     const g = t[2 * d],
                         v = t[2 * d + 1];
                     m = 1 / 0;
-                    for (let D = 0; D < o; D++) {
-                        if (D === d) continue;
-                        const e = bD(g, v, t[2 * D], t[2 * D + 1]);
-                        e < m && e > 0 && (h = D, m = e)
+                    for (let A = 0; A < o; A++) {
+                        if (A === d) continue;
+                        const e = DA(g, v, t[2 * A], t[2 * A + 1]);
+                        e < m && e > 0 && (h = A, m = e)
                     }
                     let y = t[2 * h],
                         b = t[2 * h + 1],
                         x = 1 / 0;
-                    for (let D = 0; D < o; D++) {
-                        if (D === d || D === h) continue;
-                        const e = _D(g, v, y, b, t[2 * D], t[2 * D + 1]);
-                        e < x && (p = D, x = e)
+                    for (let A = 0; A < o; A++) {
+                        if (A === d || A === h) continue;
+                        const e = CA(g, v, y, b, t[2 * A], t[2 * A + 1]);
+                        e < x && (p = A, x = e)
                     }
                     let _ = t[2 * p],
                         w = t[2 * p + 1];
                     if (x === 1 / 0) {
                         for (let i = 0; i < o; i++) this._dists[i] = t[2 * i] - t[0] || t[2 * i + 1] - t[1];
-                        wD(this._ids, this._dists, 0, o - 1);
+                        MA(this._ids, this._dists, 0, o - 1);
                         const e = new Uint32Array(o);
                         let n = 0;
                         for (let t = 0, i = -1 / 0; t < o; t++) {
                             const r = this._ids[t];
                             this._dists[r] > i && (e[n++] = r, i = this._dists[r])
                         }
                         return this.hull = e.subarray(0, n), this.triangles = new Uint32Array(0), void(this.halfedges = new Uint32Array(0))
                     }
-                    if (mD(g, v, y, b, _, w) < 0) {
+                    if (wA(g, v, y, b, _, w) < 0) {
                         const t = h,
                             e = y,
                             n = b;
                         h = p, y = _, b = w, p = t, _ = e, w = n
                     }
                     const k = function(t, e, n, i, r, o) {
                         const a = n - t,
@@ -36519,43 +36656,43 @@
                             p = e + (a * f - c * u) * d;
                         return {
                             x: h,
                             y: p
                         }
                     }(g, v, y, b, _, w);
                     this._cx = k.x, this._cy = k.y;
-                    for (let D = 0; D < o; D++) this._dists[D] = bD(t[2 * D], t[2 * D + 1], k.x, k.y);
-                    wD(this._ids, this._dists, 0, o - 1), this._hullStart = d;
+                    for (let A = 0; A < o; A++) this._dists[A] = DA(t[2 * A], t[2 * A + 1], k.x, k.y);
+                    MA(this._ids, this._dists, 0, o - 1), this._hullStart = d;
                     let E = 3;
                     n[d] = e[p] = h, n[h] = e[d] = p, n[p] = e[h] = d, i[d] = 0, i[h] = 1, i[p] = 2, r.fill(-1), r[this._hashKey(g, v)] = d, r[this._hashKey(y, b)] = h, r[this._hashKey(_, w)] = p, this.trianglesLen = 0, this._addTriangle(d, h, p, -1, -1, -1);
-                    for (let D, A, S = 0; S < this._ids.length; S++) {
+                    for (let A, D, S = 0; S < this._ids.length; S++) {
                         const o = this._ids[S],
                             a = t[2 * o],
                             s = t[2 * o + 1];
-                        if (S > 0 && Math.abs(a - D) <= gD && Math.abs(s - A) <= gD) continue;
-                        if (D = a, A = s, o === d || o === h || o === p) continue;
+                        if (S > 0 && Math.abs(a - A) <= kA && Math.abs(s - D) <= kA) continue;
+                        if (A = a, D = s, o === d || o === h || o === p) continue;
                         let c = 0;
                         for (let t = 0, e = this._hashKey(a, s); t < this._hashSize && (c = r[(e + t) % this._hashSize], -1 === c || c === n[c]); t++);
                         c = e[c];
                         let l, u = c;
-                        for (; l = n[u], mD(a, s, t[2 * u], t[2 * u + 1], t[2 * l], t[2 * l + 1]) >= 0;)
+                        for (; l = n[u], wA(a, s, t[2 * u], t[2 * u + 1], t[2 * l], t[2 * l + 1]) >= 0;)
                             if (u = l, u === c) {
                                 u = -1;
                                 break
                             } if (-1 === u) continue;
                         let f = this._addTriangle(u, o, n[u], -1, -1, i[u]);
                         i[o] = this._legalize(f + 2), i[u] = f, E++;
                         let m = n[u];
-                        for (; l = n[m], mD(a, s, t[2 * m], t[2 * m + 1], t[2 * l], t[2 * l + 1]) < 0;) f = this._addTriangle(m, o, l, i[o], -1, i[m]), i[o] = this._legalize(f + 2), n[m] = m, E--, m = l;
+                        for (; l = n[m], wA(a, s, t[2 * m], t[2 * m + 1], t[2 * l], t[2 * l + 1]) < 0;) f = this._addTriangle(m, o, l, i[o], -1, i[m]), i[o] = this._legalize(f + 2), n[m] = m, E--, m = l;
                         if (u === c)
-                            for (; l = e[u], mD(a, s, t[2 * l], t[2 * l + 1], t[2 * u], t[2 * u + 1]) < 0;) f = this._addTriangle(l, o, u, -1, i[u], i[l]), this._legalize(f + 2), i[l] = f, n[u] = u, E--, u = l;
+                            for (; l = e[u], wA(a, s, t[2 * l], t[2 * l + 1], t[2 * u], t[2 * u + 1]) < 0;) f = this._addTriangle(l, o, u, -1, i[u], i[l]), this._legalize(f + 2), i[l] = f, n[u] = u, E--, u = l;
                         this._hullStart = e[o] = u, n[u] = e[m] = o, n[o] = m, r[this._hashKey(a, s)] = o, r[this._hashKey(t[2 * u], t[2 * u + 1])] = u
                     }
                     this.hull = new Uint32Array(E);
-                    for (let D = 0, A = this._hullStart; D < E; D++) this.hull[D] = A, A = n[A];
+                    for (let A = 0, D = this._hullStart; A < E; A++) this.hull[A] = D, D = n[D];
                     this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen)
                 }
                 _hashKey(t, e) {
                     return Math.floor(function(t, e) {
                         const n = t / (Math.abs(t) + Math.abs(e));
                         return (e > 0 ? 3 - n : 1 + n) / 4
                     }(t - this._cx, e - this._cy) * this._hashSize) % this._hashSize
@@ -36569,129 +36706,129 @@
                     let r = 0,
                         o = 0;
                     for (;;) {
                         const a = n[t],
                             s = t - t % 3;
                         if (o = s + (t + 2) % 3, -1 === a) {
                             if (0 === r) break;
-                            t = vD[--r];
+                            t = EA[--r];
                             continue
                         }
                         const c = a - a % 3,
                             l = s + (t + 1) % 3,
                             u = c + (a + 2) % 3,
                             f = e[o],
                             d = e[t],
                             h = e[l],
                             p = e[u];
-                        if (xD(i[2 * f], i[2 * f + 1], i[2 * d], i[2 * d + 1], i[2 * h], i[2 * h + 1], i[2 * p], i[2 * p + 1])) {
+                        if (SA(i[2 * f], i[2 * f + 1], i[2 * d], i[2 * d + 1], i[2 * h], i[2 * h + 1], i[2 * p], i[2 * p + 1])) {
                             e[t] = p, e[a] = f;
                             const i = n[u];
                             if (-1 === i) {
                                 let e = this._hullStart;
                                 do {
                                     if (this._hullTri[e] === u) {
                                         this._hullTri[e] = t;
                                         break
                                     }
                                     e = this._hullPrev[e]
                                 } while (e !== this._hullStart)
                             }
                             this._link(t, i), this._link(a, n[o]), this._link(o, u);
                             const s = c + (a + 1) % 3;
-                            r < vD.length && (vD[r++] = s)
+                            r < EA.length && (EA[r++] = s)
                         } else {
                             if (0 === r) break;
-                            t = vD[--r]
+                            t = EA[--r]
                         }
                     }
                     return o
                 }
                 _link(t, e) {
                     this._halfedges[t] = e, -1 !== e && (this._halfedges[e] = t)
                 }
                 _addTriangle(t, e, n, i, r, o) {
                     const a = this.trianglesLen;
                     return this._triangles[a] = t, this._triangles[a + 1] = e, this._triangles[a + 2] = n, this._link(a, i), this._link(a + 1, r), this._link(a + 2, o), this.trianglesLen += 3, a
                 }
             }
 
-            function bD(t, e, n, i) {
+            function DA(t, e, n, i) {
                 const r = t - n,
                     o = e - i;
                 return r * r + o * o
             }
 
-            function xD(t, e, n, i, r, o, a, s) {
+            function SA(t, e, n, i, r, o, a, s) {
                 const c = t - a,
                     l = e - s,
                     u = n - a,
                     f = i - s,
                     d = r - a,
                     h = o - s,
                     p = u * u + f * f,
                     m = d * d + h * h;
                 return c * (f * m - p * h) - l * (u * m - p * d) + (c * c + l * l) * (u * h - f * d) < 0
             }
 
-            function _D(t, e, n, i, r, o) {
+            function CA(t, e, n, i, r, o) {
                 const a = n - t,
                     s = i - e,
                     c = r - t,
                     l = o - e,
                     u = a * a + s * s,
                     f = c * c + l * l,
                     d = .5 / (a * l - s * c),
                     h = (l * u - s * f) * d,
                     p = (a * f - c * u) * d;
                 return h * h + p * p
             }
 
-            function wD(t, e, n, i) {
+            function MA(t, e, n, i) {
                 if (i - n <= 20)
                     for (let r = n + 1; r <= i; r++) {
                         const i = t[r],
                             o = e[i];
                         let a = r - 1;
                         for (; a >= n && e[t[a]] > o;) t[a + 1] = t[a--];
                         t[a + 1] = i
                     } else {
                         let r = n + 1,
                             o = i;
-                        kD(t, n + i >> 1, r), e[t[n]] > e[t[i]] && kD(t, n, i), e[t[r]] > e[t[i]] && kD(t, r, i), e[t[n]] > e[t[r]] && kD(t, n, r);
+                        FA(t, n + i >> 1, r), e[t[n]] > e[t[i]] && FA(t, n, i), e[t[r]] > e[t[i]] && FA(t, r, i), e[t[n]] > e[t[r]] && FA(t, n, r);
                         const a = t[r],
                             s = e[a];
                         for (;;) {
                             do {
                                 r++
                             } while (e[t[r]] < s);
                             do {
                                 o--
                             } while (e[t[o]] > s);
                             if (o < r) break;
-                            kD(t, r, o)
+                            FA(t, r, o)
                         }
-                        t[n + 1] = t[o], t[o] = a, i - r + 1 >= o - n ? (wD(t, e, r, i), wD(t, e, n, o - 1)) : (wD(t, e, n, o - 1), wD(t, e, r, i))
+                        t[n + 1] = t[o], t[o] = a, i - r + 1 >= o - n ? (MA(t, e, r, i), MA(t, e, n, o - 1)) : (MA(t, e, n, o - 1), MA(t, e, r, i))
                     }
             }
 
-            function kD(t, e, n) {
+            function FA(t, e, n) {
                 const i = t[e];
                 t[e] = t[n], t[n] = i
             }
 
-            function ED(t) {
+            function OA(t) {
                 return t[0]
             }
 
-            function DD(t) {
+            function TA(t) {
                 return t[1]
             }
-            const AD = 1e-6;
-            class SD {
+            const NA = 1e-6;
+            class RA {
                 constructor() {
                     this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = ""
                 }
                 moveTo(t, e) {
                     this._ += "M".concat(this._x0 = this._x1 = +t, ",").concat(this._y0 = this._y1 = +e)
                 }
                 closePath() {
@@ -36700,24 +36837,24 @@
                 lineTo(t, e) {
                     this._ += "L".concat(this._x1 = +t, ",").concat(this._y1 = +e)
                 }
                 arc(t, e, n) {
                     const i = (t = +t) + (n = +n),
                         r = e = +e;
                     if (n < 0) throw new Error("negative radius");
-                    null === this._x1 ? this._ += "M".concat(i, ",").concat(r) : (Math.abs(this._x1 - i) > AD || Math.abs(this._y1 - r) > AD) && (this._ += "L" + i + "," + r), n && (this._ += "A".concat(n, ",").concat(n, ",0,1,1,").concat(t - n, ",").concat(e, "A").concat(n, ",").concat(n, ",0,1,1,").concat(this._x1 = i, ",").concat(this._y1 = r))
+                    null === this._x1 ? this._ += "M".concat(i, ",").concat(r) : (Math.abs(this._x1 - i) > NA || Math.abs(this._y1 - r) > NA) && (this._ += "L" + i + "," + r), n && (this._ += "A".concat(n, ",").concat(n, ",0,1,1,").concat(t - n, ",").concat(e, "A").concat(n, ",").concat(n, ",0,1,1,").concat(this._x1 = i, ",").concat(this._y1 = r))
                 }
                 rect(t, e, n, i) {
                     this._ += "M".concat(this._x0 = this._x1 = +t, ",").concat(this._y0 = this._y1 = +e, "h").concat(+n, "v").concat(+i, "h").concat(-n, "Z")
                 }
                 value() {
                     return this._ || null
                 }
             }
-            class CD {
+            class zA {
                 constructor() {
                     this._ = []
                 }
                 moveTo(t, e) {
                     this._.push([t, e])
                 }
                 closePath() {
@@ -36726,15 +36863,15 @@
                 lineTo(t, e) {
                     this._.push([t, e])
                 }
                 value() {
                     return this._.length ? this._ : null
                 }
             }
-            class FD {
+            class PA {
                 constructor(t) {
                     let [e, n, i, r] = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 0, 960, 500];
                     if (!((i = +i) >= (e = +e)) || !((r = +r) >= (n = +n))) throw new Error("invalid bounds");
                     this.delaunay = t, this._circumcenters = new Float64Array(2 * t.points.length), this.vectors = new Float64Array(2 * t.points.length), this.xmax = i, this.xmin = e, this.ymax = r, this.ymin = n, this._init()
                 }
                 update() {
                     return this.delaunay.update(), this._init(), this
@@ -36779,15 +36916,15 @@
                         l = 4 * c,
                         u = t[2 * c],
                         f = t[2 * c + 1];
                     i.fill(0);
                     for (let d = 0; d < e.length; ++d) c = e[d], o = l, a = u, s = f, l = 4 * c, u = t[2 * c], f = t[2 * c + 1], i[o + 2] = i[l] = s - f, i[o + 3] = i[l + 1] = u - a
                 }
                 render(t) {
-                    const e = null == t ? t = new SD : void 0,
+                    const e = null == t ? t = new RA : void 0,
                         {
                             delaunay: {
                                 halfedges: n,
                                 inedges: i,
                                 hull: r
                             },
                             circumcenters: o,
@@ -36814,19 +36951,19 @@
                             f = 4 * s,
                             d = this._project(n, u, a[f + 2], a[f + 3]);
                         d && this._renderSegment(n, u, d[0], d[1], t)
                     }
                     return e && e.value()
                 }
                 renderBounds(t) {
-                    const e = null == t ? t = new SD : void 0;
+                    const e = null == t ? t = new RA : void 0;
                     return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), e && e.value()
                 }
                 renderCell(t, e) {
-                    const n = null == e ? e = new SD : void 0,
+                    const n = null == e ? e = new RA : void 0,
                         i = this._clip(t);
                     if (null === i || !i.length) return;
                     e.moveTo(i[0], i[1]);
                     let r = i.length;
                     for (; i[0] === i[r - 2] && i[1] === i[r - 1] && r > 1;) r -= 2;
                     for (let o = 2; o < r; o += 2) i[o] === i[o - 2] && i[o + 1] === i[o - 1] || e.lineTo(i[o], i[o + 1]);
                     return e.closePath(), n && n.value()
@@ -36838,15 +36975,15 @@
                     } = this;
                     for (let e = 0, n = t.length / 2; e < n; ++e) {
                         const t = this.cellPolygon(e);
                         t && (t.index = e, yield t)
                     }
                 }
                 cellPolygon(t) {
-                    const e = new CD;
+                    const e = new zA;
                     return this.renderCell(t, e), e.value()
                 }
                 _renderSegment(t, e, n, i, r) {
                     let o;
                     const a = this._regioncode(t, e),
                         s = this._regioncode(n, i);
                     0 === a && 0 === s ? (r.moveTo(t, e), r.lineTo(n, i)) : (o = this._clipSegment(t, e, n, i, a, s)) && (r.moveTo(o[0], o[1]), r.lineTo(o[2], o[3]))
@@ -36991,48 +37128,48 @@
                 _edgecode(t, e) {
                     return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (e === this.ymin ? 4 : e === this.ymax ? 8 : 0)
                 }
                 _regioncode(t, e) {
                     return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (e < this.ymin ? 4 : e > this.ymax ? 8 : 0)
                 }
             }
-            const MD = 2 * Math.PI,
-                OD = Math.pow;
+            const LA = 2 * Math.PI,
+                BA = Math.pow;
 
-            function TD(t) {
+            function IA(t) {
                 return t[0]
             }
 
-            function ND(t) {
+            function jA(t) {
                 return t[1]
             }
 
-            function zD(t, e, n) {
+            function UA(t, e, n) {
                 return [t + Math.sin(t + e) * n, e + Math.cos(t - e) * n]
             }
-            class RD {
+            class qA {
                 static from(t) {
-                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : TD,
-                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ND,
+                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : IA,
+                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : jA,
                         i = arguments.length > 3 ? arguments[3] : void 0;
-                    return new RD("length" in t ? function(t, e, n, i) {
+                    return new qA("length" in t ? function(t, e, n, i) {
                         const r = t.length,
                             o = new Float64Array(2 * r);
                         for (let a = 0; a < r; ++a) {
                             const r = t[a];
                             o[2 * a] = e.call(i, r, a, t), o[2 * a + 1] = n.call(i, r, a, t)
                         }
                         return o
                     }(t, e, n, i) : Float64Array.from(function*(t, e, n, i) {
                         let r = 0;
                         for (const o of t) yield e.call(i, o, r, t), yield n.call(i, o, r, t), ++r
                     }(t, e, n, i)))
                 }
                 constructor(t) {
-                    this._delaunator = new yD(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
+                    this._delaunator = new AA(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
                 }
                 update() {
                     return this._delaunator.update(), this._init(), this
                 }
                 _init() {
                     const t = this._delaunator,
                         e = this.points;
@@ -37053,32 +37190,32 @@
                             length: e.length / 2
                         }, ((t, e) => e)).sort(((t, n) => e[2 * t] - e[2 * n] || e[2 * t + 1] - e[2 * n + 1]));
                         const t = this.collinear[0],
                             n = this.collinear[this.collinear.length - 1],
                             i = [e[2 * t], e[2 * t + 1], e[2 * n], e[2 * n + 1]],
                             r = 1e-8 * Math.hypot(i[3] - i[1], i[2] - i[0]);
                         for (let o = 0, a = e.length / 2; o < a; ++o) {
-                            const t = zD(e[2 * o], e[2 * o + 1], r);
+                            const t = UA(e[2 * o], e[2 * o + 1], r);
                             e[2 * o] = t[0], e[2 * o + 1] = t[1]
                         }
-                        this._delaunator = new yD(e)
+                        this._delaunator = new AA(e)
                     } else delete this.collinear;
                     const n = this.halfedges = this._delaunator.halfedges,
                         i = this.hull = this._delaunator.hull,
                         r = this.triangles = this._delaunator.triangles,
                         o = this.inedges.fill(-1),
                         a = this._hullIndex.fill(-1);
                     for (let s = 0, c = n.length; s < c; ++s) {
                         const t = r[s % 3 === 2 ? s - 2 : s + 1]; - 1 !== n[s] && -1 !== o[t] || (o[t] = s)
                     }
                     for (let s = 0, c = i.length; s < c; ++s) a[i[s]] = s;
                     i.length <= 2 && i.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = i[0], o[i[0]] = 1, 2 === i.length && (o[i[1]] = 0, this.triangles[1] = i[1], this.triangles[2] = i[1]))
                 }
                 voronoi(t) {
-                    return new FD(this, t)
+                    return new PA(this, t)
                 }* neighbors(t) {
                     const {
                         inedges: e,
                         hull: n,
                         _hullIndex: i,
                         halfedges: r,
                         triangles: o,
@@ -37116,30 +37253,30 @@
                         _hullIndex: o,
                         halfedges: a,
                         triangles: s,
                         points: c
                     } = this;
                     if (-1 === i[t] || !c.length) return (t + 1) % (c.length >> 1);
                     let l = t,
-                        u = OD(e - c[2 * t], 2) + OD(n - c[2 * t + 1], 2);
+                        u = BA(e - c[2 * t], 2) + BA(n - c[2 * t + 1], 2);
                     const f = i[t];
                     let d = f;
                     do {
                         let i = s[d];
-                        const f = OD(e - c[2 * i], 2) + OD(n - c[2 * i + 1], 2);
+                        const f = BA(e - c[2 * i], 2) + BA(n - c[2 * i + 1], 2);
                         if (f < u && (u = f, l = i), d = d % 3 === 2 ? d - 2 : d + 1, s[d] !== t) break;
                         if (d = a[d], -1 === d) {
-                            if (d = r[(o[t] + 1) % r.length], d !== i && OD(e - c[2 * d], 2) + OD(n - c[2 * d + 1], 2) < u) return d;
+                            if (d = r[(o[t] + 1) % r.length], d !== i && BA(e - c[2 * d], 2) + BA(n - c[2 * d + 1], 2) < u) return d;
                             break
                         }
                     } while (d !== f);
                     return l
                 }
                 render(t) {
-                    const e = null == t ? t = new SD : void 0,
+                    const e = null == t ? t = new RA : void 0,
                         {
                             points: n,
                             halfedges: i,
                             triangles: r
                         } = this;
                     for (let o = 0, a = i.length; o < a; ++o) {
                         const e = i[o];
@@ -37148,46 +37285,46 @@
                             s = 2 * r[e];
                         t.moveTo(n[a], n[a + 1]), t.lineTo(n[s], n[s + 1])
                     }
                     return this.renderHull(t), e && e.value()
                 }
                 renderPoints(t, e) {
                     void 0 !== e || t && "function" === typeof t.moveTo || (e = t, t = null), e = void 0 == e ? 2 : +e;
-                    const n = null == t ? t = new SD : void 0,
+                    const n = null == t ? t = new RA : void 0,
                         {
                             points: i
                         } = this;
                     for (let r = 0, o = i.length; r < o; r += 2) {
                         const n = i[r],
                             o = i[r + 1];
-                        t.moveTo(n + e, o), t.arc(n, o, e, 0, MD)
+                        t.moveTo(n + e, o), t.arc(n, o, e, 0, LA)
                     }
                     return n && n.value()
                 }
                 renderHull(t) {
-                    const e = null == t ? t = new SD : void 0,
+                    const e = null == t ? t = new RA : void 0,
                         {
                             hull: n,
                             points: i
                         } = this,
                         r = 2 * n[0],
                         o = n.length;
                     t.moveTo(i[r], i[r + 1]);
                     for (let a = 1; a < o; ++a) {
                         const e = 2 * n[a];
                         t.lineTo(i[e], i[e + 1])
                     }
                     return t.closePath(), e && e.value()
                 }
                 hullPolygon() {
-                    const t = new CD;
+                    const t = new zA;
                     return this.renderHull(t), t.value()
                 }
                 renderTriangle(t, e) {
-                    const n = null == e ? e = new SD : void 0,
+                    const n = null == e ? e = new RA : void 0,
                         {
                             points: i,
                             triangles: r
                         } = this,
                         o = 2 * r[t *= 3],
                         a = 2 * r[t + 1],
                         s = 2 * r[t + 2];
@@ -37195,23 +37332,23 @@
                 }* trianglePolygons() {
                     const {
                         triangles: t
                     } = this;
                     for (let e = 0, n = t.length / 3; e < n; ++e) yield this.trianglePolygon(e)
                 }
                 trianglePolygon(t) {
-                    const e = new CD;
+                    const e = new zA;
                     return this.renderTriangle(t, e), e.value()
                 }
             }
 
-            function PD(t) {
-                Rr.call(this, null, t)
+            function WA(t) {
+                zr.call(this, null, t)
             }
-            PD.Definition = {
+            WA.Definition = {
                 type: "Voronoi",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "x",
                     type: "field",
@@ -37241,71 +37378,72 @@
                     }
                 }, {
                     name: "as",
                     type: "string",
                     default: "path"
                 }]
             };
-            const LD = [-1e5, -1e5, 1e5, 1e5];
+            const HA = [-1e5, -1e5, 1e5, 1e5];
 
-            function jD(t) {
+            function XA(t) {
                 const e = t[0][0],
                     n = t[0][1];
                 let i = t.length - 1;
                 for (; t[i][0] === e && t[i][1] === n; --i);
                 return "M" + t.slice(0, i + 1).join("L") + "Z"
-            }(0, m.XW)(PD, Rr, {
+            }(0, m.XW)(WA, zr, {
                 transform(t, e) {
                     const n = t.as || "path",
                         i = e.source;
                     if (!i || !i.length) return e;
                     let r = t.size;
-                    r = r ? [0, 0, r[0], r[1]] : (r = t.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : LD;
-                    const o = this.value = RD.from(i, t.x, t.y).voronoi(r);
-                    for (let a = 0, s = i.length; a < s; ++a) {
-                        const t = o.cellPolygon(a);
-                        i[a][n] = t ? jD(t) : null
+                    r = r ? [0, 0, r[0], r[1]] : (r = t.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : HA;
+                    const o = this.value = qA.from(i, t.x, t.y).voronoi(r);
+                    for (let s = 0, c = i.length; s < c; ++s) {
+                        const t = o.cellPolygon(s);
+                        i[s][n] = t && (2 !== (a = t).length || a[0][0] !== a[1][0] || a[0][1] !== a[1][1]) ? XA(t) : null
                     }
+                    var a;
                     return e.reflow(t.modified()).modifies(n)
                 }
             });
-            var BD = Math.PI / 180,
-                ID = 64,
-                UD = 2048;
+            var GA = Math.PI / 180,
+                JA = 64,
+                ZA = 2048;
 
-            function qD() {
+            function $A() {
                 var t, e, n, i, r, o, a, s = [256, 256],
-                    c = GD,
+                    c = tD,
                     l = [],
                     u = Math.random,
                     f = {};
 
                 function d(t, e, n) {
                     for (var i, r, o, a = e.x, l = e.y, f = Math.sqrt(s[0] * s[0] + s[1] * s[1]), d = c(s), h = u() < .5 ? 1 : -1, p = -h;
                         (i = d(p += h)) && (r = ~~i[0], o = ~~i[1], !(Math.min(Math.abs(r), Math.abs(o)) >= f));)
-                        if (e.x = a + r, e.y = l + o, !(e.x + e.x0 < 0 || e.y + e.y0 < 0 || e.x + e.x1 > s[0] || e.y + e.y1 > s[1]) && (!n || !HD(e, t, s[0])) && (!n || JD(e, n))) {
+                        if (e.x = a + r, e.y = l + o, !(e.x + e.x0 < 0 || e.y + e.y0 < 0 || e.x + e.x1 > s[0] || e.y + e.y1 > s[1]) && (!n || !VA(e, t, s[0])) && (!n || QA(e, n))) {
                             for (var m, g = e.sprite, v = e.width >> 5, y = s[0] >> 5, b = e.x - (v << 4), x = 127 & b, _ = 32 - x, w = e.y1 - e.y0, k = (e.y + e.y0) * y + (b >> 5), E = 0; E < w; E++) {
                                 m = 0;
-                                for (var D = 0; D <= v; D++) t[k + D] |= m << _ | (D < v ? (m = g[E * v + D]) >>> x : 0);
+                                for (var A = 0; A <= v; A++) t[k + A] |= m << _ | (A < v ? (m = g[E * v + A]) >>> x : 0);
                                 k += y
                             }
                             return e.sprite = null, !0
                         } return !1
                 }
                 return f.layout = function() {
                     for (var c = function(t) {
                             t.width = t.height = 1;
                             var e = Math.sqrt(t.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
-                            t.width = (ID << 5) / e, t.height = UD / e;
+                            t.width = (JA << 5) / e, t.height = ZA / e;
                             var n = t.getContext("2d");
                             return n.fillStyle = n.strokeStyle = "red", n.textAlign = "center", {
                                 context: n,
                                 ratio: e
                             }
-                        }(Xc()), f = function(t) {
+                        }(il()), f = function(t) {
                             var e = [],
                                 n = -1;
                             for (; ++n < t;) e[n] = 0;
                             return e
                         }((s[0] >> 5) * s[1]), h = null, p = l.length, m = -1, g = [], v = l.map((s => ({
                             text: t(s),
                             font: e(s),
@@ -37321,125 +37459,125 @@
                             x0: 0,
                             y0: 0,
                             hasText: !1,
                             sprite: null,
                             datum: s
                         }))).sort(((t, e) => e.size - t.size)); ++m < p;) {
                         var y = v[m];
-                        y.x = s[0] * (u() + .5) >> 1, y.y = s[1] * (u() + .5) >> 1, WD(c, y, v, m), y.hasText && d(f, y, h) && (g.push(y), h ? XD(h, y) : h = [{
+                        y.x = s[0] * (u() + .5) >> 1, y.y = s[1] * (u() + .5) >> 1, YA(c, y, v, m), y.hasText && d(f, y, h) && (g.push(y), h ? KA(h, y) : h = [{
                             x: y.x + y.x0,
                             y: y.y + y.y0
                         }, {
                             x: y.x + y.x1,
                             y: y.y + y.y1
                         }], y.x -= s[0] >> 1, y.y -= s[1] >> 1)
                     }
                     return g
                 }, f.words = function(t) {
                     return arguments.length ? (l = t, f) : l
                 }, f.size = function(t) {
                     return arguments.length ? (s = [+t[0], +t[1]], f) : s
                 }, f.font = function(t) {
-                    return arguments.length ? (e = $D(t), f) : e
+                    return arguments.length ? (e = eD(t), f) : e
                 }, f.fontStyle = function(t) {
-                    return arguments.length ? (i = $D(t), f) : i
+                    return arguments.length ? (i = eD(t), f) : i
                 }, f.fontWeight = function(t) {
-                    return arguments.length ? (r = $D(t), f) : r
+                    return arguments.length ? (r = eD(t), f) : r
                 }, f.rotate = function(t) {
-                    return arguments.length ? (o = $D(t), f) : o
+                    return arguments.length ? (o = eD(t), f) : o
                 }, f.text = function(e) {
-                    return arguments.length ? (t = $D(e), f) : t
+                    return arguments.length ? (t = eD(e), f) : t
                 }, f.spiral = function(t) {
-                    return arguments.length ? (c = ZD[t] || t, f) : c
+                    return arguments.length ? (c = nD[t] || t, f) : c
                 }, f.fontSize = function(t) {
-                    return arguments.length ? (n = $D(t), f) : n
+                    return arguments.length ? (n = eD(t), f) : n
                 }, f.padding = function(t) {
-                    return arguments.length ? (a = $D(t), f) : a
+                    return arguments.length ? (a = eD(t), f) : a
                 }, f.random = function(t) {
                     return arguments.length ? (u = t, f) : u
                 }, f
             }
 
-            function WD(t, e, n, i) {
+            function YA(t, e, n, i) {
                 if (!e.sprite) {
                     var r = t.context,
                         o = t.ratio;
-                    r.clearRect(0, 0, (ID << 5) / o, UD / o);
+                    r.clearRect(0, 0, (JA << 5) / o, ZA / o);
                     var a, s, c, l, u, f = 0,
                         d = 0,
                         h = 0,
                         p = n.length;
                     for (--i; ++i < p;) {
                         if (e = n[i], r.save(), r.font = e.style + " " + e.weight + " " + ~~((e.size + 1) / o) + "px " + e.font, a = r.measureText(e.text + "m").width * o, c = e.size << 1, e.rotate) {
-                            var m = Math.sin(e.rotate * BD),
-                                g = Math.cos(e.rotate * BD),
+                            var m = Math.sin(e.rotate * GA),
+                                g = Math.cos(e.rotate * GA),
                                 v = a * g,
                                 y = a * m,
                                 b = c * g,
                                 x = c * m;
                             a = Math.max(Math.abs(v + x), Math.abs(v - x)) + 31 >> 5 << 5, c = ~~Math.max(Math.abs(y + b), Math.abs(y - b))
                         } else a = a + 31 >> 5 << 5;
-                        if (c > h && (h = c), f + a >= ID << 5 && (f = 0, d += h, h = 0), d + c >= UD) break;
-                        r.translate((f + (a >> 1)) / o, (d + (c >> 1)) / o), e.rotate && r.rotate(e.rotate * BD), r.fillText(e.text, 0, 0), e.padding && (r.lineWidth = 2 * e.padding, r.strokeText(e.text, 0, 0)), r.restore(), e.width = a, e.height = c, e.xoff = f, e.yoff = d, e.x1 = a >> 1, e.y1 = c >> 1, e.x0 = -e.x1, e.y0 = -e.y1, e.hasText = !0, f += a
+                        if (c > h && (h = c), f + a >= JA << 5 && (f = 0, d += h, h = 0), d + c >= ZA) break;
+                        r.translate((f + (a >> 1)) / o, (d + (c >> 1)) / o), e.rotate && r.rotate(e.rotate * GA), r.fillText(e.text, 0, 0), e.padding && (r.lineWidth = 2 * e.padding, r.strokeText(e.text, 0, 0)), r.restore(), e.width = a, e.height = c, e.xoff = f, e.yoff = d, e.x1 = a >> 1, e.y1 = c >> 1, e.x0 = -e.x1, e.y0 = -e.y1, e.hasText = !0, f += a
                     }
-                    for (var _ = r.getImageData(0, 0, (ID << 5) / o, UD / o).data, w = []; --i >= 0;)
+                    for (var _ = r.getImageData(0, 0, (JA << 5) / o, ZA / o).data, w = []; --i >= 0;)
                         if ((e = n[i]).hasText) {
                             for (s = (a = e.width) >> 5, c = e.y1 - e.y0, l = 0; l < c * s; l++) w[l] = 0;
                             if (null == (f = e.xoff)) return;
                             d = e.yoff;
                             var k = 0,
                                 E = -1;
                             for (u = 0; u < c; u++) {
                                 for (l = 0; l < a; l++) {
-                                    var D = s * u + (l >> 5),
-                                        A = _[(d + u) * (ID << 5) + (f + l) << 2] ? 1 << 31 - l % 32 : 0;
-                                    w[D] |= A, k |= A
+                                    var A = s * u + (l >> 5),
+                                        D = _[(d + u) * (JA << 5) + (f + l) << 2] ? 1 << 31 - l % 32 : 0;
+                                    w[A] |= D, k |= D
                                 }
                                 k ? E = u : (e.y0++, c--, u--, d++)
                             }
                             e.y1 = e.y0 + E, e.sprite = w.slice(0, (e.y1 - e.y0) * s)
                         }
                 }
             }
 
-            function HD(t, e, n) {
+            function VA(t, e, n) {
                 n >>= 5;
                 for (var i, r = t.sprite, o = t.width >> 5, a = t.x - (o << 4), s = 127 & a, c = 32 - s, l = t.y1 - t.y0, u = (t.y + t.y0) * n + (a >> 5), f = 0; f < l; f++) {
                     i = 0;
                     for (var d = 0; d <= o; d++)
                         if ((i << c | (d < o ? (i = r[f * o + d]) >>> s : 0)) & e[u + d]) return !0;
                     u += n
                 }
                 return !1
             }
 
-            function XD(t, e) {
+            function KA(t, e) {
                 var n = t[0],
                     i = t[1];
                 e.x + e.x0 < n.x && (n.x = e.x + e.x0), e.y + e.y0 < n.y && (n.y = e.y + e.y0), e.x + e.x1 > i.x && (i.x = e.x + e.x1), e.y + e.y1 > i.y && (i.y = e.y + e.y1)
             }
 
-            function JD(t, e) {
+            function QA(t, e) {
                 return t.x + t.x1 > e[0].x && t.x + t.x0 < e[1].x && t.y + t.y1 > e[0].y && t.y + t.y0 < e[1].y
             }
 
-            function GD(t) {
+            function tD(t) {
                 var e = t[0] / t[1];
                 return function(t) {
                     return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)]
                 }
             }
 
-            function $D(t) {
+            function eD(t) {
                 return "function" === typeof t ? t : function() {
                     return t
                 }
             }
-            var ZD = {
-                archimedean: GD,
+            var nD = {
+                archimedean: tD,
                 rectangular: function(t) {
                     var e = 4 * t[0] / t[1],
                         n = 0,
                         i = 0;
                     return function(t) {
                         var r = t < 0 ? -1 : 1;
                         switch (Math.sqrt(1 + 4 * r * t) - r & 3) {
@@ -37455,21 +37593,21 @@
                             default:
                                 i -= 4
                         }
                         return [n, i]
                     }
                 }
             };
-            const YD = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"],
-                VD = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
+            const iD = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"],
+                rD = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
 
-            function KD(t) {
-                Rr.call(this, qD(), t)
+            function oD(t) {
+                zr.call(this, $A(), t)
             }
-            KD.Definition = {
+            oD.Definition = {
                 type: "Wordcloud",
                 metadata: {
                     modifies: !0
                 },
                 params: [{
                     name: "size",
                     type: "number",
@@ -37517,56 +37655,56 @@
                     type: "number",
                     expr: !0
                 }, {
                     name: "as",
                     type: "string",
                     array: !0,
                     length: 7,
-                    default: YD
+                    default: iD
                 }]
-            }, (0, m.XW)(KD, Rr, {
+            }, (0, m.XW)(oD, zr, {
                 transform(t, e) {
                     !t.size || t.size[0] && t.size[1] || (0, m.vU)("Wordcloud size dimensions must be non-zero.");
                     const n = t.modified();
-                    if (!(n || e.changed(e.ADD_REM) || VD.some((function(n) {
+                    if (!(n || e.changed(e.ADD_REM) || rD.some((function(n) {
                             const i = t[n];
                             return (0, m.mf)(i) && e.modified(i.fields)
                         })))) return;
                     const i = e.materialize(e.SOURCE).source,
                         r = this.value,
-                        o = t.as || YD;
+                        o = t.as || iD;
                     let a, s = t.fontSize || 14;
                     if ((0, m.mf)(s) ? a = t.fontSizeRange : s = (0, m.a9)(s), a) {
                         const t = s,
-                            e = af("sqrt")().domain((0, m.We)(i, t)).range(a);
+                            e = Ff("sqrt")().domain((0, m.We)(i, t)).range(a);
                         s = n => e(t(n))
                     }
                     i.forEach((t => {
                         t[o[0]] = NaN, t[o[1]] = NaN, t[o[3]] = 0
                     }));
-                    const c = r.words(i).text(t.text).size(t.size || [500, 500]).padding(t.padding || 1).spiral(t.spiral || "archimedean").rotate(t.rotate || 0).font(t.font || "sans-serif").fontStyle(t.fontStyle || "normal").fontWeight(t.fontWeight || "normal").fontSize(s).random($r).layout(),
+                    const c = r.words(i).text(t.text).size(t.size || [500, 500]).padding(t.padding || 1).spiral(t.spiral || "archimedean").rotate(t.rotate || 0).font(t.font || "sans-serif").fontStyle(t.fontStyle || "normal").fontWeight(t.fontWeight || "normal").fontSize(s).random(Zr).layout(),
                         l = r.size(),
                         u = l[0] >> 1,
                         f = l[1] >> 1,
                         d = c.length;
                     for (let h, p, m = 0; m < d; ++m) h = c[m], p = h.datum, p[o[0]] = h.x + u, p[o[1]] = h.y + f, p[o[2]] = h.font, p[o[3]] = h.size, p[o[4]] = h.style, p[o[5]] = h.weight, p[o[6]] = h.rotate;
                     return e.reflow(n).modifies(o)
                 }
             });
-            var QD = n(24120);
-            const tA = t => new Uint8Array(t),
-                eA = t => new Uint16Array(t),
-                nA = t => new Uint32Array(t);
+            var aD = n(24120);
+            const sD = t => new Uint8Array(t),
+                cD = t => new Uint16Array(t),
+                lD = t => new Uint32Array(t);
 
-            function iA(t, e, n) {
-                const i = (e < 257 ? tA : e < 65537 ? eA : nA)(t);
+            function uD(t, e, n) {
+                const i = (e < 257 ? sD : e < 65537 ? cD : lD)(t);
                 return n && i.set(n), i
             }
 
-            function rA(t, e, n) {
+            function fD(t, e, n) {
                 const i = 1 << e;
                 return {
                     one: i,
                     zero: ~i,
                     range: n.slice(),
                     bisect: t.bisect,
                     index: t.index,
@@ -37582,33 +37720,33 @@
                         for (l = 0; l < a; ++l) e[o[l]] |= i;
                         for (l = s; l < c; ++l) e[o[l]] |= i;
                         return n
                     }
                 }
             }
 
-            function oA() {
-                let t = nA(0),
+            function dD() {
+                let t = lD(0),
                     e = [],
                     n = 0;
                 return {
                     insert: function(i, r, o) {
                         if (!r.length) return [];
                         const a = n,
                             s = r.length,
-                            c = nA(s);
+                            c = lD(s);
                         let l, u, f, d = Array(s);
                         for (f = 0; f < s; ++f) d[f] = i(r[f]), c[f] = f;
                         if (d = function(t, e) {
                                 return t.sort.call(e, ((e, n) => {
                                     const i = t[e],
                                         r = t[n];
                                     return i < r ? -1 : i > r ? 1 : 0
-                                })), (0, QD.Z)(t, e)
-                            }(d, c), a) l = e, u = t, e = Array(a + s), t = nA(a + s),
+                                })), (0, aD.Z)(t, e)
+                            }(d, c), a) l = e, u = t, e = Array(a + s), t = lD(a + s),
                             function(t, e, n, i, r, o, a, s, c) {
                                 let l, u = 0,
                                     f = 0;
                                 for (l = 0; u < i && f < a; ++l) e[u] < r[f] ? (s[l] = e[u], c[l] = n[u++]) : (s[l] = r[f], c[l] = o[f++] + t);
                                 for (; u < i; ++u, ++l) s[l] = e[u], c[l] = n[u];
                                 for (; f < a; ++f, ++l) s[l] = r[f], c[l] = o[f] + t
                             }(o, l, u, a, d, c, s, e, t);
@@ -37627,31 +37765,31 @@
                         let a, s, c;
                         for (s = 0; !r[t[s]] && s < o; ++s);
                         for (c = s; s < o; ++s) r[a = t[s]] || (t[c] = a, e[c] = e[s], ++c);
                         n = o - i
                     },
                     bisect: function(t, i) {
                         let r;
-                        return i ? r = i.length : (i = e, r = n), [(0, Gc.Nw)(i, t[0], 0, r), (0, Gc.ml)(i, t[1], 0, r)]
+                        return i ? r = i.length : (i = e, r = n), [(0, ol.Nw)(i, t[0], 0, r), (0, ol.ml)(i, t[1], 0, r)]
                     },
                     reindex: function(e) {
                         for (let i = 0, r = n; i < r; ++i) t[i] = e[t[i]]
                     },
                     index: () => t,
                     size: () => n
                 }
             }
 
-            function aA(t) {
-                Rr.call(this, function() {
+            function hD(t) {
+                zr.call(this, function() {
                     let t = 8,
                         e = [],
-                        n = nA(0),
-                        i = iA(0, t),
-                        r = iA(0, t);
+                        n = lD(0),
+                        i = uD(0, t),
+                        r = uD(0, t);
                     return {
                         data: () => e,
                         seen: () => n = function(t, e, n) {
                             return t.length >= e ? t : ((n = n || new t.constructor(e)).set(t), n)
                         }(n, e.length),
                         add(t) {
                             for (let n, i = 0, r = e.length, o = t.length; i < o; ++i) n = t[i], n._index = r++, e.push(n)
@@ -37673,24 +37811,24 @@
                         set(t, e) {
                             i[t] |= e
                         },
                         clear(t, e) {
                             i[t] &= ~e
                         },
                         resize(e, n) {
-                            (e > i.length || n > t) && (t = Math.max(n, t), i = iA(e, t, i), r = iA(e, t))
+                            (e > i.length || n > t) && (t = Math.max(n, t), i = uD(e, t, i), r = uD(e, t))
                         }
                     }
                 }(), t), this._indices = null, this._dims = null
             }
 
-            function sA(t) {
-                Rr.call(this, null, t)
+            function pD(t) {
+                zr.call(this, null, t)
             }
-            aA.Definition = {
+            hD.Definition = {
                 type: "CrossFilter",
                 metadata: {},
                 params: [{
                     name: "fields",
                     type: "field",
                     array: !0,
                     required: !0
@@ -37701,26 +37839,26 @@
                     required: !0,
                     content: {
                         type: "number",
                         array: !0,
                         length: 2
                     }
                 }]
-            }, (0, m.XW)(aA, Rr, {
+            }, (0, m.XW)(hD, zr, {
                 transform(t, e) {
                     return this._dims ? t.modified("fields") || t.fields.some((t => e.modified(t.fields))) ? this.reinit(t, e) : this.eval(t, e) : this.init(t, e)
                 },
                 init(t, e) {
                     const n = t.fields,
                         i = t.query,
                         r = this._indices = {},
                         o = this._dims = [],
                         a = i.length;
                     let s, c, l = 0;
-                    for (; l < a; ++l) s = n[l].fname, c = r[s] || (r[s] = oA()), o.push(rA(c, l, i[l]));
+                    for (; l < a; ++l) s = n[l].fname, c = r[s] || (r[s] = dD()), o.push(fD(c, l, i[l]));
                     return this.eval(t, e)
                 },
                 reinit(t, e) {
                     const n = e.materialize().fork(),
                         i = t.fields,
                         r = t.query,
                         o = this._indices,
@@ -37732,15 +37870,15 @@
                         f = n.rem = n.add,
                         d = n.mod,
                         h = r.length,
                         p = {};
                     let m, g, v, y, b, x, _, w, k;
                     if (l.set(c), e.rem.length && (b = this.remove(t, e, n)), e.add.length && s.add(e.add), e.mod.length)
                         for (x = {}, y = e.mod, _ = 0, w = y.length; _ < w; ++_) x[y[_]._index] = 1;
-                    for (_ = 0; _ < h; ++_) k = i[_], (!a[_] || t.modified("fields", _) || e.modified(k.fields)) && (v = k.fname, (m = p[v]) || (o[v] = g = oA(), p[v] = m = g.insert(k, e.source, 0)), a[_] = rA(g, _, r[_]).onAdd(m, c));
+                    for (_ = 0; _ < h; ++_) k = i[_], (!a[_] || t.modified("fields", _) || e.modified(k.fields)) && (v = k.fname, (m = p[v]) || (o[v] = g = dD(), p[v] = m = g.insert(k, e.source, 0)), a[_] = fD(g, _, r[_]).onAdd(m, c));
                     for (_ = 0, w = s.data().length; _ < w; ++_) b[_] || (l[_] !== c[_] ? f.push(_) : x[_] && c[_] !== u && d.push(_));
                     return s.mask = (1 << h) - 1, n
                 },
                 eval(t, e) {
                     const n = e.materialize().fork(),
                         i = this._dims.length;
                     let r = 0;
@@ -37848,29 +37986,29 @@
                         for (h = u, p = Math.min(c, f); h < p; ++h) m = o[h], r[m] ^= d, i.push(m);
                     if (l > f)
                         for (h = Math.max(c, f), p = l; h < p; ++h) m = o[h], r[m] ^= d, n.push(m);
                     else if (l < f)
                         for (h = Math.max(u, l), p = f; h < p; ++h) m = o[h], r[m] ^= d, i.push(m);
                     t.range = e.slice()
                 }
-            }), sA.Definition = {
+            }), pD.Definition = {
                 type: "ResolveFilter",
                 metadata: {},
                 params: [{
                     name: "ignore",
                     type: "number",
                     required: !0,
                     description: "A bit mask indicating which filters to ignore."
                 }, {
                     name: "filter",
                     type: "object",
                     required: !0,
                     description: "Per-tuple filter bitmaps from a CrossFilter transform."
                 }]
-            }, (0, m.XW)(sA, Rr, {
+            }, (0, m.XW)(pD, zr, {
                 transform(t, e) {
                     const n = ~(t.ignore || 0),
                         i = t.filter,
                         r = i.mask;
                     if (0 === (r & n)) return e.StopPropagation;
                     const o = e.fork(e.ALL),
                         a = i.data(),
@@ -37882,243 +38020,3504 @@
                         return !e && e ^ c[t] & n ? a[t] : null
                     })), o.filter(o.REM, (t => {
                         const e = s[t] & n;
                         return e && !(0 ^ c[t] & n) ? a[t] : null
                     }))) : (o.filter(o.ADD, l), o.filter(o.REM, (t => (s[t] & n) === r ? a[t] : null))), o.filter(o.SOURCE, (t => l(t._index)))
                 }
             });
-            var cA, lA, uA, fA, dA, hA, pA, mA, gA, vA, yA, bA, xA, _A, wA, kA, EA = n(88120),
-                DA = new jy,
-                AA = new jy,
-                SA = {
-                    point: cb,
-                    lineStart: cb,
-                    lineEnd: cb,
+            const mD = "linear",
+                gD = "log",
+                vD = "pow",
+                yD = "sqrt",
+                bD = "symlog",
+                xD = "time",
+                _D = "utc",
+                wD = "sequential",
+                kD = "diverging",
+                ED = "quantile",
+                AD = "quantize",
+                DD = "threshold",
+                SD = "continuous",
+                CD = "discrete",
+                MD = "discretizing",
+                FD = "interpolating",
+                OD = "temporal";
+
+            function TD() {
+                const t = (0, Jl.Z)().unknown(void 0),
+                    e = t.domain,
+                    n = t.range;
+                let i, r, o = [0, 1],
+                    a = !1,
+                    s = 0,
+                    c = 0,
+                    l = .5;
+
+                function u() {
+                    const t = e().length,
+                        u = o[1] < o[0],
+                        f = o[1 - u],
+                        d = function(t, e, n) {
+                            const i = t - e + 2 * n;
+                            return t ? i > 0 ? i : 1 : 0
+                        }(t, s, c);
+                    let h = o[u - 0];
+                    i = (f - h) / (d || 1), a && (i = Math.floor(i)), h += (f - h - i * (t - s)) * l, r = i * (1 - s), a && (h = Math.round(h), r = Math.round(r));
+                    const p = (0, Wo.Z)(t).map((t => h + i * t));
+                    return n(u ? p.reverse() : p)
+                }
+                return delete t.unknown, t.domain = function(t) {
+                    return arguments.length ? (e(t), u()) : e()
+                }, t.range = function(t) {
+                    return arguments.length ? (o = [+t[0], +t[1]], u()) : o.slice()
+                }, t.rangeRound = function(t) {
+                    return o = [+t[0], +t[1]], a = !0, u()
+                }, t.bandwidth = function() {
+                    return r
+                }, t.step = function() {
+                    return i
+                }, t.round = function(t) {
+                    return arguments.length ? (a = !!t, u()) : a
+                }, t.padding = function(t) {
+                    return arguments.length ? (c = Math.max(0, Math.min(1, t)), s = c, u()) : s
+                }, t.paddingInner = function(t) {
+                    return arguments.length ? (s = Math.max(0, Math.min(1, t)), u()) : s
+                }, t.paddingOuter = function(t) {
+                    return arguments.length ? (c = Math.max(0, Math.min(1, t)), u()) : c
+                }, t.align = function(t) {
+                    return arguments.length ? (l = Math.max(0, Math.min(1, t)), u()) : l
+                }, t.invertRange = function(t) {
+                    if (null == t[0] || null == t[1]) return;
+                    const i = o[1] < o[0],
+                        a = i ? n().reverse() : n(),
+                        s = a.length - 1;
+                    let c, l, u, f = +t[0],
+                        d = +t[1];
+                    return f !== f || d !== d || (d < f && (u = f, f = d, d = u), d < a[0] || f > o[1 - i]) ? void 0 : (c = Math.max(0, (0, ol.ml)(a, f) - 1), l = f === d ? c : (0, ol.ml)(a, d) - 1, f - a[c] > r + 1e-10 && ++c, i && (u = c, c = s - l, l = s - u), c > l ? void 0 : e().slice(c, l + 1))
+                }, t.invert = function(e) {
+                    const n = t.invertRange([e, e]);
+                    return n ? n[0] : n
+                }, t.copy = function() {
+                    return TD().domain(e()).range(o).round(a).paddingInner(s).paddingOuter(c).align(l)
+                }, u()
+            }
+
+            function ND(t) {
+                const e = t.copy;
+                return t.padding = t.paddingOuter, delete t.paddingInner, t.copy = function() {
+                    return ND(e())
+                }, t
+            }
+            var RD = Array.prototype.map;
+            const zD = Array.prototype.slice;
+            const PD = new Map,
+                LD = Symbol("vega_scale");
+
+            function BD(t, e, n) {
+                const i = function() {
+                    const n = e();
+                    return n.invertRange || (n.invertRange = n.invert ? function(t) {
+                            return function(e) {
+                                let n, i = e[0],
+                                    r = e[1];
+                                return r < i && (n = i, i = r, r = n), [t.invert(i), t.invert(r)]
+                            }
+                        }(n) : n.invertExtent ? function(t) {
+                            return function(e) {
+                                const n = t.range();
+                                let i, r, o, a, s = e[0],
+                                    c = e[1],
+                                    l = -1;
+                                for (c < s && (r = s, s = c, c = r), o = 0, a = n.length; o < a; ++o) n[o] >= s && n[o] <= c && (l < 0 && (l = o), i = o);
+                                if (!(l < 0)) return s = t.invertExtent(n[l]), c = t.invertExtent(n[i]), [void 0 === s[0] ? s[1] : s[0], void 0 === c[1] ? c[0] : c[1]]
+                            }
+                        }(n) : void 0), n.type = t,
+                        function(t) {
+                            return t[LD] = !0, t
+                        }(n)
+                };
+                return i.metadata = (0, m.Rg)((0, m.IX)(n)), i
+            }
+
+            function ID(t, e, n) {
+                return arguments.length > 1 ? (PD.set(t, BD(t, e, n)), this) : function(t) {
+                    return PD.has(t)
+                }(t) ? PD.get(t) : void 0
+            }
+
+            function jD(t, e) {
+                const n = PD.get(t);
+                return n && n.metadata[e]
+            }
+
+            function UD(t) {
+                return jD(t, CD)
+            }
+            ID("identity", cl), ID(mD, al.Z, SD), ID(gD, ll.Z, [SD, gD]), ID(vD, ul.ZP, SD), ID(yD, ul._b, SD), ID(bD, gl, SD), ID(xD, Dl, [SD, OD]), ID(_D, Sl, [SD, OD]), ID(wD, Tl, [SD, FD]), ID("".concat(wD, "-").concat(mD), Tl, [SD, FD]), ID("".concat(wD, "-").concat(gD), Nl, [SD, FD, gD]), ID("".concat(wD, "-").concat(vD), zl, [SD, FD]), ID("".concat(wD, "-").concat(yD), Pl, [SD, FD]), ID("".concat(wD, "-").concat(bD), Rl, [SD, FD]), ID("".concat(kD, "-").concat(mD), Il, [SD, FD]), ID("".concat(kD, "-").concat(gD), jl, [SD, FD, gD]), ID("".concat(kD, "-").concat(vD), ql, [SD, FD]), ID("".concat(kD, "-").concat(yD), Wl, [SD, FD]), ID("".concat(kD, "-").concat(bD), Ul, [SD, FD]), ID(ED, Hl.Z, [MD, ED]), ID(AD, Xl.Z, MD), ID(DD, Gl.Z, MD), ID("bin-ordinal", (function t() {
+                let e = [],
+                    n = [];
+
+                function i(t) {
+                    return null == t || t !== t ? void 0 : n[((0, ol.ZP)(e, t) - 1) % n.length]
+                }
+                return i.domain = function(t) {
+                    return arguments.length ? (e = function(t) {
+                        return RD.call(t, m.He)
+                    }(t), i) : e.slice()
+                }, i.range = function(t) {
+                    return arguments.length ? (n = zD.call(t), i) : n.slice()
+                }, i.tickFormat = function(t, n) {
+                    return (0, Zl.Z)(e[0], (0, m.fj)(e), null == t ? 10 : t, n)
+                }, i.copy = function() {
+                    return t().domain(i.domain()).range(i.range())
+                }, i
+            }), [CD, MD]), ID("ordinal", Jl.Z, CD), ID("band", TD, CD), ID("point", (function() {
+                return ND(TD().paddingInner(1))
+            }), CD);
+
+            function qD(t, e, n) {
+                return Ll(function(t, e) {
+                    const n = r[function(t) {
+                        return "interpolate" + t.toLowerCase().split("-").map((t => t[0].toUpperCase() + t.slice(1))).join("")
+                    }(t)];
+                    return null != e && n && n.gamma ? n.gamma(e) : n
+                }(e || "rgb", n), t)
+            }
+
+            function WD(t) {
+                const e = t.length / 6 | 0,
+                    n = new Array(e);
+                for (let i = 0; i < e;) n[i] = "#" + t.slice(6 * i, 6 * ++i);
+                return n
+            }
+
+            function HD(t, e) {
+                for (const n in t) GD(n, e(t[n]))
+            }
+            const XD = {};
+
+            function GD(t, e) {
+                return t = t && t.toLowerCase(), arguments.length > 1 ? (XD[t] = e, this) : XD[t]
+            }
+            HD({
+                category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
+                category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
+                category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
+                category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
+                tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
+                tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
+                accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
+                dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
+                paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
+                pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
+                pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
+                set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
+                set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
+                set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
+            }, WD), HD({
+                blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
+                greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
+                greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
+                oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
+                purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
+                reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
+                blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
+                bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
+                greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
+                orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
+                purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
+                purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
+                purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
+                redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
+                yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
+                yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
+                yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
+                blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
+                brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
+                purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
+                purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
+                redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
+                redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
+                yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
+                redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
+                redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
+                pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
+                spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
+                viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
+                magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
+                inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
+                plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
+                cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
+                rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
+                sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
+                turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
+                browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
+                tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
+                teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
+                warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
+                goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
+                goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
+                goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
+                lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
+                lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
+                lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
+                lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
+                lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
+                darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
+                darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
+                darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
+                darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
+                darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
+            }, (t => qD(WD(t))));
+            const JD = "symbol",
+                ZD = "discrete",
+                $D = t => (0, m.kJ)(t) ? t.map((t => String(t))) : String(t),
+                YD = (t, e) => t[1] - e[1],
+                VD = (t, e) => e[1] - t[1];
+
+            function KD(t, e) {
+                return t.bins ? function(t, e, n) {
+                    let i = t.range(),
+                        r = i[0],
+                        o = (0, m.fj)(i),
+                        a = YD;
+                    if (r > o && (i = o, o = r, r = i, a = VD), r = Math.floor(r), o = Math.ceil(o), e = e.map((e => [e, t(e)])).filter((t => r <= t[1] && t[1] <= o)).sort(a).map((t => t[0])), n > 0 && e.length > 1) {
+                        const t = [e[0], (0, m.fj)(e)];
+                        for (; e.length > n && e.length >= 3;) e = e.filter(((t, e) => !(e % 2)));
+                        e.length < 3 && (e = t)
+                    }
+                    return e
+                }(t, t.bins) : t.ticks ? t.ticks(e) : t.domain()
+            }
+
+            function QD(t, e, n, i, r, o) {
+                const a = e.type;
+                let s = $D;
+                if (a === xD || r === xD) s = t.timeFormat(i);
+                else if (a === _D || r === _D) s = t.utcFormat(i);
+                else if (jD(a, gD)) {
+                    const r = t.formatFloat(i);
+                    if (o || e.bins) s = r;
+                    else {
+                        const t = tS(e, n, !1);
+                        s = e => t(e) ? r(e) : ""
+                    }
+                } else if (e.tickFormat) {
+                    const r = e.domain();
+                    s = t.formatSpan(r[0], r[r.length - 1], n, i)
+                } else i && (s = t.format(i));
+                return s
+            }
+
+            function tS(t, e, n) {
+                const i = KD(t, e),
+                    r = t.base(),
+                    o = Math.log(r),
+                    a = Math.max(1, r * e / i.length),
+                    s = t => {
+                        let e = t / Math.pow(r, Math.round(Math.log(t) / o));
+                        return e * r < r - .5 && (e *= r), e <= a
+                    };
+                return n ? i.filter(s) : s
+            }
+            const eS = {
+                    [ED]: "quantiles",
+                    [AD]: "thresholds",
+                    [DD]: "domain"
+                },
+                nS = {
+                    [ED]: "quantiles",
+                    [AD]: "domain"
+                };
+
+            function iS(t, e) {
+                return t.bins ? function(t) {
+                    const e = t.slice(0, -1);
+                    return e.max = (0, m.fj)(t), e
+                }(t.bins) : t.type === gD ? tS(t, e, !0) : eS[t.type] ? function(t) {
+                    const e = [-1 / 0].concat(t);
+                    return e.max = 1 / 0, e
+                }(t[eS[t.type]]()) : KD(t, e)
+            }
+            const rS = t => eS[t.type] || t.bins;
+
+            function oS(t, e, n, i, r, o, a) {
+                const s = nS[e.type] && o !== xD && o !== _D ? function(t, e, n) {
+                    const i = e[nS[e.type]](),
+                        r = i.length;
+                    let o, a = r > 1 ? i[1] - i[0] : i[0];
+                    for (o = 1; o < r; ++o) a = Math.min(a, i[o] - i[o - 1]);
+                    return t.formatSpan(0, a, 30, n)
+                }(t, e, r) : QD(t, e, n, r, o, a);
+                return i === JD && rS(e) ? aS(s) : i === ZD ? cS(s) : lS(s)
+            }
+            const aS = t => (e, n, i) => {
+                    const r = sS(i[n + 1], sS(i.max, 1 / 0)),
+                        o = uS(e, t),
+                        a = uS(r, t);
+                    return o && a ? o + " \u2013 " + a : a ? "< " + a : "\u2265 " + o
+                },
+                sS = (t, e) => null != t ? t : e,
+                cS = t => (e, n) => n ? t(e) : null,
+                lS = t => e => t(e),
+                uS = (t, e) => Number.isFinite(t) ? e(t) : null;
+
+            function fS(t, e, n, i) {
+                const r = i || e.type;
+                return (0, m.HD)(n) && jD(r, OD) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), n || r !== xD ? n || r !== _D ? oS(t, e, 5, null, n, i, !0) : t.utcFormat("%A, %d %B %Y, %X UTC") : t.timeFormat("%A, %d %B %Y, %X")
+            }
+
+            function dS(t, e, n) {
+                n = n || {};
+                const i = Math.max(3, n.maxlen || 7),
+                    r = fS(t, e, n.format, n.formatType);
+                if (jD(e.type, MD)) {
+                    const t = iS(e).slice(1).map(r),
+                        n = t.length;
+                    return "".concat(n, " boundar").concat(1 === n ? "y" : "ies", ": ").concat(t.join(", "))
+                }
+                if (UD(e.type)) {
+                    const t = e.domain(),
+                        n = t.length,
+                        o = n > i ? t.slice(0, i - 2).map(r).join(", ") + ", ending with " + t.slice(-1).map(r) : t.map(r).join(", ");
+                    return "".concat(n, " value").concat(1 === n ? "" : "s", ": ").concat(o)
+                } {
+                    const t = e.domain();
+                    return "values from ".concat(r(t[0]), " to ").concat(r((0, m.fj)(t)))
+                }
+            }
+            let hS = 0;
+            const pS = "p_";
+
+            function mS(t) {
+                return t && t.gradient
+            }
+
+            function gS(t, e, n) {
+                const i = t.gradient;
+                let r = t.id,
+                    o = "radial" === i ? pS : "";
+                return r || (r = t.id = "gradient_" + hS++, "radial" === i ? (t.x1 = vS(t.x1, .5), t.y1 = vS(t.y1, .5), t.r1 = vS(t.r1, 0), t.x2 = vS(t.x2, .5), t.y2 = vS(t.y2, .5), t.r2 = vS(t.r2, .5), o = pS) : (t.x1 = vS(t.x1, 0), t.y1 = vS(t.y1, 0), t.x2 = vS(t.x2, 1), t.y2 = vS(t.y2, 0))), e[r] = t, "url(" + (n || "") + "#" + o + r + ")"
+            }
+
+            function vS(t, e) {
+                return null != t ? t : e
+            }
+
+            function yS(t, e) {
+                var n, i = [];
+                return n = {
+                    gradient: "linear",
+                    x1: t ? t[0] : 0,
+                    y1: t ? t[1] : 0,
+                    x2: e ? e[0] : 1,
+                    y2: e ? e[1] : 0,
+                    stops: i,
+                    stop: function(t, e) {
+                        return i.push({
+                            offset: t,
+                            color: e
+                        }), n
+                    }
+                }
+            }
+            const bS = {
+                basis: {
+                    curve: ys
+                },
+                "basis-closed": {
+                    curve: _s
+                },
+                "basis-open": {
+                    curve: ks
+                },
+                bundle: {
+                    curve: As,
+                    tension: "beta",
+                    value: .85
+                },
+                cardinal: {
+                    curve: Cs,
+                    tension: "tension",
+                    value: 0
+                },
+                "cardinal-open": {
+                    curve: Fs,
+                    tension: "tension",
+                    value: 0
+                },
+                "cardinal-closed": {
+                    curve: Ts,
+                    tension: "tension",
+                    value: 0
+                },
+                "catmull-rom": {
+                    curve: Js,
+                    tension: "alpha",
+                    value: .5
+                },
+                "catmull-rom-closed": {
+                    curve: $s,
+                    tension: "alpha",
+                    value: .5
+                },
+                "catmull-rom-open": {
+                    curve: Vs,
+                    tension: "alpha",
+                    value: .5
+                },
+                linear: {
+                    curve: Qs
+                },
+                "linear-closed": {
+                    curve: ec
+                },
+                monotone: {
+                    horizontal: uc,
+                    vertical: lc
+                },
+                natural: {
+                    curve: hc
+                },
+                step: {
+                    curve: mc
+                },
+                "step-after": {
+                    curve: vc
+                },
+                "step-before": {
+                    curve: gc
+                }
+            };
+
+            function xS(t, e, n) {
+                var i = (0, m.nr)(bS, t) && bS[t],
+                    r = null;
+                return i && (r = i.curve || i[e || "vertical"], i.tension && null != n && (r = r[i.tension](n))), r
+            }
+            const _S = {
+                    m: 2,
+                    l: 2,
+                    h: 1,
+                    v: 1,
+                    z: 0,
+                    c: 6,
+                    s: 4,
+                    q: 4,
+                    t: 2,
+                    a: 7
+                },
+                wS = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
+                kS = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
+                ES = /^((\s+,?\s*)|(,\s*))/,
+                AS = /^[01]/;
+
+            function DS(t) {
+                const e = [];
+                return (t.match(wS) || []).forEach((t => {
+                    let n = t[0];
+                    const i = n.toLowerCase(),
+                        r = _S[i],
+                        o = function(t, e, n) {
+                            const i = [];
+                            for (let r = 0; e && r < n.length;)
+                                for (let o = 0; o < e; ++o) {
+                                    const e = "a" !== t || 3 !== o && 4 !== o ? kS : AS,
+                                        a = n.slice(r).match(e);
+                                    if (null === a) throw Error("Invalid SVG path, incorrect parameter type");
+                                    r += a[0].length, i.push(+a[0]);
+                                    const s = n.slice(r).match(ES);
+                                    null !== s && (r += s[0].length)
+                                }
+                            return i
+                        }(i, r, t.slice(1).trim()),
+                        a = o.length;
+                    if (a < r || a && a % r !== 0) throw Error("Invalid SVG path, incorrect parameter count");
+                    if (e.push([n, ...o.slice(0, r)]), a !== r) {
+                        "m" === i && (n = "M" === n ? "L" : "l");
+                        for (let t = r; t < a; t += r) e.push([n, ...o.slice(t, t + r)])
+                    }
+                })), e
+            }
+            const SS = Math.PI / 180,
+                CS = Math.PI / 2,
+                MS = 2 * Math.PI,
+                FS = Math.sqrt(3) / 2;
+            var OS = {},
+                TS = {},
+                NS = [].join;
+
+            function RS(t) {
+                const e = NS.call(t);
+                if (TS[e]) return TS[e];
+                var n = t[0],
+                    i = t[1],
+                    r = t[2],
+                    o = t[3],
+                    a = t[4],
+                    s = t[5],
+                    c = t[6],
+                    l = t[7];
+                const u = l * a,
+                    f = -c * s,
+                    d = c * a,
+                    h = l * s,
+                    p = Math.cos(r),
+                    m = Math.sin(r),
+                    g = Math.cos(o),
+                    v = Math.sin(o),
+                    y = .5 * (o - r),
+                    b = Math.sin(.5 * y),
+                    x = 8 / 3 * b * b / Math.sin(y),
+                    _ = n + p - x * m,
+                    w = i + m + x * p,
+                    k = n + g,
+                    E = i + v,
+                    A = k + x * v,
+                    D = E - x * g;
+                return TS[e] = [u * _ + f * w, d * _ + h * w, u * A + f * D, d * A + h * D, u * k + f * E, d * k + h * E]
+            }
+            const zS = ["l", 0, 0, 0, 0, 0, 0, 0];
+
+            function PS(t, e, n) {
+                const i = zS[0] = t[0];
+                if ("a" === i || "A" === i) zS[1] = e * t[1], zS[2] = n * t[2], zS[3] = t[3], zS[4] = t[4], zS[5] = t[5], zS[6] = e * t[6], zS[7] = n * t[7];
+                else if ("h" === i || "H" === i) zS[1] = e * t[1];
+                else if ("v" === i || "V" === i) zS[1] = n * t[1];
+                else
+                    for (var r = 1, o = t.length; r < o; ++r) zS[r] = (r % 2 == 1 ? e : n) * t[r];
+                return zS
+            }
+
+            function LS(t, e, n, i, r, o) {
+                var a, s, c, l, u, f = null,
+                    d = 0,
+                    h = 0,
+                    p = 0,
+                    m = 0,
+                    g = 0,
+                    v = 0;
+                null == n && (n = 0), null == i && (i = 0), null == r && (r = 1), null == o && (o = r), t.beginPath && t.beginPath();
+                for (var y = 0, b = e.length; y < b; ++y) {
+                    switch (a = e[y], 1 === r && 1 === o || (a = PS(a, r, o)), a[0]) {
+                        case "l":
+                            d += a[1], h += a[2], t.lineTo(d + n, h + i);
+                            break;
+                        case "L":
+                            d = a[1], h = a[2], t.lineTo(d + n, h + i);
+                            break;
+                        case "h":
+                            d += a[1], t.lineTo(d + n, h + i);
+                            break;
+                        case "H":
+                            d = a[1], t.lineTo(d + n, h + i);
+                            break;
+                        case "v":
+                            h += a[1], t.lineTo(d + n, h + i);
+                            break;
+                        case "V":
+                            h = a[1], t.lineTo(d + n, h + i);
+                            break;
+                        case "m":
+                            g = d += a[1], v = h += a[2], t.moveTo(d + n, h + i);
+                            break;
+                        case "M":
+                            g = d = a[1], v = h = a[2], t.moveTo(d + n, h + i);
+                            break;
+                        case "c":
+                            s = d + a[5], c = h + a[6], p = d + a[3], m = h + a[4], t.bezierCurveTo(d + a[1] + n, h + a[2] + i, p + n, m + i, s + n, c + i), d = s, h = c;
+                            break;
+                        case "C":
+                            d = a[5], h = a[6], p = a[3], m = a[4], t.bezierCurveTo(a[1] + n, a[2] + i, p + n, m + i, d + n, h + i);
+                            break;
+                        case "s":
+                            s = d + a[3], c = h + a[4], p = 2 * d - p, m = 2 * h - m, t.bezierCurveTo(p + n, m + i, d + a[1] + n, h + a[2] + i, s + n, c + i), p = d + a[1], m = h + a[2], d = s, h = c;
+                            break;
+                        case "S":
+                            s = a[3], c = a[4], p = 2 * d - p, m = 2 * h - m, t.bezierCurveTo(p + n, m + i, a[1] + n, a[2] + i, s + n, c + i), d = s, h = c, p = a[1], m = a[2];
+                            break;
+                        case "q":
+                            s = d + a[3], c = h + a[4], p = d + a[1], m = h + a[2], t.quadraticCurveTo(p + n, m + i, s + n, c + i), d = s, h = c;
+                            break;
+                        case "Q":
+                            s = a[3], c = a[4], t.quadraticCurveTo(a[1] + n, a[2] + i, s + n, c + i), d = s, h = c, p = a[1], m = a[2];
+                            break;
+                        case "t":
+                            s = d + a[1], c = h + a[2], null === f[0].match(/[QqTt]/) ? (p = d, m = h) : "t" === f[0] ? (p = 2 * d - l, m = 2 * h - u) : "q" === f[0] && (p = 2 * d - p, m = 2 * h - m), l = p, u = m, t.quadraticCurveTo(p + n, m + i, s + n, c + i), h = c, p = (d = s) + a[1], m = h + a[2];
+                            break;
+                        case "T":
+                            s = a[1], c = a[2], p = 2 * d - p, m = 2 * h - m, t.quadraticCurveTo(p + n, m + i, s + n, c + i), d = s, h = c;
+                            break;
+                        case "a":
+                            BS(t, d + n, h + i, [a[1], a[2], a[3], a[4], a[5], a[6] + d + n, a[7] + h + i]), d += a[6], h += a[7];
+                            break;
+                        case "A":
+                            BS(t, d + n, h + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), d = a[6], h = a[7];
+                            break;
+                        case "z":
+                        case "Z":
+                            d = g, h = v, t.closePath()
+                    }
+                    f = a
+                }
+            }
+
+            function BS(t, e, n, i) {
+                const r = function(t, e, n, i, r, o, a, s, c) {
+                    const l = NS.call(arguments);
+                    if (OS[l]) return OS[l];
+                    const u = a * SS,
+                        f = Math.sin(u),
+                        d = Math.cos(u),
+                        h = d * (s - t) * .5 + f * (c - e) * .5,
+                        p = d * (c - e) * .5 - f * (s - t) * .5;
+                    let m = h * h / ((n = Math.abs(n)) * n) + p * p / ((i = Math.abs(i)) * i);
+                    m > 1 && (m = Math.sqrt(m), n *= m, i *= m);
+                    const g = d / n,
+                        v = f / n,
+                        y = -f / i,
+                        b = d / i,
+                        x = g * s + v * c,
+                        _ = y * s + b * c,
+                        w = g * t + v * e,
+                        k = y * t + b * e;
+                    let E = 1 / ((w - x) * (w - x) + (k - _) * (k - _)) - .25;
+                    E < 0 && (E = 0);
+                    let A = Math.sqrt(E);
+                    o == r && (A = -A);
+                    const D = .5 * (x + w) - A * (k - _),
+                        S = .5 * (_ + k) + A * (w - x),
+                        C = Math.atan2(_ - S, x - D);
+                    let M = Math.atan2(k - S, w - D) - C;
+                    M < 0 && 1 === o ? M += MS : M > 0 && 0 === o && (M -= MS);
+                    const F = Math.ceil(Math.abs(M / (CS + .001))),
+                        O = [];
+                    for (let T = 0; T < F; ++T) {
+                        const t = C + T * M / F,
+                            e = C + (T + 1) * M / F;
+                        O[T] = [D, S, t, e, n, i, f, d]
+                    }
+                    return OS[l] = O
+                }(i[5], i[6], i[0], i[1], i[3], i[4], i[2], e, n);
+                for (let o = 0; o < r.length; ++o) {
+                    const e = RS(r[o]);
+                    t.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5])
+                }
+            }
+            const IS = .5773502691896257,
+                jS = {
+                    circle: {
+                        draw: function(t, e) {
+                            const n = Math.sqrt(e) / 2;
+                            t.moveTo(n, 0), t.arc(0, 0, n, 0, MS)
+                        }
+                    },
+                    cross: {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = n / 2.5;
+                            t.moveTo(-n, -i), t.lineTo(-n, i), t.lineTo(-i, i), t.lineTo(-i, n), t.lineTo(i, n), t.lineTo(i, i), t.lineTo(n, i), t.lineTo(n, -i), t.lineTo(i, -i), t.lineTo(i, -n), t.lineTo(-i, -n), t.lineTo(-i, -i), t.closePath()
+                        }
+                    },
+                    diamond: {
+                        draw: function(t, e) {
+                            const n = Math.sqrt(e) / 2;
+                            t.moveTo(-n, 0), t.lineTo(0, -n), t.lineTo(n, 0), t.lineTo(0, n), t.closePath()
+                        }
+                    },
+                    square: {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e),
+                                i = -n / 2;
+                            t.rect(i, i, n, n)
+                        }
+                    },
+                    arrow: {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = n / 7,
+                                r = n / 2.5,
+                                o = n / 8;
+                            t.moveTo(-i, n), t.lineTo(i, n), t.lineTo(i, -o), t.lineTo(r, -o), t.lineTo(0, -n), t.lineTo(-r, -o), t.lineTo(-i, -o), t.closePath()
+                        }
+                    },
+                    wedge: {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = FS * n,
+                                r = i - n * IS,
+                                o = n / 4;
+                            t.moveTo(0, -i - r), t.lineTo(-o, i - r), t.lineTo(o, i - r), t.closePath()
+                        }
+                    },
+                    triangle: {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = FS * n,
+                                r = i - n * IS;
+                            t.moveTo(0, -i - r), t.lineTo(-n, i - r), t.lineTo(n, i - r), t.closePath()
+                        }
+                    },
+                    "triangle-up": {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = FS * n;
+                            t.moveTo(0, -i), t.lineTo(-n, i), t.lineTo(n, i), t.closePath()
+                        }
+                    },
+                    "triangle-down": {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = FS * n;
+                            t.moveTo(0, i), t.lineTo(-n, -i), t.lineTo(n, -i), t.closePath()
+                        }
+                    },
+                    "triangle-right": {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = FS * n;
+                            t.moveTo(i, 0), t.lineTo(-i, -n), t.lineTo(-i, n), t.closePath()
+                        }
+                    },
+                    "triangle-left": {
+                        draw: function(t, e) {
+                            var n = Math.sqrt(e) / 2,
+                                i = FS * n;
+                            t.moveTo(-i, 0), t.lineTo(i, -n), t.lineTo(i, n), t.closePath()
+                        }
+                    },
+                    stroke: {
+                        draw: function(t, e) {
+                            const n = Math.sqrt(e) / 2;
+                            t.moveTo(-n, 0), t.lineTo(n, 0)
+                        }
+                    }
+                };
+
+            function US(t) {
+                return (0, m.nr)(jS, t) ? jS[t] : function(t) {
+                    if (!(0, m.nr)(qS, t)) {
+                        const e = DS(t);
+                        qS[t] = {
+                            draw: function(t, n) {
+                                LS(t, e, 0, 0, Math.sqrt(n) / 2)
+                            }
+                        }
+                    }
+                    return qS[t]
+                }(t)
+            }
+            var qS = {};
+            const WS = .448084975506;
+
+            function HS(t) {
+                return t.x
+            }
+
+            function XS(t) {
+                return t.y
+            }
+
+            function GS(t) {
+                return t.width
+            }
+
+            function JS(t) {
+                return t.height
+            }
+
+            function ZS(t) {
+                return "function" === typeof t ? t : () => +t
+            }
+
+            function $S(t, e, n) {
+                return Math.max(e, Math.min(t, n))
+            }
+
+            function YS() {
+                var t = HS,
+                    e = XS,
+                    n = GS,
+                    i = JS,
+                    r = ZS(0),
+                    o = r,
+                    a = r,
+                    s = r,
+                    c = null;
+
+                function l(l, u, f) {
+                    var d, h = null != u ? u : +t.call(this, l),
+                        p = null != f ? f : +e.call(this, l),
+                        m = +n.call(this, l),
+                        g = +i.call(this, l),
+                        v = Math.min(m, g) / 2,
+                        y = $S(+r.call(this, l), 0, v),
+                        b = $S(+o.call(this, l), 0, v),
+                        x = $S(+a.call(this, l), 0, v),
+                        _ = $S(+s.call(this, l), 0, v);
+                    if (c || (c = d = jc()), y <= 0 && b <= 0 && x <= 0 && _ <= 0) c.rect(h, p, m, g);
+                    else {
+                        var w = h + m,
+                            k = p + g;
+                        c.moveTo(h + y, p), c.lineTo(w - b, p), c.bezierCurveTo(w - WS * b, p, w, p + WS * b, w, p + b), c.lineTo(w, k - _), c.bezierCurveTo(w, k - WS * _, w - WS * _, k, w - _, k), c.lineTo(h + x, k), c.bezierCurveTo(h + WS * x, k, h, k - WS * x, h, k - x), c.lineTo(h, p + y), c.bezierCurveTo(h, p + WS * y, h + WS * y, p, h + y, p), c.closePath()
+                    }
+                    if (d) return c = null, d + "" || null
+                }
+                return l.x = function(e) {
+                    return arguments.length ? (t = ZS(e), l) : t
+                }, l.y = function(t) {
+                    return arguments.length ? (e = ZS(t), l) : e
+                }, l.width = function(t) {
+                    return arguments.length ? (n = ZS(t), l) : n
+                }, l.height = function(t) {
+                    return arguments.length ? (i = ZS(t), l) : i
+                }, l.cornerRadius = function(t, e, n, i) {
+                    return arguments.length ? (r = ZS(t), o = null != e ? ZS(e) : r, s = null != n ? ZS(n) : r, a = null != i ? ZS(i) : o, l) : r
+                }, l.context = function(t) {
+                    return arguments.length ? (c = null == t ? null : t, l) : c
+                }, l
+            }
+
+            function VS() {
+                var t, e, n, i, r, o, a, s, c = null;
+
+                function l(t, e, n) {
+                    const i = n / 2;
+                    if (r) {
+                        var l = a - e,
+                            u = t - o;
+                        if (l || u) {
+                            var f = Math.hypot(l, u),
+                                d = (l /= f) * s,
+                                h = (u /= f) * s,
+                                p = Math.atan2(u, l);
+                            c.moveTo(o - d, a - h), c.lineTo(t - l * i, e - u * i), c.arc(t, e, i, p - Math.PI, p), c.lineTo(o + d, a + h), c.arc(o, a, s, p, p + Math.PI)
+                        } else c.arc(t, e, i, 0, MS);
+                        c.closePath()
+                    } else r = 1;
+                    o = t, a = e, s = i
+                }
+
+                function u(o) {
+                    var a, s, u, f = o.length,
+                        d = !1;
+                    for (null == c && (c = u = jc()), a = 0; a <= f; ++a) !(a < f && i(s = o[a], a, o)) === d && (d = !d) && (r = 0), d && l(+t(s, a, o), +e(s, a, o), +n(s, a, o));
+                    if (u) return c = null, u + "" || null
+                }
+                return u.x = function(e) {
+                    return arguments.length ? (t = e, u) : t
+                }, u.y = function(t) {
+                    return arguments.length ? (e = t, u) : e
+                }, u.size = function(t) {
+                    return arguments.length ? (n = t, u) : n
+                }, u.defined = function(t) {
+                    return arguments.length ? (i = t, u) : i
+                }, u.context = function(t) {
+                    return arguments.length ? (c = null == t ? null : t, u) : c
+                }, u
+            }
+
+            function KS(t, e) {
+                return null != t ? t : e
+            }
+            const QS = t => t.x || 0,
+                tC = t => t.y || 0,
+                eC = t => !(!1 === t.defined),
+                nC = Zc().startAngle((t => t.startAngle || 0)).endAngle((t => t.endAngle || 0)).padAngle((t => t.padAngle || 0)).innerRadius((t => t.innerRadius || 0)).outerRadius((t => t.outerRadius || 0)).cornerRadius((t => t.cornerRadius || 0)),
+                iC = Qc().x(QS).y1(tC).y0((t => (t.y || 0) + (t.height || 0))).defined(eC),
+                rC = Qc().y(tC).x1(QS).x0((t => (t.x || 0) + (t.width || 0))).defined(eC),
+                oC = Kc().x(QS).y(tC).defined(eC),
+                aC = YS().x(QS).y(tC).width((t => t.width || 0)).height((t => t.height || 0)).cornerRadius((t => KS(t.cornerRadiusTopLeft, t.cornerRadius) || 0), (t => KS(t.cornerRadiusTopRight, t.cornerRadius) || 0), (t => KS(t.cornerRadiusBottomRight, t.cornerRadius) || 0), (t => KS(t.cornerRadiusBottomLeft, t.cornerRadius) || 0)),
+                sC = nl().type((t => US(t.shape || "circle"))).size((t => KS(t.size, 64))),
+                cC = VS().x(QS).y(tC).defined(eC).size((t => t.size || 1));
+
+            function lC(t) {
+                return t.cornerRadius || t.cornerRadiusTopLeft || t.cornerRadiusTopRight || t.cornerRadiusBottomRight || t.cornerRadiusBottomLeft
+            }
+
+            function uC(t, e, n, i) {
+                return aC.context(t)(e, n, i)
+            }
+            var fC = 1;
+
+            function dC() {
+                fC = 1
+            }
+
+            function hC(t, e, n) {
+                var i = e.clip,
+                    r = t._defs,
+                    o = e.clip_id || (e.clip_id = "clip" + fC++),
+                    a = r.clipping[o] || (r.clipping[o] = {
+                        id: o
+                    });
+                return (0, m.mf)(i) ? a.path = i(null) : lC(n) ? a.path = uC(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + o + ")"
+            }
+
+            function pC(t) {
+                this.clear(), t && this.union(t)
+            }
+
+            function mC(t) {
+                this.mark = t, this.bounds = this.bounds || new pC
+            }
+
+            function gC(t) {
+                mC.call(this, t), this.items = this.items || []
+            }
+
+            function vC(t) {
+                this._pending = 0, this._loader = t || Yi()
+            }
+
+            function yC(t) {
+                t._pending += 1
+            }
+
+            function bC(t) {
+                t._pending -= 1
+            }
+
+            function xC(t, e, n) {
+                if (e.stroke && 0 !== e.opacity && 0 !== e.strokeOpacity) {
+                    const i = null != e.strokeWidth ? +e.strokeWidth : 1;
+                    t.expand(i + (n ? function(t, e) {
+                        return t.strokeJoin && "miter" !== t.strokeJoin ? 0 : e
+                    }(e, i) : 0))
+                }
+                return t
+            }
+            pC.prototype = {
+                clone() {
+                    return new pC(this)
+                },
+                clear() {
+                    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this
+                },
+                empty() {
+                    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE
+                },
+                equals(t) {
+                    return this.x1 === t.x1 && this.y1 === t.y1 && this.x2 === t.x2 && this.y2 === t.y2
+                },
+                set(t, e, n, i) {
+                    return n < t ? (this.x2 = t, this.x1 = n) : (this.x1 = t, this.x2 = n), i < e ? (this.y2 = e, this.y1 = i) : (this.y1 = e, this.y2 = i), this
+                },
+                add(t, e) {
+                    return t < this.x1 && (this.x1 = t), e < this.y1 && (this.y1 = e), t > this.x2 && (this.x2 = t), e > this.y2 && (this.y2 = e), this
+                },
+                expand(t) {
+                    return this.x1 -= t, this.y1 -= t, this.x2 += t, this.y2 += t, this
+                },
+                round() {
+                    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this
+                },
+                scale(t) {
+                    return this.x1 *= t, this.y1 *= t, this.x2 *= t, this.y2 *= t, this
+                },
+                translate(t, e) {
+                    return this.x1 += t, this.x2 += t, this.y1 += e, this.y2 += e, this
+                },
+                rotate(t, e, n) {
+                    const i = this.rotatedPoints(t, e, n);
+                    return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7])
+                },
+                rotatedPoints(t, e, n) {
+                    var {
+                        x1: i,
+                        y1: r,
+                        x2: o,
+                        y2: a
+                    } = this, s = Math.cos(t), c = Math.sin(t), l = e - e * s + n * c, u = n - e * c - n * s;
+                    return [s * i - c * r + l, c * i + s * r + u, s * i - c * a + l, c * i + s * a + u, s * o - c * r + l, c * o + s * r + u, s * o - c * a + l, c * o + s * a + u]
+                },
+                union(t) {
+                    return t.x1 < this.x1 && (this.x1 = t.x1), t.y1 < this.y1 && (this.y1 = t.y1), t.x2 > this.x2 && (this.x2 = t.x2), t.y2 > this.y2 && (this.y2 = t.y2), this
+                },
+                intersect(t) {
+                    return t.x1 > this.x1 && (this.x1 = t.x1), t.y1 > this.y1 && (this.y1 = t.y1), t.x2 < this.x2 && (this.x2 = t.x2), t.y2 < this.y2 && (this.y2 = t.y2), this
+                },
+                encloses(t) {
+                    return t && this.x1 <= t.x1 && this.x2 >= t.x2 && this.y1 <= t.y1 && this.y2 >= t.y2
+                },
+                alignsWith(t) {
+                    return t && (this.x1 == t.x1 || this.x2 == t.x2 || this.y1 == t.y1 || this.y2 == t.y2)
+                },
+                intersects(t) {
+                    return t && !(this.x2 < t.x1 || this.x1 > t.x2 || this.y2 < t.y1 || this.y1 > t.y2)
+                },
+                contains(t, e) {
+                    return !(t < this.x1 || t > this.x2 || e < this.y1 || e > this.y2)
+                },
+                width() {
+                    return this.x2 - this.x1
+                },
+                height() {
+                    return this.y2 - this.y1
+                }
+            }, (0, m.XW)(gC, mC), vC.prototype = {
+                pending() {
+                    return this._pending
+                },
+                sanitizeURL(t) {
+                    const e = this;
+                    return yC(e), e._loader.sanitize(t, {
+                        context: "href"
+                    }).then((t => (bC(e), t))).catch((() => (bC(e), null)))
+                },
+                loadImage(t) {
+                    const e = this,
+                        n = rl();
+                    return yC(e), e._loader.sanitize(t, {
+                        context: "image"
+                    }).then((t => {
+                        const i = t.href;
+                        if (!i || !n) throw {
+                            url: i
+                        };
+                        const r = new n,
+                            o = (0, m.nr)(t, "crossOrigin") ? t.crossOrigin : "anonymous";
+                        return null != o && (r.crossOrigin = o), r.onload = () => bC(e), r.onerror = () => bC(e), r.src = i, r
+                    })).catch((t => (bC(e), {
+                        complete: !1,
+                        width: 0,
+                        height: 0,
+                        src: t && t.url || ""
+                    })))
+                },
+                ready() {
+                    const t = this;
+                    return new Promise((e => {
+                        ! function n(i) {
+                            t.pending() ? setTimeout((() => {
+                                n(!0)
+                            }), 10) : e(i)
+                        }(!1)
+                    }))
+                }
+            };
+            const _C = MS - 1e-8;
+            let wC, kC, EC, AC, DC, SC, CC, MC;
+            const FC = (t, e) => wC.add(t, e),
+                OC = (t, e) => FC(kC = t, EC = e),
+                TC = t => FC(t, wC.y1),
+                NC = t => FC(wC.x1, t),
+                RC = (t, e) => DC * t + CC * e,
+                zC = (t, e) => SC * t + MC * e,
+                PC = (t, e) => FC(RC(t, e), zC(t, e)),
+                LC = (t, e) => OC(RC(t, e), zC(t, e));
+
+            function BC(t, e) {
+                return wC = t, e ? (AC = e * SS, DC = MC = Math.cos(AC), SC = Math.sin(AC), CC = -SC) : (DC = MC = 1, AC = SC = CC = 0), IC
+            }
+            const IC = {
+                beginPath() {},
+                closePath() {},
+                moveTo: LC,
+                lineTo: LC,
+                rect(t, e, n, i) {
+                    AC ? (PC(t + n, e), PC(t + n, e + i), PC(t, e + i), LC(t, e)) : (FC(t + n, e + i), OC(t, e))
+                },
+                quadraticCurveTo(t, e, n, i) {
+                    const r = RC(t, e),
+                        o = zC(t, e),
+                        a = RC(n, i),
+                        s = zC(n, i);
+                    jC(kC, r, a, TC), jC(EC, o, s, NC), OC(a, s)
+                },
+                bezierCurveTo(t, e, n, i, r, o) {
+                    const a = RC(t, e),
+                        s = zC(t, e),
+                        c = RC(n, i),
+                        l = zC(n, i),
+                        u = RC(r, o),
+                        f = zC(r, o);
+                    UC(kC, a, c, u, TC), UC(EC, s, l, f, NC), OC(u, f)
+                },
+                arc(t, e, n, i, r, o) {
+                    if (i += AC, r += AC, kC = n * Math.cos(r) + t, EC = n * Math.sin(r) + e, Math.abs(r - i) > _C) FC(t - n, e - n), FC(t + n, e + n);
+                    else {
+                        const a = i => FC(n * Math.cos(i) + t, n * Math.sin(i) + e);
+                        let s, c;
+                        if (a(i), a(r), r !== i)
+                            if ((i %= MS) < 0 && (i += MS), (r %= MS) < 0 && (r += MS), r < i && (o = !o, s = i, i = r, r = s), o)
+                                for (r -= MS, s = i - i % CS, c = 0; c < 4 && s > r; ++c, s -= CS) a(s);
+                            else
+                                for (s = i - i % CS + CS, c = 0; c < 4 && s < r; ++c, s += CS) a(s)
+                    }
+                }
+            };
+
+            function jC(t, e, n, i) {
+                const r = (t - e) / (t + n - 2 * e);
+                0 < r && r < 1 && i(t + (e - t) * r)
+            }
+
+            function UC(t, e, n, i, r) {
+                const o = i - t + 3 * e - 3 * n,
+                    a = t + n - 2 * e,
+                    s = t - e;
+                let c, l = 0,
+                    u = 0;
+                Math.abs(o) > 1e-14 ? (c = a * a + s * o, c >= 0 && (c = Math.sqrt(c), l = (-a + c) / o, u = (-a - c) / o)) : l = .5 * s / a, 0 < l && l < 1 && r(qC(l, t, e, n, i)), 0 < u && u < 1 && r(qC(u, t, e, n, i))
+            }
+
+            function qC(t, e, n, i, r) {
+                const o = 1 - t,
+                    a = o * o,
+                    s = t * t;
+                return a * o * e + 3 * a * t * n + 3 * o * s * i + s * t * r
+            }
+            var WC = (WC = il(1, 1)) ? WC.getContext("2d") : null;
+            const HC = new pC;
+
+            function XC(t) {
+                return function(e, n) {
+                    if (!WC) return !0;
+                    t(WC, e), HC.clear().union(e.bounds).intersect(n).round();
+                    const {
+                        x1: i,
+                        y1: r,
+                        x2: o,
+                        y2: a
+                    } = HC;
+                    for (let t = r; t <= a; ++t)
+                        for (let e = i; e <= o; ++e)
+                            if (WC.isPointInPath(e, t)) return !0;
+                    return !1
+                }
+            }
+
+            function GC(t, e) {
+                return e.contains(t.x || 0, t.y || 0)
+            }
+
+            function JC(t, e) {
+                const n = t.x || 0,
+                    i = t.y || 0,
+                    r = t.width || 0,
+                    o = t.height || 0;
+                return e.intersects(HC.set(n, i, n + r, i + o))
+            }
+
+            function ZC(t, e) {
+                const n = t.x || 0,
+                    i = t.y || 0;
+                return $C(e, n, i, null != t.x2 ? t.x2 : n, null != t.y2 ? t.y2 : i)
+            }
+
+            function $C(t, e, n, i, r) {
+                const {
+                    x1: o,
+                    y1: a,
+                    x2: s,
+                    y2: c
+                } = t, l = i - e, u = r - n;
+                let f, d, h, p, m = 0,
+                    g = 1;
+                for (p = 0; p < 4; ++p) {
+                    if (0 === p && (f = -l, d = -(o - e)), 1 === p && (f = l, d = s - e), 2 === p && (f = -u, d = -(a - n)), 3 === p && (f = u, d = c - n), Math.abs(f) < 1e-10 && d < 0) return !1;
+                    if (h = d / f, f < 0) {
+                        if (h > g) return !1;
+                        h > m && (m = h)
+                    } else if (f > 0) {
+                        if (h < m) return !1;
+                        h < g && (g = h)
+                    }
+                }
+                return !0
+            }
+
+            function YC(t, e) {
+                t.globalCompositeOperation = e.blend || "source-over"
+            }
+
+            function VC(t, e) {
+                return null == t ? e : t
+            }
+
+            function KC(t, e) {
+                const n = e.length;
+                for (let i = 0; i < n; ++i) t.addColorStop(e[i].offset, e[i].color);
+                return t
+            }
+
+            function QC(t, e, n) {
+                return mS(n) ? function(t, e, n) {
+                    const i = n.width(),
+                        r = n.height();
+                    let o;
+                    if ("radial" === e.gradient) o = t.createRadialGradient(n.x1 + VC(e.x1, .5) * i, n.y1 + VC(e.y1, .5) * r, Math.max(i, r) * VC(e.r1, 0), n.x1 + VC(e.x2, .5) * i, n.y1 + VC(e.y2, .5) * r, Math.max(i, r) * VC(e.r2, .5));
+                    else {
+                        const a = VC(e.x1, 0),
+                            s = VC(e.y1, 0),
+                            c = VC(e.x2, 1),
+                            l = VC(e.y2, 0);
+                        if (a !== c && s !== l && i !== r) {
+                            const n = il(Math.ceil(i), Math.ceil(r)),
+                                o = n.getContext("2d");
+                            return o.scale(i, r), o.fillStyle = KC(o.createLinearGradient(a, s, c, l), e.stops), o.fillRect(0, 0, i, r), t.createPattern(n, "no-repeat")
+                        }
+                        o = t.createLinearGradient(n.x1 + a * i, n.y1 + s * r, n.x1 + c * i, n.y1 + l * r)
+                    }
+                    return KC(o, e.stops)
+                }(t, n, e.bounds) : n
+            }
+
+            function tM(t, e, n) {
+                return (n *= null == e.fillOpacity ? 1 : e.fillOpacity) > 0 && (t.globalAlpha = n, t.fillStyle = QC(t, e, e.fill), !0)
+            }
+            var eM = [];
+
+            function nM(t, e, n) {
+                var i = null != (i = e.strokeWidth) ? i : 1;
+                return !(i <= 0) && ((n *= null == e.strokeOpacity ? 1 : e.strokeOpacity) > 0 && (t.globalAlpha = n, t.strokeStyle = QC(t, e, e.stroke), t.lineWidth = i, t.lineCap = e.strokeCap || "butt", t.lineJoin = e.strokeJoin || "miter", t.miterLimit = e.strokeMiterLimit || 10, t.setLineDash && (t.setLineDash(e.strokeDash || eM), t.lineDashOffset = e.strokeDashOffset || 0), !0))
+            }
+
+            function iM(t, e) {
+                return t.zindex - e.zindex || t.index - e.index
+            }
+
+            function rM(t) {
+                if (!t.zdirty) return t.zitems;
+                var e, n, i, r = t.items,
+                    o = [];
+                for (n = 0, i = r.length; n < i; ++n)(e = r[n]).index = n, e.zindex && o.push(e);
+                return t.zdirty = !1, t.zitems = o.sort(iM)
+            }
+
+            function oM(t, e) {
+                var n, i, r = t.items;
+                if (!r || !r.length) return;
+                const o = rM(t);
+                if (o && o.length) {
+                    for (n = 0, i = r.length; n < i; ++n) r[n].zindex || e(r[n]);
+                    r = o
+                }
+                for (n = 0, i = r.length; n < i; ++n) e(r[n])
+            }
+
+            function aM(t, e) {
+                var n, i, r = t.items;
+                if (!r || !r.length) return null;
+                const o = rM(t);
+                for (o && o.length && (r = o), i = r.length; --i >= 0;)
+                    if (n = e(r[i])) return n;
+                if (r === o)
+                    for (i = (r = t.items).length; --i >= 0;)
+                        if (!r[i].zindex && (n = e(r[i]))) return n;
+                return null
+            }
+
+            function sM(t) {
+                return function(e, n, i) {
+                    oM(n, (n => {
+                        i && !i.intersects(n.bounds) || lM(t, e, n, n)
+                    }))
+                }
+            }
+
+            function cM(t) {
+                return function(e, n, i) {
+                    !n.items.length || i && !i.intersects(n.bounds) || lM(t, e, n.items[0], n.items)
+                }
+            }
+
+            function lM(t, e, n, i) {
+                var r = null == n.opacity ? 1 : n.opacity;
+                0 !== r && (t(e, i) || (YC(e, n), n.fill && tM(e, n, r) && e.fill(), n.stroke && nM(e, n, r) && e.stroke()))
+            }
+
+            function uM(t) {
+                return t = t || m.yb,
+                    function(e, n, i, r, o, a) {
+                        return i *= e.pixelRatio, r *= e.pixelRatio, aM(n, (n => {
+                            const s = n.bounds;
+                            if ((!s || s.contains(o, a)) && s) return t(e, n, i, r, o, a) ? n : void 0
+                        }))
+                    }
+            }
+
+            function fM(t, e) {
+                return function(n, i, r, o) {
+                    var a, s, c = Array.isArray(i) ? i[0] : i,
+                        l = null == e ? c.fill : e,
+                        u = c.stroke && n.isPointInStroke;
+                    return u && (a = c.strokeWidth, s = c.strokeCap, n.lineWidth = null != a ? a : 1, n.lineCap = null != s ? s : "butt"), !t(n, i) && (l && n.isPointInPath(r, o) || u && n.isPointInStroke(r, o))
+                }
+            }
+
+            function dM(t) {
+                return uM(fM(t))
+            }
+
+            function hM(t, e) {
+                return "translate(" + t + "," + e + ")"
+            }
+
+            function pM(t) {
+                return "rotate(" + t + ")"
+            }
+
+            function mM(t) {
+                return hM(t.x || 0, t.y || 0)
+            }
+
+            function gM(t, e, n) {
+                function i(t, n) {
+                    var i = n.x || 0,
+                        r = n.y || 0,
+                        o = n.angle || 0;
+                    t.translate(i, r), o && t.rotate(o *= SS), t.beginPath(), e(t, n), o && t.rotate(-o), t.translate(-i, -r)
+                }
+                return {
+                    type: t,
+                    tag: "path",
+                    nested: !1,
+                    attr: function(t, n) {
+                        t("transform", function(t) {
+                            return hM(t.x || 0, t.y || 0) + (t.angle ? " " + pM(t.angle) : "")
+                        }(n)), t("d", e(null, n))
+                    },
+                    bound: function(t, n) {
+                        return e(BC(t, n.angle), n), xC(t, n).translate(n.x || 0, n.y || 0)
+                    },
+                    draw: sM(i),
+                    pick: dM(i),
+                    isect: n || XC(i)
+                }
+            }
+            var vM = gM("arc", (function(t, e) {
+                return nC.context(t)(e)
+            }));
+
+            function yM(t, e, n) {
+                function i(t, n) {
+                    t.beginPath(), e(t, n)
+                }
+                const r = fM(i);
+                return {
+                    type: t,
+                    tag: "path",
+                    nested: !0,
+                    attr: function(t, n) {
+                        var i = n.mark.items;
+                        i.length && t("d", e(null, i))
+                    },
+                    bound: function(t, n) {
+                        var i = n.items;
+                        return 0 === i.length ? t : (e(BC(t), i), xC(t, i[0]))
+                    },
+                    draw: cM(i),
+                    pick: function(t, e, n, i, o, a) {
+                        var s = e.items,
+                            c = e.bounds;
+                        return !s || !s.length || c && !c.contains(o, a) ? null : (n *= t.pixelRatio, i *= t.pixelRatio, r(t, s, n, i) ? s[0] : null)
+                    },
+                    isect: GC,
+                    tip: n
+                }
+            }
+            var bM = yM("area", (function(t, e) {
+                const n = e[0],
+                    i = n.interpolate || "linear";
+                return ("horizontal" === n.orient ? rC : iC).curve(xS(i, n.orient, n.tension)).context(t)(e)
+            }), (function(t, e) {
+                for (var n, i, r = "horizontal" === t[0].orient ? e[1] : e[0], o = "horizontal" === t[0].orient ? "y" : "x", a = t.length, s = 1 / 0; --a >= 0;) !1 !== t[a].defined && (i = Math.abs(t[a][o] - r)) < s && (s = i, n = t[a]);
+                return n
+            }));
+
+            function xM(t, e) {
+                t.beginPath(), lC(e) ? uC(t, e, 0, 0) : t.rect(0, 0, e.width || 0, e.height || 0), t.clip()
+            }
+
+            function _M(t) {
+                const e = VC(t.strokeWidth, 1);
+                return null != t.strokeOffset ? t.strokeOffset : t.stroke && e > .5 && e < 1.5 ? .5 - Math.abs(e - 1) : 0
+            }
+
+            function wM(t, e) {
+                const n = _M(e);
+                t("d", uC(null, e, n, n))
+            }
+
+            function kM(t, e, n, i) {
+                const r = _M(e);
+                t.beginPath(), uC(t, e, (n || 0) + r, (i || 0) + r)
+            }
+            const EM = fM(kM),
+                AM = fM(kM, !1),
+                DM = fM(kM, !0);
+            var SM = {
+                    type: "group",
+                    tag: "g",
+                    nested: !1,
+                    attr: function(t, e) {
+                        t("transform", mM(e))
+                    },
+                    bound: function(t, e) {
+                        if (!e.clip && e.items) {
+                            const n = e.items,
+                                i = n.length;
+                            for (let e = 0; e < i; ++e) t.union(n[e].bounds)
+                        }
+                        return (e.clip || e.width || e.height) && !e.noBound && t.add(0, 0).add(e.width || 0, e.height || 0), xC(t, e), t.translate(e.x || 0, e.y || 0)
+                    },
+                    draw: function(t, e, n, i) {
+                        oM(e, (e => {
+                            const r = e.x || 0,
+                                o = e.y || 0,
+                                a = e.strokeForeground,
+                                s = null == e.opacity ? 1 : e.opacity;
+                            (e.stroke || e.fill) && s && (kM(t, e, r, o), YC(t, e), e.fill && tM(t, e, s) && t.fill(), e.stroke && !a && nM(t, e, s) && t.stroke()), t.save(), t.translate(r, o), e.clip && xM(t, e), n && n.translate(-r, -o), oM(e, (e => {
+                                ("group" === e.marktype || null == i || i.includes(e.marktype)) && this.draw(t, e, n, i)
+                            })), n && n.translate(r, o), t.restore(), a && e.stroke && s && (kM(t, e, r, o), YC(t, e), nM(t, e, s) && t.stroke())
+                        }))
+                    },
+                    pick: function(t, e, n, i, r, o) {
+                        if (e.bounds && !e.bounds.contains(r, o) || !e.items) return null;
+                        const a = n * t.pixelRatio,
+                            s = i * t.pixelRatio;
+                        return aM(e, (c => {
+                            let l, u, f;
+                            const d = c.bounds;
+                            if (d && !d.contains(r, o)) return;
+                            u = c.x || 0, f = c.y || 0;
+                            const h = u + (c.width || 0),
+                                p = f + (c.height || 0),
+                                m = c.clip;
+                            if (m && (r < u || r > h || o < f || o > p)) return;
+                            if (t.save(), t.translate(u, f), u = r - u, f = o - f, m && lC(c) && !DM(t, c, a, s)) return t.restore(), null;
+                            const g = c.strokeForeground,
+                                v = !1 !== e.interactive;
+                            return v && g && c.stroke && AM(t, c, a, s) ? (t.restore(), c) : (l = aM(c, (t => function(t, e, n) {
+                                return (!1 !== t.interactive || "group" === t.marktype) && t.bounds && t.bounds.contains(e, n)
+                            }(t, u, f) ? this.pick(t, n, i, u, f) : null)), !l && v && (c.fill || !g && c.stroke) && EM(t, c, a, s) && (l = c), t.restore(), l || null)
+                        }))
+                    },
+                    isect: JC,
+                    content: function(t, e, n) {
+                        t("clip-path", e.clip ? hC(n, e, e) : null)
+                    },
+                    background: function(t, e) {
+                        t("class", "background"), t("aria-hidden", !0), wM(t, e)
+                    },
+                    foreground: function(t, e) {
+                        t("class", "foreground"), t("aria-hidden", !0), e.strokeForeground ? wM(t, e) : t("d", "")
+                    }
+                },
+                CM = {
+                    xmlns: "http://www.w3.org/2000/svg",
+                    "xmlns:xlink": "http://www.w3.org/1999/xlink",
+                    version: "1.1"
+                };
+
+            function MM(t, e) {
+                var n = t.image;
+                return (!n || t.url && t.url !== n.url) && (n = {
+                    complete: !1,
+                    width: 0,
+                    height: 0
+                }, e.loadImage(t.url).then((e => {
+                    t.image = e, t.image.url = t.url
+                }))), n
+            }
+
+            function FM(t, e) {
+                return null != t.width ? t.width : e && e.width ? !1 !== t.aspect && t.height ? t.height * e.width / e.height : e.width : 0
+            }
+
+            function OM(t, e) {
+                return null != t.height ? t.height : e && e.height ? !1 !== t.aspect && t.width ? t.width * e.height / e.width : e.height : 0
+            }
+
+            function TM(t, e) {
+                return "center" === t ? e / 2 : "right" === t ? e : 0
+            }
+
+            function NM(t, e) {
+                return "middle" === t ? e / 2 : "bottom" === t ? e : 0
+            }
+            var RM = {
+                    type: "image",
+                    tag: "image",
+                    nested: !1,
+                    attr: function(t, e, n) {
+                        const i = MM(e, n),
+                            r = FM(e, i),
+                            o = OM(e, i),
+                            a = (e.x || 0) - TM(e.align, r),
+                            s = (e.y || 0) - NM(e.baseline, o);
+                        t("href", !i.src && i.toDataURL ? i.toDataURL() : i.src || "", CM["xmlns:xlink"], "xlink:href"), t("transform", hM(a, s)), t("width", r), t("height", o), t("preserveAspectRatio", !1 === e.aspect ? "none" : "xMidYMid")
+                    },
+                    bound: function(t, e) {
+                        const n = e.image,
+                            i = FM(e, n),
+                            r = OM(e, n),
+                            o = (e.x || 0) - TM(e.align, i),
+                            a = (e.y || 0) - NM(e.baseline, r);
+                        return t.set(o, a, o + i, a + r)
+                    },
+                    draw: function(t, e, n) {
+                        oM(e, (e => {
+                            if (n && !n.intersects(e.bounds)) return;
+                            const i = MM(e, this);
+                            let r = FM(e, i),
+                                o = OM(e, i);
+                            if (0 === r || 0 === o) return;
+                            let a, s, c, l, u = (e.x || 0) - TM(e.align, r),
+                                f = (e.y || 0) - NM(e.baseline, o);
+                            !1 !== e.aspect && (s = i.width / i.height, c = e.width / e.height, s === s && c === c && s !== c && (c < s ? (l = r / s, f += (o - l) / 2, o = l) : (l = o * s, u += (r - l) / 2, r = l))), (i.complete || i.toDataURL) && (YC(t, e), t.globalAlpha = null != (a = e.opacity) ? a : 1, t.imageSmoothingEnabled = !1 !== e.smooth, t.drawImage(i, u, f, r, o))
+                        }))
+                    },
+                    pick: uM(),
+                    isect: m.yb,
+                    get: MM,
+                    xOffset: TM,
+                    yOffset: NM
+                },
+                zM = yM("line", (function(t, e) {
+                    const n = e[0],
+                        i = n.interpolate || "linear";
+                    return oC.curve(xS(i, n.orient, n.tension)).context(t)(e)
+                }), (function(t, e) {
+                    for (var n, i, r = Math.pow(t[0].strokeWidth || 1, 2), o = t.length; --o >= 0;)
+                        if (!1 !== t[o].defined && (n = t[o].x - e[0]) * n + (i = t[o].y - e[1]) * i < r) return t[o];
+                    return null
+                }));
+
+            function PM(t, e) {
+                var n = e.path;
+                if (null == n) return !0;
+                var i = e.x || 0,
+                    r = e.y || 0,
+                    o = e.scaleX || 1,
+                    a = e.scaleY || 1,
+                    s = (e.angle || 0) * SS,
+                    c = e.pathCache;
+                c && c.path === n || ((e.pathCache = c = DS(n)).path = n), s && t.rotate && t.translate ? (t.translate(i, r), t.rotate(s), LS(t, c, 0, 0, o, a), t.rotate(-s), t.translate(-i, -r)) : LS(t, c, i, r, o, a)
+            }
+            var LM = {
+                type: "path",
+                tag: "path",
+                nested: !1,
+                attr: function(t, e) {
+                    var n = e.scaleX || 1,
+                        i = e.scaleY || 1;
+                    1 === n && 1 === i || t("vector-effect", "non-scaling-stroke"), t("transform", function(t) {
+                        return hM(t.x || 0, t.y || 0) + (t.angle ? " " + pM(t.angle) : "") + (t.scaleX || t.scaleY ? " " + function(t, e) {
+                            return "scale(" + t + "," + e + ")"
+                        }(t.scaleX || 1, t.scaleY || 1) : "")
+                    }(e)), t("d", e.path)
+                },
+                bound: function(t, e) {
+                    return PM(BC(t, e.angle), e) ? t.set(0, 0, 0, 0) : xC(t, e, !0)
+                },
+                draw: sM(PM),
+                pick: dM(PM),
+                isect: XC(PM)
+            };
+
+            function BM(t, e) {
+                t.beginPath(), uC(t, e)
+            }
+            var IM = {
+                type: "rect",
+                tag: "path",
+                nested: !1,
+                attr: function(t, e) {
+                    t("d", uC(null, e))
+                },
+                bound: function(t, e) {
+                    var n, i;
+                    return xC(t.set(n = e.x || 0, i = e.y || 0, n + e.width || 0, i + e.height || 0), e)
+                },
+                draw: sM(BM),
+                pick: dM(BM),
+                isect: JC
+            };
+
+            function jM(t, e, n) {
+                var i, r, o, a;
+                return !(!e.stroke || !nM(t, e, n)) && (i = e.x || 0, r = e.y || 0, o = null != e.x2 ? e.x2 : i, a = null != e.y2 ? e.y2 : r, t.beginPath(), t.moveTo(i, r), t.lineTo(o, a), !0)
+            }
+            var UM = {
+                    type: "rule",
+                    tag: "line",
+                    nested: !1,
+                    attr: function(t, e) {
+                        t("transform", mM(e)), t("x2", null != e.x2 ? e.x2 - (e.x || 0) : 0), t("y2", null != e.y2 ? e.y2 - (e.y || 0) : 0)
+                    },
+                    bound: function(t, e) {
+                        var n, i;
+                        return xC(t.set(n = e.x || 0, i = e.y || 0, null != e.x2 ? e.x2 : n, null != e.y2 ? e.y2 : i), e)
+                    },
+                    draw: function(t, e, n) {
+                        oM(e, (e => {
+                            if (!n || n.intersects(e.bounds)) {
+                                var i = null == e.opacity ? 1 : e.opacity;
+                                i && jM(t, e, i) && (YC(t, e), t.stroke())
+                            }
+                        }))
+                    },
+                    pick: uM((function(t, e, n, i) {
+                        return !!t.isPointInStroke && (jM(t, e, 1) && t.isPointInStroke(n, i))
+                    })),
+                    isect: ZC
+                },
+                qM = gM("shape", (function(t, e) {
+                    return (e.mark.shape || e.shape).context(t)(e)
+                })),
+                WM = gM("symbol", (function(t, e) {
+                    return sC.context(t)(e)
+                }), GC);
+            const HM = (0, m.$m)();
+            var XM = {
+                height: VM,
+                measureWidth: $M,
+                estimateWidth: JM,
+                width: JM,
+                canvas: GM
+            };
+
+            function GM(t) {
+                XM.width = t && WC ? $M : JM
+            }
+
+            function JM(t, e) {
+                return ZM(eF(t, e), VM(t))
+            }
+
+            function ZM(t, e) {
+                return ~~(.8 * t.length * e)
+            }
+
+            function $M(t, e) {
+                return VM(t) <= 0 || !(e = eF(t, e)) ? 0 : YM(e, iF(t))
+            }
+
+            function YM(t, e) {
+                const n = "(".concat(e, ") ").concat(t);
+                let i = HM.get(n);
+                return void 0 === i && (WC.font = e, i = WC.measureText(t).width, HM.set(n, i)), i
+            }
+
+            function VM(t) {
+                return null != t.fontSize ? +t.fontSize || 0 : 11
+            }
+
+            function KM(t) {
+                return null != t.lineHeight ? t.lineHeight : VM(t) + 2
+            }
+
+            function QM(t) {
+                return e = t.lineBreak && t.text && !(0, m.kJ)(t.text) ? t.text.split(t.lineBreak) : t.text, (0, m.kJ)(e) ? e.length > 1 ? e : e[0] : e;
+                var e
+            }
+
+            function tF(t) {
+                const e = QM(t);
+                return ((0, m.kJ)(e) ? e.length - 1 : 0) * KM(t)
+            }
+
+            function eF(t, e) {
+                const n = null == e ? "" : (e + "").trim();
+                return t.limit > 0 && n.length ? function(t, e) {
+                    var n = +t.limit,
+                        i = function(t) {
+                            if (XM.width === $M) {
+                                const e = iF(t);
+                                return t => YM(t, e)
+                            }
+                            if (XM.width === JM) {
+                                const e = VM(t);
+                                return t => ZM(t, e)
+                            }
+                            return e => XM.width(t, e)
+                        }(t);
+                    if (i(e) < n) return e;
+                    var r, o = t.ellipsis || "\u2026",
+                        a = "rtl" === t.dir,
+                        s = 0,
+                        c = e.length;
+                    if (n -= i(o), a) {
+                        for (; s < c;) r = s + c >>> 1, i(e.slice(r)) > n ? s = r + 1 : c = r;
+                        return o + e.slice(s)
+                    }
+                    for (; s < c;) r = 1 + (s + c >>> 1), i(e.slice(0, r)) < n ? s = r : c = r - 1;
+                    return e.slice(0, s) + o
+                }(t, n) : n
+            }
+
+            function nF(t, e) {
+                var n = t.font;
+                return (e && n ? String(n).replace(/"/g, "'") : n) || "sans-serif"
+            }
+
+            function iF(t, e) {
+                return (t.fontStyle ? t.fontStyle + " " : "") + (t.fontVariant ? t.fontVariant + " " : "") + (t.fontWeight ? t.fontWeight + " " : "") + VM(t) + "px " + nF(t, e)
+            }
+
+            function rF(t) {
+                var e = t.baseline,
+                    n = VM(t);
+                return Math.round("top" === e ? .79 * n : "middle" === e ? .3 * n : "bottom" === e ? -.21 * n : "line-top" === e ? .29 * n + .5 * KM(t) : "line-bottom" === e ? .29 * n - .5 * KM(t) : 0)
+            }
+            GM(!0);
+            const oF = {
+                    left: "start",
+                    center: "middle",
+                    right: "end"
+                },
+                aF = new pC;
+
+            function sF(t) {
+                var e, n = t.x || 0,
+                    i = t.y || 0,
+                    r = t.radius || 0;
+                return r && (e = (t.theta || 0) - CS, n += r * Math.cos(e), i += r * Math.sin(e)), aF.x1 = n, aF.y1 = i, aF
+            }
+
+            function cF(t, e, n) {
+                var i, r = XM.height(e),
+                    o = e.align,
+                    a = sF(e),
+                    s = a.x1,
+                    c = a.y1,
+                    l = e.dx || 0,
+                    u = (e.dy || 0) + rF(e) - Math.round(.8 * r),
+                    f = QM(e);
+                if ((0, m.kJ)(f) ? (r += KM(e) * (f.length - 1), i = f.reduce(((t, n) => Math.max(t, XM.width(e, n))), 0)) : i = XM.width(e, f), "center" === o ? l -= i / 2 : "right" === o && (l -= i), t.set(l += s, u += c, l + i, u + r), e.angle && !n) t.rotate(e.angle * SS, s, c);
+                else if (2 === n) return t.rotatedPoints(e.angle * SS, s, c);
+                return t
+            }
+            var lF = {
+                    type: "text",
+                    tag: "text",
+                    nested: !1,
+                    attr: function(t, e) {
+                        var n, i = e.dx || 0,
+                            r = (e.dy || 0) + rF(e),
+                            o = sF(e),
+                            a = o.x1,
+                            s = o.y1,
+                            c = e.angle || 0;
+                        t("text-anchor", oF[e.align] || "start"), c ? (n = hM(a, s) + " " + pM(c), (i || r) && (n += " " + hM(i, r))) : n = hM(a + i, s + r), t("transform", n)
+                    },
+                    bound: cF,
+                    draw: function(t, e, n) {
+                        oM(e, (e => {
+                            var i, r, o, a, s, c, l, u = null == e.opacity ? 1 : e.opacity;
+                            if (!(n && !n.intersects(e.bounds) || 0 === u || e.fontSize <= 0 || null == e.text || 0 === e.text.length)) {
+                                if (t.font = iF(e), t.textAlign = e.align || "left", r = (i = sF(e)).x1, o = i.y1, e.angle && (t.save(), t.translate(r, o), t.rotate(e.angle * SS), r = o = 0), r += e.dx || 0, o += (e.dy || 0) + rF(e), c = QM(e), YC(t, e), (0, m.kJ)(c))
+                                    for (s = KM(e), a = 0; a < c.length; ++a) l = eF(e, c[a]), e.fill && tM(t, e, u) && t.fillText(l, r, o), e.stroke && nM(t, e, u) && t.strokeText(l, r, o), o += s;
+                                else l = eF(e, c), e.fill && tM(t, e, u) && t.fillText(l, r, o), e.stroke && nM(t, e, u) && t.strokeText(l, r, o);
+                                e.angle && t.restore()
+                            }
+                        }))
+                    },
+                    pick: uM((function(t, e, n, i, r, o) {
+                        if (e.fontSize <= 0) return !1;
+                        if (!e.angle) return !0;
+                        var a = sF(e),
+                            s = a.x1,
+                            c = a.y1,
+                            l = cF(aF, e, 1),
+                            u = -e.angle * SS,
+                            f = Math.cos(u),
+                            d = Math.sin(u),
+                            h = f * r - d * o + (s - f * s + d * c),
+                            p = d * r + f * o + (c - d * s - f * c);
+                        return l.contains(h, p)
+                    })),
+                    isect: function(t, e) {
+                        const n = cF(aF, t, 2);
+                        return $C(e, n[0], n[1], n[2], n[3]) || $C(e, n[0], n[1], n[4], n[5]) || $C(e, n[4], n[5], n[6], n[7]) || $C(e, n[2], n[3], n[6], n[7])
+                    }
+                },
+                uF = yM("trail", (function(t, e) {
+                    return cC.context(t)(e)
+                }), (function(t, e) {
+                    for (var n, i, r = t.length; --r >= 0;)
+                        if (!1 !== t[r].defined && (n = t[r].x - e[0]) * n + (i = t[r].y - e[1]) * i < (n = t[r].size || 1) * n) return t[r];
+                    return null
+                })),
+                fF = {
+                    arc: vM,
+                    area: bM,
+                    group: SM,
+                    image: RM,
+                    line: zM,
+                    path: LM,
+                    rect: IM,
+                    rule: UM,
+                    shape: qM,
+                    symbol: WM,
+                    text: lF,
+                    trail: uF
+                };
+
+            function dF(t, e, n) {
+                var i = fF[t.mark.marktype],
+                    r = e || i.bound;
+                return i.nested && (t = t.mark), r(t.bounds || (t.bounds = new pC), t, n)
+            }
+            var hF = {
+                mark: null
+            };
+
+            function pF(t, e, n) {
+                var i, r, o, a, s = fF[t.marktype],
+                    c = s.bound,
+                    l = t.items,
+                    u = l && l.length;
+                if (s.nested) return u ? o = l[0] : (hF.mark = t, o = hF), a = dF(o, c, n), e = e && e.union(a) || a;
+                if (e = e || t.bounds && t.bounds.clear() || new pC, u)
+                    for (i = 0, r = l.length; i < r; ++i) e.union(dF(l[i], c, n));
+                return t.bounds = e
+            }
+            const mF = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
+
+            function gF(t, e) {
+                return JSON.stringify(t, mF, e)
+            }
+
+            function vF(t) {
+                return yF("string" === typeof t ? JSON.parse(t) : t)
+            }
+
+            function yF(t) {
+                var e, n, i, r = t.marktype,
+                    o = t.items;
+                if (o)
+                    for (n = 0, i = o.length; n < i; ++n) e = r ? "mark" : "group", o[n][e] = t, o[n].zindex && (o[n][e].zdirty = !0), "group" === (r || e) && yF(o[n]);
+                return r && pF(t), t
+            }
+
+            function bF(t) {
+                arguments.length ? this.root = vF(t) : (this.root = xF({
+                    marktype: "group",
+                    name: "root",
+                    role: "frame"
+                }), this.root.items = [new gC(this.root)])
+            }
+
+            function xF(t, e) {
+                const n = {
+                    bounds: new pC,
+                    clip: !!t.clip,
+                    group: e,
+                    interactive: !1 !== t.interactive,
+                    items: [],
+                    marktype: t.marktype,
+                    name: t.name || void 0,
+                    role: t.role || void 0,
+                    zindex: t.zindex || 0
+                };
+                return null != t.aria && (n.aria = t.aria), t.description && (n.description = t.description), n
+            }
+
+            function _F(t, e, n) {
+                return !t && "undefined" !== typeof document && document.createElement && (t = document), t ? n ? t.createElementNS(n, e) : t.createElement(e) : null
+            }
+
+            function wF(t, e) {
+                e = e.toLowerCase();
+                for (var n = t.childNodes, i = 0, r = n.length; i < r; ++i)
+                    if (n[i].tagName.toLowerCase() === e) return n[i]
+            }
+
+            function kF(t, e, n, i) {
+                var r, o = t.childNodes[e];
+                return o && o.tagName.toLowerCase() === n.toLowerCase() || (r = o || null, o = _F(t.ownerDocument, n, i), t.insertBefore(o, r)), o
+            }
+
+            function EF(t, e) {
+                for (var n = t.childNodes, i = n.length; i > e;) t.removeChild(n[--i]);
+                return t
+            }
+
+            function AF(t) {
+                return "mark-" + t.marktype + (t.role ? " role-" + t.role : "") + (t.name ? " " + t.name : "")
+            }
+
+            function DF(t, e) {
+                const n = e.getBoundingClientRect();
+                return [t.clientX - n.left - (e.clientLeft || 0), t.clientY - n.top - (e.clientTop || 0)]
+            }
+
+            function SF(t, e) {
+                this._active = null, this._handlers = {}, this._loader = t || Yi(), this._tooltip = e || CF
+            }
+
+            function CF(t, e, n, i) {
+                t.element().setAttribute("title", i || "")
+            }
+
+            function MF(t) {
+                this._el = null, this._bgcolor = null, this._loader = new vC(t)
+            }
+            bF.prototype = {
+                toJSON(t) {
+                    return gF(this.root, t || 0)
+                },
+                mark(t, e, n) {
+                    const i = xF(t, e = e || this.root.items[0]);
+                    return e.items[n] = i, i.zindex && (i.group.zdirty = !0), i
+                }
+            }, SF.prototype = {
+                initialize(t, e, n) {
+                    return this._el = t, this._obj = n || null, this.origin(e)
+                },
+                element() {
+                    return this._el
+                },
+                canvas() {
+                    return this._el && this._el.firstChild
+                },
+                origin(t) {
+                    return arguments.length ? (this._origin = t || [0, 0], this) : this._origin.slice()
+                },
+                scene(t) {
+                    return arguments.length ? (this._scene = t, this) : this._scene
+                },
+                on() {},
+                off() {},
+                _handlerIndex(t, e, n) {
+                    for (let i = t ? t.length : 0; --i >= 0;)
+                        if (t[i].type === e && (!n || t[i].handler === n)) return i;
+                    return -1
+                },
+                handlers(t) {
+                    const e = this._handlers,
+                        n = [];
+                    if (t) n.push(...e[this.eventName(t)]);
+                    else
+                        for (const i in e) n.push(...e[i]);
+                    return n
+                },
+                eventName(t) {
+                    const e = t.indexOf(".");
+                    return e < 0 ? t : t.slice(0, e)
+                },
+                handleHref(t, e, n) {
+                    this._loader.sanitize(n, {
+                        context: "href"
+                    }).then((e => {
+                        const n = new MouseEvent(t.type, t),
+                            i = _F(null, "a");
+                        for (const t in e) i.setAttribute(t, e[t]);
+                        i.dispatchEvent(n)
+                    })).catch((() => {}))
+                },
+                handleTooltip(t, e, n) {
+                    if (e && null != e.tooltip) {
+                        e = function(t, e, n, i) {
+                            var r, o, a = t && t.mark;
+                            if (a && (r = fF[a.marktype]).tip) {
+                                for ((o = DF(e, n))[0] -= i[0], o[1] -= i[1]; t = t.mark.group;) o[0] -= t.x || 0, o[1] -= t.y || 0;
+                                t = r.tip(a.items, o)
+                            }
+                            return t
+                        }(e, t, this.canvas(), this._origin);
+                        const i = n && e && e.tooltip || null;
+                        this._tooltip.call(this._obj, this, t, e, i)
+                    }
+                },
+                getItemBoundingClientRect(t) {
+                    const e = this.canvas();
+                    if (!e) return;
+                    const n = e.getBoundingClientRect(),
+                        i = this._origin,
+                        r = t.bounds,
+                        o = r.width(),
+                        a = r.height();
+                    let s = r.x1 + i[0] + n.left,
+                        c = r.y1 + i[1] + n.top;
+                    for (; t.mark && (t = t.mark.group);) s += t.x || 0, c += t.y || 0;
+                    return {
+                        x: s,
+                        y: c,
+                        width: o,
+                        height: a,
+                        left: s,
+                        top: c,
+                        right: s + o,
+                        bottom: c + a
+                    }
+                }
+            }, MF.prototype = {
+                initialize(t, e, n, i, r) {
+                    return this._el = t, this.resize(e, n, i, r)
+                },
+                element() {
+                    return this._el
+                },
+                canvas() {
+                    return this._el && this._el.firstChild
+                },
+                background(t) {
+                    return 0 === arguments.length ? this._bgcolor : (this._bgcolor = t, this)
+                },
+                resize(t, e, n, i) {
+                    return this._width = t, this._height = e, this._origin = n || [0, 0], this._scale = i || 1, this
+                },
+                dirty() {},
+                render(t, e) {
+                    const n = this;
+                    return n._call = function() {
+                        n._render(t, e)
+                    }, n._call(), n._call = null, n
+                },
+                _render() {},
+                renderAsync(t, e) {
+                    const n = this.render(t, e);
+                    return this._ready ? this._ready.then((() => n)) : Promise.resolve(n)
+                },
+                _load(t, e) {
+                    var n = this,
+                        i = n._loader[t](e);
+                    if (!n._ready) {
+                        const t = n._call;
+                        n._ready = n._loader.ready().then((e => {
+                            e && t(), n._ready = null
+                        }))
+                    }
+                    return i
+                },
+                sanitizeURL(t) {
+                    return this._load("sanitizeURL", t)
+                },
+                loadImage(t) {
+                    return this._load("loadImage", t)
+                }
+            };
+            const FF = "dragenter",
+                OF = "dragleave",
+                TF = "dragover",
+                NF = "pointerdown",
+                RF = "pointermove",
+                zF = "pointerout",
+                PF = "pointerover",
+                LF = "mousedown",
+                BF = "mousemove",
+                IF = "mouseout",
+                jF = "mouseover",
+                UF = "click",
+                qF = "mousewheel",
+                WF = "touchstart",
+                HF = "touchmove",
+                XF = "touchend",
+                GF = ["keydown", "keypress", "keyup", FF, OF, TF, NF, "pointerup", RF, zF, PF, LF, "mouseup", BF, IF, jF, UF, "dblclick", "wheel", qF, WF, HF, XF],
+                JF = RF,
+                ZF = zF,
+                $F = UF;
+
+            function YF(t, e) {
+                SF.call(this, t, e), this._down = null, this._touch = null, this._first = !0, this._events = {}
+            }
+
+            function VF(t, e) {
+                (t => t === WF || t === HF || t === XF ? [WF, HF, XF] : [t])(e).forEach((e => function(t, e) {
+                    const n = t.canvas();
+                    n && !t._events[e] && (t._events[e] = 1, n.addEventListener(e, t[e] ? n => t[e](n) : n => t.fire(e, n)))
+                }(t, e)))
+            }
+
+            function KF(t, e, n) {
+                e.forEach((e => t.fire(e, n)))
+            }
+
+            function QF(t, e, n) {
+                return function(i) {
+                    const r = this._active,
+                        o = this.pickEvent(i);
+                    o === r || (r && r.exit || KF(this, n, i), this._active = o, KF(this, e, i)), KF(this, t, i)
+                }
+            }
+
+            function tO(t) {
+                return function(e) {
+                    KF(this, t, e), this._active = null
+                }
+            }
+
+            function eO(t, e, n, i, r, o) {
+                const a = "undefined" !== typeof HTMLElement && t instanceof HTMLElement && null != t.parentNode,
+                    s = t.getContext("2d"),
+                    c = a ? "undefined" !== typeof window && window.devicePixelRatio || 1 : r;
+                t.width = e * c, t.height = n * c;
+                for (const l in o) s[l] = o[l];
+                return a && 1 !== c && (t.style.width = e + "px", t.style.height = n + "px"), s.pixelRatio = c, s.setTransform(c, 0, 0, c, c * i[0], c * i[1]), t
+            }
+
+            function nO(t) {
+                MF.call(this, t), this._options = {}, this._redraw = !1, this._dirty = new pC, this._tempb = new pC
+            }(0, m.XW)(YF, SF, {
+                initialize(t, e, n) {
+                    return this._canvas = t && wF(t, "canvas"), [UF, LF, NF, RF, zF, OF].forEach((t => VF(this, t))), SF.prototype.initialize.call(this, t, e, n)
+                },
+                canvas() {
+                    return this._canvas
+                },
+                context() {
+                    return this._canvas.getContext("2d")
+                },
+                events: GF,
+                DOMMouseScroll(t) {
+                    this.fire(qF, t)
+                },
+                pointermove: QF([RF, BF], [PF, jF], [zF, IF]),
+                dragover: QF([TF], [FF], [OF]),
+                pointerout: tO([zF, IF]),
+                dragleave: tO([OF]),
+                pointerdown(t) {
+                    this._down = this._active, this.fire(NF, t)
+                },
+                mousedown(t) {
+                    this._down = this._active, this.fire(LF, t)
+                },
+                click(t) {
+                    this._down === this._active && (this.fire(UF, t), this._down = null)
+                },
+                touchstart(t) {
+                    this._touch = this.pickEvent(t.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(WF, t, !0)
+                },
+                touchmove(t) {
+                    this.fire(HF, t, !0)
+                },
+                touchend(t) {
+                    this.fire(XF, t, !0), this._touch = null
+                },
+                fire(t, e, n) {
+                    const i = n ? this._touch : this._active,
+                        r = this._handlers[t];
+                    if (e.vegaType = t, t === $F && i && i.href ? this.handleHref(e, i, i.href) : t !== JF && t !== ZF || this.handleTooltip(e, i, t !== ZF), r)
+                        for (let o = 0, a = r.length; o < a; ++o) r[o].handler.call(this._obj, e, i)
+                },
+                on(t, e) {
+                    const n = this.eventName(t),
+                        i = this._handlers;
+                    return this._handlerIndex(i[n], t, e) < 0 && (VF(this, t), (i[n] || (i[n] = [])).push({
+                        type: t,
+                        handler: e
+                    })), this
+                },
+                off(t, e) {
+                    const n = this.eventName(t),
+                        i = this._handlers[n],
+                        r = this._handlerIndex(i, t, e);
+                    return r >= 0 && i.splice(r, 1), this
+                },
+                pickEvent(t) {
+                    const e = DF(t, this._canvas),
+                        n = this._origin;
+                    return this.pick(this._scene, e[0], e[1], e[0] - n[0], e[1] - n[1])
+                },
+                pick(t, e, n, i, r) {
+                    const o = this.context();
+                    return fF[t.marktype].pick.call(this, o, t, e, n, i, r)
+                }
+            });
+            const iO = MF.prototype;
+
+            function rO(t, e) {
+                SF.call(this, t, e);
+                const n = this;
+                n._hrefHandler = oO(n, ((t, e) => {
+                    e && e.href && n.handleHref(t, e, e.href)
+                })), n._tooltipHandler = oO(n, ((t, e) => {
+                    n.handleTooltip(t, e, t.type !== ZF)
+                }))
+            }(0, m.XW)(nO, MF, {
+                initialize(t, e, n, i, r, o) {
+                    return this._options = o || {}, this._canvas = this._options.externalContext ? null : il(1, 1, this._options.type), t && this._canvas && (EF(t, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), iO.initialize.call(this, t, e, n, i, r)
+                },
+                resize(t, e, n, i) {
+                    if (iO.resize.call(this, t, e, n, i), this._canvas) eO(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
+                    else {
+                        const t = this._options.externalContext;
+                        t || (0, m.vU)("CanvasRenderer is missing a valid canvas or context"), t.scale(this._scale, this._scale), t.translate(this._origin[0], this._origin[1])
+                    }
+                    return this._redraw = !0, this
+                },
+                canvas() {
+                    return this._canvas
+                },
+                context() {
+                    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null)
+                },
+                dirty(t) {
+                    const e = this._tempb.clear().union(t.bounds);
+                    let n = t.mark.group;
+                    for (; n;) e.translate(n.x || 0, n.y || 0), n = n.mark.group;
+                    this._dirty.union(e)
+                },
+                _render(t, e) {
+                    const n = this.context(),
+                        i = this._origin,
+                        r = this._width,
+                        o = this._height,
+                        a = this._dirty,
+                        s = ((t, e, n) => (new pC).set(0, 0, e, n).translate(-t[0], -t[1]))(i, r, o);
+                    n.save();
+                    const c = this._redraw || a.empty() ? (this._redraw = !1, s.expand(1)) : function(t, e, n) {
+                        return e.expand(1).round(), t.pixelRatio % 1 && e.scale(t.pixelRatio).round().scale(1 / t.pixelRatio), e.translate(-n[0] % 1, -n[1] % 1), t.beginPath(), t.rect(e.x1, e.y1, e.width(), e.height()), t.clip(), e
+                    }(n, s.intersect(a), i);
+                    return this.clear(-i[0], -i[1], r, o), this.draw(n, t, c, e), n.restore(), a.clear(), this
+                },
+                draw(t, e, n, i) {
+                    if ("group" !== e.marktype && null != i && !i.includes(e.marktype)) return;
+                    const r = fF[e.marktype];
+                    e.clip && function(t, e) {
+                        var n = e.clip;
+                        t.save(), (0, m.mf)(n) ? (t.beginPath(), n(t), t.clip()) : xM(t, e.group)
+                    }(t, e), r.draw.call(this, t, e, n, i), e.clip && t.restore()
+                },
+                clear(t, e, n, i) {
+                    const r = this._options,
+                        o = this.context();
+                    "pdf" === r.type || r.externalContext || o.clearRect(t, e, n, i), null != this._bgcolor && (o.fillStyle = this._bgcolor, o.fillRect(t, e, n, i))
+                }
+            });
+            const oO = (t, e) => n => {
+                let i = n.target.__data__;
+                i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, e.call(t._obj, n, i)
+            };
+            (0, m.XW)(rO, SF, {
+                initialize(t, e, n) {
+                    let i = this._svg;
+                    return i && (i.removeEventListener($F, this._hrefHandler), i.removeEventListener(JF, this._tooltipHandler), i.removeEventListener(ZF, this._tooltipHandler)), this._svg = i = t && wF(t, "svg"), i && (i.addEventListener($F, this._hrefHandler), i.addEventListener(JF, this._tooltipHandler), i.addEventListener(ZF, this._tooltipHandler)), SF.prototype.initialize.call(this, t, e, n)
+                },
+                canvas() {
+                    return this._svg
+                },
+                on(t, e) {
+                    const n = this.eventName(t),
+                        i = this._handlers;
+                    if (this._handlerIndex(i[n], t, e) < 0) {
+                        const r = {
+                            type: t,
+                            handler: e,
+                            listener: oO(this, e)
+                        };
+                        (i[n] || (i[n] = [])).push(r), this._svg && this._svg.addEventListener(n, r.listener)
+                    }
+                    return this
+                },
+                off(t, e) {
+                    const n = this.eventName(t),
+                        i = this._handlers[n],
+                        r = this._handlerIndex(i, t, e);
+                    return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this
+                }
+            });
+            const aO = "aria-hidden",
+                sO = "aria-label",
+                cO = "role",
+                lO = "aria-roledescription",
+                uO = "graphics-object",
+                fO = "graphics-symbol",
+                dO = (t, e, n) => ({
+                    [cO]: t,
+                    [lO]: e,
+                    [sO]: n || void 0
+                }),
+                hO = (0, m.Rg)(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
+                pO = {
+                    axis: {
+                        desc: "axis",
+                        caption: function(t) {
+                            const e = t.datum,
+                                n = t.orient,
+                                i = e.title ? bO(t) : null,
+                                r = t.context,
+                                o = r.scales[e.scale].value,
+                                a = r.dataflow.locale(),
+                                s = o.type;
+                            return "".concat("left" === n || "right" === n ? "Y" : "X", "-axis") + (i ? " titled '".concat(i, "'") : "") + " for a ".concat(UD(s) ? "discrete" : s, " scale") + " with ".concat(dS(a, o, t))
+                        }
+                    },
+                    legend: {
+                        desc: "legend",
+                        caption: function(t) {
+                            const e = t.datum,
+                                n = e.title ? bO(t) : null,
+                                i = "".concat(e.type || "", " legend").trim(),
+                                r = e.scales,
+                                o = Object.keys(r),
+                                a = t.context,
+                                s = a.scales[r[o[0]]].value,
+                                c = a.dataflow.locale();
+                            return function(t) {
+                                return t.length ? t[0].toUpperCase() + t.slice(1) : t
+                            }(i) + (n ? " titled '".concat(n, "'") : "") + " for ".concat(function(t) {
+                                return t = t.map((t => t + ("fill" === t || "stroke" === t ? " color" : ""))), t.length < 2 ? t[0] : t.slice(0, -1).join(", ") + " and " + (0, m.fj)(t)
+                            }(o)) + " with ".concat(dS(c, s, t))
+                        }
+                    },
+                    "title-text": {
+                        desc: "title",
+                        caption: t => "Title text '".concat(yO(t), "'")
+                    },
+                    "title-subtitle": {
+                        desc: "subtitle",
+                        caption: t => "Subtitle text '".concat(yO(t), "'")
+                    }
+                },
+                mO = {
+                    ariaRole: cO,
+                    ariaRoleDescription: lO,
+                    description: sO
+                };
+
+            function gO(t, e) {
+                const n = !1 === e.aria;
+                if (t(aO, n || void 0), n || null == e.description)
+                    for (const i in mO) t(mO[i], void 0);
+                else {
+                    const n = e.mark.marktype;
+                    t(sO, e.description), t(cO, e.ariaRole || ("group" === n ? uO : fO)), t(lO, e.ariaRoleDescription || "".concat(n, " mark"))
+                }
+            }
+
+            function vO(t) {
+                return !1 === t.aria ? {
+                    [aO]: !0
+                } : hO[t.role] ? null : pO[t.role] ? function(t, e) {
+                    try {
+                        const n = t.items[0],
+                            i = e.caption || (() => "");
+                        return dO(e.role || fO, e.desc, n.description || i(n))
+                    } catch (n) {
+                        return null
+                    }
+                }(t, pO[t.role]) : function(t) {
+                    const e = t.marktype,
+                        n = "group" === e || "text" === e || t.items.some((t => null != t.description && !1 !== t.aria));
+                    return dO(n ? uO : fO, "".concat(e, " mark container"), t.description)
+                }(t)
+            }
+
+            function yO(t) {
+                return (0, m.IX)(t.text).join(" ")
+            }
+
+            function bO(t) {
+                try {
+                    return (0, m.IX)((0, m.fj)(t.items).items[0].text).join(" ")
+                } catch (e) {
+                    return null
+                }
+            }
+            const xO = t => (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
+                _O = t => xO(t).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
+
+            function wO() {
+                let t = "",
+                    e = "",
+                    n = "";
+                const i = [],
+                    r = () => e = n = "",
+                    o = (t, n) => (null != n && (e += " ".concat(t, '="').concat(_O(n), '"')), a),
+                    a = {
+                        open(s) {
+                            (o => {
+                                e && (t += "".concat(e, ">").concat(n), r()), i.push(o)
+                            })(s), e = "<" + s;
+                            for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), u = 1; u < c; u++) l[u - 1] = arguments[u];
+                            for (const t of l)
+                                for (const e in t) o(e, t[e]);
+                            return a
+                        },
+                        close() {
+                            const o = i.pop();
+                            return t += e ? e + (n ? ">".concat(n, "</").concat(o, ">") : "/>") : "</".concat(o, ">"), r(), a
+                        },
+                        attr: o,
+                        text: t => (n += xO(t), a),
+                        toString: () => t
+                    };
+                return a
+            }
+            const kO = t => EO(wO(), t) + "";
+
+            function EO(t, e) {
+                if (t.open(e.tagName), e.hasAttributes()) {
+                    const n = e.attributes,
+                        i = n.length;
+                    for (let e = 0; e < i; ++e) t.attr(n[e].name, n[e].value)
+                }
+                if (e.hasChildNodes()) {
+                    const n = e.childNodes;
+                    for (const e of n) 3 === e.nodeType ? t.text(e.nodeValue) : EO(t, e)
+                }
+                return t.close()
+            }
+            const AO = {
+                    fill: "fill",
+                    fillOpacity: "fill-opacity",
+                    stroke: "stroke",
+                    strokeOpacity: "stroke-opacity",
+                    strokeWidth: "stroke-width",
+                    strokeCap: "stroke-linecap",
+                    strokeJoin: "stroke-linejoin",
+                    strokeDash: "stroke-dasharray",
+                    strokeDashOffset: "stroke-dashoffset",
+                    strokeMiterLimit: "stroke-miterlimit",
+                    opacity: "opacity"
+                },
+                DO = {
+                    blend: "mix-blend-mode"
+                },
+                SO = {
+                    fill: "none",
+                    "stroke-miterlimit": 10
+                },
+                CO = "http://www.w3.org/2000/xmlns/",
+                MO = CM.xmlns;
+
+            function FO(t) {
+                MF.call(this, t), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
+            }
+            const OO = MF.prototype;
+
+            function TO(t, e) {
+                for (; t && t.dirty !== e; t = t.mark.group) {
+                    if (t.dirty = e, !t.mark || t.mark.dirty === e) return;
+                    t.mark.dirty = e
+                }
+            }
+
+            function NO(t, e, n) {
+                let i, r, o;
+                if ("radial" === e.gradient) {
+                    let i = kF(t, n++, "pattern", MO);
+                    UO(i, {
+                        id: pS + e.id,
+                        viewBox: "0,0,1,1",
+                        width: "100%",
+                        height: "100%",
+                        preserveAspectRatio: "xMidYMid slice"
+                    }), i = kF(i, 0, "rect", MO), UO(i, {
+                        width: 1,
+                        height: 1,
+                        fill: "url(".concat(WO(), "#").concat(e.id, ")")
+                    }), UO(t = kF(t, n++, "radialGradient", MO), {
+                        id: e.id,
+                        fx: e.x1,
+                        fy: e.y1,
+                        fr: e.r1,
+                        cx: e.x2,
+                        cy: e.y2,
+                        r: e.r2
+                    })
+                } else UO(t = kF(t, n++, "linearGradient", MO), {
+                    id: e.id,
+                    x1: e.x1,
+                    x2: e.x2,
+                    y1: e.y1,
+                    y2: e.y2
+                });
+                for (i = 0, r = e.stops.length; i < r; ++i) o = kF(t, i, "stop", MO), o.setAttribute("offset", e.stops[i].offset), o.setAttribute("stop-color", e.stops[i].color);
+                return EF(t, i), n
+            }
+
+            function RO(t, e, n) {
+                let i;
+                return (t = kF(t, n, "clipPath", MO)).setAttribute("id", e.id), e.path ? (i = kF(t, 0, "path", MO), i.setAttribute("d", e.path)) : (i = kF(t, 0, "rect", MO), UO(i, {
+                    x: 0,
+                    y: 0,
+                    width: e.width,
+                    height: e.height
+                })), EF(t, 1), n + 1
+            }
+
+            function zO(t, e, n, i, r) {
+                let o, a = t._svg;
+                if (!a && (o = e.ownerDocument, a = _F(o, i, MO), t._svg = a, t.mark && (a.__data__ = t, a.__values__ = {
+                        fill: "default"
+                    }, "g" === i))) {
+                    const e = _F(o, "path", MO);
+                    a.appendChild(e), e.__data__ = t;
+                    const n = _F(o, "g", MO);
+                    a.appendChild(n), n.__data__ = t;
+                    const i = _F(o, "path", MO);
+                    a.appendChild(i), i.__data__ = t, i.__values__ = {
+                        fill: "default"
+                    }
+                }
+                return (a.ownerSVGElement !== r || function(t, e) {
+                    return t.parentNode && t.parentNode.childNodes.length > 1 && t.previousSibling != e
+                }(a, n)) && e.insertBefore(a, n ? n.nextSibling : e.firstChild), a
+            }(0, m.XW)(FO, MF, {
+                initialize(t, e, n, i, r) {
+                    return this._defs = {}, this._clearDefs(), t && (this._svg = kF(t, 0, "svg", MO), this._svg.setAttributeNS(CO, "xmlns", MO), this._svg.setAttributeNS(CO, "xmlns:xlink", CM["xmlns:xlink"]), this._svg.setAttribute("version", CM.version), this._svg.setAttribute("class", "marks"), EF(t, 1), this._root = kF(this._svg, 0, "g", MO), UO(this._root, SO), EF(this._svg, 1)), this.background(this._bgcolor), OO.initialize.call(this, t, e, n, i, r)
+                },
+                background(t) {
+                    return arguments.length && this._svg && this._svg.style.setProperty("background-color", t), OO.background.apply(this, arguments)
+                },
+                resize(t, e, n, i) {
+                    return OO.resize.call(this, t, e, n, i), this._svg && (UO(this._svg, {
+                        width: this._width * this._scale,
+                        height: this._height * this._scale,
+                        viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
+                    }), this._root.setAttribute("transform", "translate(".concat(this._origin, ")"))), this._dirty = [], this
+                },
+                canvas() {
+                    return this._svg
+                },
+                svg() {
+                    const t = this._svg,
+                        e = this._bgcolor;
+                    if (!t) return null;
+                    let n;
+                    e && (t.removeAttribute("style"), n = kF(t, 0, "rect", MO), UO(n, {
+                        width: this._width,
+                        height: this._height,
+                        fill: e
+                    }));
+                    const i = kO(t);
+                    return e && (t.removeChild(n), this._svg.style.setProperty("background-color", e)), i
+                },
+                _render(t, e) {
+                    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t, void 0, e), EF(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
+                },
+                dirty(t) {
+                    t.dirty !== this._dirtyID && (t.dirty = this._dirtyID, this._dirty.push(t))
+                },
+                isDirty(t) {
+                    return this._dirtyAll || !t._svg || !t._svg.ownerSVGElement || t.dirty === this._dirtyID
+                },
+                _dirtyCheck() {
+                    this._dirtyAll = !0;
+                    const t = this._dirty;
+                    if (!t.length || !this._dirtyID) return !0;
+                    const e = ++this._dirtyID;
+                    let n, i, r, o, a, s, c;
+                    for (a = 0, s = t.length; a < s; ++a) n = t[a], i = n.mark, i.marktype !== r && (r = i.marktype, o = fF[r]), i.zdirty && i.dirty !== e && (this._dirtyAll = !1, TO(n, e), i.items.forEach((t => {
+                        t.dirty = e
+                    }))), i.zdirty || (n.exit ? (o.nested && i.items.length ? (c = i.items[0], c._svg && this._update(o, c._svg, c)) : n._svg && (c = n._svg.parentNode, c && c.removeChild(n._svg)), n._svg = null) : (n = o.nested ? i.items[0] : n, n._update !== e && (n._svg && n._svg.ownerSVGElement ? this._update(o, n._svg, n) : (this._dirtyAll = !1, TO(n, e)), n._update = e)));
+                    return !this._dirtyAll
+                },
+                mark(t, e, n, i) {
+                    if (!this.isDirty(e)) return e._svg;
+                    const r = this._svg,
+                        o = e.marktype,
+                        a = fF[o],
+                        s = !1 === e.interactive ? "none" : null,
+                        c = "g" === a.tag,
+                        l = zO(e, t, n, "g", r);
+                    if ("group" !== o && null != i && !i.includes(o)) return EF(l, 0), e._svg;
+                    l.setAttribute("class", AF(e));
+                    const u = vO(e);
+                    for (const p in u) qO(l, p, u[p]);
+                    c || qO(l, "pointer-events", s), qO(l, "clip-path", e.clip ? hC(this, e, e.group) : null);
+                    let f = null,
+                        d = 0;
+                    const h = t => {
+                        const e = this.isDirty(t),
+                            n = zO(t, l, f, a.tag, r);
+                        e && (this._update(a, n, t), c && function(t, e, n, i) {
+                            e = e.lastChild.previousSibling;
+                            let r, o = 0;
+                            oM(n, (n => {
+                                r = t.mark(e, n, r, i), ++o
+                            })), EF(e, 1 + o)
+                        }(this, n, t, i)), f = n, ++d
+                    };
+                    return a.nested ? e.items.length && h(e.items[0]) : oM(e, h), EF(l, d), l
+                },
+                _update(t, e, n) {
+                    PO = e, LO = e.__values__, gO(IO, n), t.attr(IO, n, this);
+                    const i = BO[t.type];
+                    i && i.call(this, t, e, n), PO && this.style(PO, n)
+                },
+                style(t, e) {
+                    if (null != e) {
+                        for (const n in AO) {
+                            let i = "font" === n ? nF(e) : e[n];
+                            if (i === LO[n]) continue;
+                            const r = AO[n];
+                            null == i ? t.removeAttribute(r) : (mS(i) && (i = gS(i, this._defs.gradient, WO())), t.setAttribute(r, i + "")), LO[n] = i
+                        }
+                        for (const n in DO) jO(t, DO[n], e[n])
+                    }
+                },
+                defs() {
+                    const t = this._svg,
+                        e = this._defs;
+                    let n = e.el,
+                        i = 0;
+                    for (const r in e.gradient) n || (e.el = n = kF(t, 1, "defs", MO)), i = NO(n, e.gradient[r], i);
+                    for (const r in e.clipping) n || (e.el = n = kF(t, 1, "defs", MO)), i = RO(n, e.clipping[r], i);
+                    n && (0 === i ? (t.removeChild(n), e.el = null) : EF(n, i))
+                },
+                _clearDefs() {
+                    const t = this._defs;
+                    t.gradient = {}, t.clipping = {}
+                }
+            });
+            let PO = null,
+                LO = null;
+            const BO = {
+                group(t, e, n) {
+                    const i = PO = e.childNodes[2];
+                    LO = i.__values__, t.foreground(IO, n, this), LO = e.__values__, PO = e.childNodes[1], t.content(IO, n, this);
+                    const r = PO = e.childNodes[0];
+                    t.background(IO, n, this);
+                    const o = !1 === n.mark.interactive ? "none" : null;
+                    if (o !== LO.events && (qO(i, "pointer-events", o), qO(r, "pointer-events", o), LO.events = o), n.strokeForeground && n.stroke) {
+                        const t = n.fill;
+                        qO(i, "display", null), this.style(r, n), qO(r, "stroke", null), t && (n.fill = null), LO = i.__values__, this.style(i, n), t && (n.fill = t), PO = null
+                    } else qO(i, "display", "none")
+                },
+                image(t, e, n) {
+                    !1 === n.smooth ? (jO(e, "image-rendering", "optimizeSpeed"), jO(e, "image-rendering", "pixelated")) : jO(e, "image-rendering", null)
+                },
+                text(t, e, n) {
+                    const i = QM(n);
+                    let r, o, a, s;
+                    (0, m.kJ)(i) ? (o = i.map((t => eF(n, t))), r = o.join("\n"), r !== LO.text && (EF(e, 0), a = e.ownerDocument, s = KM(n), o.forEach(((t, i) => {
+                        const r = _F(a, "tspan", MO);
+                        r.__data__ = n, r.textContent = t, i && (r.setAttribute("x", 0), r.setAttribute("dy", s)), e.appendChild(r)
+                    })), LO.text = r)) : (o = eF(n, i), o !== LO.text && (e.textContent = o, LO.text = o)), qO(e, "font-family", nF(n)), qO(e, "font-size", VM(n) + "px"), qO(e, "font-style", n.fontStyle), qO(e, "font-variant", n.fontVariant), qO(e, "font-weight", n.fontWeight)
+                }
+            };
+
+            function IO(t, e, n) {
+                e !== LO[t] && (n ? function(t, e, n, i) {
+                    null != n ? t.setAttributeNS(i, e, n) : t.removeAttributeNS(i, e)
+                }(PO, t, e, n) : qO(PO, t, e), LO[t] = e)
+            }
+
+            function jO(t, e, n) {
+                n !== LO[e] && (null == n ? t.style.removeProperty(e) : t.style.setProperty(e, n + ""), LO[e] = n)
+            }
+
+            function UO(t, e) {
+                for (const n in e) qO(t, n, e[n])
+            }
+
+            function qO(t, e, n) {
+                null != n ? t.setAttribute(e, n) : t.removeAttribute(e)
+            }
+
+            function WO() {
+                let t;
+                return "undefined" === typeof window ? "" : (t = window.location).hash ? t.href.slice(0, -t.hash.length) : t.href
+            }
+
+            function HO(t) {
+                MF.call(this, t), this._text = null, this._defs = {
+                    gradient: {},
+                    clipping: {}
+                }
+            }(0, m.XW)(HO, MF, {
+                svg() {
+                    return this._text
+                },
+                _render(t) {
+                    const e = wO();
+                    e.open("svg", (0, m.l7)({}, CM, {
+                        class: "marks",
+                        width: this._width * this._scale,
+                        height: this._height * this._scale,
+                        viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
+                    }));
+                    const n = this._bgcolor;
+                    return n && "transparent" !== n && "none" !== n && e.open("rect", {
+                        width: this._width,
+                        height: this._height,
+                        fill: n
+                    }).close(), e.open("g", SO, {
+                        transform: "translate(" + this._origin + ")"
+                    }), this.mark(e, t), e.close(), this.defs(e), this._text = e.close() + "", this
+                },
+                mark(t, e) {
+                    const n = fF[e.marktype],
+                        i = n.tag,
+                        r = [gO, n.attr];
+                    t.open("g", {
+                        class: AF(e),
+                        "clip-path": e.clip ? hC(this, e, e.group) : null
+                    }, vO(e), {
+                        "pointer-events": "g" !== i && !1 === e.interactive ? "none" : null
+                    });
+                    const o = o => {
+                        const a = this.href(o);
+                        if (a && t.open("a", a), t.open(i, this.attr(e, o, r, "g" !== i ? i : null)), "text" === i) {
+                            const e = QM(o);
+                            if ((0, m.kJ)(e)) {
+                                const n = {
+                                    x: 0,
+                                    dy: KM(o)
+                                };
+                                for (let i = 0; i < e.length; ++i) t.open("tspan", i ? n : null).text(eF(o, e[i])).close()
+                            } else t.text(eF(o, e))
+                        } else if ("g" === i) {
+                            const i = o.strokeForeground,
+                                r = o.fill,
+                                a = o.stroke;
+                            i && a && (o.stroke = null), t.open("path", this.attr(e, o, n.background, "bgrect")).close(), t.open("g", this.attr(e, o, n.content)), oM(o, (e => this.mark(t, e))), t.close(), i && a ? (r && (o.fill = null), o.stroke = a, t.open("path", this.attr(e, o, n.foreground, "bgrect")).close(), r && (o.fill = r)) : t.open("path", this.attr(e, o, n.foreground, "bgfore")).close()
+                        }
+                        t.close(), a && t.close()
+                    };
+                    return n.nested ? e.items && e.items.length && o(e.items[0]) : oM(e, o), t.close()
+                },
+                href(t) {
+                    const e = t.href;
+                    let n;
+                    if (e) {
+                        if (n = this._hrefs && this._hrefs[e]) return n;
+                        this.sanitizeURL(e).then((t => {
+                            t["xlink:href"] = t.href, t.href = null, (this._hrefs || (this._hrefs = {}))[e] = t
+                        }))
+                    }
+                    return null
+                },
+                attr(t, e, n, i) {
+                    const r = {},
+                        o = (t, e, n, i) => {
+                            r[i || t] = e
+                        };
+                    return Array.isArray(n) ? n.forEach((t => t(o, e, this))) : n(o, e, this), i && function(t, e, n, i, r) {
+                        let o;
+                        if (null == e) return t;
+                        "bgrect" === i && !1 === n.interactive && (t["pointer-events"] = "none");
+                        if ("bgfore" === i && (!1 === n.interactive && (t["pointer-events"] = "none"), t.display = "none", null !== e.fill)) return t;
+                        "image" === i && !1 === e.smooth && (o = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]);
+                        "text" === i && (t["font-family"] = nF(e), t["font-size"] = VM(e) + "px", t["font-style"] = e.fontStyle, t["font-variant"] = e.fontVariant, t["font-weight"] = e.fontWeight);
+                        for (const a in AO) {
+                            let n = e[a];
+                            const i = AO[a];
+                            ("transparent" !== n || "fill" !== i && "stroke" !== i) && null != n && (mS(n) && (n = gS(n, r.gradient, "")), t[i] = n)
+                        }
+                        for (const a in DO) {
+                            const t = e[a];
+                            null != t && (o = o || [], o.push("".concat(DO[a], ": ").concat(t, ";")))
+                        }
+                        o && (t.style = o.join(" "))
+                    }(r, e, t, i, this._defs), r
+                },
+                defs(t) {
+                    const e = this._defs.gradient,
+                        n = this._defs.clipping;
+                    if (0 !== Object.keys(e).length + Object.keys(n).length) {
+                        t.open("defs");
+                        for (const n in e) {
+                            const i = e[n],
+                                r = i.stops;
+                            "radial" === i.gradient ? (t.open("pattern", {
+                                id: pS + n,
+                                viewBox: "0,0,1,1",
+                                width: "100%",
+                                height: "100%",
+                                preserveAspectRatio: "xMidYMid slice"
+                            }), t.open("rect", {
+                                width: "1",
+                                height: "1",
+                                fill: "url(#" + n + ")"
+                            }).close(), t.close(), t.open("radialGradient", {
+                                id: n,
+                                fx: i.x1,
+                                fy: i.y1,
+                                fr: i.r1,
+                                cx: i.x2,
+                                cy: i.y2,
+                                r: i.r2
+                            })) : t.open("linearGradient", {
+                                id: n,
+                                x1: i.x1,
+                                x2: i.x2,
+                                y1: i.y1,
+                                y2: i.y2
+                            });
+                            for (let e = 0; e < r.length; ++e) t.open("stop", {
+                                offset: r[e].offset,
+                                "stop-color": r[e].color
+                            }).close();
+                            t.close()
+                        }
+                        for (const e in n) {
+                            const i = n[e];
+                            t.open("clipPath", {
+                                id: e
+                            }), i.path ? t.open("path", {
+                                d: i.path
+                            }).close() : t.open("rect", {
+                                x: 0,
+                                y: 0,
+                                width: i.width,
+                                height: i.height
+                            }).close(), t.close()
+                        }
+                        t.close()
+                    }
+                }
+            });
+            const XO = {
+                svgMarkTypes: ["text"],
+                svgOnTop: !0,
+                debug: !1
+            };
+
+            function GO(t) {
+                var e, n, i;
+                XO.svgMarkTypes = null !== (e = t.svgMarkTypes) && void 0 !== e ? e : ["text"], XO.svgOnTop = null === (n = t.svgOnTop) || void 0 === n || n, XO.debug = null !== (i = t.debug) && void 0 !== i && i
+            }
+
+            function JO(t) {
+                MF.call(this, t), this._svgRenderer = new FO(t), this._canvasRenderer = new nO(t)
+            }
+            const ZO = MF.prototype;
+
+            function $O(t, e) {
+                YF.call(this, t, e)
+            }(0, m.XW)(JO, MF, {
+                initialize(t, e, n, i, r) {
+                    this._root_el = kF(t, 0, "div");
+                    const o = kF(this._root_el, 0, "div"),
+                        a = kF(this._root_el, 1, "div");
+                    return this._root_el.style.position = "relative", XO.debug || (o.style.height = "100%", a.style.position = "absolute", a.style.top = "0", a.style.left = "0", a.style.height = "100%", a.style.width = "100%"), this._svgEl = XO.svgOnTop ? a : o, this._canvasEl = XO.svgOnTop ? o : a, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, e, n, i, r), this._svgRenderer.initialize(this._svgEl, e, n, i, r), ZO.initialize.call(this, t, e, n, i, r)
+                },
+                dirty(t) {
+                    return XO.svgMarkTypes.includes(t.mark.marktype) ? this._svgRenderer.dirty(t) : this._canvasRenderer.dirty(t), this
+                },
+                _render(t, e) {
+                    const n = (null !== e && void 0 !== e ? e : ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"]).filter((t => !XO.svgMarkTypes.includes(t)));
+                    this._svgRenderer.render(t, XO.svgMarkTypes), this._canvasRenderer.render(t, n)
+                },
+                resize(t, e, n, i) {
+                    return ZO.resize.call(this, t, e, n, i), this._svgRenderer.resize(t, e, n, i), this._canvasRenderer.resize(t, e, n, i), this
+                },
+                background(t) {
+                    return XO.svgOnTop ? this._canvasRenderer.background(t) : this._svgRenderer.background(t), this
+                }
+            }), (0, m.XW)($O, YF, {
+                initialize(t, e, n) {
+                    const i = kF(kF(t, 0, "div"), XO.svgOnTop ? 0 : 1, "div");
+                    return YF.prototype.initialize.call(this, i, e, n)
+                }
+            });
+            const YO = "canvas",
+                VO = "hybrid",
+                KO = "none",
+                QO = {
+                    Canvas: YO,
+                    PNG: "png",
+                    SVG: "svg",
+                    Hybrid: VO,
+                    None: KO
+                },
+                tT = {};
+
+            function eT(t, e) {
+                return t = String(t || "").toLowerCase(), arguments.length > 1 ? (tT[t] = e, this) : tT[t]
+            }
+
+            function nT(t, e, n) {
+                const i = [],
+                    r = (new pC).union(e),
+                    o = t.marktype;
+                return o ? iT(t, r, n, i) : "group" === o ? rT(t, r, n, i) : (0, m.vU)("Intersect scene must be mark node or group item.")
+            }
+
+            function iT(t, e, n, i) {
+                if (function(t, e, n) {
+                        return t.bounds && e.intersects(t.bounds) && ("group" === t.marktype || !1 !== t.interactive && (!n || n(t)))
+                    }(t, e, n)) {
+                    const r = t.items,
+                        o = t.marktype,
+                        a = r.length;
+                    let s = 0;
+                    if ("group" === o)
+                        for (; s < a; ++s) rT(r[s], e, n, i);
+                    else
+                        for (const t = fF[o].isect; s < a; ++s) {
+                            const n = r[s];
+                            oT(n, e, t) && i.push(n)
+                        }
+                }
+                return i
+            }
+
+            function rT(t, e, n, i) {
+                n && n(t.mark) && oT(t, e, fF.group.isect) && i.push(t);
+                const r = t.items,
+                    o = r && r.length;
+                if (o) {
+                    const a = t.x || 0,
+                        s = t.y || 0;
+                    e.translate(-a, -s);
+                    for (let t = 0; t < o; ++t) iT(r[t], e, n, i);
+                    e.translate(a, s)
+                }
+                return i
+            }
+
+            function oT(t, e, n) {
+                const i = t.bounds;
+                return e.encloses(i) || e.intersects(i) && n(t, e)
+            }
+            tT[YO] = tT.png = {
+                renderer: nO,
+                headless: nO,
+                handler: YF
+            }, tT.svg = {
+                renderer: FO,
+                headless: HO,
+                handler: rO
+            }, tT[VO] = {
+                renderer: JO,
+                headless: JO,
+                handler: $O
+            }, tT[KO] = {};
+            const aT = new pC;
+
+            function sT(t) {
+                const e = t.clip;
+                if ((0, m.mf)(e)) e(BC(aT.clear()));
+                else {
+                    if (!e) return;
+                    aT.set(0, 0, t.group.width, t.group.height)
+                }
+                t.bounds.intersect(aT)
+            }
+            const cT = 1e-9;
+
+            function lT(t, e, n) {
+                return t === e || ("path" === n ? uT(t, e) : t instanceof Date && e instanceof Date ? +t === +e : (0, m.hj)(t) && (0, m.hj)(e) ? Math.abs(t - e) <= cT : t && e && ((0, m.Kn)(t) || (0, m.Kn)(e)) ? function(t, e) {
+                    var n, i, r = Object.keys(t),
+                        o = Object.keys(e);
+                    if (r.length !== o.length) return !1;
+                    for (r.sort(), o.sort(), i = r.length - 1; i >= 0; i--)
+                        if (r[i] != o[i]) return !1;
+                    for (i = r.length - 1; i >= 0; i--)
+                        if (!lT(t[n = r[i]], e[n], n)) return !1;
+                    return typeof t === typeof e
+                }(t, e) : t == e)
+            }
+
+            function uT(t, e) {
+                return lT(DS(t), DS(e))
+            }
+
+            function fT() {
+                dC(), hS = 0
+            }
+            const dT = "linear",
+                hT = "log",
+                pT = "pow",
+                mT = "sqrt",
+                gT = "symlog",
+                vT = "time",
+                yT = "utc",
+                bT = "sequential",
+                xT = "diverging",
+                _T = "quantile",
+                wT = "quantize",
+                kT = "threshold",
+                ET = "continuous",
+                AT = "discrete",
+                DT = "discretizing",
+                ST = "interpolating",
+                CT = "temporal";
+
+            function MT() {
+                const t = (0, Jl.Z)().unknown(void 0),
+                    e = t.domain,
+                    n = t.range;
+                let i, r, o = [0, 1],
+                    a = !1,
+                    s = 0,
+                    c = 0,
+                    l = .5;
+
+                function u() {
+                    const t = e().length,
+                        u = o[1] < o[0],
+                        f = o[1 - u],
+                        d = function(t, e, n) {
+                            const i = t - e + 2 * n;
+                            return t ? i > 0 ? i : 1 : 0
+                        }(t, s, c);
+                    let h = o[u - 0];
+                    i = (f - h) / (d || 1), a && (i = Math.floor(i)), h += (f - h - i * (t - s)) * l, r = i * (1 - s), a && (h = Math.round(h), r = Math.round(r));
+                    const p = (0, Wo.Z)(t).map((t => h + i * t));
+                    return n(u ? p.reverse() : p)
+                }
+                return delete t.unknown, t.domain = function(t) {
+                    return arguments.length ? (e(t), u()) : e()
+                }, t.range = function(t) {
+                    return arguments.length ? (o = [+t[0], +t[1]], u()) : o.slice()
+                }, t.rangeRound = function(t) {
+                    return o = [+t[0], +t[1]], a = !0, u()
+                }, t.bandwidth = function() {
+                    return r
+                }, t.step = function() {
+                    return i
+                }, t.round = function(t) {
+                    return arguments.length ? (a = !!t, u()) : a
+                }, t.padding = function(t) {
+                    return arguments.length ? (c = Math.max(0, Math.min(1, t)), s = c, u()) : s
+                }, t.paddingInner = function(t) {
+                    return arguments.length ? (s = Math.max(0, Math.min(1, t)), u()) : s
+                }, t.paddingOuter = function(t) {
+                    return arguments.length ? (c = Math.max(0, Math.min(1, t)), u()) : c
+                }, t.align = function(t) {
+                    return arguments.length ? (l = Math.max(0, Math.min(1, t)), u()) : l
+                }, t.invertRange = function(t) {
+                    if (null == t[0] || null == t[1]) return;
+                    const i = o[1] < o[0],
+                        a = i ? n().reverse() : n(),
+                        s = a.length - 1;
+                    let c, l, u, f = +t[0],
+                        d = +t[1];
+                    return f !== f || d !== d || (d < f && (u = f, f = d, d = u), d < a[0] || f > o[1 - i]) ? void 0 : (c = Math.max(0, (0, ol.ml)(a, f) - 1), l = f === d ? c : (0, ol.ml)(a, d) - 1, f - a[c] > r + 1e-10 && ++c, i && (u = c, c = s - l, l = s - u), c > l ? void 0 : e().slice(c, l + 1))
+                }, t.invert = function(e) {
+                    const n = t.invertRange([e, e]);
+                    return n ? n[0] : n
+                }, t.copy = function() {
+                    return MT().domain(e()).range(o).round(a).paddingInner(s).paddingOuter(c).align(l)
+                }, u()
+            }
+
+            function FT(t) {
+                const e = t.copy;
+                return t.padding = t.paddingOuter, delete t.paddingInner, t.copy = function() {
+                    return FT(e())
+                }, t
+            }
+            var OT = Array.prototype.map;
+            const TT = Array.prototype.slice;
+            const NT = new Map,
+                RT = Symbol("vega_scale");
+
+            function zT(t, e, n) {
+                const i = function() {
+                    const n = e();
+                    return n.invertRange || (n.invertRange = n.invert ? function(t) {
+                            return function(e) {
+                                let n, i = e[0],
+                                    r = e[1];
+                                return r < i && (n = i, i = r, r = n), [t.invert(i), t.invert(r)]
+                            }
+                        }(n) : n.invertExtent ? function(t) {
+                            return function(e) {
+                                const n = t.range();
+                                let i, r, o, a, s = e[0],
+                                    c = e[1],
+                                    l = -1;
+                                for (c < s && (r = s, s = c, c = r), o = 0, a = n.length; o < a; ++o) n[o] >= s && n[o] <= c && (l < 0 && (l = o), i = o);
+                                if (!(l < 0)) return s = t.invertExtent(n[l]), c = t.invertExtent(n[i]), [void 0 === s[0] ? s[1] : s[0], void 0 === c[1] ? c[0] : c[1]]
+                            }
+                        }(n) : void 0), n.type = t,
+                        function(t) {
+                            return t[RT] = !0, t
+                        }(n)
+                };
+                return i.metadata = (0, m.Rg)((0, m.IX)(n)), i
+            }
+
+            function PT(t, e, n) {
+                return arguments.length > 1 ? (NT.set(t, zT(t, e, n)), this) : function(t) {
+                    return NT.has(t)
+                }(t) ? NT.get(t) : void 0
+            }
+            PT("identity", cl), PT(dT, al.Z, ET), PT(hT, ll.Z, [ET, hT]), PT(pT, ul.ZP, ET), PT(mT, ul._b, ET), PT(gT, gl, ET), PT(vT, Dl, [ET, CT]), PT(yT, Sl, [ET, CT]), PT(bT, Tl, [ET, ST]), PT("".concat(bT, "-").concat(dT), Tl, [ET, ST]), PT("".concat(bT, "-").concat(hT), Nl, [ET, ST, hT]), PT("".concat(bT, "-").concat(pT), zl, [ET, ST]), PT("".concat(bT, "-").concat(mT), Pl, [ET, ST]), PT("".concat(bT, "-").concat(gT), Rl, [ET, ST]), PT("".concat(xT, "-").concat(dT), Il, [ET, ST]), PT("".concat(xT, "-").concat(hT), jl, [ET, ST, hT]), PT("".concat(xT, "-").concat(pT), ql, [ET, ST]), PT("".concat(xT, "-").concat(mT), Wl, [ET, ST]), PT("".concat(xT, "-").concat(gT), Ul, [ET, ST]), PT(_T, Hl.Z, [DT, _T]), PT(wT, Xl.Z, DT), PT(kT, Gl.Z, DT), PT("bin-ordinal", (function t() {
+                let e = [],
+                    n = [];
+
+                function i(t) {
+                    return null == t || t !== t ? void 0 : n[((0, ol.ZP)(e, t) - 1) % n.length]
+                }
+                return i.domain = function(t) {
+                    return arguments.length ? (e = function(t) {
+                        return OT.call(t, m.He)
+                    }(t), i) : e.slice()
+                }, i.range = function(t) {
+                    return arguments.length ? (n = TT.call(t), i) : n.slice()
+                }, i.tickFormat = function(t, n) {
+                    return (0, Zl.Z)(e[0], (0, m.fj)(e), null == t ? 10 : t, n)
+                }, i.copy = function() {
+                    return t().domain(i.domain()).range(i.range())
+                }, i
+            }), [AT, DT]), PT("ordinal", Jl.Z, AT), PT("band", MT, AT), PT("point", (function() {
+                return FT(MT().paddingInner(1))
+            }), AT);
+
+            function LT(t, e) {
+                const n = e[0],
+                    i = (0, m.fj)(e) - n;
+                return function(e) {
+                    return t(n + e * i)
+                }
+            }
+
+            function BT(t, e, n) {
+                return Ll(jT(e || "rgb", n), t)
+            }
+
+            function IT(t, e) {
+                const n = new Array(e),
+                    i = e + 1;
+                for (let r = 0; r < e;) n[r] = t(++r / i);
+                return n
+            }
+
+            function jT(t, e) {
+                const n = r[function(t) {
+                    return "interpolate" + t.toLowerCase().split("-").map((t => t[0].toUpperCase() + t.slice(1))).join("")
+                }(t)];
+                return null != e && n && n.gamma ? n.gamma(e) : n
+            }
+
+            function UT(t) {
+                const e = t.length / 6 | 0,
+                    n = new Array(e);
+                for (let i = 0; i < e;) n[i] = "#" + t.slice(6 * i, 6 * ++i);
+                return n
+            }
+
+            function qT(t, e) {
+                for (const n in t) HT(n, e(t[n]))
+            }
+            const WT = {};
+
+            function HT(t, e) {
+                return t = t && t.toLowerCase(), arguments.length > 1 ? (WT[t] = e, this) : WT[t]
+            }
+            qT({
+                category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
+                category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
+                category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
+                category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
+                tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
+                tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
+                accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
+                dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
+                paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
+                pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
+                pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
+                set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
+                set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
+                set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
+            }, UT), qT({
+                blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
+                greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
+                greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
+                oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
+                purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
+                reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
+                blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
+                bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
+                greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
+                orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
+                purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
+                purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
+                purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
+                redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
+                yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
+                yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
+                yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
+                blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
+                brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
+                purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
+                purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
+                redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
+                redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
+                yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
+                redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
+                redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
+                pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
+                spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
+                viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
+                magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
+                inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
+                plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
+                cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
+                rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
+                sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
+                turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
+                browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
+                tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
+                teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
+                warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
+                goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
+                goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
+                goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
+                lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
+                lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
+                lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
+                lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
+                lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
+                darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
+                darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
+                darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
+                darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
+                darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
+            }, (t => BT(UT(t))));
+            var XT, GT, JT, ZT, $T, YT, VT, KT, QT, tN, eN, nN, iN, rN, oN, aN, sN = n(88120),
+                cN = new Xy,
+                lN = new Xy,
+                uN = {
+                    point: mb,
+                    lineStart: mb,
+                    lineEnd: mb,
                     polygonStart: function() {
-                        DA = new jy, SA.lineStart = CA, SA.lineEnd = FA
+                        cN = new Xy, uN.lineStart = fN, uN.lineEnd = dN
                     },
                     polygonEnd: function() {
-                        var t = +DA;
-                        AA.add(t < 0 ? Hy + t : t), this.lineStart = this.lineEnd = this.point = cb
+                        var t = +cN;
+                        lN.add(t < 0 ? Vy + t : t), this.lineStart = this.lineEnd = this.point = mb
                     },
                     sphere: function() {
-                        AA.add(Hy)
+                        lN.add(Vy)
                     }
                 };
 
-            function CA() {
-                SA.point = MA
+            function fN() {
+                uN.point = hN
             }
 
-            function FA() {
-                OA(cA, lA)
+            function dN() {
+                pN(XT, GT)
             }
 
-            function MA(t, e) {
-                SA.point = OA, cA = t, lA = e, uA = t *= Jy, fA = Yy(e = (e *= Jy) / 2 + Wy), dA = nb(e)
+            function hN(t, e) {
+                uN.point = pN, XT = t, GT = e, JT = t *= Qy, ZT = ib(e = (e *= Qy) / 2 + Yy), $T = lb(e)
             }
 
-            function OA(t, e) {
-                var n = (t *= Jy) - uA,
+            function pN(t, e) {
+                var n = (t *= Qy) - JT,
                     i = n >= 0 ? 1 : -1,
                     r = i * n,
-                    o = Yy(e = (e *= Jy) / 2 + Wy),
-                    a = nb(e),
-                    s = dA * a,
-                    c = fA * o + s * Yy(r),
-                    l = s * i * nb(r);
-                DA.add(Zy(l, c)), uA = t, fA = o, dA = a
-            }
-            var TA, NA, zA, RA, PA, LA, jA, BA, IA, UA, qA, WA, HA, XA, JA, GA, $A = {
-                point: ZA,
-                lineStart: VA,
-                lineEnd: KA,
+                    o = ib(e = (e *= Qy) / 2 + Yy),
+                    a = lb(e),
+                    s = $T * a,
+                    c = ZT * o + s * ib(r),
+                    l = s * i * lb(r);
+                cN.add(nb(l, c)), JT = t, ZT = o, $T = a
+            }
+
+            function mN(t) {
+                return lN = new Xy, Hy(t, uN), 2 * lN
+            }
+            var gN, vN, yN, bN, xN, _N, wN, kN, EN, AN, DN, SN, CN, MN, FN, ON, TN = {
+                point: NN,
+                lineStart: zN,
+                lineEnd: PN,
                 polygonStart: function() {
-                    $A.point = QA, $A.lineStart = tS, $A.lineEnd = eS, _A = new jy, SA.polygonStart()
+                    TN.point = LN, TN.lineStart = BN, TN.lineEnd = IN, rN = new Xy, uN.polygonStart()
                 },
                 polygonEnd: function() {
-                    SA.polygonEnd(), $A.point = ZA, $A.lineStart = VA, $A.lineEnd = KA, DA < 0 ? (hA = -(mA = 180), pA = -(gA = 90)) : _A > By ? gA = 90 : _A < -By && (pA = -90), kA[0] = hA, kA[1] = mA
+                    uN.polygonEnd(), TN.point = NN, TN.lineStart = zN, TN.lineEnd = PN, cN < 0 ? (YT = -(KT = 180), VT = -(QT = 90)) : rN > Gy ? QT = 90 : rN < -Gy && (VT = -90), aN[0] = YT, aN[1] = KT
                 },
                 sphere: function() {
-                    hA = -(mA = 180), pA = -(gA = 90)
+                    YT = -(KT = 180), VT = -(QT = 90)
                 }
             };
 
-            function ZA(t, e) {
-                wA.push(kA = [hA = t, mA = t]), e < pA && (pA = e), e > gA && (gA = e)
+            function NN(t, e) {
+                oN.push(aN = [YT = t, KT = t]), e < VT && (VT = e), e > QT && (QT = e)
             }
 
-            function YA(t, e) {
-                var n = Dx([t * Jy, e * Jy]);
-                if (xA) {
-                    var i = Sx(xA, n),
-                        r = Sx([i[1], -i[0], 0], i);
-                    Mx(r), r = Ex(r);
-                    var o, a = t - vA,
+            function RN(t, e) {
+                var n = Tx([t * Qy, e * Qy]);
+                if (iN) {
+                    var i = Rx(iN, n),
+                        r = Rx([i[1], -i[0], 0], i);
+                    Lx(r), r = Ox(r);
+                    var o, a = t - tN,
                         s = a > 0 ? 1 : -1,
-                        c = r[0] * Xy * s,
-                        l = Gy(a) > 180;
-                    l ^ (s * vA < c && c < s * t) ? (o = r[1] * Xy) > gA && (gA = o) : l ^ (s * vA < (c = (c + 360) % 360 - 180) && c < s * t) ? (o = -r[1] * Xy) < pA && (pA = o) : (e < pA && (pA = e), e > gA && (gA = e)), l ? t < vA ? nS(hA, t) > nS(hA, mA) && (mA = t) : nS(t, mA) > nS(hA, mA) && (hA = t) : mA >= hA ? (t < hA && (hA = t), t > mA && (mA = t)) : t > vA ? nS(hA, t) > nS(hA, mA) && (mA = t) : nS(t, mA) > nS(hA, mA) && (hA = t)
-                } else wA.push(kA = [hA = t, mA = t]);
-                e < pA && (pA = e), e > gA && (gA = e), xA = n, vA = t
+                        c = r[0] * Ky * s,
+                        l = tb(a) > 180;
+                    l ^ (s * tN < c && c < s * t) ? (o = r[1] * Ky) > QT && (QT = o) : l ^ (s * tN < (c = (c + 360) % 360 - 180) && c < s * t) ? (o = -r[1] * Ky) < VT && (VT = o) : (e < VT && (VT = e), e > QT && (QT = e)), l ? t < tN ? jN(YT, t) > jN(YT, KT) && (KT = t) : jN(t, KT) > jN(YT, KT) && (YT = t) : KT >= YT ? (t < YT && (YT = t), t > KT && (KT = t)) : t > tN ? jN(YT, t) > jN(YT, KT) && (KT = t) : jN(t, KT) > jN(YT, KT) && (YT = t)
+                } else oN.push(aN = [YT = t, KT = t]);
+                e < VT && (VT = e), e > QT && (QT = e), iN = n, tN = t
             }
 
-            function VA() {
-                $A.point = YA
+            function zN() {
+                TN.point = RN
             }
 
-            function KA() {
-                kA[0] = hA, kA[1] = mA, $A.point = ZA, xA = null
+            function PN() {
+                aN[0] = YT, aN[1] = KT, TN.point = NN, iN = null
             }
 
-            function QA(t, e) {
-                if (xA) {
-                    var n = t - vA;
-                    _A.add(Gy(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
-                } else yA = t, bA = e;
-                SA.point(t, e), YA(t, e)
+            function LN(t, e) {
+                if (iN) {
+                    var n = t - tN;
+                    rN.add(tb(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
+                } else eN = t, nN = e;
+                uN.point(t, e), RN(t, e)
             }
 
-            function tS() {
-                SA.lineStart()
+            function BN() {
+                uN.lineStart()
             }
 
-            function eS() {
-                QA(yA, bA), SA.lineEnd(), Gy(_A) > By && (hA = -(mA = 180)), kA[0] = hA, kA[1] = mA, xA = null
+            function IN() {
+                LN(eN, nN), uN.lineEnd(), tb(rN) > Gy && (YT = -(KT = 180)), aN[0] = YT, aN[1] = KT, iN = null
             }
 
-            function nS(t, e) {
+            function jN(t, e) {
                 return (e -= t) < 0 ? e + 360 : e
             }
 
-            function iS(t, e) {
+            function UN(t, e) {
                 return t[0] - e[0]
             }
 
-            function rS(t, e) {
+            function qN(t, e) {
                 return t[0] <= t[1] ? t[0] <= e && e <= t[1] : e < t[0] || t[1] < e
             }
-            var oS = {
-                sphere: cb,
-                point: aS,
-                lineStart: cS,
-                lineEnd: fS,
+
+            function WN(t) {
+                var e, n, i, r, o, a, s;
+                if (QT = KT = -(YT = VT = 1 / 0), oN = [], Hy(t, TN), n = oN.length) {
+                    for (oN.sort(UN), e = 1, o = [i = oN[0]]; e < n; ++e) qN(i, (r = oN[e])[0]) || qN(i, r[1]) ? (jN(i[0], r[1]) > jN(i[0], i[1]) && (i[1] = r[1]), jN(r[0], i[1]) > jN(i[0], i[1]) && (i[0] = r[0])) : o.push(i = r);
+                    for (a = -1 / 0, e = 0, i = o[n = o.length - 1]; e <= n; i = r, ++e) r = o[e], (s = jN(i[1], r[0])) > a && (a = s, YT = r[0], KT = i[1])
+                }
+                return oN = aN = null, YT === 1 / 0 || VT === 1 / 0 ? [
+                    [NaN, NaN],
+                    [NaN, NaN]
+                ] : [
+                    [YT, VT],
+                    [KT, QT]
+                ]
+            }
+            var HN = {
+                sphere: mb,
+                point: XN,
+                lineStart: JN,
+                lineEnd: YN,
                 polygonStart: function() {
-                    oS.lineStart = dS, oS.lineEnd = hS
+                    HN.lineStart = VN, HN.lineEnd = KN
                 },
                 polygonEnd: function() {
-                    oS.lineStart = cS, oS.lineEnd = fS
+                    HN.lineStart = JN, HN.lineEnd = YN
                 }
             };
 
-            function aS(t, e) {
-                t *= Jy;
-                var n = Yy(e *= Jy);
-                sS(n * Yy(t), n * nb(t), nb(e))
+            function XN(t, e) {
+                t *= Qy;
+                var n = ib(e *= Qy);
+                GN(n * ib(t), n * lb(t), lb(e))
             }
 
-            function sS(t, e, n) {
-                ++TA, zA += (t - zA) / TA, RA += (e - RA) / TA, PA += (n - PA) / TA
+            function GN(t, e, n) {
+                ++gN, yN += (t - yN) / gN, bN += (e - bN) / gN, xN += (n - xN) / gN
             }
 
-            function cS() {
-                oS.point = lS
+            function JN() {
+                HN.point = ZN
             }
 
-            function lS(t, e) {
-                t *= Jy;
-                var n = Yy(e *= Jy);
-                XA = n * Yy(t), JA = n * nb(t), GA = nb(e), oS.point = uS, sS(XA, JA, GA)
+            function ZN(t, e) {
+                t *= Qy;
+                var n = ib(e *= Qy);
+                MN = n * ib(t), FN = n * lb(t), ON = lb(e), HN.point = $N, GN(MN, FN, ON)
             }
 
-            function uS(t, e) {
-                t *= Jy;
-                var n = Yy(e *= Jy),
-                    i = n * Yy(t),
-                    r = n * nb(t),
-                    o = nb(e),
-                    a = Zy(rb((a = JA * o - GA * r) * a + (a = GA * i - XA * o) * a + (a = XA * r - JA * i) * a), XA * i + JA * r + GA * o);
-                NA += a, LA += a * (XA + (XA = i)), jA += a * (JA + (JA = r)), BA += a * (GA + (GA = o)), sS(XA, JA, GA)
+            function $N(t, e) {
+                t *= Qy;
+                var n = ib(e *= Qy),
+                    i = n * ib(t),
+                    r = n * lb(t),
+                    o = lb(e),
+                    a = nb(fb((a = FN * o - ON * r) * a + (a = ON * i - MN * o) * a + (a = MN * r - FN * i) * a), MN * i + FN * r + ON * o);
+                vN += a, _N += a * (MN + (MN = i)), wN += a * (FN + (FN = r)), kN += a * (ON + (ON = o)), GN(MN, FN, ON)
             }
 
-            function fS() {
-                oS.point = aS
+            function YN() {
+                HN.point = XN
             }
 
-            function dS() {
-                oS.point = pS
+            function VN() {
+                HN.point = QN
             }
 
-            function hS() {
-                mS(WA, HA), oS.point = aS
+            function KN() {
+                tR(SN, CN), HN.point = XN
             }
 
-            function pS(t, e) {
-                WA = t, HA = e, t *= Jy, e *= Jy, oS.point = mS;
-                var n = Yy(e);
-                XA = n * Yy(t), JA = n * nb(t), GA = nb(e), sS(XA, JA, GA)
+            function QN(t, e) {
+                SN = t, CN = e, t *= Qy, e *= Qy, HN.point = tR;
+                var n = ib(e);
+                MN = n * ib(t), FN = n * lb(t), ON = lb(e), GN(MN, FN, ON)
             }
 
-            function mS(t, e) {
-                t *= Jy;
-                var n = Yy(e *= Jy),
-                    i = n * Yy(t),
-                    r = n * nb(t),
-                    o = nb(e),
-                    a = JA * o - GA * r,
-                    s = GA * i - XA * o,
-                    c = XA * r - JA * i,
-                    l = Qy(a, s, c),
-                    u = sb(l),
+            function tR(t, e) {
+                t *= Qy;
+                var n = ib(e *= Qy),
+                    i = n * ib(t),
+                    r = n * lb(t),
+                    o = lb(e),
+                    a = FN * o - ON * r,
+                    s = ON * i - MN * o,
+                    c = MN * r - FN * i,
+                    l = ab(a, s, c),
+                    u = pb(l),
                     f = l && -u / l;
-                IA.add(f * a), UA.add(f * s), qA.add(f * c), NA += u, LA += u * (XA + (XA = i)), jA += u * (JA + (JA = r)), BA += u * (GA + (GA = o)), sS(XA, JA, GA)
+                EN.add(f * a), AN.add(f * s), DN.add(f * c), vN += u, _N += u * (MN + (MN = i)), wN += u * (FN + (FN = r)), kN += u * (ON + (ON = o)), GN(MN, FN, ON)
             }
-            var gS = n(20905);
 
-            function vS(t) {
-                return t instanceof gS.H ? t : new gS.H(t)
-            }
-            const yS = "intersect",
-                bS = "union",
-                xS = "_vgsid_",
-                _S = (0, m.EP)(xS),
-                wS = "E",
-                kS = "R",
-                ES = "R-E",
-                DS = "R-LE",
-                AS = "R-RE",
-                SS = "index:unit";
+            function eR(t) {
+                gN = vN = yN = bN = xN = _N = wN = kN = 0, EN = new Xy, AN = new Xy, DN = new Xy, Hy(t, HN);
+                var e = +EN,
+                    n = +AN,
+                    i = +DN,
+                    r = ab(e, n, i);
+                return r < Jy && (e = _N, n = wN, i = kN, vN < Gy && (e = yN, n = bN, i = xN), (r = ab(e, n, i)) < Jy) ? [NaN, NaN] : [nb(n, e) * Ky, pb(i / r) * Ky]
+            }
+            var nR = n(20905);
+
+            function iR(t) {
+                return t instanceof nR.H ? t : new nR.H(t)
+            }
+            const rR = "intersect",
+                oR = "union",
+                aR = "_vgsid_",
+                sR = (0, m.EP)(aR),
+                cR = "E",
+                lR = "R",
+                uR = "R-E",
+                fR = "R-LE",
+                dR = "R-RE",
+                hR = "index:unit";
 
-            function CS(t, e) {
+            function pR(t, e) {
                 for (var n, i, r = e.fields, o = e.values, a = r.length, s = 0; s < a; ++s)
-                    if ((i = r[s]).getter = m.EP.getter || (0, m.EP)(i.field), n = i.getter(t), (0, m.J_)(n) && (n = (0, m.He)(n)), (0, m.J_)(o[s]) && (o[s] = (0, m.He)(o[s])), (0, m.J_)(o[s][0]) && (o[s] = o[s].map(m.He)), i.type === wS) {
+                    if ((i = r[s]).getter = m.EP.getter || (0, m.EP)(i.field), n = i.getter(t), (0, m.J_)(n) && (n = (0, m.He)(n)), (0, m.J_)(o[s]) && (o[s] = (0, m.He)(o[s])), (0, m.J_)(o[s][0]) && (o[s] = o[s].map(m.He)), i.type === cR) {
                         if ((0, m.kJ)(o[s]) ? o[s].indexOf(n) < 0 : n !== o[s]) return !1
-                    } else if (i.type === kS) {
+                    } else if (i.type === lR) {
                     if (!(0, m.u5)(n, o[s])) return !1
-                } else if (i.type === AS) {
+                } else if (i.type === dR) {
                     if (!(0, m.u5)(n, o[s], !0, !1)) return !1
-                } else if (i.type === ES) {
+                } else if (i.type === uR) {
                     if (!(0, m.u5)(n, o[s], !1, !1)) return !1
-                } else if (i.type === DS && !(0, m.u5)(n, o[s], !1, !0)) return !1;
+                } else if (i.type === fR && !(0, m.u5)(n, o[s], !1, !0)) return !1;
                 return !0
             }
-            const FS = (0, Dt.Z)(_S),
-                MS = FS.left,
-                OS = FS.right;
-            var TS = {
-                ["".concat(xS, "_union")]: function() {
-                    const t = new gS.H;
+            const mR = (0, At.Z)(sR),
+                gR = mR.left,
+                vR = mR.right;
+            var yR = {
+                ["".concat(aR, "_union")]: function() {
+                    const t = new nR.H;
                     for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                     for (const r of n)
                         for (const e of r) t.add(e);
                     return t
                 },
-                ["".concat(xS, "_intersect")]: function(t) {
+                ["".concat(aR, "_intersect")]: function(t) {
                     for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
-                    t = new gS.H(t), n = n.map(vS);
+                    t = new nR.H(t), n = n.map(iR);
                     t: for (const r of t)
                         for (const e of n)
                             if (!e.has(r)) {
                                 t.delete(r);
                                 continue t
                             }
                     return t
@@ -38139,188 +41538,163 @@
                 R_intersect: function(t, e) {
                     var n = (0, m.He)(e[0]),
                         i = (0, m.He)(e[1]);
                     return n > i && (n = e[1], i = e[0]), t.length ? i < t[0] || t[1] < n ? [] : (t[0] < n && (t[0] = n), t[1] > i && (t[1] = i), t) : [n, i]
                 }
             };
 
-            function NS(t, e, n, i) {
-                e[0].type !== EA.t$ && (0, m.vU)("First argument to selection functions must be a string literal.");
+            function bR(t, e, n, i) {
+                e[0].type !== sN.t$ && (0, m.vU)("First argument to selection functions must be a string literal.");
                 const r = e[0].value,
                     o = "unit",
                     a = "@" + o,
                     s = ":" + r;
-                (e.length >= 2 && (0, m.fj)(e).value) !== yS || (0, m.nr)(i, a) || (i[a] = n.getData(r).indataRef(n, o)), (0, m.nr)(i, s) || (i[s] = n.getData(r).tuplesRef())
+                (e.length >= 2 && (0, m.fj)(e).value) !== rR || (0, m.nr)(i, a) || (i[a] = n.getData(r).indataRef(n, o)), (0, m.nr)(i, s) || (i[s] = n.getData(r).tuplesRef())
             }
 
-            function zS(t) {
+            function xR(t) {
                 const e = this.context.data[t];
                 return e ? e.values.value : []
             }
-            const RS = t => function(e, n) {
+            const _R = t => function(e, n) {
                     return this.context.dataflow.locale()[t](n)(e)
                 },
-                PS = RS("format"),
-                LS = RS("timeFormat"),
-                jS = RS("utcFormat"),
-                BS = RS("timeParse"),
-                IS = RS("utcParse"),
-                US = new Date(2e3, 0, 1);
+                wR = _R("format"),
+                kR = _R("timeFormat"),
+                ER = _R("utcFormat"),
+                AR = _R("timeParse"),
+                DR = _R("utcParse"),
+                SR = new Date(2e3, 0, 1);
 
-            function qS(t, e, n) {
-                return Number.isInteger(t) && Number.isInteger(e) ? (US.setYear(2e3), US.setMonth(t), US.setDate(e), LS.call(this, US, n)) : ""
+            function CR(t, e, n) {
+                return Number.isInteger(t) && Number.isInteger(e) ? (SR.setYear(2e3), SR.setMonth(t), SR.setDate(e), kR.call(this, SR, n)) : ""
             }
-            const WS = "%",
-                HS = "$";
+            const MR = "%";
 
-            function XS(t, e, n, i) {
-                e[0].type !== EA.t$ && (0, m.vU)("First argument to data functions must be a string literal.");
+            function FR(t, e, n, i) {
+                e[0].type !== sN.t$ && (0, m.vU)("First argument to data functions must be a string literal.");
                 const r = e[0].value,
                     o = ":" + r;
                 if (!(0, m.nr)(o, i)) try {
                     i[o] = n.getData(r).tuplesRef()
                 } catch (a) {}
             }
 
-            function JS(t, e, n, i) {
-                if (e[0].type === EA.t$) GS(n, i, e[0].value);
+            function OR(t, e, n, i) {
+                if (e[0].type === sN.t$) TR(n, i, e[0].value);
                 else
-                    for (t in n.scales) GS(n, i, t)
+                    for (t in n.scales) TR(n, i, t)
             }
 
-            function GS(t, e, n) {
-                const i = WS + n;
+            function TR(t, e, n) {
+                const i = MR + n;
                 if (!(0, m.nr)(e, i)) try {
                     e[i] = t.scaleRef(n)
                 } catch (r) {}
             }
 
-            function $S(t, e) {
+            function NR(t, e) {
                 if ((0, m.mf)(t)) return t;
                 if ((0, m.HD)(t)) {
                     const n = e.scales[t];
-                    return n && function(t) {
-                        return t && !0 === t[rf]
-                    }(n.value) ? n.value : void 0
+                    return n && Mf(n.value) ? n.value : void 0
                 }
             }
 
-            function ZS(t, e, n) {
-                e.__bandwidth = t => t && t.bandwidth ? t.bandwidth() : 0, n._bandwidth = JS, n._range = JS, n._scale = JS;
-                const i = e => "_[" + (e.type === EA.t$ ? (0, m.m8)(WS + e.value) : (0, m.m8)(WS) + "+" + t(e)) + "]";
+            function RR(t, e, n) {
+                e.__bandwidth = t => t && t.bandwidth ? t.bandwidth() : 0, n._bandwidth = OR, n._range = OR, n._scale = OR;
+                const i = e => "_[" + (e.type === sN.t$ ? (0, m.m8)(MR + e.value) : (0, m.m8)(MR) + "+" + t(e)) + "]";
                 return {
                     _bandwidth: t => "this.__bandwidth(".concat(i(t[0]), ")"),
                     _range: t => "".concat(i(t[0]), ".range()"),
                     _scale: e => "".concat(i(e[0]), "(").concat(t(e[1]), ")")
                 }
             }
 
-            function YS(t, e) {
+            function zR(t, e) {
                 return function(n, i, r) {
                     if (n) {
-                        const e = $S(n, (r || this).context);
+                        const e = NR(n, (r || this).context);
                         return e && e.path[t](i)
                     }
                     return e(i)
                 }
             }
-            const VS = YS("area", (function(t) {
-                    return AA = new jy, Ly(t, SA), 2 * AA
-                })),
-                KS = YS("bounds", (function(t) {
-                    var e, n, i, r, o, a, s;
-                    if (gA = mA = -(hA = pA = 1 / 0), wA = [], Ly(t, $A), n = wA.length) {
-                        for (wA.sort(iS), e = 1, o = [i = wA[0]]; e < n; ++e) rS(i, (r = wA[e])[0]) || rS(i, r[1]) ? (nS(i[0], r[1]) > nS(i[0], i[1]) && (i[1] = r[1]), nS(r[0], i[1]) > nS(i[0], i[1]) && (i[0] = r[0])) : o.push(i = r);
-                        for (a = -1 / 0, e = 0, i = o[n = o.length - 1]; e <= n; i = r, ++e) r = o[e], (s = nS(i[1], r[0])) > a && (a = s, hA = r[0], mA = i[1])
-                    }
-                    return wA = kA = null, hA === 1 / 0 || pA === 1 / 0 ? [
-                        [NaN, NaN],
-                        [NaN, NaN]
-                    ] : [
-                        [hA, pA],
-                        [mA, gA]
-                    ]
-                })),
-                QS = YS("centroid", (function(t) {
-                    TA = NA = zA = RA = PA = LA = jA = BA = 0, IA = new jy, UA = new jy, qA = new jy, Ly(t, oS);
-                    var e = +IA,
-                        n = +UA,
-                        i = +qA,
-                        r = Qy(e, n, i);
-                    return r < Iy && (e = LA, n = jA, i = BA, NA < By && (e = zA, n = RA, i = PA), (r = Qy(e, n, i)) < Iy) ? [NaN, NaN] : [Zy(n, e) * Xy, sb(i / r) * Xy]
-                }));
+            const PR = zR("area", mN),
+                LR = zR("bounds", WN),
+                BR = zR("centroid", eR);
 
-            function tC(t, e, n) {
+            function IR(t, e, n) {
                 try {
                     t[e].apply(t, ["EXPRESSION"].concat([].slice.call(n)))
                 } catch (i) {
                     t.warn(i)
                 }
                 return n[n.length - 1]
             }
 
-            function eC(t) {
+            function jR(t) {
                 const e = t / 255;
                 return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
             }
 
-            function nC(t) {
-                const e = (0, Ul.B8)(t);
-                return .2126 * eC(e.r) + .7152 * eC(e.g) + .0722 * eC(e.b)
+            function UR(t) {
+                const e = (0, uu.B8)(t);
+                return .2126 * jR(e.r) + .7152 * jR(e.g) + .0722 * jR(e.b)
             }
 
-            function iC(t, e) {
+            function qR(t, e) {
                 return t === e || t !== t && e !== e || ((0, m.kJ)(t) ? !(!(0, m.kJ)(e) || t.length !== e.length) && function(t, e) {
                     for (let n = 0, i = t.length; n < i; ++n)
-                        if (!iC(t[n], e[n])) return !1;
+                        if (!qR(t[n], e[n])) return !1;
                     return !0
-                }(t, e) : !(!(0, m.Kn)(t) || !(0, m.Kn)(e)) && rC(t, e))
+                }(t, e) : !(!(0, m.Kn)(t) || !(0, m.Kn)(e)) && WR(t, e))
             }
 
-            function rC(t, e) {
+            function WR(t, e) {
                 for (const n in t)
-                    if (!iC(t[n], e[n])) return !1;
+                    if (!qR(t[n], e[n])) return !1;
                 return !0
             }
 
-            function oC(t) {
-                return e => rC(t, e)
+            function HR(t) {
+                return e => WR(t, e)
             }
-            const aC = {};
+            const XR = {};
 
-            function sC(t) {
+            function GR(t) {
                 return (0, m.kJ)(t) || ArrayBuffer.isView(t) ? t : null
             }
 
-            function cC(t) {
-                return sC(t) || ((0, m.HD)(t) ? t : null)
+            function JR(t) {
+                return GR(t) || ((0, m.HD)(t) ? t : null)
             }
-            const lC = t => t.data;
+            const ZR = t => t.data;
 
-            function uC(t, e) {
-                const n = zS.call(e, t);
+            function $R(t, e) {
+                const n = xR.call(e, t);
                 return n.root && n.root.lookup || {}
             }
-            const fC = () => "undefined" !== typeof window && window || null;
+            const YR = () => "undefined" !== typeof window && window || null;
 
-            function dC(t, e, n) {
+            function VR(t, e, n) {
                 if (!t) return [];
-                const [i, r] = t, o = (new $d).set(i[0], i[1], r[0], r[1]);
-                return Dg(n || this.context.dataflow.scenegraph().root, o, function(t) {
+                const [i, r] = t, o = (new uh).set(i[0], i[1], r[0], r[1]);
+                return Lg(n || this.context.dataflow.scenegraph().root, o, function(t) {
                     let e = null;
                     if (t) {
                         const n = (0, m.IX)(t.marktype),
                             i = (0, m.IX)(t.markname);
                         e = t => (!n.length || n.some((e => t.marktype === e))) && (!i.length || i.some((e => t.name === e)))
                     }
                     return e
                 }(e))
             }
-            const hC = {
-                    random: () => $r(),
+            const KR = {
+                    random: () => Zr(),
                     cumulativeNormal: oo,
                     cumulativeLogNormal: fo,
                     cumulativeUniform: yo,
                     densityNormal: ro,
                     densityLogNormal: uo,
                     densityUniform: vo,
                     quantileNormal: ao,
@@ -38341,96 +41715,96 @@
                     isValid: t => null != t && t === t,
                     toBoolean: m.sw,
                     toDate: t => (0, m.ZU)(t),
                     toNumber: m.He,
                     toString: m.BB,
                     indexof: function(t) {
                         for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
-                        return cC(t).indexOf(...n)
+                        return JR(t).indexOf(...n)
                     },
                     join: function(t) {
                         for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
-                        return sC(t).join(...n)
+                        return GR(t).join(...n)
                     },
                     lastindexof: function(t) {
                         for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
-                        return cC(t).lastIndexOf(...n)
+                        return JR(t).lastIndexOf(...n)
                     },
                     replace: function(t, e, n) {
                         return (0, m.mf)(n) && (0, m.vU)("Function argument passed to replace."), String(t).replace(e, n)
                     },
                     reverse: function(t) {
-                        return sC(t).slice().reverse()
+                        return GR(t).slice().reverse()
                     },
                     slice: function(t) {
                         for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
-                        return cC(t).slice(...n)
+                        return JR(t).slice(...n)
                     },
                     flush: m.yl,
                     lerp: m.t7,
                     merge: function() {
                         const t = [].slice.call(arguments);
                         return t.unshift({}), (0, m.l7)(...t)
                     },
                     pad: m.vk,
                     peek: m.fj,
                     pluck: function(t, e) {
-                        const n = aC[e] || (aC[e] = (0, m.EP)(e));
+                        const n = XR[e] || (XR[e] = (0, m.EP)(e));
                         return (0, m.kJ)(t) ? t.map(n) : n(t)
                     },
                     span: m.yP,
                     inrange: m.u5,
                     truncate: m.$G,
-                    rgb: Ul.B8,
-                    lab: nu,
-                    hcl: lu,
-                    hsl: Ul.Ym,
-                    luminance: nC,
+                    rgb: uu.B8,
+                    lab: Au,
+                    hcl: Tu,
+                    hsl: uu.Ym,
+                    luminance: UR,
                     contrast: function(t, e) {
-                        const n = nC(t),
-                            i = nC(e);
+                        const n = UR(t),
+                            i = UR(e);
                         return (Math.max(n, i) + .05) / (Math.min(n, i) + .05)
                     },
                     sequence: Wo.Z,
-                    format: PS,
-                    utcFormat: jS,
-                    utcParse: IS,
+                    format: wR,
+                    utcFormat: ER,
+                    utcParse: DR,
                     utcOffset: ge,
                     utcSequence: be,
-                    timeFormat: LS,
-                    timeParse: BS,
+                    timeFormat: kR,
+                    timeParse: AR,
                     timeOffset: me,
                     timeSequence: ye,
                     timeUnitSpecifier: Ut,
                     monthFormat: function(t) {
-                        return qS.call(this, t, 1, "%B")
+                        return CR.call(this, t, 1, "%B")
                     },
                     monthAbbrevFormat: function(t) {
-                        return qS.call(this, t, 1, "%b")
+                        return CR.call(this, t, 1, "%b")
                     },
                     dayFormat: function(t) {
-                        return qS.call(this, 0, 2 + t, "%A")
+                        return CR.call(this, 0, 2 + t, "%A")
                     },
                     dayAbbrevFormat: function(t) {
-                        return qS.call(this, 0, 2 + t, "%a")
+                        return CR.call(this, 0, 2 + t, "%a")
                     },
                     quarter: m.mS,
                     utcquarter: m.N3,
                     week: Xt,
                     utcweek: Vt,
                     dayofyear: Ht,
                     utcdayofyear: Yt,
                     warn: function() {
-                        return tC(this.context.dataflow, "warn", arguments)
+                        return IR(this.context.dataflow, "warn", arguments)
                     },
                     info: function() {
-                        return tC(this.context.dataflow, "info", arguments)
+                        return IR(this.context.dataflow, "info", arguments)
                     },
                     debug: function() {
-                        return tC(this.context.dataflow, "debug", arguments)
+                        return IR(this.context.dataflow, "debug", arguments)
                     },
                     extent: t => (0, m.We)(t),
                     inScope: function(t) {
                         const e = this.context.group;
                         let n = !1;
                         if (e)
                             for (; t;) {
@@ -38438,51 +41812,51 @@
                                     n = !0;
                                     break
                                 }
                                 t = t.mark.group
                             }
                         return n
                     },
-                    intersect: dC,
+                    intersect: VR,
                     clampRange: m.l$,
                     pinchDistance: function(t) {
                         const e = t.touches,
                             n = e[0].clientX - e[1].clientX,
                             i = e[0].clientY - e[1].clientY;
                         return Math.hypot(n, i)
                     },
                     pinchAngle: function(t) {
                         const e = t.touches;
                         return Math.atan2(e[0].clientY - e[1].clientY, e[0].clientX - e[1].clientX)
                     },
                     screen: function() {
-                        const t = fC();
+                        const t = YR();
                         return t ? t.screen : {}
                     },
                     containerSize: function() {
                         const t = this.context.dataflow,
                             e = t.container && t.container();
                         return e ? [e.clientWidth, e.clientHeight] : [void 0, void 0]
                     },
                     windowSize: function() {
-                        const t = fC();
+                        const t = YR();
                         return t ? [t.innerWidth, t.innerHeight] : [void 0, void 0]
                     },
                     bandspace: function(t, e, n) {
-                        return Mu(t || 0, e || 0, n || 0)
+                        return Qu(t || 0, e || 0, n || 0)
                     },
                     setdata: function(t, e) {
                         const n = this.context.dataflow,
                             i = this.context.data[t].input;
                         return n.pulse(i, n.changeset().remove(m.yb).insert(e)), 1
                     },
                     pathShape: function(t) {
                         let e = null;
                         return function(n) {
-                            return n ? vd(n, e = e || ad(t)) : t
+                            return n ? Pd(n, e = e || Ad(t)) : t
                         }
                     },
                     panLinear: m.Dw,
                     panLog: m.mJ,
                     panPow: m.QA,
                     panSymlog: m.Zw,
                     zoomLinear: m.ay,
@@ -38502,15 +41876,15 @@
                             s = this.context.data[t],
                             c = s.input,
                             l = a.stamp();
                         let u, f, d = s.changes;
                         if (!1 === a._trigger || !(c.value.length || e || i)) return 0;
                         if ((!d || d.stamp < l) && (s.changes = d = a.changeset(), d.stamp = l, a.runAfter((() => {
                                 s.modified = !0, a.pulse(c, d).run()
-                            }), !0, 1)), n && (u = !0 === n ? m.yb : (0, m.kJ)(n) || er(n) ? n : oC(n), d.remove(u)), e && d.insert(e), i && (u = oC(i), c.value.some(u) ? d.remove(u) : d.insert(i)), r)
+                            }), !0, 1)), n && (u = !0 === n ? m.yb : (0, m.kJ)(n) || er(n) ? n : HR(n), d.remove(u)), e && d.insert(e), i && (u = HR(i), c.value.some(u) ? d.remove(u) : d.insert(i)), r)
                             for (f in o) d.modify(r, f, o[f]);
                         return 1
                     },
                     lassoAppend: function(t, e, n) {
                         let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5;
                         const r = (t = (0, m.IX)(t))[t.length - 1];
                         return void 0 === r || Math.hypot(r[0] - e, r[1] - n) > i ? [...t, [e, n]] : t
@@ -38522,209 +41896,180 @@
                         }), "")
                     },
                     intersectLasso: function(t, e, n) {
                         const {
                             x: i,
                             y: r,
                             mark: o
-                        } = n, a = (new $d).set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
+                        } = n, a = (new uh).set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
                         for (const [s, c] of e) s < a.x1 && (a.x1 = s), s > a.x2 && (a.x2 = s), c < a.y1 && (a.y1 = c), c > a.y2 && (a.y2 = c);
-                        return a.translate(i, r), dC([
+                        return a.translate(i, r), VR([
                             [a.x1, a.y1],
                             [a.x2, a.y2]
                         ], t, o).filter((t => function(t, e, n) {
                             let i = 0;
                             for (let r = 0, o = n.length - 1; r < n.length; o = r++) {
                                 const [a, s] = n[o], [c, l] = n[r];
                                 l > e != s > e && t < (a - c) * (e - l) / (s - l) + c && i++
                             }
                             return 1 & i
                         }(t.x, t.y, e)))
                     }
                 },
-                pC = ["view", "item", "group", "xy", "x", "y"],
-                mC = "this.",
-                gC = {},
-                vC = {
+                QR = ["view", "item", "group", "xy", "x", "y"],
+                tz = "this.",
+                ez = {},
+                nz = {
                     forbidden: ["_"],
                     allowed: ["datum", "event", "item"],
                     fieldvar: "datum",
-                    globalvar: t => "_[".concat((0, m.m8)(HS + t), "]"),
+                    globalvar: t => "_[".concat((0, m.m8)("$" + t), "]"),
                     functions: function(t) {
-                        const e = (0, EA.wk)(t);
-                        pC.forEach((t => e[t] = "event.vega." + t));
-                        for (const n in hC) e[n] = mC + n;
-                        return (0, m.l7)(e, ZS(t, hC, gC)), e
+                        const e = (0, sN.wk)(t);
+                        QR.forEach((t => e[t] = "event.vega." + t));
+                        for (const n in KR) e[n] = tz + n;
+                        return (0, m.l7)(e, RR(t, KR, ez)), e
                     },
-                    constants: EA._G,
-                    visitors: gC
+                    constants: sN._G,
+                    visitors: ez
                 },
-                yC = (0, EA.YP)(vC);
+                iz = (0, sN.YP)(nz);
 
-            function bC(t, e, n) {
-                return 1 === arguments.length ? hC[t] : (hC[t] = e, n && (gC[t] = n), yC && (yC.functions[t] = mC + t), this)
+            function rz(t, e, n) {
+                return 1 === arguments.length ? KR[t] : (KR[t] = e, n && (ez[t] = n), iz && (iz.functions[t] = tz + t), this)
             }
-
-            function xC(t, e) {
-                const n = {};
-                let i;
-                try {
-                    t = (0, m.HD)(t) ? t : (0, m.m8)(t) + "", i = (0, EA.BJ)(t)
-                } catch (o) {
-                    (0, m.vU)("Expression parse error: " + t)
-                }
-                i.visit((t => {
-                    if (t.type !== EA.Lt) return;
-                    const i = t.callee.name,
-                        r = vC.visitors[i];
-                    r && r(i, t.arguments, e, n)
-                }));
-                const r = yC(i);
-                return r.globals.forEach((t => {
-                    const i = HS + t;
-                    !(0, m.nr)(n, i) && e.getSignal(t) && (n[i] = e.signalRef(t))
-                })), {
-                    $expr: (0, m.l7)({
-                        code: r.code
-                    }, e.options.ast ? {
-                        ast: i
-                    } : null),
-                    $fields: r.fields,
-                    $params: n
-                }
-            }
-            bC("bandwidth", (function(t, e) {
-                const n = $S(t, (e || this).context);
+            rz("bandwidth", (function(t, e) {
+                const n = NR(t, (e || this).context);
                 return n && n.bandwidth ? n.bandwidth() : 0
-            }), JS), bC("copy", (function(t, e) {
-                const n = $S(t, (e || this).context);
+            }), OR), rz("copy", (function(t, e) {
+                const n = NR(t, (e || this).context);
                 return n ? n.copy() : void 0
-            }), JS), bC("domain", (function(t, e) {
-                const n = $S(t, (e || this).context);
+            }), OR), rz("domain", (function(t, e) {
+                const n = NR(t, (e || this).context);
                 return n ? n.domain() : []
-            }), JS), bC("range", (function(t, e) {
-                const n = $S(t, (e || this).context);
+            }), OR), rz("range", (function(t, e) {
+                const n = NR(t, (e || this).context);
                 return n && n.range ? n.range() : []
-            }), JS), bC("invert", (function(t, e, n) {
-                const i = $S(t, (n || this).context);
+            }), OR), rz("invert", (function(t, e, n) {
+                const i = NR(t, (n || this).context);
                 return i ? (0, m.kJ)(e) ? (i.invertRange || i.invert)(e) : (i.invert || i.invertExtent)(e) : void 0
-            }), JS), bC("scale", (function(t, e, n) {
-                const i = $S(t, (n || this).context);
+            }), OR), rz("scale", (function(t, e, n) {
+                const i = NR(t, (n || this).context);
                 return i ? i(e) : void 0
-            }), JS), bC("gradient", (function(t, e, n, i, r) {
-                t = $S(t, (r || this).context);
-                const o = Kf(e, n);
+            }), OR), rz("gradient", (function(t, e, n, i, r) {
+                t = NR(t, (r || this).context);
+                const o = vd(e, n);
                 let a = t.domain(),
                     s = a[0],
                     c = (0, m.fj)(a),
                     l = m.yR;
-                return c - s ? l = bf(t, s, c) : t = (t.interpolator ? af("sequential")().interpolator(t.interpolator()) : af("linear")().interpolate(t.interpolate()).range(t.range())).domain([s = 0, c = 1]), t.ticks && (a = t.ticks(+i || 15), s !== a[0] && a.unshift(s), c !== (0, m.fj)(a) && a.push(c)), a.forEach((e => o.stop(l(e), t(e)))), o
-            }), JS), bC("geoArea", VS, JS), bC("geoBounds", KS, JS), bC("geoCentroid", QS, JS), bC("geoShape", (function(t, e, n) {
-                const i = $S(t, (n || this).context);
+                return c - s ? l = Bf(t, s, c) : t = (t.interpolator ? Ff("sequential")().interpolator(t.interpolator()) : Ff("linear")().interpolate(t.interpolate()).range(t.range())).domain([s = 0, c = 1]), t.ticks && (a = t.ticks(+i || 15), s !== a[0] && a.unshift(s), c !== (0, m.fj)(a) && a.push(c)), a.forEach((e => o.stop(l(e), t(e)))), o
+            }), OR), rz("geoArea", PR, OR), rz("geoBounds", LR, OR), rz("geoCentroid", BR, OR), rz("geoShape", (function(t, e, n) {
+                const i = NR(t, (n || this).context);
                 return function(t) {
                     return i ? i.path.context(t)(e) : ""
                 }
-            }), JS), bC("indata", (function(t, e, n) {
+            }), OR), rz("indata", (function(t, e, n) {
                 const i = this.context.data[t]["index:" + e],
                     r = i ? i.value.get(n) : void 0;
                 return r ? r.count : r
             }), (function(t, e, n, i) {
-                e[0].type !== EA.t$ && (0, m.vU)("First argument to indata must be a string literal."), e[1].type !== EA.t$ && (0, m.vU)("Second argument to indata must be a string literal.");
+                e[0].type !== sN.t$ && (0, m.vU)("First argument to indata must be a string literal."), e[1].type !== sN.t$ && (0, m.vU)("Second argument to indata must be a string literal.");
                 const r = e[0].value,
                     o = e[1].value,
                     a = "@" + o;
                 (0, m.nr)(a, i) || (i[a] = n.getData(r).indataRef(n, o))
-            })), bC("data", zS, XS), bC("treePath", (function(t, e, n) {
-                const i = uC(t, this),
+            })), rz("data", xR, FR), rz("treePath", (function(t, e, n) {
+                const i = $R(t, this),
                     r = i[e],
                     o = i[n];
-                return r && o ? r.path(o).map(lC) : void 0
-            }), XS), bC("treeAncestors", (function(t, e) {
-                const n = uC(t, this)[e];
-                return n ? n.ancestors().map(lC) : void 0
-            }), XS), bC("vlSelectionTest", (function(t, e, n) {
-                for (var i, r, o, a, s, c = this.context.data[t], l = c ? c.values.value : [], u = c ? c[SS] && c[SS].value : void 0, f = n === yS, d = l.length, h = 0; h < d; ++h)
+                return r && o ? r.path(o).map(ZR) : void 0
+            }), FR), rz("treeAncestors", (function(t, e) {
+                const n = $R(t, this)[e];
+                return n ? n.ancestors().map(ZR) : void 0
+            }), FR), rz("vlSelectionTest", (function(t, e, n) {
+                for (var i, r, o, a, s, c = this.context.data[t], l = c ? c.values.value : [], u = c ? c[hR] && c[hR].value : void 0, f = n === rR, d = l.length, h = 0; h < d; ++h)
                     if (i = l[h], u && f) {
                         if (-1 === (o = (r = r || {})[a = i.unit] || 0)) continue;
-                        if (s = CS(e, i), r[a] = s ? -1 : ++o, s && 1 === u.size) return !0;
+                        if (s = pR(e, i), r[a] = s ? -1 : ++o, s && 1 === u.size) return !0;
                         if (!s && o === u.get(a).count) return !1
-                    } else if (f ^ (s = CS(e, i))) return s;
+                    } else if (f ^ (s = pR(e, i))) return s;
                 return d && f
-            }), NS), bC("vlSelectionIdTest", (function(t, e, n) {
+            }), bR), rz("vlSelectionIdTest", (function(t, e, n) {
                 const i = this.context.data[t],
                     r = i ? i.values.value : [],
-                    o = i ? i[SS] && i[SS].value : void 0,
-                    a = n === yS,
-                    s = _S(e),
-                    c = MS(r, s);
+                    o = i ? i[hR] && i[hR].value : void 0,
+                    a = n === rR,
+                    s = sR(e),
+                    c = gR(r, s);
                 if (c === r.length) return !1;
-                if (_S(r[c]) !== s) return !1;
+                if (sR(r[c]) !== s) return !1;
                 if (o && a) {
                     if (1 === o.size) return !0;
-                    if (OS(r, s) - c < o.size) return !1
+                    if (vR(r, s) - c < o.size) return !1
                 }
                 return !0
-            }), NS), bC("vlSelectionResolve", (function(t, e, n, i) {
+            }), bR), rz("vlSelectionResolve", (function(t, e, n, i) {
                 for (var r, o, a, s, c, l, u, f, d, h, p, g, v = this.context.data[t], y = v ? v.values.value : [], b = {}, x = {}, _ = {}, w = y.length, k = 0; k < w; ++k)
                     if (s = (r = y[k]).unit, o = r.fields, a = r.values, o && a) {
-                        for (p = 0, g = o.length; p < g; ++p) c = o[p], f = (u = b[c.field] || (b[c.field] = {}))[s] || (u[s] = []), _[c.field] = d = c.type.charAt(0), h = TS["".concat(d, "_union")], u[s] = h(f, (0, m.IX)(a[p]));
+                        for (p = 0, g = o.length; p < g; ++p) c = o[p], f = (u = b[c.field] || (b[c.field] = {}))[s] || (u[s] = []), _[c.field] = d = c.type.charAt(0), h = yR["".concat(d, "_union")], u[s] = h(f, (0, m.IX)(a[p]));
                         n && (f = x[s] || (x[s] = [])).push((0, m.IX)(a).reduce(((t, e, n) => (t[o[n].field] = e, t)), {}))
-                    } else c = xS, l = _S(r), (f = (u = b[c] || (b[c] = {}))[s] || (u[s] = [])).push(l), n && (f = x[s] || (x[s] = [])).push({
-                        [xS]: l
+                    } else c = aR, l = sR(r), (f = (u = b[c] || (b[c] = {}))[s] || (u[s] = [])).push(l), n && (f = x[s] || (x[s] = [])).push({
+                        [aR]: l
                     });
-                if (e = e || bS, b[xS] ? b[xS] = TS["".concat(xS, "_").concat(e)](...Object.values(b[xS])) : Object.keys(b).forEach((t => {
-                        b[t] = Object.keys(b[t]).map((e => b[t][e])).reduce(((n, i) => void 0 === n ? i : TS["".concat(_[t], "_").concat(e)](n, i)))
+                if (e = e || oR, b[aR] ? b[aR] = yR["".concat(aR, "_").concat(e)](...Object.values(b[aR])) : Object.keys(b).forEach((t => {
+                        b[t] = Object.keys(b[t]).map((e => b[t][e])).reduce(((n, i) => void 0 === n ? i : yR["".concat(_[t], "_").concat(e)](n, i)))
                     })), y = Object.keys(x), n && y.length) {
-                    b[i ? "vlPoint" : "vlMulti"] = e === bS ? {
+                    b[i ? "vlPoint" : "vlMulti"] = e === oR ? {
                         or: y.reduce(((t, e) => (t.push(...x[e]), t)), [])
                     } : {
                         and: y.map((t => ({
                             or: x[t]
                         })))
                     }
                 }
                 return b
-            }), NS), bC("vlSelectionTuples", (function(t, e) {
+            }), bR), rz("vlSelectionTuples", (function(t, e) {
                 return t.map((t => (0, m.l7)(e.fields ? {
                     values: e.fields.map((e => (e.getter || (e.getter = (0, m.EP)(e.field)))(t.datum)))
                 } : {
-                    [xS]: _S(t.datum)
+                    [aR]: sR(t.datum)
                 }, e)))
             }));
-            const _C = (0, m.Rg)(["rule"]),
-                wC = (0, m.Rg)(["group", "image", "rect"]);
+            const oz = (0, m.Rg)(["rule"]),
+                az = (0, m.Rg)(["group", "image", "rect"]);
 
-            function kC(t) {
+            function sz(t) {
                 return (t + "").toLowerCase()
             }
 
-            function EC(t, e, n) {
+            function cz(t, e, n) {
                 n.endsWith(";") || (n = "return(" + n + ");");
                 const i = Function(...e.concat(n));
                 return t && t.functions ? i.bind(t.functions) : i
             }
-            var DC = {
-                operator: (t, e) => EC(t, ["_"], e.code),
-                parameter: (t, e) => EC(t, ["datum", "_"], e.code),
-                event: (t, e) => EC(t, ["event"], e.code),
-                handler: (t, e) => EC(t, ["_", "event"], "var datum=event.item&&event.item.datum;return ".concat(e.code, ";")),
+            var lz = {
+                operator: (t, e) => cz(t, ["_"], e.code),
+                parameter: (t, e) => cz(t, ["datum", "_"], e.code),
+                event: (t, e) => cz(t, ["event"], e.code),
+                handler: (t, e) => cz(t, ["_", "event"], "var datum=event.item&&event.item.datum;return ".concat(e.code, ";")),
                 encode: (t, e) => {
                     const {
                         marktype: n,
                         channels: i
                     } = e;
                     let r = "var o=item,datum=o.datum,m=0,$;";
                     for (const o in i) {
                         const t = "o[" + (0, m.m8)(o) + "]";
                         r += "$=".concat(i[o].code, ";if(").concat(t, "!==$)").concat(t, "=$,m=1;")
                     }
                     return r += function(t, e) {
                         let n = "";
-                        return _C[e] || (t.x2 && (t.x ? (wC[e] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), t.xc && (n += "o.x=o.xc-(o.width||0)/2;"), t.y2 && (t.y ? (wC[e] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), t.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n
-                    }(i, n), r += "return m;", EC(t, ["item", "_"], r)
+                        return oz[e] || (t.x2 && (t.x ? (az[e] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), t.xc && (n += "o.x=o.xc-(o.width||0)/2;"), t.y2 && (t.y ? (az[e] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), t.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n
+                    }(i, n), r += "return m;", cz(t, ["item", "_"], r)
                 },
                 codegen: {
                     get(t) {
                         const e = "[".concat(t.map(m.m8).join("]["), "]"),
                             n = Function("_", "return _".concat(e, ";"));
                         return n.path = e, n
                     },
@@ -38739,21 +42084,21 @@
                                 }(o, a, -r, r)
                         })).join("") + "0;");
                         return n ? i.bind(n) : i
                     }
                 }
             };
 
-            function AC(t, e, n) {
+            function uz(t, e, n) {
                 if (!t || !(0, m.Kn)(t)) return t;
-                for (let i, r = 0, o = SC.length; r < o; ++r)
-                    if (i = SC[r], (0, m.nr)(t, i.key)) return i.parse(t, e, n);
+                for (let i, r = 0, o = fz.length; r < o; ++r)
+                    if (i = fz[r], (0, m.nr)(t, i.key)) return i.parse(t, e, n);
                 return t
             }
-            var SC = [{
+            var fz = [{
                 key: "$ref",
                 parse: function(t, e) {
                     return e.get(t.$ref) || (0, m.vU)("Operator not defined: " + t.$ref)
                 }
             }, {
                 key: "$key",
                 parse: function(t, e) {
@@ -38810,36 +42155,36 @@
                 }
             }, {
                 key: "$tupleid",
                 parse: function() {
                     return nr
                 }
             }];
-            const CC = {
+            const dz = {
                 skip: !0
             };
 
-            function FC(t, e, n, i) {
-                return new MC(t, e, n, i)
+            function hz(t, e, n, i) {
+                return new pz(t, e, n, i)
             }
 
-            function MC(t, e, n, i) {
-                this.dataflow = t, this.transforms = e, this.events = t.events.bind(t), this.expr = i || DC, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this)
+            function pz(t, e, n, i) {
+                this.dataflow = t, this.transforms = e, this.events = t.events.bind(t), this.expr = i || lz, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this)
             }
 
-            function OC(t) {
+            function mz(t) {
                 this.dataflow = t.dataflow, this.transforms = t.transforms, this.events = t.events, this.expr = t.expr, this.signals = Object.create(t.signals), this.scales = Object.create(t.scales), this.nodes = Object.create(t.nodes), this.data = Object.create(t.data), this.fn = Object.create(t.fn), t.functions && (this.functions = Object.create(t.functions), this.functions.context = this)
             }
 
-            function TC(t, e) {
+            function gz(t, e) {
                 t && (null == e ? t.removeAttribute("aria-label") : t.setAttribute("aria-label", e))
             }
-            MC.prototype = OC.prototype = {
+            pz.prototype = mz.prototype = {
                 fork() {
-                    const t = new OC(this);
+                    const t = new mz(this);
                     return (this.subcontext || (this.subcontext = [])).push(t), t
                 },
                 detach(t) {
                     this.subcontext = this.subcontext.filter((e => e !== t));
                     const e = Object.keys(t.nodes);
                     for (const n of e) t.nodes[n]._targets = null;
                     for (const n of e) t.nodes[n].detach();
@@ -38852,15 +42197,15 @@
                     return this.nodes[t] = e
                 },
                 add(t, e) {
                     const n = this,
                         i = n.dataflow,
                         r = t.value;
                     if (n.set(t.id, e), function(t) {
-                            return "collect" === kC(t)
+                            return "collect" === sz(t)
                         }(t.type) && r && (r.$ingest ? i.ingest(e, r.$ingest, r.$format) : r.$request ? i.preload(e, r.$request, r.$format) : i.pulse(e, i.changeset().insert(r))), t.root && (n.root = e), t.parent) {
                         let r = n.get(t.parent.$ref);
                         r ? (i.connect(r, [e]), e.targets().add(r)) : (n.unresolved = n.unresolved || []).push((() => {
                             r = n.get(t.parent.$ref), i.connect(r, [e]), e.targets().add(r)
                         }))
                     }
                     if (t.signal && (n.signals[t.signal] = e), t.scale && (n.scales[t.scale] = e), t.data)
@@ -38872,15 +42217,15 @@
                 resolve() {
                     return (this.unresolved || []).forEach((t => t())), delete this.unresolved, this
                 },
                 operator(t, e) {
                     this.add(t, this.dataflow.add(t.value, e))
                 },
                 transform(t, e) {
-                    this.add(t, this.dataflow.add(this.transforms[kC(e)]))
+                    this.add(t, this.dataflow.add(this.transforms[sz(e)]))
                 },
                 stream(t, e) {
                     this.set(t.id, e)
                 },
                 update(t, e, n, i, r) {
                     this.dataflow.on(e, n, i, r, t.options)
                 },
@@ -38903,30 +42248,30 @@
                     const e = this,
                         n = t.operators || [];
                     return t.background && (e.background = t.background), t.eventConfig && (e.eventConfig = t.eventConfig), t.locale && (e.locale = t.locale), n.forEach((t => e.parseOperator(t))), n.forEach((t => e.parseOperatorParameters(t))), (t.streams || []).forEach((t => e.parseStream(t))), (t.updates || []).forEach((t => e.parseUpdate(t))), e.resolve()
                 },
                 parseOperator: function(t) {
                     const e = this;
                     ! function(t) {
-                        return "operator" === kC(t)
+                        return "operator" === sz(t)
                     }(t.type) && t.type ? e.transform(t, t.type) : e.operator(t, t.update ? e.operatorExpression(t.update) : null)
                 },
                 parseOperatorParameters: function(t) {
                     const e = this;
                     if (t.params) {
                         const n = e.get(t.id);
                         n || (0, m.vU)("Invalid operator id: " + t.id), e.dataflow.connect(n, n.parameters(e.parseParameters(t.params), t.react, t.initonly))
                     }
                 },
                 parseParameters: function(t, e) {
                     e = e || {};
                     const n = this;
                     for (const i in t) {
                         const r = t[i];
-                        e[i] = (0, m.kJ)(r) ? r.map((t => AC(t, n, e))) : AC(r, n, e)
+                        e[i] = (0, m.kJ)(r) ? r.map((t => uz(t, n, e))) : uz(r, n, e)
                     }
                     return e
                 },
                 parseStream: function(t) {
                     var e, n = this,
                         i = null != t.filter ? n.eventExpression(t.filter) : void 0,
                         r = null != t.stream ? n.get(t.stream) : void 0;
@@ -38961,61 +42306,61 @@
                 },
                 setState: function(t) {
                     var e = this,
                         n = e.dataflow,
                         i = t.data,
                         r = t.signals;
                     Object.keys(r || {}).forEach((t => {
-                        n.update(e.signals[t], r[t], CC)
+                        n.update(e.signals[t], r[t], dz)
                     })), Object.keys(i || {}).forEach((t => {
                         n.pulse(e.data[t].input, n.changeset().remove(m.yb).insert(i[t]))
                     })), (t.subcontext || []).forEach(((t, n) => {
                         const i = e.subcontext[n];
                         i && i.setState(t)
                     }))
                 }
             };
-            const NC = "default";
+            const vz = "default";
 
-            function zC(t, e) {
+            function yz(t, e) {
                 const n = t.globalCursor() ? "undefined" !== typeof document && document.body : t.container();
                 if (n) return null == e ? n.style.removeProperty("cursor") : n.style.cursor = e
             }
 
-            function RC(t, e) {
+            function bz(t, e) {
                 var n = t._runtime.data;
                 return (0, m.nr)(n, e) || (0, m.vU)("Unrecognized data set: " + e), n[e]
             }
 
-            function PC(t, e) {
+            function xz(t, e) {
                 lr(e) || (0, m.vU)("Second argument to changes must be a changeset.");
-                const n = RC(this, t);
+                const n = bz(this, t);
                 return n.modified = !0, this.pulse(n.input, e)
             }
 
-            function LC(t) {
+            function _z(t) {
                 var e = t.padding();
                 return Math.max(0, t._viewWidth + e.left + e.right)
             }
 
-            function jC(t) {
+            function wz(t) {
                 var e = t.padding();
                 return Math.max(0, t._viewHeight + e.top + e.bottom)
             }
 
-            function BC(t) {
+            function kz(t) {
                 var e = t.padding(),
                     n = t._origin;
                 return [e.left + n[0], e.top + n[1]]
             }
 
-            function IC(t, e, n) {
+            function Ez(t, e, n) {
                 var i, r, o = t._renderer,
                     a = o && o.canvas();
-                return a && (r = BC(t), (i = am(e.changedTouches ? e.changedTouches[0] : e, a))[0] -= r[0], i[1] -= r[1]), e.dataflow = t, e.item = n, e.vega = function(t, e, n) {
+                return a && (r = kz(t), (i = bm(e.changedTouches ? e.changedTouches[0] : e, a))[0] -= r[0], i[1] -= r[1]), e.dataflow = t, e.item = n, e.vega = function(t, e, n) {
                     const i = e ? "group" === e.mark.marktype ? e : e.mark.group : null;
 
                     function r(t) {
                         var n, r = i;
                         if (t)
                             for (n = e; n; n = n.mark.group)
                                 if (n.mark.name === t) {
@@ -39037,310 +42382,310 @@
                         group: r,
                         xy: o,
                         x: t => o(t)[0],
                         y: t => o(t)[1]
                     }
                 }(t, n, i), e
             }
-            const UC = "view",
-                qC = {
+            const Az = "view",
+                Dz = {
                     trap: !1
                 };
 
-            function WC(t, e, n, i) {
+            function Sz(t, e, n, i) {
                 t._eventListeners.push({
                     type: n,
                     sources: (0, m.IX)(e),
                     handler: i
                 })
             }
 
-            function HC(t, e, n) {
+            function Cz(t, e, n) {
                 const i = t._eventConfig && t._eventConfig[e];
                 return !(!1 === i || (0, m.Kn)(i) && !i[n]) || (t.warn("Blocked ".concat(e, " ").concat(n, " event listener.")), !1)
             }
 
-            function XC(t) {
+            function Mz(t) {
                 return t.item
             }
 
-            function JC(t) {
+            function Fz(t) {
                 return t.item.mark.source
             }
 
-            function GC(t) {
+            function Oz(t) {
                 return function(e, n) {
                     return n.vega.view().changeset().encode(n.item, t)
                 }
             }
 
-            function $C(t, e, n) {
+            function Tz(t, e, n) {
                 const i = document.createElement(t);
                 for (const r in e) i.setAttribute(r, e[r]);
                 return null != n && (i.textContent = n), i
             }
-            const ZC = "vega-bind",
-                YC = "vega-bind-name",
-                VC = "vega-bind-radio";
+            const Nz = "vega-bind",
+                Rz = "vega-bind-name",
+                zz = "vega-bind-radio";
 
-            function KC(t, e, n, i) {
+            function Pz(t, e, n, i) {
                 const r = n.event || "input",
                     o = () => t.update(e.value);
-                i.signal(n.signal, e.value), e.addEventListener(r, o), WC(i, e, r, o), t.set = t => {
+                i.signal(n.signal, e.value), e.addEventListener(r, o), Sz(i, e, r, o), t.set = t => {
                     e.value = t, e.dispatchEvent(function(t) {
                         return "undefined" !== typeof Event ? new Event(t) : {
                             type: t
                         }
                     }(r))
                 }
             }
 
-            function QC(t, e, n, i) {
+            function Lz(t, e, n, i) {
                 const r = i.signal(n.signal),
-                    o = $C("div", {
-                        class: ZC
+                    o = Tz("div", {
+                        class: Nz
                     }),
-                    a = "radio" === n.input ? o : o.appendChild($C("label"));
-                a.appendChild($C("span", {
-                    class: YC
+                    a = "radio" === n.input ? o : o.appendChild(Tz("label"));
+                a.appendChild(Tz("span", {
+                    class: Rz
                 }, n.name || n.signal)), e.appendChild(o);
-                let s = tF;
+                let s = Bz;
                 switch (n.input) {
                     case "checkbox":
-                        s = eF;
+                        s = Iz;
                         break;
                     case "select":
-                        s = nF;
+                        s = jz;
                         break;
                     case "radio":
-                        s = iF;
+                        s = Uz;
                         break;
                     case "range":
-                        s = rF
+                        s = qz
                 }
                 s(t, a, n, r)
             }
 
-            function tF(t, e, n, i) {
-                const r = $C("input");
+            function Bz(t, e, n, i) {
+                const r = Tz("input");
                 for (const o in n) "signal" !== o && "element" !== o && r.setAttribute("input" === o ? "type" : o, n[o]);
                 r.setAttribute("name", n.signal), r.value = i, e.appendChild(r), r.addEventListener("input", (() => t.update(r.value))), t.elements = [r], t.set = t => r.value = t
             }
 
-            function eF(t, e, n, i) {
+            function Iz(t, e, n, i) {
                 const r = {
                     type: "checkbox",
                     name: n.signal
                 };
                 i && (r.checked = !0);
-                const o = $C("input", r);
+                const o = Tz("input", r);
                 e.appendChild(o), o.addEventListener("change", (() => t.update(o.checked))), t.elements = [o], t.set = t => o.checked = !!t || null
             }
 
-            function nF(t, e, n, i) {
-                const r = $C("select", {
+            function jz(t, e, n, i) {
+                const r = Tz("select", {
                         name: n.signal
                     }),
                     o = n.labels || [];
                 n.options.forEach(((t, e) => {
                     const n = {
                         value: t
                     };
-                    oF(t, i) && (n.selected = !0), r.appendChild($C("option", n, (o[e] || t) + ""))
+                    Wz(t, i) && (n.selected = !0), r.appendChild(Tz("option", n, (o[e] || t) + ""))
                 })), e.appendChild(r), r.addEventListener("change", (() => {
                     t.update(n.options[r.selectedIndex])
                 })), t.elements = [r], t.set = t => {
                     for (let e = 0, i = n.options.length; e < i; ++e)
-                        if (oF(n.options[e], t)) return void(r.selectedIndex = e)
+                        if (Wz(n.options[e], t)) return void(r.selectedIndex = e)
                 }
             }
 
-            function iF(t, e, n, i) {
-                const r = $C("span", {
-                        class: VC
+            function Uz(t, e, n, i) {
+                const r = Tz("span", {
+                        class: zz
                     }),
                     o = n.labels || [];
                 e.appendChild(r), t.elements = n.options.map(((e, a) => {
                     const s = {
                         type: "radio",
                         name: n.signal,
                         value: e
                     };
-                    oF(e, i) && (s.checked = !0);
-                    const c = $C("input", s);
+                    Wz(e, i) && (s.checked = !0);
+                    const c = Tz("input", s);
                     c.addEventListener("change", (() => t.update(e)));
-                    const l = $C("label", {}, (o[a] || e) + "");
+                    const l = Tz("label", {}, (o[a] || e) + "");
                     return l.prepend(c), r.appendChild(l), c
                 })), t.set = e => {
                     const n = t.elements,
                         i = n.length;
-                    for (let t = 0; t < i; ++t) oF(n[t].value, e) && (n[t].checked = !0)
+                    for (let t = 0; t < i; ++t) Wz(n[t].value, e) && (n[t].checked = !0)
                 }
             }
 
-            function rF(t, e, n, i) {
+            function qz(t, e, n, i) {
                 i = void 0 !== i ? i : (+n.max + +n.min) / 2;
                 const r = null != n.max ? n.max : Math.max(100, +i) || 100,
                     o = n.min || Math.min(0, r, +i) || 0,
                     a = n.step || (0, N.ly)(o, r, 100),
-                    s = $C("input", {
+                    s = Tz("input", {
                         type: "range",
                         name: n.signal,
                         min: o,
                         max: r,
                         step: a
                     });
                 s.value = i;
-                const c = $C("span", {}, +i);
+                const c = Tz("span", {}, +i);
                 e.appendChild(s), e.appendChild(c);
                 const l = () => {
                     c.textContent = s.value, t.update(+s.value)
                 };
                 s.addEventListener("input", l), s.addEventListener("change", l), t.elements = [s], t.set = t => {
                     s.value = t, c.textContent = t
                 }
             }
 
-            function oF(t, e) {
+            function Wz(t, e) {
                 return t === e || t + "" === e + ""
             }
 
-            function aF(t, e, n, i, r, o) {
-                return (e = e || new i(t.loader())).initialize(n, LC(t), jC(t), BC(t), r, o).background(t.background())
+            function Hz(t, e, n, i, r, o) {
+                return (e = e || new i(t.loader())).initialize(n, _z(t), wz(t), kz(t), r, o).background(t.background())
             }
 
-            function sF(t, e) {
+            function Xz(t, e) {
                 return e ? function() {
                     try {
                         e.apply(this, arguments)
                     } catch (n) {
                         t.error(n)
                     }
                 } : null
             }
 
-            function cF(t, e, n) {
+            function Gz(t, e, n) {
                 if ("string" === typeof e) {
                     if ("undefined" === typeof document) return t.error("DOM document instance not found."), null;
                     if (!(e = document.querySelector(e))) return t.error("Signal bind element not found: " + e), null
                 }
                 if (e && n) try {
                     e.textContent = ""
                 } catch (i) {
                     e = null, t.error(i)
                 }
                 return e
             }
-            const lF = t => +t || 0;
+            const Jz = t => +t || 0;
 
-            function uF(t) {
+            function Zz(t) {
                 return (0, m.Kn)(t) ? {
-                    top: lF(t.top),
-                    bottom: lF(t.bottom),
-                    left: lF(t.left),
-                    right: lF(t.right)
+                    top: Jz(t.top),
+                    bottom: Jz(t.bottom),
+                    left: Jz(t.left),
+                    right: Jz(t.right)
                 } : (t => ({
                     top: t,
                     bottom: t,
                     left: t,
                     right: t
-                }))(lF(t))
+                }))(Jz(t))
             }
-            async function fF(t, e, n, i) {
-                const r = Eg(e),
+            async function $z(t, e, n, i) {
+                const r = Pg(e),
                     o = r && r.headless;
-                return o || (0, m.vU)("Unrecognized renderer type: " + e), await t.runAsync(), aF(t, null, null, o, n, i).renderAsync(t._scenegraph.root)
+                return o || (0, m.vU)("Unrecognized renderer type: " + e), await t.runAsync(), Hz(t, null, null, o, n, i).renderAsync(t._scenegraph.root)
             }
-            var dF = "width",
-                hF = "height",
-                pF = "padding",
-                mF = {
+            var Yz = "width",
+                Vz = "height",
+                Kz = "padding",
+                Qz = {
                     skip: !0
                 };
 
-            function gF(t, e) {
+            function tP(t, e) {
                 var n = t.autosize(),
                     i = t.padding();
-                return e - (n && n.contains === pF ? i.left + i.right : 0)
+                return e - (n && n.contains === Kz ? i.left + i.right : 0)
             }
 
-            function vF(t, e) {
+            function eP(t, e) {
                 var n = t.autosize(),
                     i = t.padding();
-                return e - (n && n.contains === pF ? i.top + i.bottom : 0)
+                return e - (n && n.contains === Kz ? i.top + i.bottom : 0)
             }
 
-            function yF(t, e) {
-                return e.modified && (0, m.kJ)(e.input.value) && t.indexOf("_:vega:_")
+            function nP(t, e) {
+                return e.modified && (0, m.kJ)(e.input.value) && !t.startsWith("_:vega:_")
             }
 
-            function bF(t, e) {
+            function iP(t, e) {
                 return !("parent" === t || e instanceof Pr.proxy)
             }
 
-            function xF(t, e, n, i) {
+            function rP(t, e, n, i) {
                 const r = t.element();
                 r && r.setAttribute("title", function(t) {
-                    return null == t ? "" : (0, m.kJ)(t) ? _F(t) : (0, m.Kn)(t) && !(0, m.J_)(t) ? (e = t, Object.keys(e).map((t => {
+                    return null == t ? "" : (0, m.kJ)(t) ? oP(t) : (0, m.Kn)(t) && !(0, m.J_)(t) ? (e = t, Object.keys(e).map((t => {
                         const n = e[t];
-                        return t + ": " + ((0, m.kJ)(n) ? _F(n) : wF(n))
+                        return t + ": " + ((0, m.kJ)(n) ? oP(n) : aP(n))
                     })).join("\n")) : t + "";
                     var e
                 }(i))
             }
 
-            function _F(t) {
-                return "[" + t.map(wF).join(", ") + "]"
+            function oP(t) {
+                return "[" + t.map(aP).join(", ") + "]"
             }
 
-            function wF(t) {
+            function aP(t) {
                 return (0, m.kJ)(t) ? "[\u2026]" : (0, m.Kn)(t) && !(0, m.J_)(t) ? "{\u2026}" : t
             }
 
-            function kF(t, e) {
+            function sP(t, e) {
                 const n = this;
                 if (e = e || {}, Nr.call(n), e.loader && n.loader(e.loader), e.logger && n.logger(e.logger), null != e.logLevel && n.logLevel(e.logLevel), e.locale || t.locale) {
                     const i = (0, m.l7)({}, t.locale, e.locale);
                     n.locale(_i(i.number, i.time))
                 }
-                n._el = null, n._elBind = null, n._renderType = e.renderer || wg.Canvas, n._scenegraph = new Qp;
+                n._el = null, n._elBind = null, n._renderType = e.renderer || Rg.Canvas, n._scenegraph = new dm;
                 const i = n._scenegraph.root;
-                n._renderer = null, n._tooltip = e.tooltip || xF, n._redraw = !0, n._handler = (new Am).scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = function(t) {
+                n._renderer = null, n._tooltip = e.tooltip || rP, n._redraw = !0, n._handler = (new Im).scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = function(t) {
                     const e = (0, m.l7)({
                             defaults: {}
                         }, t),
                         n = (t, e) => {
                             e.forEach((e => {
                                 (0, m.kJ)(t[e]) && (t[e] = (0, m.Rg)(t[e]))
                             }))
                         };
                     return n(e.defaults, ["prevent", "allow"]), n(e, ["view", "window", "selector"]), e
                 }(t.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
                 const r = function(t, e, n) {
-                    return FC(t, Pr, hC, n).parse(e)
+                    return hz(t, Pr, KR, n).parse(e)
                 }(n, t, e.expr);
                 n._runtime = r, n._signals = r.signals, n._bind = (t.bindings || []).map((t => ({
                         state: null,
                         param: (0, m.l7)({}, t)
-                    }))), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = gF(n, n._width), n._viewHeight = vF(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1,
+                    }))), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = tP(n, n._width), n._viewHeight = eP(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1,
                     function(t) {
                         var e = t._signals,
-                            n = e[dF],
-                            i = e[hF],
-                            r = e[pF];
+                            n = e[Yz],
+                            i = e[Vz],
+                            r = e[Kz];
 
                         function o() {
                             t._autosize = t._resize = 1
                         }
                         t._resizeWidth = t.add(null, (e => {
-                            t._width = e.size, t._viewWidth = gF(t, e.size), o()
+                            t._width = e.size, t._viewWidth = tP(t, e.size), o()
                         }), {
                             size: n
                         }), t._resizeHeight = t.add(null, (e => {
-                            t._height = e.size, t._viewHeight = vF(t, e.size), o()
+                            t._height = e.size, t._viewHeight = eP(t, e.size), o()
                         }), {
                             size: i
                         });
                         const a = t.add(null, o, {
                             pad: r
                         });
                         t._resizeWidth.rank = n.rank + 1, t._resizeHeight.rank = i.rank + 1, a.rank = r.rank + 1
@@ -39348,59 +42693,75 @@
                     function(t) {
                         t.add(null, (e => (t._background = e.bg, t._resize = 1, e.bg)), {
                             bg: t._signals.background
                         })
                     }(n),
                     function(t) {
                         const e = t._signals.cursor || (t._signals.cursor = t.add({
-                            user: NC,
+                            user: vz,
                             item: null
                         }));
-                        t.on(t.events("view", "mousemove"), e, ((t, n) => {
+                        t.on(t.events("view", "pointermove"), e, ((t, n) => {
                             const i = e.value,
-                                r = i ? (0, m.HD)(i) ? i : i.user : NC,
+                                r = i ? (0, m.HD)(i) ? i : i.user : vz,
                                 o = n.item && n.item.cursor || null;
                             return i && r === i.user && o == i.item ? i : {
                                 user: r,
                                 item: o
                             }
                         })), t.add(null, (function(e) {
                             let n = e.cursor,
                                 i = this.value;
-                            return (0, m.HD)(n) || (i = n.item, n = n.user), zC(t, n && n !== NC ? n : i || n), i
+                            return (0, m.HD)(n) || (i = n.item, n = n.user), yz(t, n && n !== vz ? n : i || n), i
                         }), {
                             cursor: e
                         })
-                    }(n), n.description(t.description), e.hover && n.hover(), e.container && n.initialize(e.container, e.bind)
+                    }(n), n.description(t.description), e.hover && n.hover(), e.container && n.initialize(e.container, e.bind), e.watchPixelRatio && n._watchPixelRatio()
             }
 
-            function EF(t, e) {
+            function cP(t, e) {
                 return (0, m.nr)(t._signals, e) ? t._signals[e] : (0, m.vU)("Unrecognized signal name: " + (0, m.m8)(e))
             }
 
-            function DF(t, e) {
+            function lP(t, e) {
                 const n = (t._targets || []).filter((t => t._update && t._update.handler === e));
                 return n.length ? n[0] : null
             }
 
-            function AF(t, e, n, i) {
-                let r = DF(n, i);
-                return r || (r = sF(t, (() => i(e, n.value))), r.handler = i, t.on(n, null, r)), t
+            function uP(t, e, n, i) {
+                let r = lP(n, i);
+                return r || (r = Xz(t, (() => i(e, n.value))), r.handler = i, t.on(n, null, r)), t
             }
 
-            function SF(t, e, n) {
-                const i = DF(e, n);
+            function fP(t, e, n) {
+                const i = lP(e, n);
                 return i && e._targets.remove(i), t
-            }(0, m.XW)(kF, Nr, {
+            }
+
+            function dP(t, e) {
+                return null == t || null == e ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
+            }
+
+            function hP(t, e) {
+                return null == t || null == e ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
+            }
+
+            function pP() {
+                return 0
+            }
+
+            function mP(t) {
+                return t instanceof nR.H ? t : new nR.H(t)
+            }(0, m.XW)(sP, Nr, {
                 async evaluate(t, e, n) {
                     if (await Nr.prototype.evaluate.call(this, t, e), this._redraw || this._resize) try {
                         this._renderer && (this._resize && (this._resize = 0, function(t) {
-                            var e = BC(t),
-                                n = LC(t),
-                                i = jC(t);
+                            var e = kz(t),
+                                n = _z(t),
+                                i = wz(t);
                             t._renderer.background(t.background()), t._renderer.resize(n, i, e), t._handler.origin(e), t._resizeListeners.forEach((e => {
                                 try {
                                     e(n, i)
                                 } catch (r) {
                                     t.error(r)
                                 }
                             }))
@@ -39412,118 +42773,118 @@
                 },
                 dirty(t) {
                     this._redraw = !0, this._renderer && this._renderer.dirty(t)
                 },
                 description(t) {
                     if (arguments.length) {
                         const e = null != t ? t + "" : null;
-                        return e !== this._desc && TC(this._el, this._desc = e), this
+                        return e !== this._desc && gz(this._el, this._desc = e), this
                     }
                     return this._desc
                 },
                 container() {
                     return this._el
                 },
                 scenegraph() {
                     return this._scenegraph
                 },
                 origin() {
                     return this._origin.slice()
                 },
                 signal(t, e, n) {
-                    const i = EF(this, t);
+                    const i = cP(this, t);
                     return 1 === arguments.length ? i.value : this.update(i, e, n)
                 },
                 width(t) {
                     return arguments.length ? this.signal("width", t) : this.signal("width")
                 },
                 height(t) {
                     return arguments.length ? this.signal("height", t) : this.signal("height")
                 },
                 padding(t) {
-                    return arguments.length ? this.signal("padding", uF(t)) : uF(this.signal("padding"))
+                    return arguments.length ? this.signal("padding", Zz(t)) : Zz(this.signal("padding"))
                 },
                 autosize(t) {
                     return arguments.length ? this.signal("autosize", t) : this.signal("autosize")
                 },
                 background(t) {
                     return arguments.length ? this.signal("background", t) : this.signal("background")
                 },
                 renderer(t) {
-                    return arguments.length ? (Eg(t) || (0, m.vU)("Unrecognized renderer type: " + t), t !== this._renderType && (this._renderType = t, this._resetRenderer()), this) : this._renderType
+                    return arguments.length ? (Pg(t) || (0, m.vU)("Unrecognized renderer type: " + t), t !== this._renderType && (this._renderType = t, this._resetRenderer()), this) : this._renderType
                 },
                 tooltip(t) {
                     return arguments.length ? (t !== this._tooltip && (this._tooltip = t, this._resetRenderer()), this) : this._tooltip
                 },
                 loader(t) {
                     return arguments.length ? (t !== this._loader && (Nr.prototype.loader.call(this, t), this._resetRenderer()), this) : this._loader
                 },
                 resize() {
-                    return this._autosize = 1, this.touch(EF(this, "autosize"))
+                    return this._autosize = 1, this.touch(cP(this, "autosize"))
                 },
                 _resetRenderer() {
                     this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind))
                 },
                 _resizeView: function(t, e, n, i, r, o) {
                     this.runAfter((a => {
                         let s = 0;
-                        a._autosize = 0, a.width() !== n && (s = 1, a.signal(dF, n, mF), a._resizeWidth.skip(!0)), a.height() !== i && (s = 1, a.signal(hF, i, mF), a._resizeHeight.skip(!0)), a._viewWidth !== t && (a._resize = 1, a._viewWidth = t), a._viewHeight !== e && (a._resize = 1, a._viewHeight = e), a._origin[0] === r[0] && a._origin[1] === r[1] || (a._resize = 1, a._origin = r), s && a.run("enter"), o && a.runAfter((t => t.resize()))
+                        a._autosize = 0, a.width() !== n && (s = 1, a.signal(Yz, n, Qz), a._resizeWidth.skip(!0)), a.height() !== i && (s = 1, a.signal(Vz, i, Qz), a._resizeHeight.skip(!0)), a._viewWidth !== t && (a._resize = 1, a._viewWidth = t), a._viewHeight !== e && (a._resize = 1, a._viewHeight = e), a._origin[0] === r[0] && a._origin[1] === r[1] || (a._resize = 1, a._origin = r), s && a.run("enter"), o && a.runAfter((t => t.resize()))
                     }), !1, 1)
                 },
                 addEventListener(t, e, n) {
                     let i = e;
-                    return n && !1 === n.trap || (i = sF(this, e), i.raw = e), this._handler.on(t, i), this
+                    return n && !1 === n.trap || (i = Xz(this, e), i.raw = e), this._handler.on(t, i), this
                 },
                 removeEventListener(t, e) {
                     for (var n, i, r = this._handler.handlers(t), o = r.length; --o >= 0;)
                         if (i = r[o].type, n = r[o].handler, t === i && (e === n || e === n.raw)) {
                             this._handler.off(i, n);
                             break
                         } return this
                 },
                 addResizeListener(t) {
                     const e = this._resizeListeners;
-                    return e.indexOf(t) < 0 && e.push(t), this
+                    return e.includes(t) || e.push(t), this
                 },
                 removeResizeListener(t) {
                     var e = this._resizeListeners,
                         n = e.indexOf(t);
                     return n >= 0 && e.splice(n, 1), this
                 },
                 addSignalListener(t, e) {
-                    return AF(this, t, EF(this, t), e)
+                    return uP(this, t, cP(this, t), e)
                 },
                 removeSignalListener(t, e) {
-                    return SF(this, EF(this, t), e)
+                    return fP(this, cP(this, t), e)
                 },
                 addDataListener(t, e) {
-                    return AF(this, t, RC(this, t).values, e)
+                    return uP(this, t, bz(this, t).values, e)
                 },
                 removeDataListener(t, e) {
-                    return SF(this, RC(this, t).values, e)
+                    return fP(this, bz(this, t).values, e)
                 },
                 globalCursor(t) {
                     if (arguments.length) {
                         if (this._globalCursor !== !!t) {
-                            const e = zC(this, null);
-                            this._globalCursor = !!t, e && zC(this, e)
+                            const e = yz(this, null);
+                            this._globalCursor = !!t, e && yz(this, e)
                         }
                         return this
                     }
                     return this._globalCursor
                 },
                 preventDefault(t) {
                     return arguments.length ? (this._preventDefault = t, this) : this._preventDefault
                 },
                 timer: function(t, e) {
                     this._timers.push(function(t, e, n) {
-                        var i = new Xw.B7,
+                        var i = new Kw.B7,
                             r = e;
                         return null == e ? (i.restart(t, e, n), i) : (i._restart = i.restart, i.restart = function(t, e, n) {
-                            e = +e, n = null == n ? (0, Xw.zO)() : +n, i._restart((function o(a) {
+                            e = +e, n = null == n ? (0, Kw.zO)() : +n, i._restart((function o(a) {
                                 a += r, i._restart(o, r += e, n), t(a)
                             }), e, n)
                         }, i.restart(t, e, n), i)
                     }((function(e) {
                         t({
                             timestamp: Date.now(),
                             elapsed: e
@@ -39531,1308 +42892,2207 @@
                     }), e))
                 },
                 events: function(t, e, n) {
                     var i, r = this,
                         o = new yr(n),
                         a = function(n, i) {
                             r.runAsync(null, (() => {
-                                t === UC && function(t, e) {
+                                t === Az && function(t, e) {
                                     var n = t._eventConfig.defaults,
                                         i = n.prevent,
                                         r = n.allow;
                                     return !1 !== i && !0 !== r && (!0 === i || !1 === r || (i ? i[e] : r ? !r[e] : t.preventDefault()))
-                                }(r, e) && n.preventDefault(), o.receive(IC(r, n, i))
+                                }(r, e) && n.preventDefault(), o.receive(Ez(r, n, i))
                             }))
                         };
-                    if ("timer" === t) HC(r, "timer", e) && r.timer(a, e);
-                    else if (t === UC) HC(r, "view", e) && r.addEventListener(e, a, qC);
-                    else if ("window" === t ? HC(r, "window", e) && "undefined" !== typeof window && (i = [window]) : "undefined" !== typeof document && HC(r, "selector", e) && (i = Array.from(document.querySelectorAll(t))), i) {
+                    if ("timer" === t) Cz(r, "timer", e) && r.timer(a, e);
+                    else if (t === Az) Cz(r, "view", e) && r.addEventListener(e, a, Dz);
+                    else if ("window" === t ? Cz(r, "window", e) && "undefined" !== typeof window && (i = [window]) : "undefined" !== typeof document && Cz(r, "selector", e) && (i = Array.from(document.querySelectorAll(t))), i) {
                         for (var s = 0, c = i.length; s < c; ++s) i[s].addEventListener(e, a);
-                        WC(r, i, e, a)
+                        Sz(r, i, e, a)
                     } else r.warn("Can not resolve event source: " + t);
                     return o
                 },
                 finalize: function() {
                     var t, e, n, i = this._tooltip,
                         r = this._timers,
                         o = this._eventListeners;
                     for (t = r.length; --t >= 0;) r[t].stop();
                     for (t = o.length; --t >= 0;)
                         for (e = (n = o[t]).sources.length; --e >= 0;) n.sources[e].removeEventListener(n.type, n.handler);
                     return i && i.call(this, this._handler, null, null, null), this
                 },
                 hover: function(t, e) {
-                    return e = [e || "update", (t = [t || "hover"])[0]], this.on(this.events("view", "mouseover", XC), JC, GC(t)), this.on(this.events("view", "mouseout", XC), JC, GC(e)), this
+                    return e = [e || "update", (t = [t || "hover"])[0]], this.on(this.events("view", "pointerover", Mz), Fz, Oz(t)), this.on(this.events("view", "pointerout", Mz), Fz, Oz(e)), this
                 },
                 data: function(t, e) {
-                    return arguments.length < 2 ? RC(this, t).values.value : PC.call(this, t, ur().remove(m.yb).insert(e))
+                    return arguments.length < 2 ? bz(this, t).values.value : xz.call(this, t, ur().remove(m.yb).insert(e))
                 },
-                change: PC,
+                change: xz,
                 insert: function(t, e) {
-                    return PC.call(this, t, ur().insert(e))
+                    return xz.call(this, t, ur().insert(e))
                 },
                 remove: function(t, e) {
-                    return PC.call(this, t, ur().remove(e))
+                    return xz.call(this, t, ur().remove(e))
                 },
                 scale: function(t) {
                     var e = this._runtime.scales;
                     return (0, m.nr)(e, t) || (0, m.vU)("Unrecognized scale or projection: " + t), e[t].value
                 },
                 initialize: function(t, e) {
                     const n = this,
                         i = n._renderType,
                         r = n._eventConfig.bind,
-                        o = Eg(i);
-                    t = n._el = t ? cF(n, t, !0) : null,
+                        o = Pg(i);
+                    t = n._el = t ? Gz(n, t, !0) : null,
                         function(t) {
                             const e = t.container();
-                            e && (e.setAttribute("role", "graphics-document"), e.setAttribute("aria-roleDescription", "visualization"), TC(e, t.description()))
+                            e && (e.setAttribute("role", "graphics-document"), e.setAttribute("aria-roleDescription", "visualization"), gz(e, t.description()))
                         }(n), o || n.error("Unrecognized renderer type: " + i);
-                    const a = o.handler || Am,
+                    const a = o.handler || Im,
                         s = t ? o.renderer : o.headless;
-                    return n._renderer = s ? aF(n, n._renderer, t, s) : null, n._handler = function(t, e, n, i) {
-                        const r = new i(t.loader(), sF(t, t.tooltip())).scene(t.scenegraph().root).initialize(n, BC(t), t);
+                    return n._renderer = s ? Hz(n, n._renderer, t, s) : null, n._handler = function(t, e, n, i) {
+                        const r = new i(t.loader(), Xz(t, t.tooltip())).scene(t.scenegraph().root).initialize(n, kz(t), t);
                         return e && e.handlers().forEach((t => {
                             r.on(t.type, t.handler)
                         })), r
-                    }(n, n._handler, t, a), n._redraw = !0, t && "none" !== r && (e = e ? n._elBind = cF(n, e, !0) : t.appendChild($C("form", {
+                    }(n, n._handler, t, a), n._redraw = !0, t && "none" !== r && (e = e ? n._elBind = Gz(n, e, !0) : t.appendChild(Tz("form", {
                         class: "vega-bindings"
                     })), n._bind.forEach((t => {
-                        t.param.element && "container" !== r && (t.element = cF(n, t.param.element, !!t.param.input))
+                        t.param.element && "container" !== r && (t.element = Gz(n, t.param.element, !!t.param.input))
                     })), n._bind.forEach((t => {
                         ! function(t, e, n) {
                             if (!e) return;
                             const i = n.param;
                             let r = n.state;
                             r || (r = n.state = {
                                 elements: null,
                                 active: !1,
                                 set: null,
                                 update: e => {
                                     e != t.signal(i.signal) && t.runAsync(null, (() => {
                                         r.source = !0, t.signal(i.signal, e)
                                     }))
                                 }
-                            }, i.debounce && (r.update = (0, m.Ds)(i.debounce, r.update))), (null == i.input && i.element ? KC : QC)(r, e, i, t), r.active || (t.on(t._signals[i.signal], null, (() => {
+                            }, i.debounce && (r.update = (0, m.Ds)(i.debounce, r.update))), (null == i.input && i.element ? Pz : Lz)(r, e, i, t), r.active || (t.on(t._signals[i.signal], null, (() => {
                                 r.source ? r.source = !1 : r.set(t.signal(i.signal))
                             })), r.active = !0)
                         }(n, t.element || e, t)
                     }))), n
                 },
                 toImageURL: async function(t, e) {
-                    t !== wg.Canvas && t !== wg.SVG && t !== wg.PNG && (0, m.vU)("Unrecognized image type: " + t);
-                    const n = await fF(this, t, e);
-                    return t === wg.SVG ? function(t, e) {
+                    t !== Rg.Canvas && t !== Rg.SVG && t !== Rg.PNG && (0, m.vU)("Unrecognized image type: " + t);
+                    const n = await $z(this, t, e);
+                    return t === Rg.SVG ? function(t, e) {
                         const n = new Blob([t], {
                             type: e
                         });
                         return window.URL.createObjectURL(n)
                     }(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png")
                 },
                 toCanvas: async function(t, e) {
-                    return (await fF(this, wg.Canvas, t, e)).canvas()
+                    return (await $z(this, Rg.Canvas, t, e)).canvas()
                 },
                 toSVG: async function(t) {
-                    return (await fF(this, wg.SVG, t)).svg()
+                    return (await $z(this, Rg.SVG, t)).svg()
                 },
                 getState: function(t) {
                     return this._runtime.getState(t || {
-                        data: yF,
-                        signals: bF,
+                        data: nP,
+                        signals: iP,
                         recurse: !0
                     })
                 },
                 setState: function(t) {
                     return this.runAsync(null, (e => {
                         e._trigger = !1, e._runtime.setState(t)
                     }), (t => {
                         t._trigger = !0
                     })), this
+                },
+                _watchPixelRatio: function() {
+                    if ("canvas" === this.renderer() && this._renderer._canvas) {
+                        let t = null;
+                        const e = () => {
+                            null != t && t();
+                            const n = matchMedia("(resolution: ".concat(window.devicePixelRatio, "dppx)"));
+                            n.addEventListener("change", e), t = () => {
+                                n.removeEventListener("change", e)
+                            }, this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1, this._redraw = !0, this._resize = 1, this.resize().runAsync()
+                        };
+                        e()
+                    }
                 }
             });
-            var CF = n(77155);
+            const gP = Symbol("vega_selection_getter");
+
+            function vP(t) {
+                return t.getter && t.getter[gP] || (t.getter = (0, m.EP)(t.field), t.getter[gP] = !0), t.getter
+            }
+            const yP = "intersect",
+                bP = "union",
+                xP = "_vgsid_",
+                _P = (0, m.EP)(xP),
+                wP = "E",
+                kP = "R",
+                EP = "R-E",
+                AP = "R-LE",
+                DP = "R-RE",
+                SP = "index:unit";
 
-            function FF(t) {
+            function CP(t, e) {
+                for (var n, i, r = e.fields, o = e.values, a = r.length, s = 0; s < a; ++s)
+                    if (n = vP(i = r[s])(t), (0, m.J_)(n) && (n = (0, m.He)(n)), (0, m.J_)(o[s]) && (o[s] = (0, m.He)(o[s])), (0, m.kJ)(o[s]) && (0, m.J_)(o[s][0]) && (o[s] = o[s].map(m.He)), i.type === wP) {
+                        if ((0, m.kJ)(o[s]) ? o[s].indexOf(n) < 0 : n !== o[s]) return !1
+                    } else if (i.type === kP) {
+                    if (!(0, m.u5)(n, o[s])) return !1
+                } else if (i.type === DP) {
+                    if (!(0, m.u5)(n, o[s], !0, !1)) return !1
+                } else if (i.type === EP) {
+                    if (!(0, m.u5)(n, o[s], !1, !1)) return !1
+                } else if (i.type === AP && !(0, m.u5)(n, o[s], !1, !0)) return !1;
+                return !0
+            }
+            const MP = function(t) {
+                    let e, n, i;
+
+                    function r(t, i) {
+                        let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
+                            o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.length;
+                        if (r < o) {
+                            if (0 !== e(i, i)) return o;
+                            do {
+                                const e = r + o >>> 1;
+                                n(t[e], i) < 0 ? r = e + 1 : o = e
+                            } while (r < o)
+                        }
+                        return r
+                    }
+                    return 2 !== t.length ? (e = dP, n = (e, n) => dP(t(e), n), i = (e, n) => t(e) - n) : (e = t === dP || t === hP ? t : pP, n = t, i = t), {
+                        left: r,
+                        center: function(t, e) {
+                            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
+                            const o = r(t, e, n, (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.length) - 1);
+                            return o > n && i(t[o - 1], e) > -i(t[o], e) ? o - 1 : o
+                        },
+                        right: function(t, i) {
+                            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
+                                o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.length;
+                            if (r < o) {
+                                if (0 !== e(i, i)) return o;
+                                do {
+                                    const e = r + o >>> 1;
+                                    n(t[e], i) <= 0 ? r = e + 1 : o = e
+                                } while (r < o)
+                            }
+                            return r
+                        }
+                    }
+                }(_P),
+                FP = MP.left,
+                OP = MP.right;
+            var TP = {
+                ["".concat(xP, "_union")]: function() {
+                    const t = new nR.H;
+                    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
+                    for (const r of n)
+                        for (const e of r) t.add(e);
+                    return t
+                },
+                ["".concat(xP, "_intersect")]: function(t) {
+                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
+                    t = new nR.H(t), n = n.map(mP);
+                    t: for (const r of t)
+                        for (const e of n)
+                            if (!e.has(r)) {
+                                t.delete(r);
+                                continue t
+                            }
+                    return t
+                },
+                E_union: function(t, e) {
+                    if (!t.length) return e;
+                    for (var n = 0, i = e.length; n < i; ++n) t.indexOf(e[n]) < 0 && t.push(e[n]);
+                    return t
+                },
+                E_intersect: function(t, e) {
+                    return t.length ? t.filter((t => e.indexOf(t) >= 0)) : e
+                },
+                R_union: function(t, e) {
+                    var n = (0, m.He)(e[0]),
+                        i = (0, m.He)(e[1]);
+                    return n > i && (n = e[1], i = e[0]), t.length ? (t[0] > n && (t[0] = n), t[1] < i && (t[1] = i), t) : [n, i]
+                },
+                R_intersect: function(t, e) {
+                    var n = (0, m.He)(e[0]),
+                        i = (0, m.He)(e[1]);
+                    return n > i && (n = e[1], i = e[0]), t.length ? i < t[0] || t[1] < n ? [] : (t[0] < n && (t[0] = n), t[1] > i && (t[1] = i), t) : [n, i]
+                }
+            };
+
+            function NP(t, e, n, i) {
+                e[0].type !== sN.t$ && (0, m.vU)("First argument to selection functions must be a string literal.");
+                const r = e[0].value,
+                    o = "unit",
+                    a = "@" + o,
+                    s = ":" + r;
+                (e.length >= 2 && (0, m.fj)(e).value) !== yP || (0, m.nr)(i, a) || (i[a] = n.getData(r).indataRef(n, o)), (0, m.nr)(i, s) || (i[s] = n.getData(r).tuplesRef())
+            }
+
+            function RP(t) {
+                const e = this.context.data[t];
+                return e ? e.values.value : []
+            }
+            const zP = t => function(e, n) {
+                    return this.context.dataflow.locale()[t](n)(e)
+                },
+                PP = zP("format"),
+                LP = zP("timeFormat"),
+                BP = zP("utcFormat"),
+                IP = zP("timeParse"),
+                jP = zP("utcParse"),
+                UP = new Date(2e3, 0, 1);
+
+            function qP(t, e, n) {
+                return Number.isInteger(t) && Number.isInteger(e) ? (UP.setYear(2e3), UP.setMonth(t), UP.setDate(e), LP.call(this, UP, n)) : ""
+            }
+            const WP = "%",
+                HP = "$";
+
+            function XP(t, e, n, i) {
+                e[0].type !== sN.t$ && (0, m.vU)("First argument to data functions must be a string literal.");
+                const r = e[0].value,
+                    o = ":" + r;
+                if (!(0, m.nr)(o, i)) try {
+                    i[o] = n.getData(r).tuplesRef()
+                } catch (a) {}
+            }
+
+            function GP(t, e, n, i) {
+                if (e[0].type === sN.t$) JP(n, i, e[0].value);
+                else
+                    for (t in n.scales) JP(n, i, t)
+            }
+
+            function JP(t, e, n) {
+                const i = WP + n;
+                if (!(0, m.nr)(e, i)) try {
+                    e[i] = t.scaleRef(n)
+                } catch (r) {}
+            }
+
+            function ZP(t, e) {
+                if ((0, m.mf)(t)) return t;
+                if ((0, m.HD)(t)) {
+                    const n = e.scales[t];
+                    return n && Mf(n.value) ? n.value : void 0
+                }
+            }
+
+            function $P(t, e, n) {
+                e.__bandwidth = t => t && t.bandwidth ? t.bandwidth() : 0, n._bandwidth = GP, n._range = GP, n._scale = GP;
+                const i = e => "_[" + (e.type === sN.t$ ? (0, m.m8)(WP + e.value) : (0, m.m8)(WP) + "+" + t(e)) + "]";
+                return {
+                    _bandwidth: t => "this.__bandwidth(".concat(i(t[0]), ")"),
+                    _range: t => "".concat(i(t[0]), ".range()"),
+                    _scale: e => "".concat(i(e[0]), "(").concat(t(e[1]), ")")
+                }
+            }
+
+            function YP(t, e) {
+                return function(n, i, r) {
+                    if (n) {
+                        const e = ZP(n, (r || this).context);
+                        return e && e.path[t](i)
+                    }
+                    return e(i)
+                }
+            }
+            const VP = YP("area", mN),
+                KP = YP("bounds", WN),
+                QP = YP("centroid", eR);
+
+            function tL(t, e, n) {
+                try {
+                    t[e].apply(t, ["EXPRESSION"].concat([].slice.call(n)))
+                } catch (i) {
+                    t.warn(i)
+                }
+                return n[n.length - 1]
+            }
+
+            function eL(t) {
+                const e = t / 255;
+                return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
+            }
+
+            function nL(t) {
+                const e = (0, uu.B8)(t);
+                return .2126 * eL(e.r) + .7152 * eL(e.g) + .0722 * eL(e.b)
+            }
+
+            function iL(t, e) {
+                return t === e || t !== t && e !== e || ((0, m.kJ)(t) ? !(!(0, m.kJ)(e) || t.length !== e.length) && function(t, e) {
+                    for (let n = 0, i = t.length; n < i; ++n)
+                        if (!iL(t[n], e[n])) return !1;
+                    return !0
+                }(t, e) : !(!(0, m.Kn)(t) || !(0, m.Kn)(e)) && rL(t, e))
+            }
+
+            function rL(t, e) {
+                for (const n in t)
+                    if (!iL(t[n], e[n])) return !1;
+                return !0
+            }
+
+            function oL(t) {
+                return e => rL(t, e)
+            }
+            const aL = {};
+
+            function sL(t) {
+                return (0, m.kJ)(t) || ArrayBuffer.isView(t) ? t : null
+            }
+
+            function cL(t) {
+                return sL(t) || ((0, m.HD)(t) ? t : null)
+            }
+            const lL = t => t.data;
+
+            function uL(t, e) {
+                const n = RP.call(e, t);
+                return n.root && n.root.lookup || {}
+            }
+            const fL = () => "undefined" !== typeof window && window || null;
+
+            function dL(t, e, n) {
+                if (!t) return [];
+                const [i, r] = t, o = (new uh).set(i[0], i[1], r[0], r[1]);
+                return Lg(n || this.context.dataflow.scenegraph().root, o, function(t) {
+                    let e = null;
+                    if (t) {
+                        const n = (0, m.IX)(t.marktype),
+                            i = (0, m.IX)(t.markname);
+                        e = t => (!n.length || n.some((e => t.marktype === e))) && (!i.length || i.some((e => t.name === e)))
+                    }
+                    return e
+                }(e))
+            }
+            const hL = {
+                    random: () => Zr(),
+                    cumulativeNormal: oo,
+                    cumulativeLogNormal: fo,
+                    cumulativeUniform: yo,
+                    densityNormal: ro,
+                    densityLogNormal: uo,
+                    densityUniform: vo,
+                    quantileNormal: ao,
+                    quantileLogNormal: ho,
+                    quantileUniform: bo,
+                    sampleNormal: io,
+                    sampleLogNormal: lo,
+                    sampleUniform: go,
+                    isArray: m.kJ,
+                    isBoolean: m.jn,
+                    isDate: m.J_,
+                    isDefined: t => void 0 !== t,
+                    isNumber: m.hj,
+                    isObject: m.Kn,
+                    isRegExp: m.Kj,
+                    isString: m.HD,
+                    isTuple: er,
+                    isValid: t => null != t && t === t,
+                    toBoolean: m.sw,
+                    toDate: t => (0, m.ZU)(t),
+                    toNumber: m.He,
+                    toString: m.BB,
+                    indexof: function(t) {
+                        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
+                        return cL(t).indexOf(...n)
+                    },
+                    join: function(t) {
+                        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
+                        return sL(t).join(...n)
+                    },
+                    lastindexof: function(t) {
+                        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
+                        return cL(t).lastIndexOf(...n)
+                    },
+                    replace: function(t, e, n) {
+                        return (0, m.mf)(n) && (0, m.vU)("Function argument passed to replace."), String(t).replace(e, n)
+                    },
+                    reverse: function(t) {
+                        return sL(t).slice().reverse()
+                    },
+                    slice: function(t) {
+                        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
+                        return cL(t).slice(...n)
+                    },
+                    flush: m.yl,
+                    lerp: m.t7,
+                    merge: function() {
+                        const t = [].slice.call(arguments);
+                        return t.unshift({}), (0, m.l7)(...t)
+                    },
+                    pad: m.vk,
+                    peek: m.fj,
+                    pluck: function(t, e) {
+                        const n = aL[e] || (aL[e] = (0, m.EP)(e));
+                        return (0, m.kJ)(t) ? t.map(n) : n(t)
+                    },
+                    span: m.yP,
+                    inrange: m.u5,
+                    truncate: m.$G,
+                    rgb: uu.B8,
+                    lab: Au,
+                    hcl: Tu,
+                    hsl: uu.Ym,
+                    luminance: nL,
+                    contrast: function(t, e) {
+                        const n = nL(t),
+                            i = nL(e);
+                        return (Math.max(n, i) + .05) / (Math.min(n, i) + .05)
+                    },
+                    sequence: Wo.Z,
+                    format: PP,
+                    utcFormat: BP,
+                    utcParse: jP,
+                    utcOffset: ge,
+                    utcSequence: be,
+                    timeFormat: LP,
+                    timeParse: IP,
+                    timeOffset: me,
+                    timeSequence: ye,
+                    timeUnitSpecifier: Ut,
+                    monthFormat: function(t) {
+                        return qP.call(this, t, 1, "%B")
+                    },
+                    monthAbbrevFormat: function(t) {
+                        return qP.call(this, t, 1, "%b")
+                    },
+                    dayFormat: function(t) {
+                        return qP.call(this, 0, 2 + t, "%A")
+                    },
+                    dayAbbrevFormat: function(t) {
+                        return qP.call(this, 0, 2 + t, "%a")
+                    },
+                    quarter: m.mS,
+                    utcquarter: m.N3,
+                    week: Xt,
+                    utcweek: Vt,
+                    dayofyear: Ht,
+                    utcdayofyear: Yt,
+                    warn: function() {
+                        return tL(this.context.dataflow, "warn", arguments)
+                    },
+                    info: function() {
+                        return tL(this.context.dataflow, "info", arguments)
+                    },
+                    debug: function() {
+                        return tL(this.context.dataflow, "debug", arguments)
+                    },
+                    extent: t => (0, m.We)(t),
+                    inScope: function(t) {
+                        const e = this.context.group;
+                        let n = !1;
+                        if (e)
+                            for (; t;) {
+                                if (t === e) {
+                                    n = !0;
+                                    break
+                                }
+                                t = t.mark.group
+                            }
+                        return n
+                    },
+                    intersect: dL,
+                    clampRange: m.l$,
+                    pinchDistance: function(t) {
+                        const e = t.touches,
+                            n = e[0].clientX - e[1].clientX,
+                            i = e[0].clientY - e[1].clientY;
+                        return Math.hypot(n, i)
+                    },
+                    pinchAngle: function(t) {
+                        const e = t.touches;
+                        return Math.atan2(e[0].clientY - e[1].clientY, e[0].clientX - e[1].clientX)
+                    },
+                    screen: function() {
+                        const t = fL();
+                        return t ? t.screen : {}
+                    },
+                    containerSize: function() {
+                        const t = this.context.dataflow,
+                            e = t.container && t.container();
+                        return e ? [e.clientWidth, e.clientHeight] : [void 0, void 0]
+                    },
+                    windowSize: function() {
+                        const t = fL();
+                        return t ? [t.innerWidth, t.innerHeight] : [void 0, void 0]
+                    },
+                    bandspace: function(t, e, n) {
+                        return Qu(t || 0, e || 0, n || 0)
+                    },
+                    setdata: function(t, e) {
+                        const n = this.context.dataflow,
+                            i = this.context.data[t].input;
+                        return n.pulse(i, n.changeset().remove(m.yb).insert(e)), 1
+                    },
+                    pathShape: function(t) {
+                        let e = null;
+                        return function(n) {
+                            return n ? Pd(n, e = e || Ad(t)) : t
+                        }
+                    },
+                    panLinear: m.Dw,
+                    panLog: m.mJ,
+                    panPow: m.QA,
+                    panSymlog: m.Zw,
+                    zoomLinear: m.ay,
+                    zoomLog: m.dH,
+                    zoomPow: m.mK,
+                    zoomSymlog: m.bV,
+                    encode: function(t, e, n) {
+                        if (t) {
+                            const n = this.context.dataflow,
+                                i = t.mark.source;
+                            n.pulse(i, n.changeset().encode(t, e))
+                        }
+                        return void 0 !== n ? n : t
+                    },
+                    modify: function(t, e, n, i, r, o) {
+                        const a = this.context.dataflow,
+                            s = this.context.data[t],
+                            c = s.input,
+                            l = a.stamp();
+                        let u, f, d = s.changes;
+                        if (!1 === a._trigger || !(c.value.length || e || i)) return 0;
+                        if ((!d || d.stamp < l) && (s.changes = d = a.changeset(), d.stamp = l, a.runAfter((() => {
+                                s.modified = !0, a.pulse(c, d).run()
+                            }), !0, 1)), n && (u = !0 === n ? m.yb : (0, m.kJ)(n) || er(n) ? n : oL(n), d.remove(u)), e && d.insert(e), i && (u = oL(i), c.value.some(u) ? d.remove(u) : d.insert(i)), r)
+                            for (f in o) d.modify(r, f, o[f]);
+                        return 1
+                    },
+                    lassoAppend: function(t, e, n) {
+                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5;
+                        const r = (t = (0, m.IX)(t))[t.length - 1];
+                        return void 0 === r || Math.hypot(r[0] - e, r[1] - n) > i ? [...t, [e, n]] : t
+                    },
+                    lassoPath: function(t) {
+                        return (0, m.IX)(t).reduce(((e, n, i) => {
+                            let [r, o] = n;
+                            return e + (0 == i ? "M ".concat(r, ",").concat(o, " ") : i === t.length - 1 ? " Z" : "L ".concat(r, ",").concat(o, " "))
+                        }), "")
+                    },
+                    intersectLasso: function(t, e, n) {
+                        const {
+                            x: i,
+                            y: r,
+                            mark: o
+                        } = n, a = (new uh).set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
+                        for (const [s, c] of e) s < a.x1 && (a.x1 = s), s > a.x2 && (a.x2 = s), c < a.y1 && (a.y1 = c), c > a.y2 && (a.y2 = c);
+                        return a.translate(i, r), dL([
+                            [a.x1, a.y1],
+                            [a.x2, a.y2]
+                        ], t, o).filter((t => function(t, e, n) {
+                            let i = 0;
+                            for (let r = 0, o = n.length - 1; r < n.length; o = r++) {
+                                const [a, s] = n[o], [c, l] = n[r];
+                                l > e != s > e && t < (a - c) * (e - l) / (s - l) + c && i++
+                            }
+                            return 1 & i
+                        }(t.x, t.y, e)))
+                    }
+                },
+                pL = ["view", "item", "group", "xy", "x", "y"],
+                mL = "this.",
+                gL = {},
+                vL = {
+                    forbidden: ["_"],
+                    allowed: ["datum", "event", "item"],
+                    fieldvar: "datum",
+                    globalvar: t => "_[".concat((0, m.m8)(HP + t), "]"),
+                    functions: function(t) {
+                        const e = (0, sN.wk)(t);
+                        pL.forEach((t => e[t] = "event.vega." + t));
+                        for (const n in hL) e[n] = mL + n;
+                        return (0, m.l7)(e, $P(t, hL, gL)), e
+                    },
+                    constants: sN._G,
+                    visitors: gL
+                },
+                yL = (0, sN.YP)(vL);
+
+            function bL(t, e, n) {
+                return 1 === arguments.length ? hL[t] : (hL[t] = e, n && (gL[t] = n), yL && (yL.functions[t] = mL + t), this)
+            }
+
+            function xL(t, e) {
+                const n = {};
+                let i;
+                try {
+                    t = (0, m.HD)(t) ? t : (0, m.m8)(t) + "", i = (0, sN.BJ)(t)
+                } catch (o) {
+                    (0, m.vU)("Expression parse error: " + t)
+                }
+                i.visit((t => {
+                    if (t.type !== sN.Lt) return;
+                    const i = t.callee.name,
+                        r = vL.visitors[i];
+                    r && r(i, t.arguments, e, n)
+                }));
+                const r = yL(i);
+                return r.globals.forEach((t => {
+                    const i = HP + t;
+                    !(0, m.nr)(n, i) && e.getSignal(t) && (n[i] = e.signalRef(t))
+                })), {
+                    $expr: (0, m.l7)({
+                        code: r.code
+                    }, e.options.ast ? {
+                        ast: i
+                    } : null),
+                    $fields: r.fields,
+                    $params: n
+                }
+            }
+            bL("bandwidth", (function(t, e) {
+                const n = ZP(t, (e || this).context);
+                return n && n.bandwidth ? n.bandwidth() : 0
+            }), GP), bL("copy", (function(t, e) {
+                const n = ZP(t, (e || this).context);
+                return n ? n.copy() : void 0
+            }), GP), bL("domain", (function(t, e) {
+                const n = ZP(t, (e || this).context);
+                return n ? n.domain() : []
+            }), GP), bL("range", (function(t, e) {
+                const n = ZP(t, (e || this).context);
+                return n && n.range ? n.range() : []
+            }), GP), bL("invert", (function(t, e, n) {
+                const i = ZP(t, (n || this).context);
+                return i ? (0, m.kJ)(e) ? (i.invertRange || i.invert)(e) : (i.invert || i.invertExtent)(e) : void 0
+            }), GP), bL("scale", (function(t, e, n) {
+                const i = ZP(t, (n || this).context);
+                return i ? i(e) : void 0
+            }), GP), bL("gradient", (function(t, e, n, i, r) {
+                t = ZP(t, (r || this).context);
+                const o = vd(e, n);
+                let a = t.domain(),
+                    s = a[0],
+                    c = (0, m.fj)(a),
+                    l = m.yR;
+                return c - s ? l = Bf(t, s, c) : t = (t.interpolator ? Ff("sequential")().interpolator(t.interpolator()) : Ff("linear")().interpolate(t.interpolate()).range(t.range())).domain([s = 0, c = 1]), t.ticks && (a = t.ticks(+i || 15), s !== a[0] && a.unshift(s), c !== (0, m.fj)(a) && a.push(c)), a.forEach((e => o.stop(l(e), t(e)))), o
+            }), GP), bL("geoArea", VP, GP), bL("geoBounds", KP, GP), bL("geoCentroid", QP, GP), bL("geoShape", (function(t, e, n) {
+                const i = ZP(t, (n || this).context);
+                return function(t) {
+                    return i ? i.path.context(t)(e) : ""
+                }
+            }), GP), bL("geoScale", (function(t, e) {
+                const n = ZP(t, (e || this).context);
+                return n && n.scale()
+            }), GP), bL("indata", (function(t, e, n) {
+                const i = this.context.data[t]["index:" + e],
+                    r = i ? i.value.get(n) : void 0;
+                return r ? r.count : r
+            }), (function(t, e, n, i) {
+                e[0].type !== sN.t$ && (0, m.vU)("First argument to indata must be a string literal."), e[1].type !== sN.t$ && (0, m.vU)("Second argument to indata must be a string literal.");
+                const r = e[0].value,
+                    o = e[1].value,
+                    a = "@" + o;
+                (0, m.nr)(a, i) || (i[a] = n.getData(r).indataRef(n, o))
+            })), bL("data", RP, XP), bL("treePath", (function(t, e, n) {
+                const i = uL(t, this),
+                    r = i[e],
+                    o = i[n];
+                return r && o ? r.path(o).map(lL) : void 0
+            }), XP), bL("treeAncestors", (function(t, e) {
+                const n = uL(t, this)[e];
+                return n ? n.ancestors().map(lL) : void 0
+            }), XP), bL("vlSelectionTest", (function(t, e, n) {
+                for (var i, r, o, a, s, c = this.context.data[t], l = c ? c.values.value : [], u = c ? c[SP] && c[SP].value : void 0, f = n === yP, d = l.length, h = 0; h < d; ++h)
+                    if (i = l[h], u && f) {
+                        if (-1 === (o = (r = r || {})[a = i.unit] || 0)) continue;
+                        if (s = CP(e, i), r[a] = s ? -1 : ++o, s && 1 === u.size) return !0;
+                        if (!s && o === u.get(a).count) return !1
+                    } else if (f ^ (s = CP(e, i))) return s;
+                return d && f
+            }), NP), bL("vlSelectionIdTest", (function(t, e, n) {
+                const i = this.context.data[t],
+                    r = i ? i.values.value : [],
+                    o = i ? i[SP] && i[SP].value : void 0,
+                    a = n === yP,
+                    s = _P(e),
+                    c = FP(r, s);
+                if (c === r.length) return !1;
+                if (_P(r[c]) !== s) return !1;
+                if (o && a) {
+                    if (1 === o.size) return !0;
+                    if (OP(r, s) - c < o.size) return !1
+                }
+                return !0
+            }), NP), bL("vlSelectionResolve", (function(t, e, n, i) {
+                for (var r, o, a, s, c, l, u, f, d, h, p, g, v = this.context.data[t], y = v ? v.values.value : [], b = {}, x = {}, _ = {}, w = y.length, k = 0; k < w; ++k)
+                    if (s = (r = y[k]).unit, o = r.fields, a = r.values, o && a) {
+                        for (p = 0, g = o.length; p < g; ++p) c = o[p], f = (u = b[c.field] || (b[c.field] = {}))[s] || (u[s] = []), _[c.field] = d = c.type.charAt(0), h = TP["".concat(d, "_union")], u[s] = h(f, (0, m.IX)(a[p]));
+                        n && (f = x[s] || (x[s] = [])).push((0, m.IX)(a).reduce(((t, e, n) => (t[o[n].field] = e, t)), {}))
+                    } else c = xP, l = _P(r), (f = (u = b[c] || (b[c] = {}))[s] || (u[s] = [])).push(l), n && (f = x[s] || (x[s] = [])).push({
+                        [xP]: l
+                    });
+                if (e = e || bP, b[xP] ? b[xP] = TP["".concat(xP, "_").concat(e)](...Object.values(b[xP])) : Object.keys(b).forEach((t => {
+                        b[t] = Object.keys(b[t]).map((e => b[t][e])).reduce(((n, i) => void 0 === n ? i : TP["".concat(_[t], "_").concat(e)](n, i)))
+                    })), y = Object.keys(x), n && y.length) {
+                    b[i ? "vlPoint" : "vlMulti"] = e === bP ? {
+                        or: y.reduce(((t, e) => (t.push(...x[e]), t)), [])
+                    } : {
+                        and: y.map((t => ({
+                            or: x[t]
+                        })))
+                    }
+                }
+                return b
+            }), NP), bL("vlSelectionTuples", (function(t, e) {
+                return t.map((t => (0, m.l7)(e.fields ? {
+                    values: e.fields.map((e => vP(e)(t.datum)))
+                } : {
+                    [xP]: _P(t.datum)
+                }, e)))
+            }));
+            var _L = n(77155);
+            const wL = "linear",
+                kL = "log",
+                EL = "pow",
+                AL = "sqrt",
+                DL = "symlog",
+                SL = "time",
+                CL = "utc",
+                ML = "sequential",
+                FL = "diverging",
+                OL = "quantile",
+                TL = "quantize",
+                NL = "threshold",
+                RL = "continuous",
+                zL = "discrete",
+                PL = "discretizing",
+                LL = "interpolating",
+                BL = "temporal";
+
+            function IL() {
+                const t = (0, Jl.Z)().unknown(void 0),
+                    e = t.domain,
+                    n = t.range;
+                let i, r, o = [0, 1],
+                    a = !1,
+                    s = 0,
+                    c = 0,
+                    l = .5;
+
+                function u() {
+                    const t = e().length,
+                        u = o[1] < o[0],
+                        f = o[1 - u],
+                        d = function(t, e, n) {
+                            const i = t - e + 2 * n;
+                            return t ? i > 0 ? i : 1 : 0
+                        }(t, s, c);
+                    let h = o[u - 0];
+                    i = (f - h) / (d || 1), a && (i = Math.floor(i)), h += (f - h - i * (t - s)) * l, r = i * (1 - s), a && (h = Math.round(h), r = Math.round(r));
+                    const p = (0, Wo.Z)(t).map((t => h + i * t));
+                    return n(u ? p.reverse() : p)
+                }
+                return delete t.unknown, t.domain = function(t) {
+                    return arguments.length ? (e(t), u()) : e()
+                }, t.range = function(t) {
+                    return arguments.length ? (o = [+t[0], +t[1]], u()) : o.slice()
+                }, t.rangeRound = function(t) {
+                    return o = [+t[0], +t[1]], a = !0, u()
+                }, t.bandwidth = function() {
+                    return r
+                }, t.step = function() {
+                    return i
+                }, t.round = function(t) {
+                    return arguments.length ? (a = !!t, u()) : a
+                }, t.padding = function(t) {
+                    return arguments.length ? (c = Math.max(0, Math.min(1, t)), s = c, u()) : s
+                }, t.paddingInner = function(t) {
+                    return arguments.length ? (s = Math.max(0, Math.min(1, t)), u()) : s
+                }, t.paddingOuter = function(t) {
+                    return arguments.length ? (c = Math.max(0, Math.min(1, t)), u()) : c
+                }, t.align = function(t) {
+                    return arguments.length ? (l = Math.max(0, Math.min(1, t)), u()) : l
+                }, t.invertRange = function(t) {
+                    if (null == t[0] || null == t[1]) return;
+                    const i = o[1] < o[0],
+                        a = i ? n().reverse() : n(),
+                        s = a.length - 1;
+                    let c, l, u, f = +t[0],
+                        d = +t[1];
+                    return f !== f || d !== d || (d < f && (u = f, f = d, d = u), d < a[0] || f > o[1 - i]) ? void 0 : (c = Math.max(0, (0, ol.ml)(a, f) - 1), l = f === d ? c : (0, ol.ml)(a, d) - 1, f - a[c] > r + 1e-10 && ++c, i && (u = c, c = s - l, l = s - u), c > l ? void 0 : e().slice(c, l + 1))
+                }, t.invert = function(e) {
+                    const n = t.invertRange([e, e]);
+                    return n ? n[0] : n
+                }, t.copy = function() {
+                    return IL().domain(e()).range(o).round(a).paddingInner(s).paddingOuter(c).align(l)
+                }, u()
+            }
+
+            function jL(t) {
+                const e = t.copy;
+                return t.padding = t.paddingOuter, delete t.paddingInner, t.copy = function() {
+                    return jL(e())
+                }, t
+            }
+            var UL = Array.prototype.map;
+            const qL = Array.prototype.slice;
+            const WL = new Map,
+                HL = Symbol("vega_scale");
+
+            function XL(t, e, n) {
+                const i = function() {
+                    const n = e();
+                    return n.invertRange || (n.invertRange = n.invert ? function(t) {
+                            return function(e) {
+                                let n, i = e[0],
+                                    r = e[1];
+                                return r < i && (n = i, i = r, r = n), [t.invert(i), t.invert(r)]
+                            }
+                        }(n) : n.invertExtent ? function(t) {
+                            return function(e) {
+                                const n = t.range();
+                                let i, r, o, a, s = e[0],
+                                    c = e[1],
+                                    l = -1;
+                                for (c < s && (r = s, s = c, c = r), o = 0, a = n.length; o < a; ++o) n[o] >= s && n[o] <= c && (l < 0 && (l = o), i = o);
+                                if (!(l < 0)) return s = t.invertExtent(n[l]), c = t.invertExtent(n[i]), [void 0 === s[0] ? s[1] : s[0], void 0 === c[1] ? c[0] : c[1]]
+                            }
+                        }(n) : void 0), n.type = t,
+                        function(t) {
+                            return t[HL] = !0, t
+                        }(n)
+                };
+                return i.metadata = (0, m.Rg)((0, m.IX)(n)), i
+            }
+
+            function GL(t, e, n) {
+                return arguments.length > 1 ? (WL.set(t, XL(t, e, n)), this) : JL(t) ? WL.get(t) : void 0
+            }
+
+            function JL(t) {
+                return WL.has(t)
+            }
+
+            function ZL(t, e) {
+                const n = WL.get(t);
+                return n && n.metadata[e]
+            }
+
+            function $L(t) {
+                return ZL(t, zL)
+            }
+
+            function YL(t) {
+                return ZL(t, PL)
+            }
+
+            function VL(t) {
+                return ZL(t, OL)
+            }
+            GL("identity", cl), GL(wL, al.Z, RL), GL(kL, ll.Z, [RL, kL]), GL(EL, ul.ZP, RL), GL(AL, ul._b, RL), GL(DL, gl, RL), GL(SL, Dl, [RL, BL]), GL(CL, Sl, [RL, BL]), GL(ML, Tl, [RL, LL]), GL("".concat(ML, "-").concat(wL), Tl, [RL, LL]), GL("".concat(ML, "-").concat(kL), Nl, [RL, LL, kL]), GL("".concat(ML, "-").concat(EL), zl, [RL, LL]), GL("".concat(ML, "-").concat(AL), Pl, [RL, LL]), GL("".concat(ML, "-").concat(DL), Rl, [RL, LL]), GL("".concat(FL, "-").concat(wL), Il, [RL, LL]), GL("".concat(FL, "-").concat(kL), jl, [RL, LL, kL]), GL("".concat(FL, "-").concat(EL), ql, [RL, LL]), GL("".concat(FL, "-").concat(AL), Wl, [RL, LL]), GL("".concat(FL, "-").concat(DL), Ul, [RL, LL]), GL(OL, Hl.Z, [PL, OL]), GL(TL, Xl.Z, PL), GL(NL, Gl.Z, PL), GL("bin-ordinal", (function t() {
+                let e = [],
+                    n = [];
+
+                function i(t) {
+                    return null == t || t !== t ? void 0 : n[((0, ol.ZP)(e, t) - 1) % n.length]
+                }
+                return i.domain = function(t) {
+                    return arguments.length ? (e = function(t) {
+                        return UL.call(t, m.He)
+                    }(t), i) : e.slice()
+                }, i.range = function(t) {
+                    return arguments.length ? (n = qL.call(t), i) : n.slice()
+                }, i.tickFormat = function(t, n) {
+                    return (0, Zl.Z)(e[0], (0, m.fj)(e), null == t ? 10 : t, n)
+                }, i.copy = function() {
+                    return t().domain(i.domain()).range(i.range())
+                }, i
+            }), [zL, PL]), GL("ordinal", Jl.Z, zL), GL("band", IL, zL), GL("point", (function() {
+                return jL(IL().paddingInner(1))
+            }), zL);
+
+            function KL(t, e, n) {
+                return Ll(function(t, e) {
+                    const n = r[function(t) {
+                        return "interpolate" + t.toLowerCase().split("-").map((t => t[0].toUpperCase() + t.slice(1))).join("")
+                    }(t)];
+                    return null != e && n && n.gamma ? n.gamma(e) : n
+                }(e || "rgb", n), t)
+            }
+
+            function QL(t) {
+                const e = t.length / 6 | 0,
+                    n = new Array(e);
+                for (let i = 0; i < e;) n[i] = "#" + t.slice(6 * i, 6 * ++i);
+                return n
+            }
+
+            function tB(t, e) {
+                for (const n in t) nB(n, e(t[n]))
+            }
+            const eB = {};
+
+            function nB(t, e) {
+                return t = t && t.toLowerCase(), arguments.length > 1 ? (eB[t] = e, this) : eB[t]
+            }
+            tB({
+                category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
+                category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
+                category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
+                category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
+                tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
+                tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
+                accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
+                dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
+                paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
+                pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
+                pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
+                set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
+                set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
+                set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
+            }, QL), tB({
+                blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
+                greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
+                greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
+                oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
+                purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
+                reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
+                blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
+                bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
+                greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
+                orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
+                purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
+                purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
+                purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
+                redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
+                yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
+                yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
+                yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
+                blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
+                brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
+                purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
+                purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
+                redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
+                redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
+                yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
+                redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
+                redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
+                pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
+                spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
+                viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
+                magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
+                inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
+                plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
+                cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
+                rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
+                sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
+                turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
+                browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
+                tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
+                teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
+                warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
+                goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
+                goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
+                goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
+                lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
+                lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
+                lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
+                lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
+                lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
+                darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
+                darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
+                darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
+                darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
+                darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
+            }, (t => KL(QL(t))));
+
+            function iB(t) {
                 return (0, m.Kn)(t) ? t : {
                     type: t || "pad"
                 }
             }
-            const MF = t => +t || 0,
-                OF = t => ({
+            const rB = t => +t || 0,
+                oB = t => ({
                     top: t,
                     bottom: t,
                     left: t,
                     right: t
                 });
 
-            function TF(t) {
+            function aB(t) {
                 return (0, m.Kn)(t) ? t.signal ? t : {
-                    top: MF(t.top),
-                    bottom: MF(t.bottom),
-                    left: MF(t.left),
-                    right: MF(t.right)
-                } : OF(MF(t))
+                    top: rB(t.top),
+                    bottom: rB(t.bottom),
+                    left: rB(t.left),
+                    right: rB(t.right)
+                } : oB(rB(t))
             }
-            const NF = t => (0, m.Kn)(t) && !(0, m.kJ)(t) ? (0, m.l7)({}, t) : {
+            const sB = t => (0, m.Kn)(t) && !(0, m.kJ)(t) ? (0, m.l7)({}, t) : {
                 value: t
             };
 
-            function zF(t, e, n, i) {
+            function cB(t, e, n, i) {
                 if (null != n) {
                     return (0, m.Kn)(n) && !(0, m.kJ)(n) || (0, m.kJ)(n) && n.length && (0, m.Kn)(n[0]) ? t.update[e] = n : t[i || "enter"][e] = {
                         value: n
                     }, 1
                 }
                 return 0
             }
 
-            function RF(t, e, n) {
-                for (const i in e) zF(t, i, e[i]);
-                for (const i in n) zF(t, i, n[i], "update")
+            function lB(t, e, n) {
+                for (const i in e) cB(t, i, e[i]);
+                for (const i in n) cB(t, i, n[i], "update")
             }
 
-            function PF(t, e, n) {
+            function uB(t, e, n) {
                 for (const i in e) n && (0, m.nr)(n, i) || (t[i] = (0, m.l7)(t[i] || {}, e[i]));
                 return t
             }
 
-            function LF(t, e) {
+            function fB(t, e) {
                 return e && (e.enter && e.enter[t] || e.update && e.update[t])
             }
-            const jF = "mark",
-                BF = "frame",
-                IF = "scope",
-                UF = "axis",
-                qF = "axis-domain",
-                WF = "axis-grid",
-                HF = "axis-label",
-                XF = "axis-tick",
-                JF = "axis-title",
-                GF = "legend",
-                $F = "legend-band",
-                ZF = "legend-entry",
-                YF = "legend-gradient",
-                VF = "legend-label",
-                KF = "legend-symbol",
-                QF = "legend-title",
-                tM = "title",
-                eM = "title-text",
-                nM = "title-subtitle";
+            const dB = "mark",
+                hB = "frame",
+                pB = "scope",
+                mB = "axis",
+                gB = "axis-domain",
+                vB = "axis-grid",
+                yB = "axis-label",
+                bB = "axis-tick",
+                xB = "axis-title",
+                _B = "legend",
+                wB = "legend-band",
+                kB = "legend-entry",
+                EB = "legend-gradient",
+                AB = "legend-label",
+                DB = "legend-symbol",
+                SB = "legend-title",
+                CB = "title",
+                MB = "title-text",
+                FB = "title-subtitle";
 
-            function iM(t, e, n) {
+            function OB(t, e, n) {
                 t[e] = n && n.signal ? {
                     signal: n.signal
                 } : {
                     value: n
                 }
             }
-            const rM = t => (0, m.HD)(t) ? (0, m.m8)(t) : t.signal ? "(".concat(t.signal, ")") : cM(t);
+            const TB = t => (0, m.HD)(t) ? (0, m.m8)(t) : t.signal ? "(".concat(t.signal, ")") : PB(t);
 
-            function oM(t) {
+            function NB(t) {
                 if (null != t.gradient) return function(t) {
                     const e = [t.start, t.stop, t.count].map((t => null == t ? null : (0, m.m8)(t)));
                     for (; e.length && null == (0, m.fj)(e);) e.pop();
-                    return e.unshift(rM(t.gradient)), "gradient(".concat(e.join(","), ")")
+                    return e.unshift(TB(t.gradient)), "gradient(".concat(e.join(","), ")")
                 }(t);
                 let e = t.signal ? "(".concat(t.signal, ")") : t.color ? function(t) {
-                    return t.c ? aM("hcl", t.h, t.c, t.l) : t.h || t.s ? aM("hsl", t.h, t.s, t.l) : t.l || t.a ? aM("lab", t.l, t.a, t.b) : t.r || t.g || t.b ? aM("rgb", t.r, t.g, t.b) : null
-                }(t.color) : null != t.field ? cM(t.field) : void 0 !== t.value ? (0, m.m8)(t.value) : void 0;
+                    return t.c ? RB("hcl", t.h, t.c, t.l) : t.h || t.s ? RB("hsl", t.h, t.s, t.l) : t.l || t.a ? RB("lab", t.l, t.a, t.b) : t.r || t.g || t.b ? RB("rgb", t.r, t.g, t.b) : null
+                }(t.color) : null != t.field ? PB(t.field) : void 0 !== t.value ? (0, m.m8)(t.value) : void 0;
                 return null != t.scale && (e = function(t, e) {
-                    const n = rM(t.scale);
-                    null != t.range ? e = "lerp(_range(".concat(n, "), ").concat(+t.range, ")") : (void 0 !== e && (e = "_scale(".concat(n, ", ").concat(e, ")")), t.band && (e = (e ? e + "+" : "") + "_bandwidth(".concat(n, ")") + (1 === +t.band ? "" : "*" + sM(t.band)), t.extra && (e = "(datum.extra ? _scale(".concat(n, ", datum.extra.value) : ").concat(e, ")"))), null == e && (e = "0"));
+                    const n = TB(t.scale);
+                    null != t.range ? e = "lerp(_range(".concat(n, "), ").concat(+t.range, ")") : (void 0 !== e && (e = "_scale(".concat(n, ", ").concat(e, ")")), t.band && (e = (e ? e + "+" : "") + "_bandwidth(".concat(n, ")") + (1 === +t.band ? "" : "*" + zB(t.band)), t.extra && (e = "(datum.extra ? _scale(".concat(n, ", datum.extra.value) : ").concat(e, ")"))), null == e && (e = "0"));
                     return e
-                }(t, e)), void 0 === e && (e = null), null != t.exponent && (e = "pow(".concat(e, ",").concat(sM(t.exponent), ")")), null != t.mult && (e += "*".concat(sM(t.mult))), null != t.offset && (e += "+".concat(sM(t.offset))), t.round && (e = "round(".concat(e, ")")), e
+                }(t, e)), void 0 === e && (e = null), null != t.exponent && (e = "pow(".concat(e, ",").concat(zB(t.exponent), ")")), null != t.mult && (e += "*".concat(zB(t.mult))), null != t.offset && (e += "+".concat(zB(t.offset))), t.round && (e = "round(".concat(e, ")")), e
             }
-            const aM = (t, e, n, i) => "(".concat(t, "(").concat([e, n, i].map(oM).join(","), ")+'')");
+            const RB = (t, e, n, i) => "(".concat(t, "(").concat([e, n, i].map(NB).join(","), ")+'')");
 
-            function sM(t) {
-                return (0, m.Kn)(t) ? "(" + oM(t) + ")" : t
+            function zB(t) {
+                return (0, m.Kn)(t) ? "(" + NB(t) + ")" : t
             }
 
-            function cM(t) {
-                return lM((0, m.Kn)(t) ? t : {
+            function PB(t) {
+                return LB((0, m.Kn)(t) ? t : {
                     datum: t
                 })
             }
 
-            function lM(t) {
+            function LB(t) {
                 let e, n, i;
                 if (t.signal) e = "datum", i = t.signal;
                 else if (t.group || t.parent) {
                     for (n = Math.max(1, t.level || 1), e = "item"; n-- > 0;) e += ".mark.group";
                     t.parent ? (i = t.parent, e += ".datum") : i = t.group
                 } else t.datum ? (e = "datum", i = t.datum) : (0, m.vU)("Invalid field reference: " + (0, m.m8)(t));
-                return t.signal || (i = (0, m.HD)(i) ? (0, m._k)(i).map(m.m8).join("][") : lM(i)), e + "[" + i + "]"
+                return t.signal || (i = (0, m.HD)(i) ? (0, m._k)(i).map(m.m8).join("][") : LB(i)), e + "[" + i + "]"
             }
 
-            function uM(t, e, n, i, r, o) {
+            function BB(t, e, n, i, r, o) {
                 const a = {};
                 (o = o || {}).encoders = {
                     $encode: a
                 }, t = function(t, e, n, i, r) {
                     const o = {},
                         a = {};
                     let s, c, l, u;
-                    for (c in c = "lineBreak", "text" !== e || null == r[c] || LF(c, t) || iM(o, c, r[c]), ("legend" == n || String(n).startsWith("axis")) && (n = null), u = n === BF ? r.group : n === jF ? (0, m.l7)({}, r.mark, r[e]) : null, u) l = LF(c, t) || ("fill" === c || "stroke" === c) && (LF("fill", t) || LF("stroke", t)), l || iM(o, c, u[c]);
+                    for (c in c = "lineBreak", "text" !== e || null == r[c] || fB(c, t) || OB(o, c, r[c]), ("legend" == n || String(n).startsWith("axis")) && (n = null), u = n === hB ? r.group : n === dB ? (0, m.l7)({}, r.mark, r[e]) : null, u) l = fB(c, t) || ("fill" === c || "stroke" === c) && (fB("fill", t) || fB("stroke", t)), l || OB(o, c, u[c]);
                     for (c in (0, m.IX)(i).forEach((e => {
                             const n = r.style && r.style[e];
-                            for (const i in n) LF(i, t) || iM(o, i, n[i])
+                            for (const i in n) fB(i, t) || OB(o, i, n[i])
                         })), t = (0, m.l7)({}, t), o) u = o[c], u.signal ? (s = s || {})[c] = u : a[c] = u;
                     return t.enter = (0, m.l7)(a, t.enter), s && (t.update = (0, m.l7)(s, t.update)), t
                 }(t, e, n, i, r.config);
-                for (const s in t) a[s] = fM(t[s], e, o, r);
+                for (const s in t) a[s] = IB(t[s], e, o, r);
                 return o
             }
 
-            function fM(t, e, n, i) {
+            function IB(t, e, n, i) {
                 const r = {},
                     o = {};
-                for (const s in t) null != t[s] && (r[s] = dM((a = t[s], (0, m.kJ)(a) ? function(t) {
+                for (const s in t) null != t[s] && (r[s] = jB((a = t[s], (0, m.kJ)(a) ? function(t) {
                     let e = "";
                     return t.forEach((t => {
-                        const n = oM(t);
+                        const n = NB(t);
                         e += t.test ? "(".concat(t.test, ")?").concat(n, ":") : n
                     })), ":" === (0, m.fj)(e) && (e += "null"), e
-                }(a) : oM(a)), i, n, o));
+                }(a) : NB(a)), i, n, o));
                 var a;
                 return {
                     $expr: {
                         marktype: e,
                         channels: r
                     },
                     $fields: Object.keys(o),
                     $output: Object.keys(t)
                 }
             }
 
-            function dM(t, e, n, i) {
-                const r = xC(t, e);
+            function jB(t, e, n, i) {
+                const r = xL(t, e);
                 return r.$fields.forEach((t => i[t] = 1)), (0, m.l7)(n, r.$params), r.$expr
             }
-            const hM = "outer",
-                pM = ["value", "update", "init", "react", "bind"];
+            const UB = "outer",
+                qB = ["value", "update", "init", "react", "bind"];
 
-            function mM(t, e) {
+            function WB(t, e) {
                 (0, m.vU)(t + ' for "outer" push: ' + (0, m.m8)(e))
             }
 
-            function gM(t, e) {
+            function HB(t, e) {
                 const n = t.name;
-                if (t.push === hM) e.signals[n] || mM("No prior signal definition", n), pM.forEach((e => {
-                    void 0 !== t[e] && mM("Invalid property ", e)
+                if (t.push === UB) e.signals[n] || WB("No prior signal definition", n), qB.forEach((e => {
+                    void 0 !== t[e] && WB("Invalid property ", e)
                 }));
                 else {
                     const i = e.addSignal(n, t.value);
                     !1 === t.react && (i.react = !1), t.bind && e.addBinding(n, t.bind)
                 }
             }
 
-            function vM(t, e, n, i) {
+            function XB(t, e, n, i) {
                 this.id = -1, this.type = t, this.value = e, this.params = n, i && (this.parent = i)
             }
 
-            function yM(t, e, n, i) {
-                return new vM(t, e, n, i)
+            function GB(t, e, n, i) {
+                return new XB(t, e, n, i)
             }
 
-            function bM(t, e) {
-                return yM("operator", t, e)
+            function JB(t, e) {
+                return GB("operator", t, e)
             }
 
-            function xM(t) {
+            function ZB(t) {
                 const e = {
                     $ref: t.id
                 };
                 return t.id < 0 && (t.refs = t.refs || []).push(e), e
             }
 
-            function _M(t, e) {
+            function $B(t, e) {
                 return e ? {
                     $field: t,
                     $name: e
                 } : {
                     $field: t
                 }
             }
-            const wM = _M("key");
+            const YB = $B("key");
 
-            function kM(t, e) {
+            function VB(t, e) {
                 return {
                     $compare: t,
                     $order: e
                 }
             }
-            const EM = "descending";
+            const KB = "descending";
 
-            function DM(t, e) {
+            function QB(t, e) {
                 return (t && t.signal ? "$" + t.signal : t || "") + (t && e ? "_" : "") + (e && e.signal ? "$" + e.signal : e || "")
             }
-            const AM = "scope",
-                SM = "view";
+            const tI = "scope",
+                eI = "view";
 
-            function CM(t) {
+            function nI(t) {
                 return t && t.signal
             }
 
-            function FM(t) {
-                if (CM(t)) return !0;
+            function iI(t) {
+                if (nI(t)) return !0;
                 if ((0, m.Kn)(t))
                     for (const e in t)
-                        if (FM(t[e])) return !0;
+                        if (iI(t[e])) return !0;
                 return !1
             }
 
-            function MM(t, e) {
+            function rI(t, e) {
                 return null != t ? t : e
             }
 
-            function OM(t) {
+            function oI(t) {
                 return t && t.signal || t
             }
-            const TM = "timer";
+            const aI = "timer";
 
-            function NM(t, e) {
-                return (t.merge ? zM : t.stream ? RM : t.type ? PM : (0, m.vU)("Invalid stream specification: " + (0, m.m8)(t)))(t, e)
+            function sI(t, e) {
+                return (t.merge ? cI : t.stream ? lI : t.type ? uI : (0, m.vU)("Invalid stream specification: " + (0, m.m8)(t)))(t, e)
             }
 
-            function zM(t, e) {
-                const n = t.merge.map((t => NM(t, e))),
-                    i = LM({
+            function cI(t, e) {
+                const n = t.merge.map((t => sI(t, e))),
+                    i = fI({
                         merge: n
                     }, t, e);
                 return e.addStream(i).id
             }
 
-            function RM(t, e) {
-                const n = LM({
-                    stream: NM(t.stream, e)
+            function lI(t, e) {
+                const n = fI({
+                    stream: sI(t.stream, e)
                 }, t, e);
                 return e.addStream(n).id
             }
 
-            function PM(t, e) {
+            function uI(t, e) {
                 let n;
-                t.type === TM ? (n = e.event(TM, t.throttle), t = {
+                t.type === aI ? (n = e.event(aI, t.throttle), t = {
                     between: t.between,
                     filter: t.filter
                 }) : n = e.event(function(t) {
-                    return t === AM ? SM : t || SM
+                    return t === tI ? eI : t || eI
                 }(t.source), t.type);
-                const i = LM({
+                const i = fI({
                     stream: n
                 }, t, e);
                 return 1 === Object.keys(i).length ? n : e.addStream(i).id
             }
 
-            function LM(t, e, n) {
+            function fI(t, e, n) {
                 let i = e.between;
-                return i && (2 !== i.length && (0, m.vU)('Stream "between" parameter must have 2 entries: ' + (0, m.m8)(e)), t.between = [NM(i[0], n), NM(i[1], n)]), i = e.filter ? [].concat(e.filter) : [], (e.marktype || e.markname || e.markrole) && i.push(function(t, e, n) {
+                return i && (2 !== i.length && (0, m.vU)('Stream "between" parameter must have 2 entries: ' + (0, m.m8)(e)), t.between = [sI(i[0], n), sI(i[1], n)]), i = e.filter ? [].concat(e.filter) : [], (e.marktype || e.markname || e.markrole) && i.push(function(t, e, n) {
                     const i = "event.item";
                     return i + (t && "*" !== t ? "&&" + i + ".mark.marktype==='" + t + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (e ? "&&" + i + ".mark.name==='" + e + "'" : "")
-                }(e.marktype, e.markname, e.markrole)), e.source === AM && i.push("inScope(event.item)"), i.length && (t.filter = xC("(" + i.join(")&&(") + ")", n).$expr), null != (i = e.throttle) && (t.throttle = +i), null != (i = e.debounce) && (t.debounce = +i), e.consume && (t.consume = !0), t
+                }(e.marktype, e.markname, e.markrole)), e.source === tI && i.push("inScope(event.item)"), i.length && (t.filter = xL("(" + i.join(")&&(") + ")", n).$expr), null != (i = e.throttle) && (t.throttle = +i), null != (i = e.debounce) && (t.debounce = +i), e.consume && (t.consume = !0), t
             }
-            const jM = {
+            const dI = {
                 code: "_.$value",
                 ast: {
                     type: "Identifier",
                     value: "value"
                 }
             };
 
-            function BM(t, e, n) {
+            function hI(t, e, n) {
                 const i = t.encode,
                     r = {
                         target: n
                     };
                 let o = t.events,
                     a = t.update,
                     s = [];
-                o || (0, m.vU)("Signal update missing events specification."), (0, m.HD)(o) && (o = (0, CF.r)(o, e.isSubscope() ? AM : SM)), o = (0, m.IX)(o).filter((t => t.signal || t.scale ? (s.push(t), 0) : 1)), s.length > 1 && (s = [IM(s)]), o.length && s.push(o.length > 1 ? {
+                o || (0, m.vU)("Signal update missing events specification."), (0, m.HD)(o) && (o = (0, _L.r)(o, e.isSubscope() ? tI : eI)), o = (0, m.IX)(o).filter((t => t.signal || t.scale ? (s.push(t), 0) : 1)), s.length > 1 && (s = [pI(s)]), o.length && s.push(o.length > 1 ? {
                     merge: o
-                } : o[0]), null != i && (a && (0, m.vU)("Signal encode and update are mutually exclusive."), a = "encode(item()," + (0, m.m8)(i) + ")"), r.update = (0, m.HD)(a) ? xC(a, e) : null != a.expr ? xC(a.expr, e) : null != a.value ? a.value : null != a.signal ? {
-                    $expr: jM,
+                } : o[0]), null != i && (a && (0, m.vU)("Signal encode and update are mutually exclusive."), a = "encode(item()," + (0, m.m8)(i) + ")"), r.update = (0, m.HD)(a) ? xL(a, e) : null != a.expr ? xL(a.expr, e) : null != a.value ? a.value : null != a.signal ? {
+                    $expr: dI,
                     $params: {
                         $value: e.signalRef(a.signal)
                     }
                 } : (0, m.vU)("Invalid signal update specification."), t.force && (r.options = {
                     force: !0
                 }), s.forEach((t => e.addUpdate((0, m.l7)(function(t, e) {
                     return {
-                        source: t.signal ? e.signalRef(t.signal) : t.scale ? e.scaleRef(t.scale) : NM(t, e)
+                        source: t.signal ? e.signalRef(t.signal) : t.scale ? e.scaleRef(t.scale) : sI(t, e)
                     }
                 }(t, e), r))))
             }
 
-            function IM(t) {
+            function pI(t) {
                 return {
                     signal: "[" + t.map((t => t.scale ? 'scale("' + t.scale + '")' : t.signal)) + "]"
                 }
             }
-            const UM = t => (e, n, i) => yM(t, n, e || void 0, i),
-                qM = UM("aggregate"),
-                WM = UM("axisticks"),
-                HM = UM("bound"),
-                XM = UM("collect"),
-                JM = UM("compare"),
-                GM = UM("datajoin"),
-                $M = UM("encode"),
-                ZM = UM("expression"),
-                YM = UM("facet"),
-                VM = UM("field"),
-                KM = UM("key"),
-                QM = UM("legendentries"),
-                tO = UM("load"),
-                eO = UM("mark"),
-                nO = UM("multiextent"),
-                iO = UM("multivalues"),
-                rO = UM("overlap"),
-                oO = UM("params"),
-                aO = UM("prefacet"),
-                sO = UM("projection"),
-                cO = UM("proxy"),
-                lO = UM("relay"),
-                uO = UM("render"),
-                fO = UM("scale"),
-                dO = UM("sieve"),
-                hO = UM("sortitems"),
-                pO = UM("viewlayout"),
-                mO = UM("values");
-            let gO = 0;
-            const vO = {
+            const mI = t => (e, n, i) => GB(t, n, e || void 0, i),
+                gI = mI("aggregate"),
+                vI = mI("axisticks"),
+                yI = mI("bound"),
+                bI = mI("collect"),
+                xI = mI("compare"),
+                _I = mI("datajoin"),
+                wI = mI("encode"),
+                kI = mI("expression"),
+                EI = mI("facet"),
+                AI = mI("field"),
+                DI = mI("key"),
+                SI = mI("legendentries"),
+                CI = mI("load"),
+                MI = mI("mark"),
+                FI = mI("multiextent"),
+                OI = mI("multivalues"),
+                TI = mI("overlap"),
+                NI = mI("params"),
+                RI = mI("prefacet"),
+                zI = mI("projection"),
+                PI = mI("proxy"),
+                LI = mI("relay"),
+                BI = mI("render"),
+                II = mI("scale"),
+                jI = mI("sieve"),
+                UI = mI("sortitems"),
+                qI = mI("viewlayout"),
+                WI = mI("values");
+            let HI = 0;
+            const XI = {
                 min: "min",
                 max: "max",
                 count: "sum"
             };
 
-            function yO(t, e) {
+            function GI(t, e) {
                 const n = e.getScale(t.name).params;
                 let i;
-                for (i in n.domain = wO(t.domain, t, e), null != t.range && (n.range = MO(t, e, n)), null != t.interpolate && function(t, e) {
-                        e.interpolate = bO(t.type || t), null != t.gamma && (e.interpolateGamma = bO(t.gamma))
-                    }(t.interpolate, n), null != t.nice && (n.nice = function(t) {
-                        return (0, m.Kn)(t) ? {
-                            interval: bO(t.interval),
-                            step: bO(t.step)
-                        } : bO(t)
-                    }(t.nice)), null != t.bins && (n.bins = function(t, e) {
-                        return t.signal || (0, m.kJ)(t) ? xO(t, e) : e.objectProperty(t)
-                    }(t.bins, e)), t)(0, m.nr)(n, i) || "name" === i || (n[i] = bO(t[i], e))
+                for (i in n.domain = YI(t.domain, t, e), null != t.range && (n.range = rj(t, e, n)), null != t.interpolate && function(t, e) {
+                        e.interpolate = JI(t.type || t), null != t.gamma && (e.interpolateGamma = JI(t.gamma))
+                    }(t.interpolate, n), null != t.nice && (n.nice = function(t, e) {
+                        return t.signal ? e.signalRef(t.signal) : (0, m.Kn)(t) ? {
+                            interval: JI(t.interval),
+                            step: JI(t.step)
+                        } : JI(t)
+                    }(t.nice, e)), null != t.bins && (n.bins = function(t, e) {
+                        return t.signal || (0, m.kJ)(t) ? ZI(t, e) : e.objectProperty(t)
+                    }(t.bins, e)), t)(0, m.nr)(n, i) || "name" === i || (n[i] = JI(t[i], e))
             }
 
-            function bO(t, e) {
+            function JI(t, e) {
                 return (0, m.Kn)(t) ? t.signal ? e.signalRef(t.signal) : (0, m.vU)("Unsupported object: " + (0, m.m8)(t)) : t
             }
 
-            function xO(t, e) {
-                return t.signal ? e.signalRef(t.signal) : t.map((t => bO(t, e)))
+            function ZI(t, e) {
+                return t.signal ? e.signalRef(t.signal) : t.map((t => JI(t, e)))
             }
 
-            function _O(t) {
+            function $I(t) {
                 (0, m.vU)("Can not find data set: " + (0, m.m8)(t))
             }
 
-            function wO(t, e, n) {
-                if (t) return t.signal ? n.signalRef(t.signal) : ((0, m.kJ)(t) ? kO : t.fields ? DO : EO)(t, e, n);
+            function YI(t, e, n) {
+                if (t) return t.signal ? n.signalRef(t.signal) : ((0, m.kJ)(t) ? VI : t.fields ? QI : KI)(t, e, n);
                 null == e.domainMin && null == e.domainMax || (0, m.vU)("No scale domain defined for domainMin/domainMax to override.")
             }
 
-            function kO(t, e, n) {
-                return t.map((t => bO(t, n)))
+            function VI(t, e, n) {
+                return t.map((t => JI(t, n)))
             }
 
-            function EO(t, e, n) {
+            function KI(t, e, n) {
                 const i = n.getData(t.data);
-                return i || _O(t.data), uf(e.type) ? i.valuesRef(n, t.field, SO(t.sort, !1)) : pf(e.type) ? i.domainRef(n, t.field) : i.extentRef(n, t.field)
+                return i || $I(t.data), $L(e.type) ? i.valuesRef(n, t.field, ej(t.sort, !1)) : VL(e.type) ? i.domainRef(n, t.field) : i.extentRef(n, t.field)
             }
 
-            function DO(t, e, n) {
+            function QI(t, e, n) {
                 const i = t.data,
                     r = t.fields.reduce(((t, e) => (e = (0, m.HD)(e) ? {
                         data: i,
                         field: e
                     } : (0, m.kJ)(e) || e.signal ? function(t, e) {
-                        const n = "_:vega:_" + gO++,
-                            i = XM({});
+                        const n = "_:vega:_" + HI++,
+                            i = bI({});
                         if ((0, m.kJ)(t)) i.value = {
                             $ingest: t
                         };
                         else if (t.signal) {
                             const r = "setdata(" + (0, m.m8)(n) + "," + t.signal + ")";
                             i.params.input = e.signalRef(r)
                         }
-                        return e.addDataPipeline(n, [i, dO({})]), {
+                        return e.addDataPipeline(n, [i, jI({})]), {
                             data: n,
                             field: "data"
                         }
                     }(e, n) : e, t.push(e), t)), []);
-                return (uf(e.type) ? AO : pf(e.type) ? CO : FO)(t, n, r)
+                return ($L(e.type) ? tj : VL(e.type) ? nj : ij)(t, n, r)
             }
 
-            function AO(t, e, n) {
-                const i = SO(t.sort, !0);
+            function tj(t, e, n) {
+                const i = ej(t.sort, !0);
                 let r, o;
                 const a = n.map((t => {
                         const n = e.getData(t.data);
-                        return n || _O(t.data), n.countsRef(e, t.field, i)
+                        return n || $I(t.data), n.countsRef(e, t.field, i)
                     })),
                     s = {
-                        groupby: wM,
+                        groupby: YB,
                         pulse: a
                     };
-                i && (r = i.op || "count", o = i.field ? DM(r, i.field) : "count", s.ops = [vO[r]], s.fields = [e.fieldRef(o)], s.as = [o]), r = e.add(qM(s));
-                const c = e.add(XM({
-                    pulse: xM(r)
+                i && (r = i.op || "count", o = i.field ? QB(r, i.field) : "count", s.ops = [XI[r]], s.fields = [e.fieldRef(o)], s.as = [o]), r = e.add(gI(s));
+                const c = e.add(bI({
+                    pulse: ZB(r)
                 }));
-                return o = e.add(mO({
-                    field: wM,
+                return o = e.add(WI({
+                    field: YB,
                     sort: e.sortRef(i),
-                    pulse: xM(c)
-                })), xM(o)
+                    pulse: ZB(c)
+                })), ZB(o)
             }
 
-            function SO(t, e) {
-                return t && (t.field || t.op ? t.field || "count" === t.op ? e && t.field && t.op && !vO[t.op] && (0, m.vU)("Multiple domain scales can not be sorted using " + t.op) : (0, m.vU)("No field provided for sort aggregate op: " + t.op) : (0, m.Kn)(t) ? t.field = "key" : t = {
+            function ej(t, e) {
+                return t && (t.field || t.op ? t.field || "count" === t.op ? e && t.field && t.op && !XI[t.op] && (0, m.vU)("Multiple domain scales can not be sorted using " + t.op) : (0, m.vU)("No field provided for sort aggregate op: " + t.op) : (0, m.Kn)(t) ? t.field = "key" : t = {
                     field: "key"
                 }), t
             }
 
-            function CO(t, e, n) {
+            function nj(t, e, n) {
                 const i = n.map((t => {
                     const n = e.getData(t.data);
-                    return n || _O(t.data), n.domainRef(e, t.field)
+                    return n || $I(t.data), n.domainRef(e, t.field)
                 }));
-                return xM(e.add(iO({
+                return ZB(e.add(OI({
                     values: i
                 })))
             }
 
-            function FO(t, e, n) {
+            function ij(t, e, n) {
                 const i = n.map((t => {
                     const n = e.getData(t.data);
-                    return n || _O(t.data), n.extentRef(e, t.field)
+                    return n || $I(t.data), n.extentRef(e, t.field)
                 }));
-                return xM(e.add(nO({
+                return ZB(e.add(FI({
                     extents: i
                 })))
             }
 
-            function MO(t, e, n) {
+            function rj(t, e, n) {
                 const i = e.config.range;
                 let r = t.range;
                 if (r.signal) return e.signalRef(r.signal);
                 if ((0, m.HD)(r)) {
-                    if (i && (0, m.nr)(i, r)) return MO(t = (0, m.l7)({}, t, {
+                    if (i && (0, m.nr)(i, r)) return rj(t = (0, m.l7)({}, t, {
                         range: i[r]
                     }), e, n);
                     "width" === r ? r = [0, {
                         signal: "width"
-                    }] : "height" === r ? r = uf(t.type) ? [0, {
+                    }] : "height" === r ? r = $L(t.type) ? [0, {
                         signal: "height"
                     }] : [{
                         signal: "height"
                     }, 0] : (0, m.vU)("Unrecognized scale range value: " + (0, m.m8)(r))
                 } else {
-                    if (r.scheme) return n.scheme = (0, m.kJ)(r.scheme) ? xO(r.scheme, e) : bO(r.scheme, e), r.extent && (n.schemeExtent = xO(r.extent, e)), void(r.count && (n.schemeCount = bO(r.count, e)));
-                    if (r.step) return void(n.rangeStep = bO(r.step, e));
-                    if (uf(t.type) && !(0, m.kJ)(r)) return wO(r, t, e);
+                    if (r.scheme) return n.scheme = (0, m.kJ)(r.scheme) ? ZI(r.scheme, e) : JI(r.scheme, e), r.extent && (n.schemeExtent = ZI(r.extent, e)), void(r.count && (n.schemeCount = JI(r.count, e)));
+                    if (r.step) return void(n.rangeStep = JI(r.step, e));
+                    if ($L(t.type) && !(0, m.kJ)(r)) return YI(r, t, e);
                     (0, m.kJ)(r) || (0, m.vU)("Unsupported range type: " + (0, m.m8)(r))
                 }
-                return r.map((t => ((0, m.kJ)(t) ? xO : bO)(t, e)))
+                return r.map((t => ((0, m.kJ)(t) ? ZI : JI)(t, e)))
             }
 
-            function OO(t, e, n) {
-                return (0, m.kJ)(t) ? t.map((t => OO(t, e, n))) : (0, m.Kn)(t) ? t.signal ? n.signalRef(t.signal) : "fit" === e ? t : (0, m.vU)("Unsupported parameter object: " + (0, m.m8)(t)) : t
+            function oj(t, e, n) {
+                return (0, m.kJ)(t) ? t.map((t => oj(t, e, n))) : (0, m.Kn)(t) ? t.signal ? n.signalRef(t.signal) : "fit" === e ? t : (0, m.vU)("Unsupported parameter object: " + (0, m.m8)(t)) : t
             }
-            const TO = "top",
-                NO = "left",
-                zO = "right",
-                RO = "bottom",
-                PO = "center",
-                LO = "vertical",
-                jO = "start",
-                BO = "end",
-                IO = "index",
-                UO = "label",
-                qO = "offset",
-                WO = "perc",
-                HO = "perc2",
-                XO = "value",
-                JO = "guide-label",
-                GO = "guide-title",
-                $O = "group-title",
-                ZO = "group-subtitle",
-                YO = "symbol",
-                VO = "gradient",
-                KO = "discrete",
-                QO = "size",
-                tT = [QO, "shape", "fill", "stroke", "strokeWidth", "strokeDash", "opacity"],
-                eT = {
+            const aj = "top",
+                sj = "left",
+                cj = "right",
+                lj = "bottom",
+                uj = "center",
+                fj = "vertical",
+                dj = "start",
+                hj = "end",
+                pj = "index",
+                mj = "label",
+                gj = "offset",
+                vj = "perc",
+                yj = "perc2",
+                bj = "value",
+                xj = "guide-label",
+                _j = "guide-title",
+                wj = "group-title",
+                kj = "group-subtitle",
+                Ej = "symbol",
+                Aj = "gradient",
+                Dj = "discrete",
+                Sj = "size",
+                Cj = [Sj, "shape", "fill", "stroke", "strokeWidth", "strokeDash", "opacity"],
+                Mj = {
                     name: 1,
                     style: 1,
                     interactive: 1
                 },
-                nT = {
+                Fj = {
                     value: 0
                 },
-                iT = {
+                Oj = {
                     value: 1
                 },
-                rT = "group",
-                oT = "rect",
-                aT = "rule",
-                sT = "symbol",
-                cT = "text";
+                Tj = "group",
+                Nj = "rect",
+                Rj = "rule",
+                zj = "symbol",
+                Pj = "text";
 
-            function lT(t) {
-                return t.type = rT, t.interactive = t.interactive || !1, t
+            function Lj(t) {
+                return t.type = Tj, t.interactive = t.interactive || !1, t
             }
 
-            function uT(t, e) {
-                const n = (n, i) => MM(t[n], MM(e[n], i));
-                return n.isVertical = n => LO === MM(t.direction, e.direction || (n ? e.symbolDirection : e.gradientDirection)), n.gradientLength = () => MM(t.gradientLength, e.gradientLength || e.gradientWidth), n.gradientThickness = () => MM(t.gradientThickness, e.gradientThickness || e.gradientHeight), n.entryColumns = () => MM(t.columns, MM(e.columns, +n.isVertical(!0))), n
+            function Bj(t, e) {
+                const n = (n, i) => rI(t[n], rI(e[n], i));
+                return n.isVertical = n => fj === rI(t.direction, e.direction || (n ? e.symbolDirection : e.gradientDirection)), n.gradientLength = () => rI(t.gradientLength, e.gradientLength || e.gradientWidth), n.gradientThickness = () => rI(t.gradientThickness, e.gradientThickness || e.gradientHeight), n.entryColumns = () => rI(t.columns, rI(e.columns, +n.isVertical(!0))), n
             }
 
-            function fT(t, e) {
+            function Ij(t, e) {
                 const n = e && (e.update && e.update[t] || e.enter && e.enter[t]);
                 return n && n.signal ? n : n ? n.value : null
             }
 
-            function dT(t, e, n) {
-                return "item.anchor === '".concat(jO, "' ? ").concat(t, " : item.anchor === '").concat(BO, "' ? ").concat(e, " : ").concat(n)
+            function jj(t, e, n) {
+                return "item.anchor === '".concat(dj, "' ? ").concat(t, " : item.anchor === '").concat(hj, "' ? ").concat(e, " : ").concat(n)
             }
-            const hT = dT((0, m.m8)(NO), (0, m.m8)(zO), (0, m.m8)(PO));
+            const Uj = jj((0, m.m8)(sj), (0, m.m8)(cj), (0, m.m8)(uj));
 
-            function pT(t, e) {
+            function qj(t, e) {
                 return e ? t ? (0, m.Kn)(t) ? Object.assign({}, t, {
-                    offset: pT(t.offset, e)
+                    offset: qj(t.offset, e)
                 }) : {
                     value: t,
                     offset: e
                 } : e : t
             }
 
-            function mT(t, e) {
-                return e ? (t.name = e.name, t.style = e.style || t.style, t.interactive = !!e.interactive, t.encode = PF(t.encode, e, eT)) : t.interactive = !1, t
+            function Wj(t, e) {
+                return e ? (t.name = e.name, t.style = e.style || t.style, t.interactive = !!e.interactive, t.encode = uB(t.encode, e, Mj)) : t.interactive = !1, t
             }
 
-            function gT(t, e, n, i) {
-                const r = uT(t, n),
+            function Hj(t, e, n, i) {
+                const r = Bj(t, n),
                     o = r.isVertical(),
                     a = r.gradientThickness(),
                     s = r.gradientLength();
                 let c, l, u, f, d;
                 o ? (l = [0, 1], u = [0, 0], f = a, d = s) : (l = [0, 0], u = [1, 0], f = s, d = a);
                 const h = {
                     enter: c = {
-                        opacity: nT,
-                        x: nT,
-                        y: nT,
-                        width: NF(f),
-                        height: NF(d)
+                        opacity: Fj,
+                        x: Fj,
+                        y: Fj,
+                        width: sB(f),
+                        height: sB(d)
                     },
                     update: (0, m.l7)({}, c, {
-                        opacity: iT,
+                        opacity: Oj,
                         fill: {
                             gradient: e,
                             start: l,
                             stop: u
                         }
                     }),
                     exit: {
-                        opacity: nT
+                        opacity: Fj
                     }
                 };
-                return RF(h, {
+                return lB(h, {
                     stroke: r("gradientStrokeColor"),
                     strokeWidth: r("gradientStrokeWidth")
                 }, {
                     opacity: r("gradientOpacity")
-                }), mT({
-                    type: oT,
-                    role: YF,
+                }), Wj({
+                    type: Nj,
+                    role: EB,
                     encode: h
                 }, i)
             }
 
-            function vT(t, e, n, i, r) {
-                const o = uT(t, n),
+            function Xj(t, e, n, i, r) {
+                const o = Bj(t, n),
                     a = o.isVertical(),
                     s = o.gradientThickness(),
                     c = o.gradientLength();
                 let l, u, f, d, h = "";
                 a ? (l = "y", f = "y2", u = "x", d = "width", h = "1-") : (l = "x", f = "x2", u = "y", d = "height");
                 const p = {
-                    opacity: nT,
+                    opacity: Fj,
                     fill: {
                         scale: e,
-                        field: XO
+                        field: bj
                     }
                 };
                 p[l] = {
-                    signal: h + "datum." + WO,
+                    signal: h + "datum." + vj,
                     mult: c
-                }, p[u] = nT, p[f] = {
-                    signal: h + "datum." + HO,
+                }, p[u] = Fj, p[f] = {
+                    signal: h + "datum." + yj,
                     mult: c
-                }, p[d] = NF(s);
+                }, p[d] = sB(s);
                 const g = {
                     enter: p,
                     update: (0, m.l7)({}, p, {
-                        opacity: iT
+                        opacity: Oj
                     }),
                     exit: {
-                        opacity: nT
+                        opacity: Fj
                     }
                 };
-                return RF(g, {
+                return lB(g, {
                     stroke: o("gradientStrokeColor"),
                     strokeWidth: o("gradientStrokeWidth")
                 }, {
                     opacity: o("gradientOpacity")
-                }), mT({
-                    type: oT,
-                    role: $F,
-                    key: XO,
+                }), Wj({
+                    type: Nj,
+                    role: wB,
+                    key: bj,
                     from: r,
                     encode: g
                 }, i)
             }
-            const yT = "datum.".concat(WO, '<=0?"').concat(NO, '":datum.').concat(WO, '>=1?"').concat(zO, '":"').concat(PO, '"'),
-                bT = "datum.".concat(WO, '<=0?"').concat(RO, '":datum.').concat(WO, '>=1?"').concat(TO, '":"').concat("middle", '"');
+            const Gj = "datum.".concat(vj, '<=0?"').concat(sj, '":datum.').concat(vj, '>=1?"').concat(cj, '":"').concat(uj, '"'),
+                Jj = "datum.".concat(vj, '<=0?"').concat(lj, '":datum.').concat(vj, '>=1?"').concat(aj, '":"').concat("middle", '"');
 
-            function xT(t, e, n, i) {
-                const r = uT(t, e),
+            function Zj(t, e, n, i) {
+                const r = Bj(t, e),
                     o = r.isVertical(),
-                    a = NF(r.gradientThickness()),
+                    a = sB(r.gradientThickness()),
                     s = r.gradientLength();
                 let c, l, u, f, d = r("labelOverlap"),
                     h = "";
                 const p = {
                     enter: c = {
-                        opacity: nT
+                        opacity: Fj
                     },
                     update: l = {
-                        opacity: iT,
+                        opacity: Oj,
                         text: {
-                            field: UO
+                            field: mj
                         }
                     },
                     exit: {
-                        opacity: nT
+                        opacity: Fj
                     }
                 };
-                return RF(p, {
+                return lB(p, {
                     fill: r("labelColor"),
                     fillOpacity: r("labelOpacity"),
                     font: r("labelFont"),
                     fontSize: r("labelFontSize"),
                     fontStyle: r("labelFontStyle"),
                     fontWeight: r("labelFontWeight"),
-                    limit: MM(t.labelLimit, e.gradientLabelLimit)
+                    limit: rI(t.labelLimit, e.gradientLabelLimit)
                 }), o ? (c.align = {
                     value: "left"
                 }, c.baseline = l.baseline = {
-                    signal: bT
+                    signal: Jj
                 }, u = "y", f = "x", h = "1-") : (c.align = l.align = {
-                    signal: yT
+                    signal: Gj
                 }, c.baseline = {
                     value: "top"
                 }, u = "x", f = "y"), c[u] = l[u] = {
-                    signal: h + "datum." + WO,
+                    signal: h + "datum." + vj,
                     mult: s
-                }, c[f] = l[f] = a, a.offset = MM(t.labelOffset, e.gradientLabelOffset) || 0, d = d ? {
+                }, c[f] = l[f] = a, a.offset = rI(t.labelOffset, e.gradientLabelOffset) || 0, d = d ? {
                     separation: r("labelSeparation"),
                     method: d,
-                    order: "datum." + IO
-                } : void 0, mT({
-                    type: cT,
-                    role: VF,
-                    style: JO,
-                    key: XO,
+                    order: "datum." + pj
+                } : void 0, Wj({
+                    type: Pj,
+                    role: AB,
+                    style: xj,
+                    key: bj,
                     from: i,
                     encode: p,
                     overlap: d
                 }, n)
             }
 
-            function _T(t, e, n, i, r) {
-                const o = uT(t, e),
+            function $j(t, e, n, i, r) {
+                const o = Bj(t, e),
                     a = n.entries,
                     s = !(!a || !a.interactive),
                     c = a ? a.name : void 0,
                     l = o("clipHeight"),
                     u = o("symbolOffset"),
                     f = {
                         data: "value"
                     },
-                    d = "(".concat(r, ") ? datum.").concat(qO, " : datum.").concat(QO),
-                    h = l ? NF(l) : {
-                        field: QO
+                    d = "(".concat(r, ") ? datum.").concat(gj, " : datum.").concat(Sj),
+                    h = l ? sB(l) : {
+                        field: Sj
                     },
-                    p = "datum.".concat(IO),
+                    p = "datum.".concat(pj),
                     m = "max(1, ".concat(r, ")");
                 let g, v, y, b, x;
                 h.mult = .5, g = {
                     enter: v = {
-                        opacity: nT,
+                        opacity: Fj,
                         x: {
                             signal: d,
                             mult: .5,
                             offset: u
                         },
                         y: h
                     },
                     update: y = {
-                        opacity: iT,
+                        opacity: Oj,
                         x: v.x,
                         y: v.y
                     },
                     exit: {
-                        opacity: nT
+                        opacity: Fj
                     }
                 };
                 let _ = null,
                     w = null;
-                t.fill || (_ = e.symbolBaseFillColor, w = e.symbolBaseStrokeColor), RF(g, {
+                t.fill || (_ = e.symbolBaseFillColor, w = e.symbolBaseStrokeColor), lB(g, {
                     fill: o("symbolFillColor", _),
                     shape: o("symbolType"),
                     size: o("symbolSize"),
                     stroke: o("symbolStrokeColor", w),
                     strokeDash: o("symbolDash"),
                     strokeDashOffset: o("symbolDashOffset"),
                     strokeWidth: o("symbolStrokeWidth")
                 }, {
                     opacity: o("symbolOpacity")
-                }), tT.forEach((e => {
+                }), Cj.forEach((e => {
                     t[e] && (y[e] = v[e] = {
                         scale: t[e],
-                        field: XO
+                        field: bj
                     })
                 }));
-                const k = mT({
-                        type: sT,
-                        role: KF,
-                        key: XO,
+                const k = Wj({
+                        type: zj,
+                        role: DB,
+                        key: bj,
                         from: f,
                         clip: !!l || void 0,
                         encode: g
                     }, n.symbols),
-                    E = NF(u);
+                    E = sB(u);
                 E.offset = o("labelOffset"), g = {
                     enter: v = {
-                        opacity: nT,
+                        opacity: Fj,
                         x: {
                             signal: d,
                             offset: E
                         },
                         y: h
                     },
                     update: y = {
-                        opacity: iT,
+                        opacity: Oj,
                         text: {
-                            field: UO
+                            field: mj
                         },
                         x: v.x,
                         y: v.y
                     },
                     exit: {
-                        opacity: nT
+                        opacity: Fj
                     }
-                }, RF(g, {
+                }, lB(g, {
                     align: o("labelAlign"),
                     baseline: o("labelBaseline"),
                     fill: o("labelColor"),
                     fillOpacity: o("labelOpacity"),
                     font: o("labelFont"),
                     fontSize: o("labelFontSize"),
                     fontStyle: o("labelFontStyle"),
                     fontWeight: o("labelFontWeight"),
                     limit: o("labelLimit")
                 });
-                const D = mT({
-                    type: cT,
-                    role: VF,
-                    style: JO,
-                    key: XO,
+                const A = Wj({
+                    type: Pj,
+                    role: AB,
+                    style: xj,
+                    key: bj,
                     from: f,
                     encode: g
                 }, n.labels);
                 return g = {
                     enter: {
                         noBound: {
                             value: !l
                         },
-                        width: nT,
-                        height: l ? NF(l) : nT,
-                        opacity: nT
+                        width: Fj,
+                        height: l ? sB(l) : Fj,
+                        opacity: Fj
                     },
                     exit: {
-                        opacity: nT
+                        opacity: Fj
                     },
                     update: y = {
-                        opacity: iT,
+                        opacity: Oj,
                         row: {
                             signal: null
                         },
                         column: {
                             signal: null
                         }
                     }
                 }, o.isVertical(!0) ? (b = "ceil(item.mark.items.length / ".concat(m, ")"), y.row.signal = "".concat(p, "%").concat(b), y.column.signal = "floor(".concat(p, " / ").concat(b, ")"), x = {
                     field: ["row", p]
                 }) : (y.row.signal = "floor(".concat(p, " / ").concat(m, ")"), y.column.signal = "".concat(p, " % ").concat(m), x = {
                     field: p
-                }), y.column.signal = "(".concat(r, ")?").concat(y.column.signal, ":").concat(p), lT({
-                    role: IF,
+                }), y.column.signal = "(".concat(r, ")?").concat(y.column.signal, ":").concat(p), Lj({
+                    role: pB,
                     from: i = {
                         facet: {
                             data: i,
                             name: "value",
-                            groupby: IO
+                            groupby: pj
                         }
                     },
-                    encode: PF(g, a, eT),
-                    marks: [k, D],
+                    encode: uB(g, a, Mj),
+                    marks: [k, A],
                     name: c,
                     interactive: s,
                     sort: x
                 })
             }
-            const wT = 'item.orient === "left"',
-                kT = 'item.orient === "right"',
-                ET = "(".concat(wT, " || ").concat(kT, ")"),
-                DT = "datum.vgrad && ".concat(ET),
-                AT = dT('"top"', '"bottom"', '"middle"'),
-                ST = dT('"right"', '"left"', '"center"'),
-                CT = "datum.vgrad && ".concat(kT, " ? (").concat(ST, ") : (").concat(ET, " && !(datum.vgrad && ").concat(wT, ')) ? "left" : ').concat(hT),
-                FT = "item._anchor || (".concat(ET, ' ? "middle" : "start")'),
-                MT = "".concat(DT, " ? (").concat(wT, " ? -90 : 90) : 0"),
-                OT = "".concat(ET, " ? (datum.vgrad ? (").concat(kT, ' ? "bottom" : "top") : ').concat(AT, ') : "top"');
+            const Yj = 'item.orient === "left"',
+                Vj = 'item.orient === "right"',
+                Kj = "(".concat(Yj, " || ").concat(Vj, ")"),
+                Qj = "datum.vgrad && ".concat(Kj),
+                tU = jj('"top"', '"bottom"', '"middle"'),
+                eU = jj('"right"', '"left"', '"center"'),
+                nU = "datum.vgrad && ".concat(Vj, " ? (").concat(eU, ") : (").concat(Kj, " && !(datum.vgrad && ").concat(Yj, ')) ? "left" : ').concat(Uj),
+                iU = "item._anchor || (".concat(Kj, ' ? "middle" : "start")'),
+                rU = "".concat(Qj, " ? (").concat(Yj, " ? -90 : 90) : 0"),
+                oU = "".concat(Kj, " ? (datum.vgrad ? (").concat(Vj, ' ? "bottom" : "top") : ').concat(tU, ') : "top"');
 
-            function TT(t, e) {
+            function aU(t, e) {
                 let n;
-                return (0, m.Kn)(t) && (t.signal ? n = t.signal : t.path ? n = "pathShape(" + NT(t.path) + ")" : t.sphere && (n = "geoShape(" + NT(t.sphere) + ', {type: "Sphere"})')), n ? e.signalRef(n) : !!t
+                return (0, m.Kn)(t) && (t.signal ? n = t.signal : t.path ? n = "pathShape(" + sU(t.path) + ")" : t.sphere && (n = "geoShape(" + sU(t.sphere) + ', {type: "Sphere"})')), n ? e.signalRef(n) : !!t
             }
 
-            function NT(t) {
+            function sU(t) {
                 return (0, m.Kn)(t) && t.signal ? t.signal : (0, m.m8)(t)
             }
 
-            function zT(t) {
+            function cU(t) {
                 const e = t.role || "";
-                return e.indexOf("axis") && e.indexOf("legend") && e.indexOf("title") ? t.type === rT ? IF : e || jF : e
+                return e.startsWith("axis") || e.startsWith("legend") || e.startsWith("title") ? e : t.type === Tj ? pB : e || dB
             }
 
-            function RT(t) {
+            function lU(t) {
                 return {
                     marktype: t.type,
                     name: t.name || void 0,
-                    role: t.role || zT(t),
+                    role: t.role || cU(t),
                     zindex: +t.zindex || void 0,
                     aria: t.aria,
                     description: t.description
                 }
             }
 
-            function PT(t, e) {
+            function uU(t, e) {
                 return t && t.signal ? e.signalRef(t.signal) : !1 !== t
             }
 
-            function LT(t, e) {
+            function fU(t, e) {
                 const n = Lr(t.type);
                 n || (0, m.vU)("Unrecognized transform type: " + (0, m.m8)(t.type));
-                const i = yM(n.type.toLowerCase(), null, jT(n, t, e));
+                const i = GB(n.type.toLowerCase(), null, dU(n, t, e));
                 return t.signal && e.addSignal(t.signal, e.proxy(i)), i.metadata = n.metadata || {}, i
             }
 
-            function jT(t, e, n) {
+            function dU(t, e, n) {
                 const i = {},
                     r = t.params.length;
                 for (let o = 0; o < r; ++o) {
                     const r = t.params[o];
-                    i[r.name] = BT(r, e, n)
+                    i[r.name] = hU(r, e, n)
                 }
                 return i
             }
 
-            function BT(t, e, n) {
+            function hU(t, e, n) {
                 const i = t.type,
                     r = e[t.name];
                 return "index" === i ? function(t, e, n) {
                     (0, m.HD)(e.from) || (0, m.vU)('Lookup "from" parameter must be a string literal.');
                     return n.getData(e.from).lookupRef(n, e.key)
                 }(0, e, n) : void 0 !== r ? "param" === i ? function(t, e, n) {
                     const i = e[t.name];
-                    return t.array ? ((0, m.kJ)(i) || (0, m.vU)("Expected an array of sub-parameters. Instead: " + (0, m.m8)(i)), i.map((e => UT(t, e, n)))) : UT(t, i, n)
-                }(t, e, n) : "projection" === i ? n.projectionRef(e[t.name]) : t.array && !CM(r) ? r.map((e => IT(t, e, n))) : IT(t, r, n) : void(t.required && (0, m.vU)("Missing required " + (0, m.m8)(e.type) + " parameter: " + (0, m.m8)(t.name)))
+                    return t.array ? ((0, m.kJ)(i) || (0, m.vU)("Expected an array of sub-parameters. Instead: " + (0, m.m8)(i)), i.map((e => mU(t, e, n)))) : mU(t, i, n)
+                }(t, e, n) : "projection" === i ? n.projectionRef(e[t.name]) : t.array && !nI(r) ? r.map((e => pU(t, e, n))) : pU(t, r, n) : void(t.required && (0, m.vU)("Missing required " + (0, m.m8)(e.type) + " parameter: " + (0, m.m8)(t.name)))
             }
 
-            function IT(t, e, n) {
+            function pU(t, e, n) {
                 const i = t.type;
-                if (CM(e)) return XT(i) ? (0, m.vU)("Expression references can not be signals.") : JT(i) ? n.fieldRef(e) : GT(i) ? n.compareRef(e) : n.signalRef(e.signal);
+                if (nI(e)) return bU(i) ? (0, m.vU)("Expression references can not be signals.") : xU(i) ? n.fieldRef(e) : _U(i) ? n.compareRef(e) : n.signalRef(e.signal);
                 {
-                    const r = t.expr || JT(i);
-                    return r && qT(e) ? n.exprRef(e.expr, e.as) : r && WT(e) ? _M(e.field, e.as) : XT(i) ? xC(e, n) : HT(i) ? xM(n.getData(e).values) : JT(i) ? _M(e) : GT(i) ? n.compareRef(e) : e
+                    const r = t.expr || xU(i);
+                    return r && gU(e) ? n.exprRef(e.expr, e.as) : r && vU(e) ? $B(e.field, e.as) : bU(i) ? xL(e, n) : yU(i) ? ZB(n.getData(e).values) : xU(i) ? $B(e) : _U(i) ? n.compareRef(e) : e
                 }
             }
 
-            function UT(t, e, n) {
+            function mU(t, e, n) {
                 const i = t.params.length;
                 let r;
                 for (let a = 0; a < i; ++a) {
                     r = t.params[a];
                     for (const t in r.key)
                         if (r.key[t] !== e[t]) {
                             r = null;
                             break
                         } if (r) break
                 }
                 r || (0, m.vU)("Unsupported parameter: " + (0, m.m8)(e));
-                const o = (0, m.l7)(jT(r, e, n), r.key);
-                return xM(n.add(oO(o)))
+                const o = (0, m.l7)(dU(r, e, n), r.key);
+                return ZB(n.add(NI(o)))
             }
-            const qT = t => t && t.expr,
-                WT = t => t && t.field,
-                HT = t => "data" === t,
-                XT = t => "expr" === t,
-                JT = t => "field" === t,
-                GT = t => "compare" === t;
+            const gU = t => t && t.expr,
+                vU = t => t && t.field,
+                yU = t => "data" === t,
+                bU = t => "expr" === t,
+                xU = t => "field" === t,
+                _U = t => "compare" === t;
 
-            function $T(t, e) {
-                return t.$ref ? t : t.data && t.data.$ref ? t.data : xM(e.getData(t.data).output)
+            function wU(t, e) {
+                return t.$ref ? t : t.data && t.data.$ref ? t.data : ZB(e.getData(t.data).output)
             }
 
-            function ZT(t, e, n, i, r) {
+            function kU(t, e, n, i, r) {
                 this.scope = t, this.input = e, this.output = n, this.values = i, this.aggregate = r, this.index = {}
             }
 
-            function YT(t) {
+            function EU(t) {
                 return (0, m.HD)(t) ? t : null
             }
 
-            function VT(t, e, n) {
-                const i = DM(n.op, n.field);
+            function AU(t, e, n) {
+                const i = QB(n.op, n.field);
                 let r;
                 if (e.ops) {
                     for (let o = 0, a = e.as.length; o < a; ++o)
                         if (e.as[o] === i) return
                 } else e.ops = ["count"], e.fields = [null], e.as = ["count"];
                 n.op && (e.ops.push((r = n.op.signal) ? t.signalRef(r) : n.op), e.fields.push(t.fieldRef(n.field)), e.as.push(i))
             }
 
-            function KT(t, e, n, i, r, o, a) {
+            function DU(t, e, n, i, r, o, a) {
                 const s = e[n] || (e[n] = {}),
                     c = function(t) {
-                        return (0, m.Kn)(t) ? (t.order === EM ? "-" : "+") + DM(t.op, t.field) : ""
+                        return (0, m.Kn)(t) ? (t.order === KB ? "-" : "+") + QB(t.op, t.field) : ""
                     }(o);
-                let l, u, f = YT(r);
+                let l, u, f = EU(r);
                 if (null != f && (t = e.scope, f += c ? "|" + c : "", l = s[f]), !l) {
                     const n = o ? {
-                        field: wM,
+                        field: YB,
                         pulse: e.countsRef(t, r, o)
                     } : {
                         field: t.fieldRef(r),
-                        pulse: xM(e.output)
+                        pulse: ZB(e.output)
                     };
-                    c && (n.sort = t.sortRef(o)), u = t.add(yM(i, void 0, n)), a && (e.index[r] = u), l = xM(u), null != f && (s[f] = l)
+                    c && (n.sort = t.sortRef(o)), u = t.add(GB(i, void 0, n)), a && (e.index[r] = u), l = ZB(u), null != f && (s[f] = l)
                 }
                 return l
             }
 
-            function QT(t, e, n) {
+            function SU(t, e, n) {
                 const i = t.remove,
                     r = t.insert,
                     o = t.toggle,
                     a = t.modify,
                     s = t.values,
-                    c = e.add(bM()),
-                    l = xC("if(" + t.trigger + ',modify("' + n + '",' + [r, i, o, a, s].map((t => null == t ? "null" : t)).join(",") + "),0)", e);
+                    c = e.add(JB()),
+                    l = xL("if(" + t.trigger + ',modify("' + n + '",' + [r, i, o, a, s].map((t => null == t ? "null" : t)).join(",") + "),0)", e);
                 c.update = l.$expr, c.params = l.$params
             }
 
-            function tN(t, e) {
-                const n = zT(t),
-                    i = t.type === rT,
+            function CU(t, e) {
+                const n = cU(t),
+                    i = t.type === Tj,
                     r = t.from && t.from.facet,
                     o = t.overlap;
-                let a, s, c, l, u, f, d, h = t.layout || n === IF || n === BF;
-                const p = n === jF || h || r,
+                let a, s, c, l, u, f, d, h = t.layout || n === pB || n === hB;
+                const p = n === dB || h || r,
                     g = function(t, e, n) {
                         let i, r, o, a, s;
-                        return t ? (i = t.facet) && (e || (0, m.vU)("Only group marks can be faceted."), null != i.field ? a = s = $T(i, n) : (t.data ? s = xM(n.getData(t.data).aggregate) : (o = LT((0, m.l7)({
+                        return t ? (i = t.facet) && (e || (0, m.vU)("Only group marks can be faceted."), null != i.field ? a = s = wU(i, n) : (t.data ? s = ZB(n.getData(t.data).aggregate) : (o = fU((0, m.l7)({
                             type: "aggregate",
                             groupby: (0, m.IX)(i.groupby)
-                        }, i.aggregate), n), o.params.key = n.keyRef(i.groupby), o.params.pulse = $T(i, n), a = s = xM(n.add(o))), r = n.keyRef(i.groupby, !0))) : a = xM(n.add(XM(null, [{}]))), a || (a = $T(t, n)), {
+                        }, i.aggregate), n), o.params.key = n.keyRef(i.groupby), o.params.pulse = wU(i, n), a = s = ZB(n.add(o))), r = n.keyRef(i.groupby, !0))) : a = ZB(n.add(bI(null, [{}]))), a || (a = wU(t, n)), {
                             key: r,
                             pulse: a,
                             parent: s
                         }
                     }(t.from, i, e);
-                s = e.add(GM({
-                    key: g.key || (t.key ? _M(t.key) : void 0),
+                s = e.add(_I({
+                    key: g.key || (t.key ? $B(t.key) : void 0),
                     pulse: g.pulse,
                     clean: !i
                 }));
-                const v = xM(s);
-                s = c = e.add(XM({
+                const v = ZB(s);
+                s = c = e.add(bI({
                     pulse: v
-                })), s = e.add(eO({
-                    markdef: RT(t),
-                    interactive: PT(t.interactive, e),
-                    clip: TT(t.clip, e),
+                })), s = e.add(MI({
+                    markdef: lU(t),
+                    interactive: uU(t.interactive, e),
+                    clip: aU(t.clip, e),
                     context: {
                         $context: !0
                     },
                     groups: e.lookup(),
                     parent: e.signals.parent ? e.signalRef("parent") : null,
                     index: e.markpath(),
-                    pulse: xM(s)
+                    pulse: ZB(s)
                 }));
-                const y = xM(s);
-                s = l = e.add($M(uM(t.encode, t.type, n, t.style, e, {
+                const y = ZB(s);
+                s = l = e.add(wI(BB(t.encode, t.type, n, t.style, e, {
                     mod: !1,
                     pulse: y
                 }))), s.params.parent = e.encode(), t.transform && t.transform.forEach((t => {
-                    const n = LT(t, e),
+                    const n = fU(t, e),
                         i = n.metadata;
-                    (i.generates || i.changes) && (0, m.vU)("Mark transforms should not generate new data."), i.nomod || (l.params.mod = !0), n.params.pulse = xM(s), e.add(s = n)
-                })), t.sort && (s = e.add(hO({
+                    (i.generates || i.changes) && (0, m.vU)("Mark transforms should not generate new data."), i.nomod || (l.params.mod = !0), n.params.pulse = ZB(s), e.add(s = n)
+                })), t.sort && (s = e.add(UI({
                     sort: e.compareRef(t.sort),
-                    pulse: xM(s)
+                    pulse: ZB(s)
                 })));
-                const b = xM(s);
-                (r || h) && (h = e.add(pO({
+                const b = ZB(s);
+                (r || h) && (h = e.add(qI({
                     layout: e.objectProperty(t.layout),
                     legends: e.legends,
                     mark: y,
                     pulse: b
-                })), f = xM(h));
-                const x = e.add(HM({
+                })), f = ZB(h));
+                const x = e.add(yI({
                     mark: y,
                     pulse: f || b
                 }));
-                d = xM(x), i && (p && (a = e.operators, a.pop(), h && a.pop()), e.pushState(b, f || d, v), r ? function(t, e, n) {
+                d = ZB(x), i && (p && (a = e.operators, a.pop(), h && a.pop()), e.pushState(b, f || d, v), r ? function(t, e, n) {
                     const i = t.from.facet,
                         r = i.name,
-                        o = $T(i, e);
+                        o = wU(i, e);
                     let a;
-                    i.name || (0, m.vU)("Facet must have a name: " + (0, m.m8)(i)), i.data || (0, m.vU)("Facet must reference a data set: " + (0, m.m8)(i)), i.field ? a = e.add(aO({
+                    i.name || (0, m.vU)("Facet must have a name: " + (0, m.m8)(i)), i.data || (0, m.vU)("Facet must reference a data set: " + (0, m.m8)(i)), i.field ? a = e.add(RI({
                         field: e.fieldRef(i.field),
                         pulse: o
-                    })) : i.groupby ? a = e.add(YM({
+                    })) : i.groupby ? a = e.add(EI({
                         key: e.keyRef(i.groupby),
-                        group: xM(e.proxy(n.parent)),
+                        group: ZB(e.proxy(n.parent)),
                         pulse: o
                     })) : (0, m.vU)("Facet must specify groupby or field: " + (0, m.m8)(i));
                     const s = e.fork(),
-                        c = s.add(XM()),
-                        l = s.add(dO({
-                            pulse: xM(c)
+                        c = s.add(bI()),
+                        l = s.add(jI({
+                            pulse: ZB(c)
                         }));
-                    s.addData(r, new ZT(s, c, c, l)), s.addSignal("parent", null), a.params.subflow = {
+                    s.addData(r, new kU(s, c, c, l)), s.addSignal("parent", null), a.params.subflow = {
                         $subflow: s.parse(t).toRuntime()
                     }
                 }(t, e, g) : p ? function(t, e, n) {
-                    const i = e.add(aO({
+                    const i = e.add(RI({
                             pulse: n.pulse
                         })),
                         r = e.fork();
-                    r.add(dO()), r.addSignal("parent", null), i.params.subflow = {
+                    r.add(jI()), r.addSignal("parent", null), i.params.subflow = {
                         $subflow: r.parse(t).toRuntime()
                     }
                 }(t, e, g) : e.parse(t), e.popState(), p && (h && a.push(h), a.push(x))), o && (d = function(t, e, n) {
                     const i = t.method,
                         r = t.bound,
                         o = t.separation,
                         a = {
-                            separation: CM(o) ? n.signalRef(o.signal) : o,
-                            method: CM(i) ? n.signalRef(i.signal) : i,
+                            separation: nI(o) ? n.signalRef(o.signal) : o,
+                            method: nI(i) ? n.signalRef(i.signal) : i,
                             pulse: e
                         };
                     t.order && (a.sort = n.compareRef({
                         field: t.order
                     }));
                     if (r) {
                         const t = r.tolerance;
-                        a.boundTolerance = CM(t) ? n.signalRef(t.signal) : +t, a.boundScale = n.scaleRef(r.scale), a.boundOrient = r.orient
+                        a.boundTolerance = nI(t) ? n.signalRef(t.signal) : +t, a.boundScale = n.scaleRef(r.scale), a.boundOrient = r.orient
                     }
-                    return xM(n.add(rO(a)))
+                    return ZB(n.add(TI(a)))
                 }(o, d, e));
-                const _ = e.add(uO({
+                const _ = e.add(BI({
                         pulse: d
                     })),
-                    w = e.add(dO({
-                        pulse: xM(_)
+                    w = e.add(jI({
+                        pulse: ZB(_)
                     }, void 0, e.parent()));
-                null != t.name && (u = t.name, e.addData(u, new ZT(e, c, _, w)), t.on && t.on.forEach((t => {
-                    (t.insert || t.remove || t.toggle) && (0, m.vU)("Marks only support modify triggers."), QT(t, e, u)
+                null != t.name && (u = t.name, e.addData(u, new kU(e, c, _, w)), t.on && t.on.forEach((t => {
+                    (t.insert || t.remove || t.toggle) && (0, m.vU)("Marks only support modify triggers."), SU(t, e, u)
                 })))
             }
 
-            function eN(t, e) {
+            function MU(t, e) {
                 const n = e.config.legend,
                     i = t.encode || {},
-                    r = uT(t, n),
+                    r = Bj(t, n),
                     o = i.legend || {},
                     a = o.name || void 0,
                     s = o.interactive,
                     c = o.style,
                     l = {};
                 let u, f, d, h = 0;
-                tT.forEach((e => t[e] ? (l[e] = t[e], h = h || t[e]) : 0)), h || (0, m.vU)("Missing valid scale for legend.");
+                Cj.forEach((e => t[e] ? (l[e] = t[e], h = h || t[e]) : 0)), h || (0, m.vU)("Missing valid scale for legend.");
                 const p = function(t, e) {
-                        let n = t.type || YO;
+                        let n = t.type || Ej;
                         t.type || 1 !== function(t) {
-                            return tT.reduce(((e, n) => e + (t[n] ? 1 : 0)), 0)
-                        }(t) || !t.fill && !t.stroke || (n = lf(e) ? VO : ff(e) ? KO : YO);
-                        return n !== VO ? n : ff(e) ? KO : VO
+                            return Cj.reduce(((e, n) => e + (t[n] ? 1 : 0)), 0)
+                        }(t) || !t.fill && !t.stroke || (n = ZL(e, RL) ? Aj : YL(e) ? Dj : Ej);
+                        return n !== Aj ? n : YL(e) ? Dj : Aj
                     }(t, e.scaleType(h)),
                     g = {
                         title: null != t.title,
                         scales: l,
                         type: p,
                         vgrad: "symbol" !== p && r.isVertical()
                     },
-                    v = xM(e.add(XM(null, [g]))),
-                    y = xM(e.add(QM(f = {
+                    v = ZB(e.add(bI(null, [g]))),
+                    y = ZB(e.add(SI(f = {
                         type: p,
                         scale: e.scaleRef(h),
                         count: e.objectProperty(r("tickCount")),
                         limit: e.property(r("symbolLimit")),
                         values: e.objectProperty(t.values),
                         minstep: e.property(t.tickMinStep),
                         formatType: e.property(t.formatType),
                         formatSpecifier: e.property(t.format)
                     })));
-                return p === VO ? (d = [gT(t, h, n, i.gradient), xT(t, n, i.labels, y)], f.count = f.count || e.signalRef("max(2,2*floor((".concat(OM(r.gradientLength()), ")/100))"))) : p === KO ? d = [vT(t, h, n, i.gradient, y), xT(t, n, i.labels, y)] : (u = function(t, e) {
-                    const n = uT(t, e);
+                return p === Aj ? (d = [Hj(t, h, n, i.gradient), Zj(t, n, i.labels, y)], f.count = f.count || e.signalRef("max(2,2*floor((".concat(oI(r.gradientLength()), ")/100))"))) : p === Dj ? d = [Xj(t, h, n, i.gradient, y), Zj(t, n, i.labels, y)] : (u = function(t, e) {
+                    const n = Bj(t, e);
                     return {
                         align: n("gridAlign"),
                         columns: n.entryColumns(),
                         center: {
                             row: !0,
                             column: !1
                         },
                         padding: {
                             row: n("rowPadding"),
                             column: n("columnPadding")
                         }
                     }
-                }(t, n), d = [_T(t, n, i, y, OM(u.columns))], f.size = function(t, e, n) {
-                    const i = OM(iN("size", t, n)),
-                        r = OM(iN("strokeWidth", t, n)),
-                        o = OM(function(t, e, n) {
-                            return fT("fontSize", t) || function(t, e, n) {
+                }(t, n), d = [$j(t, n, i, y, oI(u.columns))], f.size = function(t, e, n) {
+                    const i = oI(OU("size", t, n)),
+                        r = oI(OU("strokeWidth", t, n)),
+                        o = oI(function(t, e, n) {
+                            return Ij("fontSize", t) || function(t, e, n) {
                                 const i = e.config.style[n];
                                 return i && i[t]
                             }("fontSize", e, n)
-                        }(n[1].encode, e, JO));
-                    return xC("max(ceil(sqrt(".concat(i, ")+").concat(r, "),").concat(o, ")"), e)
-                }(t, e, d[0].marks)), d = [lT({
-                    role: ZF,
+                        }(n[1].encode, e, xj));
+                    return xL("max(ceil(sqrt(".concat(i, ")+").concat(r, "),").concat(o, ")"), e)
+                }(t, e, d[0].marks)), d = [Lj({
+                    role: kB,
                     from: v,
                     encode: {
                         enter: {
                             x: {
                                 value: 0
                             },
                             y: {
@@ -40840,90 +45100,90 @@
                             }
                         }
                     },
                     marks: d,
                     layout: u,
                     interactive: s
                 })], g.title && d.push(function(t, e, n, i) {
-                    const r = uT(t, e),
+                    const r = Bj(t, e),
                         o = {
                             enter: {
-                                opacity: nT
+                                opacity: Fj
                             },
                             update: {
-                                opacity: iT,
+                                opacity: Oj,
                                 x: {
                                     field: {
                                         group: "padding"
                                     }
                                 },
                                 y: {
                                     field: {
                                         group: "padding"
                                     }
                                 }
                             },
                             exit: {
-                                opacity: nT
+                                opacity: Fj
                             }
                         };
-                    return RF(o, {
+                    return lB(o, {
                         orient: r("titleOrient"),
                         _anchor: r("titleAnchor"),
                         anchor: {
-                            signal: FT
+                            signal: iU
                         },
                         angle: {
-                            signal: MT
+                            signal: rU
                         },
                         align: {
-                            signal: CT
+                            signal: nU
                         },
                         baseline: {
-                            signal: OT
+                            signal: oU
                         },
                         text: t.title,
                         fill: r("titleColor"),
                         fillOpacity: r("titleOpacity"),
                         font: r("titleFont"),
                         fontSize: r("titleFontSize"),
                         fontStyle: r("titleFontStyle"),
                         fontWeight: r("titleFontWeight"),
                         limit: r("titleLimit"),
                         lineHeight: r("titleLineHeight")
                     }, {
                         align: r("titleAlign"),
                         baseline: r("titleBaseline")
-                    }), mT({
-                        type: cT,
-                        role: QF,
-                        style: GO,
+                    }), Wj({
+                        type: Pj,
+                        role: SB,
+                        style: _j,
                         from: i,
                         encode: o
                     }, n)
-                }(t, n, i.title, v)), tN(lT({
-                    role: GF,
+                }(t, n, i.title, v)), CU(Lj({
+                    role: _B,
                     from: v,
-                    encode: PF(nN(r, t, n), o, eT),
+                    encode: uB(FU(r, t, n), o, Mj),
                     marks: d,
                     aria: r("aria"),
                     description: r("description"),
                     zindex: r("zindex"),
                     name: a,
                     interactive: s,
                     style: c
                 }), e)
             }
 
-            function nN(t, e, n) {
+            function FU(t, e, n) {
                 const i = {
                     enter: {},
                     update: {}
                 };
-                return RF(i, {
+                return lB(i, {
                     orient: t("orient"),
                     offset: t("offset"),
                     padding: t("padding"),
                     titlePadding: t("titlePadding"),
                     cornerRadius: t("cornerRadius"),
                     fill: t("fillColor"),
                     stroke: t("strokeColor"),
@@ -40932,74 +45192,74 @@
                     x: t("legendX"),
                     y: t("legendY"),
                     format: e.format,
                     formatType: e.formatType
                 }), i
             }
 
-            function iN(t, e, n) {
-                return e[t] ? 'scale("'.concat(e[t], '",datum)') : fT(t, n[0].encode)
+            function OU(t, e, n) {
+                return e[t] ? 'scale("'.concat(e[t], '",datum)') : Ij(t, n[0].encode)
             }
-            ZT.fromEntries = function(t, e) {
+            kU.fromEntries = function(t, e) {
                 const n = e.length,
                     i = e[n - 1],
                     r = e[n - 2];
                 let o = e[0],
                     a = null,
                     s = 1;
-                for (o && "load" === o.type && (o = e[1]), t.add(e[0]); s < n; ++s) e[s].params.pulse = xM(e[s - 1]), t.add(e[s]), "aggregate" === e[s].type && (a = e[s]);
-                return new ZT(t, o, r, i, a)
-            }, ZT.prototype = {
+                for (o && "load" === o.type && (o = e[1]), t.add(e[0]); s < n; ++s) e[s].params.pulse = ZB(e[s - 1]), t.add(e[s]), "aggregate" === e[s].type && (a = e[s]);
+                return new kU(t, o, r, i, a)
+            }, kU.prototype = {
                 countsRef(t, e, n) {
                     const i = this,
                         r = i.counts || (i.counts = {}),
-                        o = YT(e);
+                        o = EU(e);
                     let a, s, c;
-                    return null != o && (t = i.scope, a = r[o]), a ? n && n.field && VT(t, a.agg.params, n) : (c = {
+                    return null != o && (t = i.scope, a = r[o]), a ? n && n.field && AU(t, a.agg.params, n) : (c = {
                         groupby: t.fieldRef(e, "key"),
-                        pulse: xM(i.output)
-                    }, n && n.field && VT(t, c, n), s = t.add(qM(c)), a = t.add(XM({
-                        pulse: xM(s)
+                        pulse: ZB(i.output)
+                    }, n && n.field && AU(t, c, n), s = t.add(gI(c)), a = t.add(bI({
+                        pulse: ZB(s)
                     })), a = {
                         agg: s,
-                        ref: xM(a)
+                        ref: ZB(a)
                     }, null != o && (r[o] = a)), a.ref
                 },
                 tuplesRef() {
-                    return xM(this.values)
+                    return ZB(this.values)
                 },
                 extentRef(t, e) {
-                    return KT(t, this, "extent", "extent", e, !1)
+                    return DU(t, this, "extent", "extent", e, !1)
                 },
                 domainRef(t, e) {
-                    return KT(t, this, "domain", "values", e, !1)
+                    return DU(t, this, "domain", "values", e, !1)
                 },
                 valuesRef(t, e, n) {
-                    return KT(t, this, "vals", "values", e, n || !0)
+                    return DU(t, this, "vals", "values", e, n || !0)
                 },
                 lookupRef(t, e) {
-                    return KT(t, this, "lookup", "tupleindex", e, !1)
+                    return DU(t, this, "lookup", "tupleindex", e, !1)
                 },
                 indataRef(t, e) {
-                    return KT(t, this, "indata", "tupleindex", e, !0, !0)
+                    return DU(t, this, "indata", "tupleindex", e, !0, !0)
                 }
             };
-            const rN = 'item.orient==="'.concat(NO, '"?-90:item.orient==="').concat(zO, '"?90:0');
+            const TU = 'item.orient==="'.concat(sj, '"?-90:item.orient==="').concat(cj, '"?90:0');
 
-            function oN(t, e) {
-                const n = uT(t = (0, m.HD)(t) ? {
+            function NU(t, e) {
+                const n = Bj(t = (0, m.HD)(t) ? {
                         text: t
                     } : t, e.config.title),
                     i = t.encode || {},
                     r = i.group || {},
                     o = r.name || void 0,
                     a = r.interactive,
                     s = r.style,
                     c = [],
-                    l = xM(e.add(XM(null, [{}])));
+                    l = ZB(e.add(bI(null, [{}])));
                 return c.push(function(t, e, n, i) {
                     const r = {
                             value: 0
                         },
                         o = t.text,
                         a = {
                             enter: {
@@ -41010,15 +45270,15 @@
                                     value: 1
                                 }
                             },
                             exit: {
                                 opacity: r
                             }
                         };
-                    return RF(a, {
+                    return lB(a, {
                         text: o,
                         align: {
                             signal: "item.mark.group.align"
                         },
                         angle: {
                             signal: "item.mark.group.angle"
                         },
@@ -41034,18 +45294,18 @@
                         fontStyle: e("fontStyle"),
                         fontWeight: e("fontWeight"),
                         lineHeight: e("lineHeight")
                     }, {
                         align: e("align"),
                         angle: e("angle"),
                         baseline: e("baseline")
-                    }), mT({
-                        type: cT,
-                        role: eM,
-                        style: $O,
+                    }), Wj({
+                        type: Pj,
+                        role: MB,
+                        style: wj,
                         from: i,
                         encode: a
                     }, n)
                 }(t, n, function(t) {
                     const e = t.encode;
                     return e && e.title || (0, m.l7)({
                         name: t.name,
@@ -41066,15 +45326,15 @@
                                     value: 1
                                 }
                             },
                             exit: {
                                 opacity: r
                             }
                         };
-                    return RF(a, {
+                    return lB(a, {
                         text: o,
                         align: {
                             signal: "item.mark.group.align"
                         },
                         angle: {
                             signal: "item.mark.group.angle"
                         },
@@ -41090,238 +45350,238 @@
                         fontStyle: e("subtitleFontStyle"),
                         fontWeight: e("subtitleFontWeight"),
                         lineHeight: e("subtitleLineHeight")
                     }, {
                         align: e("align"),
                         angle: e("angle"),
                         baseline: e("baseline")
-                    }), mT({
-                        type: cT,
-                        role: nM,
-                        style: ZO,
+                    }), Wj({
+                        type: Pj,
+                        role: FB,
+                        style: kj,
                         from: i,
                         encode: a
                     }, n)
-                }(t, n, i.subtitle, l)), tN(lT({
-                    role: tM,
+                }(t, n, i.subtitle, l)), CU(Lj({
+                    role: CB,
                     from: l,
-                    encode: aN(n, r),
+                    encode: RU(n, r),
                     marks: c,
                     aria: n("aria"),
                     description: n("description"),
                     zindex: n("zindex"),
                     name: o,
                     interactive: a,
                     style: s
                 }), e)
             }
 
-            function aN(t, e) {
+            function RU(t, e) {
                 const n = {
                     enter: {},
                     update: {}
                 };
-                return RF(n, {
+                return lB(n, {
                     orient: t("orient"),
                     anchor: t("anchor"),
                     align: {
-                        signal: hT
+                        signal: Uj
                     },
                     angle: {
-                        signal: rN
+                        signal: TU
                     },
                     limit: t("limit"),
                     frame: t("frame"),
                     offset: t("offset") || 0,
                     padding: t("subtitlePadding")
-                }), PF(n, e, eT)
+                }), uB(n, e, Mj)
             }
 
-            function sN(t, e) {
+            function zU(t, e) {
                 const n = [];
                 t.transform && t.transform.forEach((t => {
-                    n.push(LT(t, e))
+                    n.push(fU(t, e))
                 })), t.on && t.on.forEach((n => {
-                    QT(n, e, t.name)
+                    SU(n, e, t.name)
                 })), e.addDataPipeline(t.name, function(t, e, n) {
                     const i = [];
                     let r, o, a, s, c, l = null,
                         u = !1,
                         f = !1;
-                    t.values ? CM(t.values) || FM(t.format) ? (i.push(lN(e, t)), i.push(l = cN())) : i.push(l = cN({
+                    t.values ? nI(t.values) || iI(t.format) ? (i.push(LU(e, t)), i.push(l = PU())) : i.push(l = PU({
                         $ingest: t.values,
                         $format: t.format
-                    })) : t.url ? FM(t.url) || FM(t.format) ? (i.push(lN(e, t)), i.push(l = cN())) : i.push(l = cN({
+                    })) : t.url ? iI(t.url) || iI(t.format) ? (i.push(LU(e, t)), i.push(l = PU())) : i.push(l = PU({
                         $request: t.url,
                         $format: t.format
-                    })) : t.source && (l = r = (0, m.IX)(t.source).map((t => xM(e.getData(t).output))), i.push(null));
-                    for (o = 0, a = n.length; o < a; ++o) s = n[o], c = s.metadata, l || c.source || i.push(l = cN()), i.push(s), c.generates && (f = !0), c.modifies && !f && (u = !0), c.source ? l = s : c.changes && (l = null);
-                    r && (a = r.length - 1, i[0] = lO({
+                    })) : t.source && (l = r = (0, m.IX)(t.source).map((t => ZB(e.getData(t).output))), i.push(null));
+                    for (o = 0, a = n.length; o < a; ++o) s = n[o], c = s.metadata, l || c.source || i.push(l = PU()), i.push(s), c.generates && (f = !0), c.modifies && !f && (u = !0), c.source ? l = s : c.changes && (l = null);
+                    r && (a = r.length - 1, i[0] = LI({
                         derive: u,
                         pulse: a ? r : r[0]
-                    }), (u || a) && i.splice(1, 0, cN()));
-                    l || i.push(cN());
-                    return i.push(dO({})), i
+                    }), (u || a) && i.splice(1, 0, PU()));
+                    l || i.push(PU());
+                    return i.push(jI({})), i
                 }(t, e, n))
             }
 
-            function cN(t) {
-                const e = XM({}, t);
+            function PU(t) {
+                const e = bI({}, t);
                 return e.metadata = {
                     source: !0
                 }, e
             }
 
-            function lN(t, e) {
-                return tO({
+            function LU(t, e) {
+                return CI({
                     url: e.url ? t.property(e.url) : void 0,
                     async: e.async ? t.property(e.async) : void 0,
                     values: e.values ? t.property(e.values) : void 0,
                     format: t.objectProperty(e.format)
                 })
             }
-            const uN = t => t === RO || t === TO,
-                fN = (t, e, n) => CM(t) ? yN(t.signal, e, n) : t === NO || t === TO ? e : n,
-                dN = (t, e, n) => CM(t) ? gN(t.signal, e, n) : uN(t) ? e : n,
-                hN = (t, e, n) => CM(t) ? vN(t.signal, e, n) : uN(t) ? n : e,
-                pN = (t, e, n) => CM(t) ? bN(t.signal, e, n) : t === TO ? {
+            const BU = t => t === lj || t === aj,
+                IU = (t, e, n) => nI(t) ? GU(t.signal, e, n) : t === sj || t === aj ? e : n,
+                jU = (t, e, n) => nI(t) ? HU(t.signal, e, n) : BU(t) ? e : n,
+                UU = (t, e, n) => nI(t) ? XU(t.signal, e, n) : BU(t) ? n : e,
+                qU = (t, e, n) => nI(t) ? JU(t.signal, e, n) : t === aj ? {
                     value: e
                 } : {
                     value: n
                 },
-                mN = (t, e, n) => CM(t) ? xN(t.signal, e, n) : t === zO ? {
+                WU = (t, e, n) => nI(t) ? ZU(t.signal, e, n) : t === cj ? {
                     value: e
                 } : {
                     value: n
                 },
-                gN = (t, e, n) => _N("".concat(t, " === '").concat(TO, "' || ").concat(t, " === '").concat(RO, "'"), e, n),
-                vN = (t, e, n) => _N("".concat(t, " !== '").concat(TO, "' && ").concat(t, " !== '").concat(RO, "'"), e, n),
-                yN = (t, e, n) => kN("".concat(t, " === '").concat(NO, "' || ").concat(t, " === '").concat(TO, "'"), e, n),
-                bN = (t, e, n) => kN("".concat(t, " === '").concat(TO, "'"), e, n),
-                xN = (t, e, n) => kN("".concat(t, " === '").concat(zO, "'"), e, n),
-                _N = (t, e, n) => (e = null != e ? NF(e) : e, n = null != n ? NF(n) : n, wN(e) && wN(n) ? (e = e ? e.signal || (0, m.m8)(e.value) : null, n = n ? n.signal || (0, m.m8)(n.value) : null, {
+                HU = (t, e, n) => $U("".concat(t, " === '").concat(aj, "' || ").concat(t, " === '").concat(lj, "'"), e, n),
+                XU = (t, e, n) => $U("".concat(t, " !== '").concat(aj, "' && ").concat(t, " !== '").concat(lj, "'"), e, n),
+                GU = (t, e, n) => VU("".concat(t, " === '").concat(sj, "' || ").concat(t, " === '").concat(aj, "'"), e, n),
+                JU = (t, e, n) => VU("".concat(t, " === '").concat(aj, "'"), e, n),
+                ZU = (t, e, n) => VU("".concat(t, " === '").concat(cj, "'"), e, n),
+                $U = (t, e, n) => (e = null != e ? sB(e) : e, n = null != n ? sB(n) : n, YU(e) && YU(n) ? (e = e ? e.signal || (0, m.m8)(e.value) : null, n = n ? n.signal || (0, m.m8)(n.value) : null, {
                     signal: "".concat(t, " ? (").concat(e, ") : (").concat(n, ")")
                 }) : [(0, m.l7)({
                     test: t
                 }, e)].concat(n || [])),
-                wN = t => null == t || 1 === Object.keys(t).length,
-                kN = (t, e, n) => ({
-                    signal: "".concat(t, " ? (").concat(DN(e), ") : (").concat(DN(n), ")")
+                YU = t => null == t || 1 === Object.keys(t).length,
+                VU = (t, e, n) => ({
+                    signal: "".concat(t, " ? (").concat(QU(e), ") : (").concat(QU(n), ")")
                 }),
-                EN = (t, e, n, i, r) => ({
-                    signal: (null != i ? "".concat(t, " === '").concat(NO, "' ? (").concat(DN(i), ") : ") : "") + (null != n ? "".concat(t, " === '").concat(RO, "' ? (").concat(DN(n), ") : ") : "") + (null != r ? "".concat(t, " === '").concat(zO, "' ? (").concat(DN(r), ") : ") : "") + (null != e ? "".concat(t, " === '").concat(TO, "' ? (").concat(DN(e), ") : ") : "") + "(null)"
+                KU = (t, e, n, i, r) => ({
+                    signal: (null != i ? "".concat(t, " === '").concat(sj, "' ? (").concat(QU(i), ") : ") : "") + (null != n ? "".concat(t, " === '").concat(lj, "' ? (").concat(QU(n), ") : ") : "") + (null != r ? "".concat(t, " === '").concat(cj, "' ? (").concat(QU(r), ") : ") : "") + (null != e ? "".concat(t, " === '").concat(aj, "' ? (").concat(QU(e), ") : ") : "") + "(null)"
                 }),
-                DN = t => CM(t) ? t.signal : null == t ? null : (0, m.m8)(t),
-                AN = (t, e) => 0 === e ? 0 : CM(t) ? {
+                QU = t => nI(t) ? t.signal : null == t ? null : (0, m.m8)(t),
+                tq = (t, e) => 0 === e ? 0 : nI(t) ? {
                     signal: "(".concat(t.signal, ") * ").concat(e)
                 } : {
                     value: t * e
                 },
-                SN = (t, e) => {
+                eq = (t, e) => {
                     const n = t.signal;
                     return n && n.endsWith("(null)") ? {
                         signal: n.slice(0, -6) + e.signal
                     } : t
                 };
 
-            function CN(t, e, n, i) {
+            function nq(t, e, n, i) {
                 let r;
                 if (e && (0, m.nr)(e, t)) return e[t];
                 if ((0, m.nr)(n, t)) return n[t];
                 if (t.startsWith("title")) {
                     switch (t) {
                         case "titleColor":
                             r = "fill";
                             break;
                         case "titleFont":
                         case "titleFontSize":
                         case "titleFontWeight":
                             r = t[5].toLowerCase() + t.slice(6)
                     }
-                    return i[GO][r]
+                    return i[_j][r]
                 }
                 if (t.startsWith("label")) {
                     switch (t) {
                         case "labelColor":
                             r = "fill";
                             break;
                         case "labelFont":
                         case "labelFontSize":
                             r = t[5].toLowerCase() + t.slice(6)
                     }
-                    return i[JO][r]
+                    return i[xj][r]
                 }
                 return null
             }
 
-            function FN(t) {
+            function iq(t) {
                 const e = {};
                 for (const n of t)
                     if (n)
                         for (const t in n) e[t] = 1;
                 return Object.keys(e)
             }
 
-            function MN(t, e) {
+            function rq(t, e) {
                 return {
                     scale: t.scale,
                     range: e
                 }
             }
 
-            function ON(t, e, n, i, r) {
-                const o = uT(t, e),
+            function oq(t, e, n, i, r) {
+                const o = Bj(t, e),
                     a = t.orient,
                     s = t.gridScale,
-                    c = fN(a, 1, -1),
+                    c = IU(a, 1, -1),
                     l = function(t, e) {
                         if (1 === e);
                         else if ((0, m.Kn)(t)) {
                             let n = t = (0, m.l7)({}, t);
                             for (; null != n.mult;) {
-                                if (!(0, m.Kn)(n.mult)) return n.mult = CM(e) ? {
+                                if (!(0, m.Kn)(n.mult)) return n.mult = nI(e) ? {
                                     signal: "(".concat(n.mult, ") * (").concat(e.signal, ")")
                                 } : n.mult * e, t;
                                 n = n.mult = (0, m.l7)({}, n.mult)
                             }
                             n.mult = e
-                        } else t = CM(e) ? {
+                        } else t = nI(e) ? {
                             signal: "(".concat(e.signal, ") * (").concat(t || 0, ")")
                         } : e * (t || 0);
                         return t
                     }(t.offset, c);
                 let u, f, d;
                 const h = {
                     enter: u = {
-                        opacity: nT
+                        opacity: Fj
                     },
                     update: d = {
-                        opacity: iT
+                        opacity: Oj
                     },
                     exit: f = {
-                        opacity: nT
+                        opacity: Fj
                     }
                 };
-                RF(h, {
+                lB(h, {
                     stroke: o("gridColor"),
                     strokeCap: o("gridCap"),
                     strokeDash: o("gridDash"),
                     strokeDashOffset: o("gridDashOffset"),
                     strokeOpacity: o("gridOpacity"),
                     strokeWidth: o("gridWidth")
                 });
                 const p = {
                         scale: t.scale,
-                        field: XO,
+                        field: bj,
                         band: r.band,
                         extra: r.extra,
                         offset: r.offset,
                         round: o("tickRound")
                     },
-                    g = dN(a, {
+                    g = jU(a, {
                         signal: "height"
                     }, {
                         signal: "width"
                     }),
                     v = s ? {
                         scale: s,
                         range: 0,
@@ -41336,104 +45596,104 @@
                         range: 1,
                         mult: c,
                         offset: l
                     } : (0, m.l7)(g, {
                         mult: c,
                         offset: l
                     });
-                return u.x = d.x = dN(a, p, v), u.y = d.y = hN(a, p, v), u.x2 = d.x2 = hN(a, y), u.y2 = d.y2 = dN(a, y), f.x = dN(a, p), f.y = hN(a, p), mT({
-                    type: aT,
-                    role: WF,
-                    key: XO,
+                return u.x = d.x = jU(a, p, v), u.y = d.y = UU(a, p, v), u.x2 = d.x2 = UU(a, y), u.y2 = d.y2 = jU(a, y), f.x = jU(a, p), f.y = UU(a, p), Wj({
+                    type: Rj,
+                    role: vB,
+                    key: bj,
                     from: i,
                     encode: h
                 }, n)
             }
 
-            function TN(t, e, n, i, r) {
+            function aq(t, e, n, i, r) {
                 return {
                     signal: 'flush(range("' + t + '"), scale("' + t + '", datum.value), ' + e + "," + n + "," + i + "," + r + ")"
                 }
             }
 
-            function NN(t, e, n, i) {
-                const r = uT(t, e),
+            function sq(t, e, n, i) {
+                const r = Bj(t, e),
                     o = t.orient,
-                    a = fN(o, -1, 1);
+                    a = IU(o, -1, 1);
                 let s, c;
                 const l = {
                         enter: s = {
-                            opacity: nT,
-                            anchor: NF(r("titleAnchor", null)),
+                            opacity: Fj,
+                            anchor: sB(r("titleAnchor", null)),
                             align: {
-                                signal: hT
+                                signal: Uj
                             }
                         },
                         update: c = (0, m.l7)({}, s, {
-                            opacity: iT,
-                            text: NF(t.title)
+                            opacity: Oj,
+                            text: sB(t.title)
                         }),
                         exit: {
-                            opacity: nT
+                            opacity: Fj
                         }
                     },
                     u = {
-                        signal: 'lerp(range("'.concat(t.scale, '"), ').concat(dT(0, 1, .5), ")")
+                        signal: 'lerp(range("'.concat(t.scale, '"), ').concat(jj(0, 1, .5), ")")
                     };
-                return c.x = dN(o, u), c.y = hN(o, u), s.angle = dN(o, nT, AN(a, 90)), s.baseline = dN(o, pN(o, RO, TO), {
-                        value: RO
-                    }), c.angle = s.angle, c.baseline = s.baseline, RF(l, {
+                return c.x = jU(o, u), c.y = UU(o, u), s.angle = jU(o, Fj, tq(a, 90)), s.baseline = jU(o, qU(o, lj, aj), {
+                        value: lj
+                    }), c.angle = s.angle, c.baseline = s.baseline, lB(l, {
                         fill: r("titleColor"),
                         fillOpacity: r("titleOpacity"),
                         font: r("titleFont"),
                         fontSize: r("titleFontSize"),
                         fontStyle: r("titleFontStyle"),
                         fontWeight: r("titleFontWeight"),
                         limit: r("titleLimit"),
                         lineHeight: r("titleLineHeight")
                     }, {
                         align: r("titleAlign"),
                         angle: r("titleAngle"),
                         baseline: r("titleBaseline")
                     }),
                     function(t, e, n, i) {
-                        const r = (t, e) => null != t ? (n.update[e] = SN(NF(t), n.update[e]), !1) : !LF(e, i),
+                        const r = (t, e) => null != t ? (n.update[e] = eq(sB(t), n.update[e]), !1) : !fB(e, i),
                             o = r(t("titleX"), "x"),
                             a = r(t("titleY"), "y");
-                        n.enter.auto = a === o ? NF(a) : dN(e, NF(a), NF(o))
-                    }(r, o, l, n), l.update.align = SN(l.update.align, s.align), l.update.angle = SN(l.update.angle, s.angle), l.update.baseline = SN(l.update.baseline, s.baseline), mT({
-                        type: cT,
-                        role: JF,
-                        style: GO,
+                        n.enter.auto = a === o ? sB(a) : jU(e, sB(a), sB(o))
+                    }(r, o, l, n), l.update.align = eq(l.update.align, s.align), l.update.angle = eq(l.update.angle, s.angle), l.update.baseline = eq(l.update.baseline, s.baseline), Wj({
+                        type: Pj,
+                        role: xB,
+                        style: _j,
                         from: i,
                         encode: l
                     }, n)
             }
 
-            function zN(t, e) {
+            function cq(t, e) {
                 const n = function(t, e) {
                         var n, i, r, o = e.config,
                             a = o.style,
                             s = o.axis,
                             c = "band" === e.scaleType(t.scale) && o.axisBand,
                             l = t.orient;
-                        if (CM(l)) {
-                            const t = FN([o.axisX, o.axisY]),
-                                e = FN([o.axisTop, o.axisBottom, o.axisLeft, o.axisRight]);
-                            for (r of (n = {}, t)) n[r] = dN(l, CN(r, o.axisX, s, a), CN(r, o.axisY, s, a));
-                            for (r of (i = {}, e)) i[r] = EN(l.signal, CN(r, o.axisTop, s, a), CN(r, o.axisBottom, s, a), CN(r, o.axisLeft, s, a), CN(r, o.axisRight, s, a))
-                        } else n = l === TO || l === RO ? o.axisX : o.axisY, i = o["axis" + l[0].toUpperCase() + l.slice(1)];
+                        if (nI(l)) {
+                            const t = iq([o.axisX, o.axisY]),
+                                e = iq([o.axisTop, o.axisBottom, o.axisLeft, o.axisRight]);
+                            for (r of (n = {}, t)) n[r] = jU(l, nq(r, o.axisX, s, a), nq(r, o.axisY, s, a));
+                            for (r of (i = {}, e)) i[r] = KU(l.signal, nq(r, o.axisTop, s, a), nq(r, o.axisBottom, s, a), nq(r, o.axisLeft, s, a), nq(r, o.axisRight, s, a))
+                        } else n = l === aj || l === lj ? o.axisX : o.axisY, i = o["axis" + l[0].toUpperCase() + l.slice(1)];
                         return n || i || c ? (0, m.l7)({}, s, n, i, c) : s
                     }(t, e),
                     i = t.encode || {},
                     r = i.axis || {},
                     o = r.name || void 0,
                     a = r.interactive,
                     s = r.style,
-                    c = uT(t, n),
+                    c = Bj(t, n),
                     l = function(t) {
                         const e = t("tickBand");
                         let n, i, r = t("tickOffset");
                         return e ? e.signal ? (n = {
                             signal: "(".concat(e.signal, ") === 'extent' ? 1 : 0.5")
                         }, i = {
                             signal: "(".concat(e.signal, ") === 'extent'")
@@ -41449,120 +45709,120 @@
                         scale: t.scale,
                         ticks: !!c("ticks"),
                         labels: !!c("labels"),
                         grid: !!c("grid"),
                         domain: !!c("domain"),
                         title: null != t.title
                     },
-                    f = xM(e.add(XM({}, [u]))),
-                    d = xM(e.add(WM({
+                    f = ZB(e.add(bI({}, [u]))),
+                    d = ZB(e.add(vI({
                         scale: e.scaleRef(t.scale),
                         extra: e.property(l.extra),
                         count: e.objectProperty(t.tickCount),
                         values: e.objectProperty(t.values),
                         minstep: e.property(t.tickMinStep),
                         formatType: e.property(t.formatType),
                         formatSpecifier: e.property(t.format)
                     }))),
                     h = [];
                 let p;
-                return u.grid && h.push(ON(t, n, i.grid, d, l)), u.ticks && (p = c("tickSize"), h.push(function(t, e, n, i, r, o) {
-                    const a = uT(t, e),
+                return u.grid && h.push(oq(t, n, i.grid, d, l)), u.ticks && (p = c("tickSize"), h.push(function(t, e, n, i, r, o) {
+                    const a = Bj(t, e),
                         s = t.orient,
-                        c = fN(s, -1, 1);
+                        c = IU(s, -1, 1);
                     let l, u, f;
                     const d = {
                         enter: l = {
-                            opacity: nT
+                            opacity: Fj
                         },
                         update: f = {
-                            opacity: iT
+                            opacity: Oj
                         },
                         exit: u = {
-                            opacity: nT
+                            opacity: Fj
                         }
                     };
-                    RF(d, {
+                    lB(d, {
                         stroke: a("tickColor"),
                         strokeCap: a("tickCap"),
                         strokeDash: a("tickDash"),
                         strokeDashOffset: a("tickDashOffset"),
                         strokeOpacity: a("tickOpacity"),
                         strokeWidth: a("tickWidth")
                     });
-                    const h = NF(r);
+                    const h = sB(r);
                     h.mult = c;
                     const p = {
                         scale: t.scale,
-                        field: XO,
+                        field: bj,
                         band: o.band,
                         extra: o.extra,
                         offset: o.offset,
                         round: a("tickRound")
                     };
-                    return f.y = l.y = dN(s, nT, p), f.y2 = l.y2 = dN(s, h), u.x = dN(s, p), f.x = l.x = hN(s, nT, p), f.x2 = l.x2 = hN(s, h), u.y = hN(s, p), mT({
-                        type: aT,
-                        role: XF,
-                        key: XO,
+                    return f.y = l.y = jU(s, Fj, p), f.y2 = l.y2 = jU(s, h), u.x = jU(s, p), f.x = l.x = UU(s, Fj, p), f.x2 = l.x2 = UU(s, h), u.y = UU(s, p), Wj({
+                        type: Rj,
+                        role: bB,
+                        key: bj,
                         from: i,
                         encode: d
                     }, n)
                 }(t, n, i.ticks, d, p, l))), u.labels && (p = u.ticks ? p : 0, h.push(function(t, e, n, i, r, o) {
-                    const a = uT(t, e),
+                    const a = Bj(t, e),
                         s = t.orient,
                         c = t.scale,
-                        l = fN(s, -1, 1),
-                        u = OM(a("labelFlush")),
-                        f = OM(a("labelFlushOffset")),
+                        l = IU(s, -1, 1),
+                        u = oI(a("labelFlush")),
+                        f = oI(a("labelFlushOffset")),
                         d = a("labelAlign"),
                         h = a("labelBaseline");
                     let p, m = 0 === u || !!u;
-                    const g = NF(r);
-                    g.mult = l, g.offset = NF(a("labelPadding") || 0), g.offset.mult = l;
+                    const g = sB(r);
+                    g.mult = l, g.offset = sB(a("labelPadding") || 0), g.offset.mult = l;
                     const v = {
                             scale: c,
-                            field: XO,
+                            field: bj,
                             band: .5,
-                            offset: pT(o.offset, a("labelOffset"))
+                            offset: qj(o.offset, a("labelOffset"))
                         },
-                        y = dN(s, m ? TN(c, u, '"left"', '"right"', '"center"') : {
+                        y = jU(s, m ? aq(c, u, '"left"', '"right"', '"center"') : {
                             value: "center"
-                        }, mN(s, "left", "right")),
-                        b = dN(s, pN(s, "bottom", "top"), m ? TN(c, u, '"top"', '"bottom"', '"middle"') : {
+                        }, WU(s, "left", "right")),
+                        b = jU(s, qU(s, "bottom", "top"), m ? aq(c, u, '"top"', '"bottom"', '"middle"') : {
                             value: "middle"
                         }),
-                        x = TN(c, u, "-(".concat(f, ")"), f, 0);
+                        x = aq(c, u, "-(".concat(f, ")"), f, 0);
                     m = m && f;
                     const _ = {
-                            opacity: nT,
-                            x: dN(s, v, g),
-                            y: hN(s, v, g)
+                            opacity: Fj,
+                            x: jU(s, v, g),
+                            y: UU(s, v, g)
                         },
                         w = {
                             enter: _,
                             update: p = {
-                                opacity: iT,
+                                opacity: Oj,
                                 text: {
-                                    field: UO
+                                    field: mj
                                 },
                                 x: _.x,
                                 y: _.y,
                                 align: y,
                                 baseline: b
                             },
                             exit: {
-                                opacity: nT,
+                                opacity: Fj,
                                 x: _.x,
                                 y: _.y
                             }
                         };
-                    RF(w, {
-                        dx: !d && m ? dN(s, x) : null,
-                        dy: !h && m ? hN(s, x) : null
-                    }), RF(w, {
+                    lB(w, {
+                        dx: !d && m ? jU(s, x) : null,
+                        dy: !h && m ? UU(s, x) : null
+                    }), lB(w, {
                         angle: a("labelAngle"),
                         fill: a("labelColor"),
                         fillOpacity: a("labelOpacity"),
                         font: a("labelFont"),
                         fontSize: a("labelFontSize"),
                         fontWeight: a("labelFontWeight"),
                         fontStyle: a("labelFontStyle"),
@@ -41579,111 +45839,111 @@
                         method: E,
                         order: "datum.index",
                         bound: k ? {
                             scale: c,
                             orient: s,
                             tolerance: k
                         } : null
-                    } : void 0, p.align !== y && (p.align = SN(p.align, y)), p.baseline !== b && (p.baseline = SN(p.baseline, b)), mT({
-                        type: cT,
-                        role: HF,
-                        style: JO,
-                        key: XO,
+                    } : void 0, p.align !== y && (p.align = eq(p.align, y)), p.baseline !== b && (p.baseline = eq(p.baseline, b)), Wj({
+                        type: Pj,
+                        role: yB,
+                        style: xj,
+                        key: bj,
                         from: i,
                         encode: w,
                         overlap: E
                     }, n)
                 }(t, n, i.labels, d, p, l))), u.domain && h.push(function(t, e, n, i) {
-                    const r = uT(t, e),
+                    const r = Bj(t, e),
                         o = t.orient;
                     let a, s;
                     const c = {
                         enter: a = {
-                            opacity: nT
+                            opacity: Fj
                         },
                         update: s = {
-                            opacity: iT
+                            opacity: Oj
                         },
                         exit: {
-                            opacity: nT
+                            opacity: Fj
                         }
                     };
-                    RF(c, {
+                    lB(c, {
                         stroke: r("domainColor"),
                         strokeCap: r("domainCap"),
                         strokeDash: r("domainDash"),
                         strokeDashOffset: r("domainDashOffset"),
                         strokeWidth: r("domainWidth"),
                         strokeOpacity: r("domainOpacity")
                     });
-                    const l = MN(t, 0),
-                        u = MN(t, 1);
-                    return a.x = s.x = dN(o, l, nT), a.x2 = s.x2 = dN(o, u), a.y = s.y = hN(o, l, nT), a.y2 = s.y2 = hN(o, u), mT({
-                        type: aT,
-                        role: qF,
+                    const l = rq(t, 0),
+                        u = rq(t, 1);
+                    return a.x = s.x = jU(o, l, Fj), a.x2 = s.x2 = jU(o, u), a.y = s.y = UU(o, l, Fj), a.y2 = s.y2 = UU(o, u), Wj({
+                        type: Rj,
+                        role: gB,
                         from: i,
                         encode: c
                     }, n)
-                }(t, n, i.domain, f)), u.title && h.push(NN(t, n, i.title, f)), tN(lT({
-                    role: UF,
+                }(t, n, i.domain, f)), u.title && h.push(sq(t, n, i.title, f)), CU(Lj({
+                    role: mB,
                     from: f,
-                    encode: PF(RN(c, t), r, eT),
+                    encode: uB(lq(c, t), r, Mj),
                     marks: h,
                     aria: c("aria"),
                     description: c("description"),
                     zindex: c("zindex"),
                     name: o,
                     interactive: a,
                     style: s
                 }), e)
             }
 
-            function RN(t, e) {
+            function lq(t, e) {
                 const n = {
                     enter: {},
                     update: {}
                 };
-                return RF(n, {
+                return lB(n, {
                     orient: t("orient"),
                     offset: t("offset") || 0,
-                    position: MM(e.position, 0),
+                    position: rI(e.position, 0),
                     titlePadding: t("titlePadding"),
                     minExtent: t("minExtent"),
                     maxExtent: t("maxExtent"),
                     range: {
                         signal: 'abs(span(range("'.concat(e.scale, '")))')
                     },
                     translate: t("translate"),
                     format: e.format,
                     formatType: e.formatType
                 }), n
             }
 
-            function PN(t, e, n) {
+            function uq(t, e, n) {
                 const i = (0, m.IX)(t.signals),
                     r = (0, m.IX)(t.scales);
-                return n || i.forEach((t => gM(t, e))), (0, m.IX)(t.projections).forEach((t => function(t, e) {
+                return n || i.forEach((t => HB(t, e))), (0, m.IX)(t.projections).forEach((t => function(t, e) {
                     const n = e.config.projection || {},
                         i = {};
-                    for (const r in t) "name" !== r && (i[r] = OO(t[r], r, e));
-                    for (const r in n) null == i[r] && (i[r] = OO(n[r], r, e));
+                    for (const r in t) "name" !== r && (i[r] = oj(t[r], r, e));
+                    for (const r in n) null == i[r] && (i[r] = oj(n[r], r, e));
                     e.addProjection(t.name, i)
                 }(t, e))), r.forEach((t => function(t, e) {
                     const n = t.type || "linear";
-                    sf(n) || (0, m.vU)("Unrecognized scale type: " + (0, m.m8)(n)), e.addScale(t.name, {
+                    JL(n) || (0, m.vU)("Unrecognized scale type: " + (0, m.m8)(n)), e.addScale(t.name, {
                         type: n,
                         domain: void 0
                     })
-                }(t, e))), (0, m.IX)(t.data).forEach((t => sN(t, e))), r.forEach((t => yO(t, e))), (n || i).forEach((t => function(t, e) {
+                }(t, e))), (0, m.IX)(t.data).forEach((t => zU(t, e))), r.forEach((t => GI(t, e))), (n || i).forEach((t => function(t, e) {
                     const n = e.getSignal(t.name);
                     let i = t.update;
-                    t.init && (i ? (0, m.vU)("Signals can not include both init and update expressions.") : (i = t.init, n.initonly = !0)), i && (i = xC(i, e), n.update = i.$expr, n.params = i.$params), t.on && t.on.forEach((t => BM(t, e, n.id)))
-                }(t, e))), (0, m.IX)(t.axes).forEach((t => zN(t, e))), (0, m.IX)(t.marks).forEach((t => tN(t, e))), (0, m.IX)(t.legends).forEach((t => eN(t, e))), t.title && oN(t.title, e), e.parseLambdas(), e
+                    t.init && (i ? (0, m.vU)("Signals can not include both init and update expressions.") : (i = t.init, n.initonly = !0)), i && (i = xL(i, e), n.update = i.$expr, n.params = i.$params), t.on && t.on.forEach((t => hI(t, e, n.id)))
+                }(t, e))), (0, m.IX)(t.axes).forEach((t => cq(t, e))), (0, m.IX)(t.marks).forEach((t => CU(t, e))), (0, m.IX)(t.legends).forEach((t => MU(t, e))), t.title && NU(t.title, e), e.parseLambdas(), e
             }
-            const LN = t => PF({
+            const fq = t => uB({
                 enter: {
                     x: {
                         value: 0
                     },
                     y: {
                         value: 0
                     }
@@ -41694,92 +45954,92 @@
                     },
                     height: {
                         signal: "height"
                     }
                 }
             }, t);
 
-            function jN(t, e) {
+            function dq(t, e) {
                 const n = e.config,
-                    i = xM(e.root = e.add(bM())),
+                    i = ZB(e.root = e.add(JB())),
                     r = function(t, e) {
-                        const n = n => MM(t[n], e[n]),
-                            i = [BN("background", n("background")), BN("autosize", FF(n("autosize"))), BN("padding", TF(n("padding"))), BN("width", n("width") || 0), BN("height", n("height") || 0)],
+                        const n = n => rI(t[n], e[n]),
+                            i = [hq("background", n("background")), hq("autosize", iB(n("autosize"))), hq("padding", aB(n("padding"))), hq("width", n("width") || 0), hq("height", n("height") || 0)],
                             r = i.reduce(((t, e) => (t[e.name] = e, t)), {}),
                             o = {};
                         return (0, m.IX)(t.signals).forEach((t => {
                             (0, m.nr)(r, t.name) ? t = (0, m.l7)(r[t.name], t): i.push(t), o[t.name] = t
                         })), (0, m.IX)(e.signals).forEach((t => {
                             (0, m.nr)(o, t.name) || (0, m.nr)(r, t.name) || i.push(t)
                         })), i
                     }(t, n);
-                r.forEach((t => gM(t, e))), e.description = t.description || n.description, e.eventConfig = n.events, e.legends = e.objectProperty(n.legend && n.legend.layout), e.locale = n.locale;
-                const o = e.add(XM()),
-                    a = e.add($M(uM(LN(t.encode), rT, BF, t.style, e, {
-                        pulse: xM(o)
+                r.forEach((t => HB(t, e))), e.description = t.description || n.description, e.eventConfig = n.events, e.legends = e.objectProperty(n.legend && n.legend.layout), e.locale = n.locale;
+                const o = e.add(bI()),
+                    a = e.add(wI(BB(fq(t.encode), Tj, hB, t.style, e, {
+                        pulse: ZB(o)
                     }))),
-                    s = e.add(pO({
+                    s = e.add(qI({
                         layout: e.objectProperty(t.layout),
                         legends: e.legends,
                         autosize: e.signalRef("autosize"),
                         mark: i,
-                        pulse: xM(a)
+                        pulse: ZB(a)
                     }));
-                e.operators.pop(), e.pushState(xM(a), xM(s), null), PN(t, e, r), e.operators.push(s);
-                let c = e.add(HM({
+                e.operators.pop(), e.pushState(ZB(a), ZB(s), null), uq(t, e, r), e.operators.push(s);
+                let c = e.add(yI({
                     mark: i,
-                    pulse: xM(s)
+                    pulse: ZB(s)
                 }));
-                return c = e.add(uO({
-                    pulse: xM(c)
-                })), c = e.add(dO({
-                    pulse: xM(c)
-                })), e.addData("root", new ZT(e, o, o, c)), e
+                return c = e.add(BI({
+                    pulse: ZB(c)
+                })), c = e.add(jI({
+                    pulse: ZB(c)
+                })), e.addData("root", new kU(e, o, o, c)), e
             }
 
-            function BN(t, e) {
+            function hq(t, e) {
                 return e && e.signal ? {
                     name: t,
                     update: e.signal
                 } : {
                     name: t,
                     value: e
                 }
             }
 
-            function IN(t, e) {
+            function pq(t, e) {
                 this.config = t || {}, this.options = e || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = []
             }
 
-            function UN(t) {
+            function mq(t) {
                 this.config = t.config, this.options = t.options, this.legends = t.legends, this.field = Object.create(t.field), this.signals = Object.create(t.signals), this.lambdas = Object.create(t.lambdas), this.scales = Object.create(t.scales), this.events = Object.create(t.events), this.data = Object.create(t.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++t._nextsub[0], this._nextsub = t._nextsub, this._parent = t._parent.slice(), this._encode = t._encode.slice(), this._lookup = t._lookup.slice(), this._markpath = t._markpath
             }
 
-            function qN(t) {
-                return ((0, m.kJ)(t) ? WN : HN)(t)
+            function gq(t) {
+                return ((0, m.kJ)(t) ? vq : yq)(t)
             }
 
-            function WN(t) {
+            function vq(t) {
                 const e = t.length;
                 let n = "[";
                 for (let i = 0; i < e; ++i) {
                     const e = t[i];
-                    n += (i > 0 ? "," : "") + ((0, m.Kn)(e) ? e.signal || qN(e) : (0, m.m8)(e))
+                    n += (i > 0 ? "," : "") + ((0, m.Kn)(e) ? e.signal || gq(e) : (0, m.m8)(e))
                 }
                 return n + "]"
             }
 
-            function HN(t) {
+            function yq(t) {
                 let e, n, i = "{",
                     r = 0;
-                for (e in t) n = t[e], i += (++r > 1 ? "," : "") + (0, m.m8)(e) + ":" + ((0, m.Kn)(n) ? n.signal || qN(n) : (0, m.m8)(n));
+                for (e in t) n = t[e], i += (++r > 1 ? "," : "") + (0, m.m8)(e) + ":" + ((0, m.Kn)(n) ? n.signal || gq(n) : (0, m.m8)(n));
                 return i + "}"
             }
 
-            function XN(t, e, n) {
+            function bq(t, e, n) {
                 return (0, m.Kn)(t) || (0, m.vU)("Input Vega specification must be an object."), e = (0, m.fE)(function() {
                     const t = "sans-serif",
                         e = "#4c78a8",
                         n = "#000",
                         i = "#888",
                         r = "#ddd";
                     return {
@@ -41965,22 +46225,22 @@
                             diverging: {
                                 scheme: "blueorange",
                                 extent: [1, 0]
                             },
                             symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
                         }
                     }
-                }(), e, t.config), jN(t, new IN(e, n)).toRuntime()
+                }(), e, t.config), dq(t, new pq(e, n)).toRuntime()
             }
-            IN.prototype = UN.prototype = {
+            pq.prototype = mq.prototype = {
                 parse(t) {
-                    return PN(t, this)
+                    return uq(t, this)
                 },
                 fork() {
-                    return new UN(this)
+                    return new mq(this)
                 },
                 isSubscope() {
                     return this._subid > 0
                 },
                 toRuntime() {
                     return this.finish(), {
                         description: this.description,
@@ -41997,16 +46257,16 @@
                 },
                 add(t) {
                     return this.operators.push(t), t.id = this.id(), t.refs && (t.refs.forEach((e => {
                         e.$ref = t.id
                     })), t.refs = null), t
                 },
                 proxy(t) {
-                    const e = t instanceof vM ? xM(t) : t;
-                    return this.add(cO({
+                    const e = t instanceof XB ? ZB(t) : t;
+                    return this.add(PI({
                         value: e
                     }))
                 },
                 addStream(t) {
                     return this.streams.push(t), t.id = this.id(), t
                 },
                 addUpdate(t) {
@@ -42024,17 +46284,17 @@
                     for (t in this.data) {
                         e = this.data[t], n(e.input, t, "input"), n(e.output, t, "output"), n(e.values, t, "values");
                         for (const i in e.index) n(e.index[i], t, "index:" + i)
                     }
                     return this
                 },
                 pushState(t, e, n) {
-                    this._encode.push(xM(this.add(dO({
+                    this._encode.push(ZB(this.add(jI({
                         pulse: t
-                    })))), this._parent.push(e), this._lookup.push(n ? xM(this.proxy(n)) : null), this._markpath.push(-1)
+                    })))), this._parent.push(e), this._lookup.push(n ? ZB(this.proxy(n)) : null), this._markpath.push(-1)
                 },
                 popState() {
                     this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop()
                 },
                 parent() {
                     return (0, m.fj)(this._parent)
                 },
@@ -42045,59 +46305,59 @@
                     return (0, m.fj)(this._lookup)
                 },
                 markpath() {
                     const t = this._markpath;
                     return ++t[t.length - 1]
                 },
                 fieldRef(t, e) {
-                    if ((0, m.HD)(t)) return _M(t, e);
+                    if ((0, m.HD)(t)) return $B(t, e);
                     t.signal || (0, m.vU)("Unsupported field reference: " + (0, m.m8)(t));
                     const n = t.signal;
                     let i = this.field[n];
                     if (!i) {
                         const t = {
                             name: this.signalRef(n)
                         };
-                        e && (t.as = e), this.field[n] = i = xM(this.add(VM(t)))
+                        e && (t.as = e), this.field[n] = i = ZB(this.add(AI(t)))
                     }
                     return i
                 },
                 compareRef(t) {
                     let e = !1;
-                    const n = t => CM(t) ? (e = !0, this.signalRef(t.signal)) : function(t) {
+                    const n = t => nI(t) ? (e = !0, this.signalRef(t.signal)) : function(t) {
                             return t && t.expr
                         }(t) ? (e = !0, this.exprRef(t.expr)) : t,
                         i = (0, m.IX)(t.field).map(n),
                         r = (0, m.IX)(t.order).map(n);
-                    return e ? xM(this.add(JM({
+                    return e ? ZB(this.add(xI({
                         fields: i,
                         orders: r
-                    }))) : kM(i, r)
+                    }))) : VB(i, r)
                 },
                 keyRef(t, e) {
                     let n = !1;
                     const i = this.signals;
-                    return t = (0, m.IX)(t).map((t => CM(t) ? (n = !0, xM(i[t.signal])) : t)), n ? xM(this.add(KM({
+                    return t = (0, m.IX)(t).map((t => nI(t) ? (n = !0, ZB(i[t.signal])) : t)), n ? ZB(this.add(DI({
                         fields: t,
                         flat: e
                     }))) : function(t, e) {
                         const n = {
                             $key: t
                         };
                         return e && (n.$flat = !0), n
                     }(t, e)
                 },
                 sortRef(t) {
                     if (!t) return t;
-                    const e = DM(t.op, t.field),
+                    const e = QB(t.op, t.field),
                         n = t.order || "ascending";
-                    return n.signal ? xM(this.add(JM({
+                    return n.signal ? ZB(this.add(xI({
                         fields: e,
                         orders: this.signalRef(n.signal)
-                    }))) : kM(e, n)
+                    }))) : VB(e, n)
                 },
                 event(t, e) {
                     const n = t + ":" + e;
                     if (!this.events[n]) {
                         const i = this.id();
                         this.streams.push({
                             id: i,
@@ -42108,63 +46368,63 @@
                     return this.events[n]
                 },
                 hasOwnSignal(t) {
                     return (0, m.nr)(this.signals, t)
                 },
                 addSignal(t, e) {
                     this.hasOwnSignal(t) && (0, m.vU)("Duplicate signal name: " + (0, m.m8)(t));
-                    const n = e instanceof vM ? e : this.add(bM(e));
+                    const n = e instanceof XB ? e : this.add(JB(e));
                     return this.signals[t] = n
                 },
                 getSignal(t) {
                     return this.signals[t] || (0, m.vU)("Unrecognized signal name: " + (0, m.m8)(t)), this.signals[t]
                 },
                 signalRef(t) {
-                    return this.signals[t] ? xM(this.signals[t]) : ((0, m.nr)(this.lambdas, t) || (this.lambdas[t] = this.add(bM(null))), xM(this.lambdas[t]))
+                    return this.signals[t] ? ZB(this.signals[t]) : ((0, m.nr)(this.lambdas, t) || (this.lambdas[t] = this.add(JB(null))), ZB(this.lambdas[t]))
                 },
                 parseLambdas() {
                     const t = Object.keys(this.lambdas);
                     for (let e = 0, n = t.length; e < n; ++e) {
                         const n = t[e],
-                            i = xC(n, this),
+                            i = xL(n, this),
                             r = this.lambdas[n];
                         r.params = i.$params, r.update = i.$expr
                     }
                 },
                 property(t) {
                     return t && t.signal ? this.signalRef(t.signal) : t
                 },
                 objectProperty(t) {
-                    return t && (0, m.Kn)(t) ? this.signalRef(t.signal || qN(t)) : t
+                    return t && (0, m.Kn)(t) ? this.signalRef(t.signal || gq(t)) : t
                 },
                 exprRef(t, e) {
                     const n = {
-                        expr: xC(t, this)
+                        expr: xL(t, this)
                     };
-                    return e && (n.expr.$name = e), xM(this.add(ZM(n)))
+                    return e && (n.expr.$name = e), ZB(this.add(kI(n)))
                 },
                 addBinding(t, e) {
                     this.bindings || (0, m.vU)("Nested signals do not support binding: " + (0, m.m8)(t)), this.bindings.push((0, m.l7)({
                         signal: t
                     }, e))
                 },
                 addScaleProj(t, e) {
                     (0, m.nr)(this.scales, t) && (0, m.vU)("Duplicate scale or projection name: " + (0, m.m8)(t)), this.scales[t] = this.add(e)
                 },
                 addScale(t, e) {
-                    this.addScaleProj(t, fO(e))
+                    this.addScaleProj(t, II(e))
                 },
                 addProjection(t, e) {
-                    this.addScaleProj(t, sO(e))
+                    this.addScaleProj(t, zI(e))
                 },
                 getScale(t) {
                     return this.scales[t] || (0, m.vU)("Unrecognized scale name: " + (0, m.m8)(t)), this.scales[t]
                 },
                 scaleRef(t) {
-                    return xM(this.getScale(t))
+                    return ZB(this.getScale(t))
                 },
                 scaleType(t) {
                     return this.getScale(t).params.type
                 },
                 projectionRef(t) {
                     return this.scaleRef(t)
                 },
@@ -42174,18 +46434,18 @@
                 addData(t, e) {
                     return (0, m.nr)(this.data, t) && (0, m.vU)("Duplicate data set name: " + (0, m.m8)(t)), this.data[t] = e
                 },
                 getData(t) {
                     return this.data[t] || (0, m.vU)("Undefined data set name: " + (0, m.m8)(t)), this.data[t]
                 },
                 addDataPipeline(t, e) {
-                    return (0, m.nr)(this.data, t) && (0, m.vU)("Duplicate data set name: " + (0, m.m8)(t)), this.addData(t, ZT.fromEntries(this, e))
+                    return (0, m.nr)(this.data, t) && (0, m.vU)("Duplicate data set name: " + (0, m.m8)(t)), this.addData(t, kU.fromEntries(this, e))
                 }
             };
-            var JN = "5.25.0";
+            var xq = "5.28.0";
             (0, m.l7)(Pr, i, o, a, s, c, u, l, f, d, h, p)
         },
         76248: t => {
             "use strict";
             var e = /("(?:[^\\"]|\\.)*")|[:,]/g;
             t.exports = function(t, n) {
                 var i, r, o;
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6718.802da17e.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6718.802da17e.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/6853.3cbd385e.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/6853.3cbd385e.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7142.83028745.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7142.83028745.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7175.be4076bc.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7175.be4076bc.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7217.d970c074.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7217.d970c074.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7323.2808d029.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7323.2808d029.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7323.2808d029.chunk.js.LICENSE.txt` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7323.2808d029.chunk.js.LICENSE.txt`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7602.e8abc06b.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7602.e8abc06b.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/7805.51638fbc.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/7805.51638fbc.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8005.43974a35.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8005.43974a35.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8427.65ddaf36.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8427.65ddaf36.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8477.7419a0aa.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8477.7419a0aa.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8492.3e609489.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8492.3e609489.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8536.f13dff49.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8536.f13dff49.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8570.6de19120.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8570.6de19120.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/8691.9ccf7f89.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/8691.9ccf7f89.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9330.2b4c99e0.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9330.2b4c99e0.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9336.2d95d840.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9336.2d95d840.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/937.a1248039.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/937.a1248039.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9656.8c935274.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9656.8c935274.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9758.6e6d8662.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9758.6e6d8662.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/9865.fd93213d.chunk.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/9865.fd93213d.chunk.js`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/main.af77b7ba.js` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/main.3b0201f6.js`

 * *Files 0% similar despite different names*

#### js-beautify {}

```diff
@@ -1,8 +1,8 @@
-/*! For license information please see main.af77b7ba.js.LICENSE.txt */
+/*! For license information please see main.3b0201f6.js.LICENSE.txt */
 (() => {
     var __webpack_modules__ = {
             68785: (e, t, n) => {
                 "use strict";
                 n.d(t, {
                     B: () => i,
                     Id: () => r,
@@ -116114,18 +116114,16 @@
         }
     })(), __webpack_require__.d = (e, t) => {
         for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
             enumerable: !0,
             get: t[n]
         })
     }, __webpack_require__.f = {}, __webpack_require__.e = e => Promise.all(Object.keys(__webpack_require__.f).reduce(((t, n) => (__webpack_require__.f[n](e, t), t)), [])), __webpack_require__.u = e => "static/js/" + e + "." + {
-        43: "c6749504",
         178: "7bea8c5d",
         474: "87506447",
-        656: "7150a933",
         937: "a1248039",
         1074: "73973756",
         1168: "fc5c673b",
         1307: "8ea033f1",
         1451: "3b0a3e31",
         1479: "6709db03",
         1792: "b8efa879",
@@ -116148,24 +116146,26 @@
         4477: "e10e4373",
         4500: "b6f348d1",
         4666: "c4b22a63",
         5106: "44f0ff51",
         5117: "04bfe5d3",
         5345: "65c91ee7",
         5379: "6571574f",
+        5441: "71804c26",
         5791: "9a42fb4b",
         6013: "64cd6d28",
         6150: "427a30f5",
         6405: "ac5a6f23",
         6718: "802da17e",
         6853: "3cbd385e",
         7142: "83028745",
         7175: "be4076bc",
         7217: "d970c074",
         7323: "2808d029",
+        7483: "64f23be7",
         7602: "e8abc06b",
         7805: "51638fbc",
         8005: "43974a35",
         8427: "65ddaf36",
         8477: "7419a0aa",
         8492: "3e609489",
         8536: "f13dff49",
@@ -116173,17 +116173,17 @@
         8691: "9ccf7f89",
         9330: "2b4c99e0",
         9336: "2d95d840",
         9656: "8c935274",
         9758: "6e6d8662",
         9865: "fd93213d"
     } [e] + ".chunk.js", __webpack_require__.miniCssF = e => "static/css/" + e + "." + {
-        43: "e3b876c5",
         3092: "95a45cfe",
-        3466: "8b8f33d6"
+        3466: "8b8f33d6",
+        5441: "e3b876c5"
     } [e] + ".chunk.css", __webpack_require__.g = function() {
         if ("object" === typeof globalThis) return globalThis;
         try {
             return this || new Function("return this")()
         } catch (e) {
             if ("object" === typeof window) return window
         }
@@ -116251,17 +116251,17 @@
                     })(e, o, null, t, n)
                 })),
                 t = {
                     179: 0
                 };
             __webpack_require__.f.miniCss = (n, r) => {
                 t[n] ? r.push(t[n]) : 0 !== t[n] && {
-                    43: 1,
                     3092: 1,
-                    3466: 1
+                    3466: 1,
+                    5441: 1
                 } [n] && r.push(t[n] = e(n).then((() => {
                     t[n] = 0
                 }), (e => {
                     throw delete t[n], e
                 })))
             }
         }
@@ -121213,15 +121213,15 @@
                     }
                 }
             }), ""),
             Pi = n.lazy((() => __webpack_require__.e(9330).then(__webpack_require__.bind(__webpack_require__, 69330)))),
             Di = n.lazy((() => __webpack_require__.e(7217).then(__webpack_require__.bind(__webpack_require__, 62736)))),
             Bi = n.lazy((() => __webpack_require__.e(3301).then(__webpack_require__.bind(__webpack_require__, 69436)))),
             ji = n.lazy((() => Promise.all([__webpack_require__.e(4253), __webpack_require__.e(3092)]).then(__webpack_require__.bind(__webpack_require__, 49839)))),
-            Fi = n.lazy((() => Promise.all([__webpack_require__.e(3061), __webpack_require__.e(656), __webpack_require__.e(43)]).then(__webpack_require__.bind(__webpack_require__, 10043)))),
+            Fi = n.lazy((() => Promise.all([__webpack_require__.e(3061), __webpack_require__.e(7483), __webpack_require__.e(5441)]).then(__webpack_require__.bind(__webpack_require__, 5441)))),
             Ui = n.lazy((() => __webpack_require__.e(8427).then(__webpack_require__.bind(__webpack_require__, 18427)))),
             Vi = Pr(n.lazy((() => __webpack_require__.e(7323).then(__webpack_require__.bind(__webpack_require__, 47323)))), 100),
             Hi = n.lazy((() => Promise.all([__webpack_require__.e(3061), __webpack_require__.e(3466), __webpack_require__.e(8536)]).then(__webpack_require__.bind(__webpack_require__, 72394)))),
             Xi = n.lazy((() => Promise.all([__webpack_require__.e(6150), __webpack_require__.e(7805)]).then(__webpack_require__.bind(__webpack_require__, 32508)))),
             Gi = n.lazy((() => __webpack_require__.e(4500).then(__webpack_require__.bind(__webpack_require__, 54500)))),
             $i = n.lazy((() => __webpack_require__.e(1307).then(__webpack_require__.bind(__webpack_require__, 51307)))),
             Ki = n.lazy((() => __webpack_require__.e(2469).then(__webpack_require__.bind(__webpack_require__, 62469)))),
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/js/main.af77b7ba.js.LICENSE.txt` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/js/main.3b0201f6.js.LICENSE.txt`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_AMS-Regular.73ea273a72f4aca30ca5.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_AMS-Regular.73ea273a72f4aca30ca5.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_AMS-Regular.853be92419a6c3766b9a.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_AMS-Regular.853be92419a6c3766b9a.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_AMS-Regular.d562e886c52f12660a41.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_AMS-Regular.d562e886c52f12660a41.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Bold.7489a2fbfb9bfe704420.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Bold.7489a2fbfb9bfe704420.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Bold.a1abf90dfd72792a577a.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Bold.a1abf90dfd72792a577a.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Bold.d757c535a2e5902f1325.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Bold.d757c535a2e5902f1325.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Regular.7e873d3833eb108a0758.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Regular.7e873d3833eb108a0758.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Regular.d6484fce1ef428d5bd94.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Regular.d6484fce1ef428d5bd94.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Caligraphic-Regular.db074fa22cf224af93d7.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Caligraphic-Regular.db074fa22cf224af93d7.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Bold.354501bac435c3264834.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Bold.354501bac435c3264834.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Bold.4c761b3711973ab04edf.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Bold.4c761b3711973ab04edf.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Bold.931d67ea207ab37ee693.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Bold.931d67ea207ab37ee693.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Regular.172d3529b26f8cedef6b.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Regular.172d3529b26f8cedef6b.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Regular.6fdf0ac577be0ba82a4c.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Regular.6fdf0ac577be0ba82a4c.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Fraktur-Regular.ed305b5434865e06ffde.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Fraktur-Regular.ed305b5434865e06ffde.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Bold.0c3b8929d377c0e9b2f3.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Bold.0c3b8929d377c0e9b2f3.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Bold.39890742bc957b368704.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Bold.39890742bc957b368704.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Bold.8169508bf58f8bd92ad8.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Bold.8169508bf58f8bd92ad8.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-BoldItalic.20f389c4120be058d80a.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-BoldItalic.20f389c4120be058d80a.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-BoldItalic.428978dc7837d46de091.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-BoldItalic.428978dc7837d46de091.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-BoldItalic.828abcb200061cffbaae.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-BoldItalic.828abcb200061cffbaae.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Italic.fa675e5e4bec9eb250b6.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Italic.fa675e5e4bec9eb250b6.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Italic.fd947498bc16392e76c2.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Italic.fd947498bc16392e76c2.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Italic.fe2176f79edaa716e621.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Italic.fe2176f79edaa716e621.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Regular.4f35fbcc9ee8614c2bcc.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Regular.4f35fbcc9ee8614c2bcc.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Regular.9eba1d77abcf2aa6e94e.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Regular.9eba1d77abcf2aa6e94e.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Main-Regular.f650f111a3b890d116f1.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Main-Regular.f650f111a3b890d116f1.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-BoldItalic.3f07ed67f06c720120ce.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-BoldItalic.3f07ed67f06c720120ce.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-BoldItalic.bf2d440b3a42ea78a998.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-BoldItalic.bf2d440b3a42ea78a998.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-BoldItalic.dcbcbd93bac0470b462d.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-BoldItalic.dcbcbd93bac0470b462d.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-Italic.6d3d25f4820d0da8f01f.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-Italic.6d3d25f4820d0da8f01f.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-Italic.8a5f936332e8028c7278.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-Italic.8a5f936332e8028c7278.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Math-Italic.96759856b4e70f3a8338.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Math-Italic.96759856b4e70f3a8338.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Bold.5b49f4993ae22d7975b4.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Bold.5b49f4993ae22d7975b4.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Bold.95591a929f0d32aa282a.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Bold.95591a929f0d32aa282a.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Bold.b9cd458ac6d5889ff9c3.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Bold.b9cd458ac6d5889ff9c3.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Italic.7d393d382f3e7fb1c637.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Italic.7d393d382f3e7fb1c637.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Italic.8d593cfaa96238d5e2f8.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Italic.8d593cfaa96238d5e2f8.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Italic.b257a18c016f37ee4543.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Italic.b257a18c016f37ee4543.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Regular.02271ec5cb9f5b4588ac.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Regular.02271ec5cb9f5b4588ac.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Regular.2f7bc363fc5424ebda59.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Regular.2f7bc363fc5424ebda59.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_SansSerif-Regular.cd5e231e0cc53b2cb2c0.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_SansSerif-Regular.cd5e231e0cc53b2cb2c0.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Script-Regular.073b3402d036714b4370.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Script-Regular.073b3402d036714b4370.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Script-Regular.c81d1b2a4b75d3eded60.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Script-Regular.c81d1b2a4b75d3eded60.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Script-Regular.fc9ba5249878cd8f8d88.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Script-Regular.fc9ba5249878cd8f8d88.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size1-Regular.0108e89c9003e8c14ea3.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size1-Regular.0108e89c9003e8c14ea3.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size1-Regular.6de7d4b539221a49e9e2.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size1-Regular.6de7d4b539221a49e9e2.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size1-Regular.6eec866c69313624be60.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size1-Regular.6eec866c69313624be60.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size2-Regular.2960900c4f271311eb36.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size2-Regular.2960900c4f271311eb36.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size2-Regular.3a99e70aee4076660d38.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size2-Regular.3a99e70aee4076660d38.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size2-Regular.57f5c1837853986ea1db.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size2-Regular.57f5c1837853986ea1db.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size3-Regular.7947224e8a9914fa332b.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size3-Regular.7947224e8a9914fa332b.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size3-Regular.8d6b6822586eea3d3b20.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size3-Regular.8d6b6822586eea3d3b20.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size3-Regular.e1951519f6f0596f7356.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size3-Regular.e1951519f6f0596f7356.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size4-Regular.4ad7c7e8bb8d10a34bb7.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size4-Regular.4ad7c7e8bb8d10a34bb7.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size4-Regular.aeffd8025cba3647f1a6.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size4-Regular.aeffd8025cba3647f1a6.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Size4-Regular.e418bf257af1052628d8.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Size4-Regular.e418bf257af1052628d8.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Typewriter-Regular.4c6b94fd1d07f8beff7c.woff` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Typewriter-Regular.4c6b94fd1d07f8beff7c.woff`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Typewriter-Regular.c295e7f71970f03c0549.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Typewriter-Regular.c295e7f71970f03c0549.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/KaTeX_Typewriter-Regular.c5c02d763c89380dcb4e.ttf` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/KaTeX_Typewriter-Regular.c5c02d763c89380dcb4e.ttf`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/MaterialSymbols-Outlined.909d2dce4aba724ad02f.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/MaterialSymbols-Outlined.909d2dce4aba724ad02f.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-Bold.17a68a0751a813474a0e.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-Bold.17a68a0751a813474a0e.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-BoldItalic.d45b7a3df103d441d78b.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-BoldItalic.d45b7a3df103d441d78b.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-Italic.ec122a420df4175e74f2.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-Italic.ec122a420df4175e74f2.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-Regular.84b900b88d09398d86b0.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-Regular.84b900b88d09398d86b0.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-SemiBold.17291d1c493cb25eb2c3.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-SemiBold.17291d1c493cb25eb2c3.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceCodePro-SemiBoldItalic.f879ae27307c3926522b.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceCodePro-SemiBoldItalic.f879ae27307c3926522b.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-Bold.118dea98980e20a81ced.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-Bold.118dea98980e20a81ced.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-BoldItalic.1d664be59d2eb5fef029.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-BoldItalic.1d664be59d2eb5fef029.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-Italic.8a9bfea74d43927d6eec.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-Italic.8a9bfea74d43927d6eec.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-Regular.0d69e5ff5e92ac64a0c9.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-Regular.0d69e5ff5e92ac64a0c9.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-SemiBold.abed79cd0df1827e18cf.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-SemiBold.abed79cd0df1827e18cf.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSansPro-SemiBoldItalic.befb0a2824eabc5ce36b.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSansPro-SemiBoldItalic.befb0a2824eabc5ce36b.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-Bold.d7975b56594770699ae0.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-Bold.d7975b56594770699ae0.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-BoldItalic.913697a7178b128caa4c.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-BoldItalic.913697a7178b128caa4c.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-Italic.d3529cb5797663ac5d88.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-Italic.d3529cb5797663ac5d88.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-Regular.e6c37aa3926474cc93e1.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-Regular.e6c37aa3926474cc93e1.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-SemiBold.5c1d378dd5990ef334ca.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-SemiBold.5c1d378dd5990ef334ca.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/SourceSerifPro-SemiBoldItalic.249e948b885d0c7d30a8.woff2` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/SourceSerifPro-SemiBoldItalic.249e948b885d0c7d30a8.woff2`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/fireworks.0906f02ea43f1018a6d2.gif` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/fireworks.0906f02ea43f1018a6d2.gif`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/flake-0.beded754e8024c73d9d2.png` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/flake-0.beded754e8024c73d9d2.png`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/flake-1.8077dc154e0bf900aa73.png` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/flake-1.8077dc154e0bf900aa73.png`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/flake-2.e3f07d06933dd0e84c24.png` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/flake-2.e3f07d06933dd0e84c24.png`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/logo.83ae4f2fb87e38be7cbb8a5d2beb64d2.svg` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/logo.83ae4f2fb87e38be7cbb8a5d2beb64d2.svg`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/static/static/media/rocket.b75b17d2b0a063c6cea230d1a9d77f1e.svg` & `streamlit_nightly-1.34.1.dev20240503/streamlit/static/static/media/rocket.b75b17d2b0a063c6cea230d1a9d77f1e.svg`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/string_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/string_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/temporary_directory.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/temporary_directory.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/testing/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/testing/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -8,10 +8,19 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from streamlit.testing.v1.app_test import AppTest
+from streamlit.web.server.component_request_handler import ComponentRequestHandler
+from streamlit.web.server.routes import allow_cross_origin_requests
+from streamlit.web.server.server import Server, server_address_is_unix_socket
+from streamlit.web.server.stats_request_handler import StatsRequestHandler
 
-__all__ = ["AppTest"]
+__all__ = [
+    "ComponentRequestHandler",
+    "allow_cross_origin_requests",
+    "Server",
+    "server_address_is_unix_socket",
+    "StatsRequestHandler",
+]
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/app_test.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/app_test.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/element_tree.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/element_tree.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/local_script_runner.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/local_script_runner.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/testing/v1/util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/testing/v1/util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/time_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/time_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/type_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/type_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/url_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/url_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/user_info.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/user_info.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/ipython/modified_sys_path.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/ipython/modified_sys_path.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/vendor/pympler/asizeof.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/vendor/pympler/asizeof.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/version.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/version.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/event_based_path_watcher.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/event_based_path_watcher.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/local_sources_watcher.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/local_sources_watcher.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/path_watcher.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/path_watcher.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/polling_path_watcher.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/polling_path_watcher.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/watcher/util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/watcher/util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/__init__.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/__init__.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/bootstrap.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/bootstrap.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/cache_storage_manager_config.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/cache_storage_manager_config.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/cli.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/cli.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/app_static_file_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/app_static_file_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/browser_websocket_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/browser_websocket_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/component_request_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/component_request_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/media_file_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/media_file_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/routes.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/routes.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/server.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/server.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/server_util.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/server_util.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/stats_request_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/stats_request_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/upload_file_request_handler.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/upload_file_request_handler.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit/web/server/websocket_headers.py` & `streamlit_nightly-1.34.1.dev20240503/streamlit/web/server/websocket_headers.py`

 * *Files identical despite different names*

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/PKG-INFO` & `streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: streamlit-nightly
-Version: 1.34.1.dev20240502
+Version: 1.34.1.dev20240503
 Summary: A faster way to build and share data apps
 Home-page: https://streamlit.io
 Author: Snowflake Inc
 Author-email: hello@streamlit.io
 License: Apache License 2.0
 Project-URL: Source Code, https://github.com/streamlit/streamlit
 Project-URL: Bug Tracker, https://github.com/streamlit/streamlit/issues
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/streamlit_nightly.egg-info/SOURCES.txt` & `streamlit_nightly-1.34.1.dev20240503/streamlit_nightly.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -58,18 +58,15 @@
 streamlit/connections/base_connection.py
 streamlit/connections/snowflake_connection.py
 streamlit/connections/snowpark_connection.py
 streamlit/connections/sql_connection.py
 streamlit/connections/util.py
 streamlit/elements/__init__.py
 streamlit/elements/alert.py
-streamlit/elements/altair_utils.py
 streamlit/elements/arrow.py
-streamlit/elements/arrow_altair.py
-streamlit/elements/arrow_vega_lite.py
 streamlit/elements/balloons.py
 streamlit/elements/bokeh_chart.py
 streamlit/elements/code.py
 streamlit/elements/deck_gl_json_chart.py
 streamlit/elements/dialog_decorator.py
 streamlit/elements/doc_string.py
 streamlit/elements/empty.py
@@ -90,16 +87,18 @@
 streamlit/elements/progress.py
 streamlit/elements/pyplot.py
 streamlit/elements/snow.py
 streamlit/elements/spinner.py
 streamlit/elements/text.py
 streamlit/elements/toast.py
 streamlit/elements/utils.py
+streamlit/elements/vega_charts.py
 streamlit/elements/write.py
 streamlit/elements/lib/__init__.py
+streamlit/elements/lib/built_in_chart_utils.py
 streamlit/elements/lib/column_config_utils.py
 streamlit/elements/lib/column_types.py
 streamlit/elements/lib/dialog.py
 streamlit/elements/lib/dicttools.py
 streamlit/elements/lib/event_utils.py
 streamlit/elements/lib/mutable_status_container.py
 streamlit/elements/lib/pandas_styler_utils.py
@@ -333,15 +332,15 @@
 streamlit/runtime/state/session_state_proxy.py
 streamlit/runtime/state/widgets.py
 streamlit/static/asset-manifest.json
 streamlit/static/favicon.png
 streamlit/static/index.html
 streamlit/static/static/css/3092.95a45cfe.chunk.css
 streamlit/static/static/css/3466.8b8f33d6.chunk.css
-streamlit/static/static/css/43.e3b876c5.chunk.css
+streamlit/static/static/css/5441.e3b876c5.chunk.css
 streamlit/static/static/css/main.3aaaea00.css
 streamlit/static/static/js/1074.73973756.chunk.js
 streamlit/static/static/js/1168.fc5c673b.chunk.js
 streamlit/static/static/js/1307.8ea033f1.chunk.js
 streamlit/static/static/js/1451.3b0a3e31.chunk.js
 streamlit/static/static/js/1479.6709db03.chunk.js
 streamlit/static/static/js/178.7bea8c5d.chunk.js
@@ -361,37 +360,37 @@
 streamlit/static/static/js/3631.be5c35fa.chunk.js
 streamlit/static/static/js/4113.1e7eff4d.chunk.js
 streamlit/static/static/js/4132.49bf3f2c.chunk.js
 streamlit/static/static/js/4132.49bf3f2c.chunk.js.LICENSE.txt
 streamlit/static/static/js/4177.69f9f18d.chunk.js
 streamlit/static/static/js/4253.749d5244.chunk.js
 streamlit/static/static/js/4253.749d5244.chunk.js.LICENSE.txt
-streamlit/static/static/js/43.c6749504.chunk.js
 streamlit/static/static/js/4319.bf1c86bf.chunk.js
 streamlit/static/static/js/4477.e10e4373.chunk.js
 streamlit/static/static/js/4500.b6f348d1.chunk.js
 streamlit/static/static/js/4666.c4b22a63.chunk.js
 streamlit/static/static/js/474.87506447.chunk.js
 streamlit/static/static/js/5106.44f0ff51.chunk.js
 streamlit/static/static/js/5117.04bfe5d3.chunk.js
 streamlit/static/static/js/5345.65c91ee7.chunk.js
 streamlit/static/static/js/5379.6571574f.chunk.js
+streamlit/static/static/js/5441.71804c26.chunk.js
 streamlit/static/static/js/5791.9a42fb4b.chunk.js
 streamlit/static/static/js/6013.64cd6d28.chunk.js
 streamlit/static/static/js/6150.427a30f5.chunk.js
 streamlit/static/static/js/6405.ac5a6f23.chunk.js
-streamlit/static/static/js/656.7150a933.chunk.js
-streamlit/static/static/js/656.7150a933.chunk.js.LICENSE.txt
 streamlit/static/static/js/6718.802da17e.chunk.js
 streamlit/static/static/js/6853.3cbd385e.chunk.js
 streamlit/static/static/js/7142.83028745.chunk.js
 streamlit/static/static/js/7175.be4076bc.chunk.js
 streamlit/static/static/js/7217.d970c074.chunk.js
 streamlit/static/static/js/7323.2808d029.chunk.js
 streamlit/static/static/js/7323.2808d029.chunk.js.LICENSE.txt
+streamlit/static/static/js/7483.64f23be7.chunk.js
+streamlit/static/static/js/7483.64f23be7.chunk.js.LICENSE.txt
 streamlit/static/static/js/7602.e8abc06b.chunk.js
 streamlit/static/static/js/7805.51638fbc.chunk.js
 streamlit/static/static/js/8005.43974a35.chunk.js
 streamlit/static/static/js/8427.65ddaf36.chunk.js
 streamlit/static/static/js/8477.7419a0aa.chunk.js
 streamlit/static/static/js/8492.3e609489.chunk.js
 streamlit/static/static/js/8536.f13dff49.chunk.js
@@ -400,16 +399,16 @@
 streamlit/static/static/js/9330.2b4c99e0.chunk.js
 streamlit/static/static/js/9336.2d95d840.chunk.js
 streamlit/static/static/js/937.a1248039.chunk.js
 streamlit/static/static/js/937.a1248039.chunk.js.LICENSE.txt
 streamlit/static/static/js/9656.8c935274.chunk.js
 streamlit/static/static/js/9758.6e6d8662.chunk.js
 streamlit/static/static/js/9865.fd93213d.chunk.js
-streamlit/static/static/js/main.af77b7ba.js
-streamlit/static/static/js/main.af77b7ba.js.LICENSE.txt
+streamlit/static/static/js/main.3b0201f6.js
+streamlit/static/static/js/main.3b0201f6.js.LICENSE.txt
 streamlit/static/static/media/KaTeX_AMS-Regular.73ea273a72f4aca30ca5.woff2
 streamlit/static/static/media/KaTeX_AMS-Regular.853be92419a6c3766b9a.ttf
 streamlit/static/static/media/KaTeX_AMS-Regular.d562e886c52f12660a41.woff
 streamlit/static/static/media/KaTeX_Caligraphic-Bold.7489a2fbfb9bfe704420.ttf
 streamlit/static/static/media/KaTeX_Caligraphic-Bold.a1abf90dfd72792a577a.woff2
 streamlit/static/static/media/KaTeX_Caligraphic-Bold.d757c535a2e5902f1325.woff
 streamlit/static/static/media/KaTeX_Caligraphic-Regular.7e873d3833eb108a0758.ttf
```

### Comparing `streamlit_nightly-1.34.1.dev20240502/tests/testutil.py` & `streamlit_nightly-1.34.1.dev20240503/tests/testutil.py`

 * *Files identical despite different names*

